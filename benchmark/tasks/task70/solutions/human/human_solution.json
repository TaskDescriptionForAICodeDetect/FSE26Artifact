[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable.ListBuffer\n\nobject Main {\n\n  // _.+\n  // syntax(x)(y) = result\n  type OperationSyntax = Int => Int => Int\n\n  sealed trait Calculation {\n    val calculations: Seq[Calculation]\n\n    protected val functor: OperationSyntax\n\n    def calclate(after: Calculation): Calculation = Number(after.functor(value)(after.value))\n\n    def value: Int = {\n      val xxx = calculations.reduce[Calculation](_ calclate _).value\n      xxx\n    }\n\n    def blocking(after: Calculation): Calculation\n  }\n\n  case class Number(_value: Int) extends Calculation {\n    override def value: Int = _value\n\n    val calculations: Seq[Calculation] = Nil\n\n    val functor: OperationSyntax = x => _ => x\n\n    def blocking(after: Calculation): Calculation = CalculationBlock(this, after)\n  }\n\n  case class Plus(calculations: Calculation*) extends Calculation {\n    val functor: OperationSyntax = _.+\n\n    def blocking(after: Calculation): Calculation = Plus(calculations.:+(after): _*)\n  }\n\n  case class Minus(calculations: Calculation*) extends Calculation {\n    val functor: OperationSyntax = _.-\n\n    def blocking(after: Calculation): Calculation = Minus(calculations.:+(after): _*)\n  }\n\n  case class Multiply(calculations: Calculation*) extends Calculation {\n    val functor: OperationSyntax = _.*\n\n    def blocking(after: Calculation): Calculation = Multiply(calculations.:+(after): _*)\n  }\n\n  case class Devide(calculations: Calculation*) extends Calculation {\n    val functor: OperationSyntax = _./\n\n    def blocking(after: Calculation): Calculation = Devide(calculations.:+(after): _*)\n  }\n\n  case class CalculationBlock(calculations: Calculation*) extends Calculation {\n    val functor: OperationSyntax = x => _ => x\n\n    def blocking(after: Calculation): Calculation = CalculationBlock(this, after)\n  }\n\n  def main(args: Array[String]): Unit = {\n\n    val limit: Int = io.StdIn.readLine().toInt\n    val buffer: ListBuffer[String] = ListBuffer.empty\n    (1 to limit).map { _ =>\n      buffer += io.StdIn.readLine()\n    }\n    buffer.map(Tokenizer.tokenize).map(_.value).foreach(println)\n  }\n\n  val operationLiterals = Vector(\"+\", \"-\", \"*\", \"/\", \"(\", \")\")\n\n  def operationLiteralMatcher(syntax: String): String = \"(?<=\\\\%s)|(?=\\\\%s)\".format(syntax, syntax)\n\n  object Tokenizer {\n\n    trait TypedConstruction[T <: Calculation] {\n      val construction: Seq[Calculation] => T\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation]\n    }\n\n    implicit object NumberValueConstruction extends TypedConstruction[Number] {\n      val construction: Seq[Calculation] => Number = x => Number.apply(x.reduce[Calculation]((a, b) => a.calclate(b)).value)\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation] = _ :+ _\n    }\n\n    implicit object PlusValueConstruction extends TypedConstruction[Plus] {\n      val construction: Seq[Calculation] => Plus = Plus.apply\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation] = _ :+ Plus(_)\n    }\n\n    implicit object MinusValueConstruction extends TypedConstruction[Minus] {\n      val construction: Seq[Calculation] => Minus = Minus.apply\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation] = _ :+ Minus(_)\n    }\n\n    implicit object MultiplyValueConstruction extends TypedConstruction[Multiply] {\n      val construction: Seq[Calculation] => Multiply = Multiply.apply\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation] = (e, n) => e.init :+ e.last.blocking(Multiply(n))\n    }\n\n    implicit object DevideValueConstruction extends TypedConstruction[Devide] {\n      val construction: Seq[Calculation] => Devide = Devide.apply\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation] = (e, n) => e.init :+ e.last.blocking(Devide(n))\n    }\n\n    implicit object BlockValueConstruction extends TypedConstruction[CalculationBlock] {\n      val construction: Seq[Calculation] => CalculationBlock = CalculationBlock.apply\n      val joinConstruction: (Seq[Calculation], Calculation) => Seq[Calculation] = _ :+ _\n    }\n\n    def tokenize(v: String): Calculation = {\n      inlineExpansion[Number](\n        v.replaceAll(\"=\", \"\").split(s\"(${operationLiterals.map(operationLiteralMatcher).mkString(\"|\")})\")\n      )._2\n    }\n\n    def inlineExpansion[T <: Calculation : TypedConstruction](v: Seq[String],\n                                                              buffer: Seq[Calculation] = Nil): (Seq[String], Calculation) = {\n      v.headOption match {\n        case None => Nil -> CalculationBlock(buffer: _*)\n        case Some(head) => head match {\n          case x if x.matches(\"\\\\d+\") => inlineExpansion[Number](v.tail, implicitly[TypedConstruction[T]].joinConstruction(buffer, Number(x.toInt)))\n          case \"+\" => inlineExpansion[Plus](v.tail, buffer)\n          case \"-\" => inlineExpansion[Minus](v.tail, buffer)\n          case \"*\" => inlineExpansion[Multiply](v.tail, buffer)\n          case \"/\" => inlineExpansion[Devide](v.tail, buffer)\n          case \"(\" => block[T](v.tail) match {\n            case (tail, r) =>\n              inlineExpansion[Number](tail, implicitly[TypedConstruction[T]].joinConstruction(buffer, r))\n          }\n          case \")\" => v.tail -> CalculationBlock(buffer: _*)\n        }\n      }\n\n    }\n\n    def block[T <: Calculation : TypedConstruction](v: Seq[String]): (Seq[String], Calculation) = {\n      inlineExpansion[Number](v) match {\n        case (a, b) => a -> implicitly[TypedConstruction[T]].construction(b.calculations)\n      }\n    }\n  }\n\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App{\n  import scala.io.StdIn.{readLine}\n  type Rest = List[Char]\n  type CharMatch = Option[(Char, Rest)]\n  type StringMatch = Option[(List[Char], Rest)]\n  type CalculateResult = Option[(Int, Rest)]\n  type Operator = Option[(Int ⇒ Int ⇒ Int, Rest)]\n  object Digit{\n    def unapply(char: List[Char]):CharMatch = {\n      char match{\n        case h::t if h.isDigit ⇒ Some((h, t))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Number{\n    def unapply(string:List[Char]): StringMatch = {\n      string match{\n        case Digit(digit, Number(succ, rest)) ⇒ Some((digit :: succ, rest))\n        case Digit(digit, rest) ⇒ Some((digit::Nil, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Parenthesis{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match{\n        case '('::Expression(expression, ')'::rest) ⇒ Some((expression, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Term{\n    def unapply(string:List[Char]):CalculateResult ={\n      string match{\n        case Number(number, rest) ⇒ Some((number.mkString.toInt, rest))\n        case Parenthesis(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '*'::rest ⇒ Some((a ⇒ b ⇒ a * b, rest))\n        case '/'::rest ⇒ Some((a ⇒ b ⇒ a / b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object NoPriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '+'::rest ⇒ Some((a ⇒ b ⇒ a + b, rest))\n        case '-'::rest ⇒ Some((a ⇒ b ⇒ a - b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityTerm{\n    def unapply(string:List[Char]):CalculateResult = {\n      string match{\n        case Term(left, PriorityOperator(op, Term(right, rest))) ⇒ Some((op(left)(right), rest))\n        case Term(term, rest) ⇒ Some(term, rest)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Expression{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match {\n        case PriorityTerm(left, NoPriorityOperator(op, Expression(right, rest))) ⇒ Some((op(left)(right), rest))\n        case PriorityTerm(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ ???\n      }\n    }\n  }\n  for (_ ← 0 until readLine().toInt){\n    println (readLine().toList match{\n      case Expression(result, '='::Nil) ⇒ result\n      case _ ⇒ ???\n    })\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App{\n  import scala.io.StdIn.{readLine}\n  type Rest = List[Char]\n  type CharMatch = Option[(Char, Rest)]\n  type StringMatch = Option[(List[Char], Rest)]\n  type CalculateResult = Option[(Int, Rest)]\n  type Operator = Option[(Int ⇒ Int ⇒ Int, Rest)]\n  object Digit{\n    def unapply(char: List[Char]):CharMatch = {\n      char match{\n        case h::t if h.isDigit ⇒ Some((h, t))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Number{\n    def unapply(string:List[Char]): StringMatch = {\n      string match{\n        case Digit(digit, Number(succ, rest)) ⇒ Some((digit :: succ, rest))\n        case Digit(digit, rest) ⇒ Some((digit::Nil, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Parenthesis{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match{\n        case '('::Expression(expression, ')'::rest) ⇒ Some((expression, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Term{\n    def unapply(string:List[Char]):CalculateResult ={\n      string match{\n        case Number(number, rest) ⇒ Some((number.mkString.toInt, rest))\n        case Parenthesis(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '*'::rest ⇒ Some((a ⇒ b ⇒ a * b, rest))\n        case '/'::rest ⇒ Some((a ⇒ b ⇒ a / b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object NoPriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '+'::rest ⇒ Some((a ⇒ b ⇒ a + b, rest))\n        case '-'::rest ⇒ Some((a ⇒ b ⇒ a - b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityTerm{\n    def unapply(string:List[Char]):CalculateResult = {\n      string match{\n        case Term(left, PriorityOperator(op, Term(right, rest))) ⇒ Some((op(left)(right), rest))\n        case Term(term, rest) ⇒ Some(term, rest)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Expression{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match {\n        case PriorityTerm(left, NoPriorityOperator(op, Expression(right, rest))) ⇒ Some((op(left)(right), rest))\n        case PriorityTerm(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ Some(0, '='::Nil)\n      }\n    }\n  }\n  for (_ ← 0 until readLine().toInt){\n    println (readLine().trim.toList match{\n      case Expression(result, '='::Nil) ⇒ result\n      case _ ⇒ 0\n    })\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App{\n  import scala.io.StdIn.{readLine}\n  type Rest = List[Char]\n  type CharMatch = Option[(Char, Rest)]\n  type StringMatch = Option[(List[Char], Rest)]\n  type CalculateResult = Option[(Int, Rest)]\n  type Operator = Option[(Int ⇒ Int ⇒ Int, Rest)]\n  object Digit{\n    def unapply(char: List[Char]):CharMatch = {\n      char match{\n        case h::t if h.isDigit ⇒ Some((h, t))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Number{\n    def unapply(string:List[Char]): StringMatch = {\n      string match{\n        case Digit(digit, Number(succ, rest)) ⇒ Some((digit :: succ, rest))\n        case Digit(digit, rest) ⇒ Some((digit::Nil, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Parenthesis{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match{\n        case '('::Expression(expression, ')'::rest) ⇒ Some((expression, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Term{\n    def unapply(string:List[Char]):CalculateResult ={\n      string match{\n        case Number(number, rest) ⇒ Some((number.mkString.toInt, rest))\n        case Parenthesis(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '*'::rest ⇒ Some((a ⇒ b ⇒ a * b, rest))\n        case '/'::rest ⇒ Some((a ⇒ b ⇒ a / b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object NoPriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '+'::rest ⇒ Some((a ⇒ b ⇒ a + b, rest))\n        case '-'::rest ⇒ Some((a ⇒ b ⇒ a - b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityTerm{\n    def unapply(string:List[Char]):CalculateResult = {\n      string match{\n        case Term(left, PriorityOperator(op, Term(right, rest))) ⇒ Some((op(left)(right), rest))\n        case Term(term, rest) ⇒ Some(term, rest)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Expression{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match {\n        case PriorityTerm(left, NoPriorityOperator(op, Expression(right, rest))) ⇒ Some((op(left)(right), rest))\n        case PriorityTerm(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ ???\n      }\n    }\n  }\n  for (_ ← 0 until readLine().toInt){\n    println (readLine().trim.toList match{\n      case Expression(result, '='::Nil) ⇒ result\n      case _ ⇒ ???\n    })\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "\nobject Main extends App{\n  import scala.io.StdIn.{readLine}\n  type Operator = Option[((Int, Int) ⇒ Int, List[Char])]\n  type CharParseResult = Option[(Char, List[Char])]\n  type ParseResult = Option[(List[Char], List[Char])]\n  type CalResult = Option[(Int, List[Char])]\n  type CalMidResult = Option[(Int ⇒ Int, List[Char])]\n  for (_ ← 0 until readLine().toInt){\n    println(readLine().toList match {\n      case value AsExpression '='::Nil ⇒ value\n      case _ ⇒ ???\n    })\n  }\n  object AsDigit{\n    def unapply(arg: List[Char]):CharParseResult = arg match{\n      case h::t if h.isDigit ⇒ Some(h, t)\n      case _ ⇒ None\n    }\n  }\n  object AsNumber{\n    def unapply(arg: List[Char]):ParseResult = arg match{\n      case digit AsDigit (number AsNumber rest) ⇒ Some(digit::number, rest)\n      case digit AsDigit rest ⇒ Some(digit::Nil, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsParenthesis{\n    def unapply(arg: List[Char]): CalResult = arg match{\n      case '(':: (result AsExpression ')':: rest)⇒ Some(result, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsTerm{\n    def unapply(arg: List[Char]):CalResult = arg match{\n      case number AsNumber rest ⇒ Some(number.mkString.toInt, rest)\n      case value AsParenthesis rest ⇒ Some(value, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsHighPriorityOperator{\n    def unapply(arg: List[Char]):Operator = arg match{\n      case '*'::rest ⇒ Some(_ * _ , rest)\n      case '/'::rest ⇒ Some(_ / _, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsLowPriorityOperator{\n    def unapply(arg: List[Char]):Operator = arg match{\n      case '+'::rest ⇒ Some(_ + _, rest)\n      case '-'::rest ⇒ Some(_ - _, rest)\n      case _ ⇒ None\n    }\n  }\n  implicit class BinomialOperator(val operator:(Int, Int) ⇒ Int){\n    def <|(num:Int):Int ⇒ Int = operator(_, num)\n  }\n  implicit class MonomialOperator(val number:Int){\n    def |>(op:Int ⇒ Int):Int = op(number)\n  }\n  object AsHighPriorityOperation{\n    def unapply(arg: List[Char]):CalMidResult = arg match{\n      case op AsHighPriorityOperator (term AsTerm (converter AsHighPriorityOperation rest)) ⇒ Some(op <| term andThen converter, rest)\n      case op AsHighPriorityOperator (term AsTerm rest) ⇒ Some(op <| term, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsHighPriorityPartial{\n    def unapply(arg: List[Char]):CalResult = arg match{\n      case term AsTerm (converter AsHighPriorityOperation rest) ⇒ Some(term |> converter, rest)\n      case term AsTerm rest ⇒ Some(term, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsLowPriorityOperation{\n    def unapply(arg: List[Char]):CalMidResult = arg match{\n      case op AsLowPriorityOperator (partial AsHighPriorityPartial (converter AsLowPriorityOperation rest)) ⇒ Some(op <| partial andThen converter, rest)\n      case op AsLowPriorityOperator (partial AsHighPriorityPartial rest) ⇒ Some(op <| partial, rest)\n      case _ ⇒ None\n    }\n  }\n  object AsExpression{\n    def unapply(arg: List[Char]): CalResult = arg match{\n      case left AsHighPriorityPartial (right AsLowPriorityOperation rest) ⇒ Some(left |> right, rest)\n      case value AsHighPriorityPartial rest ⇒ Some(value, rest)\n      case _ ⇒ None\n    }\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App{\n  import scala.io.StdIn.{readLine}\n  type Rest = List[Char]\n  type CharMatch = Option[(Char, Rest)]\n  type StringMatch = Option[(List[Char], Rest)]\n  type CalculateResult = Option[(Int, Rest)]\n  type Operator = Option[(Int ⇒ Int ⇒ Int, Rest)]\n  object Digit{\n    def unapply(char: List[Char]):CharMatch = {\n      char match{\n        case h::t if h.isDigit ⇒ Some((h, t))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Number{\n    def unapply(string:List[Char]): StringMatch = {\n      string match{\n        case Digit(digit, Number(succ, rest)) ⇒ Some((digit :: succ, rest))\n        case Digit(digit, rest) ⇒ Some((digit::Nil, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Parenthesis{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match{\n        case '('::Expression(expression, ')'::rest) ⇒ Some((expression, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Term{\n    def unapply(string:List[Char]):CalculateResult ={\n      string match{\n        case Number(number, rest) ⇒ Some((number.mkString.toInt, rest))\n        case Parenthesis(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '*'::rest ⇒ Some((a ⇒ b ⇒ a * b, rest))\n        case '/'::rest ⇒ Some((a ⇒ b ⇒ a / b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object NoPriorityOperator{\n    def unapply(string:List[Char]):Operator = {\n      string match{\n        case '+'::rest ⇒ Some((a ⇒ b ⇒ a + b, rest))\n        case '-'::rest ⇒ Some((a ⇒ b ⇒ a - b, rest))\n        case _ ⇒ None\n      }\n    }\n  }\n  object PriorityTerm{\n    def unapply(string:List[Char]):CalculateResult = {\n      string match{\n        case Term(left, PriorityOperator(op, Term(right, rest))) ⇒ Some((op(left)(right), rest))\n        case Term(term, rest) ⇒ Some(term, rest)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Expression{\n    def unapply(string:List[Char]): CalculateResult = {\n      string match {\n        case PriorityTerm(left, NoPriorityOperator(op, Expression(right, rest))) ⇒ Some((op(left)(right), rest))\n        case PriorityTerm(result, rest) ⇒ Some((result, rest))\n        case _ ⇒ Some(0, '='::Nil)\n      }\n    }\n  }\n  for (_ ← 0 until readLine().toInt){\n    println (readLine().trim.toList match{\n      case Expression(result, '='::Nil) ⇒ result\n      case _ ⇒ ???\n    })\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit() {\n\tint n;\n\tassert(isdigit(S[cur]));\n\tn = S[cur] -'0';\n\t++cur;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur])) {\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor() {\n\tint n;\n\tif (S[cur] != '(') n = number();\n\telse {\n\t\t++cur;\n\t\tn = expression();\n\t\tassert(S[cur] == ')');\n\t}\n\treturn n;\n}\n\nint term() {\n\tint t = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*') t *= b; else t = (int)trunc(1.0*t/b);\n\t}\n\treturn t;\n}\n\n\n/*int expression() {\n\tint sum = number();\n\twhile (S[cur] == '+' || S[cur] == '-') {\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif(op == +) sum += b;\telse return sum -= b;\n\t}\n\treturn sum;\n}*/\n\nint expression() {\n\tint sum = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+') sum += b; else sum -= b;\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N; ++i) {\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\nusing namespace std;\nchar str[200];\npair<int,int>ad(int a);\npair<int,int>mul(int a);\npair<int,int>fact(int a);\npair<int,int>ad(int a){\n\tpair<int,int> res=mul(a);\n\twhile(str[res.second]=='+'||str[res.second]=='-'){\n\t\tpair<int,int>v=mul(res.second+1);\n\t\tif(str[res.second]=='+')res.first+=v.first;\n\t\telse res.first-=v.first;\n\t\tres.second=v.second;\n\t}\n\treturn res;\n}\npair<int,int>mul(int a){\n\tpair<int,int> res=fact(a);\n\twhile(str[res.second]=='*'||str[res.second]=='/'){\n\t\tpair<int,int>v=fact(res.second+1);\n\t\tif(str[res.second]=='*')res.first*=v.first;\n\t\telse res.first/=v.first;\n\t\tres.second=v.second;\n\t}\n\treturn res;\n}\npair<int,int>fact(int a){\n\tif(str[a]=='('){\n\t\tpair<int,int> res=ad(a+1);\n\t\tres.second++;\n\t\treturn res;\n\t}else{\n\t\tint val=0;\n\t\twhile(isdigit(str[a])){\n\t\t\tval=val*10+str[a++]-'0';\n\t\t}\n\t\treturn make_pair(val,a);\n\t}\n}\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tscanf(\"%s\",str);\n\t\tprintf(\"%d\\n\",ad(0).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint calc(string s)\n{\n\tvi v;\n\tREP(i, s.size())\n\t{\n\t\tif (s[i] == '+') v.push_back(0);\n\t\telse if (s[i] == '-') v.push_back(1);\n\t\telse if (s[i] == '*') v.push_back(2);\n\t\telse if (s[i] == '/') v.push_back(3);\n\t\telse\n\t\t{\n\t\t\tint tmp = s[i] - '0';\n\t\t\tint t = i+1;\n\t\t\twhile (isdigit(s[t]))\n\t\t\t{\n\t\t\t\ttmp = tmp * 10 + s[t] - '0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\ti = t - 1;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t}\n\n\twhile (v.size() > 1)\n\t{\n\t\tfor (int i = 1; i < v.size();i+=2)\n\t\t{\n\t\t\tif (v[i]==2)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] * v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (v[i] == 3)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] / v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < v.size(); i += 2)\n\t\t{\n\t\t\tif (v[i] == 0)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] + v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (v[i] == 1)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] - v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tnext:;\n\t\t}\n\t}\n\treturn v[0];\n}\n\nint solve(string s)\n{\n\twhile (1)\n\t{\n\t\tif (find(ALL(s), '(') == s.end())\n\t\t{\n\t\t\treturn calc(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring tmp;\n\t\t\tREP(i, s.size())\n\t\t\t{\n\t\t\t\tif (s[i] != '(') tmp.push_back(s[i]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = s.size()-1;; j--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[j] == ')')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t = solve(s.substr(i+1, j - i - 1));\n\t\t\t\t\t\t\ttmp += to_string(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn solve(tmp);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint sets;\n\tstring s;\n\tcin >> sets;\n\tREP(set, sets)\n\t{\n\t\tcin >> s;\n\t\ts.erase(s.size() - 1);\n\t\tcout << solve(s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1 && !is_all_digit(in[0])) {\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nusing namespace std;\n\nint main() {\n\tchar c[100],*st;\n\tint n,f,ca1,ca2,d;\n\tstack<int> as;\n\tstack<char> bs;\n\tcin >> n;\n\tfor (n;n>0;n--) {\n\tcin >> c; st=c;\n\twhile(true) {\n\t\tif (st[0]=='=') break;\n\t\tf=0; d=0;\n\t\tif (st[0]=='-') if (st==c) d=1; else if ((st-1)[0]=='(') d=1;\n\t\tif ((st[0]>='0' && st[0]<='9') || d==1) {\n\t\t\tas.push(atoi(st)); f=1; st++;\n\t\t    for (st;st[0]>='0' && st[0]<='9';st++);\t}\n\t\telse { if (st[0]==')') { bs.pop(); f=1;} else bs.push(st[0]); st++;}\n\t\tif (bs.empty() || f==0) continue;\n\t\twhile(true){\n\t\t\tif (bs.empty()) break; else if (bs.top()=='(') break;\n            if (bs.top()=='*' || bs.top()=='/') {\n\t\t\t\tca2=as.top(); as.pop(); ca1=as.top(); as.pop(); \n\t\t\t\tif (bs.top()=='*') ca1=ca1*ca2; else ca1=ca1/ca2;\n\t\t\t\tas.push(ca1); bs.pop();\t}\n\t\t\telse if (st[0]!='*' && st[0]!='/') {\n                ca2=as.top(); as.pop(); ca1=as.top(); as.pop(); \n\t\t\t\tif (bs.top()=='+') ca1=ca1+ca2; else ca1=ca1-ca2;\n\t\t\t\tas.push(ca1); bs.pop(); } else break;\n\t\t}\n\t}\n\t\tcout << as.top() << endl;\n\t\tas.pop();\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\nint main(){\n    int n;\n    string s;\n    while(cin>>n){\n        for(int i=0; i<n; i++){\n            cin>>s;\n            int j=0;\n            \n            queue<string> qu;\n            stack<string> st;\n            \n            \n            while(j<s.length()){\n                //cout<<s[j]<<endl;\n                //数値の処理\n                if(s[j]>='0'&&s[j]<='9'){\n                    string s_temp;\n                    \n                    while(s[j]>='0'&&s[j]<='9'){\n                        s_temp+=s[j];\n                        j++;\n                    }\n                    \n                    qu.push(s_temp);\n                    \n                }\n                \n                //括弧の処理\n                else if(s[j]==')'){\n                    while(1){\n                        string s_temp;\n                        s_temp = st.top();\n                        st.pop();\n                        if(s_temp==\"(\"){\n                            break;\n                        }else{\n                            qu.push(s_temp);\n                        }\n                    }\n                    j++;\n                }\n                \n                else if(s[j]=='('){\n                    string s_temp;\n                    s_temp+=s[j];\n                    st.push(s_temp);\n                    j++;\n                }\n                \n                //演算子の処理\n                else if(s[j]=='-'||s[j]=='+'||s[j]=='*'||s[j]=='/'){\n                    string s_temp;\n                    s_temp+=s[j];\n                    if(st.empty()){\n                        st.push(s_temp);\n                        j++;\n                    }else{\n                        if(!(s_temp==\"*\"||s_temp==\"/\")&&(st.top()==\"-\"||(st.top()==\"+\"))){\n                            s_temp = st.top();\n                            st.pop();\n                            qu.push(s_temp);\n                        }else{\n                            st.push(s_temp);\n                            j++;\n                        }\n                    }\n                }\n                //=の処理\n                else if(s[j]=='='){\n                    j++;\n                }\n                \n                \n            }\n            while(!st.empty()){\n                qu.push((st.top()));\n                st.pop();\n            }\n            \n            stack<int> num;\n            while(!qu.empty()){\n                \n                //cout<<qu.front()<<endl;\n                \n                if(qu.front()==\"*\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a*b;\n                    num.push(a);\n                }else if(qu.front()==\"/\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a/b;\n                    num.push(a);\n                    \n                }else if(qu.front()==\"-\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b-a;\n                    num.push(a);\n                }else if(qu.front()==\"+\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a+b;\n                    num.push(a);\n                }else{\n                    stringstream stream;\n                    stream<<qu.front();\n                    int temp;\n                    stream>>temp;\n                    num.push(temp);\n                }\n                qu.pop();\n            }\n            cout<<num.top()<<endl;\n        }\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring get_term(string, int&);\nint get_num(string);\nint get_exp(string);\n\nint get_num(string str) {\n    int num = 0;\n\n    if (str.size() == 0) return 0;\n\n    int i = 0;\n    if (str[i] == '(') {\n        i++;\n        string exp;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n            if (count) exp += str[i];\n        }\n\n        num = get_exp(exp + \"=\");\n    } else {\n        for (; i < str.size() && '0' <= str[i] && str[i] < '9'; i++) {\n            num = num * 10 + (str[i] - '0');\n        }\n    }\n\n    for (; i < str.size(); i++) {\n        if (str[i] == '*') {\n            i++;\n            int tmp = 0;\n            for (; i < str.size() && '0' <= str[i] && str[i] < '9'; i++) {\n                tmp = tmp * 10 + (str[i] - '0');\n            }\n            num *= tmp;\n            i--;\n        } else {\n            i++;\n            int tmp = 0;\n            for (; i < str.size() && '0' <= str[i] && str[i] < '9'; i++) {\n                tmp = tmp * 10 + (str[i] - '0');\n            }\n            num /= tmp;\n            i--;\n        }\n    }\n\n    return num;\n}\n\n\nvoid solve(string str) {\n    cout << get_exp(str) << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    while (N--) {\n        string str;\n        cin >> str;\n        solve(str);\n    }\n\n    return 0;\n}\n\nstring get_term(string str, int& i) {\n    string init_str;\n    for (int count = 0; i < str.size(); i++) {\n        if (str[i] == '(') count++;\n        if (count > 0 || ('0' <= str[i] && str[i] <= '9') || str[i] == '/' || str[i] == '*') {\n            init_str += str[i];\n        }\n        if (str[i] == ')') count--;\n\n        if (count == 0 && (str[i] == '+'|| str[i] == '-' || str[i] == '=')) {\n            break;\n        }\n    }\n\n    return init_str;\n}\n\nint get_exp(string str) {\n    int num  = 0;\n    int i = 0;\n\n    string init_str = get_term(str, i);\n    num = get_num(init_str);\n\n    while (str[i] != '=') {\n        if (str[i] == '-') {\n            i++;\n            string term = get_term(str, i);\n            num -= get_num(term);\n        } else if (str[i] == '+') {\n            i++;\n            string term = get_term(str, i);\n            num += get_num(term);\n        }\n    }\n\n    return num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_int.hpp>\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\n\ntypedef string::const_iterator State;\nll siso(State &begin);\nll jou(State &begin);\nll kak(State &begin);\nll num(State &begin);\n\nll num(State &begin){\n    ll ret=0;\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin-'0';\n        begin++;\n    }\n    return ret;\n}\nll kak(State &begin){\n    if(*begin=='('){\n        begin++;\n        ll ret=siso(begin);\n        begin++;\n        return ret;\n    }else{\n        return num(begin);\n    }\n}\nll jou(State &begin){\n    ll ret=kak(begin);\n    while(1){\n        if(*begin=='*'){\n            begin++;\n            ret*=kak(begin);\n        }else if(*begin=='/'){\n            begin++;\n            ret/=kak(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nll siso(State &begin){\n    ll ret=jou(begin);\n    while(1){\n        if(*begin=='+'){\n            begin++;\n            ret+=jou(begin);\n        }else if(*begin=='-'){\n            begin++;\n            ret-=jou(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){fastio\n    //freopen(\"Input.txt\",\"r\",stdin);freopen(\"Output.txt\",\"w\",stdout);\n    \n    ll n;cin>>n;cin.ignore();\n    while(n--){\n        string s;\n        getline(cin,s);\n        State b=s.begin();\n        cout<<siso(b)<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint number(State&);\nint term(State&);\nint expression(State&);\nint factor(State&);\n\nint number(State& begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    ++begin;\n  }\n  return ret;\n}\n\nint term(State& begin){\n  int ret = factor(begin);\n  for(;;){\n    if(*begin == '*'){\n      ++begin;\n      ret*=factor(begin);\n    }\n    else if(*begin == '/'){\n      ++begin;\n      ret/=factor(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return ret;\n}\n\n\nint factor(State& begin){\n  int ret;\n  if(*begin == '('){\n    ++begin;\n    ret = expression(begin);\n    ++begin;\n  }\n  else ret = number(begin);\n  return ret;\n}\n\nint expression(State& begin){\n  int ret = term(begin);\n  for(;;){\n    if(*begin == '+'){\n      ++begin;\n      ret+=term(begin);\n    }\n    else if(*begin == '-'){\n      ++begin;\n      ret-=term(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  cin.ignore();\n  while(n--){\n    string s;\n    getline(cin,s);\n    State b = s.begin();\n    int ans = expression(b);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\t/*const*/ string s;\n\tstack<int> num;\n\tstack<int> mar;\n\tint n1, n2;\n\tcin >> s;\n\tfor ( int i = 0; i < 100; i++ ) {\n\t\tif ( s.substr( i, 1 ) == \"+\" ) {\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t\tmar.push(0);\n\t\t} else if ( s.substr( i, 1 ) == \"-\" ) {\n\t\t\tmar.push(1);\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t} else if ( s.substr( i, 1 ) == \"*\" ) mar.push(2);\n\t\telse if ( s.substr( i, 1 ) == \"/\" ) mar.push(3);\n\t\telse if ( s.substr( i, 1 ) == \"(\" ) mar.push(4);\n\t\telse if ( s.substr( i, 1 ) == \")\" ) {\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t\t\tmar.pop();\n\t\t} else if ( s.substr( i, 1 ) == \"=\" ) {\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t\tcout << num.top();\n\t\t\tbreak;\n\t\t} else {\n\t\t\tn2 = atoi( s.c_str() );\n\t\t\tif ( mar.top() == 2 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 * n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 3 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 / n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else \n\t\t\t\tnum.push( n2 );\n\t\t}\n\t}\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint Num();\nint Fact();\nint Term();\nint Exp();\n\nint ite;\nstring s;\n\nint Num() {\n\tint res = 0;\n\twhile (isdigit(s[ite])) {\n\t\tres = res * 10 + s[ite] - '0';\n\t\tite++;\n\t}\n\treturn res;\n}\n\nint Fact() {\n\tif (s[ite] == '(') {\n\t\tite++;\n\t\tint res = Exp();\n\t\tite++;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn Num();\n\t}\n}\n\nint Term() {\n\tint res = Fact();\n\twhile (true) {\n\t\tif (s[ite] == '*') {\n\t\t\tite++;\n\t\t\tres *= Fact();\n\t\t}\n\t\telse if (s[ite] == '/') {\n\t\t\tite++;\n\t\t\tres /= Fact();\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint Exp() {\n\tint res = Term();\n\twhile (s[ite] != '=' && s[ite] != ')') {\n\t\tif (s[ite] == '+') {\n\t\t\tite++;\n\t\t\tres += Term();\n\t\t}\n\t\telse if(s[ite] == '-') {\n\t\t\tite++;\n\t\t\tres -= Term();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> s;\n\t\tite = 0;\n\t\tcout << Exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] > order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tif(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\n\tif(op.size()>=2){\n\t\tchar op1,op2;\n\t\top1=op.top();op.pop();op2=op.top();\n\t\top.push(op1);\n\t\tif(order[op1]<order[op2])\n\t\t\tcalc();\n\t}\n\t//cout << num.top() << endl;//\n\t//int tmp1=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//int tmp2=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp2);\n\t//num.push(tmp1);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF (1<<26)\nusing namespace std;\nint n;\n\n\n\nint compute(int a,int b,string str){\n\n  int i=a,sum=0,tmp=INF,tmp2=INF,cnt=0;\n  while(1){ //cout<<a<<' '<<b<<endl;\n    \n    sum=0;\n    if(str[i]=='('){\n      sum=compute(i+1,0,str);\n      //cout<<sum<<endl;\n      cnt=0;\n      for(i=i;i<(int)str.size();i++){\n\tif(str[i]==')')cnt--;\n\tif(str[i]=='(')cnt++;\n\tif(cnt==0)break;\n      }\n      i++;\n      \n    }else{\n      while(1){\n\tif('0'<=str[i]&&str[i]<='9'){\n\t  sum*=10;\n\t  sum+=(str[i]-'0');\n\t  i++;\n\t}else{\n\t  break;\n\t}\n      }\n    }\n\n    if(b==1){\n      sum*=-1;\n      b=0;\n    }\n    if(tmp!=INF){\n      sum*=tmp;\n      tmp=INF;\n    }\n    if(tmp2!=INF){\n      sum=tmp2/sum;\n      tmp2=INF;\n    }\n    //if(a==8)cout<<sum<<endl;    \n    if(str[i]=='\\0'||str[i]==')'||str[i]=='='||i==(int)str.size())return sum;\n    if(str[i]=='+')return sum + compute(i+1,0,str);\n    if(str[i]=='-')return sum + compute(i+1,1,str);\n    if(str[i]=='*'){\n      i++;\n      tmp=sum;\n    }else if(str[i]=='/'){\n      i++;\n      tmp2=sum;\n    }\n  }\n      \n}\n\n\nint main(){\n  string str;\n  cin>>n;\n  while(n--){\n    cin>>str;\n\n    //cout<<str<<endl;\n    cout<<compute(0,0,str)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\npair<int64_t,int> expr(const string &s, int i);\n\npair<int64_t,int> num(const string &s, int i) {\n  int64_t v = 0;\n  while(i < s.size() && ('0' <= s[i] && s[i] <= '9')) {\n    v *= 10;\n    v += s[i] - '0';\n    ++i;\n  }\n  return make_pair(v, i);\n}\n\npair<int64_t,int> factor(const string &s, int i) {\n  if (s[i] == '(') {\n    auto p = expr(s, i+1);\n    ++p.second;\n    return p;\n  } else {\n    return num(s, i);\n  }\n}\npair<int64_t,int> term(const string &s, int i) {\n  int64_t val;\n  tie(val, i) = factor(s, i);\n  while(i < s.size() && (s[i] == '*' || s[i] == '/')) {\n    int64_t val2;\n    int j;\n    tie(val2, j) = factor(s, i+1);\n    if (s[i] == '*') val *= val2;\n    else val /= val2;\n    i = j;\n  }\n  return make_pair(val, i);\n}\n\npair<int64_t,int> expr(const string &s, int i) {\n  int64_t val;\n  tie(val, i) = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    int64_t val2;\n    int j;\n    tie(val2, j) = term(s, i+1);\n    if (s[i] == '+') val += val2;\n    else val -= val2;\n    i = j;\n  }\n  return make_pair(val, i);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  REP(ds,n) {\n    string s;\n    cin>>s;\n    cout << expr(s, 0).first << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\n// ??§????????°\nstring S;\nsize_t cur = 0; // ?§£???????§???????\n\n// ?¬??????°??????????????¢??°\nint digit(){\n    assert(isdigit(S[cur]));\n    int n = S[cur] - '0'; // ASCII?????????????????¨?????????'0'???0?????????\n    cur = cur + 1;\n    return n;\n}\n\n// ??°???????????¨????????¨???????????°?????????????????¢??°\nint number(){\n    int n = digit(); // ?????????digit\n    while(cur < S.size() && isdigit(S[cur])){ // ?????????????????????????¬??????°??????\n        n = n*10 + digit();\n    }\n    return n;\n}\n\nint expression(); // ????????£?¨?\n\n// ()???????????°????????????????????¨???????¨????????????¢??°\nint factor(){\n    if(S[cur] != '('){\n        return number();\n    }\n    cur += 1;\n    int n = expression();\n    assert(S[cur] == ')');\n    cur += 1;\n    return n;\n}\n\n// 0?????\\?????????????????????????????????????????¨??????????¨????????????¢??°\nint term(){\n    int a = factor();\n    while(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){ // ?¬????number???????????¨???????¨????????????????????????????cur++???????????????????????????????????¨????????§??????\n        char op = S[cur++]; // cur???????????§??????+1?????????\n        int b = factor();\n        if(op == '*'){\n            a *= b;\n        } else {\n            a /= b;\n        }\n    }\n    return a;\n}\n\n// 0?????\\???????¶?????????????????????????????????¨??????????¨????????????¢??°\nint expression(){\n    int a = term();\n    while(cur < S.size() && (S[cur] == '+' || S[cur] == '-')){ // ?¬????term???????????¨???????¨????????????????????????????cur++???????????????????????????????????¨????????§??????\n        char op = S[cur++];\n        int b = term();\n        if(op == '+'){\n            a += b;\n        } else {\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint parse(){\n    return expression();\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i=0; i<N; ++i){\n        cur = 0;\n        cin >> S;\n        S.resize(S.size()-1); // ?????????=?????????\n\n        int a = parse();\n        assert(cur == S.size());\n\n        cout << a << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint exp(string&, int&);\nint term(string&, int&);\nint factor(string&, int&);\n\nint exp(string& str, int& p){\n  int res = term(str, p);\n  while(str[p] == '+' || str[p] == '-'){\n    if(str[p] == '+'){\n      p++;\n      res += term(str, p);\n    }else{\n      p++;\n      res -= term(str, p);\n    }\n  }\n  return res;\n}\n\nint term(string& str, int& p){\n  int res = factor(str, p);\n  while(str[p] == '*' || str[p] == '/'){\n    if(str[p] == '*'){\n      p++;\n      res *= factor(str, p);\n    }else{\n      p++;\n      res /= factor(str, p);\n    }\n  }\n  return res;\n}\n\nint factor(string& str, int& p){\n  int res = 0;\n  int keta = 1;\n  if(str[p] == '('){\n    while(str[p] != ')'){\n      p++;\n      res += exp(str, p);\n    }\n  }else{\n    while(isdigit(str[p])){\n      res += str[p] * keta - '0';\n      p++; keta *= 10;\n    }\n  }\n  return res;\n}\n\n\nint main(void){\n  int n; cin >> n;\n  while(n--){\n    int p=0;\n    string str;\n    cin >> str;\n    cout << exp(str, p) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef string::const_iterator State;\n\nint ctoi(const char &c)\n{\n\treturn c - '0';\n}\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint expression(State &itr)\n{\n\tint ret=term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret + term(itr);\n\t\t}\n\t\telse if (*itr == '-')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret - term(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint term(State &itr)\n{\n\tint ret=factor(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '*')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret*factor(itr);\n\t\t}\n\t\telse if (*itr == '/')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret / factor(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor(State &itr)\n{\n\tint ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = number(itr);\n\t}\n\n\treturn ret;\n}\n\nint number(State &itr)\n{\n\tint ret = 0;\n\n\twhile (isdigit(*itr))\n\t{\n\t\tret *= 10;\n\t\tret += ctoi(*itr);\n\t\titr++;\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tREP(i, n)\n\t{\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tState begin = str.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n  //   #define int long long\n            #define mod  1000000009\n            #define pa pair<int,int>\n            #define ll long long\n            #define pal pair<double,int>\n            #define ppa pair<int,pa>\n            #define ssa pair<string,int>\n            #define  mp make_pair\n            #define  pb push_back\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     //priority_queue<int, vector<int>, greater<int> > que;\n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \nstring itos( int i ) {\nostringstream s ;\ns << i ;\nreturn s.str() ;\n}\n\nint gcd(int v,int b){\n\tif(v>b) return gcd(b,v);\n\tif(v==b) return b;\n\tif(b%v==0) return v;\n\treturn gcd(v,b%v);\n}\n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \ndouble distans(double x1,double y1,double x2,double y2){\n\tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n\treturn sqrt(rr);\n\t\n}\n            //----------------kokomade tenpure------------\nstring s;\nint kakko(string &t ,int &b);\n\nint suuji(string &t, int &b){\n\tint r=0;\n\tif(isdigit(t[b])){\n\twhile(isdigit(t[b])){\n\t\tr *=10;\n\t\tr += t[b]-'0';\n\t\t(b)++;\n\t}\n\t}\n\telse if(t[b]=='('){\n\t\n\t\tr=kakko(t,b);\n\t\t\n\t}\n\t\n\treturn r;\n}\n\n\nint kake(string &t, int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=suuji(t,b);\n\t\n\t\twhile((t[b]=='*')||(t[b]=='*')){\n\t\t\tb++;\n\t\t\tif(t[b-1]=='*')i *= suuji(t,b);\n\t\t\telse i /= suuji(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint tashi(string &t ,int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=kake(t,b);\n\t\twhile((t[b]=='+')||(t[b]=='-')){\n\t\tb++;\n\t\t\tif(t[b-1]=='+')\ti += kake(t,b);\n\t\t\telse i -= kake(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint kakko(string &t ,int &b){\n\t\n\tif(t[b]=='('){\n\t\tint y;\n\t\tb++;\n\t\ty=kakko(t,b);\n\t\tb++;\n\t\treturn y;\n\t}\n\telse{\n\t\treturn tashi(t,b);\n\t}\n}\n    signed  main(){\n    \tint n;\n    \tcin>>n;\n    \tfor(int g=0;g<n;g++){\ncin>>s;\n    \tint i=0;\n    \tcout<<tashi(s,i)<<endl;\n    \t}\n    \n  //  \tprintf(\"%.10f\\n\",ans[n-1]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\n\t\t\t\tif(line[k] == '+' || line[k] == '-' || line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// <expr>   ::= <term> [ ('+'|'-') <term> ]*\n// <term>   ::= <factor> [ ('*'|'/') <factor> ]*\n// <factor> ::= <number> | '(' <expr> ')'\n// <number> :== ???????????°\n\nint expr(int& pos);\nint term(int& pos);\nint factor(int& pos);\nint number(int& pos);\n\nstring s;\n\nint expr(int& pos){\n    int res = term(pos);\n    while(s[pos] == '+' || s[pos] == '-'){\n        if(s[pos] == '+'){\n            res += term(++pos);\n        }else{\n            res -= term(++pos);\n        }\n    }\n    return res;\n}\n\nint term(int& pos){\n    int res = factor(pos);\n    while(s[pos] == '*' || s[pos] == '/'){\n        if(s[pos] == '*'){\n            res *= factor(++pos);\n        }else{\n            res /= factor(++pos);\n        }\n    }\n    return res;\n}\n\nint factor(int& pos){\n    if(isdigit(s[pos])) return number(pos);\n    pos++;  //'('?????¨??°???\n    int res = expr(pos);\n    pos++;  //')'?????¨??°???\n    return res;\n}\n\nint number(int& pos){\n    string res;\n    while(isdigit(s[pos])){\n        res.pb(s[pos++]);\n    }\n    return stoi(res);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> s;\n        int pos = 0;\n        cout << expr(pos) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint calc(string s)\n{\n\tvi v;\n\tREP(i, s.size())\n\t{\n\t\tif (s[i] == '+') v.push_back(0);\n\t\telse if (s[i] == '-') v.push_back(1);\n\t\telse if (s[i] == '*') v.push_back(2);\n\t\telse if (s[i] == '/') v.push_back(3);\n\t\telse\n\t\t{\n\t\t\tint tmp = s[i] - '0';\n\t\t\tint t = i+1;\n\t\t\twhile (isdigit(s[t]))\n\t\t\t{\n\t\t\t\ttmp = tmp * 10 + s[t] - '0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\ti = t - 1;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t}\n\n\twhile (v.size() > 1)\n\t{\n\t\tfor (int i = 1; i < v.size();i+=2)\n\t\t{\n\t\t\tif (v[i]==2)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] * v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\telse if (v[i] == 3)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] / v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < v.size(); i += 2)\n\t\t{\n\t\t\tif (v[i] == 0)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] + v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (v[i] == 1)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] - v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tnext:;\n\t\t}\n\t}\n\treturn v[0];\n}\n\nint solve(string s)\n{\n\twhile (1)\n\t{\n\t\tif (find(ALL(s), '(') == s.end())\n\t\t{\n\t\t\treturn calc(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring tmp;\n\t\t\tREP(i, s.size())\n\t\t\t{\n\t\t\t\tif (s[i] != '(') tmp.push_back(s[i]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = s.size()-1;; j--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[j] == ')')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t = solve(s.substr(i+1, j - i - 1));\n\t\t\t\t\t\t\ttmp += to_string(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn solve(tmp);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint sets;\n\tstring s;\n\tcin >> sets;\n\tREP(set, sets)\n\t{\n\t\tcin >> s;\n\t\ts.erase(s.size() - 1);\n\t\tcout << solve(s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n\nchar buf[128];\nint pos;\n#define NOW (buf[pos])\n\nbool isdigit(char c) {\n\treturn ('0' <= c && c <= '9');\n}\n\nint digit() {\n\tif ( !isdigit(NOW) ) {\n\t\tfprintf(stderr, \"%c: \", NOW);\n\t\tassert( isdigit(NOW) );\n\t}\n\tint ret = NOW - '0';\n\tpos++;\n\t\n\treturn ret;\n}\nint number() {\n\tint ret = digit();\n\twhile( isdigit(NOW) ) {\n\t\tret = ret*10 + digit();\n\t}\n\treturn ret;\n}\n\nint expression();\nint factor() {\n\tif ( NOW=='(' ) {\n\t\tpos++;\n\t\tint ret = expression();\n\t\tassert(NOW==')');\n\t\tpos++;\n\t\t\n\t\treturn ret;\n\t}\n\t\n\treturn number();\n}\n\nint term() {\n\tint ret = factor();\n\twhile ( NOW=='*' || NOW=='/' ) {\n\t\tchar oper = NOW;\n\t\tpos++;\n\t\tint right = factor();\n\t\tif ( oper == '*' ) {\n\t\t\tret *= right;\n\t\t} else {\n\t\t\tret /= right;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint expression() {\n\tint ret = term();\n\twhile ( NOW=='+' || NOW=='-' ) {\n\t\tchar oper = NOW;\n\t\tpos++;\n\t\tint right = term();\n\t\tif ( oper == '+' ) {\n\t\t\tret += right;\n\t\t} else {\n\t\t\tret -= right;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n\nint main(void) {\n\n\tint set;\n\tscanf(\"%d\", &set);\n\t\n\twhile(set--) {\n\t\tscanf(\"%s\", buf);\n\t\tpos = 0;\n\t\tprintf(\"%d\\n\", expression());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <char> VC;\n\nstring toNums( string s ) {\n    string R = \"+-*/\";\n    for ( int i = 0; i < 4; ++ i ) {\n        replace( s.begin(), s.end(), R[i], ' ' );\n    }\n    return s;\n}\n\nstring toOps( string s ) {\n    string R = \"0123456789\";\n    for ( int i = 0; i < 10; ++ i ) {\n        replace( s.begin(), s.end(), R[i], ' ' );\n    }\n    return s;\n}\n\nint eval( string expr ) {\n    stack <int> S;\n    for ( int i = 0; i < (int)expr.size(); ++ i ) {\n        if ( expr[i] == '(' ) {\n            S.push( i );\n        } else if ( expr[i] == ')' ) {\n            int left = S.top();\n            int right = i;\n            string L = expr.substr( 0, left );\n            string M = expr.substr( left, right - left + 1 );\n            string R = expr.substr( right + 1 );\n            ostringstream os;\n            os << eval( M.substr( 1, M.size()-2 ) );\n            expr = L + os.str() + R;\n            i = -1;\n            S = stack <int>();\n            continue;\n        }\n    }\n    string nums = toNums( expr );\n    string ops = toOps( expr );\n    VI N;\n    int num;\n    istringstream is1( nums );\n    while ( is1 >> num ) {\n        N.push_back( num );\n    }\n    VC O;\n    char op;\n    istringstream is2( ops );\n    while ( is2 >> op ) {\n        O.push_back( op );\n    }\n    for ( int i = 0; i + 1 < (int)N.size(); ++ i ) {\n        int a = N[i], b = N[i+1];\n        char c = O[i];\n        if ( c == '*' ) {\n            N.erase( N.begin() + i );\n            char cc = O[i+1];\n            O.erase( O.begin() + i );\n            N[i] = a * b;\n            O[i] = cc;\n            i --;\n        } else if ( c == '/' ) {\n            N.erase( N.begin() + i );\n            char cc = O[i+1];\n            O.erase( O.begin() + i );\n            N[i] = a / b;\n            O[i] = cc;\n            i --;\n        }\n    }\n    int answer = 0;\n    if ( N.size() == O.size() ) {\n        for ( int i = 0; i < (int)N.size(); ++ i ) {\n            if ( O[i] == '+' ) {\n                answer += N[i];\n            } else {\n                answer -= N[i];\n            }\n        }\n    } else {\n        answer = N[0];\n        for ( int i = 0; i + 1 < (int)N.size(); ++ i ) {\n            if ( O[i] == '+' ) {\n                answer += N[i+1];\n            } else {\n                answer -= N[i+1];\n            }\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        if ( n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            string line;\n            cin >> line;\n            cout << eval( line.substr( 0, line.size() - 1 ) ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\nusing ll = long long;\n\nstring str;\nint id;\nint expr();\nint number(){\n  int res = 0;\n  for (; isdigit(str[id]); id++) {\n    res *= 10;\n    res += str[id] - '0';\n  }\n  return res;\n}\nint factor(){\n  int res = 0;\n  if(str[id] == '('){\n    id++;\n    res = expr();\n    if(str[id] == ')') ++id;\n    return res;\n  }else {\n  return number();\n}\n\n}\nint term(){\n  int res = factor();\n  while(str[id] == '*' || str[id] == '/') {\n    if (str[id] =='*') {\n      ++id;\n      res *= factor();\n    } else {\n      ++id;\n      res /= factor();\n    }\n  } \n  return res;\n}\nint expr(){\n  int res = term();\n  while (str[id] == '+' || str[id] == '-') {\n    if(str[id] == '+'){\n      ++id;\n      res += term();\n    } else{\n      ++id;\n      res -= term();\n    }\n  }\n  return res;\n}\nint main(){\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    id = 0;\n    cin >> str;\n    int ans = expr();\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%s\", s);\n    s[strlen(s)-1] = '\\0'; //????°????=?????????\n\n    l = str2arr(s, A);\n    t = Generate_RPN(l, A, B);\n\n    calculate(t, B);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint p;\n\nint exp();\nint factor();\nint term();\n\nint factor() {\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n\n  if (str[p] == '('){\n    p++;\n    num = exp();\n    p++;\n  }\n  return num;\n}\n\nint term(){\n int val = factor();\n  while(str[p] == '*' || str[p] == '/') {\n    if(str[p] == '*') {\n      p++;\n      val *= factor();\n    } else if(str[p] == '/'){\n      p++;\n      val /= factor();\n    }\n  }\n\n  return val;\n}\n \nint exp() {\n  int val = term();\n  while(str[p] == '+' || str[p] == '-') {\n    if(str[p] == '+') {\n      p++;\n      val += term();\n    } else if(str[p] == '-'){\n      p++;\n      val -= term();\n    }\n  }\n\n  return val;\n}\n\nint main() {\n  int n;\n\n  cin >> n;\n  \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nbool IsDigit(string::iterator &itr);\nint expr(string::iterator &itr);\nint factor(string::iterator &itr);\nint number(string::iterator &itr);\n\nint expr(string::iterator &itr) {\n    int now = factor(itr);\n    /*\n    if(*itr == '+') {\n        itr++;\n        now += expr(itr);\n        return now;\n    }\n    if(*itr == '-') {\n        itr++;\n        now -= expr(itr);\n        return now;\n    }\n    return now;\n    */\n    while(true) {\n        if(*itr == '+') {\n            itr++;\n            now += factor(itr);\n            continue;\n        }\n        if(*itr == '-') {\n            itr++;\n            now -= factor(itr);\n            continue;\n        }\n        //cerr << \"expr:\" << now << endl;\n        return now;\n    }\n}\n\nint factor(string::iterator &itr) {\n    //cerr << \"factor:\" << *itr << endl;\n    int now = number(itr);\n    /*\n    if(*itr == '*') {\n        itr++;\n        now *= factor(itr);\n        return now;\n    }\n    if(*itr == '/') {\n        itr++;\n        now /= factor(itr);\n        return now;\n    }\n    return now;\n    */\n    while(true) {\n        if(*itr == '*') {\n            itr++;\n            now *= number(itr);\n            continue;\n        }\n        if(*itr == '/') {\n            itr++;\n            now /= number(itr);\n            continue;\n        }\n        //cerr << \"factor:\" << now << endl;\n        return now;\n    }\n}\n\nint number(string::iterator &itr) {\n    //cerr << \"number:\" << *itr << endl;\n    int now = 0;\n    if(*itr == '(') {\n        itr++;\n        now = expr(itr);\n        itr++;\n        //cerr << \"number:\" << now << endl;\n        return now;\n    }\n    while(IsDigit(itr)) {\n        now *= 10;\n        now += *itr - '0';\n        itr++;\n    }\n    //cerr << \"number:\" << now << endl;\n    return now;\n}\n\nbool IsDigit(string::iterator &itr) {\n    return *itr <= '9' && *itr >= '0';\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    while(N--) {\n        string S;\n        cin >> S;\n        auto itr = S.begin();\n        cout << expr(itr) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nstring s;\nint p;\n\nint solve();\n\nint elem()\n{\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tint buf = solve();\n\t\tp++;\n\t\treturn buf;\n\t}\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres = res * 10 + (s[p] - '0');\n\t\tp++;\n\t}\n\treturn res;\n}\n\nint term()\n{\n\tint tmp = elem();\n\twhile (s[p] == '*' || s[p] == '/')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tif (c == '*') tmp *= elem();\n\t\telse tmp /= elem();\n\t}\n\treturn tmp;\n}\n\nint solve()\n{\n\tint tmp = term();\n\twhile (s[p] == '+' || s[p] == '-')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tif (c == '+') tmp += term();\n\t\telse tmp -= term();\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\twhile (n--)\n\t{\n\t\tp = 0;\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 1000000007;\nusing ll = int64_t;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing state = string::const_iterator;\n\nint num(state &cur);\nint factor(state &cur);\nint muldiv(state &cur);\nint addsub(state &cur);\nint expr(state &cur);\n\nint factor(state &cur) {\n    if(isdigit(*cur)) return num(cur);\n    cur++;\n    int ans = addsub(cur);\n    cur++;\n    return ans;\n}\n\nint num(state &cur) {\n    int ans = *cur -'0';\n    while(isdigit(*++cur)) ans = ans*10 + (*cur-'0');\n    return ans;\n}\n\nint muldiv(state &cur) {\n    int ans = factor(cur);\n    while(true){\n        if(*cur == '*'){\n            cur++;\n            ans *= factor(cur);\n        }else if(*cur == '/'){\n            cur++;\n            ans /= factor(cur);\n        }else break;\n    }\n    return ans;\n}\n\nint addsub(state &cur){\n    int ans = muldiv(cur);\n    while(true){\n        if(*cur == '+'){\n            cur++;\n            ans += muldiv(cur);\n        }else if(*cur == '-'){\n            cur++;\n            ans -= muldiv(cur);\n        }else break;\n    }\n    return ans;\n}\n\nint expr(state &cur){\n    return addsub(cur);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        string s;\n        cin >> s;\n        state cur = s.begin();\n        cout << expr(cur) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\nint cur = 0;\nstring S;\nint expression();\nint term();\nint main() {\n  int times;\n  cin >>times;\n  for(int i = 0 ; i < times; i++){\n      cin >> S;\n      cur = 0;\n      S.resize(S.size()-1);\n      cout << expression() <<endl;\n  }\n\n}\nint digit() {\n//  assert(isdigit(S[cur]))\n  int n = S[cur] -'0';\n  cur = cur+1;\n  return n;\n}\nint number() {\n  int n = digit();\n  while(cur <S.size() && isdigit(S[cur])){\n      n = n*10 + digit();\n  }\n  return n;\n}\nint expression() {\n  int sum = term();\n  while (S[cur] == '+' || S[cur] == '-'){\n    char op = S[cur];\n    cur +=1;\n    int b = term();\n    if(op ==  '+') sum +=b;\n    else sum -= b;\n  }\n  return sum;\n}\nint term() {\n  int a = number();\n  while(cur < S.size()\n        && (S[cur] == '*' || S[cur] == '/')){\n          char op = S[cur];\n          cur +=1;\n          int b = number();\n          if(op == '*') a *=b;\n          else a/=b;\n        }\n  return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint number(State &begin);\nint factor(State &begin);\nint expression(State &begin);\nint term(State &begin);\n\nint number(State &begin){\t\t//数字\n\tint ret = 0;\n\twhile (isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += (*begin - '0');\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin){\t\t//括弧\n\tif (*begin == '(') return expression(begin);\n\tif (*begin == '-') return -1 * factor(begin);\n\tif (*begin == '+') return factor(begin);\n\t\n\tint ret = number(begin);\n\tbegin--;\n\treturn ret;\n}\nint term(State &begin){\t\t\t//乗算除算\n\tint ret = factor(begin);\n\twhile (1){\n\t\tif (*begin == '*') ret *= factor(++begin);\n\t\telse if (*begin == '/') ret /= factor(++begin);\n\t\telse break;\n\t}\n\tbegin--;\n\treturn ret;\n}\nint expression(State &begin){\t//四則演算\n\tint ret = term(begin);\n\twhile (1){\n\t\tif (*begin == '+') ret += term(++begin);\n\t\telse if (*begin == '-') ret -= term(++begin);\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++){\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\t\n\t\tState begin = str.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n// const string S = \"(1+1)*2\";\nstring S;\nint cur = 0;\nint digit();\nint number();\nint factor();\nint term();\nint _term(int m);\nint exp();\nint _exp(int m);\nint parse();\nbool isdigit(char);\nbool is_plu_min(char);\nbool is_tim_div(char);\nint main() {\n  int N;\n  cin >> N;\n  for (int i=0;i<N;i++) {\n    cin >> S;\n    cur = 0;\n    S.resize(S.size()-1);\n    cout << parse() << endl;\n  }\n  return 0;\n}\nint digit() {\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur]))\n    n = n*10 + digit();\n  return n;\n}\nbool isdigit(char c) {\n  if (c <= '9' and c >= '0') return true;\n  else return false;\n}\nbool is_plu_min(char c) {\n  if (c == '+' || c == '-') return true;\n  else return false;\n}\nbool is_tim_div(char c) {\n  if (c == '*' || c == '/') return true;\n  else return false;\n}\n// exp    = term exp`\n// exp`   = + term exp` | eps\n// term   = factor term`\n// term`  = * factor term` | eps\n// factor = ( exp ) | num\nint term() {\n  int n = factor();\n  return _term(n);\n}\nint _term(int m) {\n  int n = m;\n  switch (S[cur]) {\n    case '*':\n      cur++;\n      n *= factor();\n      return _term(n);\n    case '/':\n      cur++;\n      n /= factor();\n      return _term(n);\n    default:\n      return n;\n  }\n}\nint factor() {\n  if (S[cur] != '(') return number();\n  else {\n    cur++;\n    int n = exp();\n    cur++;\n    return n;\n  }\n}\nint exp() {\n  int n = term();\n  return _exp(n);\n}\nint _exp(int m) {\n  int n = m;\n  switch (S[cur]) {\n    case '+':\n      cur++;\n      n += term();\n      return _exp(n);\n    case '-':\n      cur++;\n      n -= term();\n      return _exp(n);\n    default:\n      return n;\n  }\n}\nint parse() {\n  return exp();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <string>\n\nclass Parser {\npublic:\n  std::string str;\n  int idx;\n  Parser (std::string str):str(str),idx(0)\n  {\n  }\n  int evalas();\n  int evalmd();\n  int evalexpr();\n  int evalnum();\n};\n\nint Parser::evalas() {\n  int left = evalmd(), right;\n  while(true) {\n    switch(str[idx]) {\n    case '+':\n      idx++;\n      right = evalmd();\n      left = left+right;\n      break;\n    case '-':\n      idx++;\n      right = evalmd();\n      left = left-right;\n      break;\n    default:\n      goto hoge;\n    }\n  }\n hoge:\n  return left;\n}\n\nint Parser::evalmd() {\n  int left = evalexpr(),right;\n  while(true) {\n    switch(str[idx]) {\n    case '*':\n      idx++;\n      right = evalexpr();\n      left = left*right;\n      break;\n    case '/':\n      idx++;\n      right = evalexpr();\n      left = left/right;\n      break;\n    default:\n      goto hoge;\n    }\n  }\n hoge:\n  return left;\n}\n\nint Parser::evalexpr() {\n  int n;\n  if (str[idx] == '(') {\n    idx++;\n    n = evalas();\n    idx++;\n  } else {\n    n = evalnum();\n  }\n  return n;\n}\n\nint Parser::evalnum() {\n  int ans=0;\n  char ch;\n  while (isdigit(ch=str[idx])) {\n    idx++;\n    ans = ans*10+(int)ch-(int)'0';\n  }\n  return ans;\n}\n\nint main() {\n  int time;\n  scanf(\"%d\\n\",&time);\n  while(time--) {\n    char str[100];\n    fgets(str,100,stdin);\n    printf(\"%d\\n\",Parser(std::string(str)).evalas());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nstd::string find(std::vector<std::string>&v, int a, bool b){\n\n\tstd::string res;\n\n\tif (b){\n\t\tfor (int i = a - 1; i >= 0; i--){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!b){\n\t\tfor (int i = a + 1; i < v.size(); i++){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint toint(std::string str){\n\n\tint res;\n\tstd::stringstream z;\n\n\tz << str;\n\tz >> res;\n\n\treturn res;\n\n}\n\nstd::string tostring(int a){\n\n\tstd::string str;\n\tstd::stringstream z;\n\n\tz << a;\n\tz >> str;\n\n\treturn str;\n\n}\n\nstd::string keisan(std::string lhs, std::string rhs, int t){\n\n\tint a, b, c;\n\n\ta = toint(lhs);\n\tb = toint(rhs);\n\n\tif (t == 1)c = a + b;\n\tif (t == 2)c = a - b;\n\tif (t == 3)c = a * b;\n\tif (t == 4)c = a / b;\n\n\treturn tostring(c);\n\n}\n\nstd::string keisan2(std::vector<std::string> &v){\n\n\tint res = 0;\n\n\tfor (int i = 0, j = 0, k = 0; i < v.size(); i++){\n\t\tif (v[i] == \"(\")j = i, k++;\n\t\tif (v[i] == \")\"){\n\t\t\tk--;\n\t\t\tif (k == 0){\n\t\t\t\tstd::vector<std::string>w;\n\t\t\t\tfor (int p = j + 1; p < i; p++)w.push_back(v[p]);\n\t\t\t\tv[j] = keisan2(w);\n\t\t\t\tfor (int p = j + 1; p <= i; p++)v[p] = \"T\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"*\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 3);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"/\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 4);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"+\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 1);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"-\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 2);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tv[v.size() - 1] = \"T\";\n\tfor (int i = 0; i < v.size(); i++)if (v[i] != \"T\")res = toint(v[i]);\n\n\treturn tostring(res);\n\n}\n\n\nint main(){\n\n\tint n;\n\tstd::cin >> n;\n\n\tfor (int i = 0; i < n; i++){\n\n\t\tstd::string str;\n\n\t\tstd::cin >> str;\n\n\t\tstd::vector<std::string> v;\n\n\t\tfor (int i = 0, j = 0; i < str.size(); i++){\n\n\t\t\tif (!(str[i] >= '0'&&str[i] <= '9')){\n\t\t\t\tif (i - j > 0)v.push_back(str.substr(j, i - j));\n\t\t\t\tv.push_back(str.substr(i, 1));\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << keisan2(v) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint solve(string& s, int& i)\n{\n    int a = 0;\n    int b = 0;\n    char prev = '+';\n    for(;;){\n        int x = 0;\n        if(s[i] == '('){\n            ++ i;\n            x += solve(s, i);\n            ++ i;\n        }else{\n            while('0' <= s[i] && s[i] <= '9'){\n                x *= 10;\n                x += s[i] - '0';\n                ++ i;\n            }\n        }\n\n        if(prev == '+'){\n            a += b;\n            b = x;\n        }else if(prev == '-'){\n            a += b;\n            b = -x;\n        }else if(prev == '*'){\n            b *= x;\n        }else{\n            b /= x;\n        }\n\n        if(s[i] == ')' || s[i] == '=')\n            break;\n\n        prev = s[i];\n        ++ i;\n    }\n\n    return a + b;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        string s;\n        cin >> s;\n        int i = 0;\n        cout << solve(s, i) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State& begin);\nint term(State& begin);\nint number(State& begin);\nint factor(State& begin);\n\nint expression(State& begin) {\n    int ret = term(begin);\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else break;\n    }\n    return ret;\n}\n\nint term(State& begin) {\n    int ret = factor(begin);\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else break;\n    }\n    return ret;\n}\n\nint factor(State& begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint number(State& begin) {\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret = ret*10 + (*begin - '0');\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    cin.ignore();\n    for (int i = 0; i < n; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<string>\nusing namespace std;\nint pos;\nstring parse;\n/*\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n*/\n\nint fact();\nint term();\nint expression();\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p = 0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n int term(){\n    int p = fact();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){++pos;p *= term();}\n      else {++pos;p /= term();}\n    }\n    return p;\n  }\n\n int expression(){\n    int p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){++pos;p+=term();}\n      else {++pos;p-=term();}\n    }\n    return p;\n  } \n \n/*\n};\n*/\n\n\n\n\n\n\n\nint main(){\n  string s;\n  int N;\n  cin >> N;\n  while(N-- > 0){\n    pos = 0;\n    cin >> s;\n    parse = s.substr(0,s.length()-1);\n   \n    //Parsing par = Parsing(s.substr(0,s.length()-1));\n    //cout << par.expression() << endl;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<\"foo2 \"<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(s[xl-1]=='-'&&xl-2>=0&&(s[xl-2]=='+'||s[xl-2]=='-'||s[xl-2]=='*'||s[xl-2]=='/')) {\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xr==i&&s[xr+1]=='-'){\n\t\t\t\t\t\txr++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\t\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\t// string tmp=\"123456\";\n\t// cout<<tmp.substr(5)<<endl;;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr<s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\t\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\nint pos;\nstring str;\n\nint exp();\n\nint factor() {\n  if(str[pos] >= '0' && str[pos] <= '9') {\n    string tmp = \"\";\n    while(str[pos] >= '0' && str[pos] <= '9') {\n      tmp += str[pos++];\n    }\n    return atoi(tmp.c_str());\n  }\n\n  if(str[pos] == '(') {\n    pos++;\n    int tmp = exp();\n    pos++;\n    return tmp;\n  }\n}\n\nint term() {\n  int x = factor();\n  while(str[pos] == '*' || str[pos] == '/') {\n    if(str[pos] == '*') {\n      pos++;\n      x *= factor();\n    } else if(str[pos] == '/') {\n      pos++;\n      x /= factor();\n    }\n  }\n  return x;\n}\n\nint exp() {\n  int x = term();\n  while(str[pos] == '+' || str[pos] == '-') {\n    if(str[pos] == '+') {\n      pos++;\n      x += term();\n    } else if(str[pos] == '-') {\n      pos++;\n      x -= term();\n    }\n  }\n  return x;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    pos = 0;\n    cin >> str;\n    str = str.substr(0, str.length()-1);\n    cout << exp() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\nint hoge(string a)\n{\n\tif(a==\"(\")return -1;\n\tif(a==\"*\"||a==\"/\")return 1;\n\treturn 0;\n}\n\nlong long calc(long long a,long long b,string str)\n{\n\tif(str==\"+\")return a+b;\n\tif(str==\"-\")return a-b;\n\tif(str==\"/\")return a/b;\n\tif(str==\"*\")return a*b;\n\t\n}\n\nint main()\n{\n\tint n;cin>>n;\n\twhile(n--)\n\t{\n\t\tstring str;cin>>str;\n\t\tstringstream ss;\n\t\tfor(int i=0;i<str.size()-1;i++)\n\t\t{\n\t\t\tif(str[i]=='+'||str[i]=='-'||str[i]=='/'||str[i]=='*')ss<<\" \"<<str[i]<<\" \";\n\t\t\telse if(str[i]=='(')ss<<\"( \";\n\t\t\telse if(str[i]==')')ss<<\" )\";\n\t\t\telse ss<<str[i];\n\t\t}\n\t\t\n\t\tvector<string> v;\n\t\tstack<string> st;\n\t\twhile(getline(ss,str,' '))\n\t\t{\n\t\t\t//if(str==\"\")continue;\n\t\t\tif(str==\"+\"||str==\"-\"||str==\"/\"||str==\"*\")\n\t\t\t{\n\t\t\t\twhile(!st.empty()&&hoge(st.top())>hoge(str))\n\t\t\t\t{\n\t\t\t\t\tv.push_back(st.top());\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.push(str);\n\t\t\t}\n\t\t\telse if(str==\")\")\n\t\t\t{\n\t\t\t\twhile(st.top()!=\"(\")\n\t\t\t\t{\n\t\t\t\t\tv.push_back(st.top());\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\telse if(str==\"(\")st.push(str);\n\t\t\telse v.push_back(str);\n\t\t}\n\t\twhile(!st.empty())\n\t\t{\n\t\t\tv.push_back(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tstack<long long> k;\n\t\tfor(int i=0;i<v.size();i++)\n\t\t{\n\t\t\tif(v[i]==\"+\"||v[i]==\"-\"||v[i]==\"/\"||v[i]==\"*\")\n\t\t\t{\n\t\t\t\tlong long A,B;\n\t\t\t\tB=k.top();k.pop();\n\t\t\t\tA=k.top();k.pop();\n\t\t\t\tk.push(calc(A,B,v[i]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk.push(atol(v[i].c_str()));\n\t\t\t}\n\t\t}\n\t\tcout<<k.top()<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint calc_E(char line[101],int left,int right);\nint calc_T(char line[101],int left,int right);\nint calc_F(char line[101],int left,int right);\nint calc_NUM(char line[101],int left,int right);\n\n\nint calc_E(char line[101],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、プラスまたは-を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tif(line[i] == '+'){\n\t\t\t\tQ.push(i);\n\t\t\t\ti++;\n\t\t\t}else{ //line[i] == '-'\n\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の+-がない\n\t\treturn calc_T(line,left,right);\n\t}\n\n\tint tmp = calc_E(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_T(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '+'){\n\t\t\ttmp += tmp_right;\n\t\t}else{\n\t\t\ttmp -= tmp_right;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\nint calc_T(char line[101],int left,int right){\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\t//深さ0の、*,/を探す\n\tfor(int i = left; i <= right; ){\n\t\tif(line[i] == '(')depth++;\n\t\telse if(line[i] == ')')depth--;\n\n\t\tif(depth != 0){\n\t\t\ti++;\n\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\ti++;\n\t\t}else{\n\t\t\tQ.push(i);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif(Q.empty()){ //深さ0の*がない\n\t\treturn calc_F(line,left,right);\n\t}\n\n\tint tmp = calc_T(line,left,Q.front()-1),tmp_right;\n\n\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\twhile(!Q.empty()){\n\t\tint loc = Q.front();\n\t\tQ.pop();\n\n\t\tif(Q.empty()){\n\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t}else{\n\t\t\ttmp_right = calc_F(line,loc+1,Q.front()-1);\n\t\t}\n\n\t\tif(tmp_right == BIG_NUM){\n\t\t\treturn BIG_NUM;\n\t\t}\n\n\t\tif(line[loc] == '*'){\n\t\t\ttmp *= tmp_right;\n\t\t}else{\n\t\t\ttmp /= tmp_right;\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint calc_F(char line[101],int left,int right){\n\n\tif(line[left] >= '0' && line[left] <= '9'){\n\t\treturn calc_NUM(line,left,right);\n\t}else if(line[left] == '-'){\n\t\treturn -1*calc_F(line,left+1,right);\n\t}else if(line[left] == '('){\n\n\t\tint depth = 0;\n\t\tint close_pos = BIG_NUM;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tclose_pos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\treturn calc_E(line,left+1,close_pos-1);\n\t}else{\n\t\treturn BIG_NUM;\n\t}\n}\n\nint calc_NUM(char line[101],int left,int right){\n\n\tint ret = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tret = 10*ret+line[i]-'0';\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint N,length;\n\tchar buf[101];\n\n\tscanf(\"%d\",&N);\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(length = 0; buf[length] != '='; length++);\n\n\t\tprintf(\"%d\\n\",calc_E(buf,0,length-1));\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = number(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= number(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= number(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n\nint main(void){\n\tint N;\n    cin >> N;\n    cin.ignore();\n    for(int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nint parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')'){\n\t\tbool f=true;\n\t\tfor(int i=1,d=1;i<s.length()-1;i++){\n\t\t\tif     (s[i]=='(')\td++;\n\t\t\telse if(s[i]==')')\td--;\n\t\t\tif(d==0){\tf=false;\tbreak;\t}\n\t\t}\n\t\tif(f)\treturn parse(s.substr(1,s.length()-2));\n\t}\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=s.length()-1,d=0;i>=1;i--){\n\t\tif     (s[i]==')')\td--;\n\t\telse if(s[i]=='(')\td++;\n\n\t\telse if(d==0 && prior[s[i]]!=0){\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoi(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n\n\twhile(1);\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#define I int\nI E();std::string S;I P,V;I T(){for(V=0;isdigit(S[P]);)V=V*10+S[P++]-48;return S[P]-40?V:++P?E():0;}I F(){I a=T();for(;S[P]==42|S[P]==47;)a=S[P++]-47?a*=T():a/=T();return a;}I E(){I a=F();for(;S[P]==43|S[P]==45;)a+=-(S[P++]==45)*F();return a;}main(){for(std::cin>>P;std::cin>>S;printf(\"%d\\n\",E()))S[S.size()-1]=P=0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<\"foo2 \"<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xl==1&&s[0]=='-'){\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[xl-1]=='-'&&xl-2>=0&&(s[xl-2]=='+'||s[xl-2]=='-'||s[xl-2]=='*'||s[xl-2]=='/')) {\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xr==i&&s[xr+1]=='-'){\n\t\t\t\t\t\txr++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\t\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tif(i>=1&&isdigit(s[i-1])&&((i<s.size()-1&&isdigit(s[i+1]))||(i<s.size()-2&&isdigit(s[i+2])&&s[i+1]=='-')));\n\t\t\telse continue;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xl==1&&s[xl-1]=='-'){\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xr==i&&s[xr+1]=='-'){\n\t\t\t\t\t\txr++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\t// string tmp=\"123456\";\n\t// cout<<tmp.substr(5)<<endl;;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr<s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\t\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint pri(char ch) \n{\n    if (ch == '*' || ch == '/')\n        return 2;\n    if (ch == '+' || ch == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    while (n--) {\n        string exp, cha;\n        stack<char> pol;\n        stack<int> cal;\n\n        cin >> exp;\n        for (int i = 0; i < exp.size() - 1; i++) {\n            if ('0' <= exp[i] && exp[i] <= '9') {\n                while (true) {\n                    cha.push_back(exp[i]);\n                    if ('0' > exp[i + 1] || exp[i + 1] > '9') {\n                        cha.push_back('.');\n                        break;\n                    }\n                    else\n                        i++;\n                }\n            }\n            else if (exp[i] == '(')\n                pol.push(exp[i]);\n            else if (exp[i] == ')') {\n                while (true) {\n                    if (pol.top() == '(') {\n                        pol.pop();\n                        break;\n                    }\n                    cha.push_back(pol.top());\n                    pol.pop();\n\n                }\n            }\n            else {\n                while (!pol.empty()) {\n                    if (pri(exp[i]) < pri(pol.top())) {\n                        cha.push_back(pol.top());\n                        pol.pop();\n                    }\n                    else \n                        break;\n                }\n                pol.push(exp[i]);\n            }\n        }\n\n        while (!pol.empty()) {\n            cha.push_back(pol.top());\n            pol.pop();\n        }\n\n\n        for (int i = 0; i < cha.size(); i++) {\n            if ('0' <= cha[i] && cha[i] <= '9') {\n                int tmp = cha[i] - '0';\n\n                while (true) {\n                    i++;\n                    if (cha[i] == '.') \n                        break;\n                    tmp *= 10;\n                    tmp += cha[i] - '0';\n                }\n                cal.push(tmp);\n            }\n            else {\n                int a, b;\n\n                b = cal.top();\n                cal.pop();\n                a = cal.top();\n                cal.pop();\n\n                if (cha[i] == '*') \n                    cal.push(a * b);\n                else if (cha[i] == '/') \n                    cal.push(a / b);\n                else if (cha[i] == '+') \n                    cal.push(a + b);\n                else if (cha[i] == '-') \n                    cal.push(a - b);\n            }\n        }\n        cout << cal.top() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nvoid select_cal(char c, int *tmp, int val){\n\n\tif(c == '+') *tmp += val;\n\telse if(c == '-') *tmp -= val;\n\telse if(c == '*') *tmp *= val;\n\telse if(c == '/') *tmp /= val;\n\n}\n\nint calculation(string str, int len, int begin){\n\n\tint ans, tmp, cnt;\n\tchar c;\n\t\n\tans = 0;\n\ttmp = 0;\n\tc = '+';\n\n\tfor(int i=begin; i<len; i++){\n\t\tif(str[i] == '+' || str[i] == '-'){\n\t\t\tans += tmp;\n\t\t\ttmp = 0;\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '*' || str[i] == '/'){\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '('){\n\t\t\tselect_cal(c, &tmp, calculation(str, len, i+1));\n\t\t\tcnt = 1;\n\t\t\tdo{\n\t\t\t\ti++;\n\t\t\t\tif(str[i] == '(') cnt++;\n\t\t\t\telse if(str[i] == ')') cnt--;\n\t\t\t}while(cnt != 0);\n\t\t}\n\t\telse if(str[i] == ')' || str[i] == '='){\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tselect_cal(c, &tmp, str[i] - '0');\n\t\t}\n\t}\n\tans += tmp;\n\n\treturn ans;\n\n}\n\nint main(){\n\n\tint n;\n\tstring str;\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> str;\n\t\tcout << calculation(str, str.length(), 0) << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct Parser {\n\tusing itr = string::const_iterator;\n\titr now;\n\tT ans;\n\tconst struct ex {\n\t\tvector<char> _012;\n\t\tex() {\n\t\t\t_012.resize(10);\n\t\t\tfor(int i = 0; i < 10; ++i) {\n\t\t\t\t_012[i] = (char)('0' + i);\n\t\t\t}\n\t\t}\n\t} ex;\n\tParser(const string &s) {\n\t\tnow = s.begin();\n\t\tans = expr(now);\n\t}\n\tT expr(itr &now) {\n\t\tT ret = term(now);\n\t\twhile(true) {\n\t\t\tif(*now == '+') {\n\t\t\t\tnext(now, '+');\n\t\t\t\tret += term(now);\n\t\t\t}else if(*now == '-') {\n\t\t\t\tnext(now, '-');\n\t\t\t\tret -= term(now);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tT term(itr &now) {\n\t\tT ret = fact(now);\n\t\twhile(true) {\n\t\t\tif(*now == '*') {\n\t\t\t\tnext(now, '*');\n\t\t\t\tret *= fact(now);\n\t\t\t}else if(*now == '/') {\n\t\t\t\tnext(now, '/');\n\t\t\t\tret /= fact(now);\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tT fact(itr &now) {\n\t\tif(*now == '(') {\n\t\t\tnext(now, '(');\n\t\t\tT ret = expr(now);\n\t\t\tnext(now, ')');\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn numb(now);\n\t\t}\n\t}\n\tT numb(itr &now) {\n\t\tT ret = 0;\n\t\twhile('0' <= *now and *now <= '9') {\n\t\t\tret *= 10;\n\t\t\tret += (T)(*now - '0');\n\t\t\tnext(now, ex._012);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid next(itr &now, const char expected) {\n\t\tvector<char> req = {expected};\n\t\tnext(now, req);\n\t}\n\tvoid next(itr &now, const vector<char> &expected) {\n\t\tfor(char c : expected) {\n\t\t\tif(*now == c) {\n\t\t\t\tnow++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcerr << *now << \"\\n\";\n\t\tfor(char c : expected) cerr << c << \"\\n\";\n\t}\n};\n\nint main() {\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tstring s; cin >> s;\n\t\tParser<int> parse(s);\n\t\tcout << parse.ans << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\n#if 0\n所用時間:\n\n感想:\n\n#endif\n\nstring S;\nsize_t cur;\n\nint expression();\nint factor();\n\nchar readchar(){\n    assert(cur < S.size());\n    char ret =  S[cur];\n    cur += 1;\n    return ret;\n} \n\nchar peek(){\n    // assert(cur < S.size());\n    return S[cur];\n}\n\nint digit(){\n    // assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while( cur < S.size() && isdigit(peek()))\n        n = n * 10 + digit();\n    return n;\n}\n\nint term(){\n    int a = factor();\n    while(cur < S.size() && (peek()=='*' || peek()=='/')){\n        char op = readchar();\n        int b = factor();\n        if(op=='*') a*= b;\n        else a /= b;\n        // cout << \"calc: \" << a << \" \" << op << \" \" << b << endl;\n    }\n    return a;\n}\n\nint factor(){\n    if (peek() == '('){\n        cur += 1;\n        int n = expression();\n        assert(peek() == ')');\n        cur += 1;\n        return n;\n        }\n    else return number();\n}\n\nint expression(){\n    int a = term();\n    while(cur < S.size() && (peek()=='+' || peek()=='-')){\n        char op = readchar();\n        int b = term();\n        // cout << \"calc: \" << a << \" \" << op << \" \" << b << endl;\n        if(op == '+'){\n            a += b;\n        }else{\n            a -= b;\n            }\n    }\n    return a;\n}\n\n\nint parse(){\n    return expression();\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i){\n        cin >> S;\n        cur = 0;\n        S.resize(S.size()-1); // 最後の=を無視\n        int a = parse();\n        cout << a << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ninline bool is_op(string &in) {\n\tif (in.size() == 1 && !isdigit(in[0]))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ninline bool is_num(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline bool is_expr(string &in)\n{\n\tif (!is_num(in) && !is_op(in)) { return true; }\n\telse { return false; }\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\treturn(stoi(in[0]));\n}\nint main()\n{\n\t/*string tmp = \"(-2*2)*5+(1+2)*(3+4)\";\n\tauto out=split(tmp);\n\tfor (auto i : out) {\n\t\tcout << i << endl;\n\t}\n\tcout << cal(tmp) << endl;*/\n\tstring input;\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parse{\n    typedef string::const_iterator itr;\n    itr begin;\n    T ans;\n    Parse(const string &s){\n        begin=s.begin();\n        ans=expr(begin);\n        cerr<<s<<\" \"<<ans<<\"\\n\";\n    }\n    T expr(itr &begin){\n        T ret=term(begin);\n        while(1){\n            if((*begin)=='+'){\n                consume(begin,'+');\n                ret+=term(begin);\n            }else if((*begin)=='-'){\n                consume(begin,'-');\n                ret-=term(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    T numb(itr &begin){\n        T ret=0;\n        while('0'<=(*begin)&&(*begin)<='9'){\n            ret*=10;\n            ret+=(*begin)-'0';\n            begin++;\n        }\n        return ret;\n    }\n    T fact(itr &begin){\n        T ret=0;\n        if((*begin)=='('){\n            consume(begin,'(');\n            ret=expr(begin);\n            consume(begin,')');\n        }else{\n            ret=numb(begin);\n        }\n        return ret;\n    }\n    T term(itr &begin){\n        T ret=fact(begin);\n        while(1){\n            if((*begin)=='*'){\n                consume(begin,'*');\n                ret*=fact(begin);\n            }else if((*begin)=='/'){\n                consume(begin,'/');\n                ret/=fact(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n            throw;\n        }\n    }\n};\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>>s;\n        Parse<int> parse(s);\n        cout<<parse.ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<\"foo2 \"<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\t\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\t// string tmp=\"123456\";\n\t// cout<<tmp.substr(5)<<endl;;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr==s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <stack>\n#include <cmath>\n#include <cassert>\n#define INF 10000000000\n#define MOD 10000000007\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> i_i;\n\nstring S;\nsize_t cur = 0;\n\n//with ()*************************************************************************************\n\nint factor();\n\nbool isdigit(char a){\n    if (a == '0' or a == '1' or a == '2' or a == '3' or a == '4' or a == '5' or a == '6' or a == '7' or a == '8' or a == '9') {\n        return true;\n    }\n    return false;\n}\n\n//********************************************************************************************\n\nint digit(){\n    int n = S[cur] - '0';\n    cur++;\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while(cur < S.size() and isdigit(S[cur])) n = n*10 + digit();\n    return n;\n}\n\nint term(){\n    //*****************************************************************************************\n    int a = factor();\n    //*****************************************************************************************\n    //int a = number();\n    while (cur < S.size() and (S[cur]=='*' or S[cur]=='/')) {\n        char op = S[cur++];\n        //int b = number();\n        //*****************************************************************************************\n        int b = factor();\n        //*****************************************************************************************\n        if(op=='*')a *= b; else a/=b;\n    }\n    return a;\n}\n\nint expression(){\n    int a = term();\n    while (cur < S.size() and (S[cur] == '+' or S[cur] == '-')) {\n        char op = S[cur++];\n        int b = term();\n        if(op == '+') a += b; else a -= b;\n    }\n    return a;\n}\n\n//with() *************************************************************************************\nint factor(){\n    if(S[cur] != '(') return number();\n    cur++;\n    int n = expression();\n    assert(S[cur] == ')');\n    cur++;\n    return n;\n}\n//********************************************************************************************\n\nint main(){\n    int n;\n    cin >> n;\n    while(n-- > 0){\n        cur = 0;\n        cin >> S;\n        S.resize(S.length()-1);\n        cout << expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a){\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\trep(i, s.first)rep(j, s.second)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a=0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}　\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nint g(string &s, int &p);\nint f(string &s, int &p) {\n\tint k = 0;\n\tint m = 1;\n\twhile (s[p] != ')' && s[p] != '=') {\n\t\tswitch (s[p]) {\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tk += m*f(s, p);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tm = -1;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tm = 1;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tk += m*g(s, p);\n\t\t}\n\t}\n\treturn k;\n}\nint g(string &s, int &p) {\n\tint k = 1;\n\tbool div = 0;\n\twhile (s[p] != ')' && s[p] != '+' && s[p] != '-' && s[p] != '=') {\n\t\tswitch (s[p]) {\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tif (div)k /= f(s, p);\n\t\t\telse k *= f(s, p);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tdiv = 0;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tdiv = 1;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tint num = 0;\n\t\t\twhile (isdigit(s[p])) {\n\t\t\t\tnum = num * 10 + s[p] - '0';\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (div)k /= num;\n\t\t\telse k *= num;\n\t\t}\n\t}\n\treturn k;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint p = 0;\n\t\tcout << f(s, p) << endl;\n\t}\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\n\tstruct node {\n\t\tmap<char,unique_ptr<node>> next;\n\t\tnode* fail = nullptr, *match_list = nullptr;\n\t\tstd::vector<int> match;\n\t}root;\n\tint pattern;\n\t//template<class string>\n\tAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\n\t\troot.fail = &root;\n\t\tfor (int i = 0; i < vs.size(); i++) {\n\t\t\tnode* now = &root;\n\t\t\tfor (auto c : vs[i]) {\n\t\t\t\tif (!now->next[c])now->next[c]=make_unique<node>();\n\t\t\t\tnow = now->next[c].get();\n\t\t\t}\n\t\t\tnow->match.push_back(i);\n\t\t}\n\t\tstd::queue<node*> que;\n\t\tque.push(&root);\n\t\twhile (!que.empty()) {\n\t\t\tauto now = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto &next : now->next) {\n\t\t\t\tif (!next.second)continue;\n\t\t\t\tif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\n\t\t\t\telse next.second->fail = now->fail->fail;\n\t\t\t\t//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\n\t\t\t\tif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\n\t\t\t\telse next.second->match_list = next.second->fail;\n\t\t\t\tque.push(next.second.get());\n\t\t\t}\n\t\t}\n\t}\n\tauto match_n(string str) {\n\t\tvector<int> num(pattern);\n\t\t\n\t}\n\tauto match_list(string str) {\n\t\tvector<pair<int, int>> list;\n\t\tauto now = &root;\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\tif (now->next.count(str[i]))now = now->next[str[i]].get();\n\t\t\telse now = now->fail;\n\t\t\tauto match = now->match_list;\n\t\t\tdo {\n\t\t\t\tmatch\n\t\t\t}\n\t\t}\n\t}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <string>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n# define M_PI 3.141592\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define pri_max 60000\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nbool isOperator(string c)\n{\n\tif (c == \"+\" || c == \"-\" || c == \"/\" || c == \"*\" || c == \"%\" || c == \"(\" || c == \")\" || c == \"=\")return true;\n\treturn false;\n}\nint op_pri(string c)\n{\n\tif (c == \"+\" || c == \"-\")return 2;\n\tif (c == \"(\")return -1;\n\treturn 3;\n}\nlong long calc(long long a, long long b, string op)\n{\n\tif (op == \"+\")return a + b;\n\tif (op == \"-\")return a - b;\n\tif (op == \"*\")return a * b;\n\tif (op == \"/\")return a / b;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tstring f; cin >> f;\n\t\tvector<string> v;\n\t\tstring temp;\n\t\tfor (int i = 0; i < f.size(); i++)\n\t\t{\n\t\t\tstring now;\n\t\t\tnow = f[i];\n\t\t\tif (isOperator(now))\n\t\t\t{\n\t\t\t\tif (temp != \"\")v.push_back(temp);\n\t\t\t\tv.push_back(now);\n\t\t\t\ttemp = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp += now;\n\t\t\t}\n\t\t}\n\n\t\tstack<string> st;\n\t\tvector<string> p;\n\n\t\tfor (int i = 0; i < v.size() - 1; i++)\n\t\t{\n\t\t\tstring now = v[i];\n\t\t\tif (isOperator(now))\n\t\t\t{\n\t\t\t\tif (now == \"(\")\n\t\t\t\t{\n\t\t\t\t\tst.push(now);\n\t\t\t\t}\n\t\t\t\telse if (now == \")\")\n\t\t\t\t{\n\t\t\t\t\twhile (st.top() != \"(\")\n\t\t\t\t\t{\n\t\t\t\t\t\tp.push_back(st.top());\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t}\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile (!st.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (op_pri(st.top()) >= op_pri(now))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.push_back(st.top());\n\t\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tst.push(now);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp.push_back(now);\n\t\t\t}\n\t\t}\n\t\twhile (!st.empty()) { p.push_back(st.top()); st.pop(); }\n\n\t\tstack<long long> a;\n\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t{\n\t\t\tstring now = p[i];\n\t\t\tif (isOperator(now))\n\t\t\t{\n\t\t\t\tlong long v1, v2;\n\t\t\t\tv2 = a.top(); a.pop();\n\t\t\t\tv1 = a.top(); a.pop();\n\t\t\t\ta.push(calc(v1, v2, now));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta.push(atol(now.c_str()));\n\t\t\t}\n\t\t}\n\t\tcout << a.top() << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar stk[50], psh[50];\nint v[50],pri[256], sp, pp;\n\nint calc(char *p) {\n  int i;\n  char *exp = p;\n  for (i = 0; i < 256; i++)\n    pri[i] = 3;\n  pri['+'] = pri['-'] = 1;\n  pri['*'] = pri['/'] = 2;\n  pri['('] = 4;\n  pri[')'] = 0;\n  stk[0] = 0;\n  pri[0] = -1;\n  sp = pp = 0;\n  while (*p != '\\0') {\n    while (pri[*p] <= pri[stk[sp]] && stk[sp] != '(')\n      psh[++pp] = stk[sp--];\n    if (*p != ')')\n      stk[++sp] = *p;\n    else\n      sp--;\n    p++;\n  }\n  for (i = sp; i > 0; i--)\n    psh[++pp] = stk[i];\n  sp = 0;\n  for (i = 1; i <= pp; i++) {\n    if ('0' <= psh[i] && psh[i] <= '9')\n      v[++sp] = psh[i] - '0';\n    else {\n      switch (psh[i]) {\n      case '+':\n        v[sp - 1] = v[sp - 1] + v[sp];\n        break;\n      case '-':\n        v[sp - 1] = v[sp - 1] - v[sp];\n        break;\n      case '*':\n        v[sp - 1] = v[sp - 1] * v[sp];\n        break;\n      case '/':\n        v[sp - 1] = v[sp - 1] / v[sp];\n        break;\n      }\n      sp--;\n    }\n  }\n  printf(\"%d\\n\",v[1]);\n}\n\nint main() {\n  int i, j, n;\n  char p[50][100];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++)\n    scanf(\"%s\", p[i]);\n  for (i = 0; i < n; i++)\n    for (j = 0; j < 100; j++)\n      if (p[i][j] == '=')\n        p[i][j] = '\\0';\n  for (i = 0; i < n; i++)\n    calc(p[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstring s;\nstring::iterator p;\n\nint fact();\nint term();\nint exp();\n\nint fact() {\n  int x;\n  string num;\n  while(isdigit(*p)) {\n    num += *p;\n    ++p;\n  }\n  if(num.size()) {\n    x = atoi(num.c_str());\n  } else {\n    ++p;\n    x = exp();\n    ++p;\n  }\n  return x;\n}\n\nint term() {\n  int x = fact();\n  while(*p == '*' || *p == '/') {\n    if(*p == '*') {\n      ++p;\n      x *= fact();\n    } else {\n      ++p;\n      x /= fact();\n    }\n  }\n  return x;\n\n}\n\nint exp() {\n  int x = term();\n  while(*p == '+' || *p == '-') {\n    if(*p == '+') {\n      ++p;\n      x += term();\n    } else {\n      ++p;\n      x -= term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    cin >> s;\n    p = s.begin();\n    cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cstdlib>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '*' || a == '/')\n\t\treturn 1;\n\treturn -1;\n}\n\nvoid clac_once(stack<long long> & num_stack, stack<char> & op_stack) {\n\tlong long a, b;\n\tlong long c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nlong long clac(string str) {\n\tstack<long long> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tlong long tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t}\n\n\tif(op_stack.size() != 1)\n\t\texit(1);\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint pri(char ch) \n{\n    if (ch == '*' || ch == '/')\n        return 2;\n    if (ch == '+' || ch == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    while (n--) {\n        string exp, cha;\n        stack<char> pol;\n        stack<int> cal;\n\n        cin >> exp;\n        for (int i = 0; i < exp.size() - 1; i++) {\n            if ('0' <= exp[i] && exp[i] <= '9') {\n                while (true) {\n                    cha.push_back(exp[i]);\n                    if ('0' > exp[i + 1] || exp[i + 1] > '9') {\n                        cha.push_back('.');\n                        break;\n                    }\n                    else\n                        i++;\n                }\n            }\n            else if (exp[i] == '(')\n                pol.push(exp[i]);\n            else if (exp[i] == ')') {\n                while (true) {\n                    if (pol.top() == '(') {\n                        pol.pop();\n                        break;\n                    }\n                    cha.push_back(pol.top());\n                    pol.pop();\n\n                }\n            }\n            else {\n                while (!pol.empty()) {\n                    if (pri(exp[i]) < pri(pol.top())) {\n                        cha.push_back(pol.top());\n                        pol.pop();\n                    }\n                    else \n                        break;\n                }\n                pol.push(exp[i]);\n            }\n        }\n\n        while (!pol.empty()) {\n            cha.push_back(pol.top());\n            pol.pop();\n        }\n\n        cerr << exp << endl;\n        cerr << cha << endl;\n        for (int i = 0; i < cha.size(); i++) {\n            if ('0' <= cha[i] && cha[i] <= '9') {\n                int tmp = cha[i] - '0';\n\n                while (true) {\n                    i++;\n                    if (cha[i] == '.') \n                        break;\n                    tmp *= 10;\n                    tmp += cha[i] - '0';\n                }\n                cal.push(tmp);\n            }\n            else {\n                int a, b;\n\n                b = cal.top();\n                cal.pop();\n                a = cal.top();\n                cal.pop();\n\n                if (cha[i] == '*') \n                    cal.push(a * b);\n                else if (cha[i] == '/') \n                    cal.push(a / b);\n                else if (cha[i] == '+') \n                    cal.push(a + b);\n                else if (cha[i] == '-') \n                    cal.push(a - b);\n            }\n        }\n        cout << cal.top() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\n#include <complex>\n#include <utility>\n#include <numeric>\n#define  rep(i,n) for(int i=0;i<(n);i++)\n#define  REP(i,a,n) for(int i=a;i<(n);i++)\n#define  rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define  VI\tvector<int>\n#define\t VS vector<string>\n#define  all(a) (a).begin(),(a).end()\n#define  debug(x) cout<<#x<<\": \"<<x<<endl\nusing namespace std;\ntypedef long long ll;\n\nconst int INF=1e9;\nchar fi[101][101];\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\ndouble EPS = 1e-10;\nint N,M;\nint sx,sy;\nint gx,gy;\nint w,h;\nint ans;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int MAX_V=100;\nconst int MAX_N=100;\nchar o[3]={'+','-','*'};\n#define md 1000003\n\n\nint dp[353][353]={0};\nint bow[353][353]={0};\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))\n\treturn 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\t\tP(double x,double y):x(x),y(y){\n\t\t}\n\t\tP operator + (P p){\n\t\t\treturn P(add(x,p.x),add(y,p.y));\n\t\t}\n\t\tP operator - (P p){\n\t\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t\t}\n\t\tP operator *(double d){\n\t\t\treturn P(x*d,y*d);\n\t\t}\n\t\tdouble dot(P p){\n\t\t\treturn add(x*p.x,y*p.y);\n\t\t}\n\t\tdouble det(P p){\n\t\t\treturn add(x*p.y,-y*p.x);\n\t\t}\n};\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x) return p.x<q.x;\n\treturn p.y<q.y;\n}\n\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps,ps+n,cmp_x);\n\tint k=0;\n\tvector<P> \tqs(n*2);\n\t\n\trep(i,n){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint n,m;\nvector<double> p;\nP ps[101];\nchar c[520][520];\nlong long mod=1000000007;\nlong long pow(ll i,ll j){\n\tll tmp=1;\n\twhile(j){\n\t\tif(j%2) tmp=tmp*i%mod;\n\t\ti=i*i%mod;\n\t\tj/=2;\n\t}\n\treturn tmp;\n}\nint cards[10];\nbool ok;\nvoid saiki(int deep){\n\tif(deep==4){\n\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i=1;i<=7;i++){\n\t\tif(cards[i]>0&&cards[i+1]>0&&cards[i+2]>0){\n\t\t\tcards[i]--;\n\t\t\tcards[i+1]--;\n\t\t\tcards[i+2]--;\n\t\t\tsaiki(deep+1);\n\t\t\tcards[i]++;\n\t\t\tcards[i+1]++;\n\t\t\tcards[i+2]++;\n\t\t}\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tif(cards[i]>2){\n\t\t\t\tcards[i]-=3;\n\t\t\t\tsaiki(deep+1);\n\t\t\t\tcards[i]+=3;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\t\n\tint n;\n\tcin>>n;\n\twhile(n>0){\n\t\tstack<string> a;\n\tstring s;\n\t\tcin>>s;\n\t\tstring tmp=\"\";\n\t\trep(i,s.size()){\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\t\t\t\ttmp+=s[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!a.empty()&&s[i]!='('){\n\t\t\t\tstring o=a.top();\n\t\t\t\t\tint k=0;\n\t\t\t\tif(o==\"*\"){\n\t\t\t\t\ta.pop();\n\t\t\t\t\tk=stoi(tmp)*stoi(a.top());\n\t\t\t\t\ta.pop();\n\t\t\t\t\ttmp=to_string(k);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(o==\"/\"){\n\t\t\t\t\ta.pop();\n\t\t\t\t\tk=stoi(a.top())/stoi(tmp);\n\t\t\t\t\ta.pop();\n\t\t\t\t\ttmp=to_string(k);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(tmp!=\"\"){\n\t\t\t\ta.push(tmp);\n\t\t\t\ttmp=\"\";\n\t\t\t\t}\n\t\t\t\t\tif(s[i]==')'){\n\t\t\t\t\t\tint k=stoi(a.top());\n\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\tif(a.top()==\"(\"){\n\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\tif(!a.empty()){\n\t\t\t\t\t\t\t\t\t\t\tif(a.top()==\"*\"){\n\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tk=stoi(a.top())*k;\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if(a.top()==\"/\"){\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tk=stoi(a.top())/k;\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta.push(to_string(k));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tif(a.top()==\"+\"){\n\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\tk=k+stoi(a.top());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(a.top()==\"-\"){\n\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\tk=stoi(a.top())-k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\telse if(s[i]!='='){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i==0&&s[i]=='-')\n\t\t\t\t\t\t\t\ttmp+=s[i];\n\t\t\t\t\t\t\telse if(s[i+1]=='-'){\n\t\t\t\t\t\t\t\ttmp+=s[i+1];\n\t\t\t\t\t\t\t\tstring c=\"\";\n\t\t\t\t\t\t\tc+=s[i++];\n\t\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstring c=\"\";\n\t\t\t\t\t\t\tc+=s[i];\n\t\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\tint ans=stoi(a.top());\n\t\t\ta.pop();\n\t\t\twhile(!a.empty()){\n\t\t\t\tif(a.top()==\"+\"){\n\t\t\t\ta.pop();\n\t\t\t\t\tans=ans+stoi(a.top());\n\t\t\t\t}\n\t\t\t\telse if(a.top()==\"-\"){\n\t\t\t\ta.pop();\n\t\t\t\t\tans=stoi(a.top())-ans;\n\t\t\t\t}\n\t\t\t\ta.pop();\n\t\t\t\t\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t\tn--;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nint main(){\n    int N;\n    cin >> N;\n    for(int pomu = 0; pomu < N; pomu++){\n        string s;\n        cin >> s;\n        s = s.substr(0, s.size() - 1);\n        while(1){\n            map<char, vector<int>> m;\n            for(int i = 0; i < s.size(); i++){\n                if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') m[s[i]].push_back(i);\n            }\n            vector<int> v;\n            if(m.find('*') != m.end() || m.find('/') != m.end()){\n                for(int pos : m['*']) v.push_back(pos);\n                for(int pos : m['/']) v.push_back(pos);\n            }else{\n                for(int pos : m['+']) v.push_back(pos);\n                for(int pos : m['-']) v.push_back(pos);\n            }\n            if(v.size() == 0) break;\n            sort(v.begin(), v.end());\n            string t;\n            int pos = v[0];\n            string num[2];\n            int tmp;\n            for(int j = pos - 1; 0 <= j; j--){\n                if('0' <= s[j] && s[j] <= '9'){\n                    num[0] += s[j];\n                }else{\n                    for(int k = 0; k <= j; k++){\n                        t += s[k];\n                    }\n                    break;\n                }\n            }\n            for(int j = pos + 1; j <= s.size(); j++){\n                if('0' <= s[j] && s[j] <= '9'){\n                    num[1] += s[j];\n                }else{\n                    tmp = j;\n                    break;\n                }\n            }\n            int add;\n            switch(s[pos]){\n                case '+':\n                    add = stoi(num[0]) + stoi(num[1]);\n                    break;\n                case '-':\n                    add = stoi(num[0]) - stoi(num[1]);\n                    break;\n                case '*':\n                    add = stoi(num[0]) * stoi(num[1]);\n                    break;\n                case '/':\n                    add = stoi(num[0]) / stoi(num[1]);\n                    break;\n            }\n            t += to_string(add);\n            for(int j = tmp; j < s.size(); j++) t += s[j];\n            s = t;\n        }\n        cout << s << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nint stoi(const string& s) {\n\tint res;\n\tistringstream is(s);\n\tis >> res;\n\treturn res;\n}\n\nstring s;\n\nint factor(int, int);\nint term(int, int);\nint formula(int, int);\n\nint factor(int l, int r) {\n\tif(s[l] == '(')\n\t\treturn formula(l + 1, r - 1);\n\n\treturn stoi(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == '(')\n\t\t\t--cnt;\n\n\t\telse if(!cnt) {\n\t\t\tif(s[i] == '*')\n\t\t\t\treturn term(l, i) * factor(i + 1, r);\n\n\t\t\telse if(s[i] == '/')\n\t\t\t\treturn term(l, i) / factor(i + 1, r);\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == '(')\n\t\t\t--cnt;\n\n\t\telse if(!cnt) {\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn formula(l, i) + term(i + 1, r);\n\n\t\t\telse if(s[i] == '-')\n\t\t\t\treturn formula(l, i) - term(i + 1, r);\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> s;\n\t\tcout << formula(0, s.size() - 1) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<deque>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef string::const_iterator state;\nclass parse_error {};\n\n//Debug\n//state it_begin, it_end;\n\nvoid compare(state &it, char expected) {\n\tif (*it != expected) {\n\t\tcerr << \"Expected '\" << expected << \"',\";\n\t\tcerr << \"got '\" << *it << \"'\";\n\n\t\t//Debug\n\t\t//cerr << \" rest \\\"\";\n\t\t//while (it < it_end) {\n\t\t//\tcerr << *it++;\n\t\t//}\n\t\t//cerr << \"\\\"\";\n\n\t\tcout << endl;\n\t\tthrow parse_error();\n\t}\n}\n\n/*\n\nEBNF\n\nexpression\t= {['+'|'-'] term} | '=';\nterm\t\t= factor {('*'|'/') factor};\nfactor\t\t= '(' expression ')' | integer;\ninteger\t\t= digit {digit};\ndigit\t\t= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';\n\n*/\n\nint expression(state &it);\nint term(state &it);\nint factor(state &it);\nint integer(state &it);\n\nint expression(state &it) {\n\tif (*it == '=')return 0;\n\n\tint ret = term(it);\n\n\twhile (true) {\n\t\tif (*it == '+') {\n\t\t\tit++;\n\t\t\tret += term(it);\n\t\t}\n\t\telse if (*it == '-') {\n\t\t\tit++;\n\t\t\tret -= term(it);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint term(state &it) {\n\tint ret = factor(it);\n\n\twhile (true) {\n\t\tif (*it == '*') {\n\t\t\tit++;\n\t\t\tret *= factor(it);\n\t\t}\n\t\telse if (*it == '/') {\n\t\t\tit++;\n\t\t\tret /= factor(it);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(state &it) {\n\tif (*it == '(') {\n\t\tit++;\n\t\tint ret = expression(it);\n\t\tcompare(it, ')');\n\t\tit++;\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn integer(it);\n\t}\n}\n\nint integer(state &it) {\n\tint ret = 0;\n\n\twhile (isdigit(*it)) {\n\t\tret *= 10;\n\t\tret += *it - '0';\n\t\tit++;\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\tint N; cin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\n\t\tstate it = s.begin();\n\n\t\t//Debug\n\t\t//it_begin = s.begin();\n\t\t//it_end = s.end();\n\n\t\tint ans = expression(it);\n\t\tcompare(it, '=');\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tret *= term(++begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tret /= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tret += term(++begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tret -= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tcout << expression(str.begin()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nusing namespace std;\n\n \nint number(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\nint main(void){\n  int N;\n  std::cin >> N;\n\n  while(N--){\n    std::string s;\n    std::cin>>s;\n    State begin = s.begin();\n    int ans = expression(begin);\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}\n \nint number(State &begin){\n  int ret = 0;\n \n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n \n  return ret;\n}\n \nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n \n\n \nint expression(State &begin){\n  int num = factor(begin);\n  int sum = 0;\n  \n  for(;;){\n    char ch = *begin;\n    begin++;\n    if(ch == '+'){\n      num += factor(begin);\n    } else if(ch == '-'){\n      num -= factor(begin);\n    }else if(ch == '*'){\n      sum += num;\n      num = factor(begin);\n    }else if(ch == '/'){\n      sum += num;\n      num = factor(begin);\n    }else{\n      break;\n    }\n  }\n  return sum+num;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n\nusing namespace std;\n\nchar *pt;\nint parseAtom();\nint parseExpr();\nint parseTerm();\n\n\nint parseAtom(){\n\tif('0' <= *pt && *pt <= '9'){\n\t\tint x = *pt - '0';\n\t\tpt++;\n\t\twhile('0' <= *pt && *pt <= '9'){\n\t\t\tx = x * 10 + *pt - '0';\n\t\t\tpt++;\n\t\t}\n\t\treturn x;\n\t}\n\tif('(' == *pt){\n\t\tpt++;\n\t\tint x = parseExpr();\n\t\tassert(*pt == ')');\n\t\tpt++;\n\t\treturn x;\n\t}\n\tassert(false);\n\treturn -1;\n}\nint parseExpr(){\n\tint x = parseTerm();\n\twhile(*pt == '+' || *pt == '-'){\n\t\tif(*pt == '+'){\n\t\t\tpt++;\n\t\t\tx += parseTerm();\n\t\t}else {\n\t\t\tpt++;\n\t\t\tx -= parseTerm();\n\t\t}\n\t}\n\treturn x;\n}\nint parseTerm(){\n\tint x = parseAtom();\n\twhile(*pt == '*' || *pt == '/'){\n\t\tif(*pt == '*'){\n\t\t\tpt++;\n\t\t\tx *= parseAtom();\n\t\t} else{\n\t\t\tx /= parseAtom();\n\t\t}\n\t}\n\treturn x;\n}\nint main(void){\n\tint n ;\n\tcin>>n;\n\tfor(int i = 0 ; i < n ;  i ++){\n\t\tstatic char expr[200];\n\t\tcin>>expr;\n\t\tpt=expr;\n\t\tint x = parseExpr();\n\t\tassert(*pt == '=');\n\t\tcout<<x<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nlong calc2(char *eq){\n\tlong c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nint expr(string& s,int& i);//テ・ツシツ?\n//<expr>::=<term>[('+'|'-')<term>]\nint term(string& s,int& i);//テゥツ??\n//<term>::=<factor> [(テ「ツ??テ「ツ?處テ「ツ??テ「ツ??<factor>]*\nint factor (string& s,int& i);//テ・ツ崢?ヲツ閉ー\n//<factor>::=<number>|テ「ツ??テ「ツ??expr>テ「ツ??テ「ツ??\nint number(string& s,int& i);//テヲツ閉ー\n//<number>::=テ」ツ?ェテ」ツつ禿」ツ??\n\nint number(string& s,int& i){\n  int num = s[i]-'0';\n  i++;\n  while(isdigit(s[i])){\n    num = num*10+s[i]-'0';\n    i++;\n  }\n  return num;\n}\n\nint factor(string& s,int& i){\n  if(isdigit(s[i])) return number(s,i);\n\n  i++;\n  int res=expr(s,i);\n  i++;\n  return res;\n}\n\nint term(string& s,int& i){\n  int val1=factor(s,i);\n  while(s[i]=='*'||s[i]=='/'){\n    char op=s[i];\n    i++;\n    int val2=factor(s,i);\n    if(op=='*'){\n      val1 =val1*val2;\n    }\n    else{\n      val1=val1/val2;\n    }\n  }\n  return val1;\n}\n\nint expr(string& s,int& i){\n  int val1=term(s,i);\n  while(s[i]=='+'||s[i]=='-'){\n    char op=s[i];\n    i++;\n    int val2=term(s,i);\n    if(op=='+'){\n      val1 =val1+val2;\n    }\n    else{\n      val1=val1-val2;\n    }\n  }\n  return val1;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for(int k=0;k<n;k++){\n    string s;\n    cin >> s;\n    int i=0;\n    cout << expr(s,i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n// exp1 = exp2 [ ('+'|'-') exp2 ]*\n// exp2 = exp3 [ ('*'|'/') exp3 ]*\n// exp3 = '(' exp1 ')' | number\nint exp1(const string& s, int& i);\nint exp2(const string& s, int& i);\nint exp3(const string& s, int& i);\nint number(const string& s, int& i);\nint exp1(const string& s, int& i) {\n  int acc = exp2(s, i);\n  while (1) {\n    if (s[i] == '+') acc += exp2(s, ++i);\n    else if (s[i] == '-') acc -= exp2(s, ++i);\n    else return acc;\n  }\n}\nint exp2(const string& s, int& i) {\n  int acc = exp3(s, i);\n  while (1) {\n    if (s[i] == '*') acc *= exp3(s, ++i);\n    else if (s[i] == '/') acc /= exp3(s, ++i);\n    else return acc;\n  }\n}\nint exp3(const string& s, int& i) {\n  if (s[i] == '(') {\n    int ret = exp1(s, ++i);\n    assert(s[i] == ')');\n    i++;\n    return ret;\n  }\n  return number(s, i);\n}\nint number(const string& s, int& i) {\n  int acc = 0;\n  while (isdigit(s[i])) {\n    acc = acc * 10 + (s[i++] - '0');\n  }\n  return acc;\n}\n\nvoid solve() {\n  string s; cin >> s;\n  int i = 0;\n  cout << exp1(s, i) << endl;\n  assert(s[i] == '=');\n}\nsigned main() {\n  int T; cin >> T;\n  while (T--) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint Num();\nint Term();\nint Exp();\n\nint ite;\nstring s;\n\nint Num() {\n\tint res = 0;\n\twhile (isdigit(s[ite])) {\n\t\tres = res * 10 + s[ite] - '0';\n\t\tite++;\n\t}\n\treturn res;\n}\n\nint Term() {\n\tint res = Num();\n\twhile (true) {\n\t\tif (s[ite] == '*') {\n\t\t\tite++;\n\t\t\tif (s[ite] == '(') {\n\t\t\t\tite++;\n\t\t\t\tres *= Exp();\n\t\t\t\tassert(s[ite] == ')');\n\t\t\t\tite++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres *= Num();\n\t\t\t}\n\t\t}\n\t\telse if (s[ite] == '/') {\n\t\t\tite++;\n\t\t\tif (s[ite] == '(') {\n\t\t\t\tite++;\n\t\t\t\tres /= Exp();\n\t\t\t\tassert(s[ite] == ')');\n\t\t\t\tite++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres /= Num();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint Exp() {\n\tint res = Term();\n\twhile (s[ite] != '=' && s[ite] != ')') {\n\t\tif (s[ite] == '+') {\n\t\t\tite++;\n\t\t\tres += Term();\n\t\t}\n\t\telse if(s[ite] == '-') {\n\t\t\tite++;\n\t\t\tres -= Term();\n\t\t}\n\t\telse {\n\t\t\tcout << \"abyaaaa\" << endl;\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> s;\n\t\tite = 0;\n\t\tcout << Exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])!=-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=isNum(s[oi]);\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<queue>\nusing namespace std;\n\nstring Erase(string a, int b, int c,string e) {//b???????????????c??????????????§????¶????\n\tstring d;\n\tfor (int i = 0; i < b; i++) {\n\t\td += a[i];\n\t}\n\td += e;\n\tfor (int i = c+1; i < a.length(); i++) {\n\t\td += a[i];\n\t}\n\treturn d;\n}\nstring kake(string a) {\n\tint b = 1; a = \"*\" + a;\n\tfor (int c = 0; c < a.length(); c++) {\n\t\tint e = c+1;\n\t\tif (a[c] == '*') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb *= stoi(d);\n\t\t}\n\t\telse if (a[c] == '/') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb /= stoi(d);\n\t\t}\n\t\tc = e - 1;\n\t}\n\treturn to_string(b);\n}\nstring tasi(string a) {\n\tint b = 0; a = \"+\" + a;\n\tfor (int c = 0; c < a.length(); c++) {\n\t\tint e = c + 1;\n\t\tif (a[c] == '+') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb += stoi(d);\n\t\t}\n\t\telse if (a[c] == '-') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb -= stoi(d);\n\t\t}\n\t\tc = e - 1;\n\t}\n\treturn to_string(b);\n}\nstring keisan(string a) {\n\tvector<string>V;\n\tstring b;\n\tfor (char c : a) {\n\t\tif (c == '+' || c == '-') {\n\t\t\tV.push_back(b);\n\t\t\tb = \"\"; b += c;\n\t\t\tV.push_back(b);\n\t\t\tb = \"\";\n\t\t}\n\t\telse b += c;\n\t}\n\tV.push_back(b);\n\tfor (int i = 0; i < V.size(); i += 2) {\n\t\tV[i] = kake(V[i]);\n\t}\n\tstring S;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tS += V[i];\n\t}\n\treturn tasi(S);\n}\nint main(){\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tstring c; cin >> c;\n\t\tc = c.substr(0, c.length() - 1);\n\t\tc = \"(\" + c + \")\";\n\t\twhile (1) {\n\t\t\tbool s = false;//????????????????????? ( ?????????0\n\t\t\tint last = 0;\n\t\t\tfor (int i = 0; i < c.length(); i++) {\n\t\t\t\tif (c[i] == '(') {\n\t\t\t\t\ts = false;\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t\tif (c[i] == ')') {\n\t\t\t\t\tif (!s) {\n\t\t\t\t\t\tc = Erase(c, last, i, keisan(c.substr(last+1,i-last-1)));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts = true;\n\t\t\t\t}\n\t\t\t\tif (i == c.length() - 1) { goto l; }\n\t\t\t}\n\t\t}\n\tl:;\n\t\tcout << c << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint factor(State &begin);\n\nint number(State &begin){\n    int ret=0;\n\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin -'0';\n        begin++;\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n\n    while(true){\n        if(*begin=='*')ret*=factor(++begin);\n        else if(*begin=='/')ret/=factor(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret=term(begin);\n    while(true){\n        if(*begin=='+')ret+=term(++begin);\n        else if(*begin=='-')ret-=term(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin=='(')return expression(++begin++);\n    else  return number(begin);\n}\n\nint main(){\n\n    int N;\n    cin>>N;\n    cin.ignore();\n    string s[N];\n    REP(i,N)getline(cin,s[i]);\n    REP(i,N){\n        State begin=s[i].begin();\n        cout<<expression(begin)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    cout << number(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &);\nint term(State &);\nint number(State &);\nint factor(State &);\n\nint main(void) {\n    int N;\n    cin >> N;\n    cin.ignore();\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while (1) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = number(begin);\n\n    while (1) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <sstream>\n\nusing namespace std;\n\ntypedef string::const_iterator Cursor;\nclass ParseError{};\n\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\nint expression(Cursor&);\nint term(Cursor&);\nint factor(Cursor&);\nint number(Cursor&);\n\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\nint expression(Cursor &c){\n    int ret = term(c);\n    while(*c == '+' or *c == '-'){\n        if(*c == '+'){\n            c++;\n            ret += term(c);\n        }else{\n            c++;\n            ret -= term(c);\n        }\n    }\n    return ret;\n}\n\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\nint term(Cursor &c){\n    int ret = factor(c);\n    while(*c == '*' or *c == '/'){\n        if(*c == '*'){\n            c++;\n            ret *= term(c);\n        }else{\n            c++;\n            ret /= term(c);\n        }\n    }\n    return ret;\n}\n\n// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\nint factor(Cursor &c){\n    if(*c == '('){\n        c++;\n        int ret = expression(c);\n        // ')'\n        c++;\n        return ret;\n    }else{\n        return number(c);\n    }\n}\n\n// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\nint number(Cursor &c){\n    stringstream ss;\n    while(isdigit(*c)){\n        ss << *c;\n        c++;\n    }\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nint main(){\n    int test_case;\n    cin >> test_case;\n    cin.ignore();\n    for(int i=0;i<test_case;i++){\n        string s;\n        getline(cin,s);\n        string inp = s.substr(0,s.size()-1);\n        Cursor c = inp.begin();\n        cout << expression(c) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint term(char* &s);\nint number(char* &s);\nint factor(char* &s);\nint expr(char* &s);\n\n\n//数\nint number(char* &s){\n  int res = 0;\n\n  while('0' <= *s && *s <= '9')\n    res = res*10 + (*s++ - '0');\n\n  return res;\n}\n\n\n//乗算除算\nint term(char* &s){\n  int res = factor(s);\n\n  while(1){\n    if(*s == '*') res *= factor(++s);\n    else if(*s == '/') res /= factor(++s);\n    else break;\n  }\n\n  return res;\n}\n\n//式\nint expr(char* &s){\n  int res = term(s);\n\n  while(1){\n    if(*s == '+') res += term(++s);\n    else if(*s == '-') res -= term(++s);\n    else break;\n  }\n\n  return res;\n}\n\n//括弧か数\nint factor(char * &s){\n  if(*s != '(') return number(s);\n  int res = 0;  \n  res = expr(++s); s++;\n  return res;\n}\n\n\n\n\nint main(){\n  int n;\n\n  scanf(\"%d\", &n);\n\n  while(n--){\n    char s[SIZE];\n    cin >> s;\n    for(int i=0;i<n;i++) if(s[i] == '=') s[i] = '\\0';\n    char *p = s;\n    cout << expr(p) << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=3005,INF=1<<29;\ntypedef string::const_iterator State;\n\nint expr(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\n\nint expr(State &begin){\n    int ret=term(begin);\n    \n    for(;;){\n        if(*begin=='+'){\n            begin++;\n            ret+=term(begin);\n        }else if(*begin=='-'){\n            begin++;\n            ret-=term(begin);\n        }else break;\n    }\n    \n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n    \n    for(;;){\n        if(*begin=='*'){\n            begin++;\n            ret*=factor(begin);\n        }else if(*begin=='/'){\n            begin++;\n            ret/=factor(begin);\n        }else break;\n    }\n    \n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin=='('){\n        begin++;\n        int ret=expr(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nint number(State &begin){\n    int ret=0;\n    \n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=(*begin-'0');\n        begin++;\n    }\n    \n    return ret;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    for(int i=0;i<N;i++){\n        string S;cin>>S;\n        State a=S.begin();\n        cout<<expr(a)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\n\nstring cal_mul (string str, int sym) {\n    //cout << str << endl;\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    if (str[0] == '-') sumL = -sumL; \n    while (str[sym+R] >= '0' && str[sym+R] <= '9') {\n        R++;\n    }\n    rep(i ,R-1) {\n        sumR += mul10(i, str[sym+R-i-1] - '0');\n    }\n    //dump(sumL);\n    //dump(sumR);\n    stringstream str_tmp;\n    if (str[0] == '-') rep(i, sym-L) str_tmp << str[i+1];\n    else rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length(); i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            //cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        str = cal_all(str);\n        //?????????????????????\n        int ans = stoi(str);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\nint main(){\n    int n;\n    string s;\n    while(cin>>n){\n        for(int i=0; i<n; i++){\n            cin>>s;\n            int j=0;\n            \n            queue<string> qu;\n            stack<string> st;\n            \n            \n            while(j<s.length()){\n                //cout<<s[j]<<endl;\n                //数値の処理\n                if(s[j]>='0'&&s[j]<='9'){\n                    string s_temp;\n                    \n                    while(s[j]>='0'&&s[j]<='9'){\n                        s_temp+=s[j];\n                        j++;\n                    }\n                    \n                    qu.push(s_temp);\n                    \n                }\n                \n                //括弧の処理\n                else if(s[j]==')'){\n                    while(1){\n                        string s_temp;\n                        s_temp = st.top();\n                        st.pop();\n                        if(s_temp==\"(\"){\n                            break;\n                        }else{\n                            qu.push(s_temp);\n                        }\n                    }\n                    j++;\n                }\n                \n                else if(s[j]=='('){\n                    string s_temp;\n                    s_temp+=s[j];\n                    st.push(s_temp);\n                    j++;\n                }\n                \n                //演算子の処理\n                else if(s[j]=='-'||s[j]=='+'||s[j]=='*'||s[j]=='/'){\n                    string s_temp;\n                    s_temp+=s[j];\n                    if(st.empty()){\n                        st.push(s_temp);\n                        j++;\n                    }else{\n                        if(!(s_temp==\"*\"||s_temp==\"/\")&&(st.top()==\"-\"||(st.top()==\"+\"))){\n                            s_temp = st.top();\n                            st.pop();\n                            qu.push(s_temp);\n                        }else{\n                            st.push(s_temp);\n                            j++;\n                        }\n                    }\n                }\n                //=の処理\n                else if(s[j]=='='){\n                    j++;\n                }\n                \n                \n            }\n            while(!st.empty()){\n                qu.push((st.top()));\n                st.pop();\n            }\n            \n            stack<int> num;\n            while(!qu.empty()){\n                \n                //cout<<qu.front()<<endl;\n                \n                if(qu.front()==\"*\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a*b;\n                    num.push(a);\n                }else if(qu.front()==\"/\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b/a;\n                    num.push(a);\n                    \n                }else if(qu.front()==\"-\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b-a;\n                    num.push(a);\n                }else if(qu.front()==\"+\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a+b;\n                    num.push(a);\n                }else{\n                    stringstream stream;\n                    stream<<qu.front();\n                    int temp;\n                    stream>>temp;\n                    num.push(temp);\n                }\n                qu.pop();\n            }\n            cout<<num.top()<<endl;\n        }\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint p;\nstring expr;\n\nint parseInt()\n{\n\tint ret=0;\n\twhile(isdigit(expr[p]))\n\t{\n\t\tret*=10;\n\t\tret+=expr[p]-'0';\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nchar parseChr()\n{\n\tchar ret=expr[p];\n\tp++;\n\t\n\treturn ret;\n}\n\nint calc(stack<int>& num, stack<char>& sta)\n{\n\tint r=num.top(); num.pop();\n\tint l=num.top(); num.pop();\n\tchar e=sta.top(); sta.pop();\n\t\n\tif(e=='+') return l+r;\n\tif(e=='-') return l-r;\n\tif(e=='*') return l*r;\n\t\n\treturn l/r;\n}\n\nint main()\n{\n\tint N;\n\t\n\tmap<char, int> tab;\n\ttab.insert(make_pair('+',1));\n\ttab.insert(make_pair('-',1));\n\ttab.insert(make_pair('*',2));\n\ttab.insert(make_pair('/',2));\n\ttab.insert(make_pair('(',3));\n\ttab.insert(make_pair(')',-3));\n\t\n\tcin >> N;\n\twhile(N--)\n\t{\t\n\t\tp=0;\n\t\tcin >> expr;\n\t\t\n\t\tint nc=0;\n\t\tstack<char> sta;\n\t\tstack<int> cnt;\n\t\tstack<int> num;\n\t\twhile(expr[p]!='=')\n\t\t{\n\t\t\tif(isdigit(expr[p]))\n\t\t\t{\n\t\t\t\tnum.push(parseInt());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar c=parseChr();\n\t\t\t\tif(c=='('||c==')') nc+=tab[c];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(!sta.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cnt.top()+tab[sta.top()] >= nc+tab[c])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ret=calc(num,sta);\n\t\t\t\t\t\t\tnum.push(ret);\n\t\t\t\t\t\t\tcnt.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsta.push(c);\n\t\t\t\t\tcnt.push(nc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!sta.empty())\n\t\t{\n\t\t\tint ret=calc(num,sta);\n\t\t\tnum.push(ret);\n\t\t}\n\t\t\n\t\tcout << num.top() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State& it) {\n\tint result = 0;\n\twhile (isdigit(*it)) {\n\t\tresult *= 10;\n\t\tresult += (*it) - '0';\n\t\t++it;\n\t}\n\treturn result;\n}\n\nint expression(State&);\n\nint factor(State& it) {\n\tif (*it == '(') {\n\t\t++it;\n\t\tint result = expression(it);\n\t\t++it;\n\t\treturn result;\n\t}\n\telse return number(it);\n}\n\nint term(State& it) {\n\tint result = factor(it);\n\tfor (;;) {\n\t\tif (*it == '*') {\n\t\t\t++it;\n\t\t\tresult *= factor(it);\n\t\t}\n\t\telse if (*it == '/') {\n\t\t\t++it;\n\t\t\tresult /= factor(it);\n\t\t}\n\t\telse break;\n\t}\n\treturn result;\n}\n\nint expression(State& it) {\n\tint result = term(it);\n\tfor (;;) {\n\t\tif (*it == '+') {\n\t\t\t++it;\n\t\t\tresult += term(it);\n\t\t}\n\t\telse if (*it == '-') {\n\t\t\t++it;\n\t\t\tresult -= term(it);\n\t\t}\n\t\telse break;\n\t}\n\treturn result;\n}\n\nint main () {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring line;\n\t\tcin >> line;\n\t\tState it = line.begin();\n\t\tcout << expression(it) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] > order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tif(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\n\tif(op.size()>=2){\n\t\tchar op1,op2;\n\t\top1=op.top();op.pop();op2=op.top();\n\t\top.push(op1);\n\t\tif(order[op1]<order[op2])\n\t\t\tcalc();\n\t}\n\tcout << num.top() << endl;//\n\tint tmp1=num.top();num.pop();\n\tcout << num.top() << endl;//\n\tint tmp2=num.top();num.pop();\n\tcout << num.top() << endl;//\n\tnum.push(tmp2);\n\tnum.push(tmp1);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> result;\n#define value first\n#define p second\n\nresult equation(const string &s, int p = 0);\nresult factor(const string &s, int p=0);\nresult term(const string &s, int p=0);\n\nresult equation(const string &s,int p) {\n    result r = factor(s,p);\n    while(s[r.p] == '+' || s[r.p] == '-') {\n        result r_ = factor(s, r.p+1);\n        if(s[r.p] == '+') r.value += r_.value;\n        else r.value -= r_.value;\n        r.p = r_.p;\n    }\n    return r;\n}\n\nresult factor(const string &s, int p) {\n    result r = term(s,p);\n    while(s[r.p] == '*' || s[r.p] == '/') {\n        result r_ = term(s, r.p+1);\n        if(s[r.p] == '*') r.value *= r_.value;\n        else r.value /= r_.value;\n        r.p = r_.p;\n    }\n    return r;\n}\n\nresult term(const string &s, int p) {\n    if(s[p] == '(') {\n        result r = equation(s,p+1);\n        r.p += 1;\n        return r;\n    }else{\n        int value = 0;\n        while(isdigit(s[p]))\n            value = value*10 + (s[p++] - '0');\n        return result(value,p);\n    }\n}\n\nint main() {\n    int n;\n    cin>>n;\n\n    string s;\n    for(int i=0; i<n; ++i) {\n        cin>>s;\n        result r = equation(s);\n        cout<<r.value<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\nint expression(State& begin);\nint term(State& begin);\nint number(State& begin);\nint factor(State& begin);\n\nint expression(State& begin) {\n    int ret = term(begin);\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else break;\n    }\n    return ret;\n}\n\nint term(State& begin) {\n    int ret = factor(begin);\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else break;\n    }\n    return ret;\n}\n\nint factor(State& begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint number(State& begin) {\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret = ret*10 + (*begin - '0');\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    cin.ignore();\n    for (int i = 0; i < n; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x);\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\tif (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\tif (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '(') {\n\t\t val1 = siki(str, i);\n\t\ti += 2;\n\t}\n\telse {\n\t\t val1 = number(str, i);\n\t}\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tval1 = val1 * 10;\n\t\t\tval1 += number(str, i);\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <math.h>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nstring S;\nsize_t cur;\nint parse();\n\nint digit(){\n    assert(isdigit(S[cur]));\n    int n=S[cur]-'0';\n    cur++;\n    return n;\n}\n\nint number(){\n    int n=digit();\n    while(cur<S.size()&&isdigit(S[cur]))\n\tn=n*10+digit();\n    return n;\n}\n\nint expression();\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\tassert(S[cur]==')');\n\tcur++;\n\treturn n;\n} \n\nint term1(){\n    int a=factor();\n    while(cur<S.size()&&S[cur]=='^'){\n\tcur++;\n\tint b=factor();\n\ta=pow(a,b);\n    }\n    return a;\n}\n\nint term2(){\n    int a=term1();\n    while(cur<S.size()&&(S[cur]=='*'||S[cur]=='/')){\n\t\tchar op=S[cur++];\n\t\tint b=term1();\n\t\tif(op=='*')a*=b; else a/=b;\n    }\n    return a;\n}\n\nint expression(){\n    int a=term2();\n    while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n\tchar op=S[cur++];\n\tint b=term2();\n\tif(op=='+')a+=b; else a-=b;\n    }\n    return a;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    while(cin>>S){\n\tcur=0;\n\tcout<<expression()<<endl;\n    }\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int n;\n    string q, a, sop;\n    stack<int> numstack;\n    stack<string> opstack;\n    map<string, int> oprank;\n\tvector<string> exq;\n    oprank[\"/\"] = oprank[\"*\"] = 2;\n    oprank[\"+\"] = oprank[\"-\"] = 1;\n\toprank[\"(\"] = 0;\n    cin >> n;\n    for(int i(0);i < n;++i){\n        cin >> q;\n\t\texq.clear();\n        a = \"\";\n        for(int j(0);j < q.length();++j){\n            if(q[j] < '0' || '9' < q[j]){\n                if(a.length() > 0) exq.push_back(a);\n                a = \"\";\n\t\t\t\tsop = string(1, q[j]);\n                if(opstack.empty()){\n\t\t\t\t\topstack.push(sop);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(sop == \")\"){\n\t\t\t\t\twhile(opstack.top() != \"(\"){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t\topstack.pop();\n\t\t\t\t}\n\t\t\t\telse if(sop == \"(\") opstack.push(sop);\n\t\t\t\telse if(sop == \"=\"){\n\t\t\t\t\twhile(!opstack.empty()){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(oprank[sop] <= oprank[opstack.top()]){\n\t\t\t\t\twhile(!opstack.empty() && oprank[sop] <= oprank[opstack.top()]){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t\topstack.push(sop);\n\t\t\t\t}\n\t\t\t\telse opstack.push(sop);\n            }\n            else a += q[j];\n        }\n\t\tfor(string s : exq){\n\t\t\tif(s[0] < '0' || '9' < s[0]){\n\t\t\t\tint x, y;\n\t\t\t\ty = numstack.top();\n\t\t\t\tnumstack.pop();\n\t\t\t\tx = numstack.top();\n\t\t\t\tnumstack.pop();\n\t\t\t\tif(s == \"+\"){\n\t\t\t\t\tnumstack.push(x + y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"-\"){\n\t\t\t\t\tnumstack.push(x - y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"*\"){\n\t\t\t\t\tnumstack.push(x * y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"/\"){\n\t\t\t\t\tnumstack.push(x / y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse numstack.push(stoi(s));\n\t\t}\n\t\tcout << numstack.top() << endl;\n\t\tnumstack.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\ninline int toInt(string s){int v;istringstream i(s);i>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream o;o<<x;return o.str();}\ntemplate<class T> void pv(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\nconst int INF = 1000000000;\nconst double EPS = 1e-10;\n\ntypedef string::const_iterator State;\n\nint express(State& p);\nint factor(State& p);\nint term(State &p);\nint number(State &p);\n\n// 足し算\nint express(State& p) {\n\tint r = term(p);\n\t\n\tfor(;;) {\n\t\tif(*p == '+') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr += rs;\n\t\t}\n\t\telse if(*p == '-') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr -= rs;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\n\n// 掛け算\nint term(State &p) {\n\tint r = factor(p);\n\t\n\tfor(;;) {\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr *= rs;\n\t\t}\n\t\telse if(*p == '/') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr /= rs;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\n// カッコ\nint factor(State &p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\tint ret = express(p);\n\t\tp++;\n\t\treturn ret;\n\t}\n\treturn number(p);\n}\n\nint number(State &p) {\n\t// if(*p == '(') return factor(p);\n\tint ret = 0;\n\t\n\twhile(isdigit(*p)) {\n\t\tret *= 10;\n\t\tret += *p - '0';\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tint N; cin >> N;\n\tcin.ignore();\n\twhile(N--) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tState p = line.begin();\n\t\tint ans = express(p);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\nstruct Parser\n{\n    int number(State &begin)\n    {\n        int ret = 0;\n        while(isdigit(*begin))\n        {\n            ret *= 10;\n            ret += (*begin - '0');\n            begin++;\n        }\n        return ret;\n    }\n    int factor(State &begin)\n    {\n        if(*begin == '(')\n        {\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        }\n        else return number(begin);\n    }\n    int term(State &begin)\n    {\n        int ret = factor(begin);\n        while(1)\n        {\n            if(*begin == '*')\n            {\n                begin++;\n                ret *= factor(begin);\n            }\n            else if(*begin == '/')\n            {\n                begin++;\n                ret /= factor(begin);\n            }\n            else break;\n        }\n        return ret;\n    }\n    int expression(State &begin)\n    {\n        int ret = term(begin);\n        while(1)\n        {\n            if(*begin == '+')\n            {\n                begin++;\n                ret += term(begin);\n            }\n            else if(*begin == '-')\n            {\n                begin++;\n                ret -= term(begin);\n            }\n            else break;\n        }\n        return ret;\n    }\n};\nsigned main()\n{\n    int N; cin >> N;\n    for(int i = 0; i < N; i++)\n    {\n        Parser ps;\n        string s; cin >> s;\n        State begin = s.begin();\n        int ans = ps.expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num;\nstack<char> op;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n \t\t\twhile(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\twhile(!op.empty())\n\t\tcalc();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint formula(string &s, int &i);\nint term(string &s, int &i);\nint factor(string &s, int &i);\nint number(string &s, int &i);\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint num = 0;\n\t\tcout << formula(s, num) << endl;\n\t}\n\n\treturn 0;\n}\n\nint formula(string &s, int &i) {\n\tint res = term(s, i);\n\tif (s[i] == '+') {\n\t\ti++;\n\t\treturn res + formula(s, i );\n\t}\n\tif (s[i] == '-') {\n\t\ti++;\n\t\treturn res - formula(s, i );\n\t}\n\treturn res;\n}\n\nint term(string &s, int &i) {\n\tint res = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tif (op == '*') {\n\t\t\tres *= factor(s, i);\n\t\t}\n\t\telse {\n\t\t\tres /= factor(s, i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint factor(string &s, int &i) {\n\tint res;\n\tif (s[i] == '(') {\n\t\ti++;\n\t\tres = formula(s, i);\n\t\ti++;\n\t}\n\telse {\n\t\tres = number(s, i);\n\t}\n\treturn res;\n}\n\nint number(string &s, int &i) {\n\tint res = 0;\n\tfor (; isdigit(s[i]); i++) {\n\t\tres = (s[i]-'0')+ res * 10;\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nint ex1(string input,int& i);\nint ex2(string input,int& i);\nint ex3(string input,int& i);\nint exnum(string input,int& i);\nint ex1(string input,int& i){\n  int a;\n  a=ex2(input,i);\n  if(input[i]=='+')\n    return a+ex1(input,++i);\n  else if(input[i]=='-')\n    return a-ex1(input,++i);\n  else return a;\n}\nint ex2(string input,int& i){\n  int a=ex3(input,i);\n  if(input[i]=='*')\n    return a*ex2(input,++i);\n  else if(input[i]=='/')\n    return a/ex2(input,++i);\n  else return a;\n}\nint ex3(string input,int& i){\n  int a;\n  if(input[i]=='('){\n    a=ex1(input,++i);\n    i++;\n  }\n  else a=exnum(input,i);\n  return a;\n}\nint exnum(string input,int &i){\n  int a=0;\n  while(isdigit(input[i])){\n    a*=10;\n    a+=input[i]-'0';\n    i++;\n  }\n  \n  return a;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  repn(k,n){\n    int i=0;\n    string input;\n    cin>>input;\n    cout<<ex1(input,i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint pos;\nstring str;\n\nint exp();\n\nint factor() {\n  if(str[pos] >= '0' && str[pos] <= '9') {\n    string tmp = \"\";\n    while(str[pos] >= '0' && str[pos] <= '9') {\n      tmp += str[pos++];\n    }\n    return atoi(tmp.c_str());\n  }\n\n  if(str[pos] == '(') {\n    pos++;\n    return exp();\n  } else if(str[pos] == ')') {\n    pos++;\n    return 0;\n  }\n}\n\nint term() {\n  int x = factor();\n  while(str[pos] == '*' || str[pos] == '/') {\n    if(str[pos] == '*') {\n      pos++;\n      x *= factor();\n    } else if(str[pos] == '/') {\n      pos++;\n      x /= factor();\n    }\n  }\n  return x;\n}\n\nint exp() {\n  int x = term();\n  while(str[pos] == '+' || str[pos] == '-') {\n    if(str[pos] == '+') {\n      pos++;\n      x += term();\n    } else if(str[pos] == '-') {\n      pos++;\n      x -= term();\n    }\n  }\n  return x;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    pos = 0;\n    cin >> str;\n    str = str.substr(0, str.length()-1);\n    cout << exp() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nstd::string S;\nsize_t i = 0;\nint32_t func()\n{\n\tint32_t tmpv = 0;\n\tint32_t tmpmulv;\n\tif (S[i] == '(') {\n\t\t++i;\n\t\ttmpmulv = func();\n\t\t++i;\n\t}\n\telse {\n\t\tint32_t nowv = 0;\n\t\twhile ('0' <= S[i] && S[i] <= '9') { nowv *= 10; nowv += S[i] - '0'; ++i; }\n\t\ttmpmulv = nowv;\n\t}\n\twhile (S[i] != ')')\n\t{\n\t\tchar ope = S[i];\n\t\t++i;\n\t\tint32_t nowv = 0;\n\t\tif (S[i] == '(') {\n\t\t\t++i;\n\t\t\tnowv = func();\n\t\t}\n\t\telse {\n\t\t\twhile ('0' <= S[i] && S[i] <= '9') { nowv *= 10; nowv += S[i] - '0'; ++i; }\n\t\t}\n\t\tif (ope == '+') {\n\t\t\ttmpv += tmpmulv;\n\t\t\ttmpmulv = nowv;\n\t\t}\n\t\telse if (ope == '-') {\n\t\t\ttmpv += tmpmulv;\n\t\t\ttmpmulv = -nowv;\n\t\t}\n\t\telse if (ope == '*') {\n\t\t\ttmpmulv *= nowv;\n\t\t}\n\t\telse if (ope == '/') {\n\t\t\ttmpmulv /= nowv;\n\t\t}\n\t}\n\t++i;\n\ttmpv += tmpmulv;\n\ttmpmulv = 1;\n\treturn tmpv;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tint32_t Q;\n\tin >> Q;\n\twhile (Q--)\n\t{\n\t\tin >> S;\n\t\tS.pop_back();\n\t\tS.push_back(')');\n\t\ti = 0;\n\t\tout << func() << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nstring s;\n\nint parse(int l, int r)\n{\n\tint k = 0;\n\tfor(int i = r - 1; i >= l; i--){\n\t\tif(s[i] == ')') k++;\n\t\tif(s[i] == '(') k--;\n\t\n\t\tif(!k && s[i] == '+') return parse(l, i) + parse(l+i, r);\n\t\tif(!k && s[i] == '-') return parse(l, i) - parse(l+i, r);\n\t}\n\t\n\tfor(int i = r - 1; i >= l; i--){\n\t\tif(s[i] == ')') k++;\n\t\tif(s[i] == '(') k--;\n\t\n\t\tif(!k && s[i] == '*') return parse(l, i) * parse(l+i, r);\n\t\tif(!k && s[i] == '/') return parse(l, i) / parse(l+i, r);\n\t}\n\t\n\tif(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n\t\n\treturn stoi(s.substr(l, r - l));\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> s;\n\t\tcout << parse(0, s.size() - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar stk[50], psh[50];\ndouble v[50];\nint pri[256], sp, pp;\n\nint calc(char *p) {\n  int i;\n  char *exp = p;\n  for (i = 0; i < 256; i++)\n    pri[i] = 3;\n  pri['+'] = pri['-'] = 1;\n  pri['*'] = pri['/'] = 2;\n  pri['('] = 4;\n  pri[')'] = 0;\n  stk[0] = 0;\n  pri[0] = -1;\n  sp = pp = 0;\n  while (*p != '\\0') {\n    while (pri[*p] <= pri[stk[sp]] && stk[sp] != '(')\n      psh[++pp] = stk[sp--];\n    if (*p != ')')\n      stk[++sp] = *p;\n    else\n      sp--;\n    p++;\n  }\n  for (i = sp; i > 0; i--)\n    psh[++pp] = stk[i];\n  sp = 0;\n  for (i = 1; i <= pp; i++) {\n    if ('0' <= psh[i] && psh[i] <= '9')\n      v[++sp] = psh[i] - '0';\n    else {\n      switch (psh[i]) {\n      case '+':\n        v[sp - 1] = v[sp - 1] + v[sp];\n        break;\n      case '-':\n        v[sp - 1] = v[sp - 1] - v[sp];\n        break;\n      case '*':\n        v[sp - 1] = v[sp - 1] * v[sp];\n        break;\n      case '/':\n        v[sp - 1] = v[sp - 1] / v[sp];\n        break;\n      }\n      sp--;\n    }\n  }\n  printf(\"%d\\n\",(int)v[1]);\n}\nint main() {\n  int i, j, n;\n  char p[50][100];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++)\n    scanf(\"%s\", p[i]);\n  for (i = 0; i < n; i++)\n    for (j = 0; j < 100; j++)\n      if (p[i][j] == '=')\n        p[i][j] = '\\0';\n  for (i = 0; i < n; i++)\n    calc(p[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ninline bool is_op(string &in) {\n\tif (in.size() == 1 && !isdigit(in[0]))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ninline bool is_num(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline bool is_expr(string &in)\n{\n\tif (!is_num(in) && !is_op(in)) { return true; }\n\telse { return false; }\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\treturn(stoi(in[0]));\n}\nint main()\n{\n\t/*string tmp = \"(-2*2)*5+(1+2)*(3+4)\";\n\tauto out=split(tmp);\n\tfor (auto i : out) {\n\t\tcout << i << endl;\n\t}\n\tcout << cal(tmp) << endl;*/\n\tstring input;\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n/*\n    Expr = Term {'+'|'-' Term}*\n    Term = Fact {'*'|'/' Fact}*\n    Fact = Number | '(' Expr ')'\n*/\n\nint Fact(int*, std::string);\nint Term(int*, std::string);\nint Expr(int*, std::string);\n\nint Fact(int* pos, std::string s) {\n    int res = 0;\n    if(s[*pos] == '(') {\n        *pos += 1;\n        res = Expr(pos, s);\n        *pos += 1;\n    } else {\n        while(*pos < s.length() && s[*pos] >= '0' && s[*pos] <= '9') {\n            res *= 10;\n            res += (int)(s[*pos] - '0');\n            *pos += 1;\n        }\n    }\n    return res;\n}\n\nint Term(int* pos, std::string s) {\n    int fact = Fact(pos, s);\n    if(*pos >= s.length()) return fact;\n    while( *pos < s.length() && (s[*pos] == '*' || s[*pos] == '/') ) {\n        char op = s[*pos];\n        *pos += 1;\n\n        int nfact = Fact(pos, s);\n        if(op == '*') {\n            fact *= nfact;\n        } else {\n            fact /= nfact;\n        }\n    }\n    return fact;\n}\n\nint Expr(int* pos, std::string s) {\n    int term = Term(pos, s);\n    if(*pos >= s.length()) return term;\n    while( *pos < s.length() && (s[*pos] == '+' || s[*pos] == '-') ) {\n        char op = s[*pos];\n        *pos += 1;\n\n        int nterm = Term(pos, s);\n        if(op == '+') {\n            term += nterm;\n        } else {\n            term -= nterm;\n        }\n    }\n    return term;\n}\n\nint main() {\n    int N;\n    std::string str;\n    std::cin >> N;\n    REP(i, N) {\n        int pos = 0;\n        std::cin >> str;\n        std::cout << Expr(&pos, str) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0');return m?-n:n;} //&&c<='9'\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nstruct calc {\n\tchar c;\n\n\tcalc() {\n\t\tc = gcu();\n\t}\n\n\tbool consume(char e) {\n\t\tif (c != e)\n\t\t\treturn false;\n\t\telse {\n\t\t\tc = gcu();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tint number() {\n\t\tif (isdigit(c)) {\n\t\t\tint d;\n\t\t\tungetc(c, stdin);\n\t\t\tscanf(\"%d\", &d);\n\t\t\tc = gcu();\n\t\t\treturn d;\n\t\t} else {\n\t\t\tfprintf(stderr,\"ERROR: expected number\\n, but got %c\\n\", c);\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tint mul() {\n\t\tint a = term();\n\t\tfor (;;)\n\t\t\tif (consume('*'))\n\t\t\t\ta *= term();\n\t\t\telse if (consume('/'))\n\t\t\t\ta /= term();\n\t\t\telse\n\t\t\t\treturn a;\n\t}\n\n\tint add() {\n\t\tint a = mul();\n\t\tfor (;;)\n\t\t\tif (consume('+'))\n\t\t\t\ta += mul();\n\t\t\telse if (consume('-'))\n\t\t\t\ta -= mul();\n\t\t\telse\n\t\t\t\treturn a;\n\t}\n\n\tint term() {\n\t\tif (consume('(')) {\n\t\t\tint a = add();\n\t\t\tconsume(')');\n\t\t\treturn a;\n\t\t} else\n\t\t\treturn number();\n\t}\n\n\n\tint exec() {\n\t\tint n = add();\n\t\tif (consume('='))\n\t\t\treturn n;\n\t\telse {\n\t\t\tfprintf(stderr,\"ERROR: expected =, but got %c\\n\", c);\n\t\t\texit(0);\n\t\t}\n\t}\n};\n\nint main() {\n\tfor (int n = in(); n; n--) {\n\t\tcalc c = calc();\n\t\toutl(c.exec());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\n\nbool isnum(string s){\n  for(int i = 1; i < s.length(); i++)\n    if('0' > s[i] || s[i] > '9') return false;\n  \n  return true;\n}\n\nint solve(string s){\n  // cout << s << endl;\n  if(isnum(s)){\n    stringstream ss;\n    int tmp;\n    if(s[0] == '-'){\n      ss << s.substr(1);\n      ss >> tmp;\n      return -1*tmp;\n    }else{\n      ss << s;\n      ss >> tmp;\n      return tmp;\n    }\n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n\n      if((s[i] == '+' || s[i] == '-') && i && para == 0)\n\tif(s[i] == '+') return solve(s.substr(0,i))+solve(s.substr(i+1));\n\telse return solve(s.substr(0,i))-solve(s.substr(i+1));\n    }\n\n    para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n      \n      if((s[i] == '*' || s[i] == '/') && para == 0 && i)\n\tif(s[i] == '*') return solve(s.substr(0,i))*solve(s.substr(i+1));\n\telse return solve(s.substr(0,i))/solve(s.substr(i+1));\n    }\n\n    if(s[0] == '(' && s[s.length()-1] == ')')\n      return solve(s.substr(1,s.length()-2));\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    string s;\n    cin >> s;\n    cout << solve(s.substr(0,s.length()-1)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath> // ??????\n \n#define REP(i,n) for(int i = 0; i < n; i++)\n \nusing namespace std;\n \nstruct FourArithmeticOperationParser {\n    \n    int pos;\n    bool div_zero;\n    string Formula;\n    const long long INF = 0x7fffffffffffffff;\n    \n    long long operator () (string F) {\n        pos = 0;\n        div_zero = false;\n        Formula = F;\n        long long ret = expr();\n        return div_zero ? INF : ret;\n    }\n    \n    long long number() {\n        long long ret = 0;\n        while (pos != Formula.size()) {\n            if (Formula[pos] < '0' || Formula[pos] > '9') {\n                break;\n            } else {\n                ret *= 10;\n                ret += (Formula[pos++] - '0');\n            }\n        }\n        return ret;\n    }\n    \n    long long expr() {\n        long long x = term();\n        while (pos < Formula.size()) {\n            switch (Formula[pos]) {\n                case '+':\n                    pos++;\n                    x += term();\n                    continue;\n                case '-':\n                    pos++;\n                    x -= term();\n                    continue;\n            }\n            break;\n        }\n        return x;\n    }\n    \n    long long term() {\n        long long x = factor();\n        while (pos < Formula.size()) {\n            switch (Formula[pos]) {\n                case '*':\n                    pos++;\n                    x *= factor();\n                    continue;\n                case '/':\n                    pos++;\n                    long long div = factor();\n                    if (div == 0) {\n                        div_zero = true;\n                    } else {\n                        x /= div;\n                    }\n                    continue;\n            }\n            break;\n        }\n        return x;\n    }\n    \n    long long factor() {\n        if (pos < Formula.size()) {\n            if (Formula[pos] == '(') {\n                pos++;\n                long long ret = expr();\n                if (Formula[pos] == ')') {\n                    pos++;\n                }\n                return ret;\n            }\n        }\n        return number();\n    }\n    \n};\n \nint main() {\n    \n    int N; cin >> N;\n    REP(i,N) {\n        string s; cin >> s;\n        cout << FourArithmeticOperationParser()(s.substr(0,s.size() - 1)) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nstring s;\nint p;\nint eq();\nint factor();\nint term();\nint eq()\n{\n    int res = factor();\n    for (;;)\n    {\n        if (s[p] == '+')\n        {\n            ++p;\n            res += factor();\n        }\n        else if (s[p] == '-')\n        {\n            ++p;\n            res -= factor();\n        }\n        else\n            break;\n    }\n    return res;\n}\nint factor()\n{\n    int res = term();\n    for (;;)\n    {\n        if (s[p] == '*')\n        {\n            ++p;\n            res *= term();\n        }\n        else if (s[p] == '/')\n        {\n            ++p;\n            res /= term();\n        }\n        else\n            break;\n    }\n    return res;\n}\nint term()\n{\n    if (s[p] == '(')\n    {\n        ++p;\n        int res = eq();\n        ++p;\n        return res;\n    }\n    else if (isdigit(s[p]))\n    {\n        int res = 0;\n        while (isdigit(s[p]))\n        {\n            res = 10*res + (s[p] - '0');\n            ++p;\n        }\n        return res;\n    }\n    else\n        assert(false);\n}\nint main()\n{\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        cin >> s;\n        p = 0;\n        \n        cout << eq() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work,count;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nchar *pt;\nint parseAtom();\nint parseExpr();\nint parseTerm();\nint parseAtom() {\n  if('0' <= *pt && *pt <= '9') {\n    int x = *pt-'0';\n    pt++;\n    while('0' <= *pt && *pt <= '9') {\n      x = x*10 + *pt-'0';\n      pt++;\n    }\n    return x;\n  }\n  if('(' == *pt) {\n    pt++;\n    int x = parseExpr();\n    assert(*pt == ')');\n    pt++;\n    return x;\n  }\n  assert(false);\n  return -1;\n}\nint parseExpr() {\n  int x = parseTerm();\n  while(*pt == '+' || *pt == '-') {\n    if(*pt == '+') {\n      pt++;\n      x += parseTerm();\n    } else {\n      pt++;\n      x -= parseTerm();\n    }\n  }\n  return x;\n}\nint parseTerm() {\n  int x = parseAtom();\n  while(*pt == '*' || *pt == '/') {\n    if(*pt == '*') {\n      pt++;\n      x *= parseAtom();\n    } else {\n      pt++;\n      x /= parseAtom();\n    }\n  }\n  return x;\n}\n\nint main() {\n  int tc; scanf(\"%d\", &tc);\n  for(int tci = 0; tci < tc; tci++) {\n    static char expr[200]; scanf(\" %s\", expr);\n    pt = expr;\n    int x = parseExpr();\n    assert(*pt == '=');\n    printf(\"%d\\n\", x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\ntypedef pair<int, int> result;\n#define value first\n#define p second\n\nresult equation(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n\tresult r = factor(s, p);\n\twhile( s[r.p] == '+' || s[r.p] == '-' ){\n\t\tresult r_ = factor(s, r.p+1);\n\t\tif( s[r.p] == '+' )\n\t\t\tr.value += r_.value;\n\t\telse\n\t\t\tr.value -= r_.value;\n\t\tr.p = r_.p;\n\t}\n\treturn r;\n}\n\nresult factor(const string &s, int p) {\n\tresult r = term(s, p);\n\twhile( s[r.p] == '*' || s[r.p] == '/' ) {\n\t\tresult r_ = term(s, r.p+1);\n\t\tif( s[r.p] == '*' )\n\t\t\tr.value *= r_.value;\n\t\telse\n\t\t\tr.value /= r_.value;\n\t\tr.p = r_.p;\n\t}\n\treturn r;\n}\n\nresult term(const string &s, int p) {\n\tif( s[p] == '(' ) {\n\t\tresult r = equation(s, p+1);\n\t\tr.p += 1; // skip ')'\n\t\treturn r;\n\t}else{\n\t\tint value = 0;\n\t\twhile ( isdigit(s[p]) )\n\t\t\tvalue = value * 10 + (s[p++] - '0');\n\t\treturn result(value, p);\n\t}\n}\n\nint main() {\n\tstring s;\n\tint n;\n\tcin >> n;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tcin >> s;\n\t\tresult r = equation( s );\n\t\tcout << r.value << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint exp();\nint term();\nint factor();\nstring str;\nint p;\n\nint factor(){\n  int val=0;\n  while(str[p]>='0' && str[p]<='9'){ \n    val*=10;\n    val+=str[p]-'0';\n    p++;\n  }\n  if(val!=0) return val;\n  else  if(str[p]=='('){\n    p++;\n    val=exp();\n  }\n  if(str[p]==')'){\n    p++;\n  return val;\n  }\n\nif(val==0) return 0;\n}\n\nint term(){\n  int val=factor();\n  while(str[p]=='*' || str[p]=='/'){\n  if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n }\n return val;\n}\n\nint exp(){\n  int val=term();\n  while(str[p]=='+' || str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\n\n\nint main(){\n  int n;\n  \n  cin>>n;\n  for(int i=0;i<n;i++){\n    p=0;\n    cin>>str;\n    cout<<exp()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\tcout << num.top() << endl;//\n\tint tmp=num.top();num.pop();\n\tcout << num.top() << endl;//\n\tnum.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define State string::const_iterator\nclass ParseError {};\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while(true){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State &begin) {\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// 数字の列をパースして、その数を返す。\nint number(State &begin) {\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす。\n        int ret = expression(begin);\n        begin++; // ')'を飛ばす。\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint main() {\n\n    int n;\n\n    cin >> n;\n\n    while(n--){\n\n        string input;\n\n        cin >> input;\n\n        State s = input.begin();\n\n        cout << expression(s) << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep1(i,n) for(ll i=1;i<=(ll)(n);i++)\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(ll i=(ll)(n);i>0;i--)\n#define REP(i,a,b) for(ll i=(ll)a;i<(ll)b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nll number(State&);\nll factor(State&);\nll term(State&);\nll expression(State&);\n\nll number(State &begin) {\n  ll ret = 0;\n  while (isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nll factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす。\n        ll ret = expression(begin);\n        begin++; // ')'を飛ばす。\n    } else {\n        return number(begin);\n    }\n}\n\nll term(State &begin) {\n  ll ret = factor(begin);\n  for (;;) {\n    if (*begin == '*') {\n      begin++;\n      ret *= factor(begin);\n    }\n    else if (*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    }\n    else {\n      break;\n    }\n  }\n  return ret;\n}\n\nll expression(State &begin) {\n  ll ret = term(begin);\n  for (;;) {\n    if (*begin == '+') {\n      begin++;\n      ret += term(begin);\n    }\n    else if (*begin == '-') {\n      begin++;\n      ret -= term(begin);\n    }\n    else {\n      break;\n    }\n  }\n  return ret;\n}\n\n\nint main () {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    State begin = s.begin();\n    ll ans = expression(begin);\n    cout << ans << endl;\n  }\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint64 exp(string&, int32&);\nint64 term(string&, int32&);\nint64 fact(string&, int32&);\nint64 number(string&, int32&);\n\nint64 exp(string& s, int32& p){\n\tint64 ret = term(s, p);\n\twhile(p < s.size()){\n\t\tif(s[p] == '+'){\n\t\t\tp++;\n\t\t\tret += term(s, p);\n\t\t}else if(s[p] == '-'){\n\t\t\tp++;\n\t\t\tret -= term(s, p);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint64 term(string& s, int32& p){\n\tint64 ret = fact(s, p);\n\twhile(p < s.size()){\n\t\tif(s[p] == '*'){\n\t\t\tp++;\n\t\t\tret *= fact(s, p);\n\t\t}else if(s[p] == '/'){\n\t\t\tp++;\n\t\t\tret /= fact(s, p);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint64 fact(string& s, int32& p){\n\tint64 ret = 0;\n\tif(s[p] == '('){\n\t\tp++;\n\t\tret = exp(s, p);\n\t\tp++;\n\t}else{\n\t\tret = number(s, p);\n\t}\n\treturn ret;\n}\n\nint64 number(string& s, int32& p){\n\tint64 ret = 0;\n\twhile(isdigit(s[p])){\n\t\tret = ret*10+s[p]-'0';\n\t\tp++;\n\t}\n\treturn ret;\n}\nint main(void){\n\tint32 N;\n\tcin >> N;\n\n\tREP(i, N){\n\t\tstring s;\n\t\tint32 p = 0;\n\t\tcin >> s;\n\t\tcout << exp(s, p) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nusing State = string::const_iterator;\nclass ParseError {};\n\nint number(State& begin) {\n    int ret = 0;\n    while ('0' <= *begin and *begin <= '9') {\n        ret *= 10;\n        ret += *begin - '0';\n        ++begin;\n    }\n    return ret;\n}\n\nint expression(State& begin);\n\nint factor(State& begin) {\n    if (*begin == '(') {\n        ++begin;\n        int ret = expression(begin);\n        if (*begin != ')') {\n            throw ParseError();\n        }\n        ++begin;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint term(State& begin) {\n    int prod = factor(begin);\n    while (true) {\n        if (*begin == '*') {\n            ++begin;\n            prod *= factor(begin);\n        }\n        else if (*begin == '/') {\n            ++begin;\n            prod /= factor(begin);\n        }\n        else {\n            return prod;\n        }\n    }\n}\n\nint expression(State& begin) {\n    int sum = term(begin);\n    while (true) {\n        if (*begin == '+') {\n            ++begin;\n            sum += term(begin);\n        } else if (*begin == '-') {\n            ++begin;\n            sum -= term(begin);\n        } else {\n            return sum;\n        }\n    }\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n\n    int n; cin >> n;\n    while (n--) {\n        string s; cin >> s;\n        State begin = s.begin();\n        cout << expression(begin) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    bool f=false;\n    if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    if(s[pos]=='('){\n      pos++;\n      return getAns();\n    }\n    int res=head2Num();\n    if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }else{\n      return res;\n    }\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nint parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')')\n\t\treturn parse(s.substr(1,s.length()-2));\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=0,d=0;i<s.length();i++){\n\t\tif     (s[i]=='(')\td++;\n\t\telse if(s[i]==')')\td--;\n\n\t\tif(d==0 && prior[s[i]]!=0){\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoi(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <math.h>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nstring S;\nsize_t cur=0;\nint parse();\n\nint digit(){\n    assert(isdigit(S[cur]));\n    int n=S[cur]-'0';\n    cur++;\n    return n;\n}\n\nint number(){\n    int n=digit();\n    while(cur<S.size()&&isdigit(S[cur]))\n\tn=n*10+digit();\n    return n;\n}\n\nint expression();\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\tassert(S[cur]==')');\n\tcur++;\n\treturn n;\n}\n\nint term(){\n    int a=factor();\n    while(cur<S.size()&&(S[cur]=='*'||S[cur]=='/')){\n\t\tchar op=S[cur++];\n\t\tint b=factor();\n\t\tif(op=='*')a*=b; else a/=b;\n    }\n    return a;\n}\n\nint expression(){\n    int a=term();\n    while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n\tchar op=S[cur++];\n\tint b=term();\n\tif(op=='+')a+=b; else a-=b;\n    }\n    return a;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    while(cin>>S){\n\tcur=0;\n\tcout<<expression()<<endl;\n    }\n} "
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](string s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint lp=0;\nint solve(string str){\n    vector<int>op;\n    vector<char>ope;\n    //cout<<str.length()<<endl;\n    cout<<\"str: \"<<str<<endl;\n    int i=0;\n    if(str[0]=='-'){\n        i++;\n        int g=0;\n        while(str[i]>='0'&&str[i]<='9'){\n            g=g*10+str[i]-'0';\n            i++;\n        }\n        op.push_back(g*(-1));\n        if(ope.size())\n            if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                int a=op[op.size()-1];\n                op.pop_back();\n                int b=op[op.size()-1];\n                op.pop_back();\n                if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                else op.push_back(b/a);\n                ope.pop_back();\n            }\n        if(str[i])ope.push_back(str[i]);\n    }\n    for(;i<str.length();i++){\n        //cout<<\"KK\";\n        if(str[i]=='('){\n            string t;\n            i++;\n            lp++;\n            while(lp){\n                t+=str[i];\n                i++;\n                if(str[i]=='(')lp++;\n                if(str[i]==')')lp--;\n            }\n            i++;\n            op.push_back(solve(t));\n            //cout<<\"(): \"<<ope[ope.size()-1]<<endl;\n            if(ope.size())\n            if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                int a=op[op.size()-1];\n                op.pop_back();\n                int b=op[op.size()-1];\n                op.pop_back();\n                if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                else op.push_back(b/a);\n                ope.pop_back();\n            }\n            if(str[i])ope.push_back(str[i]);\n        }\n        else if(str[i]>='0'&&str[i]<='9'){\n            int g=0;\n            while(str[i]>='0'&&str[i]<='9'){\n                g=g*10+str[i]-'0';\n                i++;\n            }\n            op.push_back(g);\n            if(ope.size())\n                if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                    int a=op[op.size()-1];\n                    op.pop_back();\n                    int b=op[op.size()-1];\n                    op.pop_back();\n                    if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                    else op.push_back(b/a);\n                    ope.pop_back();\n                }\n            if(str[i])ope.push_back(str[i]);\n        }\n    }\n    cout<<\"!\"<<endl;\n    int las=op[op.size()-1];\n    op.pop_back();\n    while(ope.size()){\n        cout<<\"las: \"<<las<<endl;\n        char c=ope[ope.size()-1];\n        ope.pop_back();\n        if(c=='=')continue;\n        int pre=op[op.size()-1];\n        cout<<\"pre: \"<<pre<<endl;\n        cout<<ope.size()<<\"   c: \"<<c<<endl;\n        op.pop_back();\n        if(c=='+')las=las+pre;\n        else las=pre-las;\n    }\n    cout<<\"returned : \"<<las<<endl;\n    return las;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        string str;\n        cin>>str;\n        cout<<solve(str)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <string>\n#include <cctype>\n#include<iostream>\n#include<map>\n#include<sstream>\nusing namespace std;\nistream* input;\nint no_of_errors;\nenum Token_value {\n  END,NUMBER,PLUS='+',MINUS='-',MUL='*',DIV='/',\n  PRINT=';',ASSIGN='=',LP='(',RP=')'\n};\nToken_value curr_tok = PRINT;\nint number_value;\nstring string_value;\nToken_value get_token()\n{\n  char ch;\n  do {\n    if(!input->get(ch)) return curr_tok = END;\n  } while (ch!='\\n' && isspace(ch));\n \n  switch (ch) {\n  case ';':\n  case '\\n':\n    return curr_tok=PRINT;\n  case '*':\n  case '/':\n  case '+':\n  case '-':\n  case '(':\n  case ')':\n  case '=':\nreturn curr_tok=Token_value(ch);\n  case '0': case '1': case '2': case '3': case '4':\ncase '5': case '6': case '7': case '8': case '9':\n    input->putback(ch);\n    *input >> number_value;\n    return curr_tok=NUMBER;\n  }\n}\nint expr(bool);\nint prim(bool get)\n{\n  if (get) get_token();\n  switch (curr_tok) {\n  case NUMBER:\n    { int v = number_value;\n      get_token();\n      return v;\n    }\n  case MINUS:\n    return -prim(true);\n  case LP:\n    { int e = expr(true);\n      get_token();\n      return e;\n    }\n  }\n}\nint term(bool get)\n{\n  int left = prim(get);\n  for (;;)\n    switch (curr_tok) {\n    case MUL:\n      left *= prim(true);\n      break;\n    case DIV:\n      if (int d = prim(true)) {\nleft /= d;\nbreak;\n      }\n    default:\n      return left;\n    }\n}\nint expr(bool get)\n{\n  int left = term(get);\n  for (;;)\n    switch (curr_tok) {\n    case PLUS:\n      left += term(true);\n      break;\n    case MINUS:\n      left -= term(true);\n      break;\n    default:\n      return left;\n    }\n}\nint main()\n{\n  int n;\n  input = &cin;\n  cin>>n;\n  while(n--){\n    while (*input) {\n      get_token();\n      if (curr_tok == END) break;\n      if (curr_tok == PRINT) continue;\n      cout << expr(false) << '\\n';\n    }\n  }\n  return no_of_errors;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint digit(){\n  return S[cur++]-'0';\n}\n\nint number(){\n  int n=digit();\n  while(cur<S.size()&&isdigit(S[cur])){\n    n=n*10+digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor(){\n  if(isdigit(S[cur]))return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint term(){\n  int t=factor();\n  for(;cur<S.size()&&(S[cur]=='*'||S[cur]=='/');){\n    if(S[cur++]=='*')t*=factor();\n\telse t/=factor();\n  }\n  return t;\n}\n\nint expression(){\n  int t=term();\n  for(;cur<S.size()&&(S[cur]=='+'||S[cur]=='-');){\n    if(S[cur++]=='+')t+=term();\n\telse t-=term();\n  }\n  return t;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  for(;n--;){\n    cin>>S;\n\tcout<<expression()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nbool is_digit(char c){return '0' <= c && c <= '9';}\nstring i2s(int i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\n\nstring parse(int i, string s) {\n  //cout<<s<<endl;\n  bool flag = true;\n  \n  // brace\n  if (s.find('(') != -1) {\n    // æª©ç`FbNµÄA')'Éoï¤êÆ\n    // »¤ÅÈ¢êÉª¯é\n    bool mode = true;\n    REP(j,s.find('(')+1, s.size()) {\n      if (s[j] == ')') break;\n      if (s[j] == '(') {\n        mode = false;\n        break;\n      }\n    }\n    // ÊÌÊuðæ¾·é\n    int lbr = s.find('('), rbr;\n    if (mode) {\n      rbr = s.find(')');\n    } else {\n      for(int j=s.size()-1;j>=0;j--) if (s[j] == ')') {\n        rbr = j; break;\n      }\n    }\n    // ÊàÌvZðæÉs¤½ßÉssð¾é\n    string inner = parse(0, s.substr(lbr+1, rbr-lbr-1));\n    // ÊàðÁ·é\n    s.erase(lbr, rbr-lbr+1);\n    s.insert(lbr, inner);\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '*' || s[i] == '/') {\n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    while (is_digit(s[li]) && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    if (s[i] == '*') {\n      res = lhs * rhs;\n    } else {\n      res = lhs / rhs;\n    }\n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    flag = false;\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '+' || s[i] == '-') {\n    if (s[i] == '-' && i == 0) continue; \n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    while (is_digit(s[li]) && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    if (s[i] == '+') {\n      res = lhs + rhs;\n    } else {\n      res = lhs - rhs;\n    }\n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    flag = false;\n    return parse(0, s);\n  }\n  \n  return s;\n}\n\nvoid solve() {\n  string s; cin>>s;\n  s = s.substr(0, s.size()-1);\n  cout<<parse(0, s)<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  int n; cin>>n;\n  rep(i,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???2:negFLG?°???\\???\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\t/*\n\t * ????????????????????¬??§???)??????????????§???????????????????????????????????????\n\t * ??°?????????????????????????????????????????????????????????????????????????????????????¨?????????????????????????\n\t * )????????????????????????????????¬??§?????????????????§<<???????????§>>?¨??????????\n\t * ?????¨?????°???6-8+6 ????§£???4??§??????????????????????????????????????????????????¨6-(8+6)??§-8????????£????????????\n\t * ????????§?????°?????¨?????????????????????????????????????????´?????????????????§?¨??????????\t *\n\t */\n\n\tint n,tmp,op1,work,count;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\t//?????????-???????????????????????????WA??¨?????????????????§?????????\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){ //??°????????´???\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t\t}else{ //??°?????§????????´???\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){ //???????????????????????????????????????????????????????????????????¨???????????????????\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\t//?¬???????-??§????????´?????¨???????????????????????????????????§????????´???????????\\??????????????°????????????!!\n\t\t\t\t\tif(line[k+1] >= '0' && line[k+1] <= '9'){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else if(line[k+1] == '('){\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\n\t\t\t\t\t/*if(k == 0){\n\t\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n*/\n\t\t\t\t}else if(line[k] == ')'){ //????????????????????§???????????¬??§?????§????????????????????????????????????????????¨????????????????????§??¨???!!!! 8*(2+3)/4= ??????\n\n\t\t\t\t\t//????????£???:??????????????????????????????????????????????????¬??§?????§????????????????????¨??°???????????????????????????\n\t\t\t\t\twork = NUM.top(); //???????????°????????°???????????????????????°??????????????????1??????\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\t//????????¬??§?????°????????????????????????\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count == 0){ // 123*(-1)+122= ?????????????????????\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//??????????????????????????§?????????????????????\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//??????????????§work_num??¨work_op?????????empty????????£???????????????\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work); //?????????????????¬??¶????????????????????????\n\n\t\t\t\t}else{\t//line[k] == '=' ????????????????????§???????????¬??§?????§????????????????????????????????????????????¨????????????????????§??¨???!!!! 8*(2+3)/4= ??????\n\t\t\t\t\t//????????£???:??????????????????????????????????????????????????¬??§?????§????????????????????¨??°???????????????????????????\n\t\t\t\t\twork = NUM.top(); //???????????°????????°???????????????????????°??????????????????1??????\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\t//??????????????????????????§?????????????????????\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t//??????????????§work_num??¨work_op?????????empty????????£???????????????\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\npair<ll, const char*> expr(const char*);\npair<ll, const char*> term(const char*);\npair<ll, const char*> fact(const char*);\n\npair<ll, const char*> expr(const char* p) {\n  pair<ll, const char*> lhs = term(p);\n  ll ret = lhs.first;\n  const char* q = lhs.second;\n  while (*q == '+' || *q == '-') {\n    pair<ll, const char*> rhs = term(q + 1);\n    if (*q == '+') { ret += rhs.first; }\n    else { ret -= rhs.first; }\n    q = rhs.second;\n  }\n  return make_pair(ret, q);\n}\n\npair<ll, const char*> term(const char* p) {\n  pair<ll, const char*> lhs = fact(p);\n  ll ret = lhs.first;\n  const char* q = lhs.second;\n  while (*q == '*' || *q == '/') {\n    pair<ll, const char*> rhs = fact(q + 1);\n    if (*q == '*') { ret *= rhs.first; }\n    else { ret /= rhs.first; }\n    q = rhs.second;\n  }\n  return make_pair(ret, q);\n}\n\npair<ll, const char*> fact(const char* p) {\n  if (*p == '(') {\n    pair<ll, const char*> inside = expr(p + 1);\n    return make_pair(inside.first, inside.second + 1);\n  } else {\n    ll ret = 0;\n    const char* q;\n    for (q = p; '0' <= *q && *q <= '9'; ++q) {\n      ret *= 10;\n      ret += *q - '0';\n    }\n    return make_pair(ret, q);\n  }\n}\n\nint main() {\n  int T; scanf(\"%d\", &T);\n  while (T--) {\n    char buffer[128]; scanf(\"%s\", buffer);\n    pair<ll, const char*> ret = expr(buffer);\n    printf(\"%lld\\n\", ret.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring str;\nint cur = 0;\n\nint expression();\nint term();\nint factor();\n\nint expression();\n\nint digit() {\n    int a = str[cur] - '0';\n    cur++;\n    return a;\n}\n\nint number() {\n    int a = digit();\n    while (cur < str.size() && isdigit(str[cur])) {\n        a = a * 10 + digit();\n    }\n    return a;\n}\n\nint expression() {\n    int a = term();\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        if (str[cur] == '+') {\n            cur++;\n            int b = term();\n            a += b;\n        } else if (str[cur] == '-') {\n            cur++;\n            int b = term();\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint term() {\n    int a = factor();\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        if (str[cur] == '*') {\n            cur++;\n            int b = factor();\n            a *= b;\n        } else if (str[cur] == '/') {\n            cur++;\n            int b = factor();\n            a /= b;\n        }\n    }\n    return a;\n}\n\nint factor() {\n    if (str[cur] != '(') return number();\n    cur++;\n    int a = expression();\n    cur++;\n    return a;\n}\n\nint main() {\n    int N = 0;\n    cin>>N;\n    for (int n = 0; n < N; n++) {\n        cin>>str;\n        cur = 0;\n        cout<<expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint p=0;\nint formula(string& s);\n\nint num(string& s){\n    int res=0;\n    int op=1;\n    if(s[p]=='-'){\n        op=-1;\n        p++;\n    }\n    else if(s[p]=='+'){\n        op=1;\n        p++;\n    }\n    while(isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return op*res;\n}\n\nint term(string & s){\n    if(s[p]=='('){\n        p++;\n        int res=formula(s);\n        p++;\n        return res;\n    }\n    return num(s);\n}\n\nint section(string& s){\n    int res=term(s);\n    while(p!=s.size() && s[p]!=')' && s[p]!='+' && s[p]!='-'){\n        char op=s[p];\n        p++;\n        int next=term(s);\n        if(op=='*') res*=next;\n        else res/=next;\n    }\n    return res;\n}\n\nint formula(string& s){\n    int res=section(s);\n    while(p!=s.size() && s[p]!=')'){\n        char op=s[p];\n        p++;\n        int next=section(s);\n        if(op=='+') res+=next;\n        else res-=next;\n    }\n    return res;\n}\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        string s;\n        cin>>s;\n        s.pop_back();\n        p=0;\n        cout<<formula(s)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  try {\n    while (isdigit(s.peek())) {\n      val *= 10;\n      val += s.peek() - '0';\n      s.next();\n    }\n  } catch (const std::string &) {}\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nbool is_digit(char c){return '0' <= c && c <= '9';}\nstring i2s(int i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\n\nstring parse(int i, string s) {\n  //cout<<s<<endl;\n  bool flag = true;\n  \n  // brace\n  if (s.find('(') != -1) {\n    // æª©ç`FbNµÄA')'Éoï¤êÆ\n    // »¤ÅÈ¢êÉª¯é\n    bool mode = true;\n    REP(j,s.find('(')+1, s.size()) {\n      if (s[j] == ')') break;\n      if (s[j] == '(') {\n        mode = false;\n        break;\n      }\n    }\n    // ÊÌÊuðæ¾·é\n    int lbr = s.find('('), rbr;\n    if (mode) {\n      rbr = s.find(')');\n    } else {\n      for(int j=s.size()-1;j>=0;j--) if (s[j] == ')') {\n        rbr = j; break;\n      }\n    }\n    // ÊàÌvZðæÉs¤½ßÉssð¾é\n    string inner = parse(0, s.substr(lbr+1, rbr-lbr-1));\n    // ÊàðÁ·é\n    s.erase(lbr, rbr-lbr+1);\n    s.insert(lbr, inner);\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '*' || s[i] == '/') {\n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    while (is_digit(s[li]) && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    \n    if (lhs == 0 || rhs == 0) {\n      res = 0;\n    } else {\n      if (s[i] == '*') {\n        res = lhs * rhs;\n      } else {\n        res = lhs / rhs;\n      }\n    }\n    \n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    flag = false;\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '+' || s[i] == '-') {\n    if (s[i] == '-' && i == 0) continue; \n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    while (is_digit(s[li]) && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    if (s[i] == '+') {\n      res = lhs + rhs;\n    } else {\n      res = lhs - rhs;\n    }\n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    flag = false;\n    return parse(0, s);\n  }\n  \n  return s;\n}\n\nvoid solve() {\n  string s; cin>>s;\n  s = s.substr(0, s.size()-1);\n  cout<<parse(0, s)<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  int n; cin>>n;\n  rep(i,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nstring its(int n){\n  stringstream s;\n  s<<n;\n  return s.str();\n}\nstack<string> mep(stack<string> me,string s){\n  int a,b;\n  b=atoi(me.top().c_str());\n  me.pop();\n  a=atoi(me.top().c_str());\n  me.pop();\n  if(s==\"+\")\n    me.push(its(a+b));\n  else if(s==\"-\")\n    me.push(its(a-b));\n  else if(s==\"*\")\n    me.push(its(a*b));\n  else if(s==\"/\")\n    me.push(its(a/b));\n  return me;\n}\nint main(){\n  int h,i,j;\n  int n,len;\n  string s;\n  stack<string> me,st;\n  cin>>n;\n  for(h=0;h<n;h++){\n    cin>>s;\n    len=s.length()-1;\n    for(i=0;i<len;i++){\n      if('1'<=s[i]&&s[i]<='9'){\n\tfor(j=i;j<len;j++)\n\t  if(s[j]<'0'||'9'<s[j])\n\t    break;\t\n\tme.push(s.substr(i,j-i));\n\ti=j-1;\n      }else if(s[i]=='('){\n\tst.push(s.substr(i,1));\n      }else if(s[i]==')'){\n\twhile(st.top()!=\"(\"){\n\t  me=mep(me,st.top());\n\t  st.pop();\n\t}\n\tst.pop();\n      }else if(s[i]=='+'||s[i]=='-'){\n\tif(st.empty());\n\telse if(st.top()==\"(\");\n\telse{\n\t  while(st.empty()==0){\n\t    if(st.top()==\"(\")\n\t      break;\n\t    else{\n\t      me=mep(me,st.top());\n\t      st.pop();\n\t    }\n\t  }\n\t}\n\tst.push(s.substr(i,1));\n      }else if(s[i]=='*'||s[i]=='/'){\n\tif(st.empty());\n\telse if(st.top()==\"(\");\n\telse if(st.top()==\"+\"||st.top()==\"-\");\n\telse{\n\t  while(st.empty()==0){\n\t    if(st.top()==\"(\")\n\t      break;\n\t    else if(st.top()==\"+\"||st.top()==\"-\")\n\t      break;\n\t    else{\n\t      me=mep(me,st.top());\n\t      st.pop();\n\t    }\n\t  }\n\t}\n\tst.push(s.substr(i,1));\n      }\n    }\n    while(st.empty()==0){\n      me=mep(me,st.top());\n      st.pop();\n    }\n    cout<<me.top()<<endl;\n    me.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n \n \n \nint calc_E(char line[101],int left,int right);\nint calc_T(char line[101],int left,int right);\nint calc_F(char line[101],int left,int right);\nint calc_NUM(char line[101],int left,int right);\n \n \nint calc_E(char line[101],int left,int right){\n \n    int depth = 0;\n    queue<int> Q;\n \n    //深さ0の、プラスまたは-を探す\n    for(int i = left; i <= right; ){\n        if(line[i] == '(')depth++;\n        else if(line[i] == ')')depth--;\n \n        if(depth != 0){\n            i++;\n        }else if(line[i] != '+' && line[i] != '-'){\n            i++;\n        }else{\n            if(line[i] == '+'){\n                Q.push(i);\n                i++;\n            }else{ //line[i] == '-'\n                if((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n                    Q.push(i);\n                }\n                while(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n            }\n        }\n    }\n \n    if(Q.empty()){ //深さ0の+-がない\n        return calc_T(line,left,right);\n    }\n \n    int tmp = calc_E(line,left,Q.front()-1),tmp_right;\n \n    if(tmp == BIG_NUM)return BIG_NUM;\n \n    while(!Q.empty()){\n        int loc = Q.front();\n        Q.pop();\n \n        if(Q.empty()){\n            tmp_right = calc_T(line,loc+1,right);\n        }else{\n            tmp_right = calc_T(line,loc+1,Q.front()-1);\n        }\n \n        if(tmp_right == BIG_NUM){\n            return BIG_NUM;\n        }\n \n        if(line[loc] == '+'){\n            tmp += tmp_right;\n        }else{\n            tmp -= tmp_right;\n        }\n    }\n \n    return tmp;\n}\n \nint calc_T(char line[101],int left,int right){\n \n    int depth = 0;\n    queue<int> Q;\n \n    //深さ0の、*,/を探す\n    for(int i = left; i <= right; ){\n        if(line[i] == '(')depth++;\n        else if(line[i] == ')')depth--;\n \n        if(depth != 0){\n            i++;\n        }else if(line[i] != '*' && line[i] != '/'){\n            i++;\n        }else{\n            Q.push(i);\n            i++;\n        }\n    }\n \n    if(Q.empty()){ //深さ0の*がない\n        return calc_F(line,left,right);\n    }\n \n    int tmp = calc_T(line,left,Q.front()-1),tmp_right;\n \n    if(tmp == BIG_NUM)return BIG_NUM;\n \n    while(!Q.empty()){\n        int loc = Q.front();\n        Q.pop();\n \n        if(Q.empty()){\n            tmp_right = calc_F(line,loc+1,right);\n        }else{\n            tmp_right = calc_F(line,loc+1,Q.front()-1);\n        }\n \n        if(tmp_right == BIG_NUM){\n            return BIG_NUM;\n        }\n \n        if(line[loc] == '*'){\n            tmp *= tmp_right;\n        }else{\n            tmp /= tmp_right;\n        }\n    }\n    return tmp;\n}\n \nint calc_F(char line[101],int left,int right){\n \n    if(line[left] >= '0' && line[left] <= '9'){\n        return calc_NUM(line,left,right);\n    }else if(line[left] == '-'){\n        return -1*calc_F(line,left+1,right);\n    }else if(line[left] == '('){\n \n        int depth = 0;\n        int close_pos = BIG_NUM;\n \n        for(int i = left; i <= right; i++){\n            if(line[i] == '(')depth++;\n            else if(line[i] == ')'){\n                depth--;\n                if(depth == 0){\n                    close_pos = i;\n                    break;\n                }\n            }\n        }\n \n        if(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n \n        return calc_E(line,left+1,close_pos-1);\n    }else{\n        return BIG_NUM;\n    }\n}\n \nint calc_NUM(char line[101],int left,int right){\n \n    int ret = 0;\n    for(int i = left; i <= right; i++){\n        ret = 10*ret+line[i]-'0';\n    }\n    return ret;\n}\n \n \nint main(){\n \n    int N,length;\n    char buf[101];\n \n    scanf(\"%d\",&N);\n \n    for(int loop = 0; loop < N; loop++){\n        scanf(\"%s\",buf);\n        for(length = 0; buf[length] != '='; length++);\n \n        printf(\"%d\\n\",calc_E(buf,0,length-1));\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nstring S = \"\";\nint cur;\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur = cur+1;\n\treturn n;\n}\nint number(){\n\tint n = digit();\n\twhile(cur < S.size() && isdigit(S[cur]))\n\t\tn = n*10 + digit();\n\treturn n;\n}\nint factor();\n\nint term(){\n\tint a = factor();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*'){\n\t\t\ta *= b;\n\t\t}else{\n\t\t\ta /= b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint sum = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = term();\n\t\tif(op == '+'){\n\t\t\tsum += b;\n\t\t}else{\n\t\t\tsum -= b;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint factor(){\n\tif(S[cur] != '('){\n\t\treturn number();\n\t}\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i = 0;i<N;i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.erase(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint number(string::const_iterator &c){//number\n\tint ret = 0;\n\twhile(isdigit(*c)){\n\t\tret*=10;\n\t\tret+=*c-'0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nint expression(string::const_iterator&);\nint factor(string::const_iterator &c) {\n\tint ret;\n\tif (*c=='(') {\n    \tc++;\n\t\tret = expression(c);\n\t\tc++;\n\t}else return number(c);\n\treturn ret;\n}\n\nint term(string::const_iterator &c){//*or/\n\tint ret = factor(c);\n\tfor(;;){\n\t\tif(*c=='*'){\n\t\t\tc++;\n\t\t\tret*=factor(c);\n\t\t}else if(*c=='/'){\n\t\t\tc++;\n\t\t\tret/=factor(c);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expression(string::const_iterator &c){//all\n\tint ret = term(c);\n\tfor(;;){\n\t\tif(*c=='+'){\n\t\t\tc++;\n\t\t\tret+=term(c);\n\t\t}else if(*c=='-'){\n\t\t\tc++;\n\t\t\tret-=term(c);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tcin.ignore();\n\twhile(n--){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tstring::const_iterator c=s.begin();\n\t\tcout<<expression(c)<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\nstatic const double eps = 1e-9;\n\ntypedef pair<int, int> p;\ntypedef long long ll;\n\ntemplate<class t>\ninline t sq(t a){return a*a;}\n\nint expr();\nint term();\nint fact();\n\nstring s;\nint ptr;\nint expr(){\n\tint x = term();\n\twhile(s[ptr] == '+' || s[ptr] == '-'){\n\t\tif(s[ptr] == '+'){\n\t\t\tptr++;\n\t\t\tx += term();\n\t\t}else{\n\t\t\tptr++;\n\t\t\tx -= term();\n\t\t}\n\t}\n\treturn x;\n}\n\nint term(){\n\tint x;\n\tx = fact();\n\twhile(s[ptr] == '*' || s[ptr] == '/'){\n\t\tif(s[ptr] == '*'){\n\t\t\tptr++;\n\t\t\tx *= fact();\n\t\t}\n\t\telse if(s[ptr] == '/'){\n\t\t\tptr++;\n\t\t\tx/= fact();\n\t\t}\n\t}\n\n\treturn x;\n}\n\nint fact(){\n\tint x = 0, y = 1;\n\tif(s[ptr] == '+') ptr++;\n\tif(s[ptr] == '-'){\n\t\ty = -1;\n\t\tptr++;\n\t}\n\tif(s[ptr] == '('){\n\t\tptr++;\n\t\tx = expr();\n\t\tptr++;\n\t}else{\n\t\twhile('0' <= s[ptr] && s[ptr] <= '9'){\n\t\t\tx *= 10;\n\t\t\tx += (s[ptr]-'0');\n\t\t\tptr++;\n\t\t}\n\t}\n\treturn x*y;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\tptr = 0;\n\t\tcout << expr() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint exp(string&, int&);\nint term(string&, int&);\nint factor(string&, int&);\n\nint exp(string& str, int& p){\n  int res = term(str, p);\n  while(str[p] == '+' || str[p] == '-'){\n    if(str[p] == '+'){\n      p++;\n      res += term(str, p);\n    }else{\n      p++;\n      res -= term(str, p);\n    }\n  }\n  return res;\n}\n\nint term(string& str, int& p){\n  int res = factor(str, p);\n  while(str[p] == '*' || str[p] == '/'){\n    if(str[p] == '*'){\n      p++;\n      res *= factor(str, p);\n    }else{\n      p++;\n      res /= factor(str, p);\n    }\n  }\n  return res;\n}\n\nint factor(string& str, int& p){\n  int res = 0;\n  int keta = 1;\n  int initp = p;\n  if(str[p] == '('){\n    while(str[p] != ')'){\n      p++;\n      res = exp(str, p);\n    }\n    p++;\n  }else{\n    while(isdigit(str[p])){\n      p++;\n    }\n    for(int i=p-1; i >= initp; i--){\n      res += keta * (str[i] - '0');\n      keta *= 10;\n    }\n  }\n  return res;\n}\n\n\nint main(void){\n  int n; cin >> n;\n  while(n--){\n    int p=0;\n    string str;\n    cin >> str;\n    cout << exp(str, p) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\ntypedef string::const_iterator iter;\n\nint expr(iter &p);\nint term(iter& p);\nint factor(iter& p);\nint number(iter& p);\n\nint expr(iter& p) {\n    int r = term(p);\n    while(true) {\n        if(*p == '+') {\n            ++p;\n            int rs = term(p);\n            r += rs;\n        }\n        else if(*p == '-') {\n            ++p;\n            int rs = term(p);\n            r -= rs;\n        }\n        else {\n            break;\n        }\n    }\n    return r;\n}\n\nint term(iter& p) {\n    int r = factor(p);\n    while(true) {\n        if(*p == '*') {\n            ++p;\n            int rs = term(p);\n            r *= rs;\n        }\n        else if(*p == '/') {\n            ++p;\n            int rs = term(p);\n            r /= rs;\n        }\n        else {\n            break;\n        }\n    }\n    return r;\n}\n\nint factor(iter& p) {\n    if(*p == '(') {\n        ++p; // skip (\n        int r = expr(p);\n        ++p; // skip )\n        return r;\n    }\n    \n    return number(p);\n}\n\nint number(iter& p) {\n    int r = 0;\n    while(isdigit(*p)) {\n        r *= 10;\n        r += *p -'0';\n        p++;\n    }\n    return r;\n}\n\nint main() {\n    int n; cin >> n;\n    while(n--) {\n        string s; cin >> s;\n        iter it = s.begin();\n        int res = expr(it);\n        cout << res << endl;\n    }\n}\ns"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nstd::string find(std::vector<std::string>&v, int a, bool b){\n\n\tstd::string res;\n\n\tif (b){\n\t\tfor (int i = a - 1; i >= 0; i--){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!b){\n\t\tfor (int i = a + 1; i < v.size(); i++){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint toint(std::string str){\n\n\tint res;\n\tstd::stringstream z;\n\n\tz << str;\n\tz >> res;\n\n\treturn res;\n\n}\n\nstd::string tostring(int a){\n\n\tstd::string str;\n\tstd::stringstream z;\n\n\tz << a;\n\tz >> str;\n\n\treturn str;\n\n}\n\nstd::string keisan(std::string lhs, std::string rhs, int t){\n\n\tint a, b, c;\n\n\ta = toint(lhs);\n\tb = toint(rhs);\n\n\tif (t == 1)c = a + b;\n\tif (t == 2)c = a - b;\n\tif (t == 3)c = a * b;\n\tif (t == 4)c = a / b;\n\n\treturn tostring(c);\n\n}\n\nstd::string keisan2(std::vector<std::string> &v){\n\n\tint res = 0;\n\n\tfor (int i = 0, j = 0, k = 0; i < v.size(); i++){\n\t\tif (v[i] == \"(\")j = i, k++;\n\t\tif (v[i] == \")\"){\n\t\t\tk--;\n\t\t\tif (k == 0){\n\t\t\t\tstd::vector<std::string>w;\n\t\t\t\tfor (int p = j + 1; p < i; p++)w.push_back(v[p]);\n\t\t\t\tv[j] = keisan2(w);\n\t\t\t\tfor (int p = j + 1; p <= i; p++)v[p] = \"T\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"*\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 3);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"/\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 4);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"+\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 1);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"-\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 2);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (int i = 0; i < v.size(); i++)res = std::max(res, toint(v[i]));\n\n\treturn tostring(res);\n\n}\n\n\nint main(){\n\n\tstd::vector<std::string> v;\n\n\tstd::string str;\n\tstd::cin >> str;\n\n\tfor (int i = 0, j = 0; i < str.size(); i++){\n\n\t\tif (!(str[i] >= '0'&&str[i] <= '9')){\n\t\t\tif (i - j > 0)v.push_back(str.substr(j, i - j));\n\t\t\tv.push_back(str.substr(i, 1));\n\t\t\tj = i + 1;\n\t\t}\n\t}\n\n\tstd::cout << keisan2(v) << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint calc1();\nint calc2();\nint calc3();\n\nint p;\nstring eq;\n\nint calc1() {\n  int a = calc2();\n  while (eq[p]=='+' || eq[p]=='-') {\n    if (eq[p]=='+') {\n      p++;\n      a += calc2();\n    } else if (eq[p]=='-') {\n      p++;\n      a -= calc2();\n    }\n  }\n  return a;\n}\n\nint calc2() {\n  int a = calc3();\n  while (eq[p]=='*' || eq[p]=='/') {\n    if (eq[p]=='*') {\n      p++;\n      a *= calc3();\n    } else if (eq[p]=='/') {\n      p++;\n      a /= calc3();\n    }\n  }\n  return a;\n}\n\nint calc3() {\n  int a;\n  if (eq[p]=='(') {\n    p++;\n    a = calc1();\n    p++;\n  } else {\n    a = 0;\n    while (eq[p]>='0'&&eq[p]<='9') {\n      a *= 10;\n      a += eq[p++] - '0';\n    }\n  }\n  return a;\n}\n\nint main() {\n  int n, r;\n\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    cin >> eq;\n    p = 0;\n    r = calc1();\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint exp();\nint term();\nint factor();\nstring str;\nint p;\n\nint factor(){\n  int val=0;\n  while(str[p]>='0' && str[p]<='9'){ \n    val*=10;\n    val+=str[p]-'0';\n    p++;\n  }\n  \n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }\n  if(str[p]==')') p++;\n  return val;\n}\n\nint term(){\n  int val=factor();\n  while(str[p]=='*' || str[p]=='/'){\n  if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n }\n return val;\n}\n\nint exp(){\n  int val=term();\n  while(str[p]=='+' || str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\n\n\nint main(){\n  int n;\n  \n  cin>>n;\n  for(int i=0;i<n;i++){\n    p=0;\n    cin>>str;\n    cout<<exp()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cassert>\n#include <string>\n#include <iostream>\nusing namespace std;\n\n\nstring S;\nsize_t cur = 0;\nint parse();\nint expression();\n\n\nint digit(){\n  // assert(isdigit(S[cur]));\n  int n = S[cur]-'0';\n  cur =cur+1;\n  // cout << n <<endl;\n  return n;\n}\n\nint number (){\n  int n = digit();\n  // cout << n << endl;\n  while(cur<S.size() && isdigit(S[cur])) n=n*10 + digit();\n  // cout << n<<endl;\n  return n;\n}\n\nint factor(){\n  if(S[cur] != '('){\n    return number();\n  }\n  cur += 1;\n  int n = expression();\n  assert(S[cur]==')');\n  cur+=1;\n  return n;\n}\n\nint term(){\n  int a=factor();\n  while(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n    char op = S[cur++];\n    int b = factor();\n    if(op=='*') a*=b; else a/=b;\n  }\n  return a;\n}\n\nint expression(){\n  int a= term();\n  while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n    char op = S[cur++];\n    int b = term();\n    if(op == '+') a += b;else a -=b;\n  }\n  return a;\n  // int sum = number();\n  // while(S[cur] == '+'|| S[cur] == '-'||S[cur]=='*'||S[sur]=='/'){\n  //   char op = S[cur];\n  //   cur += 1;\n  //   int b = number();\n  //   if(op=='+'){\n\n  //   }\n\n  // }\n\n\n  // int a = number();\n  // char op = S[cur];\n  // cur += 1;\n  // int b = number();\n  // assert(op == '+');\n  // return a + b;\n}\n\n\n\nint main(){\n  int N;\n  cin >> N;\n  for (int i=0;i<N;++i){\n    cur=0;\n    cin>>S;\n    S.resize(S.size()-1);\n    cout << expression()<<endl;\n  }\n}\n// int parse(){return expression();}\n// int main(){\n//   int a = parse();\n//   // assert(a==15);\n//   cout << a << endl;\n//   assert(cur == S.size());\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n      \n      // else if(str[i] == '+' || str[i] == '-'){\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = tmp;\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n      // else{\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = string(tmp);\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  //  getline(cin,s);\n  //  n = atoi(s.c_str());\n  cin >> n;\n    //  scanf(\"%d\\n\",&n);\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    //  getline(cin,str);\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '*')\n\t\treturn 1;\n\tif(a == '/')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<long long> & num_stack, stack<char> & op_stack) {\n\tlong long a, b;\n\tlong long c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nlong long clac(string str) {\n\tstack<long long> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tlong long tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t}\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF (1<<26)\nusing namespace std;\nint n;\n\n\n\nint compute(int a,int b,string str){\n  int i=a,sum=0,tmp=INF,tmp2=INF,cnt=0;\n  while(1){\n    sum=0;\n    if(str[i]=='('){\n      sum=compute(i+1,0,str);\n      for(i=a+1;i<(int)str.size();i++){\n\tif(str[i]==')')cnt--;\n\tif(str[i]=='(')cnt++;\n\tif(cnt<0)break;\n      }\n      i++;\n    }else{\n      while(1){\n\tif('0'<=str[i]&&str[i]<='9'){\n\t  sum*=10;\n\t  sum+=(str[i]-'0');\n\t  i++;\n\t}else{\n\t  break;\n\t}\n      }\n    }\n    \n    if(b==1){\n      sum*=-1;\n      b=0;\n    }\n    if(tmp!=INF){\n      sum*=tmp;\n      tmp=INF;\n    }\n    if(tmp2!=INF){\n      sum=tmp2/sum;\n      tmp2=INF;\n    }\n    \n    if(str[i]=='\\0'||str[i]==')')return sum;\n    if(str[i]=='+')return sum + compute(i+1,0,str);\n    if(str[i]=='-')return sum + compute(i+1,1,str);\n    if(str[i]=='*'){\n      i++;\n      tmp=sum;\n    }else if(str[i]=='/'){\n      i++;\n      tmp2=sum;\n    }\n  }\n      \n}\n\n\nint main(){\n  string str;\n  cin>>n;\n  while(n--){\n    cin>>str;\n    if(str[str.size()-1]=='=')str=str.substr(0,str.size()-1);\n    //cout<<str<<endl;\n    cout<<compute(0,0,str)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint atoi(string s);\nint calc(string in);\n\nint main() {\n\tint n; cin >> n;\n\tfor (int lop = 0; lop<n; lop++) {\n\t\tstring in; cin >> in;\n\t\tcout << calc(in.substr(0, in.size() - 1)) << endl;\n\t}\n}\n\nint calc(string in) {\n\t//cout<<in<<endl;\n\tbool f = true;\n\tfor (int i = 1; i<in.size(); i++) {\n\t\tif (in[i]<'0' || '9'<in[i]) {\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) {\n\t\tif (in[0] == '-')\n\t\t\treturn -atoi(in.substr(1, in.size() - 1));\n\t\tif (in[0] == '+')\n\t\t\treturn atoi(in.substr(1, in.size() - 1));\n\t\treturn atoi(in);\n\t}\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (in[i] == '+' || in[i] == '-' || in[i] == '(' || in[i] == ')') {\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!f) {\n\t\tint num = 1, start = 0;\n\t\t// if op * , else /\n\t\tbool op = true;\n\t\tfor (int i = 0; i<in.size(); i++) {\n\t\t\tif (in[i] == '*' || in[i] == '/') {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= atoi(in.substr(start, i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= atoi(in.substr(start, i - start));\n\t\t\t\tstart = i + 1;\n\t\t\t\tif (in[i] == '*')\n\t\t\t\t\top = true;\n\t\t\t\telse\n\t\t\t\t\top = false;\n\t\t\t}\n\t\t\tif (i == in.size() - 1) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= atoi(in.substr(start, 1 + i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= atoi(in.substr(start, 1 + i - start));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (in[i] == '(' || in[i] == ')') {\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) {\n\t\tint start = 0, num = 0;\n\t\t// if op + , else - \n\t\tbool op = true;\n\t\tfor (int i = 0; i<in.size(); i++) {\n\t\t\tif (in[i] == '+' || in[i] == '-') {\n\t\t\t\tif (op)\n\t\t\t\t\tnum += calc(in.substr(start, i - start));\n\t\t\t\telse\n\t\t\t\t\tnum -= calc(in.substr(start, i - start));\n\t\t\t\tstart = i + 1;\n\t\t\t\tif (in[i] == '+')\n\t\t\t\t\top = true;\n\t\t\t\telse\n\t\t\t\t\top = false;\n\t\t\t}\n\t\t\tif (i == in.size() - 1) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum += calc(in.substr(start, 1 + i - start));\n\t\t\t\telse\n\t\t\t\t\tnum -= calc(in.substr(start, 1 + i - start));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tint level = 1;\n\t//cout<<in<<endl;\n\tif (in[0] != '(' || in[in.size() - 1] != ')')\n\t\tf = true;\n\tif (!f) {\n\t\tfor (int i = 1; i < in.size() - 1; i++) {\n\t\t\tif (in[i] == '(')\n\t\t\t\tlevel++;\n\t\t\tif (in[i] == ')')\n\t\t\t\tlevel--;\n\t\t\tif (level == 0) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!f)\n\t\t\treturn calc(in.substr(1, in.size() - 2));\n\t}\n\tlevel = 0;\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (in[i] == '(') {\n\t\t\tlevel++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] == ')') {\n\t\t\tlevel--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0 && (in[i] == '+' || in[i] == '-'))\n\t\t\tf = false;\n\t}\n\tif (f) {\n\t\t//cout<<in<<endl;\n\t\tlevel = 0;\n\t\tint start = 0;\n\t\tint num = 1;\n\t\tbool op = true;\n\t\tfor (int i = 0; i<in.size(); i++) {\n\t\t\tif (i == in.size() - 1) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= calc(in.substr(start, 1 + i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= calc(in.substr(start, 1 + i - start));\n\t\t\t}\n\t\t\tif (in[i] == '(') {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in[i] == ')') {\n\t\t\t\tlevel--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (level == 0 && (in[i] == '*' || in[i] == '/')) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= calc(in.substr(start, i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= calc(in.substr(start, i - start));\n\t\t\t\tstart = i + 1;\n\t\t\t\tif (in[i] == '*')\n\t\t\t\t\top = true;\n\t\t\t\telse\n\t\t\t\t\top = false;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tint start = 0, num = 0;\n\tlevel = 0;\n\tbool op = true;\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (i == in.size() - 1) {\n\t\t\tif (op)\n\t\t\t\tnum += calc(in.substr(start, 1 + i - start));\n\t\t\telse\n\t\t\t\tnum -= calc(in.substr(start, 1 + i - start));\n\t\t}\n\t\tif (in[i] == '(') {\n\t\t\tlevel++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] == ')') {\n\t\t\tlevel--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0 && (in[i] == '+' || in[i] == '-')) {\n\t\t\tif (op)\n\t\t\t\tnum += calc(in.substr(start, i - start));\n\t\t\telse\n\t\t\t\tnum -= calc(in.substr(start, i - start));\n\t\t\tstart = i + 1;\n\t\t\tif (in[i] == '+')\n\t\t\t\top = true;\n\t\t\telse\n\t\t\t\top = false;\n\t\t}\n\t}\n\treturn num;\n}\n\nint atoi(string s) {\n\tint n = 0;\n\tfor (int i = 0; i<s.size(); i++) {\n\t\tn = n * 10 + s[i] - '0';\n\t}\n\treturn n;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar formula[101];\nint p;\n\nint additive() {\n  int result = multitive();\n  while (formula[p] == '+' || formula[p] == '-')\n    if (formula[p++] == '+')\n      result += multitive();\n    else\n      result -= multitive();\n  return result;\n}\n\nint multitive() {\n  int result = term();\n  while (formula[p] == '*' || formula[p] == '/')\n    if (formula[p++] == '*')\n      result *= term();\n    else\n      result /= term();\n  return result;\n}\n\nint term() {\n  int result = 0;\n  if (formula[p] == '(') {\n    p++;\n    result = additive();\n    p++;\n  } else while ('0' <= formula[p] && formula[p] <= '9')\n    result = result * 10 + formula[p++] - '0';\n  return result;\n}\n\nint main() {\n  int i, n;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%s\", formula);\n    p = 0;\n    printf(\"%d\\n\", additive());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring str;\nint cur = 0;\n\nint expression();\nint term();\nint factor();\n\nint digit() {\n    int a = str[cur] - '0';\n    cur++;\n    return a;\n}\n\nint number() {\n    int a = digit();\n    while (cur < str.size() && isdigit(str[cur])) {\n        a = a * 10 + digit();\n    }\n    return a;\n}\n\nint expression() {\n    int a = factor();\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        if (str[cur] == '+') {\n            cur++;\n            int b = factor();\n            a += b;\n        } else if (str[cur] == '-') {\n            cur++;\n            int b = factor();\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint term() {\n    int a = number();\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        if (str[cur] == '*') {\n            cur++;\n            int b = factor();\n            a *= b;\n        } else if (str[cur] == '/') {\n            cur++;\n            int b = factor();\n            a /= b;\n        }\n    }\n    return a;\n}\n\nint factor() {\n    if (str[cur] != '(') return term();\n\n    cur++;\n    int a = expression();\n    cur++;\n    return a;\n}\n\nint main() {\n    int N = 0;\n    cin>>N;\n    for (int n = 0; n < N; n++) {\n        cin>>str;\n        cur = 0;\n        cout<<expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\nstd::cout << std::endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s, int& i) {\n\tint val = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i++];\n\t\tint val2 = term(s, i);\n\t\tif (op == '+') val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\n\nint term(string& s, int& i) {\n\tint val = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i++];\n\t\tint val2 = factor(s, i);\n\t\tif (op == '*') val *= val2;\n\t\telse val /= val2;\n\t}\n\treturn val;\n}\n\nint factor(string& s, int& i) {\n\tif (isdigit(s[i])) return number(s, i);\n\t\n\ti++;\n\tint res = expr(s, i);\n\ti++;\n\treturn res;\n}\n\nint number(string& s, int& i) {\n\tint num = s[i++] - '0';\n\twhile (isdigit(s[i])) num = num*10 + s[i++] - '0';\n\treturn num;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(str.end() - 1);\n\t\tint i = 0;\n\t\tcout << expr(str, i) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\n\n#include<cassert>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nstring S;\nint cur = 0;//?§£???????§???????\n\nint expression();//????????£?¨?\n\nint digit(){\n\t// assert(isdigit(S[cur]));\n\t// cout<<\"S[cur]=\"<<S[cur]<<endl;;\n\tint n = S[cur++] - '0';\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur]))n = n*10+digit();\n\treturn n;\n}\n\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\t// assert(S[cur++]==')');\n\treturn n;\n}\n\nint term(){\n\tint a = factor();\n\twhile(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op=='*')a*=b;else a/=b;\n\t}\n\treturn a;\n}\n\nint expression() {\n\tint a = term();\n\twhile (cur<S.size() && (S[cur] == '+' || S[cur] == '-')) { // ?¶???????????????????????¶???????\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+')a+=b;else a-=b;\n\t}\n\treturn a;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tcur=0;\n\t\tcin>>S;\n\t\tS.resize(S.size()-1);\n\t\tcout<<expression()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nint c = -1;\nstring s;\n\n\n/*\n<eq> = <expr> '='\n<expr> = <expr2> (('+'|'-') <expr2>)*\n<expr2> = <expr3> (('*'|'/') <expr3>)*\n<expr3> = <number> | '(' <expr> ')'\n<number> = ['0' - '9']+\n*/\n\nchar seek(){\n  assert(c < s.size());\n  return s[c];\n}\nchar next(){\n  assert(c < s.size());\n  char res = s[c];\n  c++;\n  return res;\n}\nint number(){\n  int res = 0;\n  if(isdigit(seek())){\n    res *= 10;\n    res += next() - '0';\n  }\n  return res;\n}\nint expr();\n\nint expr3(){\n  char p = seek();\n  if(p == '('){\n    next();\n    int res = expr();\n    assert(next() == ')');\n    return res;\n  }\n  return number();\n}\nint expr2(){\n  int res = expr3();\n  while(true){\n    char op = seek();\n    if(op == '*'){\n      next();\n      int other = expr2();\n      res *= other;\n    }else if(op == '/'){\n      next();\n      int other = expr2();\n      res /= other;\n    }else{\n      return res;\n    }\n  }\n}\nint expr(){\n  int res = expr2();\n  while(true){\n    char op = seek();\n    if(op == '+'){\n      next();\n      int other = expr2();\n      res += other;\n    }else if(op == '-'){\n      next();\n      int other = expr2();\n      res -= other;\n    }else{\n      return res;\n    }\n  }\n}\n\nint eq(){\n  int e = expr();\n  char eqa = next();\n  assert(eqa == '=');\n  return e;\n}\nint solve(string str){\n  c = 0;\n  s = str;\n  return eq();\n}\nsigned main(){\n  int n; cin >> n;\n  rep(i,n){\n    string str; cin >> str;\n    cout << solve(str) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\nchar s[111];\nint cur,len;\n\nint shiki();\n\nint kazu()\n{\n  if( s[cur] == '(' ) {\n    cur += 1;\n    return shiki();\n  } else {\n    int a = s[cur]-'0';\n    cur += 1;\n    while( isdigit(s[cur]) ) {\n      a *= 10;\n      a += s[cur]-'0';\n      cur += 1;\n    }\n    return a;\n  }\n}          \n\nint kou()\n{\n  int a = kazu();\n  while( s[cur] == '*' || s[cur] == '/' ) {\n    char o = s[cur]; cur += 1;\n    int b = kazu();\n    o=='*'?(a*=b):(a/=b);\n  }\n  return a;\n}\n\nint shiki()\n{\n  int a = kou();\n  while( s[cur] == '+' || s[cur] == '-' ) {\n    char o = s[cur]; cur += 1;\n    int b = kou();\n    if( o == '+' ) a += b;\n    else a -= b;\n  }\n  return a;\n}\n\nint parse()\n{\n  len = 0;\n  while( s[len] ) len++;\n  len--;\n  cur = 0;\n  return shiki();\n}\n\nint main(void)\n{\n  int n; scanf(\"%d\",&n);\n  while( n-- ) {\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",parse());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])==-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=s[oi];\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        s[0] = '\\0';\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0'; //????°????=?????????\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n        for (int j = 0; j < t; j++)\n            cout << B[j] << \" \";\n        cout << endl;\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(char *s, char *end)\n{\n\t/*for (char *p = s; p != end; p++) printf(\"%c\", *p);\n\tputs(\"\");*/\n\t\n\tbool f = false;\n\t\n\tvector<int> st;\n\tvector<char> op;\n\t\n\tchar *p = s;\n\twhile (p != end){\n\t\tif (!f) if (*p == '('){\n\t\t\tchar *e;\n\t\t\tfor (e = p + 1; *e != ')'; e++);\n\t\t\tst.push_back(calc(p + 1, e));\n\t\t\tp = e;\n\t\t}\n\t\tif (f) if (*p == '+' || *p == '-' || *p == '*' || *p == '/'){\n\t\t\top.push_back(*p);\n\t\t\tp++;\n\t\t\tf ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!f) if (*p >= '0' && *p <= '9'){\n\t\t\tint n = atoi(p);\n\t\t\tst.push_back(n);\n\t\t\tstringstream ss;\n\t\t\tss << n;\n\t\t\tp += ss.str().size() - 1;\n\t\t}\n\t\tif (!f) if (*p == '-'){\n\t\t\tint n = atoi(p);\n\t\t\tst.push_back(n);\n\t\t\tstringstream ss;\n\t\t\tss << n;\n\t\t\tp += ss.str().size() - 1;\n\t\t\t//printf(\"%s\\n\", ss.str().c_str());\n\t\t}\n\t\tif (op.size() && (op.back() == '*' || op.back() == '/')){\n\t\t\tint b = st.back(); st.pop_back();\n\t\t\tint a = st.back(); st.pop_back();\n\t\t\tif (op.back() == '*') a *= b;\n\t\t\tif (op.back() == '/') a /= b;\n\t\t\tst.push_back(a);\n\t\t\top.pop_back();\n\t\t}\n\t\tp++;\n\t\tf = !f;\n\t\t/*printf(\"__\");\n\t\tfor (auto a : st) printf(\"%d \", a);\n\t\tputs(\"\");*/\n\t}\n\t\n\twhile (op.size()){\n\t\tint t = st.front(); st.erase(st.begin());\n\t\t/*if (st.size() == 0){\n\t\t\tif (op.front() == '-') st.push_back(-t);\n\t\t\telse st.push_back(t);\n\t\t\top.erase(op.begin());\n\t\t\tbreak;\n\t\t}*/\n\t\tif (op.front() == '+') st[0] = t + st[0];\n\t\tif (op.front() == '-') st[0] = t - st[0];\n\t\top.erase(op.begin());\n\t}\n\t\n\treturn st[0];\n}\n\nint main()\n{\n\tint n;\n\tchar str[1024];\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%s\", str);\n\t\tstr[strlen(str) - 1] = '\\0';\n\t\tprintf(\"%d\\n\", calc(str, str + strlen(str)));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint pri(char ch) \n{\n    if (ch == '*' || ch == '/')\n        return 2;\n    if (ch == '+' || ch == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    while (n--) {\n        string exp, cha;\n        stack<char> pol;\n        stack<int> cal;\n\n        cin >> exp;\n        for (int i = 0; i < exp.size() - 1; i++) {\n            if ('0' <= exp[i] && exp[i] <= '9') {\n                while (true) {\n                    cha.push_back(exp[i]);\n                    if ('0' > exp[i + 1] || exp[i + 1] > '9') {\n                        cha.push_back('.');\n                        break;\n                    }\n                    else\n                        i++;\n                }\n            }\n            else if (exp[i] == '(')\n                pol.push(exp[i]);\n            else if (exp[i] == ')') {\n                while (true) {\n                    if (pol.top() == '(') {\n                        pol.pop();\n                        break;\n                    }\n                    cha.push_back(pol.top());\n                    pol.pop();\n\n                }\n            }\n            else {\n                while (!pol.empty()) {\n                    if (pri(exp[i]) < pri(pol.top())) {\n                        cha.push_back(pol.top());\n                        pol.pop();\n                    }\n                    else \n                        break;\n                }\n                pol.push(exp[i]);\n            }\n        }\n\n        while (!pol.empty()) {\n            cha.push_back(pol.top());\n            pol.pop();\n        }\n\n        for (int i = 0; i < cha.size(); i++) {\n            if ('0' <= cha[i] && cha[i] <= '9') {\n                int tmp = cha[i] - '0';\n\n                while (true) {\n                    i++;\n                    if (cha[i] == '.') \n                        break;\n                    tmp *= 10;\n                    tmp += cha[i] - '0';\n                }\n                cal.push(tmp);\n            }\n            else {\n                int a, b;\n\n                b = cal.top();\n                cal.pop();\n                a = cal.top();\n                cal.pop();\n\n                if (cha[i] == '*') \n                    cal.push(a * b);\n                else if (cha[i] == '/') \n                    cal.push(a / b);\n                else if (cha[i] == '+') \n                    cal.push(a + b);\n                else if (cha[i] == '-') \n                    cal.push(a - b);\n            }\n        }\n        cout << cal.top() << endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '/':\n    return 2;\n  case '*':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif((cs == '*' || cs == '/') && (str[i] == '*' || str[i] == '/')){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse if(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    hand.push_back(side[i]);\n  }\n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      long long val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  cin >> n;\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(s[oi]=='(' || isNum(s[oi])!=-1){s=\"+\"+s;}\n\t//cout<<s<<endl;\n\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=isNum(s[oi]);\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  //cout<<cs<<endl;\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(48<=c && c<=57){\n\t return c-48;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(const auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint dfs1(int& pos, const string& s);\nint dfs2(int& pos, const string& s);\n\nint dfs3(int& pos, const string& s){\n    if(isdigit(s[pos])){\n        int res = 0;\n        while(isdigit(s[pos])){\n            res = res * 10 + (s[pos++] - '0');\n        }\n        return res;\n    }\n    pos++;\n    const int res = dfs1(pos, s);\n    pos++;\n    return res;\n}\n\n// m, d\nint dfs2(int& pos, const string& s){\n    int res = dfs3(pos, s);\n    while(pos < (int)s.size()){\n        if(s[pos] == '*'){\n            ++pos, res *= dfs3(pos, s);\n        }else if(s[pos] == '/'){\n            ++pos, res /= dfs3(pos, s);\n        }else break;\n    }\n    return res;\n}\n\n// a, s\nint dfs1(int& pos, const string& s){\n    int res = dfs2(pos, s);\n    while(pos < (int)s.size()){\n        if(s[pos] == '+'){\n            ++pos, res += dfs2(pos, s);\n        }else if(s[pos] == '-'){\n            ++pos, res -= dfs2(pos, s);\n        }else break;\n    }\n    return res;\n}\n\nint parse(const string& s){\n    int pos = 0;\n    return dfs1(pos, s);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t;\n    cin >> t;\n    string s;\n    rep(i,t){\n        cin >> s;\n        cout << parse(s) << \"\\n\";\n    }\n    return  0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\ntypedef pair<int,int> parsed;\n\nparsed equation(string str, int p = 0);\nparsed factor(string str, int p = 0);\nparsed term(string str, int p = 0);\n\nbool overflow = false;\n\nint conv(string str) {\n    int res = 0;\n    for (int i = 0; i < str.size(); ++i) {\n        res = res * 10 + (str[i] - '0');\n    }\n    return res;\n}\n\nparsed equation(string str, int p) {\n    parsed res = factor(str, p);\n    while (str[res.second] == '+' || str[res.second] == '-') {\n        parsed temp = factor(str, res.second+1);\n        if (str[res.second] == '+') res.first = res.first + temp.first;\n        else if (str[res.second] == '-') res.first = res.first - temp.first;\n        res.second = temp.second;\n    }\n    return res;\n}\n\nparsed factor(string str, int p) {\n    parsed res = term(str, p);\n    while (str[res.second] == '*' || str[res.second] == '/') {\n        parsed temp = term(str, res.second+1);    \n        if (str[res.second] == '*') res.first = res.first * temp.first;\n        else if (str[res.second] == '/') res.first = res.first / temp.first;\n        res.second = temp.second;\n    }\n    return res;\n}\n\nparsed term(string str, int p) {\n    if (str[p] == '(') {\n        parsed res = equation(str, p+1);\n        res.second += 1;\n        return res;\n    }\n    else {\n        string snum = \"\";\n        if (p < str.size()) {\n            while (isdigit(str[p]) || str[p] == 'i') {\n                snum += str[p++];\n            }\n        }\n        int num = conv(snum);\n        return parsed(num, p);\n    }\n}\n\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    int n;\n    cin >> n;\n    string str;\n    for (int i = 0; i < n; ++i) {\n        cin >> str;\n        cout << equation(str).FI << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include<cassert>\nusing namespace std;\nsize_t cur=0;\nstring S;\n\n\n\nint digit(){\nassert(isdigit(S[cur]));\nint n=S[cur]-'0';\ncur=cur+1;\nreturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(cur<S.size() && isdigit(S[cur])){\n\t\tn=n*10+digit();\n\t}\n\treturn n;\n}\n\nint expression();\n\nint factor(){\n\tif(S[cur]!='(') return number();\n\tcur=cur+1;\n\tint n=expression();\n\tassert(S[cur]==')');\n\tcur=cur+1;\n\treturn n;\n}\n\n\nint term(){\n int a=factor();\n while(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n \tchar op = S[cur++];\n \tint b= factor();\n \tif (op== '*')a*=b;\n \telse a/=b;\n }\nreturn a;\n}\n\n\nint expression(){\n\tint a=term();\n\twhile((S[cur]=='+'||S[cur]=='-')&&cur<S.size()){\n\t\tchar op =S[cur++];\n\t\tint b=term();\n\t\tif (op=='+'){\n\t\t\ta=a+b;\n\t\t}\n\t\telse{\n\t\t\ta=a-b;\n\t\t}\n\t}\n\treturn a;\n}\n\n\nint parse(){ return expression();}\nint main() {\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\tcin>>S;\n\tcur=0;\n\tS.resize(S.size()-1);\nint a=parse();\ncout<<a<<endl;\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nusing si = string::const_iterator;\nclass ParseError {};\n\nusing ll = long long;\nusing ull = unsigned long long;\n\nvoid cch(si &p, char exp) {\n  if (*p != exp) {\n    cerr << \"expected '\" << exp << \"' but got '\" << *p << \"'\" << endl;\n    cerr << \"rest: '\";\n    for (; *p; *p++) cerr << *p;\n    cerr << \"'\" << endl;\n    throw ParseError();\n  }\n  p++;\n}\n\nll number(si &p) {\n  ll ret = 0;\n  for ( ; isdigit(*p); p++)\n    ret = ret * 10 + (*p - '0');\n  return ret;\n}\n\nll expr(si &p);\n\nll factor(si &p) {\n  if (*p == '(') {\n    cch(p, '(');\n    ll ret = expr(p);\n    cch(p, ')');\n    return ret;\n  }\n  return number(p);\n}\n\nll term(si &p) {\n  ll ret = factor(p);\n  while (true) {\n    if (*p == '*') {\n        cch(p, '*');\n        ret *= factor(p);\n    } else if (*p == '/') {\n        cch(p, '/');\n        ret /= factor(p);\n    } else break;\n  }\n  return ret;\n}\n\nll expr(si &p) {\n  ll ret = term(p);\n  while (true) {\n    if (*p == '+') {\n        cch(p, '+');\n        ret += term(p);\n    } else if (*p == '-') {\n        cch(p, '-');\n        ret -= term(p);\n    } else break;\n  }\n  return ret;\n}\n\nint main(void) {\n  int n;\n  cin >> n;\n  cin.ignore();\n  for (int i = 0; i < n; i++) {\n    string s;\n    getline(cin, s);\n\n    si p = s.begin();\n    ll ans = expr(p);\n    cch(p, '=');\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nstring toRPN(string s){\n    stack<char> ope;\n    string ret=\"\";\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ) ret+=s[i];\n        \n        else{\n            if(s[i]=='('){\n                ope.push(s[i]);\n                \n            }else if(s[i]==')'){\n                while(ope.top()!='('){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else{\n                return \"invalid\";\n            }\n        }\n    }\n    while(ope.size()){\n        ret+=ope.top();\n        ope.pop();\n    }\n\n    return ret;\n}\n\n\nstring solveRPN(string s){\n    stack<int> stk;\n\n    \n    for(int i=0;i<s.size();i++){\n        if( isdigit(s[i]) )stk.push( s[i]-'0'  );\n        else{\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            \n            if(s[i]=='+')stk.push(a+b);\n            if(s[i]=='-')stk.push(a-b);\n            if(s[i]=='*')stk.push(a*b);\n            if(s[i]=='/')stk.push(a/b);\n        }\n    }\n    \n    stringstream ret;\n    ret<<stk.top();\n    \n    return ret.str();\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        string s;\n        cin>>s;\n        \n        s.erase(s.size()-1);\n        \n        s=toRPN(s);\n//        s=solveRPN(s);\n    \n        cout<<s<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "n=gets.to_i;n.times{puts eval gets[0..-3]}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\nvoid str2arr(string s, string A[]) {\n    int n = 0;\n    string tmp = \"\";\n\n    for (int i = 0; s[i] != '=' ; i++) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            tmp += s[i];\n        }\n        else {\n            if (tmp != \"\") { \n                A[n++] = tmp;\n                tmp = \"\";\n            }\n            A[n++] = s[i];\n        }\n    }\n    if (tmp != \"\") { A[n++] = tmp; }\n    A[n++] = \"=\";\n}\n\nvoid Generate_RPN(string A[], string B[]) {\n    map<string, int> table;\n    stack<string> St;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n\n    int i, j = 0;\n    for (i = 0; A[i] != \"=\"; i++) {\n        if ('0' <= A[i][0] && A[i][0] <= '9') {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\") {\n            St.push(A[i]);\n        }\n        else if (A[i] == \")\") {\n            while (St.top() != \"(\") {\n                B[j++] = St.top(); St.pop();\n            }\n            St.pop();\n        }\n        else {\n            while ((!St.empty()) && (table[St.top()] >= table[A[i]])) {\n                B[j++] = St.top(); St.pop();\n            }\n            St.push(A[i]);\n        }\n    }\n    while (!St.empty()) {\n        B[j++] = St.top(); St.pop();\n    }\n    B[j] = \"=\";\n}\n\nint Calculate_RPN(string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; s[i] != \"=\"; i++) {\n        if (s[i] == \"+\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = int(St.top()); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    return int(St.top());\n}\n\nint main() {\n    int n;\n    string A[100], B[100];\n    string in;\n\n    cin >> n;\n\n    while (n--) {\n        cin >> in;\n        str2arr(in, A);\n        Generate_RPN(A, B);\n        cout << Calculate_RPN(B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????????\n//??????00-440415D???Smart_Calculator.cpp\n\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\n#include <stdio.h>\n\nusing namespace std;\n\nstring S = \"1+2*(3+4)\";\nsize_t cur = 0;\n\nint expression();\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur])){\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint factor(){\n\tif(S[cur] != '('){\n\t\treturn number();\n\t}else{\n\t\tcur++;\n\t\tint n = expression();\n\t\tassert(S[cur]==')');\n\t\tcur++;\n\t\treturn n;\n\t}\n}\n\n//??????????????????????????????\nint term(){\n\tint a = factor();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*'){\n\t\t\ta *= b;\n\t\t}else if(op == '/'){\n\t\t\ta /= b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(S[cur] == '+' || S[cur] == '-'){\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+'){\n\t\t\tsum += b;\n\t\t}else if(op == '-'){\n\t\t\tsum -= b;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\ndouble calc2(char *eq){\n\tlong c=0, sign[100]={0};\n\tdouble num[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\twhile((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn (long)calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <string>\n#include <map>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nint n;\nstring S;\nint cur;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur++;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur < S.size() && isdigit(S[cur])){\n\t\tn = n * 10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur++;\n\tint n = expression();\n\tcur++;\n\treturn n;\t\n}\n\nint term(){\n\tint sum = number();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = number();\n\t\tif(op == '*') sum *= b;\n\t\telse sum /= b;\n\t}\n\treturn sum;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = term();\n\t\tif(op == '+') sum += b;\n\t\telse sum -= b;\n\t}\n\treturn sum;\n\t\n}\n\n\n\n\n\nint main(void){\n\n\tcin >> n;\n\n\tfor(int i = 0; i < n; i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint term(State &begin);\n\nint factor(State &begin);\n\nint number(State &begin);\n\nint expression(State &begin) {\n    int ret = term(begin);\n    while (true) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = factor(begin);\n    while (true) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    return number(begin);\n}\n\nint number(State &begin) {\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    cin.ignore();\n    while (N--) {\n        string s;\n        getline(cin, s);\n//        cin.ignore();\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string> \n#include <algorithm>\n#include <iostream>\nusing namespace std;\ntypedef string::iterator State;\nbool isdigit(State& pos);\nint number(State& pos);\nint factor(State& pos);\nint expression(State& pos);\nint term(State& pos);\n\nbool isdigit(State& pos)\n{\n\tif('0'<=*pos&&*pos<='9')return true;\n\telse return false;\n}\nint number(State& pos)\n{\n\tint res = 0;\n\twhile(isdigit(pos))\n\t{\n\t\tres*=10;\n\t\tres += (*pos)-'0';\n\t\tpos++;\n\t}\n\treturn res;\n}\nint term(State& pos)\n{\n\tint ret = factor(pos);\n\twhile(*pos == '*'||*pos == '/')\n\t{\n\t\tbool mul = (*pos == '*');\n\t\tpos++;\n\t\tint k = factor(pos);\n\t\tif(mul)ret *= k;\n\t\telse ret/=k;\n\t}\n\treturn ret;\n}\nint factor(State& pos)\n{\n\tint ret;\n\tif(*pos=='(')\n\t{\n\t\tpos++;\n\t\tret = expression(pos);\n\t\tpos++;\n\t}\n\telse ret = number(pos);\n\treturn ret;\n}\nint expression(State& pos)\n{\n\tint ret = term(pos);\n\twhile(*pos == '+'||*pos == '-')\n\t{\n\t\tbool plus = (*pos == '+');\n\t\tpos++;\n\t\tint k = term(pos);\n\t\tif(plus)ret += k;\n\t\telse ret -= k;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tState pos = s.begin();\n\t\tcout << expression(pos) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}\u0000\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,a,b) for(int i=(a); i<(b); i++)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst double EPS=1e-10;\n//int mod=1000000007\n\n\nstring s;\n\n\n\nint calc(int b,int e){\n\tvector<int> v;\n\tvector<char> ope;\n\tfor(int i=b; i<=e; i++){\n\t\tif(s[i]=='('){\n\t\t\tint o=1,c=0;\n\t\t\tfor(int j=i+1; j<=e; j++){\n\t\t\t\tif(s[j]=='(')o++;\n\t\t\t\tif(s[j]==')'){\n\t\t\t\t\tc++;\n\t\t\t\t\tif(o==c){\n\t\t\t\t\t\tint a=calc(i+1,j+1);\n\t\t\t\t\t\tv.pb(a);\n\t\t\t\t\t\ti=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(s[i]>='0'&&s[i]<='9'){\n\t\t\tfor(int j=i+1; j<=e; j++){\n\t\t\t\tif(s[j]<'0'||s[j]>'9'){\n\t\t\t\t\tstring t=s.substr(i,j);\n\t\t\t\t\tv.pb(atoi(t.c_str()));\n\t\t\t\t\ti=j-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tope.pb(s[i]);\n\t\t}\n\t}\n\tfor(int i=0; i<ope.size(); i++){\n\t\tif(ope[i]=='*'){\n\t\t\tv[i+1]=v[i]*v[i+1];\n\t\t\tv[i]=0;\n\t\t\tope[i]=(i==0?'+':ope[i-1]);\n\t\t}\n\t\tif(ope[i]=='*'){\n\t\t\tv[i+1]=v[i]/v[i+1];\n\t\t\tv[i]=0;\n\t\t\tope[i]=(i==0?'+':ope[i-1]);\n\t\t}\n\t}\n\tfor(int i=0; i<ope.size()-1; i++){\n\t\tif(ope[i]=='+'){\n\t\t\tv[0]+=v[i+1];\n\t\t}\n\t\tif(ope[i]=='-'){\n\t\t\tv[0]-=v[i+1];\n\t\t}\n\t}\n\treturn v[0];\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>s;\n\t\tcout<<calc(0,s.size()-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\nSmartCalculator \n教科書がとても丁寧だったので実装は意外とすぐに完成しました。\n関数を部品として少しずつ作っていって、最終的に文法の定義通りに\n組み合わせるという流れがわかりやすかったです。\n構文解析器を作ってみたかったのですが、全学期のPython\bの問題ではよくみる実装と\nは少し違っていて難しかったので、今回のはとても参考になりました。\nもう少し文脈自由文法などとの理論的な結びつきを実感できる様に、いろいろ\n遊んでみたいと思いました。\n短く書くために後置インクリメントが活用できるのが面白かったです。\n勘違いした点としては、int型での計算なので、2／4などが入ると0として\n見なされてしまうので、テストケースと予想結果が合わない時がありました。\n#endif\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <queue>\n#include <cctype>\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\nusing ll = long long;\nll ll_max = numeric_limits<ll>::max();\nll ll_min = numeric_limits<ll>::min();\nint int_max = numeric_limits<int>::max();\nint int_min = numeric_limits<int>::min();\nint N;\nstring S;\nsize_t cur = 0;\n\nchar readchar() {\n    assert(cur < S.size());\n    return S[cur++];\n}\n\nchar peek() {\n    assert(cur < S.size());\n    return S[cur];\n}\n\nint digit() {\n    assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n\nint number() {\n    int n = digit();\n    while (cur < S.size() && isdigit(peek()))\n        n = n * 10 + digit();\n    return n;\n}\n\nint expression();\nint factor() {\n    if (peek() != '(') return number();\n    cur += 1;\n    int n = expression();\n    assert(peek() == ')');\n    cur += 1;\n    return n;\n}\n\nint term() {\n    int num = factor();\n    while (cur < S.size() && (\n            peek() == '*' || peek() == '/')) {\n        char op = readchar();\n        if (op == '*')\n            num *= factor();\n        else\n            num /= factor();\n    }\n    return num;\n}\n\nint expression() {\n    int num = term();\n    while (cur < S.size() && (\n            peek() == '+' || peek() == '-')) {\n        char op = readchar();\n        if (op == '+')\n            num += term();\n        else\n            num -= term();\n    }\n    return num;\n}\n\nint parse() {\n    return expression();\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N;\n    rep(n, N) {\n        cin >> S;\n        cur = 0;\n        int a = parse();\n        // assert(cur == S.size());\n        cout << a << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nP equation(const string &str, int pos=0);\nP factor(const string &str, int pos = 0);\nP term(const string &str, int pos = 0);\n\nP equation(const string &str, int pos){\n\tP res = factor(str,pos);\n\twhile(str[res.second] == '+' || str[res.second] == '-'){\n\t\tP res_ = factor(str,res.second+1);\n\t\tif(str[res.second] == '+') res.first += res_.first;\n\t\telse res.first -= res_.first;\n\t\tres.second = res_.second;\n\t}\n\treturn res;\n}\n\nP factor(const string &str, int pos) {\n\tP res = term(str, pos);\n\twhile (str[res.second] == '*' || str[res.second] == '/') {\n\t\tP res_ = term(str, res.second+1);\n\t\tif(str[res.second] == '*') res.first *= res_.first;\n\t\telse res.first /= res_.first;\n\t\tres.second = res_.second;\n\t}\n\treturn res;\n}\n\nP term(const string &str, int pos) {\n\tif(str[pos] == '('){\n\t\tP res = equation(str,pos+1);\n\t\tres.second += 1;\n\t\treturn res;\n\t} else {\n\t\tint val = 0;\n\t\twhile(isdigit(str[pos])){\n\t\t\tval = val * 10 + (str[pos++]-'0');\n\t\t}\n\t\treturn P(val,pos);\n\t}\n}\n\n\nint main(){\n\tstring str;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>str;\n\t\tP res = equation(str);\n\t\tcout << res.first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define for(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\nstatic const double eps = 1e-9;\n\ntypedef pair<int, int> p;\ntypedef long long ll;\n\ntemplate<class t>\ninline t sq(t a){return a*a;}\n\nint expr();\nint fact();\nint num();\n\n//式 ::= 項 | 項+式 | 項-式\n//項 ::= (式) | 因子*項 | 因子/項\n//因子 ::= 数字\nstring s;\nint ptr;\nint expr(){\n\tint x = fact();\n\tif(s[ptr] == '+'){\n\t\tptr++;\n\t\tx += expr();\n\t}else if(s[ptr] == '-'){\n\t\tptr++;\n\t\tx -= expr();\n\t}\n\treturn x;\n}\n\nint fact(){\n\tint x;\n\tif(s[ptr] == '('){\n\t\tptr++;\n\t\tx = expr();\n\t\tptr++;\n\t}else{\n\t\tx = num();\n\t\tif(s[ptr] == '*'){\n\t\t\tptr++;\n\t\t\tx *= fact();\n\t\t}\n\t\telse if(s[ptr] == '/'){\n\t\t\tptr++;\n\t\t\tx/= fact();\n\t\t}\n\t}\n\treturn x;\n}\n\nint num(){\n\tint x = 0;\n\twhile('0' <= s[ptr] && s[ptr] <= '9'){\n\t\tx *= 10;\n\t\tx += (s[ptr]-'0');\n\t\tptr++;\n\t}\n\treturn x;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\tptr = 0;\n\t\tcout << expr() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\n// Parser<int> number = [](Source &s) {\n//   int val = 0;\n//   while (isdigit(s.peek())) {\n//     val *= 10;\n//     val += s.peek() - '0';\n//     s.next();\n//   }\n//   return val;\n// };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring s;\n\nint si(int&);\nint fi(int&);\nint so(int&);\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> s;\n\t\tint pos = 0;\n\t\tcout << so(pos) << endl;\n\t}\n\n\treturn 0;\n}\nint so(int& pos){\n\tint ans = fi(pos);\n\twhile (s[pos] != '=' && s[pos] != ')'){\n\t\tif (s[pos] == '+'){\n\t\t\tans += fi(++pos);\n\t\t}\n\t\telse if (s[pos] == '-'){\n\t\t\tans -= fi(++pos);\n\t\t}\n\t}\n\tpos++;\n\treturn ans;\n}\nint fi(int& pos){\n\tint ans = si(pos);\n\twhile (1){\n\t\tif (s[pos] == '*'){\n\t\t\tans *= si(++pos);\n\t\t}\n\t\telse if (s[pos] == '/'){\n\t\t\tans /= si(++pos);\n\t\t}\n\t\telse {\n\t\t\treturn ans;\n\t\t}\n\t}\n}\n\nint si(int& pos){\n\tif (s[pos] != '('){\n\t\tint ans = 0;\n\t\twhile ('0' <= s[pos] && s[pos] <= '9'){\n\t\t\tans *= 10;\n\t\t\tans += s[pos] - 48;\n\t\t\tpos++;\n\t\t}\n\t\treturn ans;\n\t}\n\telse{\n\t\treturn so(++pos);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint calc(string s)\n{\n\tvi v;\n\tREP(i, s.size())\n\t{\n\t\tif (s[i] == '+') v.push_back(0);\n\t\telse if (s[i] == '-') v.push_back(1);\n\t\telse if (s[i] == '*') v.push_back(2);\n\t\telse if (s[i] == '/') v.push_back(3);\n\t\telse\n\t\t{\n\t\t\tint tmp = s[i] - '0';\n\t\t\tint t = i+1;\n\t\t\twhile (isdigit(s[t]))\n\t\t\t{\n\t\t\t\ttmp = tmp * 10 + s[t] - '0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\ti = t - 1;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t}\n\n\twhile (v.size() > 1)\n\t{\n\t\tfor (int i = 1; i < v.size();i+=2)\n\t\t{\n\t\t\tif (v[i]==2)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] * v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (v[i] == 3)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] / v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < v.size(); i += 2)\n\t\t{\n\t\t\tif (v[i] == 0)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] + v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (v[i] == 1)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] - v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tnext:;\n\t\t}\n\t}\n\treturn v[0];\n}\n\nint solve(string s)\n{\n\twhile (1)\n\t{\n\t\tif (find(ALL(s), '(') == s.end())\n\t\t{\n\t\t\treturn calc(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring tmp;\n\t\t\tREP(i, s.size())\n\t\t\t{\n\t\t\t\tif (s[i] != '(') tmp.push_back(s[i]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = i;; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[j] == ')')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t = solve(s.substr(i+1, j - i - 1));\n\t\t\t\t\t\t\ttmp += to_string(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[j] == '(') i = j;\n\t\t\t\t\t}\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn solve(tmp);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint sets;\n\tstring s;\n\tcin >> sets;\n\tREP(set, sets)\n\t{\n\t\tcin >> s;\n\t\ts.erase(s.size() - 1);\n\t\tcout << solve(s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\nstring str,t;\n\nstring calc(string s){\n\t\n\tvector<char> otr;\n\totr.reserve(1000);\n\tvector<int> ond;\n\tond.reserve(1000);\n\tstring tmp;\n\tsize_t now = 0;\n\t\n\twhile( ~s.find_first_of(\"*/-+=\",now) ){\n\t\ttmp = s.substr(now,s.find_first_of(\"*/-+=\",now)-now);\n\t\tond.push_back( atoi(tmp.c_str() ) );\n\t\totr.push_back( s[s.find_first_of(\"*/-+=\",now)] );\n\t\tnow = s.find_first_of(\"*/-+=\",now)+1;\n\t}\n\n\tfor(int i=0;i<otr.size();i++){\n\t\tif(otr[i]=='*'){\n\t\t\tond[i] = ond[i] * ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}else if(otr[i]=='/'){\n\t\t\tond[i] = ond[i] / ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}\n\t}\n\n\t/*cout << ond[0];\n\tfor(int j=0;j<otr.size();j++){\n\t\tif(otr[j]=='=')break;\n\t\tcout << \" \" << otr[j] << \" \";\n\t\tcout << ond[j+1];\n\t}\n\tcout << endl;*/\n\t\n\tfor(int i=0;i<otr.size();i++){\n\t\tif(otr[i]=='+'){\n\t\t\tond[i] = ond[i] + ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}else if(otr[i]=='-'){\n\t\t\tond[i] = ond[i] - ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}\n\t}\n\tstringstream ret;\n\tret << ond[0];\n\treturn ret.str();\n}\n\nstring parent(string s){\t\n\tint st,en;\n\twhile( ~s.find(\"(\") ){\n\t\tst = s.find(\"(\");\n\t\ten = s.find(\")\");\n\t\tt = s.substr(st+1,en-st-1);\n\t\ts.replace( st , en-st+1 , parent(t+string(\"=\")));\n\t}\n\treturn calc(s);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(cin >> str){\n\t\t/*\n\t\tif(~s.find(\"(\")){\n\t\t\tst = s.find(\"(\");\n\t\t\ten = s.rfind(\")\");\n\t\t\tt = s.substr(st+1,en-st-1);\n\t\t}*/\n\t\tcout << parent(str) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\n//<expr>   :: = <term>[('+' | '-') <term>] *\n//<term>   :: = <factor>[('*' | '/') <factor>] *\n//<factor> :: = <number> | '(' <expr> ')'\n//<number> : == 1?????\\????????°???\n\n\nll number(string& s, ll& i);\nll term(string& s, ll& i);\nll factor(string& s, ll& i);\nll expr(string& s, ll& i);\n\nll number(string& s, ll& i) {\n\tll n = s[i++] - '0';\n\twhile (isdigit(s[i])) n = n * 10 + s[i++] - '0';\n\treturn n;\n}\n\nll factor(string& s, ll& i) {\n\tif (isdigit(s[i])) return number(s, i);\n\n\t// ????????§?§?????????£???????????° s[i] == '(' ??¨??????\n\ti++; // '('??????????£???°???\n\tll ret = expr(s, i);\n\ti++; // ')'??????????£???°???\n\treturn ret;\n}\n\nll term(string& s, ll& i) {\n\tll val = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = factor(s, i);\n\t\tif (op == '*') val *= val2;\n\t\telse val /= val2;\n\t}\n\treturn val;\n}\n\nll expr(string& s, ll& i) {\n\tll val = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (op == '+') val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\n\nint n;\nll pos = 0;\nstring s;\n\nint main() {\n\tcin >> n;\n\tREP(i,2){\n\t\tcin >> s;\n\t\tpos = 0;\n\t\tcout << expr(s, pos) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n// const string S = \"(1+1)*2\";\nstring S;\nint cur = 0;\nint digit();\nint number();\nint factor();\nint term();\nint _term(int m);\nint exp();\nint _exp(int m);\nint parse();\nbool isdigit(char);\nbool is_plu_min(char);\nbool is_tim_div(char);\nint main() {\n  int N;\n  cin >> N;\n  for (int i=0;i<N;i++) {\n    cin >> S;\n    cur = 0;\n    S.resize(S.size()-1);\n    cout << parse() << endl;\n  }\n  return 0;\n}\nint digit() {\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur]))\n    n = n*10 + digit();\n  return n;\n}\nbool isdigit(char c) {\n  if (c <= '9' and c >= '0') return true;\n  else return false;\n}\nbool is_plu_min(char c) {\n  if (c == '+' || c == '-') return true;\n  else return false;\n}\nbool is_tim_div(char c) {\n  if (c == '*' || c == '/') return true;\n  else return false;\n}\n// exp    = term exp`\n// exp`   = + term exp` | eps\n// term   = factor term`\n// term`  = * factor term` | eps\n// factor = ( exp ) | num\nint term() {\n  int n = factor();\n  return _term(n);\n}\nint _term(int m) {\n  int n = m;\n  switch (S[cur]) {\n    case '*':\n      cur++;\n      n *= factor();\n      return _term(n);\n    case '/':\n      cur++;\n      n /= factor();\n      return _term(n);\n    default:\n      return n;\n  }\n}\nint factor() {\n  if (S[cur] != '(') return number();\n  else {\n    cur++;\n    int n = exp();\n    if (S[cur] != ')') {printf(\"%s\\n\",\"Error about Paren\");return 1000000000;}\n    cur++;\n    return n;\n  }\n}\nint exp() {\n  int n = term();\n  return _exp(n);\n}\nint _exp(int m) {\n  int n = m;\n  switch (S[cur]) {\n    case '+':\n      cur++;\n      n += term();\n      return _exp(n);\n    case '-':\n      cur++;\n      n -= term();\n      return _exp(n);\n    default:\n      return n;\n  }\n}\nint parse() {\n  return exp();"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <valarray>\n#include <utility>\n#include <tuple>\n#include <cmath>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <cctype>\n\n#if (__cplusplus >= 201703L)\n#include <filesystem>\nnamespace fs = std::filesystem;\n#endif\n\n// boost\n//#define USE_BOOST_IN_CODE\n#ifdef USE_BOOST_IN_CODE\n#include <boost/range.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/strided.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/format.hpp>\n#endif\n\nnamespace {\n\n    using ll = long long;\n    using ull = unsigned long long;\n\n    //vector\n    template <class T>\n    using vec = std::vector<T>;\n\n    template <class T>\n    using vv = vec<vec<T>>;\n\n    constexpr std::size_t operator\"\"_sz(ull n) { return std::size_t (n); }\n        \n    template <class T, class BinaryOperation>\n    constexpr T fold(std::initializer_list<T> args, T init, BinaryOperation op)\n    {\n        return std::accumulate(args.begin(), args.end(), init, op);\n    }\n\n    // numeric_low\n    namespace numeric\n    {\n        template<typename T>\n        constexpr bool isOdd(T x)\n        {\n            return x % 2 != 0;\n        }\n\n        template<typename T>\n        constexpr bool isEven(T x)\n        {\n            return x % 2 == 0;\n        }\n\n        // 最大公約数\n        template<class T>\n        constexpr T gcd(const T x, const T y)\n        {\n            if (x < 0)return gcd(-x, y);\n            if (y < 0)return gcd(x, -y);\n            return (!y) ? x : gcd(y, x % y);\n        }\n\n        // 最小公倍数\n        template<class T>\n        constexpr T lcm(const T x, const T y)\n        {\n            if (x < 0)return lcm(-x, y);\n            if (y < 0)return lcm(x, -y);\n            return x * (y / gcd(x, y));\n        }\n\n        // 素数判定\n        template<class T>\n        constexpr bool isPrime(const T x)\n        {\n            if (x <= 1)return false;\n            for (T i = 2; i * i <= x; ++i)\n                if (x % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    // ビット演算\n    namespace bitOp\n    {\n\n        template <int N>\n        constexpr std::size_t distanceBetween(const std::bitset<N> bit, std::size_t current, bool isNext = true)\n        {\n            if (current > N || current < 0) \n                return -1;\n            const int dir = isNext ? 1 : -1;\n            for (auto i = current + dir; i >= 0 && i < N; i += dir)\n                if (bit[i]) \n                    return (i - current) * dir;\n            return -1;\n        }\n\n        // 次の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenNext(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, true);\n        }\n\n        // 前の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenPrev(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, false);\n        }\n    }\n\n\n#ifdef _MSVC_LANG\n#pragma region Vector\n#endif\n    ///////////////////////////////////////////////////////////\n    // Vector\n\n    template <class T>\n    struct Vec3D\n    {\n        T x, y, z;\n\n        Vec3D() = default;\n\n        constexpr Vec3D(T x, T y, T z)\n            : x {x}, y {y}, z {z}\n        {}\n\n        constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0)\n        {}\n\n        static constexpr T Dot(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n        }\n\n        static constexpr Vec3D Cross(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return {\n                lhs.y*rhs.z - lhs.z*rhs.y,\n                lhs.z*rhs.x - lhs.x*rhs.z,\n                lhs.x*rhs.y - lhs.y*rhs.x\n            };\n        }\n\n        constexpr T dot(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        constexpr Vec3D cross(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        T magnitude() const\n        {\n            return std::sqrt(sqrMagnitude());\n        }\n\n        constexpr T sqrMagnitude() const\n        {\n            return x * x + y * y + z * z;\n        }\n\n        Vec3D normalized() const\n        {\n            return *this / magnitude();\n        }\n\n        Vec3D normalize()\n        {\n            *this = normalized();\n            return *this;\n        }\n\n        constexpr bool isZero() const\n        {\n            return x == 0 && y == 0 && z == 0;\n        }\n\n        constexpr Vec3D operator+() const\n        {\n            return *this;\n        }\n\n        constexpr Vec3D operator-() const\n        {\n            return {-x, -y, -z};\n        }\n\n\n        constexpr Vec3D operator+(Vec3D rhs) const\n        {\n            return {x + rhs.x, y + rhs.y, z + rhs.z};\n        }\n\n        constexpr Vec3D operator-(Vec3D rhs) const\n        {\n            return {x - rhs.x, y - rhs.y, z - rhs.z};\n        }\n\n        template <class U>\n        constexpr Vec3D operator*(U rhs) const\n        {\n            return {x * rhs, y * rhs, z * rhs};\n        }\n\n        template <class U>\n        constexpr Vec3D operator/(U rhs) const\n        {\n            return {x / rhs, y / rhs, z / rhs};\n        }\n\n        constexpr Vec3D& operator+=(const Vec3D& other)\n        {\n            x += other.x;\n            y += other.y;\n            z += other.z;\n            return *this;\n        }\n\n        constexpr Vec3D& operator-=(const Vec3D& other)\n        {\n            x -= other.x;\n            y -= other.y;\n            z -= other.z;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator*=(U s)\n        {\n            x *= s;\n            y *= s;\n            z *= s;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator/=(U s)\n        {\n            x /= s;\n            y /= s;\n            z /= s;\n            return *this;\n        }\n\n    };\n\n    template<class T, class U>\n    inline constexpr Vec3D<T> operator*(U s, Vec3D<T> v)\n    {\n        return {s * v.x, s * v.y, s * v.z};\n    }\n\n    // Vector\n    ///////////////////////////////////////////////////////////\n#ifdef _MSVC_LANG\n#pragma endregion Vector\n#endif\n\n    // argsからハッシュ値を作成\n    template <class... Args>\n    std::size_t hash(Args... args)\n    {\n        return fold({static_cast<std::size_t>(args)...}, 0_sz,\n            [](std::size_t seed, std::size_t x)\n            {\n                // uses magic number from boost\n                return seed ^= x + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n            });\n    }\n\n    template <class Begin, class End>\n    void printAll(Begin beginIter, End endIter, std::string delimiter)\n    {\n        for (auto iter {beginIter}; iter != endIter; ++iter)\n        {\n            std::cout << *iter;\n            if (std::distance(iter, endIter) != 1)\n                std::cout << delimiter;\n        }\n    }\n\n    template <class Container>\n    void printAll(const Container& c, std::string delimiter)\n    {\n        printAll(std::cbegin(c), std::cend(c), delimiter);\n    }\n\n    template<class T>\n    void printAll(const std::initializer_list<T>& ini, std::string delimiter)\n    {\n        printAll(ini.begin(), ini.end(), delimiter);\n    }\n\n    //template <class Container>\n    //std::istream& operator>>(std::istream& is, Container& c)\n    //{\n    //    const auto end = std::end(c);\n    //    for (auto iter = std::begin(c); iter != end; ++iter)\n    //        is >> *iter;\n    //    return is;\n    //}\n\n    \n\n    using State = std::string::const_iterator;\n    class ParseError{};\n\n    int expression(State& begin);\n    int term(State& begin);\n    int number(State& begin);\n    int factor(State& begin);\n\n\n    // 四則演算の式をパースして、その評価結果を返す\n    int expression(State& begin)\n    {\n        int ret {term(begin)};\n\n        while (true)\n        {\n            if (*begin == '+')\n            {\n                ++begin;\n                ret += term(begin);\n            }\n            else if (*begin == '-')\n            {\n                ++begin;\n                ret -= term(begin);\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return ret;\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    int term(State &begin)\n    {\n        int ret {factor(begin)};\n        while (true)\n        {\n\n            if (*begin == '*')\n            {\n                ++begin;\n                ret *= factor(begin);\n            }\n            else if (*begin == '/')\n            {\n                ++begin;\n                ret /= factor(begin);\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return ret;\n    }\n\n    // 数をパースして、数を返す。\n    int number(State& begin)\n    {\n        int ret {};\n        while (isdigit(*begin))\n        {\n            ret *= 10;\n            ret += *begin - '0';\n            ++begin;\n        }\n\n        return ret;\n    }\n\n    int factor(State& begin)\n    {\n        if (*begin == '(')\n        {\n            ++begin;    //(\n            int ret = expression(begin);\n            ++begin;    //)\n            return ret;\n        }\n        else\n        {\n            return number(begin);\n        }\n    }\n\n\n    void solve()\n    {\n        using namespace std;\n\n        int n;\n        cin >> n;\n        cin.ignore();\n\n        for (int i = 0; i < n; ++i)\n        {\n            string s;\n            getline(cin, s);\n            auto begin = s.cbegin();\n            cout << expression(begin) << endl;\n        }\n\n\n\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\treturn foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n  //   #define int long long\n            #define mod  1000000009\n            #define pa pair<int,int>\n            #define ll long long\n            #define pal pair<double,int>\n            #define ppa pair<int,pa>\n            #define ssa pair<string,int>\n            #define  mp make_pair\n            #define  pb push_back\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     //priority_queue<int, vector<int>, greater<int> > que;\n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \nstring itos( int i ) {\nostringstream s ;\ns << i ;\nreturn s.str() ;\n}\n\nint gcd(int v,int b){\n\tif(v>b) return gcd(b,v);\n\tif(v==b) return b;\n\tif(b%v==0) return v;\n\treturn gcd(v,b%v);\n}\n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \ndouble distans(double x1,double y1,double x2,double y2){\n\tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n\treturn sqrt(rr);\n\t\n}\n            //----------------kokomade tenpure------------\nstring s;\nint kakko(string &t ,int &b);\n\nint suuji(string &t, int &b){\n\tint r=0;\n\tif(isdigit(t[b])){\n\twhile(isdigit(t[b])){\n\t\tr *=10;\n\t\tr += t[b]-'0';\n\t\t(b)++;\n\t}\n\t}\n\telse if(t[b]=='('){\n\t\n\t\tr=kakko(t,b);\n\t\t\n\t}\n\t\n\treturn r;\n}\n\n\nint kake(string &t, int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=suuji(t,b);\n\t//cout<<i<<endl;\n\t\twhile((t[b]=='*')||(t[b]=='/')){\n\t\t\tb++;\n\t\t\tif(t[b-1]=='*')i *= suuji(t,b);\n\t\t\telse i /= suuji(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint tashi(string &t ,int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=kake(t,b);\n\t\twhile((t[b]=='+')||(t[b]=='-')){\n\t\tb++;\n\t\t\tif(t[b-1]=='+')\ti += kake(t,b);\n\t\t\telse i -= kake(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint kakko(string &t ,int &b){\n\t\n\tif(t[b]=='('){\n\t\tint y;\n\t\tb++;\n\t\ty=kakko(t,b);\n\t\tb++;\n\t\treturn y;\n\t}\n\telse{\n\t\treturn tashi(t,b);\n\t}\n}\n    signed  main(){\n    \tint n;\n    \tcin>>n;\n    \tfor(int g=0;g<n;g++){\ncin>>s;\n    \tint i=0;\n    \tcout<<tashi(s,i)<<endl;\n    \t}\n    \n  //  \tprintf(\"%.10f\\n\",ans[n-1]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s, int& i) {\n    int val = term(s, i);\n    while(s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        i++;\n        int val2 = term(s, i);\n        if (op == '+') val += val2;\n        else val -= val2;\n    }\n    return val;\n}\n\nint term(string& s, int& i) {\n    int val = factor(s, i);\n    while(s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        i++;\n        int val2 = factor(s, i);\n        if (op == '*') val *= val2;\n        else val /= val2;\n    }\n    return val;\n}\n\nint factor(string& s, int& i) {\n    if (isdigit(s[i])) return number(s, i);\n\n    // ここで構文が正しければ s[i] == '(' となる\n    i++; // '('を読み飛ばす\n    int ret = expr(s, i);\n    i++; // ')'を読み飛ばす\n    return ret;\n}\n\nint number(string& s, int& i) {\n    int n = s[i++] - '0';\n    while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n    return n;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        string str;\n        cin >> str;\n        int j = 0;\n        cout << expr(str, j) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"pch.h\"\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ninline bool is_op(string &in) {\n\tif (in.size() == 1 && !isdigit(in[0]))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\ninline bool is_num(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\ninline bool is_expr(string &in)\n{\n\tif (!is_num(in) && !is_op(in)) { return true; }\n\telse { return false; }\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\treturn(stoi(in[0]));\n}\nint main()\n{\n\t/*string tmp = \"(-2*2)*5+(1+2)*(3+4)\";\n\tauto out=split(tmp);\n\tfor (auto i : out) {\n\t\tcout << i << endl;\n\t}\n\tcout << cal(tmp) << endl;*/\n\tstring input;\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint factor(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expression (State &begin) {\n\tint ret = term(begin);\n\n\tfor (;;) {\n\t\tif(*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor (State &begin) {\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(;n;n--){\n\t\tstring s;\n\t\tcin >> s;\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring str;\nint cur = 0;\n\nint expression();\nint term();\nint factor();\n\nint digit() {\n    int a = str[cur] - '0';\n    cur++;\n    return a;\n}\n\nint number() {\n    int a = digit();\n    while (cur < str.size() && isdigit(str[cur])) {\n        a = a * 10 + digit();\n    }\n    return a;\n}\n\nint expression() {\n    int a = factor();\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        if (str[cur] == '+') {\n            cur++;\n            int b = factor();\n            a += b;\n        } else if (str[cur] == '-') {\n            cur++;\n            int b = factor();\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint term() {\n    int a = number();\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        if (str[cur] == '*') {\n            cur++;\n            int b = factor();\n            a *= b;\n        } else if (str[cur] == '/') {\n            cur++;\n            int b = factor();\n            a /= b;\n        }\n        cur++;\n    }\n    return a;\n}\n\nint factor() {\n    if (str[cur] != '(') return term();\n\n    cur++;\n    int a = expression();\n    cur++;\n    return a;\n}\n\nint main() {\n    int N = 0;\n    cin>>N;\n    for (int n = 0; n < N; n++) {\n        cin>>str;\n        cur = 0;\n        cout<<expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\n\n#include <string>\n#include <cctype>\ntypedef string::const_iterator State;\n\nint expression(State &);\nint term(State &);\nint number(State &);\nint factor(State &);\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\n\n\nint main(){\n  int n;\n  cin>>n;\n  REP(i,0,n){\n    string s;\n    cin>>s;\n    State begin = s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nint parse(string s){\n    int i,j,x;\n    int n = s.length();\n\n    //cout << s << endl;\n\n    x = 0;\n    for(i=n-1; i>=0; i--){\n        if( s[i] == '(' ) x++;\n        if( s[i] == ')' ) x--;\n        if( x == 0 && (s[i] == '+' || s[i] == '-') ) break;\n    }\n\n    if( i == -1 ){\n        x = 0;\n        for(i=n-1; i>=0; i--){\n            if( s[i] == '(' ) x++;\n            if( s[i] == ')' ) x--;\n            if( x == 0 && (s[i] == '*' || s[i] == '/') ) break;\n        }\n    }\n\n    if( i == -1 ){\n        for(j=0; j<n; j++) if( !('0' <= s[j] && s[j] <= '9') ) break;\n        if( j == n ){ // number\n            return atoi(s.c_str());\n        }\n        // ()\n        return parse(s.substr(1,s.length()-2));\n    }\n    else{\n        int a = parse(s.substr(0,i)), b = parse(s.substr(i+1));\n        switch(s[i]){\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n        }\n    }\n}\n\nint main(){\n    int T;\n    string in;\n\n    cin >> T;\n    while( T-- ){\n        cin >> in;\n        cout << parse(in.substr(0,in.length()-1)) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nvoid select_cal(char c, int *tmp, int val){\n\n\tif(c == '+') *tmp += val;\n\telse if(c == '-') *tmp -= val;\n\telse if(c == '*') *tmp = floor(*tmp * val);\n\telse if(c == '/' && val != 0) *tmp = floor(*tmp / val);\n\n}\n\nint calculation(string str, int len, int begin){\n\n\tint ans, tmp, cnt;\n\tchar c;\n\t\n\tans = 0;\n\ttmp = 0;\n\tc = '+';\n\n\tfor(int i=begin; i<len; i++){\n\t\tif(str[i] == '+' || str[i] == '-'){\n\t\t\tans += tmp;\n\t\t\ttmp = 0;\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '*' || str[i] == '/'){\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '('){\n\t\t\tselect_cal(c, &tmp, calculation(str, len, i+1));\n\t\t\tcnt = 1;\n\t\t\tdo{\n\t\t\t\ti++;\n\t\t\t\tif(str[i] == '(') cnt++;\n\t\t\t\telse if(str[i] == ')') cnt--;\n\t\t\t}while(cnt != 0);\n\t\t}\n\t\telse if(str[i] == ')' || str[i] == '='){\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tselect_cal(c, &tmp, str[i] - '0');\n\t\t}\n\t}\n\tans += tmp;\n\n\treturn ans;\n\n}\n\nint main(){\n\n\tint n;\n\tstring str;\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> str;\n\t\tcout << calculation(str, str.length(), 0) << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\ntypedef long long ll;\n\nint it, n;\nstring input;\n\nll expr();\nll term();\nll fact();\n\nll expr() {\n    int v = term();\n    while (input[it] == '+' || input[it] == '-') {\n        if (input[it++] == '+') {\n            v += term();\n        } else {\n            v -= term();\n        }\n    }\n    return v;\n}\n\nll term() {\n    int v = fact();\n    while (input[it] == '*' || input[it] == '/') {\n        if (input[it++] == '*') {\n            v *= term();\n        } else {\n            v = (int)trunc(1.0*v/term());\n            //v /= term();\n        }\n    }\n    return v;\n}\n\nll fact() {\n    int v = 0;\n    if (input[it] == '(') {\n        ++it; // '('\n        v = expr();\n        ++it; // ')'\n    } else {\n        int sign = input[it] == '-' ? ++it, -1 : 1;\n        while ('0' <= input[it] && input[it] <= '9') {\n            v = 10*v + input[it]-'0';\n            ++it;\n        }\n    }\n    return v;\n}\n\nint main() {\n    cin >> n;\n    rep (i,n) {\n        cin >> input;\n        it = 0;\n        cout << expr() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nstring s;\nint a;\nint func();//+-\nint num();\nint func2();//*/\nint func3();//()\nint num(){\n\tint out=0;\n\twhile(isdigit(s[a])){\n\t\tout*=10;out+=s[a]-'0';\n\t\ta++;\n\t}\n\treturn out;\n}\nint func3(){\n\tint out;\n\tif(s[a]=='('){\n\t\ta++;\n\t\tout=func();\n\t\ta++;\n\t}else out=num();\n\treturn out;\n}\nint func2(){\n\tint out=func3();\n\twhile(1){\n\t\tif(s[a]=='*'){\n\t\t\ta++;\n\t\t\tout*=func3();\n\t\t}else if(s[a]=='/'){\n\t\t\ta++;\n\t\t\tout/=func3();\n\t\t}else break;\n\t}\n\treturn out;\n}\t\nint func(){\n\tint out=func2();\n\twhile(1){\n\t\tif(s[a]=='+'){\n\t\t\ta++;out+=func2();\n\t\t}else if(s[a]=='-'){\n\t\t\ta++;out-=func2();\n\t\t}else break;\n\t}\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\ta=0;\n\t\tcin>>s;\n\t\t//s=\"0+\"+s;\n\t\tcout<<func()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;(i)>=0;(i)--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n\ntypedef long long ll;\n\n\nclass Source{\nprivate:\n    string str;\n    int pos;\n    \npublic:\n    int peek(){\n        if(pos<str.size())return str[pos];\n        return -1;\n    }\n    \n    void next(){\n        pos++;\n    }\n    \n    void init(string _str){\n        str=_str;\n        pos=0;\n    }\n    \n};\n\n\nclass Parser{\nprivate:\n    Source src;\n    \npublic:\n    Parser(string str){\n        src.init(str);\n    }\n    \n    bool isDigit(char s){\n        if(s>='0'&&s<='9')return true;\n        return false;\n    }\n    \n    int number(){\n        string res;\n        while(src.peek()!=-1&&isDigit(src.peek())){\n            res+=src.peek();\n            src.next();\n        }\n        return stoi(res);\n    }\n    \n    int expr(){\n        int x=term();\n        while(true){\n            switch(src.peek()) {\n                case '+':\n                    src.next();\n                    x+=term();\n                    continue;\n                case '-':\n                    src.next();\n                    x-=term();\n                    continue;\n            }\n            break;\n        }\n        return x;\n    }\n    \n    int term(){\n        int x=factor();\n        while(true){\n            switch(src.peek()){\n                case '*':\n                    src.next();\n                    x*=factor();\n                    continue;\n                case '/':\n                    src.next();\n                    x/=factor();\n                    continue;\n            }\n            break;\n        }\n        return x;\n    }\n    \n    int factor(){\n        if(src.peek()=='('){\n            src.next();\n            int res=expr();\n            if(src.peek()==')'){\n                src.next();\n            }\n            return res;\n        }\n        return number();\n    }\n    \n};\n\n\n\nint main(){\n  \n    int n;\n    cin>>n;\n    \n    REP(i,n){\n        string s;\n        cin>>s;\n        \n        s=s.substr(0,s.size()-1);\n        \n        Parser par(s);\n        cout<<par.expr()<<endl;\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cctype>\nusing namespace std;\nstring S;\nint cur;\nchar readchar()\n{\n    assert(cur<S.size());\n    char ret=S[cur];\n    cur++;\n    return ret;\n}\nchar peek()\n{\n    assert(cur<S.size());\n    return S[cur];\n}\nint digit()\n{\n    assert(isdigit(peek()));\n    int n=readchar()-'0';\n    return n;\n}\nint number()\n{\n    int n=digit();\n    while(cur < S.size() && isdigit(peek()))\n    {\n        n=n*10+digit();\n    }\n    return n;\n}\n//-----------------\nint factor();\nint term()\n{\n    int a=factor();\n    while(cur<S.size()&&(peek()=='*'||peek()=='/'))\n    {\n        char op=readchar();\n        int b=factor();\n        if(op=='*')\n            a*=b;\n        else\n            a/=b;\n    }\n    return a;\n}\n\nint expression()\n{\n    int a=term();\n    while(cur<S.size()&&(peek()=='+'||peek()=='-'))\n    {\n        char op=readchar();\n        int b=term();\n        if(op=='+')a+=b;\n        else a-=b;\n    }\n    return a;\n}\n\nint factor()\n{\n    if(peek()!='(')return number();\n    cur+=1;\n    int n=expression();\n    assert(peek()==')');\n    cur+=1;\n    return n;\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cur=0;\n        cin>>S;\n        cout<<expression()<<endl;\n        S.erase(S.begin(),S.end());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <stack>\n\nchar buf[128];\nint pos;\n#define NOW (buf[pos])\n\nbool isdigit(char c) {\n\treturn ('0' <= c && c <= '9');\n}\n\nbool isstrong(char c) {\n\treturn (c=='*'||c=='/');\n}\nbool isweak(char c) {\n\treturn (c=='+'||c=='-');\n}\n\nint digit() {\n\tif ( !isdigit(NOW) ) {\n\t\tfprintf(stderr, \"%c: \", NOW);\n\t\tassert( isdigit(NOW) );\n\t}\n\tint ret = NOW - '0';\n\tpos++;\n\t\n\treturn ret;\n}\nint number() {\n\tint ret = digit();\n\twhile( isdigit(NOW) ) {\n\t\tret = ret*10 + digit();\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\n\tint set;\n\tscanf(\"%d\", &set);\n\t\n\twhile(set--) {\n\t\tscanf(\"%s\", buf);\n\t\tpos = 0;\n\t\t\n\t\tstd::stack<char> expr;\n\t\tstd::stack<int>  num;\n\t\t\n\t\texpr.push('(');\n\t\t\n\t\twhile(true) {\n\t\t\tif(isdigit(NOW)) {\n\t\t\t\tnum.push( number() );\n\t\t\t} else {\n\t\t\t\tif ( expr.top() == '(' && (NOW==')'||NOW=='=') ) {\n\t\t\t\t\t//対応する括弧が出てきたので、スタック上の括弧を消す\n\t\t\t\t\texpr.pop();\n\t\t\t\t\tpos++;\n\t\t\t\t\tif ( expr.empty() ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if ( expr.top() == '(' ||\n\t\t\t\t     NOW == '(' ||\n\t\t\t\t\t ( isstrong(NOW)&&isweak(expr.top()) ) ) {\n\t\t\t\t\t//強い演算子はスタックに積んでおく。括弧が積んであるなら、無条件に積む\n\t\t\t\t\texpr.push(NOW);\n\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\t//次の演算子は弱いor同じだから、積んでるものを先に計算してしまおう\n\t\t\t\t\tchar de = expr.top(); expr.pop();\n\n\t\t\t\t\tint b = num.top(); num.pop();\n\t\t\t\t\tint a = num.top(); num.pop();\n\t\t\t\t\tint ans;\n\t\t\t\t\tswitch(de) {\n\t\t\t\t\t\tcase '+': ans=a+b; break;\n\t\t\t\t\t\tcase '-': ans=a-b; break;\n\t\t\t\t\t\tcase '*': ans=a*b; break;\n\t\t\t\t\t\tcase '/': ans=a/b; break;\n\t\t\t\t\t}\n\t\t\t\t\tnum.push(ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", num.top());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iter;\n\nint expr(Iter &p);\nint term(Iter &p);\nint factor(Iter &p);\nint number(Iter &p);\n\nint expr(Iter &p) {\n\tint r = term(p);\n\tfor(;;)  {\n\t\tif(*p == '+') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr += rs;\n\t\t}\n\t\telse if(*p == '-') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr -= rs;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nint term(Iter &p) {\n\tint r = factor(p);\n\tfor(;;) {\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr *= rs;\n\t\t}\n\t\telse if(*p == '/') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr /= rs;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nint factor(Iter &p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\tint r = expr(p);\n\t\tp++;\n\t\treturn r;\n\t}\n\telse\n\t\treturn number(p);\n}\n\nint number(Iter &p) {\n\tint r = 0;\n\twhile(isdigit(*p)) {\n\t\tr *= 10;\n\t\tr += *p - '0';\n\t\tp++;\n\t}\n\treturn r;\n}\n\nint main() {\n\tstring line;\n\tgetline(cin, line);\n\tline = line += \"|\";\n\tIter begin = line.begin();\n\tcout << expr(begin) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cctype>\ntypedef string::const_iterator State;\nclass Parse Error{};\n\nint main(void){\n  int N;\n  cin >>N;\n  cin.ignore()\n  for(int i =0; i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begibn =s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint number(state &begin){\n  int ret =0;\n\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret +=~ *begin -'0';\n    begin++;\n  }\n\n  return ret;\n}\n\nint term(State &begin){\n  int ret =number(begin);\n\n  for(;;){\n    if(*begin == '*'){\n      begin++;\n      ret *= factor(begin);\n    } else if (*begin =='/'){\n      begin++;:\n      ret /= factor(begin);\n    } else{\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin =='('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n  } else{\n    return number(begin);\n  }\n}\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  for(;;){\n    if(*begin == '+'){\n      begin++;\n      ret += term(begin);\n    } else if(*begin =='-'){\n      begin++;\n      ret -=term(begin);\n    } else{\n      break;\n    }\n  }\n  return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num;\nstack<char> op;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] > order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n \t\t\twhile(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\twhile(!op.empty())\n\t\tcalc();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <cctype>/////////////////////////////////////\n#include <memory>\nclass Parser{\n\nprivate:\n    \n    typedef std::string::const_iterator State;\npublic:\n    Parser(){\n\n    }\n    ~Parser(){}\n\n    long long int parse(std::string o_s){\n        std::string::const_iterator s=o_s.begin();\n\n\n        return expression(s);\n    }\n    long long int num_or_brackets(State &b){\n        long long int result=-1;\n        if(*b=='('){\n            b++;\n            result=expression(b);\n            if(*b==')'){\n                b++;\n            }else{\n                std::cout << \"括弧の対応が正しくありません\" << std::endl;\n            }\n        }else if(isdigit(*b)){\n            result=number(b);\n        }else if(*b==')'){\n            std::cout << \"括弧の対応が正しくありません\" << std::endl;\n        }else{\n            std::cout << \"数式に数字，記号以外のものが含まれています: \"<<*b << std::endl;\n            return -1;\n        }\n        return result;\n    }\n    long long int number(State &b){\n        long long int result = 0;\n        while(isdigit(*b)){\n            result *= 10;\n            result += (long long int)(*b - '0');\n            b++;\n        }\n        return result;\n    }\n    long long int term(State &b){\n        long long int result=num_or_brackets(b);\n        while(1){\n            if(*b=='*'){\n                b++;\n                result *= num_or_brackets(b);\n\n            }else if(*b=='/'){\n                b++;\n                result /= num_or_brackets(b);\n            }else{\n                break;\n            }\n        }\n        //std::cout << result << std::endl;\n        return result;\n    }\n    long long int expression(State &b){\n        long long int result;\n        if(*b=='-'){\n            result = -term(b);\n        }else{\n            result = term(b);\n\n\n        }\n        while(*b!='\\0'){\n            if(*b=='+'){\n                b++;\n                result += term(b);\n            }else if(*b=='-'){\n                b++;\n                result -= term(b);\n            }else if(*b==')'||*b=='='){\n                return result;\n            }else{\n                std::cout << \"数式に数字，記号以外のものが含まれています: \"<<*b << std::endl;\n                return -1;\n            }\n        }\n        return result;\n    }\n\n\n\n};\n\n\nint main(){\n    std::unique_ptr<Parser> parser(new(Parser));\n    long long int n;\n    std::cin >> n;\n    std::string s;\n\n    for (long long int i=0; i < n; i++)\n    {\n\n        std::cin >> s;\n        std::cout<<parser->parse(s)<<std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\n// Parser<int> number = [](Source &s) {\n//   int val = 0;\n//   try {\n//     while (isdigit(s.peek())) {\n//       val *= 10;\n//       val += s.peek() - '0';\n//       s.next();\n//     }\n//   } catch (const std::string &) {}\n//   return val;\n// };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\nauto term = eval(factor, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        s[0] = '\\0';\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0'; //????°????=?????????\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint calc(char *s, int &i){\n  int ret = 0;\n  bool flag = i >= 0 && s[i-1] == '(';\n  \n  for(;s[i];){\n    \n    if(s[i] == ')'){\n      if(flag) i++;\n      return ret;\n    }\n    \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\n      i++;\n      \n      if(s[i] == '('){\n        i++;\n\n        if(i-2 < 0) ret += calc(s,i);\n        if(s[i-2] == '+') ret += calc(s,i);\n        if(s[i-2] == '-') ret -= calc(s,i);\n        if(s[i-2] == '*') ret *= calc(s,i);\n        if(s[i-2] == '/') ret /= calc(s,i);\n\n        continue;\n      }\n\n            \n      if(s[i-1] == '+') ret += calc(s,i);\n      if(s[i-1] == '-') ret -= calc(s,i);\n      \n    }else{\n      int start = i-1;\n      int sum = 0;\n      \n      while(!(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '\\0' || s[i] == ')')){\n        sum *= 10;\n        sum += s[i] - '0';\n        i++;\n      }\n\n      if(start < 0){\n        ret += sum;\n      }else{\n        if(s[start] == '(') ret += sum;\n        if(s[start] == '+') ret += sum;\n        if(s[start] == '-') ret += sum;\n        if(s[start] == '*') ret *= sum;\n        if(s[start] == '/') ret /= sum;\n      }\n    }\n  }\n  \n  return ret;\n}\n\n\nint main(){\n  char s[SIZE],s2[SIZE];\n  int t = 0;\n\n  int n;\n\n  scanf(\"%d\",&n);\n\n  while(n--){\n    t = 0;\n    scanf(\"%s\",s);\n\n    s[strlen(s)-1] = '\\0';\n\n    strcat(s2,\"0+\");\n    strcat(s2,s);\n    \n    printf(\"%d\\n\",calc(s2,t));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar str[120];\n\nint calc2(char *eq){\n\tint c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nint calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tint k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%d%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tint i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "n=int(input())\nfor i in range(n):\n\ta=input()\n\tb=\"\"\n\tfor i in a:\n\t\tb+=i\n\t\tif i=='/':b+='/'\n\tprint(int(eval(b[:len(b)-1])))"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tif (j != 0){\n\t\t\t\t\t\tsize1 = res.substr(j + 1, i - j - 1).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = i;\n\t\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*'){\n\t\t\t\t\t\tnum1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\t}\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t}\n\n\t//cout << \"!!\" << res << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tif (i == 0)continue;\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = res.substr(j, i - j).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\t//cout << \"!!\" << i  << endl;\n\t\t//cout << res << endl;\n\t\tint pos1, pos2, size;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\t//cout << res.substr(pos1 + 1, pos2 - pos1 - 1) << endl;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tsize = buf.size();\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2 + 1, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = pos1 + size - 1;\n\t\t\t//cout << \"!\" << i << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <string>\nusing namespace std;\n\nint exp(string &s, int &i);\nint term(string &s, int &i);\nint factor(string &s, int &i);\nint number(string &s, int &i);\n\nint exp(string &s, int &i)\n{\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-'){\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if(op == '+') val += val2;\n    else val -= val2;\n  }\n  return val;\n}\n\nint term(string &s, int &i)\n{\n  int val = factor(s, i);\n  while(s[i] == '*' || s[i] == '/'){\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if(op == '*') val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\n\nint factor(string &s, int &i)\n{\n  if(isdigit(s[i]))\n    return number(s, i);\n  i++;\n  int val = exp(s, i);\n  i++;\n  return val;\n}\n\nint number(string &s, int &i)\n{\n  int n = s[i] - '0';\n  i++;\n  while(isdigit(s[i])){\n    n = n * 10 + (s[i] - '0');\n    i++;\n  }\n  return n;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  for(int j = 0; j < n; j++){\n    string s;\n    cin >> s;\n    int i = 0;\n    cout << exp(s, i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State& base);\nint number(State& base){\n    int ret=0;\n    while(isdigit(*base)){\n        ret=ret*10+(*base-'0');\n        base++;\n    }\n    return ret;\n}\nint factor(State& base){\n    int ret;\n    if(*base=='('){\n        base++;\n        ret=expression(base);\n        base++;\n        return ret;\n    }\n    else\n        return number(base);\n}\nint term(State& base){\n    int ret=factor(base);\n    while(1){\n        if(*base=='*'){\n            base++;\n            ret*=factor(base);\n        }\n        else if(*base=='/'){\n            base++;\n            ret/=factor(base);\n        }\n        else break;\n    }\n    return ret;\n}\nint expression(State& base){\n    int ret=term(base);\n    while(1){\n        if(*base=='+'){\n            base++;\n            ret+=term(base);\n        }\n        else if(*base=='-'){\n            base++;\n            ret-=term(base);\n        }\n        else break;\n    }\n    return ret;\n}\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        string str;\n        cin>>str;\n        State base = str.begin();\n        cout<<expression(base)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint isOP(char z){\n  if(z=='+')return mod+1;\n  if(z=='-')return mod+2;\n  if(z=='*')return mod+3;\n  if(z=='/')return mod+4;\n  return 0;\n}\nint solve(string s){\n  queue<int> Q;\n  int cnt=0,i=0;\n  bool done=false;\n  while(i<s.size()){\n    \n    if('0'<=s[i]&&s[i]<='9'){\n      cnt*=10;\n      cnt+=s[i]-'0';\n      done=true;\n    }\n    else{\n      if(done)Q.push(cnt);\n      done=false;\n      cnt=0;\n    }\n    \n    if(s[i]=='('){\n      int pnt=0,tnt=1;\n      for(int j=i+1;j<s.size();j++){\n\tif(s[j]=='(')tnt++;\n\tif(s[j]==')')tnt--;\n\tif(tnt==0){pnt=j;break;}\n      }\n      Q.push(solve(s.substr(i+1,pnt-i-1)));\n      i=pnt+1;continue;\n    }\n    \n    int tmp=isOP(s[i]);\n    if(tmp>0)Q.push(tmp);\n    \n    i++;\n  }\n  if(done)Q.push(cnt);\n  \n  queue<int> R;\n  int x;\n  while(!Q.empty()){\n    int a=Q.front();Q.pop();\n    if(a==mod+1||a==mod+2){\n      R.push(x);\n      R.push(a);\n    }\n    if(a==mod+3){\n      int b=Q.front();Q.pop();\n      x*=b;\n    }\n    if(a==mod+4){\n      int b=Q.front();Q.pop();\n      x/=b;\n    }\n    if(a<mod) x=a;\n  }\n  R.push(x);\n  \n  x=0;\n  while(!R.empty()){\n    int a=R.front();R.pop();\n    if(a==mod+1){\n      int b=R.front();R.pop();\n      x+=b;\n    }\n    if(a==mod+2){\n      int b=R.front();R.pop();\n      x-=b;\n    }\n    if(a<mod) x=a;\n  }\n  return x;\n}\n\nint main(){\n  int n;cin>>n;\n  lol(i,n){\n    string s;\n    cin>>s;\n    s=s.substr(0,s.size()-1);\n    cout<<solve(s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint factor(State &begin);\n\nint number(State &begin){\n    int ret=0;\n\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin -'0';\n        begin++;\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n\n    while(true){\n        if(*begin=='*')ret*=factor(++begin);\n        else if(*begin=='/')ret/=factor(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret=term(begin);\n    while(true){\n        if(*begin=='+')ret+=term(++begin);\n        else if(*begin=='-')ret-=term(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin=='(')return expression(++begin++);\n    else  return number(begin);\n}\n\nint main(){\n\n    int N;\n    cin>>N;\n    cin.ignore();\n    REP(i,N){\n\n        string s;\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cassert>\n#include <cctype>\nusing namespace std;\nstring S;\nsize_t cur = 0;\nint term();\nint factor();\nint expression();\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0'; \n\tcur = cur + 1;\n\treturn n;\n}\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur]))\n\t\tn = n*10 + digit();\n\treturn n;\n}\nint expression(){\n\tint a =term();\n\twhile (cur < S.size()) && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+') a += b;\n\t\telse a -= b;\n\t}\n\treturn a;\n}\nint term(){\n\tint a =factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur +=1;\n\treturn n;\n}\nint main() {\n\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N;++i){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit() {\n\tint n;\n\tassert(isdigit(S[cur]));\n\tn = S[cur] -'0';\n\t++cur;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur])) {\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor() {\n\tint n;\n\tif (S[cur] != '(') n = number();\n\telse {\n\t\t++cur;\n\t\tn = expression();\n\t\tassert(S[cur] == ')');\n\t\t++cur;\n\t}\n\treturn n;\n}\n\nint term() {\n\tint t = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*') t *= b; else t = (int)trunc(1.0*t/b);\n\t\t//cout << t << endl;\n\t}\n\treturn t;\n}\n\n\n/*int expression() {\n\tint sum = number();\n\twhile (S[cur] == '+' || S[cur] == '-') {\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif(op == +) sum += b;\telse return sum -= b;\n\t}\n\treturn sum;\n}*/\n\nint expression() {\n\tint sum = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+') sum += b; else sum -= b;\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N; ++i) {\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nint apply(int lhs, char op, int rhs) {\n  switch (op) {\n  case '+': return lhs+rhs;\n  case '-': return lhs-rhs;\n  case '*': return lhs*rhs;\n  case '/': return lhs/rhs;\n  }\n  assert(false);\n}\n\nint parse(const std::string &s, size_t &i, size_t preced=0) {\n  const std::vector<std::string> ops={\"+-\", \"*/\"};\n  if (preced == ops.size()) {\n    if (s[i] == '(') {\n      int res=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if (isdigit(s[i])) {\n      int res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*10+s[i]-'0';\n      return res;\n    }\n    assert(false);\n  }\n  int res=parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    int tmp=parse(s, ++i, preced+1);\n    res = apply(res, op, tmp);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i=0; i<n; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    std::string s=buf;\n    size_t j=0;\n    printf(\"%d\\n\", parse(s, j));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring get_term(string, int&);\nint get_num(string);\nint get_exp(string);\n\nint get_num(string str) {\n    int num = 0;\n\n    if (str.size() == 0) return 0;\n\n    int i = 0;\n    if (str[i] == '(') {\n        i++;\n        string exp;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n            if (count) exp += str[i];\n        }\n\n        num = get_exp(exp + \"=\");\n    } else {\n        for (; '0' <= str[i] && str[i] < '9'; i++) {\n            num = num * 10 + (str[i] - '0');\n        }\n    }\n\n    for (; i < str.size(); i++) {\n        if (str[i] == '*') {\n            i++;\n            return num * get_num(string(str.begin() + i, str.end()));\n        } else {\n            i++;\n            return num / get_num(string(str.begin() + i, str.end()));\n        }\n    }\n\n    return num;\n}\n\n\nvoid solve(string str) {\n    cout << get_exp(str) << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    while (N--) {\n        string str;\n        cin >> str;\n        solve(str);\n    }\n\n    return 0;\n}\n\nstring get_term(string str, int& i) {\n    string init_str;\n    for (int count = 0; i < str.size(); i++) {\n        if (str[i] == '(') count++;\n        if (count > 0 || ('0' <= str[i] && str[i] <= '9') || str[i] == '/' || str[i] == '*') {\n            init_str += str[i];\n        }\n        if (str[i] == ')') count--;\n\n        if (count == 0 && (str[i] == '+'|| str[i] == '-' || str[i] == '=')) {\n            break;\n        }\n    }\n\n    return init_str;\n}\n\nint get_exp(string str) {\n    int num  = 0;\n    int i = 0;\n\n    string init_str = get_term(str, i);\n    num = get_num(init_str);\n\n    while (str[i] != '=') {\n        if (str[i] == '-') {\n            i++;\n            string term = get_term(str, i);\n            num -= get_num(term);\n        } else if (str[i] == '+') {\n            i++;\n            string term = get_term(str, i);\n            num += get_num(term);\n        }\n    }\n\n    return num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nbool is_digit(char c){\n  return '0' <= c && c <= '9';\n}\nstring i2s(int i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\n\nstring parse(int i, string s) {\n  //cout<<s<<endl;\n  bool flag = true;\n  \n  // brace\n  if (s.find('(') != -1) {\n    // æª©ç`FbNµÄA')'Éoï¤êÆ\n    // »¤ÅÈ¢êÉª¯é\n    bool mode = true;\n    REP(j,s.find('(')+1, s.size()) {\n      if (s[j] == ')') break;\n      if (s[j] == '(') {\n        mode = false;\n        break;\n      }\n    }\n    // ÊÌÊuðæ¾·é\n    int lbr = s.find('('), rbr;\n    if (mode) {\n      rbr = s.find(')');\n    } else {\n      for(int j=s.size()-1;j>=0;j--) if (s[j] == ')') {\n        rbr = j; break;\n      }\n    }\n    // ÊàÌvZðæÉs¤½ßÉssð¾é\n    string inner = parse(0, s.substr(lbr+1, rbr-lbr-1));\n    // ÊàðÁ·é\n    s.erase(lbr, rbr-lbr+1);\n    s.insert(lbr, inner);\n    //cout<<\"brace:\"<<s<<endl;\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '*' || s[i] == '/') {\n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    if (ri + 1 < s.size() && s[ri] == '-') ri++;\n\n    while (is_digit(s[li]) || s[li] == '-' && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    //cout<<s.substr(li+1, i-1-li)<<\"|\"<<s.substr(i+1, ri-1-i)<<endl;\n\n    if (lhs == 0 || rhs == 0) {\n      res = 0;\n    } else {\n      if (s[i] == '*') {\n        res = lhs * rhs;\n      } else {\n        res = lhs / rhs;\n      }\n    }\n    \n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '+' || s[i] == '-') {\n    if (s[i] == '-' && i == 0) continue; \n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    if (ri + 1 < s.size() && s[ri] == '-') ri++;\n    \n    while (is_digit(s[li]) || s[li] == '-' && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    //cout<<\"dbg::\"<<li<<\"|\"<<ri<<endl;\n    //cout<<s.substr(li+1, i-1-li)<<\"|\"<<s.substr(i+1, ri-1-i)<<endl;\n    if (s[i] == '+') {\n      res = lhs + rhs;\n    } else {\n      res = lhs - rhs;\n    }\n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    //cout<<s<<endl;\n    return parse(0, s);\n  }\n  \n  return s;\n}\n\nvoid solve() {\n  string s; cin>>s;\n  s = s.substr(0, s.size()-1);\n  cout<<parse(0, s)<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  int n; cin>>n;\n  rep(i,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n\nusing namespace std;\n\nint calc(string s){\n\t// ©gªÊÉÍÜêÄ¢éêÆAÅ éÆ«Ì\n\tif(s[0]>='0'&&s[0]<='9'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(!(s[i]>='0'&&s[i]<='9')){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f){\n\t\t\treturn atoi(s.c_str());\n\t\t}\n\t}\n\telse if(s[0]=='('){\n\t\tstack<char> sc;\n\t\tsc.push('(');\n\t\tfor(int i = 1; i < s.size(); i++){\n\t\t\tif(s[i]==')')\n\t\t\t\tsc.pop();\n\t\t\telse if(s[i]=='('){\n\t\t\t\tsc.push('(');\n\t\t\t}\n\t\t\tif(sc.size()==0){\n\t\t\t\tif(i==s.size()-1){\n\t\t\t\t\treturn calc(s.substr(1,s.size()-2));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstack<char> sc;\n\t// \\¶ðÍÆÓ¡ðÍ\n\tfor(int i = 0; i < s.size(); i++){\n\t\t// ÊÌÌZqÍ³·é\n\t\tif(s[i]=='(')\n\t\t\tsc.push('(');\n\t\telse if(s[i]==')'){\n\t\t\tsc.pop();\n\t\t}\n\t\telse if(s[i]=='+'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) + calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='-'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) - calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < s.size(); i++){\n\t\t// ÊÌÌZqÍ³·é\n\t\tif(s[i]=='(')\n\t\t\tsc.push('(');\n\t\telse if(s[i]==')'){\n\t\t\tsc.pop();\n\t\t}\n\t\telse if(s[i]=='*'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) * calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='/'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) / calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tstring str;\n\t\tcin>>str;\n\t\tcout<<calc(str.substr(0,str.size()-1))<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tint ret = expression(begin);\n\t\tconsume(begin,')');\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing State = string::const_iterator;\n\nusing ll = long long int;\n\nint expr(State &begin);\nint term(State &begin);\nint num(State &begin);\nint factor(State &begin);\n\nvoid consume(State &begin, char expected){\n    if(*begin == expected){\n        begin++;\n    }else{\n        cerr << \"Expected \" << expected << \" but \" << *begin << endl;\n        throw \"\";\n    }\n}\n\nint expr(State &begin){\n    int res = term(begin);\n    while(1){\n        if(*begin == '+'){\n            begin++;\n            res += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            res -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint term(State &begin){\n    int res = factor(begin);\n    while(1){\n        if(*begin == '*'){\n            begin++;\n            res *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            res /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint num(State &begin){\n    int res = 0;\n    while(isdigit(*begin)){\n        res = res*10 + *begin-'0';\n        begin++;\n    }\n    return res;\n}\n\nint factor(State &begin){\n    int res = 0;\n    if(*begin == '('){\n        begin++;\n        res = expr(begin);\n        consume(begin,')');  // ')'\n    }else{\n        res = num(begin);\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        string s;\n        cin >> s;\n        State begin = s.begin();\n        int ans = expr(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define INF 1000000\n\n\nint ar[2][14];\nint main(){\n\tstring str;\n\tint N;\n\tcin>>N;\n\tVI res;\n\tstack <string>st;\n\tREP(ii,N){\n\t\tcin>>str;\n\t\tpriority_queue<pair<int,char> > buf;\n\t\tpriority_queue<pair<int,char> > buf2;\n\t\t\n\t\tbool ch=false;\n\t\tint t=0;\n\t\tvector<string> temp;\n\t\tREP(i,SZ(str)){\n\t\t\tif(str[i]=='+'||str[i]=='-'){\n\t\t\t\tif((!ch&&(buf.empty()||(buf.top()).first<i))||(ch&&(buf2.empty()||(buf2.top()).first<i))){\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\ttemp.PB(toString((buf.top()).second));\n\t\t\t\t\t\tbuf.pop();\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp.PB(toString((buf2.top()).second));\n\t\t\t\t\t\tbuf2.pop();\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(str[i]=='*'||str[i]=='/'){\n\t\t\t\tif(!ch){\n\t\t\t\t\tbuf.push(MP(100+i,str[i]));\n\t\t\t\t}else{\n\t\t\t\t\tbuf2.push(MP(100+i,str[i]));\n\t\t\t\t}\n\t\t\t}else if(str[i]=='('){\n\t\t\t\tch=true;\n\t\t\t}else if(str[i]==')'){\n\t\t\t\twhile(!buf2.empty()){\n\t\t\t\t\ttemp.PB(toString((buf2.top()).second));\n\t\t\t\t\tbuf2.pop();\n\t\t\t\t}\n\t\t\t\tch=false;\n\t\t\t}else if(str[i]=='='){\n\t\t\t\twhile(!buf.empty()){\n\t\t\t\t\ttemp.PB(toString((buf.top()).second));\n\t\t\t\t\tbuf.pop();\n\t\t\t\t}\n\t\t\t}else if(str[i]>='0'&&str[i]<='9'){\n\t\t\t\tif(i+1<SZ(str)&&str[i+1]>='0'&&str[i+1]<='9'){\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\tt*=10;\n\t\t\t\t}else{\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\t//cout<<t<<endl;\n\t\t\t\t\ttemp.PB(toString(t));\n\t\t\t\t\tt=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//REP(i,SZ(temp))cout<<temp[i];\n\t\t//cout<<endl;\n\t\tstack <int> st;\n\t\tREP(i,SZ(temp)){\n\t\t\tif(temp[i]==\"+\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1+t2);\n\t\t\t}else if(temp[i]==\"-\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2-t1);\n\t\t\t}else if(temp[i]==\"*\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1*t2);\n\t\t\t}else if(temp[i]==\"/\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tif(t1!=0)st.push(t2/t1);\n\t\t\t\telse st.push(0);\n\t\t\t}else{\n\t\t\t\tst.push(toInt(temp[i]));\n\t\t\t}\n\t\t}\n\t\tcout<<st.top()<<endl;\n\t\tst.pop();\n\t\t\n\t}\n\treturn 0;\n}\n\n/*\n4\n5+4*3+2/6=\n(1+4)*(3+7)/5=\n5+4-3=\n(1+5)*(2+3)=\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint parse();\nint expression();\n\nint digit(){\n  assert(isdigit(S[cur]));\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\n\nint number(){\n  int n = digit();\n  while(cur < S.size() && isdigit(S[cur])){\n    n = n * 10 + digit();\n  }\n  return n;\n}\n\nint factor(){\n  if(S[cur] != '(') return number();\n  cur++;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur++;\n  return n;\n}\n\nint term(){\n  int a = factor();\n  while(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n    char op = S[cur++];\n    int b = factor();\n    if(op == '*') a *= b;\n    else {\n      assert(b != 0);\n      a /= b;\n    };\n  }\n  return a;\n}\n\n\nint expression(){\n  int sum = term();\n  while(S[cur] == '+' || S[cur] == '-'){\n    char op = S[cur];\n    cur++;\n    int b = term();\n    if (op == '+') sum += b;\n    else sum -= b;\n  }\n  return sum;\n}\nint parse() { return expression(); }\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> S;\n    S.resize(S.size()-1);\n    cur = 0;\n    cout << expression() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n\nusing namespace std;\n\nstring calc;\nint cur;\nint digit();\nint number();\nint expression();\nint term();\nint factor();\n\nint main(){\n  int num,i;\n  cin >> num;\n  for (i = 0; i < num; ++i){\n    cin >> calc;\n    calc.resize(calc.size()-1);\n    cur = 0;\n\n    cout << calc << endl;\n    cout << expression() << endl;\n  }\n}\n\nint digit(){\n  assert(isdigit(calc[cur]));\n  int n = calc[cur] - '0';\n  cur++;\n  return n;\n}\n\nint number(){\n  int n = digit();\n  while(cur<calc.size() && isdigit(calc[cur])){\n    n = n*10 + digit();\n  }\n  return n;\n}\n\nint expression(){\n  int sum = term(); \n  while((cur < calc.size())&&(calc[cur]=='+'||calc[cur]=='-')){\n    char op = calc[cur];\n    cur++; // will look at the next num after op\n    int b = term();\n    if(op == '+'){\n      sum += b;\n    }else{\n      sum -= b;\n    }\n  }\n  return sum;\n}\n\nint term(){\n  int a = factor();\n  while((cur < calc.size())&&(calc[cur]=='*'||calc[cur]=='/')){\n    char op = calc[cur];\n    cur++; // will look at the next num after op\n    int b = factor();\n    if(op == '*'){\n      a *= b;\n    }else{\n      a /= b;\n    }\n  }\n  return a;\n}\n\nint factor(){\n  if(calc[cur] != '('){\n    return number();\n  }else{\n    cur++;\n    int n = expression();\n    assert(calc[cur] == ')');\n    cur++;\n    return n;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(string& s,State &i);\nDef term(string& s,State &i);\nDef factor(string& s,State &i);\nDef number(string& s,State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(string& s,State &i){\n\tDef out=term(s,i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(s,i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(string& s,State &i){\n\tDef out=factor(s,i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(s,i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(string& s,State &i){\n\tif(isdigit(*i))return number(s,i);\n\t//'('\n\ti++;\n\tDef out=expr(s,i);\n\ti++;\n\treturn out;\n}\nDef number(string& s,State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s,s.begin())<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring get_term(string, int&);\nint get_num(string);\nint get_exp(string);\n\nint get_num(string str) {\n    int num = 0;\n\n    if (str.size() == 0) return 0;\n\n    int i = 0;\n    if (str[i] == '(') {\n        i++;\n        string exp;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n            if (count) exp += str[i];\n        }\n\n        num = get_exp(exp + \"=\");\n    } else {\n        for (; i < str.size() && '0' <= str[i] && str[i] <= '9'; i++) {\n            num = num * 10 + (str[i] - '0');\n        }\n    }\n\n    for (; i < str.size(); i++) {\n        if (str[i] == '*') {\n            i++;\n            int tmp = 0;\n            for (; i < str.size() && '0' <= str[i] && str[i] <= '9'; i++) {\n                tmp = tmp * 10 + (str[i] - '0');\n            }\n            num *= tmp;\n            i--;\n        } else {\n            i++;\n            int tmp = 0;\n            for (; i < str.size() && '0' <= str[i] && str[i] <= '9'; i++) {\n                tmp = tmp * 10 + (str[i] - '0');\n            }\n            num /= tmp;\n            i--;\n        }\n    }\n\n    return num;\n}\n\n\nvoid solve(string str) {\n    cout << get_exp(str) << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    while (N--) {\n        string str;\n        cin >> str;\n        solve(str);\n    }\n\n    return 0;\n}\n\nstring get_term(string str, int& i) {\n    string init_str;\n    for (int count = 0; i < str.size(); i++) {\n        if (str[i] == '(') count++;\n        if (count > 0 || ('0' <= str[i] && str[i] <= '9') || str[i] == '/' || str[i] == '*') {\n            init_str += str[i];\n        }\n        if (str[i] == ')') count--;\n\n        if (count == 0 && (str[i] == '+'|| str[i] == '-' || str[i] == '=')) {\n            break;\n        }\n    }\n\n    return init_str;\n}\n\nint get_exp(string str) {\n    int num  = 0;\n    int i = 0;\n\n    string init_str = get_term(str, i);\n    num = get_num(init_str);\n\n    while (str[i] != '=') {\n        if (str[i] == '-') {\n            i++;\n            string term = get_term(str, i);\n            num -= get_num(term);\n        } else if (str[i] == '+') {\n            i++;\n            string term = get_term(str, i);\n            num += get_num(term);\n        }\n    }\n\n    return num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Factor();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <ctime>\nusing namespace std;\n\nint number(const string &s, int &k);\nint expression(const string &s, int &k);\nint term(const string &s, int &k);\nint factor(const string &s, int &k);\n\n// 式の評価.\nint eval(const string &s){\n    int k=0;\n    int res = expression(s, k);\n    /*if( k != s.size() ){\n        // 構文規則が正しくない!!!!\n    }*/\n    return res;\n}\n\nbool is_digit(char c){\n\treturn '0' <= c && c <= '9';\n}\n\n// <number> ::= <number> <digit> | <digit>\nint number(const string &s, int &k){\n    int res = 0;\n    while( is_digit(s[k]) ){\n        res = res * 10 + (s[k] - '0');\n        ++k;\n    }\n    return res;\n}\n\n// <expression(式)> := <expression(式)> + <term(項)> | <term(項)> \nint expression(const string &s, int &k){\n    int r1 = term(s, k);\n     \n    while( k < s.size() ){\n        if( s[k] == '+' ){\n            ++k;\n            int r2 = term(s, k);\n            r1 = r1 + r2;\n        }else if( s[k] == '-' ){\n            ++k;\n            int r2 = term(s, k);\n            r1 = r1 - r2;\n        }else{\n            break;\n        }\n    }\n    return r1;\n}\n\n// <term(項)> := <term(項)> * <factor(因子)> | <factor(因子)>\nint term(const string &s, int &k){\n    int r1 = factor(s, k);\n     \n    while( k < s.size() ){\n        if( s[k] == '*' ){\n            ++k;\n            int r2 = factor(s, k);\n            r1 = r1 * r2;\n        }else if( s[k] == '/' ){\n            ++k;\n            int r2 = factor(s, k);\n            // 0 除算のエラー\n            if( r2 == 0 ){\n            \treturn -1;\n            }\n            r1 = r1 / r2;\n        }else{\n            break;\n        }\n    }\n    return r1;\n}\n\n// <factor(因子)> := (<expression(式)>) | <Number>\nint factor(const string &s, int &k){\n    if( s[k] == '(' ){ // 括弧のはじまりのとき\n        ++k; // '(' の 1つ先に進める.\n        int r = expression(s, k);\n        // ')' がないとき\n        if( s[k] != ')' ) return -1;\n         \n        ++k; // ')' の 1つ先に進める.\n        return r;\n    }else if( is_digit(s[k]) ){ // 数字のとき\n        return number(s, k);\n    }else{ // 構文エラー\n        return -1;\n    }\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tstring s;\n\t\tcin >> s;\n\t\tcout << eval(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\nint pos;\nstring str;\n\nint exp();\n\nint factor() {\n  if(str[pos] >= '0' && str[pos] <= '9') {\n    string tmp = \"\";\n    while(str[pos] >= '0' && str[pos] <= '9') {\n      tmp += str[pos++];\n    }\n    return atoi(tmp.c_str());\n  }\n\n  if(str[pos] == '(') {\n    pos++;\n    return exp();\n  } else if(str[pos] == ')') {\n    pos++;\n    return 0;\n  }\n}\n\nint term() {\n  int x = factor();\n  while(str[pos] == '*' || str[pos] == '/') {\n    if(str[pos] == '*') {\n      pos++;\n      x *= factor();\n    } else if(str[pos] == '/') {\n      pos++;\n      x /= factor();\n    }\n  }\n  return x;\n}\n\nint exp() {\n  int x = term();\n  while(str[pos] == '+' || str[pos] == '-') {\n    if(str[pos] == '+') {\n      pos++;\n      x += term();\n    } else if(str[pos] == '-') {\n      pos++;\n      x -= term();\n    }\n  }\n  return x;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    pos = 0;\n    cin >> str;\n    str = str.substr(0, str.length()-1);\n    cout << exp() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n  for(int i = 0; i < N; i++){\n    string Expression;\n    getline(cin, Expression);\n\n    State begin = Expression.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint number(State &begin){\n  int ret = 0;\n\n  while(isdigit(*begin)){\n    ret = ret * 10;\n    ret = ret + *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n\nint term(State &begin){\n  int ret = factor(begin);\n\n  while(true){\n    if(*begin == '*'){\n      begin++;\n      ret = ret * factor(begin);\n    }else if(*begin == '/'){\n      begin++;\n      ret = ret / factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  while(true){\n    if(*begin == '+'){\n      begin++;\n      ret = ret + term(begin);\n    }else if(*begin == '-'){\n      begin++;\n      ret = ret - term(begin);\n    }else{\n      break;\n    }\n  }\n\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <stack>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint cal(){\n  stack<int> st;\n  int ope=0;\n  int num;\n  while(true){\n    char c = getchar();\n    if(c == ')' ) break;\n    if(c == '=' ){\n      getchar();\n      break;\n    }\n    if(c == '(' || ('0'<=c && c<= '9') ) {\n      if(c == '(') num = cal();\n      else num = (c - '0');\n      if(ope==0){\n        st.push(num);\n      }else if(ope == 1){\n        st.push(-num);\n        ope = 0;\n      }else if(ope == 2){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp * num);\n        ope = 0;\n      }else if(ope == 3){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp / num);\n        ope = 0;\n      }\n    }\n    if(c == '+') ope = 0;\n    if(c == '-') ope = 1;\n    if(c == '*') ope = 2;\n    if(c == '/') ope = 3;\n  }\n  int sum=0;\n  while(!st.empty()){\n    sum += st.top();\n    st.pop();\n  }\n  return sum;\n}\n\nint main(void){  \n  int n;\n  cin >> n;\n  getchar();\n  REP(i,n)\n    cout << cal() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cctype>\nusing namespace std;\nstring S;\nint cur;\nint expression();\nint digit(){\n    assert(isdigit(S[cur]));\n    int n=S[cur]-'0';\n    cur=cur+1;\n    return n;\n}\nint number(){\n    int n=digit();\n    while(cur<S.size()&&isdigit(S[cur])){\n        n=n*10+digit();\n    }\n    return n;\n}\nint factor(){\n    if(S[cur]!='(') return number();\n    cur+=1;\n    int n=expression();\n    assert(S[cur]==')');\n    cur+=1;\n    return n;\n}\nint term(){\n    int a=factor();\n    while(cur<S.size()&&(S[cur]=='*'||S[cur]=='/')){\n        char op=S[cur++];\n        int b=factor();\n        if(op=='*'){\n            a*=b;\n        }\n        else a/=b;\n    }\n    return a;\n}\nint expression() {\n    int sum=term();\n    while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n        char op=S[cur++];\n        int b=term();\n        if(op=='+'){\n            sum+=b;\n        }\n        else sum-=b;\n    }\n    return sum;\n}\nint main(){\n    int N;\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cur=0;\n        cin>>S;\n        cout<<expression()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n  \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n  \n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\ntypedef long double Real;\n#define EPS 1e-13\n#define EQ(x) (-EPS<x && x<EPS)\ntypedef complex<Real> P;\nReal dot(P a,P b){return real(conj(a)*b);}\nReal cross(P a,P b){return imag(conj(a)*b);}\n\n#define MP make_pair<int,int>\n\nstring s;\nint iter;\n\nll dfs();\n\nll dfs2(ll val,int op){\n  ll tmp = 0;\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      if(op) val *= dfs();\n      else val /= dfs();\n    }else if(s[iter]==')' || s[iter]=='=' || s[iter]=='+' || s[iter]=='-'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      --iter;\n      return val;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      op = s[iter]=='*'?1:0;\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nll dfs(){\n  ll val = 0;\n  ll tmp = 0;\n  int op = 1; // op==1?'+':'-'\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      tmp = dfs();\n    }else if(s[iter]==')' || s[iter]=='='){\n      val += op*tmp;\n      tmp = 0;\n      return val;\n    }else if(s[iter]=='+'){\n      val += op*tmp;\n      tmp = 0;\n      op = 1;\n    }else if(s[iter]=='-'){\n      val += op*tmp;\n      tmp = 0;\n      op = -1;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      ++iter;\n      val += op*dfs2(tmp,s[iter-1]=='*'?1:0);\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>s;\n    iter = 0;\n    cout<<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint calc(char *s, int &i, bool f = false){\n  int ret = 0;\n  bool flag = i >= 0 && s[i-1] == '(';\n  \n  for(;s[i];){\n    \n    if(s[i] == ')'){\n      if(flag) i++;\n      return ret;\n    }\n    \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\n      i++;\n      \n      if(s[i] == '('){\n        i++;\n\n        if(i-2 < 0) ret += calc(s,i);\n        else if(s[i-2] == '+') ret += calc(s,i,false);\n        else if(s[i-2] == '-') ret -= calc(s,i,false);\n        else if(s[i-2] == '*') ret *= calc(s,i,false);\n        else if(s[i-2] == '/') ret /= calc(s,i,false);\n\n        continue;\n      }\n      \n      if(s[i-1] == '+') ret += calc(s,i,true);\n      else if(s[i-1] == '-') ret -= calc(s,i,true);\n      \n    }else{\n      int start = i-1;\n      int sum = 0;\n      \n      while(!(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '\\0' || s[i] == ')')){\n        sum *= 10;\n        sum += s[i] - '0';\n        i++;\n      }\n      /*\n      debug(ret);\n      debug(sum);\n      debug(s[start]);\n      */\n      \n      if(start < 0){\n        ret += sum;\n      }else{\n        if(s[start] == '(') ret += sum;\n        if(s[start] == '+') ret += sum;\n        if(s[start] == '-') ret += sum;\n        if(s[start] == '*') ret *= sum;\n        if(s[start] == '/') ret /= sum;\n      }\n      \n      if(f && (s[i] == '+' || s[i] == '-')){\n        //debug(i);\n        //debug(s[i]);\n        return ret;\n      }\n      \n      //debug(ret);\n    }\n  }\n\n  //debug(s[i]);\n  //debug(ret);\n  \n  return ret;\n}\n\n\nint main(){\n  char s[SIZE];\n  int t = 0;\n\n  int n;\n\n  scanf(\"%d\",&n);\n\n  while(n--){\n    char s2[SIZE] = {};\n    t = 0;\n    scanf(\"%s\",s);\n\n    s[strlen(s)-1] = '\\0';\n    strcat(s2,\"0+\");\n    strcat(s2,s);\n\n    string str = s2;\n    int r = 0;\n\n    while((r = (int)str.find(\"((\")) != -1){\n      str.replace(r, 2, \"(0+(\");\n    }\n\n    sprintf(s2,\"%s\",str.c_str());\n    \n    printf(\"%d\\n\",calc(s2,t));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\nint hoge(string a)\n{\n\tif(a==\"(\")return -1;\n\tif(a==\"*\"||a==\"/\")return 1;\n\treturn 0;\n}\n\nlong long calc(long long a,long long b,string str)\n{\n\tif(str==\"+\")return a+b;\n\tif(str==\"-\")return a-b;\n\tif(str==\"/\")return a/b;\n\tif(str==\"*\")return a*b;\n\t\n}\n\nint main()\n{\n\tint n;cin>>n;\n\twhile(n--)\n\t{\n\t\tstring str;cin>>str;\n\t\tstringstream ss;\n\t\tfor(int i=0;i<str.size()-1;i++)\n\t\t{\n\t\t\tif(str[i]=='+'||str[i]=='-'||str[i]=='/'||str[i]=='*'||str[i]=='('||str[i]==')')ss<<\" \"<<str[i]<<\" \";\n\t\t\telse ss<<str[i];\n\t\t}\n\t\t\n\t\tvector<string> v;\n\t\tstack<string> st;\n\t\twhile(getline(ss,str,' '))\n\t\t{\n\t\t\tif(str==\"\")continue;\n\t\t\tif(str==\"+\"||str==\"-\"||str==\"/\"||str==\"*\")\n\t\t\t{\n\t\t\t\twhile(!st.empty()&&hoge(st.top())>hoge(str))\n\t\t\t\t{\n\t\t\t\t\tv.push_back(st.top());\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.push(str);\n\t\t\t}\n\t\t\telse if(str==\")\")\n\t\t\t{\n\t\t\t\twhile(st.top()!=\"(\")\n\t\t\t\t{\n\t\t\t\t\tv.push_back(st.top());\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\telse if(str==\"(\")st.push(str);\n\t\t\telse v.push_back(str);\n\t\t}\n\t\twhile(!st.empty())\n\t\t{\n\t\t\t\n\t\t\tv.push_back(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tstack<long long> k;\n\t\tfor(int i=0;i<v.size();i++)\n\t\t{\n\t\t\t\n\t\t\tif(v[i]==\"+\"||v[i]==\"-\"||v[i]==\"/\"||v[i]==\"*\")\n\t\t\t{\n\t\t\t\tlong long A,B;\n\t\t\t\tB=k.top();k.pop();\n\t\t\t\tA=k.top();k.pop();\n\t\t\t\tk.push(calc(A,B,v[i]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk.push(atol(v[i].c_str()));\n\t\t\t}\n\t\t}\n\t\t\t\tcout<<k.top()<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nint expr(const string &s, int &pos);\nint term(const string &s, int &pos);\nint factor(const string &s, int &pos);\nint number(const string &s, int &pos);\n\nint expr(const string &s, int &pos) {\n  auto res = term(s, pos);\n  while ((pos < s.size()) and (s[pos] == '+' or s[pos] == '-')) {\n    auto op = s[pos++];\n    if (op == '+') {\n      res += term(s, pos);\n    } else {\n      res -= term(s, pos);\n    }\n  }\n  return res;\n}\n\nint term(const string &s, int &pos) {\n  auto res = factor(s, pos);\n  while ((pos < s.size()) and (s[pos] == '*' or s[pos] == '/')) {\n    auto op = s[pos++];\n    if (op == '*') {\n      res *= factor(s, pos);\n    } else {\n      res /= factor(s, pos);\n    }\n  }\n  return res;\n}\n\nbool is_digit(char ch) {\n  return '0' <= ch and ch <= '9';\n}\n\nint factor(const string &s, int &pos) {\n  if (is_digit(s[pos])) {\n    return number(s, pos);\n  }\n  assert(s[pos++] == '(');\n  auto res = expr(s, pos);\n  assert(s[pos++] == ')');\n  return res;\n}\n\nint number(const string &s, int &pos) {\n  int ret = 0;\n  while (pos < s.size() and is_digit(s[pos])) {\n    ret = ret * 10 + (s[pos++] - '0');\n  }\n  return ret;\n}\n\nint main() {\n\n  int n;\n  cin >> n;\n  cin.ignore();\n  \n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    // <expr> ::= <term> [('+'|'-') <term>]*\n    // <term> ::= <factor> [('*'|'/') <factor>]*\n    // <factor> ::= <number> | '(' <expr> ')'\n    // <number> ::= 123 とか\n    int pos = 0;\n    auto res = expr(s, pos);\n    cout << res << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <cctype>\nusing namespace std;\ntypedef long long ll;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nvoid calc(string st, stack<ll> &s) {\t\n\tif(st == \"*\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(a * b);\n\t} else if(st == \"+\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(a + b);\n\t} else if(st == \"-\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(b - a);\n\t} else if(st == \"/\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(b / a);\n\t} else {\n\t\ts.push(atoi(st.c_str()));\n\t}\n}\nint getPriority(string s) {\n\tif(s == \"(\") {\n\t\treturn 5;\n\t} else if(s == \"*\" || s == \"/\") {\n\t\treturn 3;\n\t} else if(s == \"+\" || s == \"-\") {\n\t\treturn 2;\n\t} else if(s == \")\") { \n\t\treturn 1;\n\t} else return 4;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(--str.end());\n\t\t\n\t\tvector<string> v;\n\t\t\n\t\tint f = 0;\n\t\trep(i, str.size()) {\t\t\t\n\t\t\tif(isdigit(str[i])) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif(f) {\n\t\t\t\t\tstring st;\n\t\t\t\t\trep(j,f) {\n\t\t\t\t\t\tst += str[i - f + j];\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(st);\n\t\t\t\t\tstring st2;\n\t\t\t\t\tst2 += str[i];\n\t\t\t\t\tv.push_back(st2);\n\t\t\t\t\tf = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstring st3;\n\t\t\t\t\tst3 += str[i];\n\t\t\t\t\tv.push_back(st3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<string> s;\n\t\tvector<string> nv;\n\t\tstack<ll> ret;\n\t\tint p = 0;\n\t\trep(i,v.size()) {\n\t\t\tp = getPriority(v[i]);\n\t\t\twhile(!s.empty() && getPriority(s.top()) > p && s.top() != \"(\") {\n\t\t\t\tnv.push_back(s.top());\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(v[i] == \")\") {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(v[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()) {\n\t\t\tnv.push_back(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\trep(i,nv.size()) {\n\t\t\tcalc(nv[i], ret);\n\t\t}\n\t\tcout << ret.top() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint k,n,ans;\nstring s;\n\nint calc1();\nint calc2();\nint calc3();\n\nint calc1(){\n\tint a;\n\ta=calc2();\n\twhile(s[k]=='+' ||s[k]=='-'){\n\t\tif(s[k]=='+'){\n\t\t\tk++;\n\t\t\ta+=calc2();\n\t\t}else if(s[k]=='-'){\n\t\t\tk++;\n\t\t\ta-=calc2();\n\t\t}\n\t}\n\treturn a;\n}\n\nint calc2(){\n\tint a;\n\ta=calc3();\n\twhile(s[k]=='*' ||s[k]=='/'){\n\t\tif(s[k]=='*'){\n\t\t\tk++;\n\t\t\ta*=calc3();\n\t\t}else if(s[k]=='/'){\n\t\t\tk++;\n\t\t\ta/=calc3();\n\t\t}\n\t}\n\treturn a;\n}\n\nint calc3(){\n\tint a;\n\tif(s[k]=='('){\n\t\tk++;\n\t\ta=calc1();\n\t\tk++;\n\t}else{\n\t\ta=0;\n\t\twhile(s[k]>='0' && s[k]<='9'){\n\t\t\ta*=10;\n\t\t\ta+=s[k]-'0';\n\t\t\tk++;\n\t\t}\n\t}\n\treturn a;\n}\n\nint main(){\n\tcin >> n;\n\twhile(n--){\n\t\tans=0;\n\t\tint k=0;\n\t\tcin >> s;\n\t\tans=calc1();\n\t\tcout << ans <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit(){\n  assert(isdigit(S[cur]));\n  int n = S[cur] - '0';\n  cur += 1;\n  return n;\n}\n\nint number(){\n  int n = digit();\n  while(cur<S.size()&&isdigit(S[cur])){\n    n = n*10 + digit();\n  }\n  return n;\n}\n\nint factor();\n\nint term(){\n  int a = factor();\n  while(cur<S.size()&&(S[cur] == '*' || S[cur] == '/')){\n    char op = S[cur];\n    cur += 1;\n    int b = factor();\n    if(op == '*') a *= b;\n    else a /= b;\n  }\n  return a;\n}\n\nint expression(){\n  int a = term();\n  while(cur<S.size()&&(S[cur] == '+' || S[cur] == '-')){\n    char op = S[cur];\n    cur += 1;\n    int b = term();\n    if(op == '+') a += b;\n    else a -= b;\n  }\n  return a;\n}\n\nint factor(){\n  if(S[cur]!='(') return number();\n  cur += 1;\n  int n = expression();\n  assert(S[cur]==')');\n  cur += 1;\n  return n;\n}\n\nint parse(){\n  cur = 0;\n  return expression();\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i=0;i<n;++i){\n    cin >> S;\n    S.pop_back();\n\n    int a = parse();\n\n    cout << a << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n#include <cctype>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5+10;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\ntypedef string::const_iterator SC;\n\nint factor(SC&);\n\n// ??°????????????\nint number(SC& begin){\n  int res = 0;\n\n  while(isdigit(*begin)){\n    res *= 10;\n    res += *begin - '0';\n    begin++;\n  }\n\n  return res;\n}\n\n// ??????\nint term(SC& begin){\n  int res = factor(begin);\n\n  while(1){\n    if(*begin == '*'){\n      begin++;\n      res *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      res /= factor(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return res;\n}\n\n// ????????????\nint expression(SC& begin){\n  int res = term(begin);\n\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      res += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      res -= term(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return res;\n}\n\n// ??¬??§?????°????????????\nint factor(SC& begin){\n  if (*begin == '('){\n    begin++;\n    int res = expression(begin);\n    begin++;\n  }\n  else{\n    return number(begin);\n  }\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tREP(i,n){\n\t\tcin >> s;\n\t\tSC begin = s.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint term(State &begin);\n\nint factor(State &begin);\n\nint number(State &begin);\n\nvoid consume(State &begin,char expected);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    string s;\n    cin>>s;\n    State begin = s.begin();\n    int ans=expression(begin);\n    consume(begin,'=');\n    cout<<ans<<endl;\n  }\n\n}\n\n\nint number(State &begin){\n  int ret = 0;\n\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  if(*begin =='('){\n    consume(begin,'(');\n    int ret = expression(begin);\n    consume(begin,')');\n    return ret;\n  }\n  else{\n    return number(begin);\n  }\n}\n\n\nint term(State &begin){\n  int ret = number(begin);\n\n  for(;;){\n    if(*begin =='*'){\n      consume(begin,'*');\n      ret *= factor(begin);\n    }\n    else if(*begin =='/'){\n      consume(begin,'/');\n      ret /= factor(begin);\n    }\n    else break;\n  }\n\n  return ret;\n}\n\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  for(;;){\n    if(*begin =='+'){\n      consume(begin,'+');\n      ret += term(begin);\n    }\n    else if(*begin =='-'){\n      consume(begin,'-');\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\n\nvoid consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n      << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<cctype>\n#include<math.h>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur = cur + 1;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur]))\n\t\tn = n * 10 + digit();\n}\n\nint term(){\n\tint a = number();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint a = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif (op == '+') a += b; else a -= b;\n\t}\n\treturn a;\n}\n\nint expression();\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\", N);\n\tfor (int i = 0; i < N; i++){\n\t\tcur = 0;\n\t\tscanf(\"%s\", S);\n\t\tS.resize(S.size() - 1);\n\t\tcout << factor() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef string::const_iterator State;\nint Factor(State& begin);\n\nint numParse(State& begin){\n    int tmp=0;\n    bool f=false;\n    if(*begin=='-')f=true;\n    while(isdigit(*begin)){\n        tmp*=10;\n        tmp+=*begin-'0';\n        begin++;\n    }\n    if(*begin=='=')begin++;\n    return f ? -tmp:tmp;\n}\nint MulDiv(State& begin){\n    int tmp=Factor(begin);\n    while(1){\n        if(*begin=='*'){\n            begin++;\n            tmp *= Factor(begin);\n        }else if(*begin=='/'){\n            begin++;\n            tmp /= Factor(begin);\n        }else{\n            break;\n        }\n    }\n    return tmp;\n}\n\nint AddSub(State& begin){\n    int tmp=MulDiv(begin);\n    while(1){\n        if(*begin=='+'){\n            begin++;\n            tmp+=MulDiv(begin);\n        }else if(*begin=='-'){\n            begin++;\n            tmp-=MulDiv(begin);\n        }else {\n            break;\n        }\n    }\n    return tmp;\n}\n\nint Factor(State& begin){\n    if(*begin=='('){\n        begin++;\n        int tmp=AddSub(begin);\n        begin++;\n        if(*begin=='=')begin++;\n        return tmp;\n    }else{\n        return numParse(begin);\n    }\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        string s2;\n        cin>>s2;\n        string s1=\"0\";\n        if(s2[0]!='-')s1+=\"+\";\n        string s=s1+s2;\n        State begin=s.begin();\n        int ans=AddSub(begin);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring S;\nsize_t cur=0;\n\nint digit() {\n  assert(isdigit(S[cur]));\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\n\nint number() {\n  int n = digit();\n  while(cur < S.size() && isdigit(S[cur])) {\n    n = n*10 + digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor() {\n  if (S[cur] != '(') return number();\n  cur++;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur++;\n  return n;\n}\n\nint term() {\n  int a = factor();\n  while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    int b = factor();\n    if (op == '*') a *= b;\n    else a /= b;\n  }\n  return a;\n}\n\nint expression() {\n  int a = term();\n  while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++];\n    int b = term();\n    if (op == '+') a += b;\n    else a -= b;\n  }\n  return a;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    cur = 0;\n    cin >> S;\n    S.resize(S.size() - 1); // '='?????????\n    cout << expression() << endl;\n  }\n}\n\n// accepted!\n#if 0\n???????????????pdf?????????????????????????????§?????¨?????§45?????????\n?????°??????????????¨??§?????????????????????????°?????????????????????¨???????????§?????????\n#endif"
  },
  {
    "language": "C++",
    "code": "import re\nclass c:\n\tdef __str__(self):\n\t\treturn str(self.x)\n\tdef __init__(self,value):\n\t\tself.x=value\n\tdef __add__(self,value):\n\t\treturn c(self.x+value.x)\n\tdef __sub__(self,value):\n\t\treturn c(self.x-value.x)\n\tdef __mul__(self,value):\n\t\treturn c(self.x*value.x)\n\tdef __truediv__(self,value):\n\t\treturn c(int(self.x/value.x))\nn=int(input())\nfor i in range(n):\n\ts=input()[:-1]\n\ts=re.sub(r'(\\d+)',r'c(\\1)',s)\n\tprint(eval(s))"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (int i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        s[0] = '\\0';\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring s;\n\nint stoi(string str) {\n\tint len = (int)str.size();\n\tif (len==0) return 0;\n\treturn (str[len - 1] - '0') + 10 * ( stoi(str.substr(0, len - 1)) );\n}\n\nint parse(int l, int r) {\n\tint k = 0;\n\t\n\t// +, -\n\tfor (int i=r-1; i>=l; i--) {\n\t\tif (s[i]=='(') k++;\n\t\tif (s[i]==')') k--;\n\t\tif (k==0 && s[i]=='+') return parse(l, i) + parse(i+1, r);\n\t\tif (k==0 && s[i]=='-') return parse(l, i) - parse(i+1, r);\n\t}\n\t\n\t// *,/\n\tfor (int i=r-1; i>=l; i--) {\n\t\tif (s[i]=='(') k++;\n\t\tif (s[i]==')') k--;\n\t\tif (k==0 && s[i]=='*') return parse(l, i) * parse(i+1, r);\n\t\tif (k==0 && s[i]=='/') return parse(l, i) / parse(i+1, r);\n\t}\n\t\n\tif (s[l] == '(' && s[r-1] == ')') return parse(l+1, r-1);\n\t\n\treturn stoi(s.substr(l, r-l));\n}\n\nint main() {\n\tint n; cin >> n;\n\t\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> s;\n\t\tcout << parse(0, (int)s.size()-1) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cctype>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint exp(char* & p);\n\nint num(char* & p) {\n    int ret = 0;\n    while (isdigit(*p)) {\n        ret *= 10;\n        ret += *p - '0';\n        p++;\n    }\n    return ret;\n}\n\nint fac(char* & p) {\n    int ret = 0;\n    if (*p == '(') {\n        p++;\n        ret += exp(p);\n        p++;\n    } else {\n        ret += num(p);\n    }\n    return ret;\n}\n\nint term(char* & p) {\n    int ret = fac(p);\n    while(1) {\n        if (*p == '*') {\n            p++;\n            ret *= fac(p);\n        } else if (*p == '/') {\n            p++;\n            ret /= fac(p);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint exp(char* & p) {\n    int ret = term(p);\n    while(1) {\n        if (*p == '+') {\n            p++;\n            ret += term(p);\n        } else if (*p == '-') {\n            p++;\n            ret -= term(p);\n        } else break;\n    }\n    return ret;\n}\n\nint eval(const string & s){\n    char* p = (char*)s.c_str();\n    return exp(p);\n}\n\nint eval(const char* str){\n    char* p = (char*)str;\n    return exp(p);\n}\n\nusing namespace std;\n\nint main(){\n  int n; cin >> n;\n  cin.ignore();\n  while(n--){\n    char str[128];\n    gets(str);\n    cout << eval(str) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\nint hoge(string a)\n{\n\tif(a==\"(\")return -1;\n\tif(a==\"*\"||a==\"/\")return 1;\n\treturn 0;\n}\n\nlong long calc(long long a,long long b,string str)\n{\n\tif(str==\"+\")return a+b;\n\tif(str==\"-\")return a-b;\n\tif(str==\"/\")return a/b;\n\tif(str==\"*\")return a*b;\n\t\n}\n\nint main()\n{\n\tint n;cin>>n;\n\twhile(n--)\n\t{\n\t\tstring str;cin>>str;\n\t\tstringstream ss;\n\t\tfor(int i=0;i<str.size()-1;i++)\n\t\t{\n\t\t\tif(str[i]=='+'||str[i]=='-'||str[i]=='/'||str[i]=='*'||str[i]=='('||str[i]==')')ss<<\" \"<<str[i]<<\" \";\n\t\t\telse ss<<str[i];\n\t\t}\n\t\t\n\t\tvector<string> v;\n\t\tstack<string> st;\n\t\twhile(getline(ss,str,' '))\n\t\t{\n\t\t\tif(str==\"\")continue;\n\t\t\tif(str==\"+\"||str==\"-\"||str==\"/\"||str==\"*\")\n\t\t\t{\n\t\t\t\twhile(!st.empty()&&hoge(st.top())>hoge(str))\n\t\t\t\t{\n\t\t\t\t\tv.push_back(st.top());\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.push(str);\n\t\t\t}\n\t\t\telse if(str==\")\")\n\t\t\t{\n\t\t\t\twhile(st.top()!=\"(\")\n\t\t\t\t{\n\t\t\t\t\tv.push_back(st.top());\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\telse if(str==\"(\")st.push(str);\n\t\t\telse v.push_back(str);\n\t\t}\n\t\twhile(!st.empty())\n\t\t{\n\t\t\t\n\t\t\tv.push_back(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\tstack<long long> k;\n\t\tfor(int i=0;i<v.size();i++)\n\t\t{\n\t\t\t\n\t\t\tif(v[i]==\"+\"||v[i]==\"-\"||v[i]==\"/\"||v[i]==\"*\")\n\t\t\t{\n\t\t\t\tlong long A,B;\n\t\t\t\tB=k.top();k.pop();\n\t\t\t\tA=k.top();k.pop();\n\t\t\t\tk.push(calc(A,B,v[i]));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk.push(atol(v[i].c_str()));\n\t\t\t}\n\t\t}\n\t\t\t\tcout<<k.top()<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tstd::string inputStr;\n\n\tint64_t calcAdd(int& s_i)\n\t{\n\t\tint64_t ret{calcMulti(s_i)};\n\t\twhile (inputStr[s_i] == '+' || inputStr[s_i] == '-')\n\t\t{\n\t\t\tchar ope{inputStr[s_i]};\n\t\t\ts_i++;\n\t\t\tif (ope == '+') ret += calcMulti(s_i);\n\t\t\telse ret -= calcMulti(s_i);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint64_t calcMulti(int& s_i)\n\t{\n\t\tint64_t ret{calcNum(s_i)};\n\t\twhile (inputStr[s_i] == '*' || inputStr[s_i] == '/')\n\t\t{\n\t\t\tchar ope{inputStr[s_i]};\n\t\t\ts_i++;\n\t\t\tif (ope == '*') ret *= calcNum(s_i);\n\t\t\telse ret /= calcNum(s_i);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint64_t calcNum(int& s_i)\n\t{\n\t\tint64_t ret{};\n\t\tif (inputStr[s_i] == '(')\n\t\t{\n\t\t\ts_i++;\n\t\t\tret = calcAdd(s_i);\n\t\t\ts_i++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (isdigit(inputStr[s_i]))\n\t\t\t{\n\t\t\t\tret = 10 * ret + inputStr[s_i] - '0';\n\t\t\t\ts_i++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tstd::cin >> inputStr;\n\t\tint s_i{};\n\t\tprintf(\"%lld\\n\", calcAdd(s_i));\n\t}\n};\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i{}; i < N; i++)\n\t\tSolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# -*- coding: utf-8 -*-\n\nnum = int(raw_input())\nfor i in range(num):\n\tinput_line = raw_input()\n\teval_line = input_line[0:-1]\n\tresult = eval(eval_line)\n\tprint result"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tif (j != 0){\n\t\t\t\t\t\tsize1 = res.substr(j + 1, i - j - 1).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = i;\n\t\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*'){\n\t\t\t\t\t\tnum1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\t}\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t}\n\n\t//cout << \"!!\" << res << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tif (i == 0)continue;\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = res.substr(j, i - j).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\t//cout << \"!!\" << i  << endl;\n\t\t//cout << res << endl;\n\t\tint pos1, pos2, size;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\t//cout << res.substr(pos1 + 1, pos2 - pos1 - 1) << endl;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tsize = buf.size();\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2 + 1, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = pos1 + size - 1;\n\t\t\t//cout << res << endl;\n\t\t\t//cout << \"!\" << i << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nbool digit(char c){\n  return (c-'0'>=0 && c-'0'<=9);\n}\n\nint stoi(string s){\n  int res,tmp;\n  res = 0;\n  tmp = 1;\n  for(int i=(int)s.size()-1;i>=0;i--){\n    res += (s[i]-'0') * tmp;\n    tmp *= 10;\n  }\n  return res;\n}\n\nint cal(string s){\n  vector<int> v,op;\n  int pos = 0;\n  while(pos<(int)s.size()){\n    if(s[pos] == '('){\n      int c = 1;\n      string tmp;\n      while(1){\n\tpos++;\n\tif(s[pos] == '(')c++;\n\tif(s[pos] == ')')c--;\n      if(!c)break;\n      tmp.push_back(s[pos]);\n      }\n      v.push_back(cal(tmp));\n      pos++;\n    }else if(digit(s[pos])){\n      string tmp;\n      while(digit(s[pos])){\n\ttmp.push_back(s[pos]);\n\tpos++;\n      }\n      v.push_back(stoi(tmp));\n    }else{\n      op.push_back(s[pos]);\n      pos++;\n    }\n  }\n    \n  for(int i=0;i<(int)op.size();i++){\n    if(op[i] == '*'){\n      int tmp = v[i]*v[i+1];\n      v.insert(v.begin()+i,tmp);\n      v.erase(v.begin()+i+1);\n      v.erase(v.begin()+i+1);\n      op.erase(op.begin()+i);\n      i = - 1;\n    }\n    if(op[i] == '/'){\n      int tmp = v[i]/v[i+1];\n      v.insert(v.begin()+i,tmp);\n      v.erase(v.begin()+i+1);\n      v.erase(v.begin()+i+1);\n      op.erase(op.begin()+i);\n      i = - 1;\n    }\n  }\n  for(int i=0;i<(int)op.size();i++){\n    if(op[i] == '+'){\n      int tmp = v[i]+v[i+1];\n      v.insert(v.begin()+i,tmp);\n      v.erase(v.begin()+i+1);\n      v.erase(v.begin()+i+1);\n      op.erase(op.begin()+i);\n      i = - 1;\n    }\n    if(op[i] == '-'){\n      int tmp = v[i]-v[i+1];\n      v.insert(v.begin()+i,tmp);\n      v.erase(v.begin()+i+1);\n      v.erase(v.begin()+i+1);\n      op.erase(op.begin()+i);\n      i = - 1;\n    }\n  }\n  return v[0]; \n}\n\nint main(){\n  string s;\n  int n;\n\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> s;\n    s.erase(s.end()-1);\n    cout << cal(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\ntypedef long long ll;\n\n\nint lp;\nint lpcnt = 0;\n\n\nstring str;\n\nbool input(){\n\n  if(lpcnt==0)cin>>lp;\n\n  if(lpcnt==lp)return false;\n  cin>>str;\n\n  lpcnt++;\n  return true;\n}\n\n\nclass S{\npublic:\n  bool isnum;\n  bool isc;\n  char c;\n  int num;\n  S(bool isnum, bool isc, char c, int num):isnum(isnum),isc(isc),c(c),num(num){}\n  S(){isnum=isc=false; c='#'; num=0;}\n  void print(){\n    printf(\"%d %d %d %c\\n\",isnum,isc,num,c);\n  }\n};\n\ntypedef pair<int,string> pis;\ntypedef pair<char,string> pcs;\n\nbool isnum(char c){\n  return '0'<=c && c<='9';\n}\n\nint ctonum(char c){\n  return c-'0';\n}\n\npis getHeadNum(string str){\n\n  pis ret = pis(0,\"\");\n  int st = 0;\n  while(str.size()!=st && isnum(str[st])){\n    ret.first *= 10;\n    ret.first += ctonum(str[st]);\n    st++;\n  }\n\n  ret.second = str.substr(st);\n  return ret;\n}\n\npcs getHeadChar(string str){\n  return pcs(str[0], str.substr(1));\n}\n\nbool iscalc(char c){\n  if(c=='*' || c=='+' || c=='-' || c=='/')return true;\n  return false;\n}\n\n\nvector<S> getEq(string str){\n  vector<S> eq;\n  string sc = str;\n  eq.clear();\n\n  while(sc.size()!=0){\n    int hu = 1;\n    S add;\n    if(sc[0]=='-' && ((eq.size()!=0 && iscalc(eq[eq.size()-1].c))||eq.size()==0)){\n      hu = -1;\n      sc = sc.substr(1);\n    }\n    if(isnum(sc[0])){\n      add.isnum = true;\n      pis res = getHeadNum(sc);\n      add.num = hu*res.first;\n      sc = res.second;\n    }else{\n      add.isc = true;\n      pcs res = getHeadChar(sc);\n      add.c = res.first;\n      sc = res.second;\n    }\n    eq.push_back(add);\n  }\n  return eq;\n}\n\nint calc(int st, int en, vector<S>& eq){\n  \n  /*\n  \n  for(int i=st;i<en;i++){\n    eq[i].print();\n  }puts(\"\");\n  */\n\n\n\n  if(st>=en){\n    printf(\"%d %d\\n\",st,en);\n    assert(0);\n  }\n\n  int num = eq[st].num;\n  if(st+1==en)return num;\n  int a=0;\n\n  reps(i,st,en){\n\n    if(eq[i].c=='(')a++;\n    if(eq[i].c==')')a--;\n\n\n    if(a==0){\n      if(eq[i].c=='-'){\n\treturn calc(st, i, eq) - calc(i+1, en, eq);\n      }\n      if(eq[i].c=='+'){\n\treturn calc(st, i, eq) + calc(i+1, en, eq);\n      }\n    }\n\n  }\n\n  a=0;\n\n  reps(i,st, en){\n\n    if(eq[i].c=='(')a++;\n    if(eq[i].c==')')a--;\n    if(a==0){\n      if(eq[i].c=='*'){\n\treturn calc(st, i, eq) * calc(i+1, en, eq);\n      }\n      if(eq[i].c=='/'){\n\treturn calc(st, i, eq) / calc(i+1, en, eq);\n      }\n    }\n\n  }\n\n  if(eq[st].c=='('){\n    return calc(st+1, en-1, eq);\n  }\n  puts(\"AAA\");\n  assert(0);\n  return -1;\n  \n}\nint solve(){\n  vector<S> eq = getEq(str);\n  return calc(0,eq.size()-1, eq);\n}\n\nint main(){\n  while(input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\n/*\n   <??????????????????> ::= <??????????????????> (+ or -) <??????????????????> (+ or -) ...\n   <??????????????????> ::= <??°> (* or /) <??°> (* or /) ...\n   <??°>           ::= ...\n   */\n\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint factor(State &begin)\n{ \n  if (*begin == '(')\n  {\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }\n  else\n  {\n    return number(begin);\n  }\n}\n\n\nint main(void) {\n  int N;\n  cin >> N;\n  cin.ignore();\n  for(int i = 0; i < N; i++)\n  {\n    string s;\n    getline(cin, s);\n    \n    State begin = s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\nint expression(State &begin)\n{\n  int ret = term(begin);\n  for(;;) {\n    if(*begin == '+') {\n        begin++;\n        ret += term(begin);\n    } else if (*begin == '-')\n       {\n          begin++;\n          ret -= term(begin);\n       }\n    else{\n        break;\n    }\n    \n  }\n  return ret;\n}\nint term(State &begin)\n{\n  int ret = factor(begin);\n  for(;;)\n  {\n    if(*begin == '*')\n    {\n      begin++;\n      ret *= factor(begin);\n    } else if(*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nint number(State &begin) {\n  int ret = 0;\n  while(isdigit(*begin)) {\n    ret *=10;\n    ret += *begin - '0';\n    begin++;\n  }\n\n  return ret;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <vector>\n#include <cmath> // ??????\n\n#define REP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\n\nstruct FourArithmeticOperationParser {\n    \n    int pos;\n    string Formula;\n    \n    long long operator () (string F) {\n        pos = 0;\n        Formula = F;\n        return expr();\n    }\n    \n    long long number() {\n        long long ret = 0;\n        while (pos != Formula.size()) {\n            if (Formula[pos] < '0' || Formula[pos] > '9') {\n                break;\n            } else {\n                ret *= 10;\n                ret += (Formula[pos++] - '0');\n            }\n        }\n        return ret;\n    }\n    \n    long long expr() {\n        long long x = term();\n        while (pos < Formula.size()) {\n            switch (Formula[pos]) {\n                case '+':\n                    pos++;\n                    x += term();\n                    continue;\n                case '-':\n                    pos++;\n                    x -= term();\n                    continue;\n            }\n            break;\n        }\n        return x;\n    }\n    \n    long long term() {\n        long long x = factor();\n        while (pos < Formula.size()) {\n            switch (Formula[pos]) {\n                case '*':\n                    pos++;\n                    x *= factor();\n                    continue;\n                case '/':\n                    pos++;\n                    x /= factor();\n                    continue;\n            }\n            break;\n        }\n        return x;\n    }\n    \n    long long factor() {\n        if (pos < Formula.size()) {\n            if (Formula[pos] == '(') {\n                pos++;\n                long long ret = expr();\n                if (Formula[pos] == ')') {\n                    pos++;\n                }\n                return ret;\n            }\n        }\n        return number();\n    }\n    \n};\n\n\nint main() {\n   \n    int N; cin >> N;\n    REP(i,N) {\n        string s; cin >> s;\n        cout << FourArithmeticOperationParser()(s.substr(0,s.size() - 1)) << endl;\n    }\n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint calculation( int a, int b, char c )\n{\n    if( c == '+' )\n        return a + b;\n    else if( c == '-' )\n        return a - b;\n    else if( c == '*' )\n        return a * b;\n    else if( c == '/' )\n        return a / b;\n    else\n        return a;\n}\n\nint main()\n{\n    int n;\n    vector<int> d, p;\n    vector<char> f;\n    string str;\n\n\n    cin >> n;\n\n    for( int k = 0; k < n; k++ )\n    {\n        cin >> str;\n\n        for( int i = 0; d.size(); i++ )\n        {\n            d.pop_back();\n            p.pop_back();\n            f.pop_back();\n        }\n\n        int plus = 0;\n        for( int i = 0; i < str.size(); i++ )\n        {\n            int a = str[i] - '0', j = i;\n            while( 0 <= a && a < 10 )\n            {\n                j++;\n                a = str[j] - '0';\n            }\n            int sum = 0, mul = 1;\n            for( int s = 0; s < j - i; s++ )\n            {\n                sum += ( str[j-(s+1)] - '0' ) * mul;\n                mul *= 10;\n            }\n            if( 0 <= str[i] - '0' && str[i] - '0' < 10 )\n            {\n                d.push_back(sum);\n                while( mul != 1 )\n                {\n                    i++;\n                    mul /= 10;\n                }\n                i--;\n            }\n            else\n            {\n                if( str[i] == '+' || str[i] == '-' )\n                    p.push_back( plus + 1 );\n                else if( str[i] == '*' || str[i] == '/' )\n                    p.push_back( plus + 2 );\n                else if( str[i] == '(' )\n                    plus += 3;\n                else if( str[i] == '=' )\n                    p.push_back(0);\n                else\n                    plus -= 3;\n                if( str[i] != '(' && str[i] != ')' )\n                    f.push_back(str[i]);\n            }\n        }\n\n        // for( int i = 0; i < d.size(); i++ )\n        //     cout << d[i] << \" \";\n        // cout << endl;\n\n        // for( int i = 0; i < p.size(); i++ )\n        //     cout << p[i] << \" \";\n        // cout << endl;\n\n        // for( int i = 0; i < f.size(); i++ )\n        //     cout << f[i] << \" \";\n        // cout << endl;\n\n        while( f[0] != '=' )\n        {\n            for( int i = 0; i < p.size() - 1; i++ )\n            {\n                if( p[i] > p[i+1] )\n                {\n                    d[i] = calculation( d[i], d[i+1], f[i] );\n                    f[i] = f[i+1];\n                    p[i] = p[i+1];\n\n                    int s = i;\n                    while( s + 2 < p.size() )\n                    {\n                        d[s+1] = d[s+2];\n                        f[s+1] = f[s+2];\n                        p[s+1] = p[s+2];\n                        s++;\n                    }\n                }\n            }\n        }\n        cout << d[0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(s[0]=='-' || isdigit(s[0])){\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\t//else if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else\n\t//\texit(0);\n\telse{\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t}\n\t//string s;\n\t//getline(cin,s);\n\t//while(getline(cin,s))\n\t//\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint pri(char ch) \n{\n    if (ch == '*' || ch == '/')\n        return 2;\n    if (ch == '+' || ch == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    while (n--) {\n        string exp, cha;\n        stack<char> pol;\n        stack<int> cal;\n\n        cin >> exp;\n        for (int i = 0; i < exp.size() - 1; i++) {\n            if ('0' <= exp[i] && exp[i] <= '9')\n                cha.push_back(exp[i]);\n            else if (exp[i] == '(')\n                pol.push(exp[i]);\n            else if (exp[i] == ')') {\n                while (true) {\n                    if (pol.top() == '(') {\n                        pol.pop();\n                        break;\n                    }\n                    cha.push_back(pol.top());\n                    pol.pop();\n\n                }\n            }\n            else {\n                while (!pol.empty()) {\n                    if (pri(exp[i]) < pri(pol.top())) {\n                        cha.push_back(pol.top());\n                        pol.pop();\n                    }\n                    else \n                        break;\n                }\n                pol.push(exp[i]);\n            }\n        }\n\n        while (!pol.empty()) {\n            cha.push_back(pol.top());\n            pol.pop();\n        }\n\n        for (int i = 0; i < cha.size(); i++) {\n            if ('0' <= cha[i] && cha[i] <= '9')\n                cal.push(cha[i] - '0');\n            else {\n                int a, b;\n\n                b = cal.top();\n                cal.pop();\n                a = cal.top();\n                cal.pop();\n\n                if (cha[i] == '*') \n                    cal.push(a * b);\n                else if (cha[i] == '/') \n                    cal.push(a / b);\n                else if (cha[i] == '+') \n                    cal.push(a + b);\n                else if (cha[i] == '-') \n                    cal.push(a - b);\n            }\n        }\n        cerr << exp << endl;\n        cout << cal.top() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\n//parsed expr(const char* s)\n//{\n//\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tparsed now=term(s);\n//\t//while(*now.second!='=' && *now.second!=')'){\n//\twhile(*now.second=='+' || *now.second=='-'){\n//\t\tchar op=*now.second;\n//\t\tparsed next=term(now.second+1);\n//\t\tif(op=='+')\n//\t\t\tnow=parsed(now.first+next.first,next.second);\n//\t\telse\n//\t\t\tnow=parsed(now.first-next.first,next.second);\n//\t}\n//\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n//\treturn now;\n//}\n//\n//parsed term(const char* s)\n//{\n//\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tparsed now=fact(s);\n//\t//while(*now.second!='=' && *now.second!=')' && *now.second!='+' && *now.second!='-'){\n//\twhile(*now.second=='*' || *now.second=='/'){\n//\t\tchar op=*now.second;\n//\t\tparsed next=fact(now.second+1);\n//\t\tif(op=='*')\n//\t\t\tnow=parsed(now.first*next.first,next.second);\n//\t\telse\n//\t\t\tnow=parsed(now.first/next.first,next.second);\n//\t}\n//\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n//\treturn now;\n//}\n//\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\tif(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse{\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+*p-'0';\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n}\n\nparsed expr(const char *p)\n{\n  parsed r=term(p);\n  while(*r.second=='+'||*r.second=='-'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=term(r.second+1);\n    if (op=='+') r.first=tmp+r.first;\n    else r.first=tmp-r.first;\n  }\n  return r;\n}\n\nparsed term(const char *p)\n{\n  parsed r=fact(p);\n  while(*r.second=='*'||*r.second=='/'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=fact(r.second+1);\n    if (op=='*') r.first=tmp*r.first;\n    else r.first=tmp/r.first;\n  }\n  return r;\n}\n\n//parsed fact(const char *p)\n//{\n//  if (isdigit(*p)){\n//    int t=*(p++)-'0';\n//    while(isdigit(*p)) t=t*10+*(p++)-'0';\n//    return parsed(t,p);\n//  }\n//  else if (*p=='('){\n//    parsed r=expr(p+1);\n//    if (*r.second!=')') exit(0); // invalid input\n//    return parsed(r.first,r.second+1);\n//  }\n//  else\n//    exit(0); // invalid input\n//}\n\nint main()\n{\n\t//const char* s=\"-6/-4=\";\n\t//parsed p=expr(s);\n\t//cout<<p.first<<\",\"<<p.second<<endl;\n\t\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << number(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nchar readchar();\nvoid initialize(string &s);\nvoid consume(char expectation);\n\n// <expression> = <term> { ('+' | '-') <term> }\nint expression();\n// <term> = <factor> { ('*' | '/') <factor> }\nint term();\n// <factor> = '(' <expression> ')' | <number>\nint factor();\n// <number> = <digit> { <digit> }\nint number();\n\nclass ParseError {};\n\nstring::const_iterator itr;\nchar cchar;\n\nvoid initialize(string &s)\n{\n\titr = s.begin();\n\treadchar();\n}\n\nchar readchar()\n{\n\treturn cchar = *itr++;\n}\n\nvoid consume(char expectation)\n{\n\tif (cchar == expectation) {\n\t\treadchar();\n\t} else {\n\t\tdprt(\"Expected: '%c', but got '%c'\\n\", expectation, cchar);\n\t\tdprt(\"Remaining: \");\n\t\twhile (readchar()) {\n\t\t\tcerr << cchar;\n\t\t}\n\t\tcerr << endl;\n\t\tthrow ParseError();\n\t}\n}\n\n// <expression> = <term> { ('+' | '-') <term> }\nint expression()\n{\n\tint ret = term();\n\twhile (true) {\n\t\tif (cchar == '+') {\n\t\t\treadchar();\n\t\t\tret += term();\n\t\t} else if (cchar == '-') {\n\t\t\treadchar();\n\t\t\tret -= term();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n// <term> = <factor> { ('*' | '/') <factor> }\nint term()\n{\n\tint ret = factor();\n\twhile (true) {\n\t\tif (cchar == '*') {\n\t\t\treadchar();\n\t\t\tret *= factor();\n\t\t} else if (cchar == '/') {\n\t\t\treadchar();\n\t\t\tret /= factor();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n// <factor> = '(' <expression> ')' | <number>\nint factor()\n{\n\tint ret;\n\tif (cchar == '(') {\n\t\tconsume('(');\n\t\tret = expression();\n\t\tconsume(')');\n\t} else {\n\t\tret = number();\n\t}\n\treturn ret;\n}\n\n// <number> = <digit> { <digit> }\nint number()\n{\n\tint ret = 0;\n\twhile (isdigit(cchar)) {\n\t\tret *= 10;\n\t\tret += cchar - '0';\n\t\treadchar();\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint n; cin >> n;\n\tcin.ignore();\n\tREP (_, n) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tinitialize(s);\n\t\tcout << expression() << endl;\n\t\tconsume('=');\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nint sum(string s,int& i);\nint mul(string s,int& i);\nint bracket(string s,int& i);\nint num(string s,int& i);\n\nbool isdigit(char c){\n    int x=c-'0';\n    return 0<=x&&x<=9;\n}\n\nint sum(string s,int& i){\n    int ret=mul(s,i);\n    while(s[i]=='+'||s[i]=='-'){\n        char op=s[i];\n        i++;\n        int res=mul(s,i);\n        if(op=='+')ret+=res;\n        else ret-=res;\n    }\n    return ret;\n}\nint mul(string s,int& i){\n    int ret=bracket(s,i);\n    while(s[i]=='*'||s[i]=='/'){\n        char op=s[i];\n        i++;\n        int res=bracket(s,i);\n        if(op=='*')ret*=res;\n        else ret/=res;\n    }\n    return ret;\n}\n\nint bracket(string s,int& i){\n    if(isdigit(s[i]))return num(s,i);\n    i++;\n    int ret=sum(s,i);\n    i++;\n    return ret;\n}\n\nint num(string s,int& i){\n    int ret=s[i]-'0';\n    i++;\n    while(isdigit(s[i])){\n        ret=10*ret+(int)(s[i]-'0');\n        i++;\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(j,n){\n        string s;\n        cin>>s;\n        int i=0;\n        cout<<sum(s,i)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstdlib>\n#include<cctype>\nusing namespace std;\n#define P pair<int, const char*>\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n\nP fact(const char *p);\nP term(const char *p);\nP expr(const char *p);\n\nint main(){\n    int c; cin >>c;\n    REP(i, c){\n        string str; cin >>str;\n        cout <<expr(str.substr(0, str.size()).c_str()).first <<endl;\n    }\n    return 0;\n}\n\nP fact(const char *p){\n    if(isdigit(*p)){\n        int t = *(p++) - '0';\n        while(isdigit(*p)) t = t * 10 + *(p++) - '0';\n        return P(t, p);\n    } else if(*p == '('){\n        P r = expr(p + 1);\n        if(*r.second != ')') exit(0);\n        return P(r.first, r.second + 1);\n    } else{\n        exit(0);\n    }\n}\n\n\nP term(const char *p){\n    P r = fact(p);\n    while(*r.second == '*' || *r.second == '/'){\n        char op = *r.second;\n        int tmp = r.first;\n        r = fact(r.second + 1);\n        if(op == '*') r.first = tmp * r.first;\n        else r.first = tmp / r.first;\n    }\n    return r;\n}\n\nP expr(const char *p){\n    P r = term(p);\n    while(*r.second == '+' || *r.second == '-'){\n        char op = *r.second;\n        int tmp = r.first;\n        r = term(r.second + 1);\n        if(op == '+') r.first = tmp + r.first;\n        else r.first = tmp - r.first;\n    }\n    return r;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])!=-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=s[oi];\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <string>\n#include <map>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nint n;\nstring str;\nint cur;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur++;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur < S.size() && isdigit(S[cur])){\n\t\tn = n * 10 + digit();\n\t}\n\treturn n;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(cur < S.size() && (S[cur] == '+' || S[cur] == '-'){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = term();\n\t\tif(op == '+') sum += b;\n\t\telse sum -= b;\n\t}\n\t\n\treturn sum;\n\t\n}\n\nint term(){\n\tint sum = factor();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/'){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = factor();\n\t\tif(op == '*') sum *= b;\n\t\telse sum /= b;\n\t}\n}\n\nint factor(){\n\tif (S[cur] != ???(???) return number();\n\tcur++;\n\tint n = expression();\n\tcur++;\n\treturn n;\t\n}\n\n\nint main(void){\n\n\tcin >> n;\n\n\tfor(int i = 0; i < n; i++){\n\t\tcur = 0;\n\t\tcin >> str;\n\t\tstr.resize(str.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint main(){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  try {\n    for (;;) {\n      if (isdigit(s.peek()))\n      val *= 10;\n      val += s.peek() - '0';\n      s.next();\n    }\n  } catch (const std::string &) {}\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cctype>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint expr(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=(*begin)-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret=number(begin);\n\tfor(;;){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tret/=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expr(State &begin){\n\tint ret=term(begin);\n\tfor(;;){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tcin.ignore();\n\tfor(int i=0;i<N;i++){\n\t\tstring str;\n\t\tgetline(cin,str);\n\t\tState begin=str.begin();\n\t\tint ans=expr(begin);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint term(State &begin);\n\nint factor(State &begin);\n\nint number(State &begin);\n\nvoid consume(State &begin,char expected);\n\nint main(){\n  int n;\n  cin>>n;\n  cin.ignore();\n  for(int i=0;i<n;i++){\n    string s;\n    getline(cin,s);\n\n    State begin = s.begin();\n    int ans=expression(begin);\n    consume(begin,'=');\n    cout<<ans<<endl;\n  }\n\n}\n\n\nint number(State &begin){\n  int ret = 0;\n\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  if(*begin =='('){\n    consume(begin,'(');\n    int ret = expression(begin);\n    consume(begin,')');\n    return ret;\n  }\n  else{\n    return number(begin);\n  }\n}\n\n\nint term(State &begin){\n  int ret = number(begin);\n\n  for(;;){\n    if(*begin =='*'){\n      consume(begin,'*');\n      ret *= factor(begin);\n    }\n    else if(*begin =='/'){\n      consume(begin,'/');\n      ret /= factor(begin);\n    }\n    else break;\n  }\n\n  return ret;\n}\n\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  for(;;){\n    if(*begin =='+'){\n      consume(begin,'+');\n      ret += term(begin);\n    }\n    else if(*begin =='-'){\n      consume(begin,'-');\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\n\nvoid consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n      << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    p=0;\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val=number();\n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }else if(str[p]==')'){\n    p++;\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  return val;\n}\nint digit(){\n  int ret;\n  if(str[p]=='0'||str[p]=='1'||str[p]=='2'||str[p]=='3'||str[p]=='4'||str[p]=='5'||str[p]=='6'||str[p]=='7'||str[p]=='8'||str[p]=='9'){\n    ret=str[p]-'0';\n    p++;\n    if(str[p]=='0'||str[p]=='1'||str[p]=='2'||str[p]=='3'||str[p]=='4'||str[p]=='5'||str[p]=='6'||str[p]=='7'||str[p]=='8'||str[p]=='9'){\n      ret=(str[p-1]-'0')*10+(str[p]-'0');\n      digit();\n    }\n    return ret;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<string>\nusing namespace std;\nint pos;\nstring parse;\n/*\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n*/\n\nint fact();\nint term();\nint expression();\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      string p;\n      p.clear();\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n\t//p *= 10;\n\t//p += parse[pos]-'0';\n\tp += parse[pos];\n\tpos++;\n      }\n      return (atoi)(p.c_str());\n    }\n  }\n\n int term(){\n    int p = fact();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){++pos;p *= term();}\n      else {++pos;p /= term();}\n    }\n    return p;\n  }\n\n int expression(){\n    int p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){++pos;p+=term();}\n      else {++pos;p-=term();}\n    }\n    return p;\n  } \n \n/*\n};\n*/\n\n\n\n\n\n\n\nint main(){\n  string s;\n  int N;\n  cin >> N;\n  while(N-- > 0){\n    pos = 0;\n    cin >> s;\n    parse = s.substr(0,s.length()-1);\n   \n    //Parsing par = Parsing(s.substr(0,s.length()-1));\n    //cout << par.expression() << endl;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n;\nstring str;\nint start,goal;\nvoid kake();\nvoid tasi();\nvoid tume(int s,int g){\n  string str2=\"\";\n  for(int i = 0 ; i < str.size() ; i++){\n    if(str[i] != '#'&& (s!=i || g != i))str2+=str[i];\n  }\n  str= str2;\n}\nvoid cal(){\n  kake();\n  tasi();\n}\nvoid kake(){\n  for(int i = start ; i <= goal ; i++ ){\n    if(str[i] == '*'){\n      int t = (str[i-1] - '0')*(str[i+1] - '0'); \n\n      str[i-1] = str[i+1] = '#'; \n      str[i] = char(t+'0');\n      tume(i-1,i+1);\n      i = start;\n      goal = goal-2;\n\n    }\n    if(str[i] == '/'){\n      int t = (str[i-1] - '0')/(str[i+1] - '0'); \n      str[i-1] = str[i+1] = '#'; \n      str[i] = char(t+'0');\n      tume(i-1,i+1);\n      i = start;\n      goal = goal-2;\n\n\n    }\n  }\n}\nvoid tasi(){\n  for(int i = start ; i <= goal ; i++ ){\n    if(str[i] == '+'){\n      int t = (str[i-1] - '0')+(str[i+1] - '0'); \n      str[i-1] = str[i+1] = '#'; \n      str[i] = char(t+'0');\n      tume(i-1,i+1);\n      i = start;\n      goal = goal-2;\n\n    }\n    if(str[i] == '-'){\n      int t = (str[i-1] - '0')-(str[i+1] - '0'); \n      str[i-1] = str[i+1] = '#'; \n      str[i] = char(t+'0');\n      tume(i-1,i+1);\n      i = start;\n      goal = goal-2;\n    }\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n--){\n    str = \"\";\n    cin >> str;\n\n    if(str[0] == '#')break;\n\n    for(int i = 0 ; i < str.size() ; i++){\n      if(str[i] == '(')start = i;\n      if(str[i] == ')'){\n\tgoal = i;\n\tcal();\n\tstr[start] = '#';\n\tstr[goal] = '#';\n\ttume(start,goal);\n\ti = -1;\n\tcontinue;\n      }\n    }\n    start = 0,goal = str.size()-1;\n    cal();\n    int ans = str[0] - '0';\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tint ret = expression(begin);\n\t\tconsume(begin,')');\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nstring s;\n\nint parse(int l, int r)\n{\n\tint k = 0;\n\tfor(int i = r - 1; i >= l; i--){\n\t\tif(s[i] == ')') k++;\n\t\tif(s[i] == '(') k--;\n\t\n\t\tif(!k && s[i] == '+') return parse(l, i) + parse(l+i, r);\n\t\tif(!k && s[i] == '-') return parse(l, i) - parse(l+i, r);\n\t}\n\t\n\tfor(int i = r - 1; i >= l; i--){\n\t\tif(s[i] == ')') k++;\n\t\tif(s[i] == '(') k--;\n\t\n\t\tif(!k && s[i] == '*') return parse(l, i) * parse(l+i, r);\n\t\tif(!k && s[i] == '/') return parse(l, i) / parse(l+i, r);\n\t}\n\t\n\tif(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n\t\n\treturn stoi(s.substr(l, r - l));\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> s;\n\t\tcout << parse(0, (int)s.size() - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\ndouble calc2(char *eq){\n\tlong c=0, sign[100]={0};\n\tdouble num[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong long int calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn (long long int)calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  参考元：構文解析 Howto\n  (https://gist.github.com/draftcode/1357281)\n\n  構文解析\n  <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n  <乗算除算の式> ::= <括弧か数> (* or / ) <括弧か数> (* or / ) ...\n  <括弧か数> ::= '(' <四則演算の式> ')' or <数>\n  <数> ::= ...\n*/\n\n#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\n\n// 数字の列をパースして，その数を返す．\nint number(State &begin)\n{\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\n// 括弧か数をパースして，その評価結果を返す．\nint factor(State &begin)\n{\n    if (*begin == '(') {\n        begin++;  // '('を飛ばす\n        int ret = expression(begin);\n        begin++; // ')'を飛ばす\n        return ret;\n    }\n    else\n        return number(begin);\n}\n\n// 乗算除算の式をパースして，その評価結果を返す．\nint term(State &begin)\n{\n    int ret = factor(begin);\n\n    while (true) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else\n            break;\n    }\n\n    return ret;\n}\n\n// 四則演算の式をパースして，その評価結果を返す．\nint expression(State &begin)\n{\n    int ret = term(begin);\n\n    while (true) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else\n            break;\n    }\n\n    return ret;\n}\n\n\nint main()\n{\n    int N;\n\n    cin >> N;\n    cin.ignore();\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint p;\nstring S;\n\nint num();\nint factor();\nint term();\nint calc();\n\nint num(){\n\tint n = 0;\n\twhile(p<S.size()-1){\n\t\tif(isdigit(S[p])) n = n*10+S[p]-'0';\n\t\telse break;\n\t\tp++;\n\t}\n\treturn n;\n}\n\nint factor(){\n\tint n;\n\tif(S[p]=='('){\n\t\tp++; n = calc(); p++;\n\t}\n\telse n = num();\n\treturn n;\n}\n\nint term(){;\n\tint n = factor();\n\twhile(p<S.size()-1){\n\t\tif(S[p]=='*') p++, n *= factor();\n\t\telse if(S[p]=='/') p++, n /= factor();\n\t\telse break;\n\t}\n\treturn n;\n}\n\nint calc(){\n\tint n = term();\n\twhile(p<S.size()-1){\n\t\tif(S[p]=='+') p++, n += term();\n\t\telse if(S[p]=='-') p++, n -= term();\n\t\telse break;\n\t}\n\treturn n;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>S;\n\t\tp = 0;\n\t\tprintf(\"%d\\n\",calc());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<cstring>\n\nvoid erase(std::vector<std::string>&v,int e,int f){\n\tfor(int i=e;i<v.size()-f;i++)v[i]=v[i+f];\n}\n\nstd::string solve(std::string str){\n\tstd::vector<std::string>v;\n\tint a,b,c,d,v_size,j=0;\n\tfor(int i=0;i<=str.size();i++){\n\t\tif(i==str.size()||str[i]=='+'||str[i]=='-'||str[i]=='*'||str[i]=='/'){\n\t\t\tv.push_back(str.substr(j,i-j));\n\t\t\tv.push_back(str.substr(i,1));\n\t\t\tj=i+1;\n\t\t}\n\t}\n\tv_size=v.size();\n\ta=std::find(v.begin(),v.begin()+v_size,\"*\")-v.begin();\n\twhile(a!=v_size){\n\t\tint p=std::stoi(v[a-1]),q=std::stoi(v[a+1]);\n\t\tstd::stringstream z;\n\t\tz<<p*q;z>>v[a-1];\n\t\terase(v,a,2);v_size-=2;\n\t\ta=std::find(v.begin(),v.begin()+v_size,\"*\")-v.begin();\n\t}\n\tb=std::find(v.begin(),v.begin()+v_size,\"/\")-v.begin();\n\twhile(b!=v_size){\n\t\tint p=std::stoi(v[b-1]),q=std::stoi(v[b+1]);\n\t\tstd::stringstream z;\n\t\tz<<p/q;z>>v[b-1];\n\t\terase(v,b,2);v_size-=2;\n\t\tb=std::find(v.begin(),v.begin()+v_size,\"/\")-v.begin();\n\t}\n\tc=std::find(v.begin(),v.begin()+v_size,\"+\")-v.begin();\n\twhile(c!=v_size){\n\t\tint p=std::stoi(v[c-1]),q=std::stoi(v[c+1]);\n\t\tstd::stringstream z;\n\t\tz<<p+q;z>>v[c-1];\n\t\terase(v,c,2);v_size-=2;\n\t\tc=std::find(v.begin(),v.begin()+v_size,\"+\")-v.begin();\n\t}\n\td=std::find(v.begin(),v.begin()+v_size,\"-\")-v.begin();\n\twhile(d!=v_size){\n\t\tint p=std::stoi(v[d-1]),q=std::stoi(v[d+1]);\n\t\tstd::stringstream z;\n\t\tz<<p-q;z>>v[d-1];\n\t\terase(v,d,2);v_size-=2;\n\t\td=std::find(v.begin(),v.begin()+v_size,\"-\")-v.begin();\n\t}\n\treturn v[0];\n}\n\nint main(){\n\tint n;\n\tstd::string str;\n\tstd::cin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstd::cin>>str;\n\t\tint a=str.find('('),b=str.find(')');\n\t\twhile(a!=-1){\n\t\t\tstd::string astr=str.substr(a+1,(b-1)-a);\n\t\t\tstr.erase(a,b-a+1);\n\t\t\tstr.insert(a,solve(astr));\n\t\t\ta=str.find('('),b=str.find(')');\n\t\t}\n\t\tstd::cout<<solve(str.substr(0,str.size()-1))<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0]) || s[0]=='-'){\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\t//else if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else\n\t//\texit(0);\n\telse{\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\ninline int toInt(string s){int v;istringstream i(s);i>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream o;o<<x;return o.str();}\ntemplate<class T> void pv(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\nconst int INF = 1000000000;\nconst double EPS = 1e-10;\n\ntypedef string::const_iterator State;\n\nint express(State& p);\nint factor(State& p);\nint term(State &p);\nint number(State &p);\n\n// 足し算\nint express(State& p) {\n\tint r = factor(p);\n\t\n\tfor(;;) {\n\t\tif(*p == '+') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr += rs;\n\t\t}\n\t\telse if(*p == '-') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr -= rs;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\n// カッコ\nint factor(State &p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\tint ret = express(p);\n\t\tp++;\n\t\treturn ret;\n\t}\n\treturn term(p);\n}\n\n// 掛け算\nint term(State &p) {\n\tint r = number(p);\n\t\n\tfor(;;) {\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tint rs = number(p);\n\t\t\tr *= rs;\n\t\t}\n\t\telse if(*p == '/') {\n\t\t\tp++;\n\t\t\tint rs = number(p);\n\t\t\tr /= rs;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint number(State &p) {\n\tif(*p == '(') return factor(p);\n\tint ret = 0;\n\t\n\twhile(isdigit(*p)) {\n\t\tret *= 10;\n\t\tret += *p - '0';;\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tint N; cin >> N;\n\tcin.ignore();\n\twhile(N--) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tState p = line.begin();\n\t\tint ans = express(p);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  cout <<  val << endl;\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val=number();\n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }else if(str[p]==')'){\n    p++;\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  return val;\n}\nint digit(){\n  cout << 'p' << p << endl;\n  if(str[p]=='0'){\n    p++;\n    return 0;\n  }\n  else if(str[p]=='1'){\n    p++;\n    return 1;\n  }\n  else if(str[p]=='2'){\n    p++;\n    return 2;\n  }\n  else if(str[p]=='3'){\n    p++;\n    return 3;\n  }\n  else if(str[p]=='4'){\n    p++;\n    return 4;\n  }\n  else if(str[p]=='5'){\n    p++;\n    return 5;\n  }\n  else if(str[p]=='6'){\n    p++;\n    return 6;\n  }\n  else if(str[p]=='7'){\n    p++;\n    return 7;\n  }\n  else if(str[p]=='8'){\n    p++;\n    return 8;\n  }\n  else if(str[p]=='9'){\n    p++;\n    return 9;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline string sub(string str, int i) {\n    return string(str.begin() + i + 1, str.end());\n}\n\nint dfs(string);\nint get_num(string&, int&);\n\nint get_num(string& str, int& i) {\n    int num = 0;\n\n    if (str[i] == '(') {\n        string ss;\n        i++;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n\n            if (count) {\n                ss += str[i];\n            }\n        }\n\n        if (str[i] != ')') i--;\n        return dfs(ss);\n    }\n\n    for (; i < str.size(); i++) {\n        if ('0' <= str[i] && str[i] <= '9') {\n            num = num * 10 + (str[i] - '0');\n        } else {\n            return num;\n        }\n    }\n\n    return num;\n}\n\nint dfs(string str) {\n    int num = 0;\n\n    int i = 0;\n\n    if (str[i] == '-') {\n        num = -1 * get_num(str, ++i);\n    }\n\n    if (str[0] == '(') {\n        num = get_num(str, i);\n    }\n\n    for (; i < str.size(); i++) {\n        if ('0' <= str[i] && str[i] <= '9') {\n            num = num * 10 + (str[i] - '0');\n        } else {\n            if (str[i] == '*') {\n                num = num * get_num(str, ++i);\n            } else if (str[i] == '/') {\n                num = num / get_num(str, ++i);\n            } else if (str[i] == '+') {\n                return num + dfs(sub(str, i));\n            } else if (str[i] == '-') {\n                return num - dfs(sub(str, i));\n            } if (str[i] == ')') {\n                continue;\n            } else {\n                return num;\n            }\n        }\n    }\n\n    return num;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        string str;\n        cin >> str;\n\n        cout << dfs(str) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nstring toRPN(string s){\n    stack<char> ope;\n    string ret=\"\";\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ) ret+=s[i];\n        \n        else{\n            if(s[i]=='('){\n                ope.push(s[i]);\n                \n            }else if(s[i]==')'){\n                while(ope.top()!='('){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else{\n                return \"invalid\";\n            }\n        }\n    }\n    while(ope.size()){\n        ret+=ope.top();\n        ope.pop();\n    }\n\n    return ret;\n}\n\n\nstring solveRPN(string s){\n    stack<int> stk;\n\n    \n    for(int i=0;i<s.size();i++){\n        if( isdigit(s[i]) )stk.push( s[i]-'0'  );\n        else{\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            \n            if(s[i]=='+')stk.push(a+b);\n            if(s[i]=='-')stk.push(a-b);\n            if(s[i]=='*')stk.push(a*b);\n            if(s[i]=='/')stk.push(a/b);\n        }\n    }\n    \n    stringstream ret;\n    ret<<stk.top();\n    \n    return ret.str();\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        string s;\n        cin>>s;\n        \n        s.erase(s.size()-1);\n        \n        s=toRPN(s);\n        s=solveRPN(s);\n    \n        cout<<s<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\nstring s;\nsize_t cur=0;\nint digit()\n{\n    assert(isdigit(s[cur]));\n    int n=s[cur]-'0';\n    cur=cur+1;\n    return n;\n};\nint number()\n{\n    int n=digit();\n    while(cur<s.size()&&isdigit(s[cur]))\n        n=n*10+digit();\n    return n;\n};\ndouble expression();\ndouble factor()\n{\n    if(s[cur]!='(')\n        return number();\n    cur++;\n    double n=expression();\n    assert(s[cur]==')');\n    cur++;\n    return n;\n};\ndouble term()\n{\n    double a=factor();\n    while(cur<s.size()&&(s[cur]=='*'||s[cur]=='/'))\n    {\n        char op=s[cur++];\n        int b=factor();\n        if(op=='*')\n            a*=b;\n        else\n            a/=b;\n    }\n    return a;\n};\n\n\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cur=0;\n        cin>>s;\n        s.resize(s.size()-1);\n        cout<<expression()<<endl;\n    }\n}\n\ndouble expression()\n{\n    int a=term();\n    while((cur<s.size())&&(s[cur]=='+'||s[cur]=='-'))\n    {\n        char op=s[cur++];\n        int b=term();\n        if(op=='+')\n            a+=b;\n        else\n            a-=b;\n    }\n    return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n\nvoid erase(std::vector<std::string>&v,int e,int f){\n\tfor(int i=e;i<v.size()-f;i++)v[i]=v[i+f];\n}\n\nstd::string solve(std::string str){\n\tstd::vector<std::string>v;\n\tint a,b,c,d,v_size,j=0;\n\tfor(int i=0;i<=str.size();i++){\n\t\tif(i==str.size()||str[i]=='+'||str[i]=='-'||str[i]=='*'||str[i]=='/'){\n\t\t\tv.push_back(str.substr(j,i-j));\n\t\t\tv.push_back(str.substr(i,1));\n\t\t\tj=i+1;\n\t\t}\n\t}\n\tv_size=v.size();\n\ta=std::find(v.begin(),v.begin()+v_size,\"*\")-v.begin();\n\twhile(a!=v_size){\n\t\tint p=std::stoi(v[a-1]),q=std::stoi(v[a+1]);\n\t\tstd::stringstream z;\n\t\tz<<p*q;z>>v[a-1];\n\t\terase(v,a,2);v_size-=2;\n\t\ta=std::find(v.begin(),v.begin()+v_size,\"*\")-v.begin();\n\t}\n\tb=std::find(v.begin(),v.begin()+v_size,\"/\")-v.begin();\n\twhile(b!=v_size){\n\t\tint p=std::stoi(v[b-1]),q=std::stoi(v[b+1]);\n\t\tstd::stringstream z;\n\t\tz<<p/q;z>>v[b-1];\n\t\terase(v,b,2);v_size-=2;\n\t\tb=std::find(v.begin(),v.begin()+v_size,\"/\")-v.begin();\n\t}\n\tc=std::find(v.begin(),v.begin()+v_size,\"+\")-v.begin();\n\twhile(c!=v_size){\n\t\tint p=std::stoi(v[c-1]),q=std::stoi(v[c+1]);\n\t\tstd::stringstream z;\n\t\tz<<p+q;z>>v[c-1];\n\t\terase(v,c,2);v_size-=2;\n\t\tc=std::find(v.begin(),v.begin()+v_size,\"+\")-v.begin();\n\t}\n\td=std::find(v.begin(),v.begin()+v_size,\"-\")-v.begin();\n\twhile(d!=v_size){\n\t\tint p=std::stoi(v[d-1]),q=std::stoi(v[d+1]);\n\t\tstd::stringstream z;\n\t\tz<<p-q;z>>v[d-1];\n\t\terase(v,d,2);v_size-=2;\n\t\td=std::find(v.begin(),v.begin()+v_size,\"-\")-v.begin();\n\t}\n\treturn v[0];\n}\n\nint main(){\n\tint n;\n\tstd::string str;\n\tstd::cin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstd::cin>>str;\n\t\tint a=str.find('('),b=str.find(')');\n\t\twhile(a!=-1){\n\t\t\tstd::string astr=str.substr(a+1,(b-1)-a);\n\t\t\tstr.erase(a,b-a+1);\n\t\t\tstr.insert(a,solve(astr));\n\t\t\ta=str.find('('),b=str.find(')');\n\t\t}\n\t\tstd::cout<<solve(str.substr(0,str.size()-1))<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return -1;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        string s;\n        cin >> s;\n        State tmp = s.begin();\n        int ans = expression(tmp);\n        consume(tmp, '=');\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint cnt=0;\nint ret;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    p=0;\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val=number();\n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }else if(str[p]==')'){\n    p++;\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  ret=0;\n  cnt=0;\n  return val;\n}\nint digit(){\n    if(str[p]=='0'||str[p]=='1'||str[p]=='2'||str[p]=='3'||str[p]=='4'||str[p]=='5'||str[p]=='6'||str[p]=='7'||str[p]=='8'||str[p]=='9'){\n    if(cnt==0){\n      ret=str[p]-'0';\n      cnt=1;\n    }\n    p++;\n    if(str[p]=='0'||str[p]=='1'||str[p]=='2'||str[p]=='3'||str[p]=='4'||str[p]=='5'||str[p]=='6'||str[p]=='7'||str[p]=='8'||str[p]=='9'){\n      ret=ret*10+(str[p]-'0');\n      digit();\n    }\n    return ret;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nstring s;\nint p;\n\nint expr();\n\nint num() {\n  int res = 0;\n  while (p < s.size() && '0' <= s[p] && s[p] <= '9') {\n    res *= 10;\n    res += s[p] - '0';\n    p++;\n  }\n  return res;\n}\n\nint factor() {\n  int res = 0;\n  if (s[p] == '(') {\n    p++;\n    res = expr();\n    p++;\n  } else {\n    res = num();\n  }\n  return res;\n}\n\nint term() {\n  int res = factor();\n  while (p < s.size()) {\n    if (s[p] == '*') {\n      p++;\n      res *= factor();\n    } else if (s[p] == '/') {\n      p++;\n      res /= factor();\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nint expr() {\n  int res = term();\n  while (p < s.size()) {\n    if (s[p] == '+') {\n      p++;\n      res += term();\n    } else if (s[p] == '-') {\n      p++;\n      res -= term();\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i, n) {\n    cin >> s;\n    p = 0;\n    cout << expr() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint digit(){\n  return S[cur++]-'0';\n}\n\nint number(){\n  int n=digit();\n  while(cur<S.size()&&isdigit(S[cur])){\n    n=n*10+digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor(){\n  if(isdigit(S[cur]))return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint term(){\n  int t=factor();\n  for(;cur<S.size()&&(S[cur]=='*'||S[cur]=='/');){\n    if(S[cur++]=='*')t*=factor();\n\telse t/=factor();\n  }\n  return t;\n}\n\nint expression(){\n  int t=term();\n  for(;cur<S.size()&&(S[cur]=='+'||S[cur]=='-');){\n    if(S[cur++]=='+')t+=term();\n\telse t-=term();\n  }\n  return t;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  for(;n--;){\n    cur=0;\n    cin>>S;\n\tcout<<expression()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x);\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\tif (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\tif (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '(') {\n\t\t val1 = siki(str, i);\n\t\ti += 2;\n\t}\n\telse {\n\t\t val1 = number(str, i);\n\t}\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tval1 = val1 * 10;\n\t\t\tval1 += number(str, i);\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work,count;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}else if(line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '('){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\ntypedef long long ll;\n\n\nint lp;\nint lpcnt = 0;\n\n\nstring str;\n\nbool input(){\n\n  if(lpcnt==0)cin>>lp;\n\n  if(lpcnt==lp)return false;\n  cin>>str;\n\n  lpcnt++;\n  return true;\n}\n\n\nclass S{\npublic:\n  bool isnum;\n  bool isc;\n  char c;\n  int num;\n  S(bool isnum, bool isc, char c, int num):isnum(isnum),isc(isc),c(c),num(num){}\n  S(){isnum=isc=false; c='#'; num=0;}\n  void print(){\n    printf(\"%d %d %d %c\\n\",isnum,isc,num,c);\n  }\n};\n\ntypedef pair<int,string> pis;\ntypedef pair<char,string> pcs;\n\nbool isnum(char c){\n  return '0'<=c && c<='9';\n}\n\nint ctonum(char c){\n  return c-'0';\n}\n\npis getHeadNum(string str){\n\n  pis ret = pis(0,\"\");\n  int st = 0;\n  while(str.size()!=st && isnum(str[st])){\n    ret.first *= 10;\n    ret.first += ctonum(str[st]);\n    st++;\n  }\n\n  ret.second = str.substr(st);\n  return ret;\n}\n\npcs getHeadChar(string str){\n  return pcs(str[0], str.substr(1));\n}\n\n\n\nvector<S> getEq(string str){\n  vector<S> eq;\n  string sc = str;\n  eq.clear();\n\n  while(sc.size()!=0){\n    int hu = 1;\n    S add;\n    if(sc[0]=='-' && ((eq.size()!=0 && eq[eq.size()-1].isc)||eq.size()==0)){\n      hu = -1;\n      sc = sc.substr(1);\n    }\n    if(isnum(sc[0])){\n      add.isnum = true;\n      pis res = getHeadNum(sc);\n      add.num = hu*res.first;\n      sc = res.second;\n    }else{\n      add.isc = true;\n      pcs res = getHeadChar(sc);\n      add.c = res.first;\n      sc = res.second;\n    }\n    eq.push_back(add);\n  }\n  return eq;\n}\n\nint calc(int st, int en, vector<S>& eq){\n  \n  /*\n  for(int i=st;i<en;i++){\n    eq[i].print();\n  }puts(\"\");\n  */\n\n\n\n  if(st>=en){\n    printf(\"%d %d\\n\",st,en);\n    assert(0);\n  }\n\n  if(eq[st].isc){\n    int a = 0;\n\n    if(eq[st].c=='('){\n      reps(i,st,eq.size()){\n\tif(eq[i].c=='(')a++;\n\tif(eq[i].c==')')a--;\n\tif(a==0){\n\t  return calc(st+1, i, eq);\n\t}\n      }\n\n      puts(\"isc\");\n      assert(0);\n    }\n  }\n\n  if(eq[st].isnum){\n    int num = eq[st].num;\n    if(st+1==en)return num;\n    int a=0;\n\n    reps(i,st+1,en){\n\n      if(eq[i].c=='(')a++;\n      if(eq[i].c==')')a--;\n\n\n      if(a==0){\n\tif(eq[i].c=='-'){\n\t  return calc(st, i, eq) - calc(i+1, en, eq);\n\t}\n\tif(eq[i].c=='+'){\n\t  return calc(st, i, eq) + calc(i+1, en, eq);\n\t}\n      }\n\n    }\n\n    reps(i,st+1, en){\n\n      if(eq[i].c=='*'){\n\treturn calc(st, i, eq) * calc(i+1, en, eq);\n      }\n      if(eq[i].c=='/'){\n\treturn calc(st, i, eq) / calc(i+1, en, eq);\n      }\n    }\n\n    puts(\"isn\");\n    assert(0);\n\n  }\n  puts(\"AAA\");\n  assert(0);\n  return -1;\n  \n}\nint solve(){\n  vector<S> eq = getEq(str);\n  return calc(0,eq.size()-1, eq);\n}\n\nint main(){\n  while(input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstring s;\nint a;\nint func();//+-\nint num();\nint func2();//*/\nint func3();//()\nint num(){\n    int out=0;\n    while(isdigit(s[a])){\n        out*=10;out+=s[a]-'0';\n        a++;\n    }\n    return out;\n}\nint func3(){\n    int out;\n    if(s[a]=='('){\n        a++;\n        out=func();\n        a++;\n    }else out=num();\n    return out;\n}\nint func2(){\n    int out=func3();\n    while(1){\n        if(s[a]=='*'){\n            a++;\n            out*=func3();\n        }else if(s[a]=='/'){\n            a++;\n            out/=func3();\n        }else break;\n    }\n    return out;\n}   \nint func(){\n    int out=func2();\n    while(1){\n        if(s[a]=='+'){\n            a++;out+=func2();\n        }else if(s[a]=='-'){\n            a++;out-=func2();\n        }else break;\n    }\n    return out;\n}\nint main(){\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tcin>>s;\n\t\ta=0;\n\t\tcout<<func()<<endl;\n\t}\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nusing namespace std;\n\n \nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint main(void){\n  int N;\n  std::cin >> N;\n\n  while(N--){\n    std::string s;\n    std::cin>>s;\n    State begin = s.begin();\n    int ans = expression(begin);\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}\n \nint number(State &begin){\n  int ret = 0;\n \n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n \n  return ret;\n}\n \nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n \n\n \nint expression(State &begin){\n  int num = term(begin);\n  int sum = 0;\n  \n  for(;;){\n    char ch = *begin;\n    begin++;\n    if(ch == '+'){\n      num += factor(begin);\n    } else if(ch == '-'){\n      num -= factor(begin);\n    }else if(ch == '*'){\n      sum += num;\n      num = factor(begin);\n    }else if(ch == '/'){\n      sum += num;\n      num = factor(begin);\n    }else{\n      break;\n    }\n  }\n  return sum+num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nstruct S{\n\tstring s;\n\tint i;\n\tchar nx(){\n\t\treturn s[i];\n\t}\n\tbool dig(){\n\t\treturn '0'<=nx()&&nx()<='9';\n\t}\n\tvoid inc(){i++;}\n};\n\nint expr(S&);\nint term(S&);\nint fact(S&s);\nint num(S&);\n\nint expr(S&s){\n\tint a=term(s);\n\twhile(1){\n\t\tif(s.nx()=='+'){\n\t\t\ts.inc();\n\t\t\ta+=term(s);\n\t\t}else if(s.nx()=='-'){\n\t\t\ts.inc();\n\t\t\ta-=term(s);\n\t\t}else\n\t\t\tbreak;\n\t}\n\treturn a;\n}\n\nint fdiv(int a,int b){\n\treturn a/b-((a^b)<0&&a%b);\n}\n\nint term(S&s){\n\tint a=fact(s);\n\twhile(1){\n\t\tif(s.nx()=='*'){\n\t\t\ts.inc();\n\t\t\ta*=fact(s);\n\t\t}else if(s.nx()=='/'){\n\t\t\ts.inc();\n\t\t\ta/=fact(s);\n\t\t\t//a=fdiv(a,fact(s));\n\t\t}else\n\t\t\tbreak;\n\t}\n\treturn a;\n}\n\nint fact(S&s){\n\tif(s.nx()=='('){\n\t\ts.inc();\n\t\tint a=expr(s);\n\t\ts.inc();\n\t\treturn a;\n\t}else{\n\t\tint a=0;\n\t\twhile(s.dig()){\n\t\t\ta=a*10+s.nx()-'0';\n\t\t\ts.inc();\n\t\t}\n\t\treturn a;\n\t}\n}\n\nvoid slv(){\n\tS s;\n\tcin>>s.s;\n\ts.i=0;\n\tcout<<expr(s)<<endl;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\trep(_,n)slv();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  // while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  // }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State &begin) {\n  int ans = 0;\n  bool flag = false;\n  if (*begin == '-') flag = true, begin++;\n  while (isdigit(*begin)) ans = ans * 10 + (*begin - '0'), begin++;\n  if (flag) ans = -ans;\n  return ans;\n}\n\nint expression(State &begin);\n\nint factor(State &begin) {\n  int ans;\n  if (*begin == '(') begin++, ans = expression(begin), begin++;\n  else ans = number(begin);\n  return ans;\n}\n\nint term(State &begin) {\n  int ans = factor(begin);\n  while (1) {\n    if (*begin == '*') begin++, ans *= factor(begin);\n    else if (*begin == '/') begin++, ans /= factor(begin);\n    else return ans;\n    //begin++;\n  }\n}\n\nint expression(State &begin) {\n  int ans = term(begin);\n  while (1) {\n    if (*begin == '+') begin++, ans += term(begin);\n    else if (*begin == '-') begin++, ans -= term(begin);\n    else return ans;\n    //begin++;\n  }\n}\n\nint main() {\n  int n;\n  string s;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    State temp = s.begin();\n    cout << expression(temp) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint cnt=0;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    p=0;\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val=number();\n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }else if(str[p]==')'){\n    p++;\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  return val;\n}\nint digit(){\n  int ret,cnt=0;\n  while(1){\n    if(cnt==0&&'0'<=str[p]&&str[p]<='9'){\n      ret=str[p]-'0';\n      p++;\n      cnt=1;\n    }\n    else if(cnt==1&&'0'<=str[p]&&str[p]<='9'){\n      ret=ret*10+(str[p]-'0');\n      p++;\n    }\n    else{\n      break;\n    }\n  }\n  /*  if('0' <= str[p] && str[p] <= '9') {\n    if(cnt==0){\n      ret=str[p]-'0';\n      cnt=1;\n    }\n    p++;\n    if('0' <= str[p] && str[p] <= '9') {\n      ret=ret*10+(str[p]-'0');\n      digit();\n    }\n    return ret;\n    }*/\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n  //  string hand;                                                                                                                                                                                                                                                                                                                                                                                          \n  //  string side;                                                                                                                                                                                                                                                                                                                                                                                          \n\n  vector<string> hand;\n  vector<string> side;\n\n  // ÊàtO                                                                                                                                                                                                                                                                                                                                                                                           \n  bool isInside = false;\n\n  for(int i = 0; i < str.size(); i++){\n    //    cout << str[i] << endl;                                                                                                                                                                                                                                                                                                                                                                           \n    //    cout << hand << endl;                                                                                                                                                                                                                                                                                                                                                                             \n    //    cout << side << endl;                                                                                                                                                                                                                                                                                                                                                                             \n\n    if(str[i] >= '0' && str[i] <= '9'){\n      cout << str[i] << endl;\n      string num;\n      while(i < str.size()){\n        if(str[i] < '0' || str[i] > '9'){\n          //      hand += str[i];                                                                                                                                                                                                                                                                                                                                                                           \n          break;\n        }\n        num += str[i];\n        i++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      isInside = true;\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(isInside && str[i] == ')'){\n      // EÊÜÅZqðêÂ¸Âè³Éß·                                                                                                                                                                                                                                                                                                                                                               \n      //      cout << side << endl;                                                                                                                                                                                                                                                                                                                                                                         \n      for(int j = side.size()-1 ; ;j--){\n        if(side[j] == \"(\"){\n          if(j != 0){\n            vector<string> tmp;\n            for(int k = 0; k < j; k++){\n              tmp.push_back(side[k]);\n            }\n            side = tmp;\n          }\n          else\n            side.clear();\n          break;\n        }\n        else{\n          string tmp = side[j];\n          hand.push_back(tmp);\n        }\n      }\n      isInside = false;\n    }\n    else{\n      if(side.size() == 0){\n        string tmp;\n        tmp += str[i];\n        side.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n        if(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n          hand.push_back(side[side.size()-1]);\n          string tmp;\n          tmp += str[i];\n          side[side.size()-1] = tmp;\n        }\n        else{\n          string tmp;\n          tmp += str[i];\n          side.push_back(tmp);\n        }\n      }\n      else{\n        if(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n          hand.push_back(side[side.size()-1]);\n          string tmp;\n          tmp += str[i];\n          side[side.size()-1] = string(tmp);\n        }\n        else{\n          string tmp;\n          tmp += str[i];\n          side.push_back(tmp);\n        }\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n\n  return hand;\n}\n\n\nint calc(vector<string> str){\n\n  //  cout << str << endl;                                                                                                                                                                                                                                                                                                                                                                                  \n  //  string stack;                                                                                                                                                                                                                                                                                                                                                                                         \n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n        st.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n        st.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n        st.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n        st.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  string str;\n  getline(cin,str);\n\n  vector<string> vec = toReversePorland(str);\n  // for(int i = 0; i < vec.size(); i++)                                                                                                                                                                                                                                                                                                                                                                    \n  //   cout << vec[i] << flush;                                                                                                                                                                                                                                                                                                                                                                             \n  // cout << endl;                                                                                                                                                                                                                                                                                                                                                                                          \n\n  cout << calc(toReversePorland(str)) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Factor();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include<stack>\n\nusing namespace std;\nstring str;\nint p;\n \nint exp();\nint factor();\nint term();\n \nint factor() {\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n \n  if (str[p] == '('){\n    p++;\n    num = exp();\n    p++;\n  }\n\n  return num;\n}\n\nint exp() {\n\n  int sum=0,top=factor();\n  \n\n  while(str[p]!='=' && str[p]!=')') {\n    if(str[p] == '+') {\n      p++;\n      sum+=top;\n      top=factor();\n    } else if(str[p] == '-'){\n      p++;\n      sum+=top;\n      top=-factor();\n    } else if(str[p] == '*'){\n      p++;\n      top*=factor();\n    }else if(str[p] == '/'){\n      p++;\n      top/=factor();\n    }\n  }\n  return sum+top;\n}\n\n\n/*\nint exp() {\n\n  \n  stack<int> st;\n  st.push(factor());\n\n  while(str[p]!='=' && str[p]!=')') {\n    if(str[p] == '+') {\n      p++;\n      st.push(factor());\n    } else if(str[p] == '-'){\n      p++;\n      st.push(-factor());\n    } else if(str[p] == '*'){\n      p++;\n      int k=st.top();\n      st.pop();\n      st.push(k*factor());\n    }else if(str[p] == '/'){\n      p++;\n      int k=st.top();\n      st.pop();\n      st.push(k/factor()); \n    }\n    \n  }\n \n  int sum=0;\n  while(!st.empty()){\n    sum+=st.top();\n    st.pop();\n  }\n  return sum;\n}\n*/ \nint main() {\n  int n;\n \n  cin >> n;\n   \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nlong calc2(char *eq){\n\tlong c=0, sign[100]={0};\n\tlong num[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\twhile((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tbuf[p2-p]=0;\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn (long)calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\nusing namespace std;\n\n//????¨???????????¶????????????¨???????????????\nclass CAL{\nprivate:\n  string m_str;\n  size_t m_cur;\n  int digit();\n  int number();\n  int term();\n  int expression();\n  int factor();\n  int calterm();\npublic:\n  CAL(string str);\n  int cal();\n};\n\n//?????????????????????\nCAL::CAL(string str)\n{\n  m_str = str;\n  m_cur = 0;\n  m_str.resize(m_str.size() - 1);\n}\n\n//??????????????°????????°????????????\nint CAL::digit()\n{\n  assert(isdigit(m_str[m_cur]));\n  int n = m_str[m_cur++] - '0';\n  return n;\n}\n\n//??°??????????????¨?????¨???????????°??????????????????\nint CAL::number()\n{\n  int n = digit();\n  while(m_cur < m_str.size() && isdigit(m_str[m_cur]))\n    n = n*10 + digit();\n  return n;\n}\n\n//???????????¨?????????????°???\\\nint CAL::term()\n{\n  int a = number();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = number();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????????\nint CAL::expression()\n{\n  int a = term();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = term();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????°?????¨?????????????????????number()??????????????????\nint CAL::factor()\n{\n  if(m_str[m_cur] != '(') return number();\n  m_cur += 1;\n  int n = expression();\n  assert(m_str[m_cur] == ')');\n  m_cur += 1;\n  return n;\n}\n\n//??¬??§????????£?????´?????????????????¨?????????????°???\\\nint CAL::calterm()\n{\n  int a = factor();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = factor();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§????????£?????´???????????????????????????????¨????\nint CAL::cal()\n{\n  int a = calterm();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = calterm();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  queue<int> answer;\n  string str;\n  for(int i = 0; i < N; ++i){\n    cin >> str;\n    CAL a(str);\n    answer.push(a.cal());\n  }\n  while(!answer.empty()){\n    cout << answer.front() << endl;\n    answer.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nusing namespace std;\n\nint expression(State&);\nint term(State&);\nint number(State&);\nint factor(State&);\nvoid consume(State&);\n\n// begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n            << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\t//cout << \"e:\" << *begin << endl;\n\twhile(1) {\n\t\tif(*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = factor(begin);\n\t//cout << \"t:\" << *begin << endl;\n\twhile(1) {\n\t\tif(*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else if(*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\t//cout << \"n:\" << *begin << endl;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\t\n\treturn ret;\n}\n\nint factor(State &begin) {\n\t//cout << \"f:\" << *begin << endl;\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor(int i=0; i<n; ++i) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\t\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint isOP(char z){\n  if(z=='+')return mod+1;\n  if(z=='-')return mod+2;\n  if(z=='*')return mod+3;\n  if(z=='/')return mod+4;\n  return 0;\n}\nint solve(string s){\n  queue<int> Q;\n  int cnt=0,i=0;\n  bool done=false;\n  while(i<s.size()){\n    \n    if('0'<=s[i]&&s[i]<='9'){\n      cnt*=10;\n      cnt+=s[i]-'0';\n      done=true;\n    }\n    else{\n      if(done)Q.push(cnt);\n      done=false;\n      cnt=0;\n    }\n    \n    if(s[i]=='('){\n      int pnt=0,tnt=1;\n      for(int j=i+1;j<s.size();j++){\n\tif(s[j]=='(')tnt++;\n\tif(s[j]==')')tnt--;\n\tif(tnt==0){pnt=j;break;}\n      }\n      Q.push(solve(s.substr(i+1,pnt-i-1)));\n      i=pnt+1;continue;\n    }\n    \n    int tmp=isOP(s[i]);\n    if(tmp>0)Q.push(tmp);\n    \n    i++;\n  }\n  if(done)Q.push(cnt);\n  \n  queue<int> R;\n  int x;\n  while(!Q.empty()){\n    int a=Q.front();Q.pop();\n    if(a==mod+1||a==mod+2){\n      R.push(x);\n      R.push(a);\n    }\n    if(a==mod+3){\n      int b=Q.front();Q.pop();\n      x*=b;\n    }\n    if(a==mod+4){\n      int b=Q.front();Q.pop();\n      x/=b;\n    }\n    if(a<mod) x=a;\n  }\n  R.push(x);\n  \n  x=0;\n  while(!R.empty()){\n    int a=R.front();R.pop();\n    if(a==mod+1){\n      int b=R.front();R.pop();\n      x+=b;\n    }\n    if(a==mod+2){\n      int b=R.front();R.pop();\n      x-=b;\n    }\n    if(a<mod) x=a;\n  }\n  return x;\n}\n\nint main(){\n  int n;cin>>n;\n  lol(i,n){\n    string s;\n    cin>>s;\n    s.pop_back();\n    cout<<solve(s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\ntypedef long long ll;\n\nll expression(State &);\nll term(State &);\nll factor(State &);\nll number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n\n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    ll ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nll expression(State &begin){\n  ll ret=term(begin);\n\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nll term(State &begin){\n  ll ret=number(begin);\n\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nll factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    ll ret=expression(begin);\n    begin++;\nreturn ret;\n  }\n  else return number(begin);\n}\n\nll number(State &begin){\n  ll ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar stk[50], psh[50];\nint v[50],pri[256], sp, pp;\n\nint calc(char *p) {\n  int i;\n  char *exp = p;\n  for (i = 0; i < 256; pri[i++] = 3);   \n  pri['+'] = pri['-'] = 1; pri['*'] = pri['/'] = 2; pri['('] = 4; pri[')'] = 0;\n  stk[0] = 0; pri[0] = -1;\n  sp = pp = 0;\n  while (*p != '\\0') {\n    while (pri[*p] <= pri[stk[sp]] && stk[sp] != '(')psh[++pp] = stk[sp--];\n    if (*p != ')')stk[++sp] = *p;\n    else sp--;\n    p++;\n  }\n  for (i = sp; i > 0; psh[++pp] = stk[i], i--);\n  sp = 0;\n  for (i = 1; i <= pp; i++) {\n    if ('0' <= psh[i] && psh[i] <= '9')v[++sp] = psh[i] - '0';\n    else {\n      switch (psh[i]) {\n      case '+':v[sp - 1] = v[sp - 1] + v[sp];break;\n      case '-':v[sp - 1] = v[sp - 1] - v[sp];break;\n      case '*':v[sp - 1] = v[sp - 1] * v[sp];break;\n      case '/':v[sp - 1] = v[sp - 1] / v[sp];break;\n      }\n      sp--;\n    }\n  }\n  printf(\"%d\\n\",v[1]);\n}\n\nint main() {\n  int i, j, n;\n  char p[50][100];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; scanf(\"%s\", p[i++]));\n  for (i = 0; i < n; i++)\n    for (j = 0; j < 100; j++)\n      if (p[i][j] == '=')p[i][j] = '\\0';\n  for (i = 0; i < n; calc(p[i++]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cctype>\n#include<stack>\n#include<deque>\n#include<map>\n#include<utility>\nusing namespace std;\nint main(void)\n{\n\tmap<char, int> priority;\n\tpriority['*'] = 30;\n\tpriority['/'] = 30;\n\tpriority['+'] = 10;\n\tpriority['-'] = 10;\n\tpriority['('] = 0;\n\tpriority[')'] = 0;\n\tchar str[128], *p,*next;\n\tint v, n;\n\n\tscanf(\"%d\", &n);\n\twhile(n--)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tdeque<pair<char,int> > source;\t\n\t\tstack<char> subStack;\n\n\t\tp = str;\n\t\twhile(*p)\n\t\t{\n\t\t\tif(isdigit(*p))\n\t\t\t{\n\t\t\t\tv = strtol(p, &next, 10);\n\t\t\t\tsource.push_back(make_pair('\\0', v));\n\t\t\t\tp = next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch(*p)\n\t\t\t\t{\n\t\t\t\tcase '(':\n\t\t\t\t\tsubStack.push(*p);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\twhile(subStack.top() != '(')\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.push_back(make_pair(subStack.top(),0));\n\t\t\t\t\t\tsubStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tsubStack.pop();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\t\twhile(!subStack.empty() && priority[*p] <= priority[subStack.top()])\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.push_back(make_pair(subStack.top(),0) );\n\t\t\t\t\t\tsubStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tsubStack.push(*p);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '=':\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t}\n\t\t}\n\t\twhile(!subStack.empty())\n\t\t{\n\t\t\tsource.push_back(make_pair(subStack.top(),0));\n\t\t\tsubStack.pop();\n\t\t}\n\t\tstack<int> s;\n\t\twhile(!source.empty())\n\t\t{\n\t\t\tif(source.front().first)\n\t\t\t{\n\t\t\t\tint lhv, rhv;\n\t\t\t\trhv = s.top();s.pop();\n\t\t\t\tlhv = s.top();s.pop();\n\t\t\t\tswitch(source.front().first)\n\t\t\t\t{\n\t\t\t\tcase '+': s.push(lhv+rhv); break;\n\t\t\t\tcase '-': s.push(lhv-rhv); break;\n\t\t\t\tcase '*': s.push(lhv*rhv); break;\n\t\t\t\tcase '/': s.push(lhv/rhv); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse s.push(source.front().second);\n\t\t\tsource.pop_front();\n\t\t}\n\t\tprintf(\"%d\\n\", s.top());\n\t\ts.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nint number(const string &s, int &k);\nint fact(const string &s, int &k);\nint term(const string &s, int &k);\n\nint expr(const string &s, int &k){\n  int result = term(s,k);\n  while(true){\n    if(s[k]=='+')result += term(s,++k);\n    else if(s[k]=='-')result -= term(s,++k);\n    else break;\n  }\n  return result;\n}\n\nint term(const string &s, int &k){\n  int res = fact(s,k);\n  while(true){\n    if(s[k]=='*')res *= fact(s,++k);\n    else if(s[k]=='/')res /= fact(s,++k);\n    else break;\n  }\n  return res;\n}\n\nint fact(const string &s, int &k){\n  if(s[k]=='('){\n    int res = 0;\n    ++k;\n    res = expr(s,k);\n    k++;\n    return res;\n  }\n  return number(s,k);\n}\n\nint number(const string &s, int &k){\n  int res = 0;\n  while(isdigit(s[k])){\n    res *= 10;\n    res += (int)(s[k++] - '0');\n  }\n  return res;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  while(n--){\n    string s;\n    cin >> s;\n    int k = 0;\n    cout << expr(s, k) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 空白を含む場合の文字列の受け取りはgetline(cin,s)\n// cinとgetlineを同時に使う場合はcinの後にcin.ignore()で空白や改行をスキップしてからgetlineしないと空白を受け取ってしまう\n\ntypedef string::const_iterator S;\nint n;\nstring s;\n\nint number(S &i), term(S &i), expr(S &i), fact(S &i);\n\n// 数字のパース\nint number(S &i) {\n\tint ret = 0;\n\twhile (isdigit(*i)) {\n\t\tret *= 10;\n\t\tret += *i-'0';\n\t\ti++;\n\t}\n\treturn ret;\n}\n\n// 掛け算割り算(または数字単体)のパース\nint term(S &i) {\n\tint ret = fact(i);\n\twhile (1) {\n\t\tif (*i=='*') i++, ret *= fact(i);\n\t\telse if (*i=='/') i++, ret /= fact(i);\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n// termの足し算引き算のパース\nint expr(S &i) {\n\tint ret = term(i);\n\twhile (1) {\n\t\tif (*i=='+') i++, ret += term(i);\n\t\telse if (*i=='-') i++, ret -= term(i);\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n// かっこ付きの式のパース\nint fact(S &i) {\n\tint ret = 0;\n\tif (*i=='(') {\n\t\ti++;\n\t\tret = expr(i);\n\t\ti++;\n\t} else ret = number(i);\n\treturn ret;\n}\n\nsigned main() {\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> s;\n\t\tS beg = s.begin();\n\t\tcout << expr(beg) << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\tif(!op.empty())\n\t\tcalc();\n\t//cout << num.top() << endl;//\n\t//int tmp=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\nusing State = string::const_iterator;\n\n\nint expression(State& begin);\nint term(State& begin);\nint factor(State& begin);\nint number(State& begin);\n\n\nint expression(State& begin){\n\tint ret = term(begin);\n\n\twhile (true){\n\t\tif (*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint term(State& begin){\n\tint ret = factor(begin);\n\n\twhile (true){\n\t\tif (*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint factor(State& begin){\n\tint ret;\n\tif (*begin == '('){\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\n\nint number(State& begin){\n\tint ret = 0;\n\n\twhile (isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tstring expr;\n\n\tcin >> n;\n\tcin.ignore();\n\n\tfor (int i = 0; i < n; i++){\n\t\tgetline(cin, expr);\n\n\t\tState begin = expr.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n  \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n  \n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\ntypedef long double Real;\n#define EPS 1e-13\n#define EQ(x) (-EPS<x && x<EPS)\ntypedef complex<Real> P;\nReal dot(P a,P b){return real(conj(a)*b);}\nReal cross(P a,P b){return imag(conj(a)*b);}\n\n#define MP make_pair<int,int>\n\nstring s;\nint iter;\n\nll dfs();\n\nll dfs2(ll val,int op){\n  ll tmp = 0;\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      if(op) val *= dfs();\n      else val /= dfs();\n    }else if(s[iter]==')' || s[iter]=='=' || s[iter]=='+' || s[iter]=='-'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      --iter;\n      return val;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      op = s[iter]=='*'?1:0;\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nll dfs(){\n  ll val = 0;\n  ll tmp = 0;\n  int op = 1; // op==1?'+':'-'\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      val = op*dfs();\n    }else if(s[iter]==')' || s[iter]=='='){\n      val += op*tmp;\n      tmp = 0;\n      if(s[iter]==')')++iter;\n      return val;\n    }else if(s[iter]=='+'){\n      val += op*tmp;\n      tmp = 0;\n      op = 1;\n    }else if(s[iter]=='-'){\n      val += op*tmp;\n      tmp = 0;\n      op = -1;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      ++iter;\n      val += op*dfs2(tmp,s[iter-1]=='*'?1:0);\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>s;\n    iter = 0;\n    cout<<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\nint p;\n\nint exp(string str);\nint term(string str);\nint fact(string str);\n\nint exp(string str)\n{\n\tint val = term(str);\n\twhile(str[p] == '+' || str[p] == '-'){\n\t\tif(str[p++] == '+'){\n\t\t\tval += term(str);\n\t\t} else {\n\t\t\tval -= term(str);\n\t\t}\n\t}\n\t\n\treturn val;\n}\n\nint term(string str)\n{\n\tint val = fact(str);\n\twhile(str[p] == '*' || str[p] == '/'){\n\t\tif(str[p++] == '*'){\n\t\t\tval *= fact(str);\n\t\t} else {\n\t\t\tval /= fact(str);\n\t\t}\n\t}\n\t\n\treturn val;\n}\n\nint fact(string str)\n{\n\tint val = 0;\n\tif(str[p] == '('){\n\t\tp++;\n\t\tval = exp(str);\n\t\tp++;\n\t} else {\n\t\tstring s = \"\";\n\t\twhile('0' <= str[p] && str[p] <= '9'){\n\t\t\ts += str[p++];\n\t\t}\n\t\tif(s.size() > 0){\n\t\t\tval = atoi(s.c_str());\n\t\t}\n\t}\n\t\n\treturn val;\n}\n\nint main()\n{\n\tint n;\n\tstring str;\n\t\n\twhile(cin >> n && n){\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tp = 0;\n\t\t\tcout << exp(str) << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nstring s;\nint a;\nint num(){\n\tint out=0;\n\twhile(isdigit(s[a])){out*=10;out+=s[a]-'0';a++;}\n\treturn out;\n}\nint func();\nint func2(){\n\tint out=num();\n\twhile(a!=s.size()){\n\t\tif(s[a]=='*'){\n\t\t\ta++;\n\t\t\tif(s[a]=='('){a++;out*=func();}\n\t\t\telse out*=num();\n\t\t}else if(s[a]=='/'){\n\t\t\ta++;\n\t\t\tif(s[a]=='('){a++;out/=func();}\n\t\t\telse out/=num();\n\t\t}else return out;\n\t}\n}\nint func(){\n\tint out=num();\n\twhile(a!=s.size()){\n\t\t//cout<<a<<\" \"<<out<<endl;\n\t\tif(s[a]=='=')return out;\n\t\tif(s[a]==')')return out;\n\t\tif(s[a]=='+'){a++;out+=func2();}\n\t\telse if(s[a]=='-'){a++;out-=func2();}\n\t}\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\ta=0;\n\t\tcin>>s;\n\t\ts=\"0+\"+s;\n\t\tcout<<func()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint cur;\nstring s;\n\nint digit() {\n\treturn ( s[cur++] - '0' );\n}\n\nint number() {\n\tint n = digit();\n\twhile ( isdigit( s[cur] ) )\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint factor() {\n\tint n;\n\tif ( s[cur] == '(' ) {\n\t\tcur++;\n\t\tn = expression();\n\t\tcur++;\n\t} else\n\t\tn = number();\n\treturn n;\n}\n\nint term() {\n\tint n = factor();\n\twhile ( s[cur] == '*' || s[cur] == '/' ) {\n\t\tcur++;\n\t\tif ( s[cur - 1] == '*' )\n\t\t\tn *= factor();\n\t\telse\n\t\t\tn /= factor();\n\t}\n\treturn n;\n}\n\nint expression() {\n\tint n = term();\n\twhile ( s[cur] == '+' || s[cur] == '-' ) {\n\t\tcur++;\n\t\tif ( s[cur - 1] == '+' )\n\t\t\tn += term();\n\t\telse\n\t\t\tn -= term();\n\t}\n\treturn n;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcur = 0;\n\t\tcin >> s;\n\t\tint m = expression();\n\t\tcout << m << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint k,n,ans;\nstring s;\n\nint calc1();\nint calc2();\nint calc3();\n\nint calc1(){\n\tint a;\n\ta=calc2();\n\twhile(s[k]=='+' ||s[k]=='-'){\n\t\tif(s[k]=='+'){\n\t\t\tk++;\n\t\t\ta+=calc2();\n\t\t}else if(s[k]=='-'){\n\t\t\tk++;\n\t\t\ta-=calc2();\n\t\t}\n\t}\n\treturn a;\n}\n\nint calc2(){\n\tint a;\n\ta=calc3();\n\twhile(s[k]=='*' ||s[k]=='/'){\n\t\tif(s[k]=='*'){\n\t\t\tk++;\n\t\t\ta*=calc3();\n\t\t}else if(s[k]=='/'){\n\t\t\tk++;\n\t\t\ta/=calc3();\n\t\t}\n\t}\n\treturn a;\n}\n\nint calc3(){\n\tint a;\n\tif(s[k]=='('){\n\t\tk++;\n\t\ta=calc1();\n\t\tk++;\n\t}else{\n\t\ta=0;\n\t\twhile(s[k]>='0' && s[k]<='9'){\n\t\t\ta*=10;\n\t\t\ta+=s[k]-'0';\n\t\t\tk++;\n\t\t}\n\t}\n\treturn a;\n}\n\nint main(){\n\tcin >> n;\n\twhile(n--){\n\t\tans=0;\n\t\tk=0;\n\t\tcin >> s;\n\t\tans=calc1();\n\t\tcout << ans <<endl;\n\t\ts.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define all(a) (a).begin() ,(a).end()\n\nconst double eps = 1e-10;\nconst double inf = (int)1e8;\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n    int ret = 0;\n    \n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin ++;\n    }\n    return ret;\n}\n\nint term(State & begin){\n    int ret = factor(begin);\n    \n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret = term(begin);\n    \n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n    }else{\n        return number(begin);\n    }\n}\n\nint main(void){\n    int n;\n    string s;\n    cin>>n;\n    getline(cin,s);\n    while(n--){\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint digit() {\n  assert(isdigit(S[cur]));\n  int n = S[cur] - '0'; // ASCII code -> digit\n  cur = cur+1;\n  return n;\n}\n\nint number() {\n  int n = digit();\n  while (cur<S.size() && isdigit(S[cur])) {\n    n = n*10 + digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor() {\n  if (S[cur] != '(') return number();\n  cur += 1;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur += 1;\n  return n;\n}\n\nint term() {\n  int a = factor();\n  while (cur<S.size() && (S[cur]=='*' || S[cur]=='/')) {\n    char op = S[cur++];\n    int b = factor();\n    if (op=='*') a *= b;\n    else a /= b;\n  }\n  return a;\n}\n\nint expression() {\n  int a = term();\n  while (cur<S.size() && (S[cur]=='+' || S[cur]=='-')) {\n    char op = S[cur++];\n    int b = term();\n    if (op == '+') a += b;\n    else a -= b;\n  }\n  return a;\n}\n\n#if 0\nint parse() {return expression();}\n\nint main() {\n  int a = parse();\n  cout << a << endl;\n  assert(a == 4);\n  assert(cur == S.size());\n  return 0;\n}\n#endif\n  \nint main() {\n  int N;\n  cin >> N;\n  for (int i=0; i<N; i++){\n    cur = 0;\n    cin >> S;\n    S.resize(S.size()-1); // delete '='\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1 && !is_all_digit(in[0])) {\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n#include <cassert>\nenum class Type : char {\n\tNum, Pos = '+', Neg = '-', Mul = '*', Div = '/', LP = '(', RP = ')', End = '='\n};\n\nstruct Token {\n\tType type;\n\tdouble num;\n};\n\nclass Expression {\npublic:\n\tExpression(std::istream *s) :is{ s } {};\n\tToken &current() {\n\t\treturn _current;\n\t}\n\tToken get() {\n\t\tchar c;\n\t\tif (!((*is).get(c))) return _current = { Type::End };\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\tcase '/':\n\t\tcase '(':\n\t\tcase ')':return _current = { static_cast<Type>(c) }; break;\n\t\tcase '=':\n\t\tcase '\\n': return _current = { Type::End }; break;\n\t\tdefault:\n\t\t\tif (isdigit(c)) {\n\t\t\t\tstd::string str;\n\t\t\t\tstr.push_back(c);\n\t\t\t\twhile ((*is).get(c)) {\n\t\t\t\t\tif (isdigit(c)) {\n\t\t\t\t\t\tstr.push_back(c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*is).putback(c);\n\t\t\t\t\t\treturn _current = { Type::Num, std::stod(str) };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn _current = { Type::Num, std::stod(str) };\n\t\t\t}\n\t\t\telse throw;\n\t\t}\n\t}\nprivate:\n\tstd::istream *is;\n\tToken _current{ Type::End };\n};\ndouble execute_sub(Expression &, const bool &);\ndouble single_value(Expression &exp, const bool &use_get) {\n\tdouble left;\n\tif (use_get) exp.get();\n\tswitch (exp.current().type) {\n\tcase Type::Num:\n\t\treturn exp.current().num;\n\tcase Type::Neg:\n\t\treturn -single_value(exp, true);\n\tcase Type::LP:\n\t\tleft = execute_sub(exp, true);\n\t\texp.get();\n\t\texp.current() = { Type::Num, left };\n\t\treturn left;\n\tdefault: throw;\n\t}\n}\ndouble execute_pri(Expression &exp, const bool &use_get) {\n\tif (use_get) exp.get();\n\tauto left = single_value(exp, false);\n\tswitch (exp.get().type) {\n\tcase Type::Mul:\n\t\treturn left * execute_pri(exp, true);\n\tcase Type::Div:\n\t\treturn left / execute_pri(exp, true);\n\tdefault:\n\t\treturn left;\n\t}\n}\ndouble execute_sub(Expression &exp, const bool &use_get) {\n\tif (use_get) exp.get();\n\tauto left = execute_pri(exp, false);\n\tswitch (exp.current().type) {\n\tcase Type::Pos:\n\t\treturn left + execute_sub(exp, true);\n\tcase Type::Neg:\n\t\treturn left - execute_sub(exp, true);\n\tdefault:\n\t\treturn left;\n\t}\n}\ndouble execute(Expression &exp) {\n\texp.get();\n\treturn execute_sub(exp, false);\n}\nint main() {\n\tExpression express(&std::cin);\n\tstd::cout << execute(express) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<string>\nusing namespace std;\nint pos;\nstring parse;\n/*\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n*/\n\nint fact();\nint term();\nint expression();\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p = 0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n int term(){\n    int p = fact();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*')pos++,p *= term();\n      else pos++,p /= term();\n    }\n    return p;\n  }\n\n int expression(){\n    int p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+')pos++,p+=term();\n      else pos++,p-=term();\n    }\n    return p;\n  } \n \n/*\n};\n*/\n\n\n\n\n\n\n\nint main(){\n  string s;\n  int N;\n  cin >> N;\n  while(N-- > 0){\n    pos = 0;\n    cin >> parse;\n    //Parsing par = Parsing(s.substr(0,s.length()-1));\n    //cout << par.expression() << endl;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\nusing namespace std;\n\n//????¨???????????¶????????????¨???????????????\nclass CAL{\nprivate:\n  string m_str;\n  size_t m_cur;\n  int digit();\n  int number();\n  int term();\n  int expression();\n  int factor();\n  int calterm();\npublic:\n  CAL(string str);\n  int cal();\n};\n\n//?????????????????????\nCAL::CAL(string str)\n{\n  m_str = str;\n  m_cur = 0;\n  m_str.resize(m_str.size() - 1);\n}\n\n//??????????????°????????°????????????\nint CAL::digit()\n{\n  assert(isdigit(m_str[m_cur]));\n  int n = m_str[m_cur++] - '0';\n  return n;\n}\n\n//??°??????????????¨?????¨???????????°??????????????????\nint CAL::number()\n{\n  int n = digit();\n  while(m_cur < m_str.size() && isdigit(m_str[m_cur]))\n    n = n*10 + digit();\n  return n;\n}\n\n//???????????¨?????????????°???\\\nint CAL::term()\n{\n  int a = number();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = number();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????????\nint CAL::expression()\n{\n  int a = term();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = term();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????°?????¨?????????????????????number()??????????????????\nint CAL::factor()\n{\n  if(m_str[m_cur] != '(') return number();\n  m_cur += 1;\n  int n = expression();\n  assert(m_str[m_cur] == ')');\n  m_cur += 1;\n  return n;\n}\n\n//??¬??§????????£?????´?????????????????¨?????????????°???\\\nint CAL::calterm()\n{\n  int a = factor();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = factor();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§????????£?????´???????????????????????????????¨????\nint CAL::cal()\n{\n  int a = calterm();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = calterm();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  queue<int> answer;\n  string str;\n  for(int i = 0; i < N; ++i){\n    cin >> str;\n    CAL a(str);\n    answer.push(a.cal());\n  }\n  while(!answer.empty()){\n    cout << answer.front() << endl;\n    answer.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nclass Parser{\n    public:\n\n    string s;\n    int i, n;\n\n    Parser(string s): s(s) {}\n\n    int parse(){\n        i = 0;\n        n = s.length();\n        return expr();\n    }\n\n    private:\n\n    int expr(){\n        int ret = term();\n        while(s[i] != '='){\n            if(s[i] == '+'){\n                i++;\n                ret += term();\n            }else if(s[i] == '-'){\n                i++;\n                ret -= term();\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int term(){\n        int ret = fac();\n        while(i < n){\n            if(s[i] == '*'){\n                i++;\n                ret *= fac();\n            }else if(s[i] == '/'){\n                i++;\n                ret /= fac();\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int fac(){\n        if(isdigit(s[i])) return num();\n        i++;\n        int ret = expr();\n        // int ret = num();\n        // while(s[i] != ')'){\n        //     if(s[i] == '+'){\n        //         i++;\n        //         ret += num();\n        //     }else if(s[i] =='-'){\n        //         i++;\n        //         ret -= num();\n        //     }else{\n        //         break;\n        //     }\n        // }\n        i++;\n        return ret;\n    }\n\n    int num(){\n        int ret = s[i] - '0';\n        i++;\n        while(isdigit(s[i])){\n            ret = ret * 10 + (s[i] - '0');\n            i++;\n        }\n        return ret;\n    }\n\n};\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        string s;\n        cin >> s;\n        Parser p = Parser(s);\n        cout << p.parse() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\nusing namespace std;\n\n//????¨???????????¶????????????¨???????????????\nclass CAL{\nprivate:\n  string m_str;\n  size_t m_cur;\n  int digit();\n  int number();\n  int term();\n  int factor();\npublic:\n  CAL(string str);\n  int expression();\n};\n\n//?????????????????????\nCAL::CAL(string str):\n  m_str(str),m_cur(0)\n{\n  m_str.resize(m_str.size() - 1);\n}\n\n//??????????????°????????°????????????\nint CAL::digit()\n{\n  assert(isdigit(m_str[m_cur]));\n  int n = m_str[m_cur++] - '0';\n  return n;\n}\n\n//??°??????????????¨?????¨???????????°?????¨????????????\nint CAL::number()\n{\n  int n = digit();\n  while(m_cur < m_str.size() && isdigit(m_str[m_cur]))\n    n = n*10 + digit();\n  return n;\n}\n\n//???????????¨?????????????°???\\\nint CAL::term()\n{\n  int a = factor();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = factor();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????°?????¨?????????????????????number()??????????????????\nint CAL::factor()\n{\n  if(m_str[m_cur] != '(') return number();\n  m_cur += 1;\n  int n = expression();\n  assert(m_str[m_cur] == ')');\n  m_cur += 1;\n  return n;\n}\n\n//??????????¨?\nint CAL::expression()\n{\n  int a = term();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = term();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\nint main()\n{\n  int N;\n  cin >> N;//???????????°\n  queue<int> answer;//???????????\\?????????\n  string str;\n  for(int i = 0; i < N; ++i){\n    cin >> str;//????????£??\\\n    CAL a(str);\n    answer.push(a.expression());\n  }\n  while(!answer.empty()){\n    cout << answer.front() << endl;\n    answer.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<string>\nusing namespace std;\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p=0;\n     \n      while('0' <= parse[pos] && parse[pos] <= '9'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n int term(){\n    int p = fact();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){pos++;p *= fact();}\n      else {pos++;p /= fact();}\n    }\n    return p;\n  }\n\n int expression(){\n    int p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else {pos++;p-=term();}\n    }\n    return p;\n  } \n \n\n};\n\n\n\n\n\n\n\n\nint main(){\n  string s;\n  int N;\n  cin >> N;\n  while(N-- > 0){\n \n    cin >> s;\n   \n    Parsing par = Parsing(s.substr(0,s.length()-1));\n    cout << par.expression() << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n\nconst char *p;\nclass ParseError {};\n\nint expression();\nint term();\nint factor();\nvoid consume(char);\n\nint main() {\n  using namespace std;\n\n  int n;\n  string str;\n  int ans;\n\n  cin >> n;\n  cin.ignore();\n  for(int i = 0; i < n; i++) {\n    getline(cin, str);\n    p = str.c_str();\n    ans = expression();\n    consume('=');\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n\nvoid consume(char expected) {\n  if(*p == expected) {\n    p++;\n  } else {\n    std::cerr << \"Expected '\" << expected << \"' but got '\" << *p << \"'\" << std::endl;\n    std::cerr << \"Rest string is '\";\n    while(*p) {\n      std::cerr << *p++;\n    }\n    std::cerr << \"'\" << std::endl;\n    throw ParseError();\n  }\n}\n\nint factor() {\n  int ret;\n  char *e;\n  \n  if(*p == '(') {\n    consume('(');\n    ret = expression();\n    consume(')');\n  } else {\n    ret = strtol(p, &e, 10);\n    p = e;\n  }\n  \n  return ret;\n}\n\nint term() {\n  int ret = factor();\n  \n  for(;;) {\n    if(*p == '*') {\n      p++;\n      ret *= factor();\n    } else if (*p == '/') {\n      p++;\n      ret /= factor();\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint expression() {\n  int ret = term();\n  \n  for(;;) {\n    if(*p == '+') {\n      p++;\n      ret += term();\n    } else if (*p == '-') {\n      p++;\n      ret -= term();\n    } else {\n      break;\n    }\n  }\n  \n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\ntypedef long long ll;\n\n\nint lp;\nint lpcnt = 0;\n\n\nstring str;\n\nbool input(){\n\n  if(lpcnt==0)cin>>lp;\n\n  if(lpcnt==lp)return false;\n  cin>>str;\n\n  lpcnt++;\n  return true;\n}\n\n\nclass S{\npublic:\n  bool isnum;\n  bool isc;\n  char c;\n  int num;\n  S(bool isnum, bool isc, char c, int num):isnum(isnum),isc(isc),c(c),num(num){}\n  S(){isnum=isc=false; c='#'; num=0;}\n  void print(){\n    printf(\"%d %d %d %c\\n\",isnum,isc,num,c);\n  }\n};\n\ntypedef pair<int,string> pis;\ntypedef pair<char,string> pcs;\n\nbool isnum(char c){\n  return '0'<=c && c<='9';\n}\n\nint ctonum(char c){\n  return c-'0';\n}\n\npis getHeadNum(string str){\n\n  pis ret = pis(0,\"\");\n  int st = 0;\n  while(str.size()!=st && isnum(str[st])){\n    ret.first *= 10;\n    ret.first += ctonum(str[st]);\n    st++;\n  }\n\n  ret.second = str.substr(st);\n  return ret;\n}\n\npcs getHeadChar(string str){\n  return pcs(str[0], str.substr(1));\n}\n\nbool iscalc(char c){\n  if(c=='*' || c=='+' || c=='-' || c=='/')return true;\n  return false;\n}\n\n\nvector<S> getEq(string str){\n  vector<S> eq;\n  string sc = str;\n  eq.clear();\n\n  while(sc.size()!=0){\n    int hu = 1;\n    S add;\n    if(sc[0]=='-' && ((eq.size()!=0 && iscalc(eq[eq.size()-1].c))||eq.size()==0)){\n      hu = -1;\n      sc = sc.substr(1);\n    }\n    if(isnum(sc[0])){\n      add.isnum = true;\n      pis res = getHeadNum(sc);\n      add.num = hu*res.first;\n      sc = res.second;\n    }else{\n      add.isc = true;\n      pcs res = getHeadChar(sc);\n      add.c = res.first;\n      sc = res.second;\n    }\n    eq.push_back(add);\n  }\n  return eq;\n}\n\nint calc(int st, int en, vector<S>& eq){\n  \n  \n  /*\n  for(int i=st;i<en;i++){\n    eq[i].print();\n  }puts(\"\");\n  */\n\n\n\n  if(st>=en){\n    printf(\"%d %d\\n\",st,en);\n    assert(0);\n  }\n\n  int num = eq[st].num;\n  if(st+1==en)return num;\n  int a=0;\n\n  for(int i=en-1;i>=st;i--){\n\n    if(eq[i].c=='(')a++;\n    if(eq[i].c==')')a--;\n\n\n    if(a==0){\n      if(eq[i].c=='-'){\n\treturn calc(st, i, eq) - calc(i+1, en, eq);\n      }\n      if(eq[i].c=='+'){\n\treturn calc(st, i, eq) + calc(i+1, en, eq);\n      }\n    }\n\n  }\n\n  a=0;\n\n  for(int i=en-1;i>=st;i--){\n\n    if(eq[i].c=='(')a++;\n    if(eq[i].c==')')a--;\n    if(a==0){\n      if(eq[i].c=='*'){\n\treturn calc(st, i, eq) * calc(i+1, en, eq);\n      }\n      if(eq[i].c=='/'){\n\treturn calc(st, i, eq) / calc(i+1, en, eq);\n      }\n    }\n\n  }\n\n  if(eq[st].c=='('){\n    return calc(st+1, en-1, eq);\n  }\n  puts(\"AAA\");\n  assert(0);\n  return -1;\n  \n}\nint solve(){\n  vector<S> eq = getEq(str);\n  return calc(0,eq.size()-1, eq);\n}\n\nint main(){\n  while(input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        s[0] = '\\0';\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0'; //????°????=?????????\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\nint cur = 0;\nstring S;\nint expression();\nint term();\nint factor();\nint main() {\n  int times;\n  cin >>times;\n  for(int i = 0 ; i < times; i++){\n      cin >> S;\n      cur = 0;\n      S.resize(S.size()-1);\n      cout << expression() <<endl;\n  }\n\n}\nint digit() {\n  assert(isdigit(S[cur]));\n  int n = S[cur] -'0';\n  cur = cur+1;\n  return n;\n}\nint number() {\n  int n = digit();\n  while(cur <S.size() && isdigit(S[cur])){\n      n = n*10 + digit();\n  }\n  return n;\n}\nint expression() {\n  int sum = term();\n  while (S[cur] == '+' || S[cur] == '-'){\n    char op = S[cur];\n    cur +=1;\n    int b = term();\n    if(op ==  '+') sum +=b;\n    else sum -= b;\n  }\n  return sum;\n}\nint term() {\n  int a = factor();\n  while(cur < S.size()\n        && (S[cur] == '*' || S[cur] == '/')){\n          char op = S[cur];\n          cur +=1;\n          int b = factor();\n          if(op == '*') a *=b;\n          else a/=b;\n        }\n  return a;\n}\nint factor() {\n  if(S[cur] != '(' ) return number();\n  cur +=1;\n  int n =expression();\n  assert(S[cur] == ')');\n  cur +=1;\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint Num();\nint Fact();\nint Term();\nint Exp();\n\nint ite;\nstring s;\n\nint Num() {\n\tint res = 0;\n\twhile (isdigit(s[ite])) {\n\t\tres = res * 10 + s[ite] - '0';\n\t\tite++;\n\t}\n\treturn res;\n}\n\nint Fact() {\n\tif (s[ite] == '(') {\n\t\tite++;\n\t\tint res = Exp();\n\t\tite++;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn Num();\n\t}\n}\n\nint Term() {\n\tint res = Fact();\n\twhile (true) {\n\t\tif (s[ite] == '*') {\n\t\t\tite++;\n\t\t\tres *= Fact();\n\t\t}\n\t\telse if (s[ite] == '/') {\n\t\t\tite++;\n\t\t\tres /= Fact();\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint Exp() {\n\tint res = Term();\n\twhile (s[ite] != '=' && s[ite] != ')') {\n\t\tif (s[ite] == '+') {\n\t\t\tite++;\n\t\t\tres += Term();\n\t\t}\n\t\telse if(s[ite] == '-') {\n\t\t\tite++;\n\t\t\tres -= Term();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> s;\n\t\tite = 0;\n\t\tcout << Exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "gets;$<.each_line.map{|s|p eval(s[0..-3])}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n  \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n  \n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\ntypedef long double Real;\n#define EPS 1e-13\n#define EQ(x) (-EPS<x && x<EPS)\ntypedef complex<Real> P;\nReal dot(P a,P b){return real(conj(a)*b);}\nReal cross(P a,P b){return imag(conj(a)*b);}\n\n#define MP make_pair<int,int>\n\nstring s;\nint iter;\n\nll dfs();\n\nll dfs2(ll val,int op){\n  ll tmp = 0;\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      if(op) val *= dfs();\n      else val /= dfs();\n    }else if(s[iter]==')' || s[iter]=='=' || s[iter]=='+' || s[iter]=='-'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      --iter;\n      return val;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      op = s[iter]=='*'?1:0;\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nll dfs(){\n  ll val = 0;\n  ll tmp = 0;\n  int op = 1; // op==1?'+':'-'\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      val = op*dfs();\n    }else if(s[iter]==')' || s[iter]=='='){\n      val += op*tmp;\n      tmp = 0;\n      if(s[iter]==')')++iter;\n      return val;\n    }else if(s[iter]=='+'){\n      val += op*tmp;\n      tmp = 0;\n      op = 1;\n    }else if(s[iter]=='-'){\n      val += op*tmp;\n      tmp = 0;\n      op = -1;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      ++iter;\n      val += op*dfs2(tmp,s[iter-1]=='*'?1:0);\n      tmp = 0;\n    }\n    ++iter;\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>s;\n    iter = 0;\n    cout<<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<stack>\n#include<cstdlib>\n#include<iostream>\nusing namespace std;\n\nconst int obracket\t=-1;\nconst int sum\t\t=0;\nconst int diff\t\t=1;\nconst int multi\t\t=2;\nconst int divide\t=3;\n\nstack<double> operands;\nstack<int> operators;\n\nint evaluate(string& expression);\nint calc(int a,int b,int op);\n\nint main()\n{\n\tstring str;\n\tint i,n;\n\n\tcin>>n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tcin>>str;\n\t\tcout<<evaluate(str)<<endl;\n\t}\n\treturn 0;\n}\n\nint evaluate(string& expression)\n{\n\tint i,n,numstart;\n\tbool innum=false;\n\tint a,b;\n\tchar temp;\n\n\twhile(!operands.empty())operands.pop();\n\twhile(!operators.empty())operators.pop();\n\n\tfor(i=0;expression[i]!='=';i++)\n\t{\n\t\ttemp=expression[i];\n\t\tif(isdigit(temp)||temp=='.')\n\t\t{\n\t\t\tif(!innum)\n\t\t\t{\n\t\t\t\tinnum=true;\n\t\t\t\tnumstart=i;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(innum)\n\t\t\t{\n\t\t\t\tinnum=false;\n\t\t\t\toperands.push(atof(expression.substr(numstart,i-numstart).c_str()));\n\t\t\t}\n\t\t\tswitch(temp)\n\t\t\t{\n\t\t\t\tcase '(':\n\t\t\t\t\toperators.push(obracket);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\twhile(operators.top()!=obracket)\n\t\t\t\t\t{\n\t\t\t\t\t\tb=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\ta=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\toperands.push(calc(a,b,operators.top()));\n\t\t\t\t\t\toperators.pop();\n\t\t\t\t\t}\n\t\t\t\t\toperators.pop();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\twhile(!operators.empty() && operators.top()!=obracket)\n\t\t\t\t\t{\n\t\t\t\t\t\tb=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\ta=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\toperands.push(calc(a,b,operators.top()));\n\t\t\t\t\t\toperators.pop();\n\t\t\t\t\t}\n\t\t\t\t\toperators.push(sum);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif(i==0||expression.at(i-1)=='(')\n\t\t\t\t\t{\n\t\t\t\t\t\toperands.push(0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(!operators.empty() && operators.top()!=obracket)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb=operands.top();\n\t\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\t\ta=operands.top();\n\t\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\t\toperands.push(calc(a,b,operators.top()));\n\t\t\t\t\t\t\toperators.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperators.push(diff);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\twhile(!operators.empty() && operators.top()>=multi)\n\t\t\t\t\t{\n\t\t\t\t\t\tb=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\ta=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\toperands.push(calc(a,b,operators.top()));\n\t\t\t\t\t\toperators.pop();\n\t\t\t\t\t}\n\t\t\t\t\toperators.push(multi);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\twhile(!operators.empty() && operators.top()>=multi)\n\t\t\t\t\t{\n\t\t\t\t\t\tb=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\ta=operands.top();\n\t\t\t\t\t\toperands.pop();\n\t\t\t\t\t\toperands.push(calc(a,b,operators.top()));\n\t\t\t\t\t\toperators.pop();\n\t\t\t\t\t}\n\t\t\t\t\toperators.push(divide);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(innum)operands.push(atof(expression.substr(numstart,i-numstart).c_str()));\n\twhile(!operators.empty())\n\t{\n\t\tb=operands.top();\n\t\toperands.pop();\n\t\ta=operands.top();\n\t\toperands.pop();\n\t\toperands.push(calc(a,b,operators.top()));\n\t\toperators.pop();\n\t}\n\treturn operands.top();\n}\n\nint calc(int a,int b,int op)\n{\n\tswitch(op)\n\t{\n\t\tcase sum:\n\t\t\treturn a+b;\n\t\t\tbreak;\n\t\tcase diff:\n\t\t\treturn a-b;\n\t\t\tbreak;\n\t\tcase multi:\n\t\t\treturn a*b;\n\t\t\tbreak;\n\t\tcase divide:\n\t\t\treturn a/b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n#include <cassert>\nenum class Type : char {\n\tNum, Pos = '+', Neg = '-', Mul = '*', Div = '/', LP = '(', RP = ')', End = '='\n};\n\nstruct Token {\n\tType type;\n\tint num;\n};\n\nclass Expression {\npublic:\n\tExpression(std::istream *s) :is{ s } {};\n\tToken &current() {\n\t\treturn _current;\n\t}\n\tToken get() {\n\t\tchar c;\n\t\tif (!((*is).get(c))) return _current = { Type::End };\n\t\tswitch (c) {\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\tcase '/':\n\t\tcase '(':\n\t\tcase ')':return _current = { static_cast<Type>(c) }; break;\n\t\tcase '=':\n\t\tcase '\\n': return _current = { Type::End }; break;\n\t\tdefault:\n\t\t\tif (isdigit(c)) {\n\t\t\t\tstd::string str;\n\t\t\t\tstr.push_back(c);\n\t\t\t\twhile ((*is).get(c)) {\n\t\t\t\t\tif (isdigit(c)) {\n\t\t\t\t\t\tstr.push_back(c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t(*is).putback(c);\n\t\t\t\t\t\treturn _current = { Type::Num, std::stoi(str) };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn _current = { Type::Num, std::stoi(str) };\n\t\t\t}\n\t\t\telse throw;\n\t\t}\n\t}\nprivate:\n\tstd::istream *is;\n\tToken _current{ Type::End };\n};\nint cul_sub_express(Expression &, const bool &);\nint cul_value(Expression &exp, const bool &use_get) {\n\tif (use_get) exp.get(); //?????????????£???°???\n\tint mid;\n\tswitch (exp.current().type) {\n\tcase Type::Num: return exp.current().num;\n\tcase Type::Neg: \n\t\tmid = cul_sub_express(exp, true);\n\t\treturn exp.current().num = -mid;\n\tcase Type::LP:\n\t\tmid = cul_sub_express(exp, true);\n\t\texp.current() = { Type::Num, mid };\n\t\treturn mid;\n\t}\n}\nint cul_pri_express(Expression &exp, const bool &use_get) {\n\tif (use_get) exp.get();\n\tauto left = cul_value(exp, false);\n\tswitch (exp.get().type) {\n\tcase Type::Mul:\n\t\tleft *= cul_value(exp, true);\n\t\texp.current().num = left;\n\t\treturn cul_pri_express(exp, false);\n\tcase Type::Div:\n\t\tleft /= cul_value(exp, true);\n\t\texp.current().num = left;\n\t\treturn cul_pri_express(exp, false);\n\tdefault:\n\t\treturn left;\n\t}\n}\nint cul_sub_express(Expression &exp, const bool &use_get) {\n\tif (use_get) exp.get();\n\tauto left = cul_pri_express(exp, false);\n\tswitch (exp.current().type) {\n\tcase Type::Pos:\n\t\tleft += cul_pri_express(exp, true);\n\t\treturn exp.current().num = left;\n\tcase Type::Neg:\n\t\tleft -= cul_pri_express(exp, true);\n\t\treturn exp.current().num = left;\n\tdefault:\n\t\treturn left;\n\t}\n}\nint execute(Expression &exp) {\n\treturn cul_sub_express(exp, true);\n}\nint main() {\n\tExpression express(&std::cin);\n\tstd::cout << execute(express) << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???2:negFLG?°???\\???\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work,count,work2;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\n\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && OP.top() == '*'){\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork *= work2;\n\t\t\t\t\t}else if(OP.empty() == false &&OP.top() == '/'){\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork = work2/work;\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nlong calc2(char *eq){\n\tlong c=0, sign[100]={0};\n\tdouble num[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn (int)num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nvoid select_cal(char c, int *tmp, int val){\n\n\tif(c == '+') *tmp += val;\n\telse if(c == '-') *tmp -= val;\n\telse if(c == '*') *tmp = floor(*tmp * val);\n\telse if(c == '/' && val != 0) *tmp = floor(*tmp / val);\n\n}\n\nint calculation(string str, int len, int begin){\n\n\tint ans, tmp, cnt, val;\n\tchar c;\n\t\n\tans = 0;\n\ttmp = 0;\n\tc = '+';\n\n\tfor(int i=begin; i<len; i++){\n\t\tif(str[i] == '+' || str[i] == '-'){\n\t\t\tans += tmp;\n\t\t\ttmp = 0;\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '*' || str[i] == '/'){\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '('){\n\t\t\tselect_cal(c, &tmp, calculation(str, len, i+1));\n\t\t\tcnt = 1;\n\t\t\tdo{\n\t\t\t\ti++;\n\t\t\t\tif(str[i] == '(') cnt++;\n\t\t\t\telse if(str[i] == ')') cnt--;\n\t\t\t}while(cnt != 0);\n\t\t}\n\t\telse if(str[i] == ')' || str[i] == '='){\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcnt = 1;\n\t\t\twhile(str[i+cnt] >= '0' && str[i+cnt] <= '9'){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tval = 0;\n\t\t\tfor(int j=0; j<cnt; j++){\n\t\t\t\tval += (str[i+cnt-j-1] - '0') * pow(10, j);\n\t\t\t}\n\t\t\tselect_cal(c, &tmp, val);\n\t\t\ti += cnt - 1;\n\t\t}\n\t}\n\tans += tmp;\n\n\treturn ans;\n\n}\n\nint main(){\n\n\tint n;\n\tstring str;\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> str;\n\t\tcout << calculation(str, str.length(), 0) << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHokudai Practice Contest 2014\nC - Smart Calculator\n\nティツァツ」テヲツウツ陛ッツシツ堙ヲツァツ凝ヲツ鳴?ィツァツ」テヲツ楪?\nテ・ツ?クテ・ツ楪凝ァツ堋?」ツ?ェテヲツァツ凝ヲツ鳴?ィツァツ」テヲツ楪静・ツ閉湘ゥツ。ツ古」ツ??\nテ」ツ?陛」ツ?セテ」ツ?姪」ツ?セテ」ツ?ェテヲツ可凝ヲツウツ陛」ツ?古ィツ?ε」ツ?暗」ツつ嘉」ツつ古」ツつ凝」ツ?古ゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝・ツ?催・ツクツーテァツ堋?・ツ?ヲテァツ青?」ツつ津ィツ。ツ古」ツ??ヲツ鳴ケテヲツウツ陛」ツ?古ァツーツ。テ・ツ債佚」ツ?ァテ」ツ?づ」ツつ凝」ツ??\nテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテァツュツ氾」ツ?暗」ツつ津ィツィツ暗ァツョツ療」ツ?凖」ツつ凝ゥツ鳴「テヲツ閉ーテ」ツつ津ァツ板ィテヲツ?湘」ツ?療」ツ?ヲテ」ツ??)テ」ツ?ォテ・ツ崢イテ」ツつ湘」ツつ古」ツ?淌ゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ョティツィツ暗ァツョツ療」ツつ津・ツ?催・ツクツーテ」ツ?ァテヲツアツづ」ツつ?」ツつ凝」ツ??\n\n1テ・ツコツヲテ」ツ?ョテ・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療」ツ?ョテ・ツ?ヲテァツ青?ヲツ卍づゥツ鳴禿」ツ?ッO(n)テ」ツ?ァテ」ツ?づ」ツつ凝」ツ??\n()テ」ツ?ョテ」ツδ堙」ツつ「テ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療」ツ?古ィツ。ツ古」ツつ湘」ツつ古」ツつ凝」ツ?ョテ」ツ?ァテ」ツ??・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療」ツ?ョテヲツ閉ーテ」ツつづ」ツ?セテ」ツ?欅(n)テ」ツ?ァテ」ツ?づ」ツつ凝」ツ??\nテ」ツつ暗」ツ?」テ」ツ?ヲテ」ツ??ヲツ卍づゥツ鳴禿ィツィツ暗ァツョツ療ゥツ?湘」ツ?ッO(n^2)テ」ツ?ァテ」ツ?づ」ツつ凝」ツ??\n*/\n\n#include<iostream>\n#include<string>\nusing namespace std;\n\n//テヲツ鳴?・ツュツ療・ツ按療」ツつ津」ツつーテ」ツδュテ」ツδシテ」ツδ静」ツδォテ・ツ、ツ嘉ヲツ閉ーテ」ツ?ォテァツスツョテ」ツ?催」ツ??ヲツ鳴?・ツュツ療」ツ?ョテゥツ鳴凝・ツァツ凝、ツスツ催ァツスツョテ」ツ?ィテァツオツづ、ツコツ?、ツスツ催ァツスツョテ」ツつ津ゥツ鳴「テヲツ閉ーテ」ツ?ォテ、ツクツ偲」ツ?暗」ツつ凝」ツ?禿」ツ?ィテ」ツ?ァテ」ツ??\n//テゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツつ津ゥツ鳴「テヲツ閉ーテ」ツ?ォテヲツクツ。テ」ツ?凖」ツ?ョテ」ツ?ィテ・ツ青古ァツュツ嘉」ツ?ョテ・ツ?ヲテァツ青?」ツ?古」ツ?ァテ」ツ?催」ツつ?\nstring s;\n\n//テゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按耀[l,r)テ」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝・ツ?催・ツクツーテァツ堋?」ツ?ェテヲツァツ凝ヲツ鳴?ィツァツ」テヲツ楪?\n//lテヲツ鳴?・ツュツ療ァツ崢ョテ」ツ?凝」ツつ嘉・ツァツ凝」ツ?セテ」ツつ甘」ツ?〉-1テヲツ鳴?・ツュツ療ァツ崢ョテ」ツ?ァテァツオツづ」ツつ湘」ツつ凝・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴禿」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?禿」ツ?ィテ」ツ?ォテヲツウツィテヲツ??\n//(テ・ツ個コテゥツ鳴禿」ツつ津ヲツ可アテ」ツ??ヲツ卍づ」ツ?ッテ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴禿」ツ??」ツ?ィテゥツδステ・ツ青暗」ツ?古」ツつ暗」ツ??」ツ?禿」ツ?ィテ」ツ?古・ツ、ツ堙」ツ?湘」ツ?，++ STLテ」ツ?ァテ」ツつづ・ツ、ツ堙」ツ?湘」ツ?ョテ・ツ?エテ・ツ青暗」ツ?敕」ツ??」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ?\nint parse(int l, int r){\n  //テ・ツ?催・ツクツーテ・ツ?ヲテァツ青?・ツ??」ツ?ァテ」ツ?ッテ」ツ??・ツ?ェテ・ツ?暗ゥツ??、ツスツ催」ツ?ョテ、ツスツ偲」ツ??ィツィツ暗ァツョツ療」ツ?凝」ツつ嘉・ツ?暗」ツ?ォティツィツ佚ィツソツーテ」ツ?凖」ツつ?\n  //テ」ツ?ェテ」ツ?愿」ツ?ェテ」ツつ嘉」ツ??・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療・ツ?暗」ツ?ョティツィツ暗ァツョツ療」ツ?ョテヲツ鳴ケテ」ツ?古・ツ?ェテ・ツ?暗ァツ堋?」ツ?ォティツ。ツ古」ツつ湘」ツつ古」ツつ凝」ツ?凝」ツつ嘉」ツ?ァテ」ツ?づ」ツつ?\n  //テ」ツつ暗」ツ?」テ」ツ?ヲテ」ツ??+-\"->\"*/\"->\"()\"->\"テヲツ閉ーテ・ツュツ?テ」ツ?ョテゥツ??」ツ?ォティツィツ佚ィツソツーテ」ツ?凖」ツつ?\n\n  //k:テゥツ鳴嘉」ツ?佚ヲツ仰ャテ・ツシツァテ」ツ?ョテヲツ閉ーテ」ツ?ョテ」ツつォテ」ツつヲテ」ツδウテ」ツつソテ」ツ?Ｌ=0テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ??・ツョツ古・ツ?ィテ」ツ?ォテヲツ仰ャテ・ツシツァテ」ツ?古ゥツ鳴嘉」ツ?佚」ツ?ヲテ」ツ??」ツつ?\n  int k = 0;\n\n  //+,-テ」ツ?ョテ・ツ?ヲテァツ青?\n  //テ・ツ?ェテ・ツ?暗ゥツ??、ツスツ催」ツ?ョテ、ツスツ偲」ツ??ィツィツ暗ァツョツ療」ツ?凝」ツつ嘉・ツ?暗」ツ?ォテ・ツ?ヲテァツ青?」ツ?凖」ツつ凝」ツ?淌」ツつ?」ツ??」ツδォテ」ツδシテ」ツδ療」ツ?ョテヲツ鳴ケテ・ツ青妥」ツつづゥツ卍催ゥツ??」ツ?ォテ」ツ?凖」ツつ?\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')k++;\n    if(s[i] == '(')k--;\n    //テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴禿」ツ?ォテ」ツ?ェテ」ツつ凝」ツつ暗」ツ??」ツ?ォiテ」ツつ暗」ツつ甘・ツキツヲテ」ツ?ィテ・ツ渉ウテ」ツ?ョテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ォテ・ツ按?」ツ?妥」ツつ凝」ツ?づヲツキツサテ・ツュツ療」ツδ淌」ツつケテ」ツつ津」ツ?療」ツつ?」ツ?凖」ツ??」ツ?ョテ」ツ?ァテヲツーツ療」ツつ津」ツ?、テ」ツ?妥」ツつ凝」ツ??\n    if(!k && s[i] == '+')return parse(l,i) + parse(i+1,r);\n    if(!k && s[i] == '-')return parse(l,i) - parse(i+1,r);\n  }\n\n  //*,/テ」ツ?ョテ・ツ?ヲテァツ青?\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')k++;\n    if(s[i] == '(')k--;\n    if(!k && s[i] == '*')return parse(l,i) * parse(i+1,r);\n    if(!k && s[i] == '/')return parse(l,i) / parse(i+1,r);\n  }\n\n  //()テ」ツ?ョテ・ツ?ヲテァツ青?\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n\n  //テゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?古ヲツ閉ーテ・ツュツ療」ツ?ョテ」ツ?ソテ」ツ?凝」ツつ嘉」ツ?ェテ」ツつ凝・ツ?エテ・ツ青?\n  //stoi(string)テ」ツ?ッstringテ・ツ楪凝」ツ?ァティツ。ツィテ」ツ?陛」ツつ古」ツ?淌ヲツ閉ーテ・ツュツ療」ツつ段ntテ・ツ楪凝」ツ?ォテ・ツ、ツ嘉ヲツ渉崚」ツ?凖」ツつ凝」ツ??++11テ」ツ?凝」ツつ鋭tringテ」ツδ佚」ツδε」ツδ?」ツ?ォテ・ツ?・テ」ツ?」テ」ツ?淌」ツ??\n  return stoi( s.substr(l,r-l) );\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t//\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] > order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t//\t\tcalc();\n\t//\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tif(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\n\tif(op.size()>=2){\n\t\tchar op1,op2;\n\t\top1=op.top();op.pop();op2=op.top();\n\t\top.push(op1);\n\t\tif(order[op1]<order[op2])\n\t\t\tcalc();\n\t}\n\t//cout << num.top() << endl;//\n\t//int tmp1=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//int tmp2=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp2);\n\t//num.push(tmp1);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-6;\ndouble add(double a,double b){\n    if(abs(a+b)<eps)return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\n    vector<int>ans;\n    while(cin>>n,n!=0){\n        P a[n];\n        double r[n];\n        rep(i,n)cin>>a[i].first>>a[i].second>>r[i];\n        P b[n-1][2];\n        rep(i,n-1){\n            P v=(a[i+1]-a[i])*(1.0/d(a[i+1],a[i]));\n            P h={v.second,-v.first};\n            double l=(r[i]*r[i]+d(a[i],a[i+1])*d(a[i],a[i+1])-r[i+1]*r[i+1])/2/d(a[i],a[i+1]);\n            b[i][0]=a[i]+v*l+h*sqrt(r[i]*r[i]-l*l);\n            b[i][1]=a[i]+v*l-h*sqrt(r[i]*r[i]-l*l);\n        }\n        double x[2*n][2*n];\n        rep(i,2*n)rep(j,2*n)x[i][j]=inf;\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            rep(k,i)if(!cross(a[0],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[0][2*i+j+1]=d(a[0],b[i][j]);\n        }\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            REP(k,i+1,n-1)if(!cross(a[n-1],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[2*n-1][2*i+j+1]=d(a[n-1],b[i][j]);\n        }\n        rep(i,n-1)REP(j,i+1,n-1)rep(k,2)rep(l,2){\n            bool ok=true;\n            REP(m,i+1,j)if(!cross(b[i][k],b[j][l],b[m][0],b[m][1]))ok=false;\n            if(ok)x[2*i+k+1][2*j+l+1]=d(b[i][k],b[j][l]);\n        }\n        bool ok=true;\n        rep(i,n-1)if(!cross(a[0],a[n-1],b[i][0],b[i][1]))ok=false;\n        if(ok)x[0][2*n-1]=d(a[0],a[n-1]);\n        rep(i,2*n)x[i][i]=0;\n        rep(i,n)x[2*i+1][2*i+2]=d(b[i][0],b[i][1]);\n        rep(i,2*n)rep(j,2*n)x[i][j]=min(x[i][j],x[j][i]);\n        rep(i,2*n)rep(j,2*n)rep(k,2*n)x[j][k]=min(x[i][j]+x[i][k],x[j][k]);\n        cout<<setprecision(10)<<x[0][2*n-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <stack>\n\nchar buf[128];\nint pos;\n#define NOW (buf[pos])\n\nbool isdigit(char c) {\n\treturn ('0' <= c && c <= '9');\n}\n\nbool isstrong(char c) {\n\treturn (c=='*'||c=='/');\n}\nbool isweak(char c) {\n\treturn (c=='+'||c=='-');\n}\n\nint digit() {\n\tif ( !isdigit(NOW) ) {\n\t\tfprintf(stderr, \"%c: \", NOW);\n\t\tassert( isdigit(NOW) );\n\t}\n\tint ret = NOW - '0';\n\tpos++;\n\t\n\treturn ret;\n}\nint number() {\n\tint ret = digit();\n\twhile( isdigit(NOW) ) {\n\t\tret = ret*10 + digit();\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\n\tint set;\n\tscanf(\"%d\", &set);\n\t\n\twhile(set--) {\n\t\tscanf(\"%s\", buf);\n\t\tstd::stack<char> expr;\n\t\tstd::stack<int>  num;\n\t\t\n\t\texpr.push('(');\n\t\t\n\t\twhile(true) {\n\t\t\tif(isdigit(NOW)) {\n\t\t\t\tnum.push( number() );\n\t\t\t} else {\n\t\t\t\tif ( expr.top() == '(' && (NOW==')'||NOW=='=') ) {\n\t\t\t\t\t//対応する括弧が出てきたので、スタック上の括弧を消す\n\t\t\t\t\texpr.pop();\n\t\t\t\t\tif ( expr.empty() ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if ( expr.top() == '(' ||\n\t\t\t\t     NOW == '(' ||\n\t\t\t\t\t ( isstrong(NOW)&&isweak(expr.top()) ) ) {\n\t\t\t\t\t//強い演算子はスタックに積んでおく。括弧が積んであるなら、無条件に積む\n\t\t\t\t\texpr.push(NOW);\n\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\t//次の演算子は弱いor同じだから、積んでるものを先に計算してしまおう\n\t\t\t\t\tchar de = expr.top(); expr.pop();\n\n\t\t\t\t\tint b = num.top(); num.pop();\n\t\t\t\t\tint a = num.top(); num.pop();\n\t\t\t\t\tint ans;\n\t\t\t\t\tswitch(de) {\n\t\t\t\t\t\tcase '+': ans=a+b; break;\n\t\t\t\t\t\tcase '-': ans=a-b; break;\n\t\t\t\t\t\tcase '*': ans=a*b; break;\n\t\t\t\t\t\tcase '/': ans=a/b; break;\n\t\t\t\t\t}\n\t\t\t\t\tnum.push(ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", num.top());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cctype>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint exp(char* & p);\n\nint num(char* & p) {\n    int ret = 0;\n    while (isdigit(*p)) {\n        ret *= 10;\n        ret += *p - '0';\n        p++;\n    }\n    return ret;\n}\n\nint fac(char* & p) {\n    int ret = 0;\n    if (*p == '(') {\n        p++;\n        ret += exp(p);\n        p++;\n    } else {\n        ret += num(p);\n    }\n    return ret;\n}\n\nint term(char* & p) {\n    int ret = fac(p);\n    while(1) {\n        if (*p == '*') {\n            p++;\n            ret *= fac(p);\n        } else if (*p == '/') {\n            p++;\n            ret /= fac(p);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint exp(char* & p) {\n    int ret = term(p);\n    while(1) {\n        if (*p == '+') {\n            p++;\n            ret += term(p);\n        } else if (*p == '-') {\n            p++;\n            ret -= term(p);\n        } else break;\n    }\n    return ret;\n}\n\nint eval(const string & s){\n    char* p = (char*)s.c_str();\n    return exp(p);\n}\n\nint eval(const char* str){\n    char* p = (char*)str;\n    return exp(p);\n}\n\nusing namespace std;\n\nint main(){\n    char str[128];\n    while(gets(str))\n        cout << eval(str) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1 && !is_all_digit(in[0])) {\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\tcerr<<n<<endl;\n\twhile (n--) {\n\t\tcin >> input;\n\t\t//input.erase(input.end() - 1);\n\t\t//cout << cal(input) << endl;\n\t\tcerr << input << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint calc(string ex){\n\tint str,cnt,ans=0,now=0,add=1,n=ex.length(),i;\n\tbool sus=false;\n\tchar pm='+',md='*';\n\tfor(i=0; i<n; i++){\n\t\tif(sus){\n\t\t\tif(ex[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}else if(ex[i]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tnow = calc(ex.substr(str,i-str));\n\t\t\t\tsus = false;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(ex[i]){\n\t\t\t\tcase '(':\n\t\t\t\t\tstr = i+1;\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tsus = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\tadd *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tadd /= now;\n\t\t\t\t\t}\n\t\t\t\t\tif(pm == '+'){\n\t\t\t\t\t\tans += add;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans -= add;\n\t\t\t\t\t}\n\t\t\t\t\tpm = ex[i];\n\t\t\t\t\tmd = '*';\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tadd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\tadd *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tadd /= now;\n\t\t\t\t\t}\n\t\t\t\t\tmd = ex[i];\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tnow *= 10;\n\t\t\t\t\tnow += ex[i]-'0';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(md == '*'){\n\t\tadd *= now;\n\t}else{\n\t\tadd /= now;\n\t}\n\tif(pm == '+'){\n\t\tans += add;\n\t}else{\n\t\tans -= add;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n,i,ans;\n\tstring str;\n\tcin >> n;\n\tfor(i=0; i<n; i++){\n\t\tcin >> str;\n\t\tans = calc(str);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint calc(char *s, int &i){\n  int ret = 0;\n  bool flag = i >= 0 && s[i-1] == '(';\n  \n  for(;s[i];){\n    \n    if(s[i] == ')'){\n      if(flag) i++;\n      return ret;\n    }\n    \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\n      i++;\n      \n      if(s[i] == '('){\n        i++;\n\n        if(i-2 < 0) ret += calc(s,i);\n        if(s[i-2] == '+') ret += calc(s,i);\n        if(s[i-2] == '-') ret -= calc(s,i);\n        if(s[i-2] == '*') ret *= calc(s,i);\n        if(s[i-2] == '/') ret /= calc(s,i);\n\n        continue;\n      }\n\n            \n      if(s[i-1] == '+') ret += calc(s,i);\n      if(s[i-1] == '-') ret -= calc(s,i);\n      \n    }else{\n      int start = i-1;\n      int sum = 0;\n      \n      while(!(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '\\0' || s[i] == ')')){\n        sum *= 10;\n        sum += s[i] - '0';\n        i++;\n      }\n\n      if(start < 0){\n        ret += sum;\n      }else{\n        if(s[start] == '(') ret += sum;\n        if(s[start] == '+') ret += sum;\n        if(s[start] == '-') ret += sum;\n        if(s[start] == '*') ret *= sum;\n        if(s[start] == '/') ret /= sum;\n      }\n    }\n  }\n\n  return ret;\n}\n\n\nint main(){\n  char s[SIZE];\n  int t = 0;\n\n  int n;\n\n  scanf(\"%d\",&n);\n\n  while(n--){\n    t = 0;\n    scanf(\"%s\",s);\n\n    s[strlen(s)-1] = '\\0';\n    \n    printf(\"%d\\n\",calc(s,t));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n// Appendix??????????????????\n#include <bits/stdc++.h>\nusing namespace std;\nint n, cur;\nstring str;\nint expression();\nint factor();\nint digit() {\n    assert(isdigit(str[cur]));\n    int n = str[cur] - '0';\n    cur++;\n    return n;\n}\nint number() {\n    int n = digit();\n    while (cur < str.size() && isdigit(str[cur])) n = n * 10 + digit();\n    return n;\n}\nint factor() {\n    if (str[cur] != '(') return number();\n    cur++;\n    int n = expression();\n    assert(str[cur] == ')');\n    cur++;\n    return n;\n}\nint term() {\n    int a = factor();\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        char op = str[cur++];\n        int b = factor();\n        if (op == '*') a *= b;\n        else a /= b;\n    }\n    return a;\n}\nint expression() {\n    int a = term();\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        char op = str[cur++];\n        int b = term();\n        if (op == '+') a += b;\n        else a -= b;\n    }\n    return a;\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i=0; i<n; i++) {\n        cur = 0;\n        cin >> str;\n        str.resize(str.size() - 1);\n        printf(\"%d\\n\", expression());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "for t in xrange(input()):\n\tprint eval(raw_input()[:-1])"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nstruct RevPolElement\n{\n\tRevPolElement(int type, int n) : type(type), n(n) { }\n\tint type;\n\tint n;\n};\n\ndeque<RevPolElement> make_revpol(char* s)\n{\n\tmap<char, int> pr;\n\tpr['w'] = -1;\n\tpr['('] = 0;\n\n\tpr['+'] = pr['-'] = 1;\n\tpr['*'] = pr['/'] = 2;\n\tpr['@'] = 3;\n\n\tchar* before_unary = \"+-*/(\";\n\n\tdeque<RevPolElement> res;\n\tstack<char> t;\n\tt.push('w');\n\tfor (int i = 0; s[i] != '='; ++i)\n\t{\n\t\tif (isdigit(s[i]))\n\t\t{\n\t\t\tint t = s[i] - '0';\n\t\t\twhile (isdigit(s[i+1]))\n\t\t\t\tt = t*10 + s[++i] - '0';\n\n\t\t\tres.push_back(RevPolElement(0, t));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar op = s[i];\n\t\t\tif (op == '-' && (i == 0 || strchr(before_unary, s[i-1])))\n\t\t\t\top = '@';\n\n\t\t\tif (op == ')')\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tchar topOp = t.top();\n\t\t\t\t\tt.pop();\n\t\t\t\t\tif (topOp == '(')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tres.push_back(RevPolElement(1, topOp));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == '(')\n\t\t\t\tt.push(op);\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (pr[op] <= pr[t.top()])\n\t\t\t\t{\n\t\t\t\t\tres.push_back(RevPolElement(1, t.top()));\n\t\t\t\t\tt.pop();\n\t\t\t\t}\n\t\t\t\tt.push(op);\n\t\t\t}\n\t\t}\n\t}\n\twhile (t.size() > 1)\n\t{\n\t\tres.push_back(RevPolElement(1, t.top()));\n\t\tt.pop();\n\t}\n\n\treturn res;\n}\n\nint calculate_revpol(deque<RevPolElement> revpol)\n{\n\tstack<int> t;\n\twhile (!revpol.empty())\n\t{\n\t\tif (revpol.front().type)\n\t\t{\n\t\t\tchar op = revpol.front().n;\n\t\t\tint res;\n\t\t\tif (op == '@')\n\t\t\t{\n\t\t\t\tres = -t.top();\n\t\t\t\tt.pop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a, b;\n\t\t\t\tb = t.top(); t.pop();\n\t\t\t\ta = t.top(); t.pop();\n\t\t\t\tif (op == '+')\n\t\t\t\t\tres = a + b;\n\t\t\t\telse if (op == '-')\n\t\t\t\t\tres = a - b;\n\t\t\t\telse if (op == '*')\n\t\t\t\t\tres = a * b;\n\t\t\t\telse if (op == '/')\n\t\t\t\t\tres = a / b;\n\t\t\t}\n\n\t\t\tt.push(res);\n\t\t}\n\t\telse\n\t\t\tt.push(revpol.front().n);\n\n\t\trevpol.pop_front();\n\t}\n\n\treturn t.top();\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcin.get();\n\t\twhile (n--)\n\t\t{\n\t\t\tchar buf[256];\n\t\t\tcin.getline(buf, sizeof(buf));\n\t\t\tprintf(\"%d\\n\", calculate_revpol(make_revpol(buf)));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint getNumber( string& str, int* index )\n{\n\tint ret = 0;\n\twhile( *index < (int)str.size() ){\n\t\tif( str[ *index ] < '0' || str[ *index ] > '9' ){\n\t\t\tbreak;\n\t\t}\n\t\tret *= 10;\n\t\tret += ( str[ *index ] - '0' );\n\t\t++(*index);\n\t}\n\treturn ret;\n}\n\ndouble rec( string& formula, int* index )\n{\n\tdouble ret = 0;\n\tvector<double> num_list;\n\tvector<char> sign_list( 1, '.' );\n\tbool end = false;\n\n\twhile( !end && *index < (int)formula.size() ){\n\t\tif( formula[ *index ] >= '0' && formula[ *index ] <= '9' ){\n\t\t\tnum_list.push_back( getNumber( formula, index ) );\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tswitch( formula[ *index ] ){\n\t\t\t\tcase '(':\n\t\t\t\t\t++(*index);\n\t\t\t\t\tnum_list.push_back( rec( formula, index ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\tcase '=':\n\t\t\t\t\t++(*index);\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsign_list.push_back( formula[ *index ] );\n\t\t\t\t\t++(*index);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<double> num2_list;\n\tvector<char> sign2_list( 1, '.' );\n\n\tfor( int i = 0; i < (int)num_list.size(); ++i ){\n\t\tdouble num = num_list[ i ];\n\t\tswitch( sign_list[ i ] ){\n\t\t\tcase '.':\n\t\t\t\tret = num;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tret *= num;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tret /= num;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnum2_list.push_back( ret );\n\t\t\t\tret = num;\n\t\t\t\tsign2_list.push_back( sign_list[ i ] );\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tnum2_list.push_back( ret );\n\n\tfor( int i = 0; i < (int)num2_list.size(); ++i ){\n\t\tdouble num = num2_list[ i ];\n\t\tswitch( sign2_list[ i ] ){\n\t\t\tcase '.':\n\t\t\t\tret = num;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tret += num;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tret -= num;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint solve( string& formula ){\n\tint index = 0;\n\treturn (int)rec( formula, &index );\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor( int i = 0; i < n; ++i ){\n\t\tstring formula;\n\t\tcin >> formula;\n\t\tcout << solve( formula ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint calculation( int a, int b, char c )\n{\n    if( c == '+' )\n        return a + b;\n    else if( c == '-' )\n        return a - b;\n    else if( c == '*' )\n        return a * b;\n    else if( c == '/' )\n        return a / b;\n    else\n        return a;\n}\n\nint main()\n{\n    int n;\n    vector<int> d, p;\n    vector<char> f;\n    string str;\n\n\n    cin >> n;\n\n    for( int k = 0; k < n; k++ )\n    {\n        cin >> str;\n\n        int plus = 0;\n        for( int i = 0; i < str.size(); i++ )\n        {\n            int a = str[i] - '0', j = i;\n            while( 0 <= a && a < 10 )\n            {\n                j++;\n                a = str[j] - '0';\n            }\n            int sum = 0, mul = 1;\n            for( int s = 0; s < j - i; s++ )\n            {\n                sum += ( str[j-(s+1)] - '0' ) * mul;\n                mul *= 10;\n            }\n            if( 0 <= str[i] - '0' && str[i] - '0' < 10 )\n            {\n                d.push_back(sum);\n                while( mul != 1 )\n                {\n                    i++;\n                    mul /= 10;\n                }\n                i--;\n            }\n            else\n            {\n                if( str[i] == '+' || str[i] == '-' )\n                    p.push_back( plus + 1 );\n                else if( str[i] == '*' || str[i] == '/' )\n                    p.push_back( plus + 2 );\n                else if( str[i] == '(' )\n                    plus += 3;\n                else if( str[i] == '=' )\n                    p.push_back(0);\n                else\n                    plus -= 3;\n                if( str[i] != '(' && str[i] != ')' )\n                    f.push_back(str[i]);\n            }\n        }\n\n        // for( int i = 0; i < d.size(); i++ )\n        //     cout << d[i] << \" \";\n        // cout << endl;\n\n        // for( int i = 0; i < p.size(); i++ )\n        //     cout << p[i] << \" \";\n        // cout << endl;\n\n        // for( int i = 0; i < f.size(); i++ )\n        //     cout << f[i] << \" \";\n        // cout << endl;\n\n        while( f[0] != '=' )\n        {\n            for( int i = 0; i < p.size() - 1; i++ )\n            {\n                if( p[i] > p[i+1] )\n                {\n                    d[i] = calculation( d[i], d[i+1], f[i] );\n                    f[i] = f[i+1];\n                    p[i] = p[i+1];\n\n                    int s = i;\n                    while( s + 2 < p.size() )\n                    {\n                        d[s+1] = d[s+2];\n                        f[s+1] = f[s+2];\n                        p[s+1] = p[s+2];\n                        s++;\n                    }\n                }\n            }\n        }\n        cout << d[0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n      \n      // else if(str[i] == '+' || str[i] == '-'){\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = tmp;\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n      // else{\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = string(tmp);\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nstring Str;\nunsigned int cur = 0;\n\nint digit();\nint number();\nint term();\nint facter();\nint expression();\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cur = 0;\n        cin >> Str;\n        Str.resize(Str.size()-1);\n        int ans = expression();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint digit()\n{\n    assert(isdigit(Str[cur]));\n    int n = Str[cur] - '0';\n    cur++;\n    return n;\n}\n\nint number()\n{\n    int n = digit();\n    while(cur < Str.size() && isdigit(Str[cur])) n = n*10 + digit();\n    return n;\n}\n\nint factor()\n{\n    if(Str[cur] != '(') return number();\n    cur++;\n    int n = expression();\n    assert(Str[cur] == ')');\n    cur++;\n    return n;\n}\n\nint term()\n{\n    int a = factor();\n    while(cur < Str.size() && (Str[cur] == '*' || Str[cur] == '/')){\n        char op = Str[cur++];\n        int b = factor();\n        if(op == '*') a *= b;\n        else a /= b;\n    }\n    return a;\n}\n\nint expression()\n{\n    int a = term();\n    while(cur < Str.size() && (Str[cur] == '+' || Str[cur] == '-')){\n        char op = Str[cur++];\n        int b = term();\n        if(op == '+') a += b;\n        else a -= b;\n    }\n    return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nint expression();\nint term();\nint factor();\nint number();\n\nint now;\nstring s;\n\nint expression(){\n\tint res=term();\n\t\twhile(true){\n\t\tif(s[now]=='+')now++,res+=term();\n\t\telse if(s[now]=='-')now++,res-=term();\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint term(){\n\tint res=factor();\n\twhile(true){\n\t\tif(s[now]=='(')res+=factor();\n\t\telse if(s[now]=='*')now++,res*=factor();\n\t\telse if(s[now]=='/')now++,res/=factor();\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint factor(){\n\tint res=0;\n\tif(s[now]=='(')now++,res=expression(),now++;\n\telse return number();\n\treturn res;\n}\n\nint number(){\n\tint res=0;\n\twhile('0'<=s[now] && s[now]<='9')res*=10,res+=s[now++]-'0';\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\t\n\twhile(n--){\n\t\tcin >> s;\n\t\tnow=0;\n\t\tcout << expression() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include <fstream>\n#include <time.h>\n#include <iterator>\n\n\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end());\n#define ll long long\n#define pb(a) push_back(a)\n#define m0(x) memset(x,0,sizeof(x))\n#define print(x) cout<<x<<endl;\n#define pe(x) cout<<x<<\" \";\n#define lb(v,n) lower_bound(v.begin(), v.end(), n);\n#define ub(v,n) upper_bound(v.begin(), v.end(), n);\n#define int long long\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nint MOD = (ll)1000000000 + 7;\nconst ll INF = 1e17;\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ntypedef pair<int, int>P;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s, int& i) {\n\tint val = term(s, i);\n\twhile (s[i]=='+'||s[i]=='-')\n\t{\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (op == '+')val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\n\nint term(string &s, int &i) {\n\tint val = factor(s, i);\n\twhile (s[i]=='*'||s[i]=='/')\n\t{\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint  val2 = factor(s, i);\n\t\tif (op == '*')val *= val2;\n\t\telse val /= val2;\n\t}\n\treturn val;\n}\n\nint factor(string &s, int &i) {\n\tif (isdigit(s[i]))return number(s, i);\n\ti++;\n\tint ret = expr(s, i);\n\ti++;\n\treturn ret;\n}\n\nint number(string &s, int &i) {\n\tint n = s[i++] - '0';\n\twhile (isdigit(s[i])) {\n\t\tn = n * 10 + s[i++] - '0';\n\t}\n\treturn n;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tREP(i, N) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tint j = 0;\n\t\tprint(expr(str, j));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\nusing State = string::const_iterator;\n\n\nint expression(State& begin);\nint term(State& begin);\nint factor(State& begin);\nint number(State& begin);\n\n\nint expression(State& begin){\n\tint ret = term(begin);\n\n\twhile (true){\n\t\tif (*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint term(State& begin){\n\tint ret = factor(begin);\n\n\twhile (true){\n\t\tif (*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint factor(State& begin){\n\tint ret;\n\tif (*begin == '('){\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\n\nint number(State& begin){\n\tint ret = 0;\n\n\twhile (isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tstring expr;\n\n\tcin >> n;\n\tcin.ignore();\n\n\tfor (int i = 0; i < n; i++){\n\t\tgetline(cin, expr);\n\n\t\tState begin = expr.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint p;\n\nint exp();\nint factor();\nint term();\n\nint factor() {\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n\n  else if (str[p] == '('){\n    p++;\n    num = exp();\n  }\n  if(str[p] == ')')  p++;\n\n   \n  return num;\n}\n\nint term(){\n int val = factor();\n  while(str[p] == '*' || str[p] == '/') {\n    if(str[p] == '*') {\n      p++;\n      val *= factor();\n    } else if(str[p] == '/'){\n      p++;\n      val /= factor();\n    }\n  }\n\n  return val;\n}\n \nint exp() {\n  int val = term();\n  while(str[p] == '+' || str[p] == '-') {\n    if(str[p] == '+') {\n      p++;\n      val += term();\n    } else if(str[p] == '-'){\n      p++;\n      val -= term();\n    }\n  }\n\n  return val;\n}\n\nint main() {\n  int n;\n\n  cin >> n;\n  \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint p;\nstring S;\n\nint num();\nint factor();\nint term();\nint calc();\n\nint num(){\n\tint n = 0;\n\twhile(p<S.size()){\n\t\tif(isdigit(S[p])) n = n*10+S[p]-'0';\n\t\telse break;\n\t\tp++;\n\t}\n\treturn n;\n}\n\nint factor(){\n\tint n;\n\tif(S[p]=='('){\n\t\tp++; n = calc(); p++;\n\t}\n\telse n = num();\n\treturn n;\n}\n\nint term(){;\n\tint n = factor();\n\twhile(p<S.size()){\n\t\tif(S[p]=='*') p++, n *= factor();\n\t\telse if(S[p]=='/') p++, n /= factor();\n\t\telse break;\n\t}\n\treturn n;\n}\n\nint calc(){\n\tint n = term();\n\twhile(p<S.size()){\n\t\tif(S[p]=='+') p++, n += term();\n\t\telse if(S[p]=='-') p++, n -= term();\n\t\telse break;\n\t}\n\treturn n;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>S; S.pop_back();\n\t\tp = 0;\n\t\tprintf(\"%d\\n\",calc());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::iterator State;\nint n;\nstring str;\n\nint factor(State &begin);\nint number(State &begin);\nint term(State &begin);\nint expressin(State &begin);\n\nint factor(State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nchar readchar();\nchar peek();\nint digit();\nint number();\nint expression();\nint parse();\n\nint main() {\n\tint count;\n\tcin >> count;\n\tfor(int i=0;i<count;i++) {\n\t\tcur = 0;\n\t\t\n\t\tcin >> S;\n\t\t//cout << S << endl;\n\t\tS.resize(S.size()-1);\n\t\tint a = parse();\n\t\tcout << a << endl;\n\t}\n\t\n\n}\n\n\n// 1 ??????????????§ cur ????????????\n// ??????:?¬???? readchar ??§???????¬???????????????????\nchar readchar() {\n\tassert(cur < S.size());\n\tchar ret = S[cur];\n\tcur += 1;\n\treturn ret;\n// return S[cur++]; ??¨????????§???????????¨?????§??????\n}\nchar peek() { // 1 ??????????????? cur ???????????????\n\t//assert(cur < S.size());\n\treturn S[cur];\n}\n\nint digit() {\n\tassert(isdigit(peek())); // S[cur] ?????°?????§???????????¨????¢????\n\tint n = readchar() - '0'; // ???0??? ??? 0 ?????????\n\treturn n;\n}\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(peek())) // ?¬??????°?????? 1 ????????????\n\tn = n*10 + digit();\n\treturn n;\n}\nint expression();\n\nint factor() {\n\tif (peek() != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(peek() == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint term() {\n\tint a = factor();\n\twhile (cur < S.size() && (peek() == '*' || peek() == '/')) {\n\t\tchar op = readchar();\n\t\tint b = factor();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\n\nint expression() {\n\tint a = term();\n\twhile(cur < S.size() && (peek() == '+' || peek() == '-')) {\n\t\tchar op = readchar();\n\t\tint b = term();\n\t\tassert((op == '+') || (op == '-'));\n\t\tif(op == '+') {\n\t\t\ta+=b;\n\t\t} else {\n\t\t\ta-=b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint parse() {\n\treturn expression();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#define int long long\n//#define _DEBUG\n//#include <vector>\n#include <string>\n//#include <map>\n//#include <stack>\n#include <cassert>\nusing namespace std;\n\n//input\nint N;\nstring input;\n\nint cur;\nint expression();\n\nchar readchar(){\n    assert(cur < input.size());\n    return input[cur++];\n}\nchar peek(){\n    assert(cur < input.size());\n    return input[cur];\n}\nbool isDisit(char c){\n    return int(c)>=48 && int(c)<58;\n}\nint disit(){\n    assert(isDisit(peek()));\n    return readchar() - '0';\n}\nint number(){\n    int n = disit();\n    while(cur < input.size() && isDisit(peek())){\n        n = 10*n + disit();\n    }\n    return n;\n}\nchar additiveOpr(){\n    assert(peek()=='+' || peek()=='-');\n    return readchar();\n}\nchar multiveOpr(){\n    assert(peek()=='*' || peek()=='/');\n    return readchar();\n}\nint opr(char opr, int x, int y){\n    if(opr=='+'){\n        return x+y;\n    }else if(opr=='-'){\n        return x-y;\n    }else if(opr=='*'){\n        return x*y;\n    }else if(opr=='/'){\n        assert(y!=0);\n        return x/y;\n    }else{\n        return -1;//error\n    }\n}\nint factor(){\n    if(peek()!='(') return number();\n    cur++;\n    int n = expression();\n    assert(peek()==')');\n    cur++;\n    return n;\n}\nint term(){\n    int r = factor();\n    while(cur<input.size()\n            &&(peek()=='*' || peek()=='/')){\n        char o = multiveOpr();\n        int b = factor();\n        r = opr(o,r,b);\n    }\n    return r;\n}\nint expression(){\n    int r = term();\n    while(cur<input.size() \n            &&(peek()=='+' || peek()=='-')){\n        char o = additiveOpr();\n        int b = term();\n        r = opr(o,r,b);\n    }\n    return r;\n}\nint solve(){\n    int n = expression();\n    assert(peek()=='=');\n    return n;\n}\nsigned main(){\n    cin >> N;\n    for(int i=0; i<N; i++){\n        cin >> input;\n        cur = 0;\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\n\n#include<cassert>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nstring S;\nint cur = 0;//?§£???????§???????\n\nint expression();//????????£?¨?\n\nint digit(){\n\t// assert(isdigit(S[cur]));\n\t// cout<<\"S[cur]=\"<<S[cur]<<endl;;\n\tint n = S[cur++] - '0';\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur]))n = n*10+digit();\n\treturn n;\n}\n\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\t// assert(S[cur++]==')');\n\tcur++;\n\treturn n;\n}\n\nint term(){\n\tint a = factor();\n\twhile(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op=='*')a*=b;else a/=b;\n\t}\n\treturn a;\n}\n\nint expression() {\n\tint a = term();\n\twhile (cur<S.size() && (S[cur] == '+' || S[cur] == '-')) { // ?¶???????????????????????¶???????\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+')a+=b;else a-=b;\n\t}\n\treturn a;\n}\n\nint main(){\n\tint N;\n\tint ans[50];\n\tcin>>N;\n\trep(i,N){\n\t\tcur=0;\n\t\tcin>>S;\n\t\tS.resize(S.size()-1);\n\t\tans[i]=expression();\n\t}\n\trep(i,N)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <deque>\n#include <memory.h>\n\n#define rep(idx, max)\t\t\tfor(int idx = 0, idx##Max = (max); idx < idx##Max; idx ++)\n#define rrep(idx, min, max)\tfor(int idx = (min), idx##Max = max; idx < idx##Max; idx ++)\n#define erep(idx, min, max)\tfor(int idx = (min), idx##Max = max; idx <= idx##Max; idx ++)\n\n#define rev(idx, max)\t\t\tfor(int idx = (max) - 1; idx >= 0; idx --)\n#define rrev(idx, min, max)\tfor(int idx = (max) - 1, idx##Min = (min); idx >= idx##Min; idx --)\n#define erev(idx, min, max)\tfor(int idx = (max), idx##Min = (min); idx >= idx##Min; idx --)\n\n#define foreach(it, obj)\tfor(auto it = obj.begin(), it##End = obj.end(); it >= it##End; it ++)\n\nusing namespace\tstd;\n\nclass CCalc\n{\n\tstring\ts_;\n\tint\tpos_;\n\t\n\tint\tIsDigit(int x)\t{\treturn(x <= '9' && x >= '0');\t}\n\tvoid\tSkipSpace()\n\t{\n\t\tcout << \"Skipping...\";\n\t\tfor(int c = s_[pos_]; (c == ' ' || c == '\\t') && pos_ < s_.size(); pos_ ++);\n\t\tcout << \"OK\" << endl;\n\t}\n\tint\tNumber()\n\t{\n\t\tint num = 0;\n\t\twhile(IsDigit(s_[pos_]))\t{\tnum\t= num * 10 + s_[pos_ ++] - '0';\t}\n\t\treturn(num);\n\t}\n\tint\tFactor()\n\t{\n\t\tint val;\n\t\tif(pos_ >= s_.size())\t{\tcout << \"warning: Out of bounds!\" << endl;\t}\n\t\tif(IsDigit(s_[pos_]))\n\t\t{\n\t\t\tval = Number();\n\t\t\treturn(val);\n\t\t}\n\t\tpos_ ++;\n\t\tval\t= Expr();\n\t\tpos_ ++;\n\t\treturn(val);\n\t}\n\tint\tTerm()\n\t{\n\t\tint\tval1\t= Factor();\n\t\twhile(s_[pos_] == '*' || s_[pos_] == '/')\n\t\t{\n\t\t\tchar\top\t= s_[pos_ ++];\n\t\t\tint val2\t= Factor();\n\t\t\tswitch(op)\n\t\t\t{\n\t\t\t\tcase '*':\tval1 *= val2;\tbreak;\n\t\t\t\tcase '/':\tval1 /= val2;\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn(val1);\n\t}\n\tint\tExpr()\n\t{\n\t\tint\tval1\t= Term();\n\t\twhile(s_[pos_] == '+' || s_[pos_] == '-')\n\t\t{\n\t\t\tchar\top\t= s_[pos_ ++];\n\t\t\tint val2\t= Term();\n\t\t\tswitch(op)\n\t\t\t{\n\t\t\t\tcase '+':\tval1 += val2;\tbreak;\n\t\t\t\tcase '-':\tval1 -= val2;\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn(val1);\n\t}\n\t\npublic:\n\tint\tEval(string &expression)\n\t{\n\t\tpos_\t= 0;\n\t\tint pos = 0;\n\t\ts_.resize(expression.size());\n\t\trep(i, expression.size())\n\t\t{\n\t\t\tif(expression[i] != ' ')\n\t\t\t{\ts_[pos ++] = expression[i];\t}\n\t\t}\n\t\treturn(Expr());\n\t}\n};\n\nint main()\n{\n\tCCalc\tcalc;\n\tstring\texpression;\n\tint tc;\n\t\n\tfor(cin >> tc, cin.ignore(); tc > 0; tc --)\n\t{\n\t\tgetline(cin, expression);\n\t\tcout << calc.Eval(expression) << endl;\n\t}\n\t\n//\twhile(getline(cin, expression), expression.size())\n//\t{\t::printf(\"%s = %d\\n\", expression.c_str(), calc.Eval(expression));\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\n\ndouble expression(State &);\ndouble term(State &);\ndouble factor(State &);\ndouble number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n\n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    double ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\ndouble expression(State &begin){\n  double ret=term(begin);\n\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\ndouble term(State &begin){\n  double ret=number(begin);\n\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\ndouble factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    double ret=expression(begin);\n    begin++;\nreturn ret;\n  }\n  else return number(begin);\n}\n\ndouble number(State &begin){\n  double ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n \nusing namespace std;\n \nint expression();\nint term();\nint factor();\nint number();\n \nint now;\nstring s;\n \nint expression(){\n    int res=term();\n        while(true){\n        if(s[now]=='+')now++,res+=term();\n        else if(s[now]=='-')now++,res-=term();\n        else break;\n    }\n    return res;\n}\n \nint term(){\n    int res=factor();\n    while(true){\n        if(s[now]=='*')now++,res*=factor();\n        else if(s[now]=='/')now++,res/=factor();\n        else break;\n    }\n    return res;\n}\n \nint factor(){\n    int res=0;\n    if(s[now]=='('){\n        now++;\n        res=expression();\n        now++;\n    }\n    else return number();\n     \n    return res;\n}\n \nint number(){\n    int res=0;\n    while('0'<=s[now] && s[now]<='9'){\n        res*=10;\n        res+=s[now++]-'0';\n    }\n    return res;\n}\n \n \nint main(void){\n    int n;\n    cin >> n;\n     \n    while(n--){\n        cin >> s;\n        now=0;\n        cout << expression() << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit() {\n\tint n;\n\tassert(isdigit(S[cur]));\n\tn = S[cur] -'0';\n\t++cur;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur])) {\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor() {\n\tint n;\n\tif (S[cur] != '(') n = number();\n\telse {\n\t\t++cur;\n\t\tn = expression();\n\t\tassert(S[cur] == ')');\n\t}\n\treturn n;\n}\n\nint term() {\n\tint t = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*') t *= b; else t /= b;\n\t}\n\treturn t;\n}\n\n\n/*int expression() {\n\tint sum = number();\n\twhile (S[cur] == '+' || S[cur] == '-') {\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif(op == +) sum += b;\telse return sum -= b;\n\t}\n\treturn sum;\n}*/\n\nint expression() {\n\tint sum = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+') sum += b; else sum -= b;\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N; ++i) {\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    if(s[pos]=='('){\n      pos++;\n      return getAns();\n    }\n    int res=head2Num();\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      if(s[pos]==')'){pos++;break;}\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.s=a.s.substr(0,a.s.size()-1);\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int Int;\ntypedef string::const_iterator Iter;\n\nInt eval(const string&);\nInt expr(Iter&);\nInt term(Iter&);\nInt factor(Iter&);\nInt number(Iter&);\n\nInt eval(const string &s){\n\tIter it = s.begin();\n\treturn expr(it);\n}\n\nInt expr(Iter &it){\n\tInt res = term(it);\n\twhile (true){\n\t\tif (*it == '+'){\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t}\n\t\telse if (*it == '-'){\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt term(Iter &it){\n\tInt res = factor(it);\n\twhile (true){\n\t\tif (*it == '*'){\n\t\t\t++it;\n\t\t\tres *= term(it);\n\t\t}\n\t\telse if (*it == '/'){\n\t\t\t++it;\n\t\t\tres /= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt factor(Iter &it){\n\tif (*it == '('){\n\t\t++it;\n\t\tInt res = expr(it);\n\t\t++it;\n\t\treturn res;\n\t}\n\telse return number(it);\n}\n\nInt number(Iter &it){\n\tInt res = 0;\n\twhile (isdigit(*it)){\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tcout << eval(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tsize1 = res.substr(j + 1, i - j - 1).size();\n\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t}\n\n\t//cout << \"!!\" << res << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tif (i == 0)continue;\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = res.substr(j, i - j).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\t//cout << \"!!\" << i  << endl;\n\t\t//cout << res << endl;\n\t\tint pos1, pos2, size;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\t//cout << res.substr(pos1 + 1, pos2 - pos1 - 1) << endl;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tsize = buf.size();\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2 + 1, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = pos1 + size - 1;\n\t\t\t//cout << \"!\" << i << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit() {\n\tint n;\n\tassert(isdigit(S[cur]));\n\tn = S[cur] -'0';\n\t++cur;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur])) {\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor() {\n\tint n;\n\tif (S[cur] != '(') n = number();\n\telse {\n\t\t++cur;\n\t\tn = expression();\n\t\tassert(S[cur] == ')');\n\t}\n\treturn n;\n}\n\nint term() {\n\tint t = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*') t *= b; else t = (int)trunk(1.0*t/b);\n\t}\n\treturn t;\n}\n\n\n/*int expression() {\n\tint sum = number();\n\twhile (S[cur] == '+' || S[cur] == '-') {\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif(op == +) sum += b;\telse return sum -= b;\n\t}\n\treturn sum;\n}*/\n\nint expression() {\n\tint sum = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+') sum += b; else sum -= b;\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N; ++i) {\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\t// if(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\tstring tmp;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\t// if(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr>=s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s,int& i) {\n\tint a = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint b = term(s, i);\n\t\tif (op == '+') {\n\t\t\ta = a+b;\n\t\t}\n\t\telse {\n\t\t\ta = a - b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint term(string& s, int& i) {\n\tint a = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint b = factor(s, i);\n\t\tif (op == '*') {\n\t\t\ta = a*b;\n\t\t}\n\t\telse {\n\t\t\ta = a / b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint factor(string& s, int& i) {\n\tif (isdigit(s[i])) {\n\t\tint a = number(s, i);\n\t\treturn a;\n\t}\n\telse {\n\t\ti++;//(\n\t\tint a = expr(s, i);\n\t\ti++;//)\n\t\treturn a;\n\t}\n}\n\nint number(string& s, int& i) {\n\tint a = s[i]-'0';\n\ti++;\n\twhile (isdigit(s[i])) {\n\t\ta = a * 10 + (s[i] - '0');\n\t\ti++;\n\t}\n\treturn a;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tREP(j, n) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tint k = 0;\n\t\tcout << expr(ss, k) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nint calc(string s){\n    while(1){\n        vector<pair<int, int>> vv;\n        int depth = 0;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '('){\n                vv.push_back(pair<int, int>(i, ++depth));\n            }else if(s[i] == ')'){\n                --depth;\n            }\n        }\n        if(vv.size() != 0){\n            sort(vv.begin(), vv.end(), [](auto a, auto b){return a.second != b.second ? a.second > b.second : a.first < b.first;});\n            int pos;\n            for(pos = vv[0].first; s[pos] != ')'; pos++);\n            int ret = calc(s.substr(vv[0].first + 1, pos - vv[0].first - 1));\n            string t = s.substr(0, vv[0].first) + to_string(ret) + s.substr(pos + 1);\n            s = t;\n            cout << s << endl;\n        }else{\n            while(1){\n                map<char, vector<int>> m;\n                for(int i = 0; i < s.size(); i++){\n                    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') m[s[i]].push_back(i);\n                }\n                vector<int> v;\n                if(m.find('*') != m.end() || m.find('/') != m.end()){\n                    for(int pos : m['*']) v.push_back(pos);\n                    for(int pos : m['/']) v.push_back(pos);\n                }else{\n                    for(int pos : m['+']) v.push_back(pos);\n                    for(int pos : m['-']) v.push_back(pos);\n                }\n                if(v.size() == 0 || (v.size() == 1 && v[0] == 0)) break;\n                sort(v.begin(), v.end());\n                string t;\n                int pos = v[0];\n                string num[2];\n                int tmp;\n                for(int j = pos - 1; 0 <= j; j--){\n                    if('0' <= s[j] && s[j] <= '9'){\n                        num[0] += s[j];\n                    }else{\n                        for(int k = 0; k <= j; k++){\n                            t += s[k];\n                        }\n                        break;\n                    }\n                }\n                for(int j = pos + 1; j <= s.size(); j++){\n                    if('0' <= s[j] && s[j] <= '9'){\n                        num[1] += s[j];\n                    }else{\n                        tmp = j;\n                        break;\n                    }\n                }\n                int add;\n                switch(s[pos]){\n                    case '+':\n                        add = stoi(num[0]) + stoi(num[1]);\n                        break;\n                    case '-':\n                        add = stoi(num[0]) - stoi(num[1]);\n                        break;\n                    case '*':\n                        add = stoi(num[0]) * stoi(num[1]);\n                        break;\n                    case '/':\n                        add = stoi(num[0]) / stoi(num[1]);\n                        break;\n                }\n                t += to_string(add);\n                for(int j = tmp; j < s.size(); j++) t += s[j];\n                s = t;\n            }\n            return stoi(s);\n        }\n    }\n}\n    \nint main(){\n    int N;\n    cin >> N;\n    for(int pomu = 0; pomu < N; pomu++){\n        string s;\n        cin >> s;\n        s = s.substr(0, s.size() - 1);\n        cout << calc(s) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define int long long\n#define range(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nconst int MOD = 1e9 + 7, INF = 1e17;\nusing vi = vector <int>;\nusing vvi = vector <vi>;\n//g++ -std==c++14\n\n\nint expr(const char **);\nint term(const char **);\nint factor(const char **);\nint number(const char **);\n\nint expr(const char **p) {\n  int val = term(p);\n  while (1) {\n    if (**p == '+') {\n      (*p)++;\n      val += term(p);\n    } else if (**p == '-') {\n      (*p)++;\n      val -= term(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(const char **p) {\n  int val = factor(p);\n  while (1) {\n    if (**p == '*') {\n      (*p)++;\n      val *= factor(p);\n    } else if (**p == '/') {\n      (*p)++;\n      val /= factor(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(const char **p) {\n  if (**p == '(') {\n    (*p)++;\n    int val = expr(p);\n    (*p)++;\n    return val;\n  }\n  return number(p);\n}\n\nint number(const char **p) {\n  int val = 0;\n  while ('0' <= **p && **p <= '9') {\n    val = val * 10 + **p - '0';\n    (*p)++;\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    const char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\nsize_t cur;\nstring s;\n\nint expression();\n\nint digit(){\n  assert(cur < s.size());\n  return s[cur++] - '0';\n}\nint number(){\n  int n = 0.0;\n  assert(cur < s.size());\n  while(cur < s.size() && isdigit(s[cur])){\n    n = n * 10 + digit();\n  }\n  return n;\n}\n\nint factor(){\n  assert(cur < s.size());\n  if(isdigit(s[cur])){\n    return number();\n  }else{\n    cur++;\n    int a = expression();\n    assert(s[cur] == ')');\n    cur++;\n    return a;\n  }\n}\n\nint term(){\n  assert(cur < s.size());\n  int a = factor();\n    while(cur < s.size() && (s[cur] == '*' || s[cur] == '/')){\n    char op = s[cur++];\n    int b = factor();\n    if(op == '*') a *= b; else a /= b;\n  }\n  return a;\n}\n\nint expression(){\n  assert(cur < s.size());\n  int a = term();\n  while(cur < s.size() && (s[cur] == '-' || s[cur] == '+')){\n    char op = s[cur++];\n    int b = term();\n    if(op == '-') a -= b; else a += b;\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cur = 0;\n    cin >> s;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\nstd::cout << std::endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else if(k > 0 && line[k-1] == ('+' || '-' || '*' || '-' || '(')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\nstring str;\n\nbool isNum(string s){\n  for(int i = 1; i < s.length(); i++)\n    if(s[i] < '0' || s[i] > '9') return false;\n\n  return true;\n}\n\nint solve(string s){\n\n  //  cout << s << endl;\n  if(isNum(s)){\n    stringstream ss(s);\n    int out;\n    ss >> out;\n    return out;\n  }\n\n  int pos = -1;\n\n  for(int i = 0; i < s.length(); i++)\n    if(s[i] == '+' || s[i] == '-' || s[i] == '('){\n      pos = i;\n      break;\n    }\n\n  if(pos == -1){\n    int now = 0;\n    string a,b;\n    a = b = \"\";\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '*' || s[i] == '/'){\n\tnow = i;\n\tbreak;\n      }\n      a += s[i];\n\n    }\n\n    for(int i = now+1; i < s.length(); i++)\n      b+=s[i];\n\n    if(s[now] == '+') return solve(a)+solve(b);\n    if(s[now] == '-') return solve(a)-solve(b);\n    if(s[now] == '*') return solve(a)*solve(b);\n    if(s[now] == '/') return solve(a)/solve(b);\n\n  }else{\n\n    string a,b;\n    a = b = \"\";\n\n    for(int i = 0; i < pos; i++)\n      a += s[i];\n    for(int i = pos+1; i < s.length(); i++)\n      b += s[i];\n\n    if(s[pos] == '+') return solve(a)+solve(b);\n    else if(s[pos] == '-') return solve(a)-solve(b);\n    else if(s[pos] == '('){\n\n      if(pos == 0){\n\n\tint par = 1;\n\ta = b = \"\";\n\tint now;\n\n\tfor(int i = 1; i < s.length(); i++){\n\t  if(s[i] == '(') par++;\n\t  if(s[i] == ')') par--;\n\t  a+=s[i];\n\t  if(par == 0){\n\t    now = i+1;\n\t    break;\n\t  }\n\t}\n\n\tif(now == s.length()){\n\t  for(int i = 1; i < s.length()-1; i++)\n\t    b += s[i];\n\n\t  return solve(b);\n\t}\n\n\tfor(int i = now+1; i < s.length(); i++)\n\t  b+=s[i];\n\n\tif(s[now] == '+') return solve(a)+solve(b);\n\tif(s[now] == '-') return solve(a)-solve(b);\n\tif(s[now] == '*') return solve(a)*solve(b);\n\tif(s[now] == '/') return solve(a)/solve(b);\n\t\n\n\n      }else{\n\ta = b = \"\";\n\n\tfor(int i = 0; i < pos-1; i++)\n\t  a+=s[i];\n\n\tfor(int i = pos; i < s.length(); i++)\n\t  b+=s[i];\n\n\tif(s[pos-1] == '+') return solve(a)+solve(b);\n\tif(s[pos-1] == '-') return solve(a)-solve(b);\n\tif(s[pos-1] == '*') return solve(a)*solve(b);\n\tif(s[pos-1] == '/') return solve(a)/solve(b);\n       \n      }\n    }\n  }\n\n}\n\nstring make(string s){\n  string out = \"\";\n\n  for(int i = 0; i < s.length()-1; i++)\n    out += s[i];\n\n  return out;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> str;\n    str = make(str);\n    cout << solve(str) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nclass Parser{\n    public:\n\n    string s;\n    int i, n;\n\n    Parser(string s): s(s) {}\n\n    int parse(){\n        i = 0;\n        n = s.length();\n        return expr();\n    }\n\n    private:\n\n    int expr(){\n        int ret = term();\n        while(s[i] != '='){\n            if(s[i] == '+'){\n                i++;\n                ret += term();\n            }else if(s[i] == '-'){\n                i++;\n                ret -= term();\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int term(){\n        int ret = num();\n        while(i < n){\n            if(s[i] == '*'){\n                i++;\n                if(s[i] == '('){\n                    i++;\n                    ret *= expr();\n                    i++;\n                }else{\n                    ret *= num();\n                }\n            }else if(s[i] == '/'){\n                i++;\n                if(s[i] == '('){\n                    i++;\n                    ret /= expr();\n                    i++;\n                }else{\n                    ret /= num();\n                }\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int num(){\n        int ret = s[i] - '0';\n        i++;\n        return ret;\n    }\n\n};\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        string s;\n        cin >> s;\n        Parser p = Parser(s);\n        cout << p.parse() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  while(n--){\n    string s;\n    int p=0;\n    cin>>s;s.pop_back();\n    cout<<expression(s,p)<<endl;\n  }\n  return 0;\n}\n\n/*\nverified on 2017/04/26\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id=0109\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x);\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\twhile (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\twhile (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\n\tif(str[i] != '(')val1 = number(str, i);\n\tif(str[i] == '(') {\n\t\ti++;\n\t\tval1 += siki(str, i);\n\t\ti += 1;\n\t}\n\n\t\n\t\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tval1 = val1 * 10;\n\t\t\tval1 += number(str, i);\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctype.h>\n \nstd::string s;\nstd::string::iterator it;\n \nint term();\nint fact();\n \n// ?¨????\nint expr()\n{\n    int p = term();\n     \n    // + or -\n    while( *it == '+' || *it == '-' ){\n        if( *it == '+' ){\n            it++;\n            int q = term();\n            p += q;\n        }\n        else{\n            it++;\n            int q = term();\n            p -= q;\n        }\n    }\n     \n    return p;\n}\n \n// ???????¨????\nint term()\n{\n    int p = fact();\n     \n    while( *it == '*' || *it == '/' ){\n        if( *it == '*' ){\n            it++;\n            int q = fact();\n            p *= q;\n        }\n        else{\n            it++;\n            int q = fact();\n            p /= q;\n        }\n    }\n     \n    return p;\n}\n \n// ??¬??§??? or ??°???\nint fact()\n{\n    if( *it == '(' ){\n        it++;\n        int p = expr();\n        it++;\n         \n        return p;\n    }\n    else{\n        int p = 0;\n         \n        while( isdigit( *it ) ){\n            p *= 10;\n            p += *it - '0';\n            it++;\n        }\n         \n        return p;\n    }\n}\n \nint main()\n{\n    int n;\n    std::cin >> n;\n     \n    while( n-- ){\n        std::cin >> s;\n        s[s.size()-1] = '\\0';\n        it = s.begin();\n        std::cout << expr() << std::endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint atoi(string s);\nint calc(string in);\n\nint main() {\n\tint n; cin >> n;\n\tfor (int lop = 0; lop<n; lop++) {\n\t\tstring in; cin >> in;\n\t\tcout << calc(in.substr(0, in.size() - 1)) << endl;\n\t}\n}\n\nint calc(string in) {\n\t//cout<<in<<endl;\n\tbool f = true;\n\tfor (int i = 1; i<in.size(); i++) {\n\t\tif (in[i]<'0' || '9'<in[i]) {\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) {\n\t\tif (in[0] == '-')\n\t\t\treturn -atoi(in.substr(1, in.size() - 1));\n\t\tif (in[0] == '+')\n\t\t\treturn atoi(in.substr(1, in.size() - 1));\n\t\treturn atoi(in);\n\t}\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (in[i] == '+' || in[i] == '-' || in[i] == '(' || in[i] == ')') {\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!f) {\n\t\tint num = 1, start = 0;\n\t\t// if op * , else /\n\t\tbool op = true;\n\t\tfor (int i = 0; i<in.size(); i++) {\n\t\t\tif (in[i] == '*' || in[i] == '/') {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= atoi(in.substr(start, i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= atoi(in.substr(start, i - start));\n\t\t\t\tstart = i + 1;\n\t\t\t\tif (in[i] == '*')\n\t\t\t\t\top = true;\n\t\t\t\telse\n\t\t\t\t\top = false;\n\t\t\t}\n\t\t\tif (i == in.size() - 1) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= atoi(in.substr(start, 1 + i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= atoi(in.substr(start, 1 + i - start));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (in[i] == '(' || in[i] == ')') {\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) {\n\t\tint start = 0, num = 0;\n\t\t// if op + , else - \n\t\tbool op = true;\n\t\tfor (int i = 0; i<in.size(); i++) {\n\t\t\tif (in[i] == '+' || in[i] == '-') {\n\t\t\t\tif (op)\n\t\t\t\t\tnum += calc(in.substr(start, i - start));\n\t\t\t\telse\n\t\t\t\t\tnum -= calc(in.substr(start, i - start));\n\t\t\t\tstart = i + 1;\n\t\t\t\tif (in[i] == '+')\n\t\t\t\t\top = true;\n\t\t\t\telse\n\t\t\t\t\top = false;\n\t\t\t}\n\t\t\tif (i == in.size() - 1) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum += calc(in.substr(start, 1 + i - start));\n\t\t\t\telse\n\t\t\t\t\tnum -= calc(in.substr(start, 1 + i - start));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tint level = 1;\n\t//cout<<in<<endl;\n\tif (in[0] != '(' || in[in.size() - 1] != ')')\n\t\tf = true;\n\tif (!f) {\n\t\tfor (int i = 1; i < in.size() - 1; i++) {\n\t\t\tif (in[i] == '(')\n\t\t\t\tlevel++;\n\t\t\tif (in[i] == ')')\n\t\t\t\tlevel--;\n\t\t\tif (level == 0) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!f)\n\t\t\treturn calc(in.substr(1, in.size() - 2));\n\t}\n\tlevel = 0;\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (in[i] == '(') {\n\t\t\tlevel++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] == ')') {\n\t\t\tlevel--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0 && (in[i] == '+' || in[i] == '-'))\n\t\t\tf = false;\n\t}\n\tif (f) {\n\t\t//cout<<in<<endl;\n\t\tlevel = 0;\n\t\tint start = 0;\n\t\tint num = 1;\n\t\tbool op = true;\n\t\tfor (int i = 0; i<in.size(); i++) {\n\t\t\tif (i == in.size() - 1) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= calc(in.substr(start, 1 + i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= calc(in.substr(start, 1 + i - start));\n\t\t\t}\n\t\t\tif (in[i] == '(') {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (in[i] == ')') {\n\t\t\t\tlevel--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (level == 0 && (in[i] == '*' || in[i] == '/')) {\n\t\t\t\tif (op)\n\t\t\t\t\tnum *= calc(in.substr(start, i - start));\n\t\t\t\telse\n\t\t\t\t\tnum /= calc(in.substr(start, i - start));\n\t\t\t\tstart = i + 1;\n\t\t\t\tif (in[i] == '*')\n\t\t\t\t\top = true;\n\t\t\t\telse\n\t\t\t\t\top = false;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tint start = 0, num = 0;\n\tlevel = 0;\n\tbool op = true;\n\tfor (int i = 0; i<in.size(); i++) {\n\t\tif (i == in.size() - 1) {\n\t\t\tif (op)\n\t\t\t\tnum += calc(in.substr(start, 1 + i - start));\n\t\t\telse\n\t\t\t\tnum -= calc(in.substr(start, 1 + i - start));\n\t\t}\n\t\tif (in[i] == '(') {\n\t\t\tlevel++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[i] == ')') {\n\t\t\tlevel--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0 && (in[i] == '+' || in[i] == '-')) {\n\t\t\tif (op)\n\t\t\t\tnum += calc(in.substr(start, i - start));\n\t\t\telse\n\t\t\t\tnum -= calc(in.substr(start, i - start));\n\t\t\tstart = i + 1;\n\t\t\tif (in[i] == '+')\n\t\t\t\top = true;\n\t\t\telse\n\t\t\t\top = false;\n\t\t}\n\t}\n\treturn num;\n}\n\nint atoi(string s) {\n\tint n = 0;\n\tfor (int i = 0; i<s.size(); i++) {\n\t\tn = n * 10 + s[i] - '0';\n\t}\n\treturn n;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\nstring str,t;\n\nstring calc(string s){\n\t\n\tvector<char> otr;\n\totr.reserve(1000);\n\tvector<int> ond;\n\tond.reserve(1000);\n\tstring tmp;\n\tsize_t now = 0;\n\t\n\twhile( ~s.find_first_of(\"*/-+=\",now) ){\n\t\ttmp = s.substr(now,s.find_first_of(\"*/-+=\",now)-now);\n\t\tond.push_back( atoi(tmp.c_str() ) );\n\t\totr.push_back( s[s.find_first_of(\"*/-+=\",now)] );\n\t\tnow = s.find_first_of(\"*/-+=\",now)+1;\n\t}\n\n\tfor(int i=0;i<otr.size();i++){\n\t\tif(otr[i]=='*'){\n\t\t\tond[i] = ond[i] * ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}else if(otr[i]=='/'){\n\t\t\t//ond[i] = ond[i] / ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}\n\t}\n\n\t/*cout << ond[0];\n\tfor(int j=0;j<otr.size();j++){\n\t\tif(otr[j]=='=')break;\n\t\tcout << \" \" << otr[j] << \" \";\n\t\tcout << ond[j+1];\n\t}\n\tcout << endl;*/\n\t\n\tfor(int i=0;i<otr.size();i++){\n\t\tif(otr[i]=='+'){\n\t\t\tond[i] = ond[i] + ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}else if(otr[i]=='-'){\n\t\t\tond[i] = ond[i] - ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}\n\t}\n\tstringstream ret;\n\tret << ond[0];\n\treturn ret.str();\n}\n\nstring parent(string s){\t\n\tint st,en;\n\twhile( ~s.find(\"(\") ){\n\t\tst = s.find(\"(\");\n\t\ten = s.find(\")\");\n\t\tt = s.substr(st+1,en-st-1);\n\t\ts.replace( st , en-st+1 , parent(t+string(\"=\")));\n\t}\n\treturn calc(s);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(cin >> str){\n\t\t/*\n\t\tif(~s.find(\"(\")){\n\t\t\tst = s.find(\"(\");\n\t\t\ten = s.rfind(\")\");\n\t\t\tt = s.substr(st+1,en-st-1);\n\t\t}*/\n\t\tcout << parent(str) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  char c = buf[pos];\n\n  if ('0' <= c && c <= '9') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  if (buf[pos] == '*') {\n    Pair q = EvalExp(pos+1);\n    return Pair(p.first*q.first, q.second);\n  }\n\n  if (buf[pos] == '/') {\n    Pair q = EvalExp(pos+1);\n    return Pair(p.first/q.first, q.second);\n  }\n\n  return p;\n}\n\nPair EvalExp(int pos) {\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n  int res = p.first;\n  while (1) {\n    if (buf[pos] == '=' || buf[pos] == ')') {\n      return Pair(res, pos);\n    }\n\n    Pair q = EvalTerm(pos+1);\n    if (buf[pos] == '+') res += q.first;\n    else if (buf[pos] == '-') res -= q.first;\n    else assert(0);\n\n    pos = q.second;\n  }\n\n}\n\nint main() {\n  scanf(\"%d\", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint digit(){\n  return S[cur++]-'0';\n}\n\nint number(){\n  int n=digit();\n  while(cur<S.size()&&isdigit(S[cur])){\n    n=n*10+digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor(){\n  if(isdigit(S[cur]))return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint term(){\n  int t=factor();\n  for(;cur<S.size()&&(S[cur]=='*'||S[cur]=='/');){\n    if(S[cur++]=='*')t*=factor();\n\telse t/=factor();\n  }\n  return t;\n}\n\nint expression(){\n  int t=term();\n  for(;cur<S.size()&&(S[cur]=='+'||S[cur]=='-');){\n    if(S[cur++]=='+')t+=term();\n\telse t-=term();\n  }\n  return t;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  for(;n--;){\n    cur=0;\n    cin>>S;\n\tcout<<expression()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x) << endl;\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\tif (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\tif (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\tif(str[i] != '(')val1 = number(str, i);\n\telse if(str[i] == '(') {\n\t\ti++;\n\t\tval1 += siki(str, i);\n\t\ti += 1;\n\t}\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tint val2 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif ( str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tint now = i;\n\t\t\tval2 += number(str, i);\n\t\t\tval1 = val1 * pow(10,i - now);\n\t\t\tval1 += val2;\n\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include<iostream>\n#include <cctype>\n\nusing namespace std;\n\n#if 0\n\n08-182020の方のものを参照。termの書き換えがわからなかった。\n\n#endif\n\nstring S;\nsize_t cur = 0; // 解析開始位置cursor の略記\n\n// 1 文字読んでcur を進める\n// 意味:次のreadchar では、次の文字を読む\nchar readchar() {\n\tassert(cur < S.size());\n\tchar ret = S[cur];\n\tcur += 1;\n\treturn ret;\n\t// return S[cur++]; と一行で書くこともできる\n}\nchar peek() { // 1 文字読むがcur を進めない\n\tassert(cur < S.size());\n\treturn S[cur];\n}\n\n\nint factorial(int n) {\n\tassert(n > 0); // (*)\n\tif (n == 1) return 1;\n\treturn n * factorial(n-1);\n}\n\nint digit() {\n\t//assert(isdigit(peek())); // S[cur] が数字であることを確認\n\tint n = readchar() - '0'; // ’0’ を0 に変換\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(peek())) // 次も数字か1 文字先読\n\t\tn = n*10 + digit();\n\treturn n;\n}\nint expression(); // 前方宣言\nint factor() {\n\tif (peek() != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(peek() == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint term() {\n\tint a = factor();\n\twhile (cur < S.size()&& (peek() == '*' || peek() == '/')) {\n\t\tchar op = readchar();\n\t\tint b = factor();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\n\nint expression() {\n\tint a = term();\n\twhile ((cur < S.size())&& (peek() == '+' || peek() == '-')) {\n\t\tchar op = readchar();\n\t\tint b = term();\n\t\tif (op == '+') a += b; else a -= b;\n\t}\n\treturn a;\n}\n\n\n\nint parse(){\n\treturn expression();\n}\n\nint main() {\n\t//int a = parse();\n\t//cout << a << endl;\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1); // 最後の=を無視\n\t\tcout << expression() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  char c = buf[pos];\n\n  if ('0' <= c && c <= '9') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  if (buf[pos] == '*') {\n    Pair q = EvalExp(pos+1);\n    return Pair(p.first * q.first, q.second);\n  }\n\n  if (buf[pos] == '/') {\n    Pair q = EvalExp(pos+1);\n    return Pair(p.first/q.first, q.second);\n  }\n\n  return p;\n}\n\nPair EvalExp(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n  int res = p.first;\n  while (1) {\n\n    if (buf[pos] == '=' || buf[pos] == ')') {\n      return Pair(res, pos);\n    }\n\n    Pair q = EvalTerm(pos+1);\n    if (buf[pos] == '+') res += q.first;\n    else if (buf[pos] == '-') res -= q.first;\n    else assert(0);\n\n    pos = q.second;\n  }\n\n}\n\nint main() {\n  scanf(\"%d\", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Factor();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint calc(string s)\n{\n\tvi v;\n\tREP(i, s.size())\n\t{\n\t\tif (s[i] == '+') v.push_back(0);\n\t\telse if (s[i] == '-') v.push_back(1);\n\t\telse if (s[i] == '*') v.push_back(2);\n\t\telse if (s[i] == '/') v.push_back(3);\n\t\telse\n\t\t{\n\t\t\tint tmp = s[i] - '0';\n\t\t\tint t = i+1;\n\t\t\twhile (isdigit(s[t]))\n\t\t\t{\n\t\t\t\ttmp = tmp * 10 + s[t] - '0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\ti = t - 1;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t}\n\n\twhile (v.size() > 1)\n\t{\n\t\tfor (int i = 1; i < v.size();i+=2)\n\t\t{\n\t\t\tif (v[i]==2)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] * v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\telse if (v[i] == 3)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] / v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < v.size(); i += 2)\n\t\t{\n\t\t\tif (v[i] == 0)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] + v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (v[i] == 1)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] - v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tnext:;\n\t\t}\n\t}\n\treturn v[0];\n}\n\nint solve(string s)\n{\n\twhile (1)\n\t{\n\t\tif (find(ALL(s), '(') == s.end())\n\t\t{\n\t\t\treturn calc(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring tmp;\n\t\t\tREP(i, s.size())\n\t\t\t{\n\t\t\t\tif (s[i] != '(') tmp.push_back(s[i]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = s.size()-1;; j--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[j] == ')')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t = solve(s.substr(i+1, j - i - 1));\n\t\t\t\t\t\t\ttmp += to_string(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn solve(tmp);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint sets;\n\tstring s;\n\tcin >> sets;\n\tREP(set, sets)\n\t{\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << solve(s) << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\n\n#include<cassert>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nstring S;\nint cur = 0;//?§£???????§???????\n\nint expression();//????????£?¨?\n\nint digit(){\n\t// assert(isdigit(S[cur]));\n\t// cout<<\"S[cur]=\"<<S[cur]<<endl;;\n\tint n = S[cur++] - '0';\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur]))n = n*10+digit();\n\treturn n;\n}\n\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\t// assert(S[cur++]==')');\n\treturn n;\n}\n\nint term(){\n\tint a = factor();\n\twhile(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op=='*')a*=b;else a/=b;\n\t}\n\treturn a;\n}\n\nint expression() {\n\tint a = term();\n\twhile (cur<S.size() && (S[cur] == '+' || S[cur] == '-')) { // ?¶???????????????????????¶???????\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+')a+=b;else a-=b;\n\t}\n\treturn a;\n}\n\nint main(){\n\tint N;\n\tint ans[50];\n\tcin>>N;\n\trep(i,N){\n\t\tcur=0;\n\t\tcin>>S;\n\t\tS.resize(S.size()-1);\n\t\tans[i]=expression();\n\t}\n\trep(i,N)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint calc2(char *eq){\n\tint c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nint calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tint k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%d%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tint i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\nusing namespace std;\n\nstring S;\nint cur = 0;\n\nint digit() {\n  return S[cur++] - '0';\n}\n\nint number() {\n  int n = digit();\n  while(cur < S.size() && isdigit(S[cur])) n = n * 10 + digit();\n  return n;\n}\n\nint expression();\n\nint factor() {\n  if(S[cur] != '(') return number();\n  cur++;\n  int n = expression();\n  cur++;\n  return n;\n}\n\nint term() {\n  int n = factor();\n  while(cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    if(op == '*') n *= factor(); else n /= factor();\n  }\n  return n;\n}\n\nint expression() {\n  int n = term();\n  while(cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++];\n    if(op == '+') n += term(); else n -= term();\n  }\n  return n;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for(int i = 0;i < n;i++) {\n    cur = 0;\n    cin >> S;\n    S.erase(S.size() - 1);\n    cout << expression() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1 && !is_all_digit(in[0])) {\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\treturn(stoi(in[0]));\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint roc = 0;\nstring s;\nint insu();\nint kou();\nint shiki();\n\nint insu() {\n\tif(s[roc] >= '0' && s[roc] <= '9') {\n\t\tint j = roc;\n\t\twhile(roc < s.size() && s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\treturn stoi(s.substr(j, roc - j));\n\t} else {\n\t\t++roc;\n\t\tint res = shiki();\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint kou() {\n\tint res = insu();\n\twhile (s[roc] == '*' || s[roc] == '/') {\n\t\tif(s[roc] == '*') {\n\t\t\t++roc;\n\t\t\tres *= insu();\n\t\t}\n\t\telse {\n\t\t\t++roc;\n\t\t\tres /= insu();\n\t\t}\n\t}\n\treturn res;\n}\n\nint shiki() {\n\tint res = kou();\n\twhile (s[roc] == '+' || s[roc] == '-') {\n\t\tif(s[roc] == '+') {\n\t\t\t++roc;\n\t\t\tres += kou();\n\t\t}\n\t\telse {\n\t\t\t++roc;\n\t\t\tres -= kou();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n;\n\tcin>>n;\n\tREP(roop, n) {\n\t\troc = 0;\n\t\tcin>>s;\n\t\ts.pop_back();\n\t\tcout<<shiki()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\nauto term = eval(factor, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nint calc(string s){\n    while(1){\n        vector<pair<int, int>> vv;\n        int depth = 0;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '('){\n                vv.push_back(pair<int, int>(i, ++depth));\n            }else if(s[i] == ')'){\n                --depth;\n            }\n        }\n        if(vv.size() != 0){\n            sort(vv.begin(), vv.end(), [](auto a, auto b){return a.second != b.second ? a.second > b.second : a.first < b.first;});\n            int pos;\n            for(pos = vv[0].first; s[pos] != ')'; pos++);\n            int ret = calc(s.substr(vv[0].first + 1, pos - vv[0].first - 1));\n            string t = s.substr(0, vv[0].first) + to_string(ret) + s.substr(pos + 1);\n            s = t;\n        }else{\n            while(1){\n                map<char, vector<int>> m;\n                for(int i = 0; i < s.size(); i++){\n                    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') m[s[i]].push_back(i);\n                }\n                vector<int> v;\n                if(m.find('*') != m.end() || m.find('/') != m.end()){\n                    for(int pos : m['*']) v.push_back(pos);\n                    for(int pos : m['/']) v.push_back(pos);\n                }else{\n                    for(int pos : m['+']) v.push_back(pos);\n                    for(int pos : m['-']) v.push_back(pos);\n                }\n                if(v.size() == 0 || (v.size() == 1 && v[0] == 0)) break;\n                sort(v.begin(), v.end());\n                string t;\n                int pos = v[0];\n                string num[2];\n                int tmp;\n                for(int j = pos - 1; 0 <= j; j--){\n                    if('0' <= s[j] && s[j] <= '9'){\n                        num[0] += s[j];\n                    }else{\n                        for(int k = 0; k <= j; k++){\n                            t += s[k];\n                        }\n                        break;\n                    }\n                }\n                for(int j = pos + 1; j <= s.size(); j++){\n                    if('0' <= s[j] && s[j] <= '9'){\n                        num[1] += s[j];\n                    }else{\n                        tmp = j;\n                        break;\n                    }\n                }\n                int add;\n                switch(s[pos]){\n                    case '+':\n                        add = stoi(num[0]) + stoi(num[1]);\n                        break;\n                    case '-':\n                        add = stoi(num[0]) - stoi(num[1]);\n                        break;\n                    case '*':\n                        add = stoi(num[0]) * stoi(num[1]);\n                        break;\n                    case '/':\n                        add = stoi(num[0]) / stoi(num[1]);\n                        break;\n                }\n                t += to_string(add);\n                for(int j = tmp; j < s.size(); j++) t += s[j];\n                s = t;\n            }\n            return stoi(s);\n        }\n    }\n}\n    \nint main(){\n    int N;\n    cin >> N;\n    for(int pomu = 0; pomu < N; pomu++){\n        string s;\n        cin >> s;\n        s = s.substr(0, s.size() - 1);\n        cout << calc(s) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nstring toRPN(string s){\n    stack<char> ope;\n    string ret=\"\";\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ) ret+=s[i];\n        \n        else{\n            if(s[i]=='('){\n                ope.push(s[i]);\n                \n            }else if(s[i]==')'){\n                while(ope.top()!='('){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else{\n                return \"invalid\";\n            }\n        }\n    }\n    while(ope.size()){\n        ret+=ope.top();\n        ope.pop();\n    }\n\n    return ret;\n}\n\n\nstring solveRPN(string s){\n    stack<int> stk;\n\n    \n    for(int i=0;i<s.size();i++){\n        if( isdigit(s[i]) )stk.push( s[i]-'0'  );\n        else{\n            if(stk.size()>-2){\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            \n            if(s[i]=='+')stk.push(a+b);\n            if(s[i]=='-')stk.push(a-b);\n            if(s[i]=='*')stk.push(a*b);\n            if(s[i]=='/')stk.push(a/b);\n            }\n        }\n    }\n    \n    stringstream ret;\n    ret<<stk.top();\n    \n    return ret.str();\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        string s;\n        cin>>s;\n        \n        s.erase(s.size()-1);\n        \n        s=toRPN(s);\n        s=solveRPN(s);\n    \n        cout<<s<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  char c = buf[pos];\n  if ('0' <= c && c <= '9') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  char c = buf[pos];\n  if (c == '*') {\n    Pair q = EvalTerm(pos+1);\n    return Pair(p.first*q.first, q.second);\n  }\n\n  if (c == '/') {\n    Pair q = EvalTerm(pos+1);\n    return Pair(p.first/q.first, q.second);\n  }\n\n  return p;\n}\n\nPair EvalExp(int pos) {\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n\n  char c = buf[pos];\n  int res = p.first;\n  if (c == '=' || c == ')') {\n    return Pair(res, pos);\n  }\n\n  Pair q = EvalExp(pos+1);\n  if (c == '+') res += q.first;\n  else if (c == '-') res -= q.first;\n  else assert(0);\n\n  return Pair(res, q.second);\n}\n\nint main() {\n  scanf(\"%d \", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nstring S;\nsize_t cur;\n\nchar readchar() {\n  assert(cur < S.size());\n  return S[cur++];\n}\nchar peek() {\n  assert(cur < S.size());\n  return S[cur];\n}\nint digit() {\n  assert(isdigit(peek()));\n  int n = readchar() - '0';\n  return n;\n}\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(peek()))\n    n = n*10 + digit();\n  return n;\n}\nint expression();\nint factor() {\n  if (peek() != '(')\n    return number();\n  cur += 1;\n  int n = expression();\n  assert(peek() == ')');\n  cur += 1;\n  return n;\n}\nint term() {\n  int a = factor();\n  while (cur < S.size() && (peek() == '*' || peek() == '/')) {\n    char op = readchar();\n    int b = factor();\n    if (op == '*')\n      a *= b;\n    else\n      a /= b;\n  }\n  return a;\n}\nint expression() {\n  int a = term();\n  while (cur < S.size() && (peek() == '+' || peek() == '-')) {\n    char op = readchar();\n    int b = term();\n    if (op == '+')\n      a += b;\n    else\n      a -= b;\n  }\n  return a;\n}\n\nint main() {\n  int N; cin >> N;\n  for (int i = 0; i < N; i++) {\n    cur = 0;\n    cin >> S;\n    S.resize(S.size()-1);\n    cout << expression() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\t//std::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tint ret = expression(begin);\n\t\tconsume(begin,')');\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\nstring str;\n\nint subj(int s, int e){\n\tint n = 0;\n\tfor(int i = s;i < e;i++){\n\t\tif(str[i] == '(')n++;\n\t\tif(str[i] == ')'){if(n == 0)return i;n--;}\n\t}\n}\n\nint calc(int s, int e, int m){\n\tint p = 0;\n\tfor(p = s;p < e && str[p] >= '0' && str[p] <= '9';p++);\n\tint a = atoi(str.substr(s, p-s).c_str());\n\tif(str[s] == '('){\n\t\tp = subj(s+1, e);\n\t\ta = calc(s+1, p, 0);p++;\n\t\t//cout << \"p = \" << s << p << \" \";\n\t}\n\tif(m%10 == 1)a *= m/10;\n\tif(m%10 == 2)a = (m/10) / a;\n\t\n\tif(str[p] == '+')return a + calc(p+1, e, 0);\n\tif(str[p] == '-')return a - calc(p+1, e, 0);\n\tif(str[p] == '*')return calc(p+1, e, a*10+1);\n\tif(str[p] == '/')return calc(p+1, e, a*10+2);\n\tif(str[p] == '=' || str[p] == ')')return a;\n\t\n\treturn 0;\n}\n\nint main(){\n\tint n;cin >> n;\n\twhile(n--){\n\t\tcin >> str;\n\t\tcout << calc(0, str.size(), 0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#define _LIBCPP_DEBUG 0\n#else\n#define DEB 0\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vp = vector<Pl>;\nusing vvp = vector<vp>;\n\nconst int INF = 1<<29;\nconst long long LINF=1LL<<59;\n\nclass ParseExpression{\n  public:\n  using Result = pair<int,int>; // value, index\n  int idx, val;\n  ParseExpression(const string& s){\n    // expression := factor{+factor}*\n    // factor     := term{*term}*\n    // term       := (expression)|Number\n    tie(val,idx) = expression(s);\n  }\n  int op(char optr,int lhs,int rhs){\n    if(optr=='+') return lhs+rhs;\n    if(optr=='-') return lhs-rhs;\n    if(optr=='*') return lhs*rhs;\n    if(optr=='/') return lhs/rhs;\n    return -1; // undefined\n  }\n  Result expression(const string& s,int p=0){\n    Result res = factor(s,p);\n    p = res.second;\n    while(p<s.size() && (s[p] == '+' || s[p] == '-')){\n      Result right = factor(s,p+1);\n      res.first = op(s[p],res.first,right.first);\n      p = right.second;\n    }\n    res.second = p;\n    return res;\n  }\n  Result factor(const string& s,int p=0){\n    Result res = term(s,p);\n    p = res.second;\n    while(p<s.size() && (s[p] == '*' || s[p] == '/')){\n      Result right = term(s,p+1);\n      res.first = op(s[p],res.first,right.first);\n      p = right.second;\n    }\n    res.second = p;\n    return res;\n  }\n  Result term(const string& s,int p=0){\n    if(s[p]=='('){\n      Result res = expression(s,p+1);\n      res.second++; // skip '('\n      return res;\n    }else{\n      int val = 0;\n      while(isdigit(s[p])) val = val * 10 + (s[p++]-'0');\n      return Result(val, p);\n    }\n  }\n};\n\nint main(){\n  int Q; cin >> Q ;\n  rep(i,Q){\n    string s;\n    cin >> s;\n    cout << ParseExpression(s).val << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr!=s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr!=s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\tif(xr==s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\t//consume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\t//consume(begin,'(');\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\t//consume(begin,')');\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n<expr>   ::= <term> [ ('+'|'-') <term> ]*\n<term>   ::= <factor> [ ('*'|'/') <factor> ]*\n<factor> ::= <number> | '(' <expr> ')'\n<number> :== 1つ以上の数字\n*/\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int j = 0; j < n; j++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tint i = 0;\n\t\t\n\t\tcout << expr(str, i) << endl;\n\t}\n\t\n\treturn 0;\n}\n\nint expr(string& s, int& i){\n\tint val = term(s, i);\n\n\twhile(s[i] == '+' || s[i] == '-'){\n\t\tchar op = s[i++];\n\t\tint val2 = term(s, i);\n\t\tif(op == '+')\n\t\t\tval += val2;\n\t\telse\n\t\t\tval -= val2;\n\t}\n\t\n\treturn val;\n}\n\nint term(string& s, int& i){\n\tint val = factor(s, i);\n\twhile(s[i] == '*' || s[i] == '/'){\n\t\tchar op = s[i++];\n\t\tint val2 = factor(s, i);\n\t\tif(op == '*')\n\t\t\tval *= val2;\n\t\telse\n\t\t\tval /= val2;\n\t}\n\t\n\treturn val;\n}\n\nint factor(string& s, int& i){\n\tif(isdigit(s[i]))\n\t\treturn number(s, i);\n\t\n\ti++;\n\tint ret = expr(s, i);\n\ti++;\n\t\n\treturn ret;\n}\n\nint number(string& s, int& i){\n\tint n = s[i++] - '0';\n\twhile(isdigit(s[i]))\n\t\tn = n * 10 + s[i++] - '0';\n\t\n\treturn n;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include <map>\n#include <fstream>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <assert.h>\n#include <complex>\n#include <omp.h>\nusing namespace std;\n#define eps 0.000001\n#define LONG_INF 100000000000000\n#define GOLD 1.61803398874989484820458\n#define seg_size 65536*4\n#define REP(i,n) for(long long i = 0;i < n;++i)\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ntypedef string::const_iterator State;\nint expression(State& begin);\nint term(State& begin);\nint number(State& begin);\nint factor(State& begin);\nint factor(State& begin) {\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n}\nint expression(State& begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\nint term(State& begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nint number(State& begin) {\n\tint ret = 0;\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint main() {\n\tlong long n;\n\tcin >> n;\n\tREP(imt, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tState begin = s.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\ntypedef long long ll;\n\nint it, n;\nstring input;\n\nll expr();\nll term();\nll fact();\n\nll expr() {\n    int v = term();\n    while (input[it] == '+' || input[it] == '-') {\n        if (input[it++] == '+') {\n            v += term();\n        } else {\n            v -= term();\n        }\n    }\n    return v;\n}\n\nll term() {\n    int v = fact();\n    while (input[it] == '*' || input[it] == '/') {\n        if (input[it++] == '*') {\n            v *= term();\n        } else {\n            v = (int)trunc(1.0*v/term());\n            //v /= term();\n        }\n    }\n    return v;\n}\n\nll fact() {\n    int v = 0;\n    if (input[it] == '(') {\n        ++it; // '('\n        v = expr();\n        ++it; // ')'\n    } else {\n        while ('0' <= input[it] && input[it] <= '9') {\n            v = 10*v + input[it]-'0';\n            ++it;\n        }\n    }\n    return v;\n}\n\nint main() {\n    cin >> n;\n    rep (i,n) {\n        cin >> input;\n        it = 0;\n        cout << expr() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n    for (auto i : in)\n    {\n        if (!isdigit(i))\n            return false;\n    }\n    return true;\n}\nvector<string> split(string in)\n{\n    vector<string> spl;\n    int pos = 0;\n    if (in[pos] == '-')\n    {\n        pos++;\n        while (pos < in.size())\n        {\n            if (isdigit(in[pos]))\n            {\n                pos++;\n            }\n            else\n            {\n                break;\n            }\n        }\n        spl.push_back(in.substr(0, pos));\n        in.erase(0, pos);\n        pos = 0;\n    }\n    while (pos < in.size())\n    {\n        if (!isdigit(in[pos]))\n        {\n            if (pos != 0)\n            {\n                spl.push_back(in.substr(0, pos));\n                in.erase(0, pos);\n                pos = 0;\n            }\n            else\n            {\n                if (in[0] == '(')\n                {\n                    int cnt = 1;\n                    int r_pos = 1;\n                    for (r_pos = 1; r_pos < in.size(); r_pos++)\n                    {\n                        if (in[r_pos] == '(')\n                            cnt++;\n                        if (in[r_pos] == ')')\n                            cnt--;\n                        if (cnt == 0)\n                            break;\n                    }\n                    spl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n                    in.erase(0, r_pos + 1);\n                    pos = 0;\n                    continue;\n                }\n                else if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n                {\n                    spl.push_back(in.substr(0, 1));\n                    in.erase(0, 1);\n                    pos = 0;\n                }\n            }\n        }\n        else\n        {\n            pos++;\n        }\n    }\n    if (in.size() != 0)\n        spl.push_back(in);\n    return spl;\n}\nint cal(string &in_str)\n{\n    auto in = split(in_str);\n    while (in.size() == 1 && !is_all_digit(in[0]))\n    {\n        in = split(in[0]);\n    }\n    while (in.size() != 1)\n    {\n        auto pos = in.begin();\n        while (pos != in.end())\n        {\n            if (*pos == \"*\")\n            {\n                pos--;\n                *pos = to_string(cal(*pos) * cal(*(pos + 2)));\n                in.erase(pos + 1, pos + 3);\n            }\n            else if (*pos == \"/\")\n            {\n                pos--;\n                *pos = to_string(cal(*pos) / cal(*(pos + 2)));\n                in.erase(pos + 1, pos + 3);\n            }\n            if (in.size() == 1)\n                break;\n            if (pos != in.end())\n                pos++;\n        }\n        pos = in.begin();\n        while (pos != in.end())\n        {\n            if (*pos == \"+\")\n            {\n                pos--;\n                *pos = to_string(cal(*pos) + cal(*(pos + 2)));\n                in.erase(pos + 1, pos + 3);\n            }\n            else if (*pos == \"-\")\n            {\n                pos--;\n                *pos = to_string(cal(*pos) - cal(*(pos + 2)));\n                in.erase(pos + 1, pos + 3);\n            }\n            if (in.size() == 1)\n                break;\n            if (pos != in.end())\n                pos++;\n        }\n    }\n    try\n    {\n        return (stoi(in[0]));\n    }\n    catch (const std::invalid_argument &a)\n    {\n        cerr << a.what() << input << endl;\n    }\n}\nint main()\n{\n\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        cin >> input;\n        input.erase(input.end() - 1);\n        cout << cal(input) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\nint parse();\nint digit();\nint number();\nint expression();\nint term();\nint factor();\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> S;\n\t\tcur = 0;\n\t\tS.resize(S.size() - 1);\n\t\tcout << expression() << endl;\n\t\tassert(cur == S.size());\n\t}\n\t\n\treturn 0;\n}\n\nint digit() {\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur++;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur]))\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint expression() {\n\tint a = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+') a += b;\n\t\telse a -= b;\n\t}\n\treturn a;\n\n}\n\nint parse() {\n\treturn expression();\n}\n\nint term() {\n\tint a = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif (op == '*') a *= b;\n\t\telse a /= b;\n\t}\n\treturn a;\n}\n\nint factor() {\n\tif (S[cur] != '(') return number();\n\tcur++;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur++;\n\treturn n;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <vector> \n#include <cstring>\n#include <stack>\n#include <iostream>\nusing namespace std;\n\n//¶ñÌ¡»\nvoid strcpy(char*a,char*b){\n\twhile(*a++=*b++);\n}\n\n//¶ñÌXy[Xð·×Äæè­\nvoid trim(char*str){\n\tif(' '==*str) strcpy(str,str+1);\n\tif(*str++) trim(str);\n}\n\n//¶ñðg[N²ÆÉØèoµ\nvoid token(char*str,std::vector<std::string>*data){\n\tchar pos;\n\tstd::string strpos=\"\";\n\twhile(pos=*str++){\n\t\tswitch (pos){\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tstrpos=strpos+pos;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tif(strpos!=\"\") data->push_back(strpos);\n\t\t\tstrpos=\"\";\n\t\t\tdata->push_back(\"+\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif(strpos!=\"\") data->push_back(strpos);\n\t\t\tstrpos=\"\";\n\t\t\tdata->push_back(\"-\");\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tif(strpos!=\"\") data->push_back(strpos);\n\t\t\tstrpos=\"\";\n\t\t\tdata->push_back(\"*\");\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tif(strpos!=\"\") data->push_back(strpos);\n\t\t\tstrpos=\"\";\n\t\t\tdata->push_back(\"/\");\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tif(strpos!=\"\") data->push_back(strpos);\n\t\t\tstrpos=\"\";\n\t\t\tdata->push_back(\"(\");\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tif(strpos!=\"\") data->push_back(strpos);\n\t\t\tstrpos=\"\";\n\t\t\tdata->push_back(\")\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(strpos!=\"\") data->push_back(strpos);\n}\n\n//g[NÅ é©mF\nbool isToken(std::string str){\n\tif(str==\"+\" || str==\"-\" || str==\"*\" || str==\"/\") return true;\n\treturn false;\n}\n\n//g[NÌ®`·é\nvoid tokenAna(std::vector<std::string>*in,std::vector<std::string>*out){\n\tif(isToken((*in)[0])){\n\t\t(*in)[1]=(*in)[0]+(*in)[1];\n\t}else{\n\t\tout->push_back((*in)[0]);\n\t}\n\n\tfor(int i=1;i<in->size();i++) {\n\t\tif(isToken((*in)[i])){\n\t\t\tif(isToken((*in)[i-1])){\n\t\t\t\t(*in)[i+1]=(*in)[i]+(*in)[i+1];\n\t\t\t}else{\n\t\t\t\tif((*in)[i-1]==\"(\"){\n\t\t\t\t\t(*in)[i+1]=(*in)[i]+(*in)[i+1];\n\t\t\t\t}else{\n\t\t\t\t\tout->push_back((*in)[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tout->push_back((*in)[i]);\n\t\t}\n\t}\n}\n\n\n\n//t|[h@ÉÏ··é½ßÌZqÌDæÊðè\nint Priority(const char*str){\n\tif(0==strcmp(str,\"+\")) return 10;\n\tif(0==strcmp(str,\"-\")) return 10;\n\tif(0==strcmp(str,\"*\")) return 20;\n\tif(0==strcmp(str,\"/\")) return 20;\n\treturn 0;\n}\n\n//®ðt|[h@ÉÏ·\nvoid Analyzer(std::vector<std::string>*data,std::vector<std::string>*out,int*i){\n\tstd::stack<const char*> stack;\n\n\tfor(;*i<data->size();(*i)++){\n\t\tif((*data)[*i]==\"+\" || (*data)[*i]==\"-\" || (*data)[*i]==\"*\" || (*data)[*i]==\"/\"){\n\t\t\twhile(stack.empty()==false && //false : X^bNÉlª é\n\t\t\t\t!(Priority((*data)[*i].c_str())>Priority(stack.top()))){ \n\t\t\t\t\tconst char*str=stack.top();//ÅãöÌlÌæ¾\n\t\t\t\t\tstack.pop();//ÅãöÌlÌí\n\t\t\t\t\tout->push_back(str);\n\t\t\t}\n\t\t\tstack.push((*data)[*i].c_str());//lÌÇÁ\n\t\t}else{\n\t\t\tif((*data)[*i]==\"(\"){\n\t\t\t\t*i=*i+1;\n\t\t\t\tAnalyzer(data,out,i);\n\t\t\t}else{\n\t\t\t\tif((*data)[*i]==\")\"){\n\t\t\t\t\tgoto end;\n\t\t\t\t}else{\n\t\t\t\t\tout->push_back((*data)[*i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nend:\n\twhile(stack.empty()==false){//false : X^bNÉlª é\n\t\tconst char*str=stack.top();//ÅãöÌlÌæ¾\n\t\tstack.pop();//ÅãöÌlÌí\n\t\tout->push_back(str);\n\t}\n}\n\n//t|[h@\\LÌvZ®ðvZ\ndouble calc(std::vector<std::string>*out){\n\tint c=out->size();\n\tstd::stack<double> stack;\n\tdouble j,k;\n\tfor(int i=0;i<c;i++){\n\t\t\tif((*out)[i]== \"+\"){\n\t\t\t\tj=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tk=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tstack.push(k+j);\n\t\t\t}else if((*out)[i]==\"-\"){\n\t\t\t\tj=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tk=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tstack.push(k-j);\n\t\t\t}else if((*out)[i]==\"*\"){\n\t\t\t\tj=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tk=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tstack.push(k*j);\n\t\t\t}else if((*out)[i]==\"/\"){\n\t\t\t\tj=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tk=stack.top();\n\t\t\t\tstack.pop();\n\t\t\t\tstack.push(k/j);\n\t\t\t}else{\n\t\t\t\tstack.push(atof((*out)[i].c_str()));\n\t\t\t}\n\t\t}\n\treturn stack.top();\n}\n\nint main(){\n//\tprintf(\"%s\\n\",\"((-10+-20)*((30+40))+1)*2 [Enter] ÌlÉüÍµÄ­¾³¢\");\n//\tprintf(\"--------------------------------------\\n\");\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tstd::vector<std::string> data;\n\t\tstd::vector<std::string> out;\n\n\t\t//¶ñÆµÄüÍ\n\t\tchar str[1024];\n\t\tscanf(\"%s\",str);\n\t\ttrim(str);\n\t\ttoken(str,&data);\n\t\t\n\t\tstd::vector<std::string> data2;\n\t\ttokenAna(&data,&data2);\n\n\t\t//{printf(\"g[NØèoµÊ : \");for(int a=0;a<data2.size();a++) printf(\"%s \",data2[a].c_str());}\n\t\t\n\t\tint c=0;\n\t\tAnalyzer(&data2,&out,&c);\n\n\t\t//{printf(\"\\nt|[h@ÉÏ· : \");for(int a=0;a<out.size();a++) printf(\"%s \",out[a].c_str());}\n\t\t//printf(\"\\nvZÊ : \");\n\t\tprintf(\"%g\\n\",calc(&out));\n\t\t//printf(\"--------------------------------------\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint exp(char a[]);\nint term(char a[]);\nint factor(char a[]);\nint p;\n\nint exp(char a[])\n{\n  int x = term(a);\n  while(a[p] == '+' || a[p] == '-'){\n    if(a[p] == '+'){\n      p++;\n      x += term(a);\n    } else {\n      p++;\n      x -= term(a);\n    }\n  }\n\n  return x;\n}\n\nint term(char a[])\n{\n  int x = factor(a);\n  while(a[p] == '*' || a[p] == '/'){\n    if(a[p] == '*'){\n      p++;\n      x *= factor(a);\n    } else {\n      p++;\n      x /= factor(a);\n    }\n  }\n\n  return x;\n}\n\nint factor(char a[])\n{\n  int x;\n  if(a[p] == '('){\n    p++;\n    x = exp(a);\n    if(a[p] == ')'){\n      p++;\n    }\n  } else {\n    x = (int)(a[p]-'0');\n    p++;\n  }\n\n  return x;\n}\n\nint main()\n{\n  int n;\n  char a[101];\n\n  while(cin>>n && n){\n    while(n--){\n      scanf(\"%s\", a);\n      p = 0;\n      cout << exp(a) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nstd::string find(std::vector<std::string>&v, long long a, bool b){\n\n\tstd::string res;\n\n\tif (b){\n\t\tfor (unsigned long long i = a - 1; i >= 0; i--){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!b){\n\t\tfor (unsigned long long i = a + 1; i < v.size(); i++){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nlong long tolong(std::string str){\n\n\tlong long res;\n\tstd::stringstream z;\n\n\tz << str;\n\tz >> res;\n\n\treturn res;\n\n}\n\nstd::string tostring(long long a){\n\n\tstd::string str;\n\tstd::stringstream z;\n\n\tz << a;\n\tz >> str;\n\n\treturn str;\n\n}\n\nstd::string keisan(std::string lhs, std::string rhs, long long t){\n\n\tlong long a, b, c;\n\n\ta = tolong(lhs);\n\tb = tolong(rhs);\n\n\tif (t == 1)c = a + b;\n\tif (t == 2)c = a - b;\n\tif (t == 3)c = a * b;\n\tif (t == 4)c = a / b;\n\n\treturn tostring(c);\n\n}\n\nstd::string keisan2(std::vector<std::string> &v){\n\n\tlong long res = 0;\n\n\tfor (unsigned long long i = 0, j = 0, c = 0; i < v.size(); i++){\n\n\t\tif (v[i] == \"(\"){\n\t\t\tif (c == 0)j = i;\n\t\t\tc++;\n\t\t}\n\n\t\tif (v[i] == \")\"){\n\t\t\tc--;\n\t\t\tif (c == 0){\n\t\t\t\tstd::vector<std::string>w;\n\t\t\t\tfor (unsigned long long p = j + 1; p < i; p++)w.push_back(v[p]);\n\t\t\t\tv[j] = keisan2(w);\n\t\t\t\tfor (unsigned long long p = j + 1; p <= i; p++)v[p] = \"T\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (unsigned long long i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"*\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 3);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"/\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 4);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (unsigned long long i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"+\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 1);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\n\t\tif (v[i] == \"-\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 2);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tv[v.size() - 1] = \"T\";\n\tfor (unsigned long long i = 0; i < v.size(); i++){\n\t\tif (v[i] != \"T\")res = tolong(v[i]);\n\t}\n\treturn tostring(res);\n\n}\n\n\nint main(){\n\n\tlong long n;\n\tstd::cin >> n;\n\n\tfor (long long i = 0; i < n; i++){\n\n\t\tstd::string str;\n\n\t\tstd::cin >> str;\n\n\t\tstd::vector<std::string> v;\n\n\t\tfor (unsigned long long i = 0, j = 0; i < str.size(); i++){\n\n\t\t\tif (!(str[i] >= '0'&&str[i] <= '9')){\n\t\t\t\tif (i - j > 0)v.push_back(str.substr(j, i - j));\n\t\t\t\tv.push_back(str.substr(i, 1));\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << keisan2(v) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,a,b) for(int i=(a); i<(b); i++)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst double EPS=1e-10;\n//int mod=1000000007\n\n\nstring s;\n\n\n\nint calc(int b,int e){\n\tvector<int> v;\n\tvector<char> ope;\n\tfor(int i=b; i<=e; i++){\n\t\tif(s[i]=='('){\n\t\t\tint o=1,c=0;\n\t\t\tfor(int j=i+1; j<=e; j++){\n\t\t\t\tif(s[j]=='(')o++;\n\t\t\t\tif(s[j]==')'){\n\t\t\t\t\tc++;\n\t\t\t\t\tif(o==c){\n\t\t\t\t\t\tint a=calc(i+1,j);\n\t\t\t\t\t\tv.pb(a);\n\t\t\t\t\t\ti=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(s[i]>='0'&&s[i]<='9'){\n\t\t\tfor(int j=i+1; j<=e; j++){\n\t\t\t\tif(s[j]<'0'||s[j]>'9'){\n\t\t\t\t\tstring t=s.substr(i,j);\n\t\t\t\t\tv.pb(atoi(t.c_str()));\n\t\t\t\t\ti=j-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tope.pb(s[i]);\n\t\t}\n\t}\n\tfor(int i=0; i<ope.size(); i++){\n\t\tif(ope[i]=='*'){\n\t\t\tv[i+1]=v[i]*v[i+1];\n\t\t\tv[i]=0;\n\t\t\tope[i]=(i==0?'+':ope[i-1]);\n\t\t}\n\t\tif(ope[i]=='/'){\n\t\t\tv[i+1]=v[i]/v[i+1];\n\t\t\tv[i]=0;\n\t\t\tope[i]=(i==0?'+':ope[i-1]);\n\t\t}\n\t}\n\tfor(int i=0; i<ope.size()-1; i++){\n\t\tif(ope[i]=='+'){\n\t\t\tv[0]+=v[i+1];\n\t\t}\n\t\tif(ope[i]=='-'){\n\t\t\tv[0]-=v[i+1];\n\t\t}\n\t}\n\treturn v[0];\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>s;\n\t\tcout<<calc(0,s.size()-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\nint number(State &begin);\nvoid consume(State &begin, char expected);\n\nint expression(State &begin){\n    int ret = term(begin);\n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret = factor(begin);\n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\n// begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n            << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    cin.ignore();\n    for(int i = 0; i < N; i++){\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n/*\n exp    ::= term    | exp  + term   | exp  - term\n term   ::= factor  | term * factor | term / factor\n factor ::= literal | (exp) | -factor\n*/\n\nint perseExp( string str );\nint perseTerm( string str );\nint perseFactor( string str );\n\nint perseExp( string str ){\n  int  nest = 0;\n  char op   = 0;\n  int pos;\n  for(int i=str.size()-1; i>0; i--){\n    char c = str[i];\n    if(nest == 0 && (c == '+' || c == '-')){\n      op = c;\n      pos = i;\n      break;\n    }\n    if(c == '('){\n      nest--;\n    }else if(c == ')'){\n      nest++;\n    }\n    if(nest < 0)\n      throw \"Error: perseExp\";\n  }\n  if(op == 0){\n    return perseTerm(str);\n  }else{\n    int op1 = perseExp( str.substr(0, pos) );\n    int op2 = perseTerm( str.substr(pos+1) );\n    if(op == '+'){\n      return op1 + op2;\n    }else{\n      return op1 - op2;\n    }\n  }\n}\n\nint perseTerm( string str ){\n  int nest = 0;\n  char op = 0;\n  int pos;\n  for(int i=str.size()-1; i>0; i--){\n    char c = str[i];\n    if(nest == 0 && (c == '*' || c == '/')){\n      op = c;\n      pos = i;\n      break;\n    }\n    if(c == '('){\n      nest--;\n    }else if(c == ')'){\n      nest++;\n    }\n    if(nest < 0)\n      throw \"Error: perseTerm\";\n  }\n  if(op == 0){\n    return perseFactor(str);\n  }else{\n    int op1 = perseTerm( str.substr(0, pos) );\n    int op2 = perseFactor( str.substr(pos+1) );\n    if(op == '*'){\n      return op1 * op2;\n    }else{\n      return op1 / op2;\n    }\n  }\n}\n\nint perseFactor( string str ){\n  if(str.size() == 0)\n    throw \"Parse Error: perseFactor\";\n\n  char firstStr = str[0];\n  if(firstStr == '('){\n    return perseExp( str.substr(1, str.size()-1) );\n  }else if(firstStr == '-'){\n    return -1 * perseFactor( str.substr(1) );\n  }else{\n    int num;\n    sscanf(str.c_str(), \"%d\", &num);\n    return num;\n  }\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  while(n-->0){\n    string str;\n    cin >> str;\n    str = str.substr(0, str.size()-1);\n    int ret = perseExp(str);\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n/*\ndigit : 0-9\nnumber : (digit)+\nblock :(\"(\"expression\")\"|number)\nterm : block((\"*\"|\"/\")block)*\nexpression : term((\"+\"|\"-\")term)*\n*/\n\nint getExpression(char* exp,int &it);\n\nbool isDigit(char *exp,int it)\n{\n    return '0' <= exp[it] && exp[it] <= '9';\n}\n\nint getDigit(char *exp,int &it)\n{\n    it++;\n    return (int)(exp[it-1]-'0');\n}\n\nint getNumber(char *exp,int &it)\n{\n    int r=0;\n    while(isDigit(exp,it))\n    {\n\tr*=10;\n\tr+=getDigit(exp,it);\n    }\n    return r;\n}\n\nint getBlock(char *exp,int &it)\n{\n    int r;\n    if (exp[it] == '(')\n    {\n\tit++;\n\tr = getExpression(exp,it);\n\tit++;\n\treturn r;\n    }\n    return getNumber(exp,it);\n}\n\nint getTerm(char *exp,int &it)\n{\n    int r=getBlock(exp,it);\n    while(exp[it] == '*' || exp[it] == '/')\n    {\n\tif (exp[it] == '*') {\n\t    it++;\n\t    r*=getBlock(exp,it);\n\t} else {\n\t    it++;\n\t    r/=getBlock(exp,it);\n\t}\n    }\n    return r;\n}\n\nint getExpression(char *exp,int &it)\n{\n    int r=getTerm(exp,it);\n    while (exp[it] == '+' || exp[it] == '-')\n    {\n\tif (exp[it] == '+')\n\t{\n\t    it++;\n\t    r+=getTerm(exp,it);\n\t} else {\n\t    it++;\n\t    r-=getTerm(exp,it);\n\t}\n    }\n    return r;\n}\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i=0; i<n; i++)\n    {\n\tint it=0;\n\tchar input[101] = \"\";\n\tscanf(\"%s\", input);\n\tprintf(\"%d\\n\", getExpression(input,it));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint64 exp(string&, int32&);\nint64 term(string&, int32&);\nint64 fact(string&, int32&);\nint64 number(string&, int32&);\n\nint64 exp(string& s, int32& p){\n\tint64 ret = term(s, p);\n\twhile(p < s.size()){\n\t\tif(s[p] == '+'){\n\t\t\tp++;\n\t\t\tret += term(s, p);\n\t\t}else if(s[p] == '-'){\n\t\t\tp++;\n\t\t\tret -= term(s, p);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint64 term(string& s, int32& p){\n\tint64 ret = number(s, p);\n\twhile(p < s.size()){\n\t\tif(s[p] == '*'){\n\t\t\tp++;\n\t\t\tret *= fact(s, p);\n\t\t}else if(s[p] == '/'){\n\t\t\tp++;\n\t\t\tret /= fact(s, p);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint64 fact(string& s, int32& p){\n\tint64 ret = 0;\n\tif(s[p] == '('){\n\t\tp++;\n\t\tret = exp(s, p);\n\t\tp++;\n\t}else{\n\t\tret = number(s, p);\n\t}\n\treturn ret;\n}\n\nint64 number(string& s, int32& p){\n\tint64 ret = 0;\n\twhile(isdigit(s[p])){\n\t\tret = ret*10+s[p]-'0';\n\t\tp++;\n\t}\n\treturn ret;\n}\nint main(void){\n\tint32 N;\n\tcin >> N;\n\n\tREP(i, N){\n\t\tstring s;\n\t\tint32 p = 0;\n\t\tcin >> s;\n\t\tcout << exp(s, p) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n  \n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    int ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n  \n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=factor(begin);\n  \n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n    return ret;\n  }\n  if(*begin=='-'){\n    begin++;\n    return -factor(begin);\n  }\n  return number(begin);\n}\n\nint number(State &begin){\n  int ret=0;\n  \n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass Parser {\n    string s;\n    ll pos;\n    ll E() {\n        ll res = T();\n        while (!end() && (nchar() == '+' || nchar() == '-')) {\n            if (nchar() == '+') {\n                read_char('+');\n                res += T();\n            }\n            else {\n                read_char('-');\n                res -= T();\n            }\n        }\n        return res;\n    }\n    ll T() {\n        ll res = number();\n        while (!end() && (nchar() == '*' || nchar() == '/')) {\n            if (nchar() == '*') {\n                read_char('*');\n                res *= number();\n            }\n            else {\n                read_char('/');\n                res /= number();\n            }\n        }\n        return res;\n    }\n    ll number() {\n        if (nchar() == '(') {\n            read_char('(');\n            ll res = E();\n            read_char(')');\n            return res;\n        }\n        else {\n            string res = \"\";\n            while (!end() && isdigit(nchar())) {\n                res += nchar();\n                ++pos;\n            }\n            return stoll(res);\n        }\n    }\n    bool end() {\n        return nchar() == '=';\n    }\n    char nchar() {\n        assert(pos < s.size());\n        return s[pos];\n    }\n    void read_char(char c) {\n        assert(!end() && nchar() == c);\n        ++pos;\n    }\npublic:\n    Parser(const string& s) : s(s), pos(0) {}\n    ll parse() {\n        pos = 0;\n        return E();\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll T; cin >> T;\n    rep(t, T) {\n        string s; cin >> s;\n        cout << Parser(s).parse() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%s\", s);\n\n    l = str2arr(s, A);\n    t = Generate_RPN(l, A, B);\n\n    calculate(t, B);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n  //   #define int long long\n            #define mod  1000000009\n            #define pa pair<int,int>\n            #define ll long long\n            #define pal pair<double,int>\n            #define ppa pair<int,pa>\n            #define ssa pair<string,int>\n            #define  mp make_pair\n            #define  pb push_back\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     //priority_queue<int, vector<int>, greater<int> > que;\n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \nstring itos( int i ) {\nostringstream s ;\ns << i ;\nreturn s.str() ;\n}\n\nint gcd(int v,int b){\n\tif(v>b) return gcd(b,v);\n\tif(v==b) return b;\n\tif(b%v==0) return v;\n\treturn gcd(v,b%v);\n}\n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \ndouble distans(double x1,double y1,double x2,double y2){\n\tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n\treturn sqrt(rr);\n\t\n}\n            //----------------kokomade tenpure------------\nstring s;\nint kakko(string &t ,int &b);\n\nint suuji(string &t, int &b){\n\tint r=0;\n\tif(isdigit(t[b])){\n\twhile(isdigit(t[b])){\n\t\tr *=10;\n\t\tr += t[b]-'0';\n\t\t(b)++;\n\t}\n\t}\n\telse if(t[b]=='('){\n\t\n\t\tr=kakko(t,b);\n\t\t\n\t}\n\t\n\treturn r;\n}\n\n\nint kake(string &t, int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=suuji(t,b);\n\t\n\t\twhile((t[b]=='*')||(t[b]=='*')){\n\t\t\tb++;\n\t\t\tif(t[b-1]=='*')i *= suuji(t,b);\n\t\t\telse i /= suuji(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint tashi(string &t ,int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=kake(t,b);\n\t\twhile((t[b]=='+')||(t[b]=='-')){\n\t\tb++;\n\t\t\tif(t[b-1]=='+')\ti += kake(t,b);\n\t\t\telse i -= kake(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint kakko(string &t ,int &b){\n\t\n\tif(t[b]=='('){\n\t\tint y;\n\t\tb++;\n\t\ty=kakko(t,b);\n\t\tb++;\n\t\treturn y;\n\t}\n\telse{\n\t\treturn tashi(t,b);\n\t}\n}\n    signed  main(){\n    \tint n;\n    \tcin>>n;\n    \tfor(int g=0;g<n;g++){\ncin>>s;\n    \tint i=0;\n    \tcout<<tashi(s,i)<<endl;\n    \t}\n    \n  //  \tprintf(\"%.10f\\n\",ans[n-1]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cctype>\nusing namespace std;\n\nint exp(const string& s, int& p);\nint term(const string& s, int& p);\nint fact(const string& s, int& p);\nint number(const string& s, int& p);\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      string s;\n      cin >> s;\n      s.erase(s.end()-1);\n      int p = 0;\n      cout << exp(s, p) << endl;\n    }\n  }\n  return 0;\n}\n\nint exp(const string& s, int& p)\n{\n  int ret = term(s, p);\n  for ( ; ; ) {\n    if (s[p] == '+')\n      ret += term(s, ++p);\n    else if (s[p] == '-')\n      ret -= term(s, ++p);\n    else\n      break;\n  }\n  return ret;\n}\n\nint term(const string& s, int& p)\n{\n  int ret = fact(s, p);\n  for ( ; ; ) {\n    if (s[p] == '*')\n      ret *= fact(s, ++p);\n    else if (s[p] == '/')\n      ret /= fact(s, ++p);\n    else\n      break;\n  }\n  return ret;\n}\n\nint fact(const string& s, int& p)\n{\n  int ret = 0;\n  if (s[p] == '(') {\n    ret = exp(s, ++p);\n    ++p;\n  } else {\n    ret = number(s, p);\n  }\n  return ret;\n}\n\nint number(const string&s, int& p)\n{\n  int ret = 0;\n  while (isdigit(s[p])) {\n    ret *= 10;\n    ret += s[p] - '0';\n    ++p;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nLL plusub(void);\nLL muldiv(void);\nLL parent(void);\nLL number(LL a);\n\nint ind;\nstring str;\n\nLL plusub(void){\n  LL a=muldiv();\n  if(str[ind]=='+'){\n    ++ind;\n    return a+plusub();\n  }else if(str[ind]=='-'){\n    ++ind;\n    return a-plusub();\n  }else return a;\n}\n\nLL muldiv(void){\n  LL a=parent();\n  if(str[ind]=='*'){\n    ++ind;\n    return a*muldiv();\n  }else if(str[ind]=='/'){\n    ++ind;\n    return a/muldiv();\n  }else return a;\n}\n\nLL parent(void){\n  if(str[ind]=='('){\n    ++ind;\n    LL a=plusub();\n    ++ind;\n    return a;\n  }else return number(0);\n}\n\nLL number(LL a){\n  if('0'<=str[ind] && str[ind]<='9'){\n    LL b=str[ind]-'0';\n    ++ind;\n    return number(a*10+b);\n  }else return a;\n}\n\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(i,n){\n    ind=0;\n    cin >> str;\n    cout << plusub() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 1e9+7;\nconst lint INF = mod;\nconst int MAX = 100010;\n\nint expression(string &s, int &idx);\nint term(string &s, int &idx);\nint factor(string &s, int &idx);\nint number(string &s, int &idx);\n\nint expression(string &s, int &idx){\n    int ret=term(s, idx);\n    while(true) {\n        if (s[idx]=='+') ++idx, ret+=term(s, idx);\n        else if(s[idx]=='-') ++idx, ret-=term(s, idx);\n        else break;\n    }\n    return ret;\n}\n\nint term(string &s, int &idx){\n    int ret=factor(s, idx);\n    while(true) {\n        if (s[idx]=='*') ++idx, ret*=factor(s, idx);\n        else if(s[idx]=='/') ++idx, ret/=factor(s, idx);\n        else break;\n    }\n    return ret;\n}\n\nint factor(string &s, int &idx){\n    if(s[idx]=='('){\n        ++idx;\n        int ret=expression(s, idx);\n        ++idx;\n        return ret;\n    }\n    else return number(s, idx);\n}\n\nint number(string &s, int &idx){\n    int ret=0;\n    while(0<=s[idx]-'0' && s[idx]-'0'<=9){\n        ret=ret*10+(s[idx]-'0');\n        ++idx;\n    }\n    return ret;\n}\n\nint main(){\n    int q;\n    scanf(\"%d\", &q);\n    while(q--){\n        string s;\n        cin >> s;\n        int idx=0;\n        printf(\"%d\\n\", expression(s, idx));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nint expression(string &s,int &pos);\n\n\nint factor(string &s,int &pos){\n\tif(s[pos]=='('){\n\t\tpos++;\n\t\tint ret=expression(s,pos);\n\t\tassert(s[pos]==')');\n\t\tpos++;\n\t\treturn ret;\n\t}else{\n\t\tassert(isdigit(s[pos]));\n\t\tint ret=s[pos]-'0';\n\t\tpos++;\n\t\twhile(isdigit(s[pos])){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nint term(string &s,int &pos){\n\tint ret=factor(s,pos);\n\twhile(s[pos]=='*'||s[pos]=='/'){\n\t\tchar op=s[pos];\n\t\tpos++;\n\t\tif(op=='*'){\n\t\t\tret*=factor(s,pos);\n\t\t}else{\n\t\t\tret/=factor(s,pos);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(string &s,int &pos){\n\tint ret=term(s,pos);\n\twhile(s[pos]=='+'||s[pos]=='-'){\n\t\tchar op=s[pos];\n\t\tpos++;\n\t\tif(op=='+'){\n\t\t\tret+=term(s,pos);\n\t\t}else{\n\t\t\tret-=term(s,pos);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tREP(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tint pos=0;\n\t\tint ans=expression(s,pos);\n\t\tassert(s[pos]=='=');\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint p1( string const& expr, int& pos );\nint p2( string const& expr, int& pos );\nint p3( string const& expr, int& pos );\n\nint p1( string const& expr, int& pos )\n{\n    int result = p2(expr, pos);\n    if ( result == -1 )\n        return -1;\n\n    while( expr[pos] == '+' || expr[pos] == '-' ) {\n        int const cp = pos;\n        ++pos;\n        int const a = p2( expr, pos );\n        if ( expr[cp] == '+' )\n            result += a;\n        else\n            result -= a;\n    }\n\n    return result;\n}\n\nint p2( string const& expr, int& pos )\n{\n    int result = p3(expr, pos);\n    if ( result == -1 )\n        return -1;\n\n    while( expr[pos] == '*' || expr[pos] == '/' ) {\n        int const cp = pos;\n        ++pos;\n        int const a = p3( expr, pos );\n        if ( expr[cp] == '*' )\n            result *= a;\n        else\n            result /= a;\n    }\n\n    return result;\n}\n\nint p3( string const& expr, int& pos )\n{\n    if ( expr[pos] >= '0' && expr[pos] <= '9' ) {\n        int const cp = pos;\n        ++pos;\n        return expr[cp] - '0';\n\n    } else if ( expr[pos] == '(' ){\n        ++pos;\n        int const res = p1( expr, pos );\n        ++pos; // ')'\n        return res;\n    }\n\n    return ~1;\n}\n\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    cin.ignore();\n    for( int iii=0; iii<n; ++iii ) {\n        string s;\n        getline( cin, s );\n//        cout << s << endl;\n        int pos = 0;\n        cout << p1( s, pos ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nbool is_digit(char c){\n  return '0' <= c && c <= '9';\n}\nstring i2s(int i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\n\nstring parse(int i, string s) {\n  //cout<<s<<endl;\n  bool flag = true;\n  \n  // brace\n  if (s.find('(') != -1) {\n    // æª©ç`FbNµÄA')'Éoï¤êÆ\n    // »¤ÅÈ¢êÉª¯é\n    bool mode = true;\n    REP(j,s.find('(')+1, s.size()) {\n      if (s[j] == ')') break;\n      if (s[j] == '(') {\n        mode = false;\n        break;\n      }\n    }\n    // ÊÌÊuðæ¾·é\n    int lbr = s.find('('), rbr;\n    if (mode) {\n      rbr = s.find(')');\n    } else {\n      for(int j=s.size()-1;j>=0;j--) if (s[j] == ')') {\n        rbr = j; break;\n      }\n    }\n    // ÊàÌvZðæÉs¤½ßÉssð¾é\n    string inner = parse(0, s.substr(lbr+1, rbr-lbr-1));\n    // ÊàðÁ·é\n    s.erase(lbr, rbr-lbr+1);\n    s.insert(lbr, inner);\n    //cout<<\"brace:\"<<s<<endl;\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '*' || s[i] == '/') {\n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    if (ri + 1 < s.size() && s[ri] == '-') ri++;\n\n    while (is_digit(s[li]) && li >= 0) {\n      if (s[li] == '-') break;\n      li--;\n    }\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    //cout<<s.substr(li+1, i-1-li)<<\"|\"<<s.substr(i+1, ri-1-i)<<endl;\n\n    if (lhs == 0 || rhs == 0) {\n      res = 0;\n    } else {\n      if (s[i] == '*') {\n        res = lhs * rhs;\n      } else {\n        res = lhs / rhs;\n      }\n    }\n    \n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    //cout<<\"tmp:\"<<s<<endl;\n    return parse(0, s);\n  }\n  \n  rep(i,s.size()) if (s[i] == '+' || s[i] == '-') {\n    if (s[i] == '-' && i == 0) continue; \n    int lhs, rhs, res;\n    int li = i-1, ri = i+1;\n    if (ri + 1 < s.size() && s[ri] == '-') ri++;\n    \n    while (is_digit(s[li]) || s[li] == '-' && li >= 0) li--;\n    while (is_digit(s[ri]) && ri < s.size()) ri++;\n    lhs = atoi(s.substr(li+1, i-1-li).c_str());\n    rhs = atoi(s.substr(i+1, ri-1-i).c_str());\n    //cout<<s.substr(li+1, i-1-li)<<\"|\"<<s.substr(i+1, ri-1-i)<<endl;\n    if (s[i] == '+') {\n      res = lhs + rhs;\n    } else {\n      res = lhs - rhs;\n    }\n    s.erase(li+1, ri-li-1);\n    s.insert(li+1, i2s(res));\n    //cout<<\"tmp:\"<<s<<endl;\n    return parse(0, s);\n  }\n  \n  return s;\n}\n\nvoid solve() {\n  string s; cin>>s;\n  s = s.substr(0, s.size()-1);\n  cout<<parse(0, s)<<endl;\n  //cout<<\"+++++\"<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  int n; cin>>n;\n  rep(i,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<queue>\n#define int long long\nusing namespace std;\n\nstring Erase(string a, int b, int c,string e) {//b???????????????c??????????????§????¶????\n\tstring d;\n\tfor (int i = 0; i < b; i++) {\n\t\td += a[i];\n\t}\n\td += e;\n\tfor (int i = c+1; i < a.length(); i++) {\n\t\td += a[i];\n\t}\n\treturn d;\n}\nstring kake(string a) {\n\tint b = 1; a = \"*\" + a;\n\tfor (int c = 0; c < a.length(); c++) {\n\t\tint e = c+1;\n\t\tif (a[c] == '*') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb *= stoi(d);\n\t\t}\n\t\telse if (a[c] == '/') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb /= stoi(d);\n\t\t}\n\t\tc = e - 1;\n\t}\n\treturn to_string(b);\n}\nstring tasi(string a) {\n\tint b = 0; a = \"+\" + a;\n\tfor (int c = 0; c < a.length(); c++) {\n\t\tint e = c + 1;\n\t\tif (a[c] == '+') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb += stoi(d);\n\t\t}\n\t\telse if (a[c] == '-') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb -= stoi(d);\n\t\t}\n\t\tc = e - 1;\n\t}\n\treturn to_string(b);\n}\nstring keisan(string a) {\n\tvector<string>V;\n\tstring b;\n\tfor (char c : a) {\n\t\tif (c == '+' || c == '-') {\n\t\t\tV.push_back(b);\n\t\t\tb = \"\"; b += c;\n\t\t\tV.push_back(b);\n\t\t\tb = \"\";\n\t\t}\n\t\telse b += c;\n\t}\n\tV.push_back(b);\n\tfor (int i = 0; i < V.size(); i += 2) {\n\t\tV[i] = kake(V[i]);\n\t}\n\tstring S;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tS += V[i];\n\t}\n\treturn tasi(S);\n}\nsigned main(){\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tstring c; cin >> c;\n\t\tc = c.substr(0, c.length() - 1);\n\t\tc = \"(\" + c + \")\";\n\t\twhile (1) {\n\t\t\tbool s = false;//????????????????????? ( ?????????0\n\t\t\tint last = 0;\n\t\t\tfor (int i = 0; i < c.length(); i++) {\n\t\t\t\tif (c[i] == '(') {\n\t\t\t\t\ts = false;\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t\tif (c[i] == ')') {\n\t\t\t\t\tif (!s) {\n\t\t\t\t\t\tc = Erase(c, last, i, keisan(c.substr(last+1,i-last-1)));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts = true;\n\t\t\t\t}\n\t\t\t\tif (i == c.length() - 1) { goto l; }\n\t\t\t}\n\t\t}\n\tl:;\n\t\tcout << c << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\nstring error_check(string str) {\n    stringstream tmp;\n    int flag = 0;\n    //cout << str << endl;\n    rep(i, str.length()-1) {\n        if (str[i] == '+' && str[i+1] == '-') {\n            i++;\n            flag = 1;\n        }\n        tmp << str[i];\n    }\n    tmp << str[str.length()-1];\n    if (flag == 0) return str;\n    str = tmp.str();\n    cout << str << endl;\n    return str;\n}\n\nstring cal_mul (string str, int sym) {\n    error_check(str);\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    //dump(sym - L);\n    if (str[sym-L] == '-' && str[0] == '-') sumL = -sumL; \n    int flag = 0;\n    if (str[sym+1] == '-') flag = 1;\n    //dump(flag);\n    while (str[sym+R+flag] >= '0' && str[sym+R+flag] <= '9') {\n        R++;\n    }\n    //dump(L);\n    //dump(R);\n    rep(i ,R-1) {\n        //dump(str[sym+R-i-1+flag]);\n        sumR += mul10(i, str[sym+R-i-1+flag] - '0');\n    }\n    if (flag == 1) sumR = -sumR;\n    //dump(sumL);\n    //dump(sumR);\n    stringstream str_tmp;\n    //cout << str << endl;\n    if (str[0] == '-') rep(i, sym-L) str_tmp << str[i+1];\n    else rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length()-flag; i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        //cout << str << endl;\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            //cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        str = cal_all(str);\n        //?????????????????????\n        int ans = stoi(str);\n        cout << str << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\nstd::cout << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(string delim,string str){\n\tvector<string> res;\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ) res.push_back(str.substr(i,j-1));\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstring calc(vector<string> v){\n\tstack<string> stk;\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"-\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2-num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2+num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"*\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2*num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"/\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2/num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse{\n\t\t\tstk.push(v[i]);\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nvector<string> rvs_polish(string str){\n\tstack<string> stk;\n\tvector<string> v;\n\n\tstring tmp=\"\";\n\tvector<string> res;\n\tif(str[0]=='-'){\n\t\tstr='0'+str;\n\t}\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='*'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"*\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='/'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"/\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]=='*' || str[i-1]=='/')){\n\t\t\ttmp+='-';\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]!='*' && str[i-1]!='/')){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"-\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='+'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"+\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='='){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"=\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse{\n\t\t\ttmp+=str.substr(i,1);\n\t\t}\n\t}\n\n\tv.push_back(tmp);\n\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"*\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\"){\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"/\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"/\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\" || opr == \"*\"){\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"-\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres.push_back(v[i]);\n\t\t}\n\t}\n\n\twhile(!stk.empty()){\n\t\tres.push_back(stk.top());\n\t\tstk.pop();\n\t}\n\n\treturn res;\n}\n\nvoid dfs(string str){\n\tstack<P> stk;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='(') {stk.push(P('(',i));}\n\t\telse if(str[i]==')') {\n\t\t\tchar sym = stk.top().first;\n\t\t\tif(sym != '(') continue;\n\n\t\t\tint pos = stk.top().second;\n\t\t\tstk.pop();\n\n\t\t\tif(str.substr(pos+1,(i-1)-(pos+1)+1).find('(') == string::npos\n\t\t\t\t&& str.substr(pos+1,(i-1)-(pos+1)+1).find(')') == string::npos){\n\t\t\t\t\tvector<string> pol = rvs_polish(str.substr(pos+1,(i-1)-(pos+1)+1));\n\t\t\t\t\tstring num = calc(pol);\n\t\t\t\t\tstr.replace(pos,i-pos+1,num);\n\t\t\t\t\t//cout << str << endl;\n\t\t\t\t\twhile(!stk.empty()) stk.pop();\n\t\t\t\t\ti=-1;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<string> ans = rvs_polish(str);\n\n\tcout << calc(ans) << endl;\n}\n\nint main(){\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tint n;\n\t\tsscanf(str.c_str(),\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\t\t\tdfs(str.substr(0,str.size()-1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint calc1();\nint calc2();\nint calc3();\n\nint p;\nstring eq;\n\nint calc1() {\n  int a = calc2();\n  if (eq[p]=='+') {\n    p++;\n    a += calc2();\n  } else if (eq[p]=='-') {\n    p++;\n    a -= calc2();\n  }\n  return a;\n}\n\nint calc2() {\n  int a = calc3();\n  if (eq[p]=='*') {\n    p++;\n    a *= calc3();\n  } else if (eq[p]=='/') {\n    p++;\n    a /= calc3();\n  }\n  return a;\n}\n\nint calc3() {\n  int a;\n  if (eq[p]=='(') {\n    p++;\n    a = calc1();\n    p++;\n  } else {\n    a = 0;\n    while (eq[p]>='0'&&eq[p]<='9') {\n      a *= 10;\n      a += eq[p++] - '0';\n    }\n  }\n  return a;\n}\n\nint main() {\n  int n, r;\n\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    cin >> eq;\n    p = 0;\n    r = calc1();\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\nstring S=\"\";\nint cur=0;\nchar readchar()\n{\n  assert(cur<S.size());\n  return S[cur++];\n}\n\nchar peek()\n{\n  assert(cur<S.size());\n  return S[cur];\n}\n\nint digit()\n{\n  assert(isdigit(peek()));\n  int n=readchar()-'0';\n  return n;\n}\n\nint number()\n{\n  int n=digit();\n  while(cur<S.size()&&isdigit(peek()))\n  {\n    n=n*10+digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor()\n{\n  if(peek()!='(') return number();\n  cur+=1;\n  int n=expression();\n  assert(peek()==')');\n  cur+=1;\n  return n;\n}\n\nint term()\n{\n  int a=factor();\n  while(cur<S.size()&&(peek()=='*'||peek()=='/'))\n  {\n    char op=readchar();\n    int b=factor();\n    if(op=='*')\n    {\n      a*=b;\n    }\n    else\n    {\n      a/=b;\n    }\n  }\n  return a;\n}\n\nint expression()\n{\n  int sum=term();\n  while(cur<S.size()&&(peek()=='+'||peek()=='-'))\n  {\n    char op=readchar();\n    int b=term();\n    if(op=='+')\n    {\n      sum+=b;\n    }\n    else\n    {\n      sum-=b;\n    }\n  }\n  return sum;\n}\n\n\n\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++)\n  {\n    cur=0;\n    cin>>S;\n    S.resize(S.size()-1);\n    cout<<expression()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nint number(const string &s, int &k);\nint fact(const string &s, int &k);\nint term(const string &s, int &k);\n\nint expr(const string &s, int &k){\n  int result = term(s,k);\n  while(k < s.size()-1){\n    if(s[k]=='+')result += term(s,++k);\n    else if(s[k]=='-')result -= term(s,++k);\n    else return result;\n  }\n  return result;\n}\n\nint term(const string &s, int &k){\n  int res = fact(s,k);\n  while(k<s.size()-1){\n    if(s[k]=='*')return res *= fact(s,++k);\n    else if(s[k]=='/')return res /= fact(s,++k);\n    else return res;\n  }\n  return res;\n}\n\nint fact(const string &s, int &k){\n  if(s[k]=='('){\n    int res = 0;\n    ++k;\n    res = expr(s,k);\n    k++;\n    return res;\n  }\n  return number(s,k);\n}\n\nint number(const string &s, int &k){\n  int res = 0;\n  while(isdigit(s[k])){\n    res *= 10;\n    res += (int)(s[k++] - '0');\n  }\n  return res;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  while(n--){\n    string s;\n    cin >> s;\n    int k = 0;\n    cout << expr(s, k) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring s;\n\nbool isDigit(char c)\n{\n\treturn (c >= '0' && c <= '9');\n}\nint parseNumber(string &s, int &pos)\n{\n\tint ret = 0;\n\twhile(1){\n\t\tif(isDigit(s[pos])) ret *= 10, ret += s[pos]-'0';\n\t\telse break;\n\t\tpos++;\n\t}\n\treturn ret;\n}\nint parseExp(string &s, int &pos);\nint parseFactor(string &s, int &pos)\n{\n\tif(s[pos] == '('){\n\t\tpos++;\n\t\tint ret = parseExp(s, pos);\n\t\tpos++;\n\t\treturn ret;\n\t}\n\telse if(isDigit(s[pos])) return parseNumber(s, pos); \n}\nint parseTerm(string &s, int &pos)\n{\n\tint ret = 1;\n\tret *= parseFactor(s, pos);\n\twhile(1){\n\t\tif(s[pos] == '*'){\n\t\t\tpos++;\n\t\t\tret *= parseFactor(s, pos);\n\t\t}\n\t\telse if(s[pos] == '/'){\n\t\t\tpos++;\n\t\t\tret /= parseFactor(s, pos);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\nint parseExp(string &s, int &pos)\n{\n\tint ret = 0;\n\tret += parseTerm(s, pos);\n\twhile(1){\n\t\tif(s[pos] == '+'){\n\t\t\tpos++;\n\t\t\tret += parseTerm(s, pos);\n\t\t}\n\t\telse if(s[pos] == '-'){\n\t\t\tpos++;\n\t\t\tret -= parseTerm(s, pos);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tint T;\n\tcin >> T;\n\tfor(int t = 0; t < T; t++){\n\t\tcin >> s;\n\t\tint pos = 0;\n\t\tcout << parseExp(s, pos) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n\n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    int ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=number(begin);\n\n  while(1){\n    if(*begin=='*'){\nbegin++;\nif(*begin=='-'){\nbegin++;\nret*=(-factor(begin));\n}\n else ret*=factor(begin);\n}\n    else if(*begin=='/'){\nbegin++;\nif(*begin=='-'){\nbegin++;\nret/=(-factor(begin));\n}\n else ret/=factor(begin);\n}\n    else break;\n}\nreturn ret;\n}\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\nreturn ret;\n  }\n  else return number(begin);\n}\n\nint number(State &begin){\n  int ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s.begin())<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n\n  void init(){ pos=0;len=s.size();}\n\n  int head2Num(){\n    bool f=false;\n    if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    int res;\n    if(s[pos]=='('){\n      pos++;\n      res = getAns();\n    }else res=head2Num();\n\n    if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }else{\n      return res;\n    }\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else assert(0);\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass calc{\n  string s;\n  string::iterator it;\n\npublic:\n  calc(const string&str){\n    s = str;\n    it = s.begin();\n  }\n\n  int fact(){\n    if(*it == '('){\n      ++it;\n      int ret = exp();\n      ++it;\n      return ret;\n    }\n    else{\n      int ret = 0;\n      while('0' <= *it && *it <= '9'){\n\tret *= 10;\n\tret += *it - '0';\n\t++it;\n      }\n      return ret;\n    }\n  }\n\n  int term(){\n    int ret = fact();\n    while(*it == '*' || *it == '/'){\n      if(*it == '*'){\n\t++it;\n\tret *= fact();\n      }\n      else if(*it == '/'){\n\t++it;\n\tret /= fact();\n      }\n    }\n    return ret;\n  }\n  \n  int exp(){\n    int ret = term();\n\n    while(*it == '+' || *it == '-'){\n      if(*it == '+'){\n\t++it;\n\tret += term();\n      }\n      else if(*it == '-'){\n\t++it;\n\tret -= term();\n      }\n    }\n    return ret;\n  }\n};\n\nint main(){\n  string str;\n  int n;\n\n  cin >> n;\n  while(n--){\n    cin >> str;\n    calc ans(str);\n    cout << ans.exp() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int l, t;\n    string A[100], B[100];\n    char s[10];\n\n    scanf(\"%s\", s);\n\n    l = str2arr(s, A);\n    t = Generate_RPN(l, A, B);\n\n    calculate(t, B);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nchar *pt;\nint parseAtom();\nint parseExpr();\nint parseTerm();\n\n\nint parseAtom(){\n\tif('0' <= *pt && *pt <= '9'){\n\t\tint x = *pt - '0';\n\t\tpt++;\n\t\twhile('0' <= *pt && *pt <= '9'){\n\t\t\tx = x * 10 + *pt - '0';\n\t\t\tpt++;\n\t\t}\n\t\treturn x;\n\t}\n\tif('(' == *pt){\n\t\tpt++;\n\t\tint x = parseExpr();\n\t\tassert(*pt == ')');\n\t\tpt++;\n\t\treturn x;\n\t}\n\tassert(false);\n\treturn -1;\n}\nint parseExpr(){\n\tint x = parseTerm();\n\twhile(*pt == '+' || *pt == '-'){\n\t\tif(*pt == '+'){\n\t\t\tpt++;\n\t\t\tx += parseTerm();\n\t\t}else {\n\t\t\tpt++;\n\t\t\tx -= parseTerm();\n\t\t}\n\t}\n\treturn x;\n}\nint parseTerm(){\n\tint x = parseAtom();\n\twhile(*pt == '*' || *pt == '/'){\n\t\tif(*pt == '*'){\n\t\t\tpt++;\n\t\t\tx *= parseAtom();\n\t\t} else{\n\t\t\tx /= parseAtom();\n\t\t}\n\t}\n\treturn x;\n}\nint main(void){\n\tint n ;\n\tcin>>n;\n\tfor(int i = 0 ; i < n ;  i ++){\n\t\tstatic char expr[200];\n\t\tscanf(\"%d\",expr);\n\t\tpt=expr;\n\t\tint x = parseExpr();\n\t\tassert(*pt == '=');\n\t\tcout<<x<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n\n#define REP(i,x)for(int i=0;i<(int)x;i++)\n\n// 逆ポーランド記法\n// op!=0なら演算子\nstruct Parsed{\n\tchar op;\n\tint value;\n\tint priority;\n};\nvector<Parsed> parse(const string &s){\n\tint op[256] = {}; // 演算子の情報\n\t// 演算子の情報を入れる\n\top['+']=op['-']=2;\n\top['*']=op['/']=3;\n\top['(']=100;\n\top[')']=1;\n\tstack<Parsed> stack;\n\tvector<Parsed> res;\n\tint it=0;\n\twhile(it<(int)s.size()){\n\t\tint pri=0,value=0,opd=0;\n\t\tif(op[(int)s[it]]){\n\t\t\tpri=op[(int)s[it]];\n\t\t\tvalue=0;\n\t\t\topd=s[it];\n\t\t}else{\n\t\t\tvalue=0;\n\t\t\twhile(it<(int)s.size()&&isdigit(s[it])){\n\t\t\t\tvalue=value*10+s[it]-'0';\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tit--;\n\t\t\tpri=99;\n\t\t}\n\t\twhile(!stack.empty()&&pri<=stack.top().priority&&stack.top().op != '('){\n\t\t\tres.push_back(stack.top());\n\t\t\tstack.pop();\n\t\t}\n\t\tif(opd!=')'){\n\t\t\tstack.push((Parsed){opd,value,pri});\n\t\t}else{\n\t\t\tstack.pop();\n\t\t}\n\t\tit++;\n\t}\n\twhile(!stack.empty()){\n\t\tres.push_back(stack.top());\n\t\tstack.pop();\n\t}\n\treturn res;\n}\nint main() {\n\tstring in;\n\tfor(cin>>in;cin>>in;){\n\t\tin=in.substr(0,in.size()-1);\n\t\tvector<Parsed> parsed = parse(in);\n\t\tstack<int> stack;\n\t\tfor(int i=0;i<(int)parsed.size();i++){\n\t\t\tif(parsed[i].op=='+'){\n\t\t\t\tint a=stack.top();stack.pop();\n\t\t\t\tint b=stack.top();stack.pop();\n\t\t\t\tstack.push(a+b);\n\t\t\t}else if(parsed[i].op=='-'){\n\t\t\t\tint a=stack.top();stack.pop();\n\t\t\t\tint b=stack.top();stack.pop();\n\t\t\t\tstack.push(b-a);\n\t\t\t}else if(parsed[i].op=='*'){\n\t\t\t\tint a=stack.top();stack.pop();\n\t\t\t\tint b=stack.top();stack.pop();\n\t\t\t\tstack.push(a*b);\n\t\t\t}else if(parsed[i].op=='/'){\n\t\t\t\tint a=stack.top();stack.pop();\n\t\t\t\tint b=stack.top();stack.pop();\n\t\t\t\tstack.push(b/a);\n\t\t\t}else{\n\t\t\t\tstack.push(parsed[i].value);\n\t\t\t}\n\t\t}\n\t\tcout<<stack.top()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\t if(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\tstring tmp;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\t if(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr>=s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <stack>\n\nchar buf[128];\nint pos;\n#define NOW (buf[pos])\n\nbool isdigit(char c) {\n\treturn ('0' <= c && c <= '9');\n}\n\nbool isstrong(char c) {\n\treturn (c=='*'||c=='/');\n}\nbool isweak(char c) {\n\treturn (c=='+'||c=='-');\n}\n\nint digit() {\n\tif ( !isdigit(NOW) ) {\n\t\tfprintf(stderr, \"%c: \", NOW);\n\t\tassert( isdigit(NOW) );\n\t}\n\tint ret = NOW - '0';\n\tpos++;\n\t\n\treturn ret;\n}\nint number() {\n\tint ret = digit();\n\twhile( isdigit(NOW) ) {\n\t\tret = ret*10 + digit();\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\n\tint set;\n\tscanf(\"%d\", &set);\n\t\n\twhile(set--) {\n\t\tscanf(\"%s\", buf);\n\t\tstd::stack<char> expr;\n\t\tstd::stack<int>  num;\n\t\t\n\t\texpr.push('(');\n\t\t\n\t\twhile(true) {\n\t\t\tif(isdigit(NOW)) {\n\t\t\t\tnum.push( number() );\n\t\t\t} else {\n\t\t\t\tif ( expr.top() == '(' && (NOW==')'||NOW=='=') ) {\n\t\t\t\t\t//対応する括弧が出てきたので、スタック上の括弧を消す\n\t\t\t\t\texpr.pop();\n\t\t\t\t\tif ( expr.empty() ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if ( expr.top() == '(' ||\n\t\t\t\t     NOW == '(' ||\n\t\t\t\t\t ( isstrong(NOW)&&isweak(expr.top()) ) ) {\n\t\t\t\t\t//強い演算子はスタックに積んでおく。括弧が積んであるなら、無条件に積む\n\t\t\t\t\texpr.push(NOW);\n\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\t//次の演算子は弱いor同じだから、積んでるものを先に計算してしまおう\n\t\t\t\t\tchar de = expr.top(); expr.pop();\n\n\t\t\t\t\tint b = num.top(); num.pop();\n\t\t\t\t\tint a = num.top(); num.pop();\n\t\t\t\t\tint ans;\n\t\t\t\t\tswitch(de) {\n\t\t\t\t\t\tcase '+': ans=a+b; break;\n\t\t\t\t\t\tcase '-': ans=a-b; break;\n\t\t\t\t\t\tcase '*': ans=a*b; break;\n\t\t\t\t\t\tcase '/': ans=a/b; break;\n\t\t\t\t\t}\n\t\t\t\t\tnum.push(ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", num.top());\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\nusing namespace std;\n\nlong long num(string&, int&);\nlong long term(string&, int&);\nlong long mul(string&, int&);\nlong long expr(string&, int&);\n\nlong long num(string &s, int &k) {\n    long long ret = 0;\n    while ('0' <= s[k] && s[k] <= '9') {\n        ret *= 10;\n        ret += s[k] - '0';\n        k ++;\n    }\n    return ret;\n}\n\nlong long term(string &s, int &k) {\n    int sym = 1;\n    if (s[k] == '+') {\n        sym = 1;\n        k ++;\n    } else if (s[k] == '-') {\n        sym = -1;\n        k ++;\n    }\n    long long ret;\n    if (s[k] == '(') {\n        k ++;\n        ret = expr(s, k);\n        k ++;\n    } else {\n        ret = num(s, k);\n    }\n    return sym * ret;\n}\n\nlong long mul(string &s, int &k) {\n    long long ret = term(s, k);\n    if (s[k] == '*') {\n        k ++;\n        return ret * mul(s, k);\n    } else if (s[k] == '/') {\n        k ++;\n        return ret / mul(s, k);\n    }\n    return ret;\n}\n\nlong long expr(string &s, int &k) {\n    long long ret = mul(s, k);\n    if (s[k] == '+') {\n        k ++;\n        return ret + expr(s, k);\n    } else if (s[k] == '-') {\n        return ret + expr(s, k);\n    }\n    return ret;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string s;\n    while (n--) {\n        cin >> s;\n        int pos = 0;\n        cout << expr(s, pos) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string>\n#include<vector>\n#include<sstream>\n\nstd::string a;\nstd::vector<std::string>v;\nstd::vector<std::string>va;\nstd::stack<std::string>s;\nint i=0;\n\nvoid bun(){\n\tint ii=0,k=0;\n\tfor(int jj=0;jj<a.size();jj++){\n\t\tif(a[jj]=='+'||a[jj]=='-'||a[jj]=='*'||a[jj]=='/'||a[jj]==')'){\n\t\t\tif(a[jj-1]!=')'){\n\t\t\t\tv.push_back(\"1\");\n\t\t\t\tstd::stringstream z;\n\t\t\t\tz<<a.substr(ii,jj-ii);\n\t\t\t\tz>>v[k];\n\t\t\t\tk++;\n\t\t\t\tii=jj+1;\n\t\t\t}\n\t\t\tv.push_back(\"1\");\n\t\t\tv[k]=a[jj];\n\t\t\tk++;\n\t\t}else if(a[jj]=='('){\n\t\t\tv.push_back(\"1\");\n\t\t\tv[k]=a[jj];\n\t\t\tk++;\n\t\t\tii=jj+1;\n\t\t}else if(jj==a.size()-1){\n\t\t\tv.push_back(\"1\");\n\t\t\tjj++;\n\t\t\tstd::stringstream z;\n\t\t\tz<<a.substr(ii,jj-ii);\n\t\t\tz>>v[k];\n\t\t}\n\t}\n}\n\nstd::string change(double p){\n\tstd::stringstream z;\n\tstd::string str;\n\tz<<p;\n\tz>>str;\n\treturn str;\n}\n\nvoid por(int p,int q,int si){\n\tint m=0,ma=0;\n\tfor(int k=p;k<=q;k++){\n\t\tif(v[k]==\")\"){}\n\t\telse if(v[k]==\"(\"){\n\t\t\tint ky,z=1;\n\t\t\tfor(ky=k+1;ky<=q;ky++){\n\t\t\t\tif(v[ky]==\"(\")z++;\n\t\t\t\tif(v[ky]==\")\")z--;\n\t\t\t\tif(z==0)break;\n\t\t\t}\n\t\t\tpor(k+1,ky-1,s.size());\n\t\t\tk=ky;\n\t\t}else if(v[k]!=\"+\"&&v[k]!=\"-\"&&v[k]!=\"*\"&&v[k]!=\"/\"){\n\t\t\tva.push_back(\"1\");\n\t\t\tva[i]=v[k];\n\t\t\ti++;\n\t\t}else if(v[k]==\"+\"||v[k]==\"-\"||v[k]==\"*\"||v[k]==\"/\"){\n\t\t\tif(v[k]==\"+\")ma=1;\n\t\t\tif(v[k]==\"-\")ma=1;\n\t\t\tif(v[k]==\"*\")ma=2;\n\t\t\tif(v[k]==\"/\")ma=3;\n\t\t\twhile(ma<=m&&s.size()>si){\n\t\t\t\tva.push_back(\"1\");\n\t\t\t\tva[i]=s.top();\n\t\t\t\ts.pop();\n\t\t\t\ti++;\n\t\t\t\tif(s.size()>=1){\n\t\t\t\t\tif(s.top()==\"+\")m=1;\n\t\t\t\t\tif(s.top()==\"-\")m=1;\n\t\t\t\t\tif(s.top()==\"*\")m=2;\n\t\t\t\t\tif(s.top()==\"/\")m=3;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\ts.push(v[k]);\n\t\t\tm=ma;\n\t\t}if(k==q){\n\t\t\twhile(s.size()>si){\n\t\t\t\tva.push_back(\"1\");\n\t\t\t\tva[i]=s.top();\n\t\t\t\ts.pop();\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstd::string calc(){\n\tstd::stack<std::string>sa;\n\tfor(int k=0;k<va.size();k++){\n\t\tif(va[k]!=\"+\"&&va[k]!=\"-\"&&va[k]!=\"*\"&&va[k]!=\"/\")sa.push(va[k]);\n\t\telse{\n\t\t\tstd::stringstream z;\n\t\t\tstd::stringstream zz;\n\t\t\tdouble x,y;\n\t\t\tz<<sa.top();\n\t\t\tz>>x;\n\t\t\tsa.pop();\n\t\t\tzz<<sa.top();\n\t\t\tzz>>y;\n\t\t\tsa.pop();\n\t\t\tif(va[k]==\"+\")sa.push(change(y+x));\n\t\t\tif(va[k]==\"-\")sa.push(change(y-x));\n\t\t\tif(va[k]==\"*\")sa.push(change(y*x));\n\t\t\tif(va[k]==\"/\")sa.push(change(y/x));\n\t\t}\n\t}\n\treturn sa.top();\n}\n\nint main(){\n\tstd::stringstream z;\n\tdouble ans;\n\tstd::cin>>a;\n\ta.pop_back();\n\tbun();\n\tpor(0,v.size()-1,0);\n\tz<<calc();\n\tz>>ans;\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef int number;\n\nint c;\nstring str;\n\nnumber Z();\nnumber Expr();\nnumber Factor();\nnumber Term();\nnumber Num();\n\nvoid debug(string str) {\n//  cout << str << endl;\n}\n\nnumber Z() {\n  debug(\"Z: \" + str.substr(c));\n  number ans = Expr();\n  c++; // read =\n  debug(\"Z(\" + to_string(ans) + \"): \" + str.substr(c));\n  return ans;\n}\n\nnumber Expr() {\n  debug(\"Expr: \" + str.substr(c));\n  number val = Factor();\n  int p;\n  while (p = c, (str[p] == '+' || str[p] == '-')) {\n    if (str[c] == '+') {\n      c++; // read +\n      number expr = Expr();\n      val += expr;\n    } else {\n      // c++; // read -\n      number expr = Expr();\n      // val -= expr;\n      val += expr;\n    }\n  }\n  debug(\"Expr(\" + to_string(val) + \"): \" + str.substr(c));\n  return val;\n}\n\nnumber Factor() {\n  debug(\"Factor: \" + str.substr(c));\n  number val = Term();\n  int p;\n  while (p = c, (str[p] == '*' || str[p] == '/')) {\n    if (str[c] == '*') {\n      c++; // read *\n      number factor = Term();\n      val *= factor;\n    } else {\n      c++; // read /\n      number factor = Term();\n      val /= factor;\n    }\n  }\n  debug(\"Factor(\" + to_string(val) + \"): \" + str.substr(c));\n  return val;\n}\n\nnumber Term() {\n  debug(\"Term: \" + str.substr(c));\n  if (str[c] == '-') {\n    c++; // read -\n    number term = Term();\n    return -term;\n  } else if (str[c] == '(') {\n    c++; // read (\n    number expr = Expr();\n    c++; // read )\n    return expr;\n  } else {\n    number num = Num();\n    return num;\n  }\n}\n\nnumber Num() {\n  debug(\"Num: \" + str.substr(c));\n  number val = 0;\n  while (isdigit(str[c])) {\n    val = val * 10 + (str[c] - '0');\n    c++;\n  }\n  debug(\"Num(\" + to_string(val) + \"): \" + str.substr(c));\n  return val;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i, n) {\n    c = 0;\n    cin >> str;\n    cout << Z() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,a,b) for(int i=(a); i<(b); i++)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst double EPS=1e-10;\n//int mod=1000000007\n\n\nstring s;\n\n\n\nint calc(int b,int e){\n\tvector<int> v;\n\tvector<char> ope;\n\tfor(int i=b; i<=e; i++){\n\t\tif(s[i]=='('){\n\t\t\tint o=1,c=0;\n\t\t\tfor(int j=i+1; j<=e; j++){\n\t\t\t\tif(s[j]=='(')o++;\n\t\t\t\tif(s[j]==')'){\n\t\t\t\t\tc++;\n\t\t\t\t\tif(o==c){\n\t\t\t\t\t\tint a=calc(i+1,j+1);\n\t\t\t\t\t\tv.pb(a);\n\t\t\t\t\t\ti=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(s[i]>='0'&&s[i]<='9'){\n\t\t\tfor(int j=i+1; j<=e; j++){\n\t\t\t\tif(s[j]<'0'||s[j]>'9'){\n\t\t\t\t\tstring t=s.substr(i,j);\n\t\t\t\t\tv.pb(atoi(t.c_str()));\n\t\t\t\t\ti=j-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tope.pb(s[i]);\n\t\t}\n\t}\n\tfor(int i=0; i<ope.size(); i++){\n\t\tif(ope[i]=='*'){\n\t\t\tv[i+1]=v[i]*v[i+1];\n\t\t\tv[i]=0;\n\t\t\tope[i]=(i==0?'+':ope[i-1]);\n\t\t}\n\t\tif(ope[i]=='/'){\n\t\t\tv[i+1]=v[i]/v[i+1];\n\t\t\tv[i]=0;\n\t\t\tope[i]=(i==0?'+':ope[i-1]);\n\t\t}\n\t}\n\tfor(int i=0; i<ope.size()-1; i++){\n\t\tif(ope[i]=='+'){\n\t\t\tv[0]+=v[i+1];\n\t\t}\n\t\tif(ope[i]=='-'){\n\t\t\tv[0]-=v[i+1];\n\t\t}\n\t}\n\treturn v[0];\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>s;\n\t\tcout<<calc(0,s.size()-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint64 exp(string&, int32&);\nint64 term(string&, int32&);\nint64 fact(string&, int32&);\nint64 number(string&, int32&);\n\nint64 exp(string& s, int32& p){\n\tint64 ret = term(s, p);\n\twhile(p < s.size()){\n\t\tif(s[p] == '+'){\n\t\t\tp++;\n\t\t\tret += term(s, p);\n\t\t}else if(s[p] == '-'){\n\t\t\tp++;\n\t\t\tret -= term(s, p);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint64 term(string& s, int32& p){\n\tint64 ret = number(s, p);\n\twhile(p < s.size()){\n\t\tif(s[p] == '*'){\n\t\t\tp++;\n\t\t\tret *= fact(s, p);\n\t\t}else if(s[p] == '/'){\n\t\t\tp++;\n\t\t\tret /= fact(s, p);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint64 fact(string& s, int32& p){\n\tint64 ret = 0;\n\tif(s[p] == '('){\n\t\tp++;\n\t\tret = exp(s, p);\n\t\tp++;\n\t}else{\n\t\tret = number(s, p);\n\t}\n\treturn ret;\n}\n\nint64 number(string& s, int32& p){\n\tint64 ret = 0;\n\twhile(isdigit(s[p])){\n\t\tret = ret*10+s[p]-'0';\n\t\tp++;\n\t}\n\treturn ret;\n}\nint main(void){\n\tint32 N;\n\tcin >> N;\n\n\tREP(i, N){\n\t\tstring s;\n\t\tint32 p = 0;\n\t\tcin >> s;\n\t\tcout << exp(s, p) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <string>\nusing namespace std;\n\nint weak(string& s, int& i);\nint strong(string& s, int& i);\nint fc(string& s, int& i);\nint inte(string& s, int& i);\n\nint weak(string& s, int& i) {\n\tint buf = strong(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tif (s[i] == '+') {\n\t\t\ti++;\n\t\t\tbuf += strong(s, i);\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tbuf -= strong(s, i);\n\t\t}\n\t}\n\treturn buf;\n}\n\nint strong(string& s, int& i) {\n\tint buf = fc(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tif (s[i] == '*') {\n\t\t\ti++;\n\t\t\tbuf *= fc(s, i);\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tbuf /= fc(s, i);\n\t\t}\n\t}\n\treturn buf;\n}\n\nint fc(string& s, int& i) {\n\tif ('0' <= s[i] && '9' >= s[i])return inte(s, i);\n\telse {\n\t\ti++;\n\t\tint re = weak(s, i);\n\t\ti++;\n\t\treturn re;\n\t}\n}\n\nint inte(string& s, int& i) {\n\tint buf = s[i] - '0';\n\ti++;\n\twhile ('0' <= s[i] && '9' >= s[i]) {\n\t\tbuf = buf * 10 + s[i] - '0';\n\t\ti++;\n\t}\n\treturn buf;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s; int j = 0;\n\t\tcin >> s;\n\t\tcout << weak(s, j) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nstring S;\nsize_t cur=0;\n\nint term();\nint expression();\n\nint digit(){\n\tassert(isdigit(S[cur])); \n\tint n = S[cur] - '0'; \n\tcur++; \n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(cur <S.size() && isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nint factor() {\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint term(){\n\tint sum = factor();\n\twhile(S[cur] == '*' || S[cur] == '/'){\n\t\tchar op = S[cur];\n\t\tcur += 1;\n\t\tint b = factor();\n\t\tif( op == '*')\n\t\t\tsum*=b;\n\t\telse {\n\t\t\tassert(b);\n\t\t\tsum/=b;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(S[cur] == '+' || S[cur] == '-'){\n\t\tchar op = S[cur];\n\t\tcur += 1;\n\t\tint b = term();\n\t\tif( op == '+')\n\t\t\tsum+=b;\n\t\telse \n\t\t\tsum-=b;\n\t}\n\treturn sum;\n}\n\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> S;\n\t\tcur=0;\n\t\tint r;\n\t\tr=expression();\n\t\tcout << r << endl;\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\ntypedef string::const_iterator state;\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\ntemplate<typename T, bool Check=false>\nstruct LexParser {\n  typedef T expr_t;\n  typedef string::const_iterator state_t;\n  LexParser(){}\n  expr_t eval(const string& expr){\n    auto s = begin(expr);\n    auto r = expression(s);\n    consume(s, '=');\n    return r;\n  }\n  void consume(state_t& s, char expected){\n    if (!Check || *s == expected){\n      s++;\n      return;\n    }\n    cerr << \"Expected '\" << expected << \"' but got '\" << *s << \"'\" << endl;\n    cerr << \"Rest string is '\";\n    while (*s) cerr << *s;\n    cerr << \"'\" << endl;\n  }\n  expr_t number(state_t& s){\n    expr_t r = 0;\n    while (isdigit(*s)){\n      r = r * 10 + (*s - '0');\n      s++;\n    }\n    return r;\n  }\n  expr_t term(state_t& s){\n    expr_t r = factor(s);\n    while (1){\n      if (*s == '*'){\n        consume(s, '*');\n        r *= factor(s);\n      }\n      else if (*s == '/'){\n        consume(s, '/');\n        r /= factor(s);\n      }\n      else break;\n    }\n    return r;\n  }\n  expr_t factor(state_t& s){\n    expr_t r;\n    if (*s == '('){\n      consume(s, '(');\n      r = expression(s);\n      consume(s, ')');\n    }\n    else r = number(s);\n    return r;\n  }\n  expr_t expression(state_t& s){\n    expr_t r = term(s);\n    while (1){\n      if (*s == '+'){\n        consume(s, '+');\n        r += term(s);\n      }\n      else if (*s == '-'){\n        consume(s, '-');\n        r -= term(s);\n      }\n      else break;\n    }\n    return r;\n  }\n};\n\nint main()\n{\n  LexParser<int> parser;\n  for (int n = in(); n--;){\n    string expr;\n    cin >> expr;\n    cout << parser.eval(expr) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n\nclass Parser\n{\npublic:\n\tstring exp;\n\tint p;\n\tint expression (void );\n\tint term (void );\n\tint factor (void );\nprivate:\n\n};\n\nint Parser::expression (void)\n{\n\tint value = term ();\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tif (exp[p] == '+' ){\n\t\t\t++p; value += term();\n\t\t}else{\n\t\t\t++p; value -= term();\n\t\t} // end if\n\t} // end while\n\n\treturn value;\n}\n\nint Parser::term (void)\n{\n\tint value = factor();\n\n\twhile (exp[p] == '*' || exp[p] == '/' ){\n\t\tif (exp[p] == '*'){\n\t\t\t++p; value *= factor();\n\t\t}else{\n\t\t\t++p; value /= factor();\n\t\t} // end if\n\t} // end while\n\n\treturn value;\n}\n\nint Parser::factor (void)\n{\n\tint value = 0;\n\n\tif (exp[p] == '('){\n\t\t++p; value = expression(); ++p;\n\t}else{\n\t\twhile (isdigit(exp[p]) ){\n\t\t\tvalue = value * 10 + exp[p] - '0';\n\t\t\t++p;\n\t\t} // end while\n\t} // end if\n\t\n\treturn value;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.sc\", \"r\", stdin);\n\n\tParser parser;\n\tstring str = \"\";\n\tint n;\n\n\tgetline (cin, str );\n\tstringstream ssn(str);\n\tssn >> n;\n\n\tint i;\n\tfor (i = 0; i < n; ++i){\n\t\tgetline (cin, str );\n\t\tparser.exp = str;\n\t\tparser.p = 0;\n\t\tcout << parser.expression() << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nint parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')'){\n\t\tbool f=true;\n\t\tfor(int i=1,d=1;i<s.length()-1;i++){\n\t\t\tif     (s[i]=='(')\td++;\n\t\t\telse if(s[i]==')')\td--;\n\t\t\tif(d==0){\tf=false;\tbreak;\t}\n\t\t}\n\t\tif(f)\treturn parse(s.substr(1,s.length()-2));\n\t}\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=0,d=0;i<s.length();i++){\n\t\tif     (s[i]=='(')\td++;\n\t\telse if(s[i]==')')\td--;\n\n\t\telse if(d==0 && prior[s[i]]!=0){\n\t\t\tif(i==0 && prior[s[i]]==1)\tcontinue;\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoi(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <deque>\n#include <memory.h>\n\n#define rep(idx, max)\t\t\tfor(int idx = 0, idx##Max = (max); idx < idx##Max; idx ++)\n#define rrep(idx, min, max)\tfor(int idx = (min), idx##Max = max; idx < idx##Max; idx ++)\n#define erep(idx, min, max)\tfor(int idx = (min), idx##Max = max; idx <= idx##Max; idx ++)\n\n#define rev(idx, max)\t\t\tfor(int idx = (max) - 1; idx >= 0; idx --)\n#define rrev(idx, min, max)\tfor(int idx = (max) - 1, idx##Min = (min); idx >= idx##Min; idx --)\n#define erev(idx, min, max)\tfor(int idx = (max), idx##Min = (min); idx >= idx##Min; idx --)\n\n#define foreach(it, obj)\tfor(auto it = obj.begin(), it##End = obj.end(); it >= it##End; it ++)\n\nusing namespace\tstd;\n\nclass CCalc\n{\n\tstring\ts_;\n\tint\tpos_;\n\t\n\tint\tIsDigit(int x)\t{\treturn(x <= '9' && x >= '0');\t}\n\tvoid\tSkipSpace()\n\t{\n\t\tcout << \"Skipping...\";\n\t\tfor(int c = s_[pos_]; (c == ' ' || c == '\\t') && pos_ < s_.size(); pos_ ++);\n\t\tcout << \"OK\" << endl;\n\t}\n\tint\tNumber()\n\t{\n\t\tint num = 0;\n\t\twhile(IsDigit(s_[pos_]))\t{\tnum\t= num * 10 + s_[pos_ ++] - '0';\t}\n\t\treturn(num);\n\t}\n\tint\tFactor()\n\t{\n\t\tint val;\n\t\tif(pos_ >= s_.size())\t{\tcout << \"warning: Out of bounds!\" << endl;\t}\n\t\tif(IsDigit(s_[pos_]))\n\t\t{\n\t\t\tval = Number();\n\t\t\treturn(val);\n\t\t}\n\t\tpos_ ++;\n\t\tval\t= Expr();\n\t\tpos_ ++;\n\t\treturn(val);\n\t}\n\tint\tTerm()\n\t{\n\t\tint\tval1\t= Factor();\n\t\twhile(s_[pos_] == '*' || s_[pos_] == '/')\n\t\t{\n\t\t\tchar\top\t= s_[pos_ ++];\n\t\t\tint val2\t= Factor();\n\t\t\tswitch(op)\n\t\t\t{\n\t\t\t\tcase '*':\tval1 *= val2;\tbreak;\n\t\t\t\tcase '/':\tval1 /= val2;\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn(val1);\n\t}\n\tint\tExpr()\n\t{\n\t\tint\tval1\t= Term();\n\t\twhile(s_[pos_] == '+' || s_[pos_] == '-')\n\t\t{\n\t\t\tchar\top\t= s_[pos_ ++];\n\t\t\tint val2\t= Term();\n\t\t\tswitch(op)\n\t\t\t{\n\t\t\t\tcase '+':\tval1 += val2;\tbreak;\n\t\t\t\tcase '-':\tval1 -= val2;\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn(val1);\n\t}\n\t\npublic:\n\tint\tEval(string &expression)\n\t{\n\t\tpos_\t= 0;\n\t\tint pos = 0;\n\t\ts_.resize(expression.size());\n\t\trep(i, expression.size())\n\t\t{\n\t\t\tif(expression[i] != ' ')\n\t\t\t{\ts_[pos ++] = expression[i];\t}\n\t\t}\n\t\treturn(Expr());\n\t}\n};\n\nint main()\n{\n\tCCalc\tcalc;\n\tstring\texpression;\n\tint tc;\n\t\n\tfor(cin >> tc, cin.ignore(); tc > 0; tc --)\n\t{\n\t\tgetline(cin, expression);\n\t\tcout << calc.Eval(expression) << endl;\n\t}\n\t\n//\twhile(getline(cin, expression), expression.size())\n//\t{\t::printf(\"%s = %d\\n\", expression.c_str(), calc.Eval(expression));\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n\nclass Parser\n{\npublic:\n\tstring exp;\n\tint p;\n\tdouble expression (void );\n\tdouble term (void );\n\tdouble factor (void );\nprivate:\n\tdouble stod (string );\n};\n\ndouble Parser::stod (string str )\n{\n\tstringstream ss (str );\n\tdouble res;\n\t\n\tss >> res;\n\n\treturn res;\n}\n\ndouble Parser::expression (void)\n{\n\tdouble value = term ();\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tif (exp[p] == '+' ){\n\t\t\t++p; value += term();\n\t\t}else{\n\t\t\t++p; value -= term();\n\t\t} // end if\n\t} // end while\n\n\treturn value;\n}\n\ndouble Parser::term (void)\n{\n\tdouble value = factor();\n\n\twhile (exp[p] == '*' || exp[p] == '/' ){\n\t\tif (exp[p] == '*'){\n\t\t\t++p; value *= factor();\n\t\t}else{\n\t\t\t++p; value /= factor();\n\t\t} // end if\n\t} // end while\n\n\treturn value;\n}\n\ndouble Parser::factor (void)\n{\n\tdouble value = 0;\n\tstring res = \"\";\n\n\tif (exp[p] == '('){\n\t\t++p; value = expression(); ++p;\n\t}else{\n\t\twhile (isdigit(exp[p]) || exp[p] == '.' ){\n\t\t\tres += exp[p];\n//\t\t\tvalue = value * 10 + exp[p] - '0';\n\t\t\t++p;\n\t\t} // end while\n\t\tvalue = stod (res );\n\t} // end if\n\t\n\treturn value;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.sc\", \"r\", stdin);\n\n\tParser parser;\n\tstring str = \"\";\n\tint n;\n\n\tgetline (cin, str );\n\tstringstream ssn(str);\n\tssn >> n;\n\n\tint i;\n\tfor (i = 0; i < n; ++i){\n\t\tgetline (cin, str );\n\t\tparser.exp = str;\n\t\tparser.p = 0;\n\t\tcout << (int)(parser.expression()) << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum,tmpnum;\nstack<char> op,rop,tmpop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tfor(int i=1;i<=2;i++){\n\t\twhile(!rop.empty()){\n\t\t\tif(order[rop.top()]!=i){\n\t\t\t\ttmpop.push(rop.top());rop.pop();\n\t\t\t\ttmpnum.push(rnum.top());rnum.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a=rnum.top();rnum.pop();\n\t\t\t\tint b=rnum.top();rnum.pop();\n\t\t\t\tchar o=rop.top();rop.pop();\n\t\t\t\tint c;\n\t\t\t\tswitch(o){\n\t\t\t\t\tcase '+' :\n\t\t\t\t\t\tc=a+b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-' :\n\t\t\t\t\t\tc=a-b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*' :\n\t\t\t\t\t\tc=a*b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/' :\n\t\t\t\t\t\tc=a/b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trnum.push(c);\n\t\t\t}\n\t\t}\n\t\ttmpnum.push(rnum.top());rnum.pop();\n\t\tif(tmpnum.size()==1)\n\t\t\tbreak;\n\t\twhile(!tmpop.empty()){\n\t\t\trop.push(tmpop.top());tmpop.pop();\n\t\t\trnum.push(tmpnum.top());tmpnum.pop();\n\t\t}\n\t\trnum.push(tmpnum.top());tmpnum.pop();\n\t}\n\tnum.push(tmpnum.top());tmpnum.pop();\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(S[cur] == ')' ){\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\trnum.push(num.top());num.pop();\n\t\t\tcalc();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\t//cout << num.top() << endl;//\n\t//int tmp1=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//int tmp2=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp2);\n\t//num.push(tmp1);\n\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\trnum.push(num.top());num.pop();\n\n\tcalc();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n\nusing namespace std;\n\nvoid str2arr(string s, string A[]) {\n    int n = 0;\n    string tmp = \"\";\n\n    for (int i = 0; s[i] != '=' ; i++) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            tmp += s[i];\n        }\n        else {\n            if (tmp != \"\") { \n                A[n++] = tmp;\n                tmp = \"\";\n            }\n            A[n++] = s[i];\n        }\n    }\n    if (tmp != \"\") { A[n++] = tmp; }\n    A[n++] = \"=\";\n}\n\nvoid Generate_RPN(string A[], string B[]) {\n    map<string, int> table;\n    stack<string> St;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n\n    int j = 0;\n    for (int i = 0; A[i] != \"=\"; i++) {\n        if ('0' <= A[i][0] && A[i][0] <= '9') {\n            B[j++] = A[i];\n        }\n        else if (A[i] == \"(\") {\n            St.push(A[i]);\n        }\n        else if (A[i] == \")\") {\n            while (St.top() != \"(\") {\n                B[j++] = St.top(); St.pop();\n            }\n            St.pop();\n        }\n        else {\n            while ((!St.empty()) && (table[St.top()] >= table[A[i]])) {\n                B[j++] = St.top(); St.pop();\n            }\n            St.push(A[i]);\n        }\n    }\n    while (!St.empty()) {\n        B[j++] = St.top(); St.pop();\n    }\n    B[j] = \"=\";\n}\n\nint Calculate_RPN(string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; s[i] != \"=\"; i++) {\n        if (s[i] == \"+\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = int(St.top()); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    return int(St.top());\n}\n\nint main() {\n    int n;\n    string A[100], B[100];\n    string in;\n\n    cin >> n;\n\n    while (n--) {\n        cin >> in;\n        str2arr(in, A);\n        Generate_RPN(A, B);\n        cout << Calculate_RPN(B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cctype>\n\n\nusing namespace std;\n#define modd 1000000007\n\n\ntypedef pair<long long, long long> pl;\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\n\n\n\n#define ll long long\n\n\n\n\n/*\nclass UnionFind {\npublic:\n\tvector <ll> par;\n\tvector <ll> siz;\n\tvector <ll> gr;\n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) ,gr(sz_){\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i;\n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { // 根の検索\n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\n\t\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\n\n\tbool issame(ll x, ll y) { // 連結判定\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) { // 素集合のサイズ\n\t\treturn siz[root(x)];\n\t}\n\n\n};*/\n\n\nlong long N, M, K, a, b, c, d, e, H, W, L;\nll A[200005] = {};\nll B[200005] = {};\nll C[200005] = {};\nbool f, ff;\nstring S;\nset <long long>sll;\npl bufpl;\nvector <long long>vl[3];\nvector <pl>vpl;\nvector <string> vs;\nset<ll> llset;\n\n/*struct ST\n{\n\tlong long Kati;\n\tint bangou;\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn Kati < another.Kati;//比較\n\t};\n\n};\n\n\n\nvector <ST> vst;\nST st[200005];\nST bufst;\nbitset<5000> bits;*/\n\n\nlong long modinv(long long aa, long long mm) {\n\tlong long bb = mm, uu = 1, vv = 0;\n\twhile (bb) {\n\t\tlong long tt = aa / bb;\n\t\taa -= tt * bb; swap(aa, bb);\n\t\tuu -= tt * vv; swap(uu, vv);\n\t}\n\tuu %= mm;\n\tif (uu < 0) uu += mm;\n\treturn uu;\n}\n\n\n\nll minn, maxx;\ndouble ansa;\n\nint expression(State& begin);\nint term(State& begin);\nint factor(State& begin);\nint number(State& begin);\n\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State& begin) {\n\tint ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn ret;\n\n}\n\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State& begin) {\n\n\tint ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\n\t}\n\n\treturn ret;\n\n}\n\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State& begin) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす。\n\t\tint ret = expression(begin);\n\t\tbegin++; // ')'を飛ばす。\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n}\n\n\n\n\n\n// 数字の列をパースして、その数を返す。\nint number(State& begin) {\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\n\t}\n\n\treturn ret;\n\n}\n\n\n\n\n\n\n\nint main() {\n\n\tcin >> N;\n\ta= 0;\n\tcin.ignore();\n\n\twhile (a < N) {\n\n\t\tstring s;\n\n\t\tgetline(cin, s);\n\n\t\tState begin = s.begin();\n\n\t\te = expression(begin);\n\n\t\tcout << e << endl;\n\t\ta++;\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nint c = -1;\nstring s;\n\n\n/*\n<eq> = <expr> '='\n<expr> = <expr2> (('+'|'-') <expr2>)*\n<expr2> = <expr3> (('*'|'/') <expr3>)*\n<expr3> = <number> | '(' <expr> ')'\n<number> = ['0' - '9']+\n*/\n\nchar seek(){\n  assert(c < s.size());\n  return s[c];\n}\nchar next(){\n  assert(c < s.size());\n  char res = s[c];\n  c++;\n  return res;\n}\nint number(){\n  int res = 0;\n  while(isdigit(seek())){\n    res *= 10;\n    res += next() - '0';\n  }\n return res;\n}\nint expr();\n\nint expr3(){\n  char p = seek();\n  if(p == '('){\n    next();\n    int res = expr();\n    assert(next() == ')');\n    return res;\n  }\n  return number();\n}\nint expr2(){\n  int res = expr3();\n  while(true){\n    char op = seek();\n    if(op == '*'){\n      next();\n      int other = expr3();\n      res *= other;\n    }else if(op == '/'){\n      next();\n      int other = expr3();\n      res /= other;\n    }else{\n      return res;\n    }\n  }\n}\nint expr(){\n  int res = expr2();\n  while(true){\n    char op = seek();\n    if(op == '+'){\n      next();\n      int other = expr2();\n      res += other;\n    }else if(op == '-'){\n      next();\n      int other = expr2();\n      res -= other;\n    }else{\n      return res;\n    }\n  }\n}\n\nint eq(){\n  int e = expr();\n  char eqa = next();\n  assert(eqa == '=');\n  return e;\n}\nint solve(string str){\n  c = 0;\n  s = str;\n  return eq();\n}\nsigned main(){\n  int n; cin >> n;\n  rep(i,n){\n    string str; cin >> str;\n    cout << solve(str) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x) << endl;\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\twhile (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\twhile (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\tif(str[i] != '(')val1 = number(str, i);\n\telse if(str[i] == '(') {\n\t\ti++;\n\t\tval1 += siki(str, i);\n\t\ti += 1;\n\t}\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tint val2 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif ( str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tint now = i;\n\t\t\tval2 += number(str, i);\n\t\t\tval1 = val1 * pow(10,i - now);\n\t\t\tval1 += val2;\n\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\nstring input;\ninline int op(const string op, int a, int b)\n{\n    if (op == \"+\")\n        return a + b;\n    if (op == \"-\")\n        return a - b;\n    if (op == \"*\")\n        return a * b;\n    if (op == \"/\")\n        return a / b;\n}\ninline bool is_all_digit(string in)\n{\n    for (auto i : in)\n    {\n        if (!isdigit(i))\n            return false;\n    }\n    return true;\n}\nvector<string> split(string in)\n{\n    vector<string> spl;\n    int pos = 0;\n    if (in[pos] == '-')\n    {\n        pos++;\n        while (pos < in.size())\n        {\n            if (isdigit(in[pos]))\n            {\n                pos++;\n            }\n            else\n            {\n                break;\n            }\n        }\n        spl.push_back(in.substr(0, pos));\n        in.erase(0, pos);\n        pos = 0;\n    }\n    while (pos < in.size())\n    {\n        if (!isdigit(in[pos]))\n        {\n            if (pos != 0)\n            {\n                spl.push_back(in.substr(0, pos));\n                in.erase(0, pos);\n                pos = 0;\n            }\n            else\n            {\n                if (in[0] == '(')\n                {\n                    int cnt = 1;\n                    int r_pos = 1;\n                    for (r_pos = 1; r_pos < in.size(); r_pos++)\n                    {\n                        if (in[r_pos] == '(')\n                            cnt++;\n                        if (in[r_pos] == ')')\n                            cnt--;\n                        if (cnt == 0)\n                            break;\n                    }\n                    spl.push_back(in.substr(pos + 1, r_pos - 1));\n                    in.erase(0, r_pos + 1);\n                    pos = 0;\n                    continue;\n                }\n                else if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n                {\n                    spl.push_back(in.substr(0, 1));\n                    in.erase(0, 1);\n                    pos = 0;\n                }\n            }\n        }\n        else\n        {\n            pos++;\n        }\n    }\n    if (in.size() != 0)\n        spl.push_back(in);\n    return spl;\n}\nint cal(string &in_str)\n{\n    auto in = split(in_str);\n    while (in.size() == 1)\n    {\n        if ((in[0][0] == '-' && is_all_digit(in[0].substr(1))) || (is_all_digit(in[0])))\n            break;\n        in = split(in[0]);\n    }\n    auto pos = in.begin();\n    auto lambda = [&]() {pos--;*pos = to_string(op(*(pos+1),cal(*pos), cal(*(pos + 2))));in.erase(pos + 1, pos + 3); };\n    while (in.size() != 1)\n    {\n        while (pos != in.end())\n        {\n            if (*pos == \"*\" || *pos == \"/\")\n                lambda();\n            if (in.size() == 1)\n                break;\n            if (pos != in.end())\n                pos++;\n        }\n        pos = in.begin();\n        while (pos != in.end())\n        {\n            if (*pos == \"+\" || *pos == \"-\")\n                lambda();\n            if (in.size() == 1)\n                break;\n            if (pos != in.end())\n                pos++;\n        }\n    }\n    return (stoi(in[0]));\n}\nint main()\n{\n\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        cin >> input;\n        input.erase(input.end() - 1);\n        cout << cal(input) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n\nvector<string> toRPN(string s){\n    stack<string> ope;\n    vector<string> ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ){\n            string tmp=\"\";\n            for(int j=i;j<len;j++){\n                if( isdigit(s[j]) )tmp+=s[j];\n                else break;\n            }\n            ret.push_back(tmp);\n            i+=tmp.size()-1;\n            \n        }else{\n            if( s[i]=='(' )ope.push(\"(\");\n            \n            else if( s[i]==')' ){\n                if( ope.empty() )return {\"invalid\"};\n                \n                while( ope.top()!=\"(\" ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                    \n                    if( ope.empty() )return {\"invalid\"};\n                }\n                if( ope.empty() )return {\"invalid\"};\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( ope.size() && ( ope.top()==\"*\" || ope.top()==\"/\" || ope.top()==\"+\" || ope.top()==\"-\" ) ){\n                    ret.push_back( ope.top() );\n                    ope.pop();\n                }\n                ope.push( string(1,s[i]) );\n            }\n        }\n    }\n    while( ope.size() ){\n        ret.push_back( ope.top() );\n        ope.pop();\n    }\n    \n    return ret;\n}\n\n\n\n\nint solveRPN(vector<string> s){\n    stack<int> stk;\n    \n    \n    for(int i=0;i<s.size();i++){\n        if( (s[i]!=\"+\" && s[i]!=\"-\" && s[i]!=\"*\" && s[i]!=\"/\") )stk.push( stoi(s[i])  );\n        else{\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]==\"+\")stk.push(a+b);\n            if(s[i]==\"-\")stk.push(a-b);\n            if(s[i]==\"*\")stk.push(a*b);\n            if(s[i]==\"/\")stk.push(a/b);\n        }\n    }\n    \n    \n    return stk.top();\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        string s;\n        cin>>s;\n        \n        s.erase(s.size()-1);\n        \n        vector<string> poland;\n        poland=toRPN(s);\n        \n//        rep(i,poland.size())cout<<poland[i];cout<<endl;\n        \n        int ans;\n        ans=solveRPN(poland);\n        \n        cout<<ans<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n/*\n exp    ::= term    | exp  + term   | exp  - term\n term   ::= factor  | term * factor | term / factor\n factor ::= literal | (exp) | -factor\n*/\n\nint perseExp( string str );\nint perseTerm( string str );\nint perseFactor( string str );\n\nint perseExp( string str ){\n  //cout << \"perseExp\" << str << endl;\n  int  nest = 0;\n  char op   = 0;\n  int pos;\n  for(int i=str.size()-1; i>0; i--){\n    char c = str[i];\n    if(nest == 0 && (c == '+' || c == '-')){\n      op = c;\n      pos = i;\n      break;\n    }\n    if(c == '('){\n      nest--;\n    }else if(c == ')'){\n      nest++;\n    }\n    if(nest < 0)\n      throw \"Error: perseExp\";\n  }\n  if(op == 0){\n    return perseTerm(str);\n  }else{\n    int op1 = perseExp( str.substr(0, pos) );\n    int op2 = perseTerm( str.substr(pos+1) );\n    if(op == '+'){\n      return op1 + op2;\n    }else{\n      return op1 - op2;\n    }\n  }\n}\n\nint perseTerm( string str ){\n  //cout << \"perseTerm\" << str << endl;\n  int nest = 0;\n  char op = 0;\n  int pos;\n  for(int i=str.size()-1; i>0; i--){\n    char c = str[i];\n    if(nest == 0 && (c == '*' || c == '/')){\n      op = c;\n      pos = i;\n      break;\n    }\n    if(c == '('){\n      nest--;\n    }else if(c == ')'){\n      nest++;\n    }\n    if(nest < 0)\n      throw \"Error: perseTerm\";\n  }\n  if(op == 0){\n    return perseFactor(str);\n  }else{\n    int op1 = perseTerm( str.substr(0, pos) );\n    int op2 = perseFactor( str.substr(pos+1) );\n    if(op == '*'){\n      return op1 * op2;\n    }else{\n      return op1 / op2;\n    }\n  }\n}\n\nint perseFactor( string str ){\n  //cout << \"perseFactor\" << str << endl;\n  if(str.size() == 0)\n    throw \"Parse Error: perseFactor\";\n\n  char firstStr = str[0];\n  if(firstStr == '('){\n    return perseExp( str.substr(1, str.size()-2) );\n  }else if(firstStr == '-'){\n    return -1 * perseFactor( str.substr(1) );\n  }else{\n    bool f = true;\n    for(int i=0; i<str.size(); i++){\n      if(!isdigit(str[i])) f = false;\n    }\n    if(f){\n      int num; sscanf(str.c_str(), \"%d\", &num);\n      return num;\n    }else{\n      return perseExp(str);\n    }\n  }\n}\n\nstring trim(string str){\n  while(str.find(' ') != -1) str.erase(str.find(' '), 1);\n  while(str.find('=') != -1) str.erase(str.find('='), 1);\n  return str;\n}\n\nint main(){\n  int n;\n  string str;\n  getline(cin,str);\n  sscanf(str.c_str(),\"%d\",&n);\n  while(n-->0){\n    getline(cin,str);\n    str = trim(str);\n    int ret = perseExp(str);\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<string>\nusing namespace std;\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n\n  int expression(){\n    int p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+')pos++,p+=term();\n      else pos++,p-=term();\n    }\n    return p;\n  }\n\n  int term(){\n    int p = fact();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*')pos++,p *= term();\n      else pos++,p /= term();\n    }\n    return p;\n  }\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      int p = 0;\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n\tp *= 10;\n\tp += parse[pos]-'0';\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n\n};\n\n\n\n\n\n\n\n\nint main(){\n  string s;\n  int N;\n  cin >> N;\n  while(N-- > 0){\n    cin >> s;\n    Parsing par = Parsing(s.substr(0,s.length()-1));\n    cout << par.expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n\nusing namespace std;\n\nstring calc;\nint cur;\nint digit();\nint number();\nint expression();\nint term();\nint factor();\n\nint main(){\n  int num,i;\n  cin >> num;\n  for (i = 0; i < num; ++i){\n    cin >> calc;\n    calc.resize(calc.size()-1);\n    cur = 0;\n\n    cout << calc << endl;\n    cout << expression() << endl;\n  }\n}\n\nint digit(){\n  assert(isdigit(calc[cur]));\n  int n = calc[cur] - '0';\n  cur++;\n  return n;\n}\n\nint number(){\n  int n = digit();\n  while(cur<calc.size() && isdigit(calc[cur])){\n    n = n*10 + digit();\n  }\n  return n;\n}\n\nint expression(){\n  int sum = term(); \n  while((cur < calc.size())&&(calc[cur]=='+'||calc[cur]=='-')){\n    char op = calc[cur];\n    cur++; // will look at the next num after op\n    int b = term();\n    if(op == '+'){\n      sum += b;\n    }else{\n      sum -= b;\n    }\n  }\n  return sum;\n}\n\nint term(){\n  int a = factor();\n  while((cur < calc.size())&&(calc[cur]=='*'||calc[cur]=='/')){\n    char op = calc[cur];\n    cur++; // will look at the next num after op\n    int b = factor();\n    if(op == '*'){\n      a *= b;\n    }else{\n      a /= b;\n    }\n  }\n  return a;\n}\n\nint factor(){\n  if(calc[cur] != '('){\n    return number();\n  }else{\n    cur++;\n    int n = expression();\n    assert(calc[cur] == ')');\n    cur++;\n    return n;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntemplate<typename T> class Calculation\n{\npublic:\n  static void consume(State& begin, char expected) {\n    if (*begin == expected) {\n      begin++;\n    } else {\n      cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n           << endl;\n      cerr << \"Rest string is '\";\n      while (*begin) {\n        cerr << *begin++;\n      }\n      cerr << \"'\" << endl;\n      throw ParseError();\n    }\n  }\n\n  static T expression(State& begin){\n    T ret = term(begin);\n    while(true){\n      if(*begin == '+'){\n        begin++;\n        ret += term(begin);\n      }\n      else if(*begin == '-'){\n        begin++;\n        ret -= term(begin);\n      }\n      else break;\n    }\n    return ret;\n  }\n\n  static T term(State& begin){\n    T ret = factor(begin);\n    while(true){\n      if(*begin == '*'){\n        begin++;\n        ret *= factor(begin);\n      }\n      else if(*begin == '/'){\n        begin++;\n        ret /= factor(begin);\n      }\n      else break;\n    }\n    return ret;\n  }\n\n  static T factor(State& begin){\n    if(*begin == '('){\n      consume(begin, '(');\n      T ret= expression(begin);\n      consume(begin, ')');\n      return ret;\n    }\n    else{\n      return number(begin);\n    }\n  }\n\n  static T number(State& begin){\n    T ret = 0;\n    for(; isdigit(*begin); begin++){\n      ret *= 10;\n      ret += *begin - '0';\n    }\n    return ret;\n  }\n};\n\nint N;\nstring s;\n\nint main()\n{\n  cin >> N;\n  cin.ignore();\n\n  rep(i, N){\n    getline(cin, s);\n    State begin = s.begin();\n    int res = Calculation<int>::expression(begin);\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\nconst int MOD=1000000007;\nconst int INF=1000000000;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\n\nclass Parser{\npublic:\n\n  int number(State &begin)\n  {\n    int ret=0;\n    while(isdigit(*begin))\n      {\n\tret*=10;\n\tret+=*begin-'0';\n\tbegin++;\n      }\n    return ret;\n  }\n\n  int expression(State &begin)\n  {\n    int ret=term(begin);\n    for(;;)\n      {\n\tif(*begin=='+')\n\t  {\n\t    begin++;\n\t    ret+=term(begin);\n\t  }\n\telse if(*begin=='-')\n\t  {\n\t    begin++;\n\t    ret-=term(begin);\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret;\n  }\n\n  int term(State &begin)\n  {\n    int ret=factor(begin);\n    for(;;)\n      {\n\tif(*begin=='*')\n\t  {\n\t    begin++;\n\t    ret*=factor(begin);\n\t  }\n\telse if(*begin=='/')\n\t  {\n\t    begin++;\n\t    ret/=factor(begin);\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret;\n  }\n\n  int factor(State &begin)\n  {\n    int ret;\n    if(*begin=='(')\n      {\n\tbegin++;\n        ret=expression(begin);\n\tbegin++;\n      }\n    else\n      {\n\tret=number(begin);\n      }\n    return ret;\n  }\n};\n\n\nint main(int argc,char const* argv[])\n{\n  int n;\n  cin >> n;\n  cin.ignore();\n  for(int data=0;data<n;data++)\n    {\n      Parser ps;\n      string s;\n      getline(cin,s);\n      State begin=s.begin();\n      int ans=ps.expression(begin);\n      cout << ans << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint Parse(string a) {\n\tint s = 0;\n\tfor (int b = 0; b < a.length(); b++) {\n\t\ts *= 10;\n\t\ts += a[b] - 48;\n\t}\n\treturn s;\n}\nint main() \n{\n\tint a;\n\tcin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tvector<int>c;\n\t\tvector<char>d;\n\t\tstring e;\n\t\tcin >> e; string g = \"\";\n\t\tfor (int f = 0; f < e.length()-1; f++) {\n\t\t\tif (e[f]<'0' || e[f]>'9') { c.push_back(Parse(g)); g = \"\"; d.push_back(e[f]); }\n\t\t\telse g += e[f];\n\t\t}\n\t\tc.push_back(Parse(g));\n\t\tfor (int o = 0; o < d.size(); o++) {\n\t\t\tif (d[o] == '*') {int q= c[o] * c[o + 1]; c[o + 1] =q; c[o] = q; }\n\t\t\telse if (d[o] == '/') { int q = c[o] / c[o + 1]; c[o + 1] = q; c[o] = q; }\n\t\t}\n\t\tint s = c[0];\n\t\tfor (int k = 0; k < d.size(); k++) {\n\t\t\tif (d[k] == '+')s += c[k+1];\n\t\t\telse if (d[k] == '-')s -= c[k+1];\n\t\t}\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\nint number(State &begin);\n\nint expression(State &begin){\n    int ret = term(begin);\n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret = number(begin);\n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    cin.ignore();\n    for(int i = 0; i < N; i++){\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define LOOP(i,x,n) for(int i=x;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define int long long\nusing namespace std;\nconst int MOD=1000000007;\nconst int INF=1000000009;\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint factor(State &);\n\nvoid consume(State &begin,char expected){\n  if(*begin==expected){\n    begin++;\n  }else{\n    cerr<<\"Expected '\"<<expected<<\"'but got '\"<<*begin<<\"''\"<<endl;\n    cerr<<\"Rest string is '\";\n    while(*begin){\n      cerr<<*begin++;\n    }\n    cerr<<\"'\"<<endl;\n    throw ParseError();\n  }\n}\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=factor(begin);\n  for(;;){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expr(State &begin){\n  int ret=term(begin);\n  for(;;){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expr(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  cin.ignore();\n  REP(i,n){\n    string s;\n    getline(cin,s);\n    State begin=s.begin();\n    int ans=expr(begin);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n \nchar *pt;\nint parseAtom();\nint parseExpr();\nint parseTerm();\nint parseAtom() {\n  if('0' <= *pt && *pt <= '9') {\n    int x = *pt-'0';\n    pt++;\n    while('0' <= *pt && *pt <= '9') {\n      x = x*10 + *pt-'0';\n      pt++;\n    }\n    return x;\n  }\n  if('(' == *pt) {\n    pt++;\n    int x = parseExpr();\n    assert(*pt == ')');\n    pt++;\n    return x;\n  }\n  assert(false);\n  return -1;\n}\nint parseExpr() {\n  int x = parseTerm();\n  while(*pt == '+' || *pt == '-') {\n    if(*pt == '+') {\n      pt++;\n      x += parseTerm();\n    } else {\n      pt++;\n      x -= parseTerm();\n    }\n  }\n  return x;\n}\nint parseTerm() {\n  int x = parseAtom();\n  while(*pt == '*' || *pt == '/') {\n    if(*pt == '*') {\n      pt++;\n      x *= parseAtom();\n    } else {\n      pt++;\n      x /= parseAtom();\n    }\n  }\n  return x;\n}\n \nint main() {\n  int tc; scanf(\"%d\", &tc);\n  for(int tci = 0; tci < tc; tci++) {\n    static char expr[200]; scanf(\" %s\", expr);\n    pt = expr;\n    int x = parseExpr();\n    assert(*pt == '=');\n    printf(\"%d\\n\", x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\n\nchar siki[200];\nint cur;\n\n\nint digit(){\n  int n=siki[cur]-'0';\n  ++cur;\n  return n;\n}\n\nint number(){\n  int n=digit();\n  while(cur<strlen(siki) && isdigit(siki[cur]))\n    n=n*10+digit();\n\n  return n;\n}\n\nint factor();\n\nint term(){\n  int a=factor();\n  while(cur<strlen(siki) && (siki[cur]=='*' || siki[cur]=='/')){\n    char op=siki[cur];\n    ++cur;\n    int b=factor();\n    if(op=='*')a*=b;else a/=b;\n  }\n  return a;\n}\n\nint expression(){\n  int a=term();\n  while(cur<strlen(siki) && (siki[cur]=='+' || siki[cur]=='-')){\n    char op=siki[cur];\n    cur++;\n    int b=term();\n    if(op=='+')a+=b;else a-=b;\n  }\n  return a;\n}\n\nint factor(){\n  if(siki[cur]!='(')return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint main(){\n  int n;\n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>siki;\n    cur=0;\n    cout<<expression()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1 && !is_all_digit(in[0])) {\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\t//input.erase(input.end() - 1);\n\t\t//cout << cal(input) << endl;\n\t\tcerr << input << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define INF 1000000\n\n\nint ar[2][14];\nint main(){\n\tstring str;\n\tint N;\n\tcin>>N;\n\tVI res;\n\tstack <string>st;\n\tREP(ii,N){\n\t\tcin>>str;\n\t\tpriority_queue<pair<int,char> > buf;\n\t\tpriority_queue<pair<int,char> > buf2;\n\t\t\n\t\tbool ch=false;\n\t\tint t=0;\n\t\tvector<string> temp;\n\t\tREP(i,SZ(str)){\n\t\t\tif(str[i]=='+'||str[i]=='-'){\n\t\t\t\tif((!ch&&(buf.empty()||(buf.top()).first<i))||(ch&&(buf2.empty()||(buf2.top()).first<i))){\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\ttemp.PB(toString((buf.top()).second));\n\t\t\t\t\t\tbuf.pop();\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp.PB(toString((buf2.top()).second));\n\t\t\t\t\t\tbuf2.pop();\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(str[i]=='*'||str[i]=='/'){\n\t\t\t\tif(!ch){\n\t\t\t\t\tbuf.push(MP(100+i,str[i]));\n\t\t\t\t}else{\n\t\t\t\t\tbuf2.push(MP(100+i,str[i]));\n\t\t\t\t}\n\t\t\t}else if(str[i]=='('){\n\t\t\t\tch=true;\n\t\t\t}else if(str[i]==')'){\n\t\t\t\twhile(!buf2.empty()){\n\t\t\t\t\ttemp.PB(toString((buf2.top()).second));\n\t\t\t\t\tbuf2.pop();\n\t\t\t\t}\n\t\t\t\tch=false;\n\t\t\t}else if(str[i]=='='){\n\t\t\t\twhile(!buf.empty()){\n\t\t\t\t\ttemp.PB(toString((buf.top()).second));\n\t\t\t\t\tbuf.pop();\n\t\t\t\t}\n\t\t\t}else if(str[i]>='0'&&str[i]<='9'){\n\t\t\t\tif(i+1<SZ(str)&&str[i+1]>='0'&&str[i+1]<='9'){\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\tt*=10;\n\t\t\t\t}else{\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\t//cout<<t<<endl;\n\t\t\t\t\ttemp.PB(toString(t));\n\t\t\t\t\tt=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,SZ(temp))cout<<temp[i];\n\t\tcout<<endl;\n\t\tstack <int> st;\n\t\t/*REP(i,SZ(temp)){\n\t\t\tif(temp[i]==\"+\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1+t2);\n\t\t\t}else if(temp[i]==\"-\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2-t1);\n\t\t\t}else if(temp[i]==\"*\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1*t2);\n\t\t\t}else if(temp[i]==\"/\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2/t1);\n\t\t\t}else{\n\t\t\t\tst.push(toInt(temp[i]));\n\t\t\t}\n\t\t}*/\n\t\tcout<<\"0\"<<endl;\n\t\t//st.pop();\n\t\t\n\t}\n\treturn 0;\n}\n\n/*\n4\n5+4*3+2/6=\n(1+4)*(3+7)/5=\n5+4-3=\n(1+5)*(2+3)=\n*/"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<string>\n \n using namespace std;\n \n int expression();\n int term();\n int factor();\n \n string exp;\n int p;\n \n int expression(){\n     int value = term();\n    while( exp[p] == '+' || exp[p] == '-' ){\n        if ( exp[p] == '+' ) { p++; value += term(); }\n        else { p++; value -= term(); }\n     }\n     return value;\n }\n \n int term(){\n     int value = factor();\n    while( exp[p] == '*' || exp[p] == '/' ){\n        if ( exp[p] == '*' ) { p++; value *= factor(); }\n         else { p++; value /= factor(); }\n     }\n     return value;\n }\n \n int factor(){\n     int value = 0;\n     if ( exp[p] == '(' ){\n         p++; value = expression(); p++;\n     } else {\n         while( isdigit(exp[p]) ) { value = value*10 + exp[p++] - '0';}\n     }\n     return value;\n }\n \n int main(){\n     int tcase; cin >> tcase;\n     for ( int i = 0; i < tcase; i++ ){\n         cin >> exp;\n         p = 0;\n         cout << expression() << endl;\n     }\n     return 0;\n }"
  },
  {
    "language": "C++",
    "code": "//\n//AOJ vol1 109\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n//2017/07/10\n//640009E\n//Yang Bo\n//\n\n#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\n//string?????°??????int???\"??°???\"???????????????\nint digit()\n{\n  int n = S[cur] - '0';\n  cur = cur + 1; //cur?????????????????????????????????(?¬??????°??????)\n  return n;\n}\n\n//?????????????????????????????????????????????????????????\nint number()\n{\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur])) //?????¨?????¨???????????°\n    n = n * 10 + digit();\n  return n;\n}\n\nint expression(); //??£?¨?\n\n//??¬??§????????§?????????\nint bracket()\n{\n  if (S[cur] != '(')\n    return number();\n  cur++;\n  int n = expression();\n  cur++; //')'??????????????????????????????\n  return n;\n}\n\n//????????????????????????\nint term()\n{\n  int a = bracket(); //????????????????????°\n  while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    int b = bracket(); //???????????????????????°(?¶????????????°?????????)\n    if (op == '*')\n      a *= b;\n    else if (op == '/')\n      a /= b;\n  }\n  return a;\n}\n\n//????????????????????????\nint expression()\n{\n  int a = term(); //????????????????????°\n  while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++]; //cur?????????????????????????????????(?????????????????????)\n    int b = term(); //???????????????????????°(?¶????????????°?????????)\n    if (op == '+')\n      a += b;\n    else if (op == '-')\n      a -= b;\n  }\n  return a;\n}\n\nint main()\n{\n  int n; cin >> n;\n  while (n-- > 0) {\n  cin >> S;\n  int a = expression();\n  cout << a << endl;\n  }\n}\n\n/*\n?????£??¨?????????????????´??\\??\\??????????????????????????????????????¨????????????????????§????????????????????????????????£????????§?????????\n?????????????????????????§????????????§????????±????????????????????????????§£???????????????\n(11.A??????????????????????????§????????????????§£?????????????????????????????£???????????£????????????????????????)\n????????¨?????\\????????????????????£???Encryption System?????¢??????????????£????????§????????????????????¨???????§£??????????????????\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\t//while(*now.second!='=' && *now.second!=')'){\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\t//while(*now.second!='=' && *now.second!=')' && *now.second!='+' && *now.second!='-'){\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\tif(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse{\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+*p-'0';\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n}\n\nint main()\n{\n\t//const char* s=\"-6/-4=\";\n\t//parsed p=expr(s);\n\t//cout<<p.first<<\",\"<<p.second<<endl;\n\t\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ref:  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <numeric>\n#include <queue>\n#include <complex>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nint CalcString(char str[100])\n{\n    char varstack[100];   //演算子用のスタック\n    char porstr[100][20]; //逆ポーランド記法配列（数値は文字列、他は1文字）\n    char numstr[20];      //数値\n\n    int i;\n    int k = 0; //stacksize\n    int varstacksize = 0;\n    int numstrsize = 0;\n\n    int strLen = strlen(str);\n    if (strLen == 0)\n    {\n        printf(\"文字列が空です。\\n\");\n        return 0.0;\n    }\n    if (strLen >= 98)\n    {\n        printf(\"文字列が長すぎます。\\n\");\n        return 0.0;\n    }\n\n    //前後に '(', ')' を追加\n    for (i = strLen; i > 0; i--)\n        str[i] = str[i - 1];\n    str[0] = '(';\n    strLen += 2;\n    str[strLen - 1] = ')';\n    str[strLen] = '\\0';\n\n    for (i = 0; i < strLen; i++)\n    {\n        switch (str[i])\n        { //入力文字列の先頭文字\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4': //数値の場合\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '.':\n            numstr[numstrsize] = str[i]; //数値文字列に追加\n            numstrsize++;\n            break;\n        case '+': //+,-の場合は演算子スタックを掃き出す\n        case '-':\n            if (numstrsize > 0)\n            {\n                numstr[numstrsize] = '\\0';\n                strcpy(porstr[k], numstr);\n                k++;\n                numstrsize = 0;\n            }\n            while (varstacksize > 0)\n            { //演算子スタックが空でない場合\n                if (varstack[varstacksize - 1] == '(')\n                {          //stack の top\n                    break; //トップが開き括弧のときはブレイク\n                }\n                //演算子スタックからポーランド記法へ\n                porstr[k][0] = varstack[varstacksize - 1];\n                porstr[k][1] = '\\0';\n                k++;\n                varstacksize--; //演算子スタックから1文字削除\n            }\n            varstack[varstacksize] = str[i];\n            varstacksize++;\n            break;\n        case '*':\n        case '/': //*,/の場合は演算子スタックに追加\n            if (numstrsize > 0)\n            {\n                //数値文字列があればポーランド記法に加える\n                numstr[numstrsize] = '\\0';\n                strcpy(porstr[k], numstr);\n                k++;\n            }\n            numstrsize = 0; //数値文字列の初期化（空にする）\n            if (varstacksize > 0 && (varstack[varstacksize - 1] == '*' || varstack[varstacksize - 1] == '/'))\n            {\n                //演算子スタックからポーランド記法へ\n                porstr[k][0] = varstack[varstacksize - 1];\n                porstr[k][1] = '\\0';\n                k++;\n                varstacksize--; //演算子スタックから1文字削除\n            }\n            varstack[varstacksize] = str[i];\n            varstacksize++;\n            break;\n        case '(':\n            varstack[varstacksize] = str[i]; //演算子スタックへ\n            varstacksize++;\n            break;\n        case ')':\n            if (numstrsize > 0)\n            {\n                //数値文字列があればポーランド記法に加える\n                numstr[numstrsize] = '\\0';\n                strcpy(porstr[k], numstr);\n                k++;\n            }\n            numstrsize = 0; //数値文字列の初期化（空にする）\n            while (varstacksize > 0)\n            { //演算子スタックが空でない間\n                if (varstack[varstacksize - 1] == '(')\n                {\n                    varstacksize--; //開き括弧の時はスタックから消してブレイク\n                    break;\n                }\n                porstr[k][0] = varstack[varstacksize - 1]; //ポーランド記法文字列へ\n                porstr[k][1] = '\\0';\n                k++;\n                varstacksize--; //演算子スタックから1文字削除\n            }\n            break;\n        case '=':\n            break;\n        }\n    }\n\n    //  逆ポーランド記法の計算\n    int numstack[100];\n    int numstacksize = 0;\n\n    for (i = 0; i < k; i++)\n    {\n        if (porstr[i][0] >= '0' && porstr[i][0] <= '9')\n        {\n            numstack[numstacksize] = atof(porstr[i]);\n            numstacksize++;\n        }\n        else\n        {\n            if (numstacksize < 2)\n            {\n                printf(\"エラーです。\\n\");\n                return 0.0;\n            }\n            double ope1, ope2;\n            ope1 = numstack[numstacksize - 2];\n            ope2 = numstack[numstacksize - 1];\n            switch (porstr[i][0])\n            {\n            case '-':\n                numstack[numstacksize - 2] = (ope1 - ope2);\n                break;\n            case '+':\n                numstack[numstacksize - 2] = (ope1 + ope2);\n                break;\n            case '/':\n                numstack[numstacksize - 2] = (ope1 / ope2);\n                break;\n            case '*':\n                numstack[numstacksize - 2] = (ope1 * ope2);\n                break;\n            }\n            numstacksize--;\n        }\n    }\n    if (numstacksize != 1)\n    {\n        printf(\"エラーです。\\n\");\n        return 0.0;\n    }\n\n    return numstack[0];\n}\n\nint main()\n{\n    //テスト用のメイン関数\n\n    char str[100];\n\n    int n;\n    scanf(\"%d\", &n);\n    cin.ignore();\n    while (n--)\n    {\n        scanf(\"%s\",str); //入力数式\n        //逆ポーランド法による計算\n        printf(\"%d\\n\", CalcString(str));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\n#define ans pair<int, int>\nans equation(string s, int p = 0);\nans factor(string s, int p = 0);\nans term(string s, int p = 0);\nint main(){\n  int n;\n  cin >>n;\n  while(n--){\n    string s;\n    cin >>s;\n    ans r = equation(s);\n    cout <<r.first<<endl;\n  }\n  return 0;\n}\nans equation(string s, int p){\n  ans r = factor(s,p);\n  while(s[r.second] == '+' || s[r.second] == '-'){\n    ans r_dash = factor(s,r.second+1);\n    if(s[r.second] == '+'){r.first += r_dash.first;}\n    if(s[r.second] == '-'){r.first -= r_dash.first;}\n    r.second = r_dash.second;\n  }\n  return r;\n}\nans factor(string s, int p){\n  ans r = term(s,p);\n  while(s[r.second] == '*' || s[r.second] == '/'){\n    ans r_dash = term(s,r.second+1);\n    if(s[r.second] == '*'){r.first *= r_dash.first;}\n    if(s[r.second] == '/'){r.first /= r_dash.first;}\n    r.second = r_dash.second;\n  }\n  return r;\n}\nans term(string s, int p){\n  if(s[p] == '('){\n    ans r = equation(s,p+1);\n    r.second++;\n    return r;\n  }\n  else{\n    int v = 0;\n    while(isdigit(s[p])){\n      v = v*10+s[p++]-'0';\n    }\n    return ans(v,p);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nlong long parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')'){\n\t\tbool f=true;\n\t\tfor(int i=1,d=1;i<s.length()-1;i++){\n\t\t\tif     (s[i]=='(')\td++;\n\t\t\telse if(s[i]==')')\td--;\n\t\t\tif(d==0){\tf=false;\tbreak;\t}\n\t\t}\n\t\tif(f)\treturn parse(s.substr(1,s.length()-2));\n\t}\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=0,d=0;i<s.length();i++){\n\t\tif     (s[i]=='(')\td++;\n\t\telse if(s[i]==')')\td--;\n\n\t\telse if(d==0 && prior[s[i]]!=0){\n\t\t\tif(i==0 && prior[s[i]]==1)\tcontinue;\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoll(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nint expr();\nint term();\nint fact();\n\nchar *p;\nchar inp[101];\n\nint main(){\n    int n;\n    cin >> n;\n    cin.ignore();\n    while (n--){\n\tcin.getline(inp, sizeof(inp));\n\tp = inp;\n\tcout << expr() << endl;\n    }\n}\n\nint expr(){\n    int m = 0;\n    m = term();\n    while (*p == '+' || *p == '-'){\n\tif (*p == '+')\n\t    p++, m += term();\n\telse if (*p == '-')\n\t    p++, m -= term();\n    }\n    return m;\n}\n\nint term(){\n    int m = 0;\n    m = fact();\n    while (*p == '*' || *p == '/'){\n\tif (*p == '*')\n\t    p++, m *= fact();\n\telse if (*p == '/')\n\t    p++, m /= fact();\n    }\n    return m;\n}\n\nint fact(){\n    int m = 0;\n    if (*p == '('){\n\tp++;\n\tm = expr();\n\tp++;\n\treturn m;\n    }\n    else {\n\twhile ('0' <= *p && *p <= '9'){\n\t    m *= 10;\n\t    m += *p - '0';\n\t    p++;\n\t}\n    }\n    return m;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nusing namespace std;\n\n \nint number(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\nint main(void){\n  int N;\n  std::cin >> N;\n\n  while(N--){\n    std::string s;\n    std::cin>>s;\n    State begin = s.begin();\n    int ans = expression(begin);\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}\n \nint number(State &begin){\n  int ret = 0;\n \n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n \n  return ret;\n}\n \nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n \n\n \nint expression(State &begin){\n  int num = factor(begin);\n  int sum = 0;\n  \n  for(;;){\n    char ch = *begin;\n    begin++;\n    if(ch == '+'){\n      sum += num;\n      num = factor(begin);\n    } else if(ch == '-'){\n      sum += num;\n      num = -factor(begin);\n    }else if(ch == '*'){\n      num *= factor(begin);\n    }else if(ch == '/'){\n      num /= factor(begin);\n    }else{\n      begin--;\n      break;\n    }\n  }\n  return sum+num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\nint expr(string& s,int& i);\nint term(string& s,int& i);\nint factor(string& s,int& i);\nint number(string& s,int& i);\n\n\nint expr(string& s,int& i){\n  int val = term(s,i);\n  while(s[i]=='+' || s[i]=='-'){\n    char op = s[i];\n    i++;\n    int val2 = term(s,i);\n    if(op=='+')val += val2;\n    else val -= val2;\n  }\n  return val;\n}\n\nint term(string& s,int& i){\n  int val = factor(s,i);\n  while(s[i]=='*' || s[i]=='/'){\n    char op = s[i];\n    i++;\n    int val2 = factor(s,i);\n    if(op=='*')val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\n\nint factor(string& s,int& i){\n  if(isdigit(s[i]))return number(s,i);\n\n\n  i++;\n  int ret = expr(s,i);\n  i++;\n  return ret;\n}\n\nint number(string& s,int& i){\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n=n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(void)\n{\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++){\n    string str;\n    cin >> str;\n    int j=0;\n    cout << expr(str,j) << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nint number(State &begin);\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\n\nbool isdigit(char in) {\n    if((in <= '9') && (in >= '0')) return true;\n    else return false;\n}\n\nint number(State &begin) {\n    int ret = 0;\n    while(isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = factor(begin);\n    for(;;) {\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n            continue;\n        }\n        if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n            continue;\n        }\n        break;\n    }\n    return ret;\n}\n\nint expression(State &begin) {\n    int ret = term(begin);\n    for(;;) {\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n            continue;\n        }\n        if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n            continue;\n        }\n        break;\n    }\n    return ret;\n}\n\nint factor(State &begin) {\n    int ret;\n    if(*begin == '(') {\n        begin++;\n        ret = expression(begin);\n        begin++;\n    } else {\n        ret = number(begin);\n    }\n    return ret;\n}\nint main() {\n    //cout.precision(10);\n    int n;\n    cin >> n;\n    cin.ignore();\n    while(n--){\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <valarray>\n#include <utility>\n#include <tuple>\n#include <cmath>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <cctype>\n\n#if (__cplusplus >= 201703L)\n#include <filesystem>\nnamespace fs = std::filesystem;\n#endif\n\n// boost\n//#define USE_BOOST_IN_CODE\n#ifdef USE_BOOST_IN_CODE\n#include <boost/range.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/strided.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/format.hpp>\n#endif\n\nnamespace {\n\n    using ll = long long;\n    using ull = unsigned long long;\n\n    //vector\n    template <class T>\n    using vec = std::vector<T>;\n\n    template <class T>\n    using vv = vec<vec<T>>;\n\n    constexpr std::size_t operator\"\"_sz(ull n) { return std::size_t (n); }\n        \n    template <class T, class BinaryOperation>\n    constexpr T fold(std::initializer_list<T> args, T init, BinaryOperation op)\n    {\n        return std::accumulate(args.begin(), args.end(), init, op);\n    }\n\n    // numeric_low\n    namespace numeric\n    {\n        template<typename T>\n        constexpr bool isOdd(T x)\n        {\n            return x % 2 != 0;\n        }\n\n        template<typename T>\n        constexpr bool isEven(T x)\n        {\n            return x % 2 == 0;\n        }\n\n        // 最大公約数\n        template<class T>\n        constexpr T gcd(const T x, const T y)\n        {\n            if (x < 0)return gcd(-x, y);\n            if (y < 0)return gcd(x, -y);\n            return (!y) ? x : gcd(y, x % y);\n        }\n\n        // 最小公倍数\n        template<class T>\n        constexpr T lcm(const T x, const T y)\n        {\n            if (x < 0)return lcm(-x, y);\n            if (y < 0)return lcm(x, -y);\n            return x * (y / gcd(x, y));\n        }\n\n        // 素数判定\n        template<class T>\n        constexpr bool isPrime(const T x)\n        {\n            if (x <= 1)return false;\n            for (T i = 2; i * i <= x; ++i)\n                if (x % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    // ビット演算\n    namespace bitOp\n    {\n\n        template <int N>\n        constexpr std::size_t distanceBetween(const std::bitset<N> bit, std::size_t current, bool isNext = true)\n        {\n            if (current > N || current < 0) \n                return -1;\n            const int dir = isNext ? 1 : -1;\n            for (auto i = current + dir; i >= 0 && i < N; i += dir)\n                if (bit[i]) \n                    return (i - current) * dir;\n            return -1;\n        }\n\n        // 次の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenNext(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, true);\n        }\n\n        // 前の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenPrev(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, false);\n        }\n    }\n\n\n#ifdef _MSVC_LANG\n#pragma region Vector\n#endif\n    ///////////////////////////////////////////////////////////\n    // Vector\n\n    template <class T>\n    struct Vec3D\n    {\n        T x, y, z;\n\n        Vec3D() = default;\n\n        constexpr Vec3D(T x, T y, T z)\n            : x {x}, y {y}, z {z}\n        {}\n\n        constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0)\n        {}\n\n        static constexpr T Dot(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n        }\n\n        static constexpr Vec3D Cross(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return {\n                lhs.y*rhs.z - lhs.z*rhs.y,\n                lhs.z*rhs.x - lhs.x*rhs.z,\n                lhs.x*rhs.y - lhs.y*rhs.x\n            };\n        }\n\n        constexpr T dot(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        constexpr Vec3D cross(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        T magnitude() const\n        {\n            return std::sqrt(sqrMagnitude());\n        }\n\n        constexpr T sqrMagnitude() const\n        {\n            return x * x + y * y + z * z;\n        }\n\n        Vec3D normalized() const\n        {\n            return *this / magnitude();\n        }\n\n        Vec3D normalize()\n        {\n            *this = normalized();\n            return *this;\n        }\n\n        constexpr bool isZero() const\n        {\n            return x == 0 && y == 0 && z == 0;\n        }\n\n        constexpr Vec3D operator+() const\n        {\n            return *this;\n        }\n\n        constexpr Vec3D operator-() const\n        {\n            return {-x, -y, -z};\n        }\n\n\n        constexpr Vec3D operator+(Vec3D rhs) const\n        {\n            return {x + rhs.x, y + rhs.y, z + rhs.z};\n        }\n\n        constexpr Vec3D operator-(Vec3D rhs) const\n        {\n            return {x - rhs.x, y - rhs.y, z - rhs.z};\n        }\n\n        template <class U>\n        constexpr Vec3D operator*(U rhs) const\n        {\n            return {x * rhs, y * rhs, z * rhs};\n        }\n\n        template <class U>\n        constexpr Vec3D operator/(U rhs) const\n        {\n            return {x / rhs, y / rhs, z / rhs};\n        }\n\n        constexpr Vec3D& operator+=(const Vec3D& other)\n        {\n            x += other.x;\n            y += other.y;\n            z += other.z;\n            return *this;\n        }\n\n        constexpr Vec3D& operator-=(const Vec3D& other)\n        {\n            x -= other.x;\n            y -= other.y;\n            z -= other.z;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator*=(U s)\n        {\n            x *= s;\n            y *= s;\n            z *= s;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator/=(U s)\n        {\n            x /= s;\n            y /= s;\n            z /= s;\n            return *this;\n        }\n\n    };\n\n    template<class T, class U>\n    inline constexpr Vec3D<T> operator*(U s, Vec3D<T> v)\n    {\n        return {s * v.x, s * v.y, s * v.z};\n    }\n\n    // Vector\n    ///////////////////////////////////////////////////////////\n#ifdef _MSVC_LANG\n#pragma endregion Vector\n#endif\n\n    // argsからハッシュ値を作成\n    template <class... Args>\n    std::size_t hash(Args... args)\n    {\n        return fold({static_cast<std::size_t>(args)...}, 0_sz,\n            [](std::size_t seed, std::size_t x)\n            {\n                // uses magic number from boost\n                return seed ^= x + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n            });\n    }\n\n    template <class Begin, class End>\n    void printAll(Begin beginIter, End endIter, std::string delimiter)\n    {\n        for (auto iter {beginIter}; iter != endIter; ++iter)\n        {\n            std::cout << *iter;\n            if (std::distance(iter, endIter) != 1)\n                std::cout << delimiter;\n        }\n    }\n\n    template <class Container>\n    void printAll(const Container& c, std::string delimiter)\n    {\n        printAll(std::cbegin(c), std::cend(c), delimiter);\n    }\n\n    template<class T>\n    void printAll(const std::initializer_list<T>& ini, std::string delimiter)\n    {\n        printAll(ini.begin(), ini.end(), delimiter);\n    }\n\n    //template <class Container>\n    //std::istream& operator>>(std::istream& is, Container& c)\n    //{\n    //    const auto end = std::end(c);\n    //    for (auto iter = std::begin(c); iter != end; ++iter)\n    //        is >> *iter;\n    //    return is;\n    //}\n\n    \n\n    using State = std::string::const_iterator;\n    class ParseError{};\n\n    int expression(State& begin);\n    int term(State& begin);\n    int number(State& begin);\n    int factor(State& begin);\n\n\n    // 四則演算の式をパースして、その評価結果を返す\n    int expression(State& begin)\n    {\n        int ret {term(begin)};\n\n        while (true)\n        {\n            if (*begin == '+')\n            {\n                ++begin;\n                ret += term(begin);\n            }\n            else if (*begin == '-')\n            {\n                ++begin;\n                ret -= term(begin);\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return ret;\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    int term(State &begin)\n    {\n        int ret {number(begin)};\n        while (true)\n        {\n\n            if (*begin == '*')\n            {\n                ++begin;\n                ret *= factor(begin);\n            }\n            else if (*begin == '/')\n            {\n                ++begin;\n                ret /= factor(begin);\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return ret;\n    }\n\n    // 数をパースして、数を返す。\n    int number(State& begin)\n    {\n        int ret {};\n        while (isdigit(*begin))\n        {\n            ret *= 10;\n            ret += *begin - '0';\n            ++begin;\n        }\n\n        return ret;\n    }\n\n    int factor(State& begin)\n    {\n        if (*begin == '(')\n        {\n            ++begin;\n            int ret = expression(begin);\n            ++begin;\n            return ret;\n        }\n        else\n        {\n            return number(begin);\n        }\n    }\n\n\n    void solve()\n    {\n        using namespace std;\n\n        int n;\n        cin >> n;\n        cin.ignore();\n\n        for (int i = 0; i < n; ++i)\n        {\n            string s;\n            getline(cin, s);\n            auto begin = s.cbegin();\n            cout << expression(begin) << endl;\n        }\n\n\n\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint t;\nint N;\nint d[110], f[110];\nvector<vector<int> > adj(110);\nvoid dfs(int cur){\n    d[cur] = t;\n    t += 1;\n    //cerr << \"visiting \" << cur << \" \" << t << endl;\n    for(int i = 0; i < adj[cur].size(); ++i){\n        int dst = adj[cur][i];\n        if(d[dst] == 0){\n            dfs(dst);\n        }\n    }\n    f[cur] = t;\n    t++;\n}\n\nint main(){\n    cin >> N;\n    t = 1;\n    int u, k;\n    for(int i = 0; i < N; ++i){\n        d[i] = 0;\n        f[i] = 0;\n    }\n    for(int i = 0; i < N; ++i){\n        cin >> u >> k;\n        for(int j = 0; j < k; j++){\n            int v;\n            cin >> v;\n            adj[u].push_back(v);\n        }\n        sort(adj[u].begin(), adj[u].end());\n    }\n    for(int i = 1; i < N+1; ++i){\n        if(d[i] == 0) dfs(i);\n    }\n    \n    for(int i = 1; i < N+1; ++i){\n        cout << 1 << \" \" << d[i] << \" \" << f[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint cal(string&);\nint expression(string&, int&);\nint kou(string&, int&);\nint num(string&, int&);\n\nint cal(string& s) {\n\tint pos = 0;\n\treturn expression(s, pos);\n}\nint expression(string& s, int& pos) {\n\tint left = kou(s, pos);\n\twhile (1) {\n\t\tchar op = s[pos++];\n\t\tif (op == '+') {\n\t\t\tint right = kou(s, pos);\n\t\t\tleft += right;\n\t\t}\n\t\telse if (op == '-') {\n\t\t\tint right = kou(s, pos);\n\t\t\tleft -= right;\n\t\t}\n\t\telse if (op == '=') {\n\t\t\treturn left;\n\t\t}\n\t\telse if (op == ')') {\n\t\t\treturn left;\n\t\t}\n\t}\n}\nint kou(string& s, int& pos) {\n\tint left = num(s, pos);\n\twhile (1) {\n\t\tchar op = s[pos++];\n\t\tif (op == '*') {\n\t\t\tleft *= num(s, pos);\n\t\t}\n\t\telse if (op == '/') {\n\t\t\tleft /= num(s, pos);\n\t\t}\n\t\telse {\n\t\t\t--pos;\n\t\t\treturn left;\n\t\t}\n\t}\n}\nint num(string& s, int& pos) {\n\tint ret = 0;\n\tif (s[pos] == '(') {\n\t\t++pos;\n\t\treturn expression(s, pos);\n\t}\n\telse {\n\t\twhile ('0' <= s[pos] && s[pos] <= '9') {\n\t\t\tret *= 10;\n\t\t\tret += s[pos] - '0';\n\t\t\t++pos;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring s; cin >> s;\n\t\tcout << cal(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint p;\nstring exp;\n\nint term();\nint expression();\nint factor();\n\n\nint expression(){\n     int value;\n\t value=term();\n\t while(exp[p]=='+' || exp[p]=='-'){\n\t\t if(exp[p]=='+'){\n\t\t\t p++;\n\t\t\t value+=term();\n\t\t }\n\t\t else{\n\t\t\t p++;\n\t\t\t value-=term();\n\t\t }\n\t }\n\t return value;\n}\n\n\nint term(){\n\tint value;\n\tvalue=factor();\n\twhile(exp[p]=='*' || exp[p]=='/'){\n\t\tif(exp[p]=='*'){\n\t\t\tp++;\n\t\t\tvalue*=factor();\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\tvalue/=factor();\n\t\t}\n\t}\n\n\treturn value;\n}\n\nint factor(){\n\tint value=0;\n\tif(exp[p]=='('){\n\t\tvalue=expression();\n\t}\n\telse{\n\t\twhile(isdigit(exp[p])){\n\t\t\tvalue=value*10+exp[p++]-'0';\n\t\t}\n\t}\n\treturn value;\n}\n\n\n\nint main()\n{\n\tint i,c;\n\tcin>>c;\n\tfor(i=0;i<c;i++){\n\t\tcin>>exp;\n\t\tp=0;\n\t\tcout<<expression()<<\"\\n\";\n\t\t}\n\tcout<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '/')\n\t\treturn 1;\n\tif(a == '*')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<int> & num_stack, stack<char> & op_stack) {\n\tint a, b;\n\tint c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nint clac(string str) {\n\tstack<int> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tint tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t\telse if(str[i] == '-') {\n\t\t\tint tmp = 0;\n\t\t\ti++;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp * -1);\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority('+')) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push('+');\n\t\t}\n\t}\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nint parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')')\n\t\treturn parse(s.substr(1,s.length()-2));\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=0,d=0;i<s.length();i++){\n\t\tif     (s[i]=='(')\td++;\n\t\telse if(s[i]==')')\td--;\n\n\t\tif(d==0 && prior[s[i]]!=0){\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoi(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  try {\n    for (;;) {\n      if (isdigit(s.peek())) {\n        val *= 10;\n        val += s.peek() - '0';\n        s.next();\n      } else {\n        break;\n      }\n    }\n  } catch (const std::string &) {}\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nusing P   = pair<ll, ll>;\nusing mat = vector<vector<ll>>;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nvoid IOS() { ios::sync_with_stdio(false), cin.tie(0); }\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-12;\n\ntemplate <typename T>\nvoid dump(T x) { cout << x << endl; }\nvoid dumpf(ld x, int t) { cout << setprecision(t) << fixed << x << endl; }\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\ninline ll mod(ll a, ll b) {\n\tif (a > 0) return a % b;\n\tif (a % b == 0) return 0;\n\tll x = -a / b + 1;\n\ta += x * b;\n\treturn a % b;\n}\nll powm(ll a, ll b, ll c) {\n\tif (b == 0)\n\t\treturn 1;\n\telse if (b % 2 == 0) {\n\t\tll d = powm(a, b / 2, c);\n\t\treturn (d * d) % c;\n\t} else\n\t\treturn (a * powm(a, b - 1, c)) % c;\n}\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n//ll dx[4] = {1, 0, -1, 0};\n//ll dy[4] = {0, 1, 0, -1};\n\nll number(State &);\nll factor(State &);\nll term(State &);\nll expr(State &);\n\nll number(State &begin) {\n\tll ret = 0;\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nll factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tll ret = expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\nll term(State &begin) {\n\tll ret = factor(begin);\n\twhile (1) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nll expr(State &begin) {\n\tll ret = term(begin);\n\twhile (1) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\n\t\tState begin = s.begin();\n\t\tdump(expr(begin));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint term(State &begin);\n\nint factor(State &begin);\n\nint number(State &begin);\n\nvoid consume(State &begin,char expected);\n\nint main(){\n  int n;\n  cin>>n;\n  cin.ignore();\n  for(int i=0;i<n;i++){\n    string s;\n    getline(cin,s);\n\n    State begin = s.begin();\n    int ans=expression(begin);\n    consume(begin,'=');\n    cout<<ans<<endl;\n  }\n\n}\n\n\nint number(State &begin){\n  int ret = 0;\n\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  if(*begin =='('){\n    consume(begin,'(');\n    int ret = expression(begin);\n    consume(begin,')');\n    return ret;\n  }\n  else{\n    return number(begin);\n  }\n}\n\n\nint term(State &begin){\n  int ret = number(begin);\n\n  for(;;){\n    if(*begin =='*'){\n      consume(begin,'*');\n      ret *= factor(begin);\n    }\n    else if(*begin =='/'){\n      consume(begin,'/');\n      ret /= factor(begin);\n    }\n    else break;\n  }\n\n  return ret;\n}\n\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  for(;;){\n    if(*begin =='+'){\n      consume(begin,'+');\n      ret += term(begin);\n    }\n    else if(*begin =='-'){\n      consume(begin,'-');\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\n\nvoid consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n      << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return -1;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        string s;\n        cin >> s;\n        s.erase(--s.end());\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint expr(char *& s);\n\nint val(char *& s){\n\tif(*s == '('){\n\t\ts++;\n\t\tint ret = expr(s);\n\t\ts++;\n\t\treturn ret;\n\t}\n\n\tint v = 0;\n\twhile(*s >= '0' && *s <= '9'){\n\t\tv *= 10;\n\t\tv += *s - '0';\n\t\ts++;\n\t}\n\treturn v;\n}\n\nint pri(char *& s){\n\tif(*s == '-'){\n\t\ts++;\n\t\treturn -val(s);\n\t}\n\tint l = val(s);\n\tchar ope = *s;\n\tif(ope != '*' && ope != '/')\n\t\treturn l;\n\ts++;\n\tint r = pri(s);\n\tif(ope == '*')\n\t\treturn l*r;\n\telse\n\t\treturn l/r;\n}\n\nint expr(char *& s){\n\tint l = pri(s);\n\tchar ope = *s;\n\tif(ope != '+' && ope != '-')\n\t\treturn l;\n\ts++;\n\tint r = expr(s);\n\tif(ope == '+')\n\t\treturn l+r;\n\telse\n\t\treturn l-r;\n}\n\nvoid solve()\n{\n\tchar s[101];\n\tcin>>s;\n\tchar *p = s;\n\tcout << expr(p) << endl;\n}\n\nint main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\nclass myCalc {\nprivate:\n\tstd::map<char, int> mOperator;\npublic:\n\tmyCalc( void ) {\n\t\tmOperator['('] = -2;\n\t\tmOperator[')'] = -1;\n\t\tmOperator['+'] = 0;\n\t\tmOperator['-'] = 1;\n\t\tmOperator['/'] = 2;\n\t\tmOperator['*'] = 2;\n\t}\n\tstd::string ToRPN( std::string str ) {\n\t\tstd::string ret;\n\t\tstd::stack<char> st;\n\t\tint len = str.size(), i = 0;\n\t\twhile(i < len) {\n\t\t\tswitch(str[i]) {\n\t\t\tcase '+' :\n\t\t\t\twhile(!st.empty() && mOperator[st.top()] > mOperator[str[i]]) {\n\t\t\t\t\t\tret += st.top(); st.pop();\n\t\t\t\t}\n\t\t\tcase '(':\n\t\t\t\tst.push(str[i++]);\n\t\t\t\tbreak;\n\t\t\tcase '-': case '/': case '*':\n\t\t\t\twhile(!st.empty() && mOperator[st.top()] >= mOperator[str[i]]) {\n\t\t\t\t\tret += st.top(); st.pop();\n\t\t\t\t}\n\t\t\t\tst.push(str[i++]);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(!st.empty() && st.top() != '(') {\n\t\t\t\t\tret += st.top();\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t\t++i;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret += '[';\n\t\t\t\twhile('0' <= str[i] && str[i] <= '9') ret += str[i++];\n\t\t\t\tret += ']';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(!st.empty()) { ret += st.top(); st.pop(); }\n\t\treturn ret;\n\t}\n\tint Calculate( std::string str ) {\n\t\tstd::stack<int> st;\n\t\tint len = str.size(), i = 0;\n\t\twhile(i < len) {\n\t\t\tint a, b;\n\t\t\tswitch(str[i]) {\n\t\t\tcase '+':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(a+b);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tif(!st.empty()) {b = st.top(); st.pop();}\n\t\t\t\telse b = 0;\n\t\t\t\tst.push(b-a);\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(a*b);\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(b/a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t++i; a = 0;\n\t\t\t\twhile(str[i] != ']') {\n\t\t\t\t\ta *= 10;\n\t\t\t\t\ta += (str[i++] - '0');\n\t\t\t\t}\n\t\t\t\tst.push(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn st.top();\n\t}\n};\n\nint main( void )\n{\n\tlong long n;\n\tmyCalc calc;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring in;\n\t\tcin >> in;\n\t\tin.erase(in.size()-1);\n\t\t//cout << in << ' ' << calc.ToRPN(in) << endl;\n\t\tcout << calc.Calculate(calc.ToRPN(in)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\n\ntypedef string::const_iterator State;\n\n\nint expression(State &begin);\n\n\nint number(State &begin)\n{\n\tint ret = 0;\n\t\n\tfor(; isdigit(*begin); begin++) {\n\t\tret = ret * 10 + *begin - '0';\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin)\n{\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\t\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin)\n{\n\tint ret = number(begin);\n\n\twhile(true) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expression(State &begin)\n{\n\tint ret = term(begin);\n\n\twhile(true) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\t\t\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\n\t\tState begin = s.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  Expr = Term { (+|-) Term}\n  Term = Fact { (*|/) Fact}\n  Fact = (Expr) | number\n\n*/\n\n#include<iostream>\n\nusing namespace std;\n\n\ntypedef pair<int,const char*>parsed;\n\n\nparsed expr(const char *p);\nparsed term(const char *p);\nparsed fact(const char *p);\n\n\nparsed expr(const char *p)\n{\n  parsed r=term(p);\n \n while(*r.second=='+'||*r.second=='-'){\n    char op =*r.second;\n    int tmp=r.first;\n    r=term(r.second+1);\n    if(op=='+')r.first=tmp+r.first;\n    else r.first=tmp-r.first;\n  }\n  return r;\n}\n\nparsed term(const char *p)\n{\n  parsed r=fact(p);\n  while(*r.second=='*'||*r.second=='/'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=fact(r.second+1);\n    if(op=='*')r.first=tmp*r.first;\n    else r.first=tmp/r.first;\n  }\n  return r;\n}\n\nparsed fact(const char *p)\n{\n  if(isdigit(*p)){\n    int t=*(p++)-'0';\n    while(isdigit(*p))t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if(*p=='('){\n    parsed r=expr(p+1);\n    if(*r.second!=')')exit(0);\n    return parsed(r.first,r.second+1);\n  }\n  else exit(0);\n}\n\nint main()\n{\n  string str;\n  int n;\n  cin>>n;\n  while(n--){\n\t  cin>>str;\n    cout<<expr(str.c_str()).first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint n;\nstring str;\nint number(int& i);\nint term(int& i);\nint expression(int& i);\nint factor(int& i);\n\nint number(int& i)\n{\n\tint ret = 0;\n\twhile ('0' <= str[i] && str[i] <= '9')\n\t{\n\t\tret *= 10;\n\t\tret += str[i] - '0';\n\t\ti++;\n\t}\n\treturn ret;\n}\n\nint term(int& i)\n{\n\tint ret = factor(i);\n\twhile (true)\n\t{\n\t\tif (str[i] == '*')\n\t\t{\n\t\t\ti++;\n\t\t\tret *= factor(i);\n\t\t}\n\t\telse if (str[i] == '/')\n\t\t{\n\t\t\ti++;\n\t\t\tret /= factor(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(int& i)\n{\n\tint ret = term(i);\n\twhile (true)\n\t{\n\t\tif (str[i] == '+')\n\t\t{\n\t\t\ti++;\n\t\t\tret += term(i);\n\t\t}\n\t\telse if (str[i] == '-')\n\t\t{\n\t\t\ti++;\n\t\t\tret -= term(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(int& i)\n{\n\tint ret = 0;\n\tif (str[i] == '(')\n\t{\n\t\ti++;\n\t\tret = expression(i);\n\t\ti++;\n\t}\n\telse\n\t{\n\t\tret = number(i);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tint i = 0;\n\t\tcout << expression(i) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\nusing namespace std;\n\n//????¨???????????¶????????????¨???????????????\nclass CAL{\nprivate:\n  string m_str;\n  size_t m_cur;\n  int digit();\n  int number();\n  int term();\n  int expression();\n  int factor();\n  int calterm();\npublic:\n  CAL(string str);\n  int cal();\n};\n\n//?????????????????????\nCAL::CAL(string str):\n  m_cur(0)\n{\n  m_str = str;\n  m_str.resize(m_str.size() - 1);\n}\n\n//??????????????°????????°????????????\nint CAL::digit()\n{\n  assert(isdigit(m_str[m_cur]));\n  int n = m_str[m_cur++] - '0';\n  return n;\n}\n\n//??°??????????????¨?????¨???????????°?????¨????????????\nint CAL::number()\n{\n  int n = digit();\n  while(m_cur < m_str.size() && isdigit(m_str[m_cur]))\n    n = n*10 + digit();\n  return n;\n}\n\n//???????????¨?????????????°???\\\nint CAL::term()\n{\n  int a = number();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = number();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????????\nint CAL::expression()\n{\n  int a = term();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = term();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\n//??¬??§???????????????????????°?????¨?????????????????????number()??????????????????\nint CAL::factor()\n{\n  if(m_str[m_cur] != '(') return number();\n  m_cur += 1;\n  int n = expression();\n  assert(m_str[m_cur] == ')');\n  m_cur += 1;\n  return n;\n}\n\n//??¬??§????????£?????´?????????????????¨?????????????°???\\\nint CAL::calterm()\n{\n  int a = factor();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = factor();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\n//??¬??§????????£?????´???????????????????????????????¨????\nint CAL::cal()\n{\n  int a = calterm();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = calterm();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  queue<int> answer;\n  string str;\n  for(int i = 0; i < N; ++i){\n    cin >> str;\n    CAL a(str);\n    answer.push(a.cal());\n  }\n  while(!answer.empty()){\n    cout << answer.front() << endl;\n    answer.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\nstd::cout << std::endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tint total=0,work=0;\n\tint tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(s[oi]=='(' || isNum(s[oi])!=-1){s='+'+s;}\n\t//cout<<s<<endl;\n\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=isNum(s[oi]);\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  //cout<<cs<<endl;\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(48<=c && c<=57){\n\t return c-48;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint expression(void);\n\nstring str;\nint pos;\n\nint factor(void){\n\n  int num = 0;\n  if( isdigit( str[pos] ) ){ // '0' <= str[pos] && str[pos] <= '9' \n    while( isdigit( str[pos] ) ){\n      num *= 10;\n      num += str[pos] - '0';\n      pos++;\n    }\n    return num;\n  }else if( str[pos] == '(' ){\n    pos++;\n    int res = expression();\n    pos++; // ')' テ」ツ?ョテ・ツ按?\n    return res;\n  }\n\n}\n\nint term(void){\n\n  int res = factor();\n  while(1){\n\n    if( str[pos] == '*' ){\n      pos++;\n      res *= factor();\n    }else if( str[pos] == '/' ){\n      pos++;\n      res /= factor();\n    }else break;\n\n  }\n  return res;\n}\n\nint expression(void){\n\n  int res = term();\n  while(1){\n\n    if( str[pos] == '+' ){\n      pos++;\n      res += term();\n    }else if( str[pos] == '-' ){\n      pos++;\n    res -= term();\n    }else break; // '=' テ」ツ?禿」ツ?禿」ツ?ァテ」ツつケテ」ツδォテ」ツδシ\n  }\n  return res;\n}\n\nint main(void){\n\n  int dn;\n  cin >> dn;\n\n  while(dn--){\n    pos = 0;\n    cin >> str;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n//typedef long long ll;\ntypedef int ll;\n\nint it, n;\nstring input;\n\nll expr();\nll term();\nll fact();\n\nll expr() {\n    int v = term();\n    while (input[it] == '+' || input[it] == '-') {\n        if (input[it++] == '+') {\n            v += term();\n        } else {\n            v -= term();\n        }\n    }\n    return v;\n}\n\nll term() {\n    int v = fact();\n    while (input[it] == '*' || input[it] == '/') {\n        if (input[it++] == '*') {\n            v *= term();\n        } else {\n            v = (int)trunc(1.0*v/term());\n            //v /= term();\n        }\n    }\n    return v;\n}\n\nll fact() {\n    int v = 0;\n    if (input[it] == '(') {\n        ++it; // '('\n        v = expr();\n        ++it; // ')'\n    } else {\n        int sign = input[it] == '-' ? ++it, -1 : 1;\n        while ('0' <= input[it] && input[it] <= '9') {\n            v = 10*v + input[it]-'0';\n            ++it;\n        }\n    }\n    return v;\n}\n\nint main() {\n    cin >> n;\n    rep (i,n) {\n        cin >> input;\n        it = 0;\n        cout << expr() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint calculate( int a, int b, char c )\n{\n    if( c == '+' )\n        return a + b;\n    else if( c == '-' )\n        return a - b;\n    else if( c == '*' )\n        return a * b;\n    else if( c == '/' )\n        return a / b;\n    else\n        return a;\n}\n\nint getMax( int a, int b )\n{\n    return a > b ? a : b;\n}\n\nint main()\n{\n    int n;\n    string s;\n    vector<int> d, p;\n    vector<char> c;\n\n    cin >> n;\n\n    for( int i = 0; i < n; i++ )\n    {\n        cin >> s;\n\n        int a = 0, b = 0;\n        for( int j = 0; j < s.size(); j++ )\n        {\n            if( '0' <= s[j] && s[j] <= '9' )\n                a = a * 10 + s[j] - '0';\n            else if( '0' <= s[j-1] && s[j-1] <= '9' )\n            {\n                d.push_back(a);\n                a = 0;\n            }\n            else;\n            \n            if( s[j] == '+' || s[j] == '-' )\n            {\n                c.push_back(s[j]);\n                p.push_back(b+1);\n            }\n            else if( s[j] == '*' || s[j] == '/' )\n            {\n                c.push_back(s[j]);\n                p.push_back(b+2);\n            }\n            else if( s[j] == '(' )\n                b += 10;\n            else if( s[j] == ')' )\n                b -= 10;\n            else;\n        }\n\n        int cnt = c.size();\n        while( cnt-- )\n        {    \n            int m = 0;\n            for( int j = 0; j < p.size(); j++ )\n                m = max( m, p[j] );\n\n            for( int j = 0; j < p.size(); j++ )\n                if( p[j] == m )\n                {\n                    p[j] = 0;\n                    d[j] = calculate( d[j], d[j+1], c[j] );\n                    for( int k = j; k < c.size() - 1; k++ )\n                    {\n                        c[k] = c[k+1];\n                        p[k] = p[k+1];\n                        p[k+1] = 0;\n                    }\n                    for( int k = j + 1; k < d.size() - 1; k++ )\n                        d[k] = d[k+1];\n                    break;\n                }\n        }\n        cout << d[0] << endl;\n        d.clear();\n        c.clear();\n        p.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\nint exp(char* & p);\n\nint num(char* & p) {\n    int ret = 0;\n    while (isdigit(*p)) {\n        ret *= 10;\n        ret += *p - '0';\n        p++;\n    }\n    return ret;\n}\n\nint fac(char* & p) {\n    int ret = 0;\n    if (*p == '(') {\n        p++;\n        ret += exp(p);\n        p++;\n    } else {\n        ret += num(p);\n    }\n    return ret;\n}\n\nint term(char* & p) {\n    int ret = fac(p);\n    while(1) {\n        if (*p == '*') {\n            p++;\n            ret *= fac(p);\n        } else if (*p == '/') {\n            p++;\n            ret /= fac(p);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint exp(char* & p) {\n    int ret = term(p);\n    while(1) {\n        if (*p == '+') {\n            p++;\n            ret += term(p);\n        } else if (*p == '-') {\n            p++;\n            ret -= term(p);\n        } else break;\n    }\n    return ret;\n}\n\nint eval(const string & s){\n    char* p = (char*)s.c_str();\n    return exp(p);\n}\n\nint eval(const char* str){\n    char* p = (char*)str;\n    return exp(p);\n}\n\nusing namespace std;\n\nint main(){\n    char str[128];\n    while(gets(str))\n        cout << eval(str) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cctype>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint expr(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=(*begin)-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret=number(begin);\n\tfor(;;){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tret/=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expr(State &begin){\n\tint ret=factor(begin);\n\tfor(;;){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=factor(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tcin.ignore();\n\tfor(int i=0;i<N;i++){\n\t\tstring str;\n\t\tgetline(cin,str);\n\t\tState begin=str.begin();\n\t\tint ans=expr(begin);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '/':\n    return 2;\n  case '*':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif((cs == '*' || cs == '/') && (str[i] == '*' || str[i] == '/')){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse if(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    hand.push_back(side[i]);\n  }\n  for(int i = 0; i < hand.size(); i++)\n    cout << hand[i] << flush;\n  cout << endl;\n\n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      long long val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  cin >> n;\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<climits>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<bitset>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\ntypedef pair<LL,LL>PLL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define F first\n#define S second\n\ntypedef string::const_iterator State;\nint Number(State &Begin){\n    int ret=0;\n    while(isdigit(*Begin)){\n        ret*=10;\n        ret+=(*Begin)-'0';\n        Begin++;\n    }\n\n    return ret;\n}\nint Expression(State&);\nint Factor(State &Begin){\n    if(*Begin=='('){\n        Begin++;\n        int ret=Expression(Begin);\n        Begin++;\n        return ret;\n    }\n    else return Number(Begin);\n}\n\nint Term(State &Begin){\n    int ret=Factor(Begin);\n    while(true){\n        if(*Begin=='*'){\n            Begin++;\n            ret*=Factor(Begin);\n        }\n        else if(*Begin=='/'){\n            Begin++;\n            ret/=Factor(Begin);\n        }\n        else break;\n    }\n    return ret;\n}\n\nint Expression(State &Begin){\n    int ret=Term(Begin);\n    while(true){\n        if(*Begin=='+'){\n            Begin++;\n            ret+=Term(Begin);\n        }\n        else if(*Begin=='-'){\n            Begin++;\n            ret-=Term(Begin);\n        }\n        else break;\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin>>N;\n    cin.ignore();\n    while(N--){\n        string str;\n        getline(cin,str);\n        State Begin=str.begin();\n        cout<<Expression(Begin)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\nint main(){\n    int n;\n    string s;\n    while(cin>>n){\n        for(int i=0; i<n; i++){\n            cin>>s;\n            int j=0;\n            \n            queue<string> qu;\n            stack<string> st;\n            \n            \n            while(j<s.length()){\n                //cout<<s[j]<<endl;\n                //数値の処理\n                if(s[j]>='0'&&s[j]<='9'){\n                    string s_temp;\n                    \n                    while(s[j]>='0'&&s[j]<='9'){\n                        s_temp+=s[j];\n                        j++;\n                    }\n                    \n                    qu.push(s_temp);\n                    \n                }\n                \n                //括弧の処理\n                else if(s[j]==')'){\n                    while(1){\n                        string s_temp;\n                        s_temp = st.top();\n                        st.pop();\n                        if(s_temp==\"(\"){\n                            break;\n                        }else{\n                            qu.push(s_temp);\n                        }\n                    }\n                    j++;\n                }\n                \n                else if(s[j]=='('){\n                    string s_temp;\n                    s_temp+=s[j];\n                    st.push(s_temp);\n                    j++;\n                }\n                \n                //演算子の処理\n                else if(s[j]=='-'||s[j]=='+'||s[j]=='*'||s[j]=='/'){\n                    string s_temp;\n                    s_temp+=s[j];\n                    if(st.empty()){\n                        st.push(s_temp);\n                        j++;\n                    }else{\n                        if(!(s_temp==\"*\"||s_temp==\"/\")&&(st.top()==\"-\"||(st.top()==\"+\"))){\n                            s_temp = st.top();\n                            st.pop();\n                            qu.push(s_temp);\n                        }else{\n                            st.push(s_temp);\n                            j++;\n                        }\n                    }\n                }\n                //=の処理\n                else if(s[j]=='='){\n                    j++;\n                }\n                \n                \n            }\n            while(!st.empty()){\n                qu.push((st.top()));\n                st.pop();\n            }\n            \n            stack<int> num;\n            while(!qu.empty()){\n                \n                //cout<<qu.front()<<endl;\n                \n                if(qu.front()==\"*\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a*b;\n                    num.push(a);\n                }else if(qu.front()==\"/\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a/b;\n                    num.push(a);\n                    \n                }else if(qu.front()==\"-\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b-a;\n                    num.push(a);\n                }else if(qu.front()==\"+\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=a+b;\n                    num.push(a);\n                }else{\n                    stringstream stream;\n                    stream<<qu.front();\n                    int temp;\n                    stream>>temp;\n                    num.push(temp);\n                }\n                qu.pop();\n            }\n            cout<<num.top();\n        }\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if (op == '+') val += val2;\n    else val -= val2;\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*' || s[i] == '/') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n  if (isdigit(s[i])) return number(s, i);\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n  return ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\n\nint main() {\n  int n = 0;\n  cin >> n;\n  string s;\n  getline(cin, s);\n  for(int i = 0; i < n; i++) {\n    getline(cin, s);\n    s = s.substr(0, s.size() - 1);\n    int i = 0;\n    cout << expr(s, i) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\t\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\t//cout << \"number :: \" << ret << endl;\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = number(begin);\n\t\n\twhile(1) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go factor // *\" << endl;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go factor // /\" << endl;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse break;\n\t}\n\t//cout << \"term :: \" << ret << endl;\n    return ret;\n}\nint expression(State &begin) {\n\tint ret = term(begin);\n\t\n\twhile(1) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go term // +\" << endl;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go term // -\" << endl;\n\t\t\tret -= term(begin);\n        }\n        else break;\n\t}\n\t//cout << \"expression :: \" << ret << endl;\n\treturn ret;\n}\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++; \n\t\t//cout << \"go expression\" << endl;\n\t\tint ret = expression(begin);\n\t\t//cout << \"factor :: \" << ret << endl;\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse return number(begin);\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\t\n\t\tState begin = s.begin();\n\t\t//cout << \"Start !!!\" << endl;\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n#include <cctype>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5+10;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\ntypedef string::const_iterator SC;\n\nint factor(SC&);\n\n// ??°????????????\nint number(SC& begin){\n  int res = 0;\n\n  while(isdigit(*begin)){\n    res *= 10;\n    res += *begin - '0';\n    begin++;\n  }\n\n  return res;\n}\n\n// ??????\nint term(SC& begin){\n  int res = factor(begin);\n\n  while(1){\n    if(*begin == '*'){\n      begin++;\n      res *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      res /= factor(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return res;\n}\n\n// ????????????\nint expression(SC& begin){\n  int res = term(begin);\n\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      res += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      res -= term(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return res;\n}\n\n// ??¬??§?????°????????????\nint factor(SC& begin){\n  if (*begin == '('){\n    begin++;\n    int res = expression(begin);\n    begin++;\n  }\n  else{\n    return number(begin);\n  }\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n && n){\n\t\tstring s;\n\t\tREP(i,n){\n\t\t\tcin >> s;\n\t\t\tSC begin = s.begin();\n\t\t\tcout << expression(begin) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define for(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\nstatic const double eps = 1e-9;\n\ntypedef pair<int, int> p;\ntypedef long long ll;\n\ntemplate<class t>\ninline t sq(t a){return a*a;}\n\nint expr();\nint term();\nint num();\n\nstring s;\nint ptr;\nint expr(){\n\tint x = term();\n\tif(s[ptr] == '+'){\n\t\tptr++;\n\t\tx += expr();\n\t}else if(s[ptr] == '-'){\n\t\tptr++;\n\t\tx -= expr();\n\t}\n\treturn x;\n}\n\nint term(){\n\tint x, y = 1;\n\tif(s[ptr] == '+') ptr++;\n\tif(s[ptr] == '-'){\n\t\ty = -1;\n\t\tptr++;\n\t}\n\tif(s[ptr] == '('){\n\t\tptr++;\n\t\tx = expr();\n\t\tptr++;\n\t}else{\n\t\tx = num();\n\t}\n\tif(s[ptr] == '*'){\n\t\tptr++;\n\t\tx *= term();\n\t}\n\telse if(s[ptr] == '/'){\n\t\tptr++;\n\t\tx/= term();\n\t}\n\treturn x*y;\n}\n\nint num(){\n\tint x = 0;\n\twhile('0' <= s[ptr] && s[ptr] <= '9'){\n\t\tx *= 10;\n\t\tx += (s[ptr]-'0');\n\t\tptr++;\n\t}\n\treturn x;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\tptr = 0;\n\t\tcout << expr() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (int i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nint calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    return int(St.top());\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        cout << calculate(t, B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n//template\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\n//typedef\ntypedef complex<double> Point;\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\n\nclass Arithmetic{\npublic:\n\tstring str;\n\tint n, flag = 1;\n\tvoid init(string s){str = s;n = str.size();}\n\tint add(int a, int b){return a+b;}\n\tint mul(int a, int b){return a*b;}\n\tint div(int a, int b){return a/b;}\n  int sur(int a, int b){return a%b;}\n\t\n\tP get_num(int p){\n\t\tint ans = 0, q = -1, f = 0;\n\t\tif(str[p] == '(')return calc(p+1, 0);\n\t\tif(str[p] == '-'){f = 1;p++;}\n\t\tif(str[p] == '('){P pi = calc(p+1, 0);return P(-pi.fi, pi.se);}\n\t\trepi(i,p,n){\n\t\t\tif(!isdigit(str[i]))break;\n\t\t\tans = ans*10+(str[i]-'0');q = i;\n\t\t}\n\t\tif(f)return P(-ans, q);\n\t\treturn P(ans, q);\n\t}\n\t\n\tP calc(int pp = 0, int f = 0){\n\t\tP pi = get_num(pp);\n\t\tint ans = pi.fi, p = pi.se+1;\n\t\trepi(i,p,n){\n\t\t\tif(f and str[i] == ')')return P(ans, i-1);\n\t\t\tif(str[i] == ')')return P(ans, i);\n\t\t\tif(str[i] == '*' or str[i] == '/' or str[i] == '%'){\n\t\t\t\tpi = get_num(i+1);\n\t\t\t\tif(str[i] == '*')ans = mul(ans, pi.fi);\n\t\t\t\tif(str[i] == '/')ans = div(ans, pi.fi);\n        if(str[i] == '%')ans = sur(ans, pi.fi);\n\t\t\t}\n\t\t\tif(str[i] == '+' or str[i] == '-'){\n\t\t\t\tif(f)return P(ans, i-1);\n\t\t\t\tif(str[i] == '+')pi = calc(i+1, 1);\n\t\t\t\tif(str[i] == '-')pi = calc(i, 1);\n\t\t\t\tans = add(ans, pi.fi);\n\t\t\t}\n\t\t\ti = pi.se;\n\t\t}\n\t\treturn P(ans, n-1);\n\t}\n\tint solve(int ret = -INF){\t//0除算のとき返す値\n\t\tflag = 1;\n\t\tP ans = calc();\n\t\tif(!flag)return ret;\n\t\treturn ans.fi;\n\t}\n};\n\nsigned main(){\n  int n;\n  scanf(\"%lld\", &n);\n  rep(i,n){\n    string str;\n    cin >> str;\n    str.pop_back();\n    Arithmetic A;\n    A.init(str);\n    int ans = A.solve();\n    cout << ans << endl;\n  }\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\n// Parser<int> number = [](Source &s) {\n//   int val = 0;\n//   while (isdigit(s.peek())) {\n//     val *= 10;\n//     val += s.peek() - '0';\n//     s.next();\n//   }\n//   return val;\n// };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << term(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nlong calc2(char *eq){\n\tlong c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\n\nstring cal_mul (string str, int sym) {\n    //cout << str << endl;\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    if (str[0] == '-') sumL = -sumL; \n    int flag = 0;\n    if (str[sym+1] == '-') flag = 1;\n    //dump(flag);\n    while (str[sym+R+flag] >= '0' && str[sym+R+flag] <= '9') {\n        R++;\n    }\n    //dump(L);\n    //dump(R);\n    rep(i ,R-1) {\n        //dump(str[sym+R-i-1+flag]);\n        sumR += mul10(i, str[sym+R-i-1+flag] - '0');\n    }\n    if (flag == 1) sumR = -sumR;\n    //dump(sumL);\n    //dump(sumR);\n    stringstream str_tmp;\n    if (str[0] == '-') rep(i, sym-L) str_tmp << str[i+1];\n    else rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length()-flag; i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            //cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        str = cal_all(str);\n        //?????????????????????\n        int ans = stoi(str);\n        cout << str << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nstring its(int n){\n  stringstream s;\n  s<<n;\n  return s.str();\n}\nstack<string> mep(stack<string> me,string s){\n  int a,b;\n  b=atoi(me.top().c_str());\n  me.pop();\n  a=atoi(me.top().c_str());\n  me.pop();\n  if(s==\"+\")\n    me.push(its(a+b));\n  else if(s==\"-\")\n    me.push(its(a-b));\n  else if(s==\"*\")\n    me.push(its(a*b));\n  else if(s==\"/\")\n    me.push(its(a/b));\n  return me;\n}\nint main(){\n  int h,i,j;\n  int n,len;\n  string s;\n  stack<string> me,st;\n  cin>>n;\n  for(h=0;h<n;h++){\n    cin>>s;\n    len=s.length()-1;\n    for(i=0;i<len;i++){\n      if('0'<=s[i]&&s[i]<='9'){\n\tfor(j=i;j<len;j++)\n\t  if(s[j]<'0'||'9'<s[j])\n\t    break;\t\n\tme.push(s.substr(i,j-i));\n\ti=j-1;\n      }else if(s[i]=='('){\n\tst.push(s.substr(i,1));\n      }else if(s[i]==')'){\n\twhile(st.top()!=\"(\"){\n\t  me=mep(me,st.top());\n\t  st.pop();\n\t}\n\tst.pop();\n      }else if(s[i]=='+'||s[i]=='-'){\n\tif(st.empty());\n\telse if(st.top()==\"(\");\n\telse{\n\t  while(st.empty()==0){\n\t    if(st.top()==\"(\")\n\t      break;\n\t    else{\n\t      me=mep(me,st.top());\n\t      st.pop();\n\t    }\n\t  }\n\t}\n\tst.push(s.substr(i,1));\n      }else if(s[i]=='*'||s[i]=='/'){\n\tif(st.empty());\n\telse if(st.top()==\"(\");\n\telse if(st.top()==\"+\"||st.top()==\"-\");\n\telse{\n\t  while(st.empty()==0){\n\t    if(st.top()==\"(\")\n\t      break;\n\t    else if(st.top()==\"+\"||st.top()==\"-\")\n\t      break;\n\t    else{\n\t      me=mep(me,st.top());\n\t      st.pop();\n\t    }\n\t  }\n\t}\n\tst.push(s.substr(i,1));\n      }\n    }\n    while(st.empty()==0){\n      me=mep(me,st.top());\n      st.pop();\n    }\n    cout<<me.top()<<endl;\n    me.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<cctype>\n#include<math.h>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur = cur + 1;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur]))\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint expression();\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint term(){\n\tint a = number();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint a = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif (op == '+') a += b; else a -= b;\n\t}\n\treturn a;\n}\n\nint parse(){\n\treturn expression();\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++){\n\t\tcur = 0;\n\t\tscanf(\"%s\", &S);\n\t\tS.resize(S.size() - 1);\n\t\tcout << parse() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur;\n\nint digit() {\n  assert(isdigit(S[cur])); // S[cur]が数字でなければストップ。正しく動作すれば実行されない。\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\n\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur])) {\n    n = n * 10 + digit();\n  }\n  return n;\n}\n\nint factor();\nint term() {\n  int a = factor();\n  while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    int b = factor();\n    if (op == '*') {\n      a *= b;\n    } else {\n      a /= b;\n    }\n  }\n  return a;\n}\n\nint expression();\nint factor() {\n  if (S[cur] != '(') return number();\n  assert(S[cur] == '(');\n  cur++;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur++;\n  return n;\n}\n\nint expression() {\n  int a = term();\n  while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++];\n    int b = term();\n    if (op == '+') {\n      a += b;\n    } else {\n      a -= b;\n    }\n  }\n  return a;\n}\n\nint parse() { return expression(); }\n\nint main() {\n  int N;\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    cur = 0;\n    cin >> S;\n    S.resize(S.size()-1); // 最後の=はいらない\n    cout << expression() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <cstddef>\n\nusing namespace std;\n\n\n// ?????????????§?????§£???????????????????????¨???????????????\nclass MathExpress\n{\nprivate:\n    string m_express;\n    size_t m_cur;\n\npublic:\n    MathExpress(string str) : m_express(str), m_cur(0) \n    {\n        m_express.resize(m_express.size() - 1);\n    }\n\n    int digit(); // ???????????°???\n    int number(); // ??°??????????????°????????´???\n    int term();\n    int factor(); \n    int expression();\n};\n\n\nint MathExpress::digit()\n{\n    assert(isdigit(m_express.at(m_cur)));\n\n    int n = m_express.at(m_cur) - '0';\n\n    m_cur += 1;\n\n    //cout << \"digit: \" << n << endl;\n\n    return n;\n}\n\n\nint MathExpress::number()\n{\n    int num = digit();\n\n    while ( m_cur < m_express.size() && isdigit(m_express.at(m_cur)) )\n    {\n        num = num * 10 + digit();\n    }\n\n    //cout << \"number: \" << num << endl;\n\n    return num;\n}\n\n\nint MathExpress::term()\n{\n    int left = factor();\n\n    while (m_cur < m_express.size() \n         && (m_express.at(m_cur) == '*' || m_express.at(m_cur) == '/'))\n    {\n        char op = m_express.at(m_cur++);\n\n        //cout << op << endl;\n\n        int right = number();\n\n        switch (op) {\n            case '*':\n                left *= right;\n                break;\n            case '/':\n                left /= right;\n                break;\n            default:\n                break;\n        }\n\n    }\n\n    //cout << \"term: \" << left << endl;\n\n    return left;\n}\n\n\nint MathExpress::expression()\n{\n    int left = term();\n\n    while (m_cur < m_express.size() \n         && (m_express.at(m_cur) = '+' || m_express.at(m_cur) == '-'))\n    {\n        //cout << m_cur << \" \" << m_express.at(m_cur) << endl;\n        char op = m_express.at(m_cur);\n\n        m_cur += 1;\n\n        //cout << op << endl;\n        //cout << \"hoge\" << endl;\n\n        int right = term();\n\n        //cout << \"hoge\" << endl;\n\n        switch (op) {\n            case '+':\n                //cout << \"hoge\" << endl;\n                left += right;\n                break;\n            case '-':\n                left -= right;\n                break;\n            default:\n                //cout << \"hoge\" << endl;\n                break;\n        }\n\n        //cout << \"left : right = \" << left << \" \" << right << endl;\n    }\n\n    return left;\n}\n\n\nint MathExpress::factor()\n{\n    if (m_express.at(m_cur) != '(') return number();\n\n    m_cur += 1;\n\n    int exp = expression();\n\n    assert (m_express.at(m_cur) == ')');\n\n    m_cur += 1;\n\n    return exp;\n}\n\n\nint main()\n{\n    int data_num;\n    \n    cin >> data_num;\n    \n    cin.clear();\n\n    string val; \n    for (int i = 0; i < data_num; ++i) {\n        cin >> val;\n\n        MathExpress mathexp(val);\n        cout << mathexp.expression() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\nint parse();\nint number();\nint expression();\nint factor();\nchar readchar();\nchar peek();\n\n//------ number ------\n\nint digit()\n{\n    int n = readchar() - '0';\n    return n;\n}\n\nint number()\n{\n    int n = digit();\n    while (peek() != '=' && isdigit(peek()))\n    {\n        n = n * 10 + digit();\n    }\n    return n;\n}\n\n//------ expression ------\n\nint term()\n{\n    int a = factor();\n    while (peek() != '=' && peek() != ')' && (peek() == '*' || peek() == '/'))\n    {\n        char op = readchar();\n        int b = factor();\n\n        if (op == '*')\n            a *= b;\n        else if (op == '/')\n            a /= b;\n    }\n    return a;\n}\n\nint expression()\n{\n    int a = term();\n    while (peek() != '=' && peek() != ')' && (peek() == '+' || peek() == '-'))\n    {\n        char op = readchar();\n        int b = term();\n\n        if (op == '+')\n            a += b;\n        else if (op == '-')\n            a -= b;\n    }\n    return a;\n}\n\nint factor()\n{\n    if (peek() != '(')\n        return number();\n    cur += 1;\n    int n = expression();\n    assert(peek() == ')');\n    cur += 1;\n    return n;\n}\n\n//------ parse ------\n\nint parse()\n{\n    cur = 0;\n    return expression();\n}\n\n//------ READ ------\n\nchar readchar()\n{\n    char ret = S[cur++];\n    return ret;\n}\nchar peek()\n{\n    return S[cur];\n}\n\n//------------------\n\nint main()\n{\n    int N;\n    cin >> N;\n    for (size_t i = 0; i < (size_t)N; i++)\n    {\n        cin >> S;\n        int ans = parse();\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n\n  // ÊàtO\n  bool isInside = false;    \n\n  for(int i = 0; i < str.size(); i++){\n    //    cout << str[i] << endl;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      isInside = true;\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(isInside && str[i] == ')'){\n      // EÊÜÅZqðêÂ¸Âè³Éß·\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n      isInside = false;\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n = 1;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  for(int i = 0; i < n; i++){\n    string str;\n    getline(cin,str);\n    str = str.substr(0,str.size()-1);\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    \n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar* p;\n\nint number();\nint term();\nint expression();\nint program();\n\nint main(){\n\tint n;\tcin>>n;\n\tchar x[100];\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",x);\n\t\tp=x;\n\t\tcout<<expression()<<endl;\n\t}\n\n\treturn 0;\n}\n\nint program(){\n\tint num;\n\tif(*p=='('){\n\t\tp++;\n\t\tnum=expression();\n\t\tp++;\n\t}else num=number();\n\n\treturn num;\n}\n\nint number(){\n\tint num=0;\n\twhile('0'<=*p &&*p<='9'){\n\t\tnum*=10;\tnum+=(*p-'0');\n\t\tp++;\n\t}\n\n\treturn num;\n}\n\nint expression(){\n\tint num=term();\n\twhile(1){\n\t\tif(*p=='+'){\n\t\t\tp++;\n\t\t\tnum+=term();\n\t\t}else if(*p=='-'){\n\t\t\tp++;\n\t\t\tnum-=term();\n\t\t}else break;\n\t}\n\n\treturn num;\n}\n\nint term(){\n\tint num=program();\n\twhile(1){\n\t\tif(*p=='*'){\n\t\t\tp++;\n\t\t\tnum*=program();\n\t\t}else if(*p=='/'){\n\t\t\tp++;\n\t\t\tnum/=program();\n\t\t}else break;\n\t}\n\n\treturn num;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstring s;\nint index;\nint number();\nint factor();\nint term();\nint expr();\nint number(){\n    int n = s[index] - '0';\n    index++;\n    while(isdigit(s[index])){\n        n = n*10 + s[index] - '0';\n        index++;\n    }\n    return n;\n}\nint factor(){\n    if(isdigit(s[index])) return number();\n    index++;\n    int ret = expr();\n    index++;\n    return ret;\n}\nint term(){\n    int val = factor();\n    while(s[index] == '*' || s[index] == '/'){\n        char op = s[index];\n        index++;\n        int tmp = factor();\n        if(op == '*') val *= tmp;\n        else val /= tmp;\n    }\n    return val;\n}\nint expr(){\n    int val = term();\n    while(s[index] == '+' || s[index] == '-'){\n        char op = s[index];\n        index++;\n        int tmp = term();\n        if(op == '+')val += tmp;\n        else val -= tmp;\n    }\n    return val;\n}\nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        index = 0;\n        cin >> s;\n        s.resize(s.size()-1);\n        cout << expr() << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cctype>\n#include <cassert>\nusing namespace std;\nint parse();\nsize_t cur = 0; // 解析開始位置\nstring S;\n\nchar readchar() {\n  assert(cur < S.size());\n  char ret = S[cur];\n  cur += 1;\n  return ret;\n  // return S[cur++]; と一行で書くこともできる\n}\nchar peek() { // 1 文字読むが cur を進めない\n  assert(cur < S.size());\n  return S[cur];\n}\n\nint digit() {\n  assert(isdigit(peek())); // S[cur] が数字であることを確認\n  int n = readchar() - '0'; // ’0’ を 0 に変換\n  return n;\n}\n\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(peek())) // 次も数字か 1 文字先読\n    n = n*10 + digit();\n  return n;\n}\n\nint factor();\nint term() {\n  int a = factor();\n  while (cur < S.size() && peek() != ')' && (peek() == '*' || peek() == '/')) {\n    char op = readchar();\n    int b = factor();\n    if (op == '*') a *= b; else a /= b;\n  }\n  return a;\n}\n\nint expression(); // 前方宣言\nint factor() {\n  if (peek() != '(') return number();\n  cur += 1;\n  int n = expression();\n  assert(peek() == ')');\n  cur += 1;\n  return n;\n}\n\nint expression() {\n  int a = term();\n  while (cur < S.size() && (peek() == '+' || peek() == '-')) { // 足し算か引き算が続く間\n    char op = readchar();\n    int b = term();\n    if (op == '+') {\n      a += b;\n    }\n    else\n    {\n      a -= b;\n    }\n  }\n  return a;\n}\n\n\n\nint parse() { return expression(); }\nint main() {\n  int N;\n  cin >> N;\n  for (int i=0; i<N; ++i) {\n    cur = 0;\n    cin >> S;\n    S.resize(S.size()-1); // 最後の=を無視\n  cout << expression() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n\n  // ÊàtO\n  bool isInside = false;    \n\n  for(int i = 0; i < str.size(); i++){\n    //    cout << str[i] << endl;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      isInside = true;\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // EÊÜÅZqðêÂ¸Âè³Éß·\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n      isInside = false;\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n = 1;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  for(int i = 0; i < n; i++){\n    string str;\n    getline(cin,str);\n    str = str.substr(0,str.size()-1);\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n\n  // ÊàtO\n  bool isInside = false;    \n\n  for(int i = 0; i < str.size(); i++){\n    //    cout << str[i] << endl;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      isInside = true;\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // EÊÜÅZqðêÂ¸Âè³Éß·\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n      isInside = false;\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n = 1;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  for(int i = 0; i < n; i++){\n    string str;\n    getline(cin,str);\n    str = str.substr(0,str.size()-1);\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000\u0000\u0000\u001d\u0000"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cassert>\n#include <cctype>\nusing namespace std;\nstring S;\nsize_t cur = 0;\nint term();\nint factor();\nint expression();\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0'; \n\tcur = cur + 1;\n\treturn n;\n}\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur]))\n\t\tn = n*10 + digit();\n\treturn n;\n}\nint expression(){\n\tint a =term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+') a += b;\n\t\telse a -= b;\n\t}\n\treturn a;\n}\nint term(){\n\tint a =factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur +=1;\n\treturn n;\n}\nint main() {\n\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N;++i){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tsize1 = res.substr(j + 1, i - j - 1).size();\n\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t}\n\n\t//cout << \"!!\" << res << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tif (i == 0)continue;\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = res.substr(j, i - j).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\t//cout << \"!!\" << i  << endl;\n\t\t//cout << res << endl;\n\t\tint pos1, pos2, size;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\t//cout << res.substr(pos1 + 1, pos2 - pos1 - 1) << endl;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tsize = buf.size();\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2 + 1, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = pos1 + size - 1;\n\t\t\t//cout << \"!\" << i << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\t//std::cin>>s;\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\t//consume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\t//consume(begin,'(');\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\t//consume(begin,')');\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n      \n      // else if(str[i] == '+' || str[i] == '-'){\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = tmp;\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n      // else{\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = string(tmp);\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  //  getline(cin,s);\n  //  n = atoi(s.c_str());\n  cin >> n;\n    //  scanf(\"%d\\n\",&n);\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    //  getline(cin,str);\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint getNumber( string& str, int* index )\n{\n\tint ret = 0;\n\twhile( *index < (int)str.size() ){\n\t\tif( str[ *index ] < '0' || str[ *index ] > '9' ){\n\t\t\tbreak;\n\t\t}\n\t\tret *= 10;\n\t\tret += ( str[ *index ] - '0' );\n\t\t++(*index);\n\t}\n\treturn ret;\n}\n\nint rec( string& formula, int* index )\n{\n\tint ret = 0;\n\tvector<int> num_list;\n\tvector<char> sign_list( 1, '.' );\n\tbool end = false;\n\n\twhile( !end && *index < (int)formula.size() ){\n\t\tif( formula[ *index ] >= '0' && formula[ *index ] <= '9' ){\n\t\t\tnum_list.push_back( getNumber( formula, index ) );\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tswitch( formula[ *index ] ){\n\t\t\t\tcase '(':\n\t\t\t\t\t++(*index);\n\t\t\t\t\tnum_list.push_back( rec( formula, index ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\tcase '=':\n\t\t\t\t\t++(*index);\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsign_list.push_back( formula[ *index ] );\n\t\t\t\t\t++(*index);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> num2_list;\n\tvector<char> sign2_list( 1, '.' );\n\n\tfor( int i = 0; i < (int)num_list.size(); ++i ){\n\t\tint num = num_list[ i ];\n\t\tswitch( sign_list[ i ] ){\n\t\t\tcase '.':\n\t\t\t\tret = num;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tret *= num;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tret /= num;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnum2_list.push_back( ret );\n\t\t\t\tret = num;\n\t\t\t\tsign2_list.push_back( sign_list[ i ] );\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tnum2_list.push_back( ret );\n\n\tfor( int i = 0; i < (int)num2_list.size(); ++i ){\n\t\tint num = num2_list[ i ];\n\t\tswitch( sign2_list[ i ] ){\n\t\t\tcase '.':\n\t\t\t\tret = num;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tret += num;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tret -= num;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint solve( string& formula ){\n\tint index = 0;\n\treturn (int)rec( formula, &index );\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor( int i = 0; i < n; ++i ){\n\t\tstring formula;\n\t\tcin >> formula;\n\t\tcout << solve( formula ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint calc(char *s, int &i, bool f = false){\n  int ret = 0;\n  bool flag = i >= 0 && s[i-1] == '(';\n  \n  for(;s[i];){\n    \n    if(s[i] == ')'){\n      if(flag) i++;\n      return ret;\n    }\n    \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\n      i++;\n      \n      if(s[i] == '('){\n        i++;\n\n        if(i-2 < 0) ret += calc(s,i);\n        else if(s[i-2] == '+') ret += calc(s,i,false);\n        else if(s[i-2] == '-') ret -= calc(s,i,false);\n        else if(s[i-2] == '*') ret *= calc(s,i,false);\n        else if(s[i-2] == '/') ret /= calc(s,i,false);\n\n        continue;\n      }\n      \n      if(s[i-1] == '+') ret += calc(s,i,true);\n      else if(s[i-1] == '-') ret -= calc(s,i,true);\n      \n    }else{\n      int start = i-1;\n      int sum = 0;\n      \n      while(!(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '\\0' || s[i] == ')')){\n        sum *= 10;\n        sum += s[i] - '0';\n        i++;\n      }\n      /*\n      debug(ret);\n      debug(sum);\n      debug(s[start]);\n      */\n      \n      if(start < 0){\n        ret += sum;\n      }else{\n        if(s[start] == '(') ret += sum;\n        if(s[start] == '+') ret += sum;\n        if(s[start] == '-') ret += sum;\n        if(s[start] == '*') ret *= sum;\n        if(s[start] == '/') ret /= sum;\n      }\n      \n      if(f && (s[i] == '+' || s[i] == '-')){\n        //debug(i);\n        //debug(s[i]);\n        return ret;\n      }\n      \n      //debug(ret);\n    }\n  }\n\n  //debug(s[i]);\n  //debug(ret);\n  \n  return ret;\n}\n\n\nint main(){\n  char s[SIZE];\n  int t = 0;\n\n  int n;\n\n  scanf(\"%d\",&n);\n\n  while(n--){\n    char s2[SIZE] = {};\n    t = 0;\n    scanf(\"%s\",s);\n\n    s[strlen(s)-1] = '\\0';\n\n    strcat(s2,\"0+\");\n    strcat(s2,s);\n    \n    printf(\"%d\\n\",calc(s2,t));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#!/usr/bin/python3\n\nimport re\nn = int(input())\nfor _ in range(n):\n    print(eval(re.sub(r'(\\d+/\\d+)', r'int(\\1)', input()[0:-1])))"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\nchar e[128];\nint p;\n\nint exp();\nint term();\nint fact();\n\nint exp(){\n  int ret = term();\n  while(e[p] == '+' || e[p] == '-'){\n    if(e[p] == '+'){\n      p++;\n      ret += term();\n    }else if(e[p] == '-'){\n      p++;\n      ret -= term();\n    }\n  }\n  return ret;\n}\n\nint term(){\n  int ret = fact();\n  while(e[p] == '*' || e[p] == '/'){\n    if(e[p] == '*'){\n      p++;\n      ret *= fact();\n    }else if(e[p] == '/'){\n      p++;\n      ret /= fact();\n    }\n  }\n  return ret;\n}\n\nint fact(){\n  int ret = 0;\n  if(e[p] == '('){\n    p++;\n    ret = exp();\n    p++;\n  }\n  while(isdigit(e[p])){\n    ret = ret * 10 + e[p] - '0';\n    p++;\n  }\n  return ret;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  while(n--){\n    scanf(\"%s\", e);\n    p = 0;\n    printf(\"%d\\n\", exp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cctype>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nvoid consume(State &begin, char expected);\nint factor(State &begin);\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\n\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n            << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        consume(begin, '(');\n        int ret = expression(begin);\n        consume(begin, ')');\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            int a = factor(begin);\n            ret *= a;\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    cin.ignore();\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        consume(begin, '=');\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\nint N;\nint parse();\n\nchar readchar(){\n    assert(cur < S.size());\n    return S[cur++];\n}\n\nchar peek(){\n    //assert(cur < S.size());\n    return S[cur];\n}\n\nint digit(){\n    assert(isdigit(peek())); \n    int n = readchar() - '0';\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while (cur < S.size() && isdigit(peek())) {\n        n = n*10 + digit();\n    }\n    return n;\n}\n\n\nint expression();\n\nint factor(){\n    if (peek() != '(') return number();\n    cur += 1;\n    int n = expression();\n    assert(peek() == ')');\n    cur += 1;\n    return n;\n}\n\nint term() {\n    int a = factor();\n    while (cur < S.size() && (peek() == '*' || peek() == '/')){\n        char op = readchar();\n        int b = factor();\n        if (op == '*') a *= b; else a /= b;\n    }\n    return a;\n}\n\nint expression(){\n    int a = term();\n    while (cur < S.size() && (peek() == '+' || peek() == '-')){\n        char op = readchar();\n        int b = term();\n        if (op == '+') a += b; else a -= b;\n    }\n    return a;\n}\n\nint parse() { return expression(); }\n\n\nint main(){\n    cin >> N;\n    for(int i = 0; i < N; i++){\n        cin >> S;\n        cur = 0;\n        int a = parse();\n        cout << a << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<string>\nusing namespace std;\nint pos;\nstring parse;\n/*\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\npublic:\n\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n*/\n\nint fact();\nint term();\nint expression();\n\n  int fact(){\n    if(parse[pos] == '('){\n      pos++;\n      int p = expression();\n      pos++;\n      return p;\n    }else{\n      //int p=0;\n      string p; p.clear();\n      while('0' <= parse[pos] && parse[pos] <= '9'){\n\t//p *= 10;\n\t//p += parse[pos]-'0';\n\tp += parse[pos];\n\tpos++;\n      }\n      //return p;\n      return (atoi)(p.c_str());\n    }\n  }\n\n int term(){\n    int p = fact();\n    while(parse[pos] == '*' || parse[pos] == '/'){\n      if(parse[pos] == '*'){pos++;p *= term();}\n      else {pos++;p /= term();}\n    }\n    return p;\n  }\n\n int expression(){\n    int p = term();\n    while(parse[pos] == '+' || parse[pos] == '-'){\n      if(parse[pos] == '+'){pos++;p+=term();}\n      else {pos++;p-=term();}\n    }\n    return p;\n  } \n \n/*\n};\n*/\n\n\n\n\n\n\n\nint main(){\n  string s;\n  int N;\n  cin >> N;\n  while(N-- > 0){\n    pos = 0;\n    cin >> s;\n    parse = s.substr(0,s.length()-1);\n   \n    //Parsing par = Parsing(s.substr(0,s.length()-1));\n    //cout << par.expression() << endl;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nclass Parser{\n    public:\n\n    string s;\n    int i, n;\n\n    Parser(string s): s(s) {}\n\n    int parse(){\n        i = 0;\n        n = s.length();\n        return expr();\n    }\n\n    private:\n\n    int expr(){\n        int ret = term();\n        while(s[i] != '='){\n            if(s[i] == '+'){\n                i++;\n                ret += term();\n            }else if(s[i] == '-'){\n                i++;\n                ret -= term();\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int term(){\n        int ret = num();\n        while(i < n){\n            if(s[i] == '*'){\n                i++;\n                if(s[i] == '('){\n                    i++;\n                    ret *= expr();\n                    i++;\n                }else{\n                    ret *= num();\n                }\n            }else if(s[i] == '/'){\n                i++;\n                if(s[i] == '('){\n                    i++;\n                    ret /= expr();\n                    i++;\n                }else{\n                    ret /= num();\n                }\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int num(){\n        int ret = s[i] - '0';\n        i++;\n        while(isdigit(s[i])){\n            ret = ret * 10 + (s[i] - '0');\n            i++;\n        }\n        return ret;\n    }\n\n};\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        string s;\n        cin >> s;\n        Parser p = Parser(s);\n        cout << p.parse() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\n\nstring lltostr(ll n) {\n  // cout << \"lltostr \" << n << endl;\n  stringstream ss;\n  ss << n;\n  return ss.str();\n}\n\nll calc(string str) {\n  // ©Á±ª êÎêÔOÌ©Á±ðÍ¸·\n  int p = 0, s = 0;\n  // cout << \"before \" << str << endl;\n  REP(i,str.length()) {\n    if (str[i] == '(') {\n      p++;\n      s = i;\n    }\n    if (str[i] == ')') {\n      if (p==1) {\n        string tmp = lltostr(calc(str.substr(s+1,i-s-1)));\n        str = str.substr(0,s) + tmp + str.substr(i+1);\n        i = s + tmp.length()-1;\n      }\n      p--;\n    }\n  }\n  p = -1;\n  // cout << \"remove () \" << str << endl;\n  REP(i,str.length()) {\n    char c = str[i];\n    if (c=='*' || c=='/') {\n      string a = str.substr(p+1,i-p-1);\n      int q = i;\n      string b;\n      for(i++;i<str.length();i++) {\n        if (i!=q+1 && !isdigit(str[i])) {\n          b = str.substr(q+1,i-q-1);\n          break;\n        }\n      }\n      if (i == str.length())\n        b = str.substr(q+1);\n      string tmp;\n      if (c=='*')\n        tmp = lltostr(atoll(a.c_str()) * atoll(b.c_str()));\n      else if (c=='/')\n        tmp = lltostr(atoll(a.c_str()) / atoll(b.c_str()));\n      str = str.substr(0,p+1) + tmp + str.substr(i);\n      i = p + tmp.length();\n    }\n    if (!isdigit(str[i])) {\n      p = i;\n    }\n  }\n  // cout << \"cal *|/ \" << str << endl;\n  p = -1;\n  REP(i,str.length()) {\n    char c = str[i];\n    if (c=='+' || c=='-') {\n      string a = str.substr(p+1,i-p-1);\n      int q = i;\n      string b;\n      for(i++;i<str.length();i++) {\n        if (i!=q+1 && !isdigit(str[i])) {\n          b = str.substr(q+1,i-q-1);\n          break;\n        }\n      }\n      if (i == str.length())\n        b = str.substr(q+1);\n      string tmp;\n      if (c=='+')\n        tmp = lltostr(atoll(a.c_str()) + atoll(b.c_str()));\n      else if (c=='-')\n        tmp = lltostr(atoll(a.c_str()) - atoll(b.c_str()));\n      str = str.substr(0,p+1) + tmp + str.substr(i);\n      i = p + tmp.length();\n    }\n    if (!isdigit(str[i])) {\n      p = i;\n    }\n  }\n  // cout << \"cal +|- \" << str << endl;\n  return atoll(str.c_str());\n}\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while(n--) {\n    string s;\n    getline(cin,s);\n    s = s.substr(0,s.length()-1);\n    cout << calc(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring str;\nint pos;\n\nint exp();\nint term();\nint factor();\nint henkan(string);\nint ruijou(int);\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i=0;i<n;i++){\n    str=\"\";\n    getchar();\n    while(1){\n      char temp;\n      cin >> temp;\n      if(temp=='=') break;\n      str+=temp;\n    }\n    \n    pos=0;\n    int ans=0;\n    ans=exp();\n\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint exp(){\n  int x=term();\n  \n  while(str[pos]=='+' || str[pos]=='-'){\n    char op=str[pos];\n    pos++;\n    if(op=='+'){\n      x+=term();\n    }\n    else{\n      x-=term();\n    }\n  }\n  return x;\n}\n\nint term(){\n  int x=factor();\n  while(str[pos]=='*' || str[pos]=='/'){\n    char op=str[pos];\n    pos++;\n    if(op=='*') x*=factor();\n    else x/=factor();\n  }\n  return x;\n}\n\nint factor(){\n  int x;\n\n  if(str[pos]=='('){\n    pos++;\n    x=exp();\n    pos++;\n  }\n  else{\n    string number=\"\";\n    int i=pos;\n    while(str[i]>='0' && str[i]<='9'){\n      number+=str[i];\n      i++;\n    }\n    pos=i;\n    x=henkan(number);\n  }\n  \n  return x;\n}\n\nint henkan(string number){\n  int size=number.size();\n  int sum=0;\n  \n  for(int i=0;i<size;i++){\n    sum+=(number[i]-'0')*ruijou(size-i-1);\n  }\n  return sum;\n}\n\nint ruijou(int n){\n  int sum=1;\n  \n  for(int i=0;i<n;i++){\n    sum*=10;\n  }\n  \n  return sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long Int;\ntypedef string::const_iterator Iter;\n\nInt eval(const string&);\nInt expr(Iter&);\nInt term(Iter&);\nInt factor(Iter&);\nInt number(Iter&);\n\nInt eval(const string &s){\n\tIter it = s.begin();\n\treturn expr(it);\n}\n\nInt expr(Iter &it){\n\tInt res = term(it);\n\twhile (true){\n\t\tif (*it == '+'){\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t}\n\t\telse if (*it == '-'){\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt term(Iter &it){\n\tInt res = factor(it);\n\twhile (true){\n\t\tif (*it == '*'){\n\t\t\t++it;\n\t\t\tres *= term(it);\n\t\t}\n\t\telse if (*it == '/'){\n\t\t\t++it;\n\t\t\tres /= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt factor(Iter &it){\n\tif (*it == '('){\n\t\t++it;\n\t\tInt res = expr(it);\n\t\t++it;\n\t\treturn res;\n\t}\n\telse return number(it);\n}\n\nInt number(Iter &it){\n\tInt res = 0;\n\twhile (isdigit(*it)){\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tcout << eval(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(char *s, char *end)\n{\n\t/*for (char *p = s; p != end; p++) printf(\"%c\", *p);\n\tputs(\"\");*/\n\t\n\tvector<int> st;\n\tvector<char> op;\n\t\n\tchar *p = s;\n\twhile (p != end){\n\t\tif (*p == '+' || *p == '-' || *p == '*' || *p == '/'){\n\t\t\top.push_back(*p);\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p >= '0' && *p <= '9'){\n\t\t\tint n = atoi(p);\n\t\t\tst.push_back(n);\n\t\t\tstringstream ss;\n\t\t\tss << n;\n\t\t\tp += ss.str().size() - 1;\n\t\t}\n\t\telse if (*p == '('){\n\t\t\tchar *e;\n\t\t\tfor (e = p + 1; *e != ')'; e++);\n\t\t\tst.push_back(calc(p + 1, e));\n\t\t\tp = e;\n\t\t}\n\t\tif (op.size() && (op.back() == '*' || op.back() == '/')){\n\t\t\tint b = st.back(); st.pop_back();\n\t\t\tint a = st.back(); st.pop_back();\n\t\t\tif (op.back() == '*') a *= b;\n\t\t\tif (op.back() == '/') a /= b;\n\t\t\tst.push_back(a);\n\t\t\top.pop_back();\n\t\t}\n\t\tp++;\n\t\t\n\t\t/*printf(\"__\");\n\t\tfor (auto a : st) printf(\"%d \", a);\n\t\tputs(\"\");*/\n\t}\n\t\n\twhile (op.size()){\n\t\tint t = st.front(); st.erase(st.begin());\n\t\tif (op.front() == '+') st[0] = t + st[0];\n\t\tif (op.front() == '-') st[0] = t - st[0];\n\t\top.erase(op.begin());\n\t}\n\t\n\treturn st[0];\n}\n\nint main()\n{\n\tint n;\n\tchar str[1024];\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%s\", str);\n\t\tstr[strlen(str) - 1] = '\\0';\n\t\tprintf(\"%d\\n\", calc(str, str + strlen(str)));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring s;\n\nint single(int& pos);\n\nint figure(int& pos);\n\nint solve(int& pos);\n\nint main(){\n\tint T;\n\tcin>>T;\n\tfor(int i = 0; i < T; i++){\n\t\tcin>>s;\n\t\tint pos = 0;\n\t\tcout<<solve(pos)<<endl;\n\t}\n\t\n\treturn 0;\n}\n\nint single(int& pos){//??°??????????????????????????¢??°\n\tif(s[pos]!='('){\n\t\tint res = 0;\n\t\twhile('0'<=s[pos] && s[pos]<='9'){\n\t\t\tres *= 10;\n\t\t\tres += s[pos]-48;\n\t\t\tpos++;\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn solve(++pos);\n\t}\n}\n\nint figure(int& pos){//????????????????????????????????¢??°\n\tint res = single(pos);\n\twhile(1){\n\t\tif(s[pos]=='*'){\n\t\t\tres *= single(++pos);\n\t\t}else if(s[pos]=='/'){\n\t\t\tres /= single(++pos);\n\t\t}else {\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nint solve(int& pos){//?????¨???????¨????????????¢??°(????????????????¨?????????????????????¨?????????)\n\tint res = figure(pos);\n\twhile(s[pos]!='=' && s[pos]!=')'){\n\t\tif(s[pos]=='+') res += figure(++pos);\n\t\telse if(s[pos]=='-') res -= figure(++pos);\n\t}\n\tpos++;\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\n\nusing namespace std;\n\nstring str;\nint cur = 0;\n\nint expression();\nint term();\nint factor();\n\nint digit() {\n    assert(isdigit(str[cur]));\n    int a = str[cur] - '0';\n    cur++;\n    return a;\n}\n\nint number() {\n    int a = digit();\n    while (cur < str.size() && isdigit(str[cur])) {\n        a = a * 10 + digit();\n    }\n    return a;\n}\n\nint expression() {\n    int a = factor();\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        if (str[cur] == '+') {\n            cur++;\n            int b = factor();\n            a += b;\n        } else if (str[cur] == '-') {\n            cur++;\n            int b = factor();\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint term() {\n    int a = number();\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        if (str[cur] == '*') {\n            cur++;\n            int b = factor();\n            a *= b;\n        } else if (str[cur] == '/') {\n            cur++;\n            int b = factor();\n            a /= b;\n        }\n        cur++;\n    }\n    return a;\n}\n\nint factor() {\n    if (str[cur] != '(') return term();\n\n    cur++;\n    int a = expression();\n    assert(str[cur] == ')');\n    cur++;\n    return a;\n}\n\nint main() {\n    int N = 0;\n    cin>>N;\n    for (int n = 0; n < N; n++) {\n        cin>>str;\n        cur = 0;\n        cout<<expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint pri(char ch) \n{\n    if (ch == '*' || ch == '/')\n        return 2;\n    if (ch == '+' || ch == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    while (n--) {\n        string exp, cha;\n        stack<char> pol;\n        stack<int> cal;\n\n        cin >> exp;\n        for (int i = 0; i < exp.size() - 1; i++) {\n\n            if ('0' <= exp[i] && exp[i] <= '9')\n                cha.push_back(exp[i]);\n            else if (exp[i] == '(')\n                pol.push(exp[i]);\n            else if (exp[i] == ')') {\n                while (true) {\n                    if (pol.top() == '(') {\n                        pol.pop();\n                        break;\n                    }\n                    cha.push_back(pol.top());\n                    pol.pop();\n\n                }\n            }\n            else {\n                while (!pol.empty()) {\n                    if (pri(exp[i]) < pri(pol.top())) {\n                        cha.push_back(pol.top());\n                        pol.pop();\n                    }\n                    else \n                        break;\n                }\n                pol.push(exp[i]);\n            }\n        }\n\n        while (!pol.empty()) {\n            cha.push_back(pol.top());\n            pol.pop();\n        }\n\n        for (int i = 0; i < cha.size(); i++) {\n            if ('0' <= cha[i] && cha[i] <= '9')\n                cal.push(cha[i] - '0');\n            else {\n                int a, b;\n\n                b = cal.top();\n                cal.pop();\n                a = cal.top();\n                cal.pop();\n\n                if (cha[i] == '*') \n                    cal.push(a * b);\n                else if (cha[i] == '/') \n                    cal.push(a / b);\n                else if (cha[i] == '+') \n                    cal.push(a + b);\n                else if (cha[i] == '-') \n                    cal.push(a - b);\n            }\n        }\n        cout << cal.top() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <string>\n#include <map>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nint n;\nstring S;\nint cur;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur++;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur < S.size() && isdigit(S[cur])){\n\t\tn = n * 10 + digit();\n\t}\n\treturn n;\n}\n\nint term(){\n\tint sum = number();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = number();\n\t\tif(op == '*') sum *= b;\n\t\telse sum /= b;\n\t}\n\treturn sum;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = term();\n\t\tif(op == '+') sum += b;\n\t\telse sum -= b;\n\t}\n\treturn sum;\n\t\n}\n\n\n\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur++;\n\tint n = expression();\n\tcur++;\n\treturn n;\t\n}\n\n\nint main(void){\n\n\tcin >> n;\n\n\tfor(int i = 0; i < n; i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nclass Parsing {\npublic:\n    using State = string::const_iterator;\nprivate:\n    class ParseError : std::exception {};\n    int term(State &begin) {//??????\n        int ret = factor(begin);\n        while (true) {\n            if (*begin == '*') {\n                begin++;\n                ret *= factor(begin);\n            } else if (*begin == '/') {\n                begin++;\n                ret /= factor(begin);\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\n    int number(State &begin) {  //??°???\n        int ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += (*begin) - '0';\n            begin++;\n        }\n        return ret;\n    }\n    int factor(State &begin) {  //?????????\n        int ret = 0;\n        if (*begin == '(') {\n            begin++;\n            ret += expression(begin);\n            begin++;\n        } else {\n            ret += number(begin);\n        }\n        return ret;\n    }\n    int expression(State &begin) {//????????????\n        int ret = term(begin);\n        while (true) {\n            if (*begin == '+') {\n                begin++;\n                ret += term(begin);\n            } else if (*begin == '-') {\n                begin++;\n                ret -= term(begin);\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\npublic:\n    Parsing() {}\n    int getans(const string &s) {\n        State itr = s.begin();\n        int ans = 0;\n        while (itr != s.end()) {\n            ans += expression(itr);\n        }\n        return ans;\n    }\n};\n\nvoid solve(int n) {\n    Parsing ps;\n    while (n--) {\n        string s;\n        cin >> s;\n        s.pop_back();\n        cout << ps.getans(s) << endl;\n    }\n    return;\n}\n\nsigned main(void) {\n    int n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    while (cin >> n) {\n        solve(n);\n        return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint compute(string s) {\n    int begin;\n    int nest = 0;\n    int n = 0;\n    vector<int> children, children2;\n    vector<char> operators, operators2;\n\n    for (int i=0; i<(int)s.length(); i++) {\n        if (s[i] == '(') {\n            nest++;\n            if (nest == 1) {\n                begin = i+1;\n            }\n        }\n        else if (s[i] == ')') {\n            if (nest == 1) {\n                string substr = s.substr(begin, i-begin);\n                n = compute(substr);\n            }\n            nest--;\n        }\n        else if (nest == 0) {\n            if ('0' <= s[i] && s[i] <= '9') {\n                n *= 10;\n                n += s[i]-'0';\n            }\n            else {\n                children.push_back(n);\n                operators.push_back(s[i]);\n                n = 0;\n            }\n        }\n    }\n    children.push_back(n);\n    children2.push_back(children[0]);\n    for (int i=0; i<(int)operators.size(); i++) {\n        if (operators[i] == '*') {\n            children2[children2.size()-1] *= children[i+1];\n        }\n        else if (operators[i] == '/') {\n            children2[children2.size()-1] /= children[i+1];\n        }\n        else {\n            children2.push_back(children[i+1]);\n            operators2.push_back(operators[i]);\n        }\n    }\n    n = children2[0];\n    for (int i=0; i<(int)operators2.size(); i++) {\n        if (operators2[i] == '+') {\n            n += children2[i+1];\n        }\n        else {\n            n -= children2[i+1];\n        }\n    }\n    return n;\n}\n\nint main() {\n    int n;\n    string s;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n        cin >> s;\n        cout << compute(s.substr(0, s.length()-1)) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(string delim,string str){\n\tvector<string> res;\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ) res.push_back(str.substr(i,j-1));\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstring calc(vector<string> v){\n\tstack<string> stk;\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"-\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2-num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2+num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"*\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2*num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"/\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2/num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse{\n\t\t\tstk.push(v[i]);\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nvector<string> rvs_polish(string str){\n\tstack<string> stk;\n\tvector<string> v;\n\n\tstring tmp=\"\";\n\tvector<string> res;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='*'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"*\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='-'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"-\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='/'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"/\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='+'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"+\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='='){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"=\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse{\n\t\t\ttmp+=str.substr(i,1);\n\t\t}\n\t}\n\n\tv.push_back(tmp);\n\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"*\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\"){\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"/\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"/\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\" || opr == \"*\"){\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"-\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres.push_back(v[i]);\n\t\t}\n\t}\n\n\twhile(!stk.empty()){\n\t\tres.push_back(stk.top());\n\t\tstk.pop();\n\t}\n\n\treturn res;\n}\n\nstring dfs(string str){\n\tint rc=0,lc=0;\n\tstack<P> stk;\n\tstring res=\"\";\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='(') {stk.push(P('(',i));}\n\t\telse if(str[i]==')') {\n\t\t\tchar sym = stk.top().first;\n\t\t\tif(sym != '(') continue;\n\n\t\t\tint pos = stk.top().second;\n\t\t\tstk.pop();\n\n\t\t\tvector<string> pol = rvs_polish(str.substr(pos+1,(i-1)-(pos+1)+1));\n\t\t\tstring num = calc(pol);\n\t\t\tres+=num;\n\t\t}\n\t\telse if(stk.empty() || (!stk.empty() && stk.top().first != '(')){\n\t\t\tres+=str[i];\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tint n;\n\t\tsscanf(str.c_str(),\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\t\t\tstring str1 = dfs(str.substr(0,str.size()-1));\n\t\t\tvector<string> pol = rvs_polish(str1);\n\t\t\tstring num = calc(pol);\n\n\t\t\tcout << num << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n// <四則演算> ::= <乗除算> | <四則演算> + <乗除算> | <四則演算> - <乗除算>\n// <乗除算>   ::= <括弧か数> | <乗除算> * <括弧か数> | <乗除算> / <括弧か数>\n// <括弧か数> ::= ( <四則演算> ) | <数>\n// <数>       ::= [数]\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expr(State&);\nint term(State&);\nint factor(State&);\nint number(State&);\n\n// 四則演算の式\nint expr(State &begin)\n{\n    int ret = term(begin);\n    while (true) {\n        if (*begin == '+') {\n            begin++; // skip '+'\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\n\n// 乗除算\nint term(State &begin)\n{\n    int ret = factor(begin);\n    while (true) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\n\n// 括弧か数\nint factor(State &begin)\n{\n    if (*begin == '(') {\n        begin++; // skip '('\n        int ret = expr(begin);\n        begin++; // skip ')'\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\n\n// 数字\nint number(State &begin)\n{\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += (*begin - '0');\n        begin++;\n    }\n    return ret;\n}\n\n\nint main()\n{\n    int N; cin >> N;\n    rep(i, N) {\n        string S; cin >> S;\n        State begin = S.begin();\n        cout << expr(begin) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint factor(State &begin);\n\nint number(State &begin)\n{\n\tint ret = 0;\n\n\twhile(isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn  ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile(true)\n\t{\n\t\tif(*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if(*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expression(State &begin)\n{\n\tint ret = term(begin);\n\n\twhile(true)\n\t{\n\t\tif(*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if(*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n\nint factor(State &begin)\n{\n\tint ret;\n\n\tif(*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\twhile(n--)\n\t{\n\t\tstring s;\n\t\tgetline(cin,s);\n\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ntemplate <class _Tt>\nclass calculate {\npublic:\n    enum op {NUM,ADD,SUB,MUL,DIV,LPA,RPA};\nprivate:\n    typedef pair<op, _Tt> pt; \n    deque<pt> mq;\n    void popf(deque<pt> &q, op &type, _Tt &num){\n        type = q.front().first; num = q.front().second;\n        q.pop_front();\n    }\n    void popb(deque<pt> &q, op &type, _Tt &num){\n        type = q.back().first; num = q.back().second;\n        q.pop_back();\n    }\n    _Tt cal2(deque<pt> &q){\n        op sop, dop; _Tt snum, dnum, num = 0;\n        while(!q.empty()){\n            popf(q, sop, snum);\n            switch(sop){\n            case NUM: num = snum; break;\n            case ADD: case SUB:\n                popf(q, dop, dnum); dbgchk(dop != NUM);\n                num = (sop == ADD) ? num+dnum : num-dnum;\n                break;\n            default: throw;\n            }\n\n        }\n        return num;\n    }\n    _Tt cal(deque<pt> &q){\n        deque<pt> s;\n        while(!q.empty()){\n            op qop; _Tt num;\n            popf(q, qop, num);\n            switch(qop){\n            case NUM: case ADD: case SUB:\n                s.pb(mp(qop,num)); break;\n            case LPA:\n                s.pb(mp(NUM,cal(q))); break;\n            case RPA:\n                return cal2(s); break;\n            case MUL: case DIV:\n                op sop, dop; _Tt snum, dnum;\n                popb(s, sop, snum); dbgchk(sop != NUM);\n                popf(q, dop, dnum); dbgchk(dop != NUM && dop != LPA);\n                if(dop == LPA) dnum = cal(q);\n                _Tt r = (qop == MUL) ? snum*dnum : snum/dnum;\n                s.pb(mp(NUM,r));\n                break;\n            }\n        }\n        return cal2(s);\n    }\npublic:\n    void add(_Tt n){ mq.pb(mp(NUM,n)); }\n    void add(op opr){ mq.pb(mp(opr,0)); }\n    _Tt result(){ return cal(mq); }\n};\n\nvoid solve(string s){\n    int n = s.length();\n    calculate<int> calc;\n    REP(i,n){\n        if(isdigit(s[i])){\n            calc.add(atoi(s.c_str()+i));\n            continue;\n        }\n        if(s[i] == '=') break;\n        switch(s[i]){\n        case '+': calc.add(calc.ADD); break;\n        case '-': calc.add(calc.SUB); break;\n        case '*': calc.add(calc.MUL); break;\n        case '/': calc.add(calc.DIV); break;\n        case '(': calc.add(calc.LPA); break;\n        case ')': calc.add(calc.RPA); break;\n        }\n    }\n    cout << calc.result() << endl;\n}\n\nint main(){\n    int n;\n    string s; getline(cin, s);\n    istringstream ss(s); ss >> n;\n    REP(i,n){\n        getline(cin, s);\n        solve(s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\nchar s[111];\nint cur,len;\n\nint shiki();\n\nint kazu()\n{\n  if( s[cur] == '(' ) {\n    cur += 1;\n    int s = shiki();\n    cur += 1;\n    return s;\n  } else {\n    int a = s[cur]-'0';\n    cur += 1;\n    while( isdigit(s[cur]) ) {\n      a *= 10;\n      a += s[cur]-'0';\n      cur += 1;\n    }\n    return a;\n  }\n}          \n\nint kou()\n{\n  int a = kazu();\n  while( s[cur] == '*' || s[cur] == '/' ) {\n    char o = s[cur]; cur += 1;\n    int b = kazu();\n    o=='*'?(a*=b):(a/=b);\n  }\n  return a;\n}\n\nint shiki()\n{\n  int a = kou();\n  while( s[cur] == '+' || s[cur] == '-' ) {\n    char o = s[cur]; cur += 1;\n    int b = kou();\n    if( o == '+' ) a += b;\n    else a -= b;\n  }\n  return a;\n}\n\nint parse()\n{\n  len = 0;\n  while( s[len] ) len++;\n  len--;\n  cur = 0;\n  return shiki();\n}\n\nint main(void)\n{\n  int n; scanf(\"%d\",&n);\n  while( n-- ) {\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",parse());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint num(string&, int&);\nint fact(string&, int&);\nint mul(string&, int&);\nint expr(string&, int&);\n\nint num(string &s, int &k) {\n    int ret = 0;\n    while ('0' <= s[k] && s[k] <= '9') {\n        ret *= 10;\n        ret += s[k] - '0';\n        k ++;\n    }\n    return ret;\n}\n\nint fact(string &s, int &k) {\n    int ret;\n    if (s[k] == '(') {\n        ret = expr(s, ++k);\n        k ++;\n    } else if (s[k] == '-') {\n        ret = -num(s, ++k);\n    } else if (s[k] == '+') {\n        ret = num(s, ++k);\n    } else {\n        ret = num(s, k);\n    }\n    return ret;\n}\n\nint mul(string &s, int &k) {\n    int ret = fact(s, k);\n    while (1) {\n        if (s[k] == '*') {\n            ret *= fact(s, ++k);\n        } else if (s[k] == '/') {\n            ret /= fact(s, ++k);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint expr(string &s, int &k) {\n    int ret = mul(s, k);\n    while (1) {\n        if (s[k] == '+') {\n            ret += mul(s, ++k);\n        } else if (s[k] == '-') {\n            ret -= mul(s, ++k);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string s;\n    while (n--) {\n        cin >> s;\n        int pos = 0;\n        cout << expr(s, pos) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cctype>\n#include<stdio.h>\nusing namespace std;\nint ex(char **b);\nint te(char **b);\nint fu(char **b);\nint num(char **b);\nint main(){\n\tint n;\n\tchar s[1000];\n\tscanf(\"%d\\n\",&n);\n\twhile(n--){\n\t\tscanf(\"%s\",s);\n\t\tchar *p = s;\n\t\tprintf(\"%d\\n\",ex(&p));\n\t}\n}\n\n\n//和差\nint ex(char **b){\n\tint r=te(b);\n\tfor(;;){\n\t\tif(**b=='+')r+=te(&(++*b));\n\t\telse if(**b=='-')r-=te(&(++*b));\n\t\telse break;\n\t}\n\treturn r;\n}\n//乗除\nint te(char **b){\n\tint r=fu(b);\n\tfor(;;){\n\t\tif(**b=='*')r*=fu(&(++*b));\n\t\telse if(**b=='/')r/=fu(&(++*b));\n\t\telse break;\n\t}\n\treturn r;\n}\n//数字\nint num(char **b){\n\tint r=0,cnt=0;\n\twhile(isdigit(**b)){\n\t\tr*=10;\n\t\tr+=**b-'0';\n\t\t++*b;\n\t\tcnt++;\n\t}\n\treturn r;\n}\n//括弧\nint fu(char **b){\n\tif(**b=='('){\n\t\tint r=ex(&(++*b));\n\t\t++*b;\n\t\treturn r;\n\t}\n\telse return num(b);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<stack>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define rep(l,r,i) for(int i=l;i<r;i++)\n#define P pair<int,int>\n#define ll long long \n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\n\nint number(State &begin){\n    int ret=0;\n\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin-'0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint factor(State &begin){\n    int ret=0;\n\n    if(*begin=='('){\n        begin++;\n        ret=expression(begin);\n        begin++;\n    }\n    else{\n        ret=number(begin);\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n\n    for(;;){\n        if(*begin=='*'){\n            begin++;\n            ret*=factor(begin);\n        }\n        else if(*begin=='/'){\n            begin++;\n            ret/=factor(begin);\n        }\n        else{\n            break;\n        }\n    }\n    return ret;\n}\n\n\n\nint expression(State &begin){\n    int ret=term(begin);\n\n    for(;;){\n        if(*begin=='+'){\n            begin++;\n            ret+=term(begin);\n        }\n        else if(*begin=='-'){\n            begin++;\n            ret-=term(begin);\n        }\n        else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){\n\n    int n;\n    cin>>n;\n    cin.ignore();\n    for(int i=0;i<n;i++){\n        string s;\n        getline(cin,s);\n        State begin=s.begin();\n        cout<<expression(begin)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(string& s,State &i);\nDef term(string& s,State &i);\nDef factor(string& s,State &i);\nDef number(string& s,State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\tcerr<<\"!\"<<endl;\n\t}\n}\nDef expr(string& s,State &i){\n\tDef out=term(s,i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(s,i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(string& s,State &i){\n\tDef out=factor(s,i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(s,i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(string& s,State &i){\n\tif(isdigit(*i))return number(s,i);\n\t//'('\n\ti++;\n\tDef out=expr(s,i);\n\ti++;\n\treturn out;\n}\nDef number(string& s,State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s,s.begin())<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string &in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1 && !is_all_digit(in[0])) {\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\tcerr<<n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\t//input.erase(input.end() - 1);\n\t\t//cout << cal(input) << endl;\n\t\tcerr << input << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint expression(State&);\nint term(State&);\nint number(State&);\nint factor(State&);\n\nint expression(State &begin){\n\tint ret = term(begin);\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\t++begin;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if(*begin == '-'){\n\t\t\t++begin;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\t++begin;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if(*begin == '/'){\n\t\t\t++begin;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tint ret;\n\tif(*begin == '('){\n\t\t++begin;\n\t\tret = expression(begin);\n\t\t++begin;\n\t}\n\telse{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\t++begin;\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tstring q;\n\tcin >> n;\n\tcin.ignore();\n\tfor(int i(0);i < n;++i){\n\t\tgetline(cin, q);\n\t\tState begin = q.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\n\nstring lltostr(ll n) {\n  // cout << \"lltostr \" << n << endl;\n  stringstream ss;\n  ss << n;\n  return ss.str();\n}\n\nll calc(string str) {\n  // ©Á±ª êÎêÔOÌ©Á±ðÍ¸·\n  int p = 0, s = 0;\n  // cout << \"before \" << str << endl;\n  REP(i,str.length()) {\n    if (str[i] == '(') {\n      p++;\n      if (p==1)\n        s = i;\n    }\n    if (str[i] == ')') {\n      if (p==1) {\n        string tmp = lltostr(calc(str.substr(s+1,i-s-1)));\n        str = str.substr(0,s) + tmp + str.substr(i+1);\n        i = s + tmp.length()-1;\n      }\n      p--;\n    }\n  }\n  p = -1;\n   // cout << \"remove () \" << str << endl;\n  REP(i,str.length()) {\n    char c = str[i];\n    if (c=='*' || c=='/') {\n      string a = str.substr(p+1,i-p-1);\n      int q = i;\n      string b;\n      for(i++;i<str.length();i++) {\n        if (i!=q+1 && !isdigit(str[i])) {\n          b = str.substr(q+1,i-q-1);\n          break;\n        }\n      }\n      if (i == str.length())\n        b = str.substr(q+1);\n      string tmp;\n      if (c=='*')\n        tmp = lltostr(atoll(a.c_str()) * atoll(b.c_str()));\n      else if (c=='/')\n        tmp = lltostr(atoll(a.c_str()) / atoll(b.c_str()));\n      str = str.substr(0,p+1) + tmp + str.substr(i);\n      i = p + tmp.length();\n    }\n    if (!isdigit(str[i])) {\n      p = i;\n    }\n  }\n  // cout << \"cal *|/ \" << str << endl;\n  p = -1;\n  REP(i,str.length()) {\n    char c = str[i];\n    if (c=='+' || c=='-') {\n      string a = str.substr(p+1,i-p-1);\n      int q = i;\n      string b;\n      for(i++;i<str.length();i++) {\n        if (i!=q+1 && !isdigit(str[i])) {\n          b = str.substr(q+1,i-q-1);\n          break;\n        }\n      }\n      if (i == str.length())\n        b = str.substr(q+1);\n      string tmp;\n      if (c=='+')\n        tmp = lltostr(atoll(a.c_str()) + atoll(b.c_str()));\n      else if (c=='-')\n        tmp = lltostr(atoll(a.c_str()) - atoll(b.c_str()));\n      str = str.substr(0,p+1) + tmp + str.substr(i);\n      i = p + tmp.length();\n    }\n    if (!isdigit(str[i])) {\n      p = i;\n    }\n  }\n  // cout << \"cal +|- \" << str << endl;\n  return atoll(str.c_str());\n}\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while(n--) {\n    string s;\n    getline(cin,s);\n    s = s.substr(0,s.length()-1);\n    cout << calc(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (int i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nint Calculate_RPN(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = int(St.top()); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    return int(St.top());\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        cout << Calculate_RPN(t, B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\n\nll stol(string str){\n  stringstream ss(str);\n  ll n;\n  ss >> n;\n  return n;\n}\n\nll parse(int l, int r){\n  int num = 0, i;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')n++;\n    if(s[i] == '(')n--;\n    if(!n){\n      if(s[i] == '+')return parse(l,i) + parse(i+1,r);\n      if(s[i] == '-')return parse(l,i) - parse(i+1,r);\n    }\n  }\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')n++;\n    if(s[i] == '(')n--;\n    if(!n){\n      if(s[i] == '*')return parse(l,i) * parse(i+1,r);\n      if(s[i] == '/')return parse(l,i) / parse(i+1,r);\n    }\n  }\n\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  return stol( s.substr(l,r-l) );\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s,int& i) {\n\tint a = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint b = term(s, i);\n\t\tif (op == '+') {\n\t\t\ta = a+b;\n\t\t}\n\t\telse {\n\t\t\ta = a - b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint term(string& s, int& i) {\n\tint a = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint b = factor(s, i);\n\t\tif (op == '*') {\n\t\t\ta = a*b;\n\t\t}\n\t\telse {\n\t\t\ta = a / b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint factor(string& s, int& i) {\n\tif (isdigit(s[i])) {\n\t\tint a = number(s, i);\n\t\treturn a;\n\t}\n\telse {\n\t\ti++;//(\n\t\tint a = expr(s, i);\n\t\ti++;//)\n\t\treturn a;\n\t}\n}\n\nint number(string& s, int& i) {\n\tint a = s[i]-'0';\n\ti++;\n\twhile (isdigit(s[i])) {\n\t\ta = a * 10 + (s[i] - '0');\n\t\ti++;\n\t}\n\treturn a;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tREP(j, n) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tint k = 0;\n\t\tcout << expr(ss, k) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cctype> // isdigit\n#include<cassert> // assert\n#include<cstdlib> // atoi\n\nusing namespace std;\n\nqueue<string>exp;\n\nint calculate();\nint add();\nint multiply();\nint term();\n\nint calculate()\n{\n  return add();\n}\n\nint add()\n{\n  int num=multiply();\n  if(exp.empty())return num;\n  string s=exp.front();\n  if(s[0]=='+'||s[0]=='-'){\n    exp.pop();\n    int num2=calculate();\n    if(s[0]=='+')return num+num2;\n    if(s[0]=='-')return num-num2;\n  }\n  return num;\n}\n\nint multiply()\n{\n  int num=term();\n  if(exp.empty())return num;\n  string s=exp.front();\n  if(s[0]=='*'||s[0]=='/'){\n    exp.pop();\n    int num2=calculate();\n    if(s[0]=='*')return num*num2;\n    if(s[0]=='/')return num/num2;\n  }\n  return num;\n}\n\nint term()\n{\n  string s=exp.front();\n  // l\n  if(isdigit(s[0])){\n    exp.pop();\n    return atoi(s.c_str());\n  }\n  // PZqÌ}CiX\n  if(s[0]=='-'){\n    exp.pop();\n    return -calculate();\n  }\n  // Ê\n  if(s[0]=='('){\n    exp.pop();\n    int num=calculate();\n    assert(exp.front()==\")\");\n    exp.pop();\n    return num;\n  }\n}\n\nint main()\n{\n  int n;\n  string s;\n  cin>>n;\n  while(n-->0){\n    cin>>s;\n    while(exp.size())exp.pop();\n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=')break;\n      if(isdigit(s[i])){\n\tint j;\n\tfor(j=i+1;j<s.size();j++)if(!isdigit(s[j]))break;\n\texp.push(s.substr(i,j-i));\n\ti=j-1;\n      }else{\n\texp.push(s.substr(i,1));\n      }\n    }\n    /*\n    while(exp.size()){\n      cout<<exp.front()<<endl;\n      exp.pop();\n    }\n    */\n    cout<<calculate()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\n\nconst char symbollist[] = \"+-*/()$;\" ;//??????????????????\nchar SymbolJudge(char c, const char* str)//?????????????????¢??°\n{\n  for(size_t i = 0; str[i] != '\\0'; ++i )\n  {\n    if( c == str[i])\n    {\n      return str[i] ;\n    }\n  }\n  return 0 ;\n}\n\nint Judge(char *str)//()????????????????????????????????¢??°\n{\n  int pa_n = 0;\n  for(size_t i = 0; str[i] != '\\0'; ++i )\n  {\n    if(str[i] == '('){\n      ++pa_n ;\n    }\n  }\n  return pa_n ;\n}\n\nint Str(const char* str,const char* tar,const char* bul){//?????????????????¢??°\n  char *temp ;\n  size_t slen = strlen(str) ;\n  size_t tlen = strlen(tar) ;\n  size_t blen = strlen(bul) ;\n  if((temp = strstr(str,tar)) == NULL){\n    return 0 ;\n  }\n  memmove(temp + blen,temp + tlen,slen - (temp + tlen - str) + 1 ) ;\n  memcpy(temp, bul , blen) ;\n  return 1 ;\n}\nconst int N = 200;\ndouble EasyCalc(char *string){//()??????????¨????????????¢??°\n  char formula[100] = {}, operators[N], temp[N], c ;\n  size_t i, j = 0, nu_n = 0, op_n = 0 ;\n  int tmp = 0  ;\n  double num[N] ;\n  strcpy(formula,string ) ;\n  while(Str(formula,\" \",\"\")) ;\n  strcat(formula,\";\") ;\n  for(i = 0,j = 0; formula[i] != '\\0'; ++ i){\n    if(SymbolJudge(formula[i], symbollist) == '-'){\n      if(i == 0 || SymbolJudge(formula[i-1], symbollist) != 0){\n        temp[j] = formula[i] ;\n        ++j ;\n        operators[op_n] = '+';\n      }\n      else{\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else if((c =SymbolJudge(formula[i], symbollist)) != 0){\n      if(c != '('){\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else{\n      temp[j] = formula[i] ;\n      ++j ;\n    }\n  }\n  tmp = 0 ;\n  while(1){\n    if((c=SymbolJudge(operators[tmp], symbollist) ) == ';'){\n      break ;\n    }\n    switch(c){\n      case '*':\n        num[tmp] *= num[tmp + 1];\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '/':\n        num[tmp] /= num[tmp + 1];\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        ++tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == 0){\n        num[j] = num[j + 1] ;\n        num[j + 1] = 0 ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  tmp = 0 ;\n  while(1){\n    if((c=SymbolJudge(operators[0],symbollist)) == ';'){\n      break ;\n    }\n    switch(c){\n      case '+':\n        num[tmp] += num[tmp + 1] ;\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '-':\n        num[tmp] -= num[tmp + 1] ;\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        ++ tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == 0){\n        num[j] = num[j + 1] ;\n        num[j + 1] = 0 ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  return num[0] ;\n}\ndouble Calculation(string str)//???????????£??????????¨??????????\n{\n  char* string = const_cast<char*>(str.c_str());\n  bool flag = false ;\n  char formula[N], formula1[N] = {}, operators[N], temp[N], c, buf[N] ;\n  int flag_p = 0, pa_n = 0 ;\n  size_t i, j = 0, nu_n = 0, op_n = 0, tmp = 0 ;\n  double num[N] , ans;\n  strcpy(formula,string ) ;\n  while(1){//()??????????¨????????????¨???\n    flag_p = Judge(formula) ;//()??????????????????????????????\n    if(flag_p == 0 ){\n      break ;\n    }\n    for(i = 0,j = 0,pa_n =0; formula[i] != '\\0' ; ++ i){\n      c = SymbolJudge(formula[i],symbollist) ;\n      if(c == '('){\n        ++pa_n ;\n        if(flag_p == pa_n){\n          formula[i] = '$' ;\n          flag = true ;\n        }\n        j = 0;\n        memset(formula1,'\\0',N) ;\n      }\n      if(flag_p == pa_n){\n        if(c == ')'){\n          formula[i] = ' ' ;\n          while(Str(formula1,\" \",\"\")) ;\n          while(Str(formula1,\"\\n\",\"\")) ;\n          ans = EasyCalc(formula1) ;\n          break ;\n        }\n        else{\n          if(flag){\n            flag = !flag ;\n          }\n          else{\n            formula1[j] = formula[i] ;\n            formula[i] = ' ' ;\n            ++ j ;\n          }\n        }\n      }\n    }\n    while(Str(formula,\" \",\"\")) ;\n    for(i = 0,j = 0; formula[i] != '\\0' ; ++ i){\n      c = SymbolJudge(formula[i],symbollist) ;\n      if(c == '$'){\n        sprintf(buf,\"%lf\",ans) ;\n        Str(formula,\"$\", buf) ;\n        break ;\n      }\n    }\n  }\n\n  strcat(formula,\";\") ;//????°?????????????????????§???????????¨???????????????????????????????¨?\n\n  Str(formula,\")\",\"\") ;\n  for(i = 0,j = 0; formula[i] != '\\0'; ++ i){\n    if(SymbolJudge(formula[i], symbollist) == '-'){\n      if(formula[i+1] != '\\0' && SymbolJudge(formula[i+1], symbollist) == '-'){\n        num[nu_n] = -1 ;\n        ++nu_n ;\n        operators[op_n] = '*' ;\n        ++op_n ;\n      }\n      else if(i == 0 || SymbolJudge(formula[i-1], symbollist) != 0){//????????°??????????????????\n        temp[j] = formula[i] ;\n        ++j ;\n        operators[op_n] = '+';\n      }\n      else{//???????????°?????¨???????????????????????????\n        operators[op_n] = formula[i] ;//????????????????´?\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else if((c =SymbolJudge(formula[i], symbollist)) != 0){//????????????????????°??§???????????§??????\n      if(c != '('){\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else{//???????????§??????????????°??§??????\n      temp[j] = formula[i] ;\n      ++j ;\n    }\n  }\n  while(1){//*/??????????????????\n//         printf(\"%lf\\n\",num[nu_n-1]) ;\n    if((c=SymbolJudge(operators[tmp], symbollist) ) == ';'){//???????????????????????????\n      break ;\n    }\n    switch(c){//????´?????????????????????????????????£?????????????????????\n      case '*':\n        num[tmp] *= num[tmp + 1];\n        num[tmp + 1] = INFINITY ;//????????¨?????\\?????????????????¨??????\n        operators[tmp] = '\\0' ;//????????¨?????\\???\n        break ;\n      case '/':\n        num[tmp] /= num[tmp + 1];\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default://+-???????????§????¨?????????????\n        ++tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){//????????¨?????\\????????????????????????????????°????????????\n      if(num[j] == INFINITY){\n        num[j] = num[j + 1] ;\n        num[j + 1] = INFINITY ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){//????§????\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  tmp = 0 ;\n  while(1){//+-?????????\n    if((c=SymbolJudge(operators[0],symbollist)) == ';'){\n      break ;\n    }\n    switch(c){//*/??¨?????????????????§??????\n      case '+':\n        num[tmp] += num[tmp + 1] ;\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '-':\n        num[tmp] -= num[tmp + 1] ;\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == INFINITY){\n        num[j] = num[j + 1] ;\n        num[j + 1] = INFINITY ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  return num[0] ;//??°????????????????????????????????????????´??????????\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  string str;\n  int n;\n  cin >> n;\n  getline(cin,str);\n  rep(i,n){\n    getline(cin,str);\n    cout << Calculation(str) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int n, junjo[4] = { 0, 0, 1, 1 };\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return stoi(S.substr(L,R-L));\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) cin >> S, printf(\"%d\\n\", calc(0, S.size() - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<int,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second!='=' && *now.second!=')'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second!='=' && *now.second!=')' && *now.second!='+' && *now.second!='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\tif(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse{\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\twhile(isdigit(*p))\n\t\t\tp++;\n\t\treturn parsed(atoi(s),p);\n\t}\n}\n\nint main()\n{\n\t//parsed p=expr(\"((3+4)/(1+2))=\");\n\t//cout<<p.first<<\",\"<<p.second<<endl;\n\tchar s[101];\n\tgets(s);\n\twhile(gets(s))\n\t\tcout<<expr(s).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n  //   #define int long long\n            #define mod  1000000009\n            #define pa pair<int,int>\n            #define ll long long\n            #define pal pair<double,int>\n            #define ppa pair<int,pa>\n            #define ssa pair<string,int>\n            #define  mp make_pair\n            #define  pb push_back\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     //priority_queue<int, vector<int>, greater<int> > que;\n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \nstring itos( int i ) {\nostringstream s ;\ns << i ;\nreturn s.str() ;\n}\n\nint gcd(int v,int b){\n\tif(v>b) return gcd(b,v);\n\tif(v==b) return b;\n\tif(b%v==0) return v;\n\treturn gcd(v,b%v);\n}\n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \ndouble distans(double x1,double y1,double x2,double y2){\n\tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n\treturn sqrt(rr);\n\t\n}\n            //----------------kokomade tenpure------------\nstring s;\nint kakko(string &t ,int &b);\n\nint suuji(string &t, int &b){\n\tint r=0;\n\tif(isdigit(t[b])){\n\twhile(isdigit(t[b])){\n\t\tr *=10;\n\t\tr += t[b]-'0';\n\t\t(b)++;\n\t}\n\t}\n\telse if(t[b]=='('){\n\t\n\t\tr=kakko(t,b);\n\t\t\n\t}\n\t\n\treturn r;\n}\n\n\nint kake(string &t, int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=suuji(t,b);\n\t//cout<<i<<endl;\n\t\twhile((t[b]=='*')||(t[b]=='/')){\n\t\t\tb++;\n\t\t\tif(t[b-1]=='*')i *= suuji(t,b);\n\t\t\telse i /= suuji(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint tashi(string &t ,int &b){\n\tif(isdigit(t[b])||t[b]=='('){\n\t\tint i=kake(t,b);\n\t\twhile((t[b]=='+')||(t[b]=='-')){\n\t\tb++;\n\t\t\tif(t[b-1]=='+')\ti += kake(t,b);\n\t\t\telse i -= kake(t,b);\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint kakko(string &t ,int &b){\n\t\n\tif(t[b]=='('){\n\t\tint y;\n\t\tb++;\n\t\ty=kakko(t,b);\n\t\tb++;\n\t\treturn y;\n\t}\n\telse{\n\t\treturn tashi(t,b);\n\t}\n}\n    signed  main(){\n    \tint n;\n    \tcin>>n;\n    \tfor(int g=0;g<n;g++){\ncin>>s;\n    \tint i=0;\n    \tcout<<tashi(s,i)<<endl;\n    \t}\n    \n  //  \tprintf(\"%.10f\\n\",ans[n-1]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nstring in; int n;\n\nint eval(int s,int t){\n  int i,d=0;\n  for(i=t-1;i>=s;i--){\n    if(in[i]==')')d++;\n    else if(in[i]=='(')d--;\n    if(d==0&&(in[i]=='+'||in[i]=='-'))break;\n  }\n  if(i>=s){\n    int a=eval(s,i),b=eval(i+1,t);\n    return in[i]=='+'?a+b:a-b;\n  }\n  d=0;\n  for(i=t-1;i>=s;i--){\n    if(in[i]==')')d++;\n    else if(in[i]=='(')d--;\n    if(d==0&&(in[i]=='*'||in[i]=='/'))break;\n  }\n  if(i>=s){\n    int a=eval(s,i),b=eval(i+1,t);\n    return in[i]=='*'?a*b:a/b;\n  }\n  if(in[s]=='('&&in[t-1]==')')return eval(s+1,t-1);\n  return atoi(in.substr(s,t-s).c_str());\n}\nint main()\n{\n  int cs; cin>>cs; cin.ignore();\n  rep(i,cs){\n    getline(cin,in);\n    n=in.size();\n    cout<<eval(0,n-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &);\nint term(State &);\nint number(State &);\nint factor(State &);\n\nint main(void) {\n    int N;\n    cin >> N;\n    cin.ignore();\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while (1) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = factor(begin);\n\n    while (1) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint lp=0;\nint solve(string str){\n    vector<int>op;\n    vector<char>ope;\n    //cout<<str.length()<<endl;\n    for(int i=0;i<str.length();i++){\n        //cout<<\"KK\";\n        if(str[i]=='('){\n            string t;\n            i++;\n            lp++;\n            while(lp){\n                t+=str[i];\n                i++;\n                if(str[i]=='(')lp++;\n                if(str[i]==')')lp--;\n            }\n            i++;\n            op.push_back(solve(t));\n            //cout<<\"(): \"<<ope[ope.size()-1]<<endl;\n            if(ope.size())\n            if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                int a=op[op.size()-1];\n                op.pop_back();\n                int b=op[op.size()-1];\n                op.pop_back();\n                if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                else op.push_back(b/a);\n                ope.pop_back();\n            }\n            ope.push_back(str[i]);\n        }\n        else if(str[i]>='0'&&str[i]<='9'){\n            int g=0;\n            while(str[i]>='0'&&str[i]<='9'){\n                g=g*10+str[i]-'0';\n                i++;\n            }\n            op.push_back(g);\n            if(ope.size())\n                if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                    int a=op[op.size()-1];\n                    op.pop_back();\n                    int b=op[op.size()-1];\n                    op.pop_back();\n                    if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                    else op.push_back(b/a);\n                    ope.pop_back();\n                }\n            if(str[i])ope.push_back(str[i]);\n        }\n    }\n    //cout<<\"!\"<<endl;\n    int las=op[op.size()-1];\n    op.pop_back();\n    while(ope.size()){\n        //cout<<\"las: \"<<las<<endl;\n        char c=ope[ope.size()-1];\n        ope.pop_back();\n        if(c=='=')continue;\n        int pre=op[op.size()-1];\n        //cout<<\"pre: \"<<pre<<endl;\n        //cout<<ope.size()<<\"   c: \"<<c<<endl;\n        op.pop_back();\n        if(c=='+')las=las+pre;\n        else las=pre-las;\n    }\n    //cout<<\"returned : \"<<las<<endl;\n    return las;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        string str;\n        cin>>str;\n        cout<<solve(str)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n//END CUT HERE\n\nsigned main(){\n  int n;\n  cin>>n;\n  while(n--){\n    string s;\n    int p=0;\n    cin>>s;s.pop_back();\n    cout<<expression(s,p)<<endl;\n  }\n  return 0;\n}\n\n/*\nverified on 2017/11/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id=0109\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nstring s;\nint a;\nint func();\nint num();\nint func2();\nint num(){\n\tint out=0;\n\twhile(isdigit(s[a])){out*=10;out+=s[a]-'0';a++;}\n\treturn out;\n}\nint func2(){\n\tint out;\n\tif(isdigit(s[a]))out=num();\n\telse {a++;out=func();}\n\twhile(a!=s.size()){\n\t\tif(s[a]=='*'){\n\t\t\ta++;\n\t\t\tif(s[a]=='('){a++;out*=func();}\n\t\t\telse out*=num();\n\t\t}else if(s[a]=='/'){\n\t\t\ta++;\n\t\t\tif(s[a]=='('){a++;out/=func();}\n\t\t\telse out/=num();\n\t\t}else return out;\n\t}\n\treturn out;\n}\nint func(){\n\tint out;\n\tif(isdigit(s[a]))out=num();\n\telse {a++;out=func();}\n\twhile(a!=s.size()){\n\t\t//cout<<a<<\" \"<<out<<endl;\n\t\tif(s[a]=='=')return out;\n\t\tif(s[a]==')'){a++;return out;}\n\t\tif(s[a]=='+'){a++;out+=func2();}\n\t\telse if(s[a]=='-'){a++;out-=func2();}\n\t}\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\ta=0;\n\t\tcin>>s;\n\t\ts=\"0+\"+s;\n\t\tcout<<func()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\tif(tmp_right == 0){\n\t\t\t\t\ttmp_right = 1;\n\t\t\t\t\tSystem.out.println(\"BUG!\\n\");\n\t\t\t\t}\n\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -calc_F(left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum{\n\tINT,\n\tPLUS,\n\tMINUS,\n\tMUL,\n\tDIV,\n\tEQ,\n\tLPAREN,\n\tRPAREN,\n\tNL\n} token_kind_t;\n\ntypedef struct token{\n\tint c;\n\ttoken_kind_t kind;\n\tint ival;\n} *token_t;\n\nint calc_expr_add(token_t t);\n\ntoken_t next_tok(token_t t)\n{\n\twhile (t->c == ' ' || t->c == '\\n') {\n\t\tt->c = getchar();\n\t}\n\tif (isdigit(t->c)){\n\t\tt->ival = 0;\n\t\tt->kind = INT;\n\t\twhile (isdigit(t->c)){\n\t\t\tt->ival *= 10;\n\t\t\tt->ival += t->c - '0';\n\t\t\tt->c = getchar();\n\t\t}\n\t}\n\telse{\n\t\tif (t->c == '+') t->kind = PLUS;\n\t\telse if (t->c == '-') t->kind = MINUS;\n\t\telse if (t->c == '*') t->kind = MUL;\n\t\telse if (t->c == '/') t->kind = DIV;\n\t\telse if (t->c == '(') t->kind = LPAREN;\n\t\telse if (t->c == ')') t->kind = RPAREN;\n\t\telse if (t->c == '=') t->kind = EQ;\n\t\telse if (t->c == '\\n') t->kind = NL;\n\t\telse exit(1);\n\n\t\tt->c = getchar();\n\t}\n\n\treturn t;\n}\n\ntoken_t mk_tok()\n{\n\ttoken_t t;\n\tif ((t = (token_t)malloc(sizeof(struct token))) == NULL){\n\t\tperror(\"malloc\");\n\t\texit(1);\n\t}\n\n\tt->c = getchar();\n\n\treturn t;\n}\n\nint calc_expr_un(token_t t)\n{\n\tint ret = 0;\n\tif (t->kind == INT){\n\t\tret = t->ival;\n\t\tnext_tok(t);\n\t}\n\telse if (t->kind == LPAREN){\n\t\tnext_tok(t);\n\t\tret = calc_expr_add(t);\n\t\tif (t->kind != RPAREN) exit(1);\n\t\tnext_tok(t);\n\t}\n\telse if (t->kind == PLUS || t->kind == MINUS){\n\t\tif (t->kind == PLUS){\n\t\t\tnext_tok(t);\n\t\t\tret += calc_expr_un(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret -= calc_expr_un(t);\n\t\t}\n\t}\n\telse exit(1);\n\treturn ret;\n}\n\nint calc_expr_mul(token_t t)\n{\n\tint ret = 0;\n\tret = calc_expr_un(t);\n\twhile (t->kind == MUL || t->kind == DIV){\n\t\tif (t->kind == MUL){\n\t\t\tnext_tok(t);\n\t\t\tret *= calc_expr_un(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret /= calc_expr_un(t);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_expr_add(token_t t)\n{\n\tint ret = 0;\n\tret = calc_expr_mul(t);\n\twhile (t->kind == PLUS || t->kind == MINUS){\n\t\tif (t->kind == PLUS){\n\t\t\tnext_tok(t);\n\t\t\tret += calc_expr_mul(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret -= calc_expr_mul(t);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_expr(token_t t)\n{\n\tint ret = 0;\n\n\tnext_tok(t);\n\tret = calc_expr_add(t);\n\tif (t->kind != EQ) exit(1);\n\n\treturn ret;\n}\n\nint main()\n{\n\tint i, n;\n\n\tn = 0;\n\twhile (isdigit(i = getchar())){\n\t\tn *= 10;\n\t\tn += i - '0';\n\t}\n\n\ttoken_t t = mk_tok();\n\n\tfor (i = 0; i < n; i++){\n\t\tint result = calc_expr(t);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nclass Parser{\npublic:\n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            if(*begin == '+'){\n                begin++;\n                ret += term(begin);\n            }else if(*begin == '-'){\n                begin++;\n                ret -= term(begin);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            if(*begin == '*'){\n                begin++;\n                ret *= factor(begin);\n            }else if(*begin == '/'){\n                begin++;\n                ret /= factor(begin);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        int ret;\n        if(*begin == '('){\n            begin++;//'('?????????\n            ret = expression(begin);\n            begin++;//')'?????????\n        }else{\n            ret = number(begin);\n        }\n        return ret;\n    }\n    int number(State &begin){\n        int ret = 0;\n        while(isdigit(*begin)){\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return ret;\n    }\n};\n\nint main(void){\n    int n; cin >> n;\n    rep(i, n){\n        Parser ps;\n        string s; cin >> s;\n        string tmp = s.substr(0, s.size() - 1);\n   //     cout << tmp << endl;\n        State begin = s.begin();\n        int ret = ps.expression(begin);\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <stdio.h>\n\ntypedef enum{\n\tINT,\n\tPLUS,\n\tMINUS,\n\tMUL,\n\tDIV,\n\tEQ,\n\tLPAREN,\n\tRPAREN,\n\tNL\n} token_kind_t;\n\ntypedef struct token{\n\tint c;\n\ttoken_kind_t kind;\n\tint ival;\n} *token_t;\n\nint calc_expr_add(token_t t);\n\ntoken_t next_tok(token_t t)\n{\n\twhile (t->c == ' ' || t->c == '\\n') {\n\t\tt->c = getchar();\n\t}\n\tif (isdigit(t->c)){\n\t\tt->ival = 0;\n\t\tt->kind = INT;\n\t\twhile (isdigit(t->c)){\n\t\t\tt->ival *= 10;\n\t\t\tt->ival += t->c - '0';\n\t\t\tt->c = getchar();\n\t\t}\n\t}\n\telse{\n\t\tif (t->c == '+') t->kind = PLUS;\n\t\telse if (t->c == '-') t->kind = MINUS;\n\t\telse if (t->c == '*') t->kind = MUL;\n\t\telse if (t->c == '/') t->kind = DIV;\n\t\telse if (t->c == '(') t->kind = LPAREN;\n\t\telse if (t->c == ')') t->kind = RPAREN;\n\t\telse if (t->c == '=') t->kind = EQ;\n\t\telse if (t->c == '\\n') t->kind = NL;\n\t\telse exit(1);\n\n\t\tt->c = getchar();\n\t}\n\n\treturn t;\n}\n\ntoken_t mk_tok()\n{\n\ttoken_t t;\n\tif ((t = (token_t)malloc(sizeof(struct token))) == NULL){\n\t\tperror(\"malloc\");\n\t\texit(1);\n\t}\n\n\tt->c = getchar();\n\n\treturn t;\n}\n\nint calc_expr_un(token_t t)\n{\n\tint ret = 0;\n\tif (t->kind == INT){\n\t\tret = t->ival;\n\t\tnext_tok(t);\n\t}\n\telse if (t->kind == LPAREN){\n\t\tnext_tok(t);\n\t\tret = calc_expr_add(t);\n\t\tif (t->kind != RPAREN) exit(1);\n\t\tnext_tok(t);\n\t}\n\telse if (t->kind == PLUS || t->kind == MINUS){\n\t\tif (t->kind == PLUS){\n\t\t\tnext_tok(t);\n\t\t\tret += calc_expr_un(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret -= calc_expr_un(t);\n\t\t}\n\t}\n\telse exit(1);\n\treturn ret;\n}\n\nint calc_expr_mul(token_t t)\n{\n\tint ret = 0;\n\tret = calc_expr_un(t);\n\twhile (t->kind == MUL || t->kind == DIV){\n\t\tif (t->kind == MUL){\n\t\t\tnext_tok(t);\n\t\t\tret *= calc_expr_un(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret /= calc_expr_un(t);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_expr_add(token_t t)\n{\n\tint ret = 0;\n\tret = calc_expr_mul(t);\n\twhile (t->kind == PLUS || t->kind == MINUS){\n\t\tif (t->kind == PLUS){\n\t\t\tnext_tok(t);\n\t\t\tret += calc_expr_mul(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret -= calc_expr_mul(t);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_expr(token_t t)\n{\n\tint ret = 0;\n\n\tnext_tok(t);\n\tret = calc_expr_add(t);\n\tif (t->kind != EQ) exit(1);\n\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\n\tn = getchar() - '0';\n\tgetchar();\n\n\ttoken_t t = mk_tok();\n\n\tint i;\n\tfor (i = 0; i < n; i++){\n\t\tint result = calc_expr(t);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype> // isdigit\n#include<cassert> // assert\nusing namespace std;\n\nstruct Result{int value,pos;};\n\nint calculate(string expression);\nResult equation(string expression,int pos);\nResult factor(string expression,int pos);\nResult term(string expression,int pos);\n\nint calculate(string expression)\n{\n  return equation(expression,0).value;\n}\n\nResult equation(string expression,int pos)\n{\n  Result r=factor(expression,pos);\n  // Á¸Z\n  while(expression[r.pos]=='+' || expression[r.pos]=='-'){\n    Result _r=factor(expression,r.pos+1);\n    if(expression[r.pos]=='+')r.value += _r.value;\n    if(expression[r.pos]=='-')r.value -= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult factor(string expression,int pos)\n{\n  Result r=term(expression,pos);\n  // æZ\n  while(expression[r.pos]=='*' || expression[r.pos]=='/'){\n    Result _r=term(expression,r.pos+1);\n    if(expression[r.pos]=='*')r.value *= _r.value;\n    if(expression[r.pos]=='/')r.value /= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult term(string expression,int pos)\n{\n  Result r;\n  // l\n  if(isdigit(expression[pos])){\n    int value=0;\n    while(isdigit(expression[pos]))value = value*10 + expression[pos++]-'0';\n    r.value=value;\n    r.pos=pos;\n    return r;\n  }\n  // Ê\n  if(expression[pos]=='('){\n    r=equation(expression,pos+1);\n    assert(expression[r.pos++]==')');\n    return r;\n  }\n}\n\nint main()\n{\n  int n;\n  string s;\n  cin>>n;\n  while(n-->0){\n    cin>>s;\n    s=s.substr(0,s.size()-1);\n    cout<<calculate(s)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint p1( string const& expr, int& pos );\nint p2( string const& expr, int& pos );\nint p3( string const& expr, int& pos );\n\nint p1( string const& expr, int& pos )\n{\n    int result = p2(expr, pos);\n    if ( result == -1 )\n        return -1;\n\n    while( expr[pos] == '+' || expr[pos] == '-' ) {\n        int const cp = pos;\n        ++pos;\n        int const a = p2( expr, pos );\n        if ( expr[cp] == '+' )\n            result += a;\n        else\n            result -= a;\n    }\n\n    return result;\n}\n\nint p2( string const& expr, int& pos )\n{\n    int result = p3(expr, pos);\n    if ( result == -1 )\n        return -1;\n\n    while( expr[pos] == '*' || expr[pos] == '/' ) {\n        int const cp = pos;\n        ++pos;\n        int const a = p3( expr, pos );\n        if ( expr[cp] == '*' )\n            result *= a;\n        else\n            result /= a;\n    }\n\n    return result;\n}\n\nint p3( string const& expr, int& pos )\n{\n    if ( expr[pos] >= '0' && expr[pos] <= '9' ) {\n        string s;\n        do {\n            s += expr[pos];\n            ++pos;\n        } while( pos < expr.size() && expr[pos] >= '0' && expr[pos] <= '9' );\n        \n        return atoi( s.c_str() );\n\n    } else if ( expr[pos] == '(' ){\n        ++pos;\n        int const res = p1( expr, pos );\n        ++pos; // ')'\n        return res;\n    }\n\n    return -1;\n}\n\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    cin.ignore();\n    for( int iii=0; iii<n; ++iii ) {\n        string s;\n        getline( cin, s );\n//        cout << s << endl;\n        int pos = 0;\n        cout << p1( s, pos ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\ntypedef long long ll;\n\nint it, n;\nstring input;\n\nll expr();\nll term();\nll fact();\n\nll expr() {\n    int v = term();\n    while (input[it] == '+' || input[it] == '-') {\n        if (input[it++] == '+') {\n            v += term();\n        } else {\n            v -= term();\n        }\n    }\n    return v;\n}\n\nll term() {\n    int v = fact();\n    while (input[it] == '*' || input[it] == '/') {\n        if (input[it++] == '*') {\n            v *= term();\n        } else {\n            v /= term();\n        }\n    }\n    return v;\n}\n\nll fact() {\n    int v = 0;\n    if (input[it] == '(') {\n        ++it; // '('\n        v = expr();\n        ++it; // ')'\n    } else {\n        while ('0' <= input[it] && input[it] <= '9') {\n            v = 10*v + input[it]-'0';\n            ++it;\n        }\n    }\n    return v;\n}\n\nint main() {\n    cin >> n;\n    rep (i,n) {\n        cin >> input;\n        it = 0;\n        cout << expr() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nint parse_int(std::string const& s, size_t& i) {\n  int res = s[i]-'0';\n  while (isdigit(s[++i]))\n    res = res*10 + s[i]-'0';\n  return res;\n}\n\nint apply(int lhs, char op, int rhs) {\n  if (op == '+') return lhs + rhs;\n  if (op == '-') return lhs - rhs;\n  if (op == '*') return lhs * rhs;\n  if (op == '/') return lhs / rhs;\n  assert(false);\n}\n\nconst std::vector<std::string> ops = {\"+-\", \"*/\"};\nint parse(std::string const& s, size_t& i, size_t preced = 0) {\n  if (ops.size() == preced) {\n    if (isdigit(s[i])) return parse_int(s, i);\n    if (s[i] == '(') {\n      int res = parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    assert(false);\n  }\n  int res = parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op = s[i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    res = apply(res, op, parse(s, ++i, preced+1));\n  }\n  return res;\n}\n\nint main() {\n  size_t n;\n  scanf(\"%zu\", &n);\n\n  for (size_t i = 0; i < n; ++i) {\n    char buf[1024];\n    scanf(\"%s\", buf);\n    std::string s = buf;\n    if (s.back() != '=') {\n      printf(\"%s\\n\", s.c_str());\n      continue;\n    }\n\n    size_t j = 0;\n    printf(\"%d\\n\", parse(s, j));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nclass Parser{\npublic:\n\tint expression(State &begin){\n\t\tint ret = term(begin);\n\t\tfor(;;){\n\t\t\tif(*begin == '+'){\n\t\t\t\tbegin++;\n\t\t\t\tret += term(begin);\n\t\t\t}else if(*begin == '-'){\n\t\t\t\tbegin++;\n\t\t\t\tret -= term(begin);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint term(State &begin){\n\t\tint ret = factor(begin);\n\t\tfor(;;){\n\t\t\tif(*begin == '*'){\n\t\t\t\tbegin++;\n\t\t\t\tret *= factor(begin);\n\t\t\t}else if(*begin == '/'){\n\t\t\t\tbegin++;\n\t\t\t\tret /= factor(begin);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint factor(State &begin){\n\t\tint ret;\n\t\tif(*begin == '('){\n\t\t\tbegin++;//'('?????????\n\t\t\tret = expression(begin);\n\t\t\tbegin++;//')'?????????\n\t\t}else{\n\t\t\tret = number(begin);\n\t\t}\n\t\treturn ret;\n\t}\n\tint number(State &begin){\n\t\tint ret = 0;\n\t\twhile(isdigit(*begin)){\n\t\t\tret *= 10;\n\t\t\tret += *begin - '0';\n\t\t\tbegin++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main(void){\n\tint n; cin >> n;\n\trep(i, n){\n\t\tParser ps;\n\t\tstring s; cin >> s;\n\t\tstring tmp = s.substr(0, s.size() - 1);\n\t\t// cout << tmp << endl;\n\t\tState begin = s.begin();\n\t\tint ret = ps.expression(begin);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\n//<expr>   :: = <term>[('+' | '-') <term>] *\n//<term>   :: = <factor>[('*' | '/') <factor>] *\n//<factor> :: = <number> | '(' <expr> ')'\n//<number> : == 1?????\\????????°???\n\n\nll number(string& s, ll& i);\nll term(string& s, ll& i);\nll factor(string& s, ll& i);\nll expr(string& s, ll& i);\n\nll number(string& s, ll& i) {\n\tll n = s[i++] - '0';\n\twhile (isdigit(s[i])) n = n * 10 + s[i++] - '0';\n\treturn n;\n}\n\nll factor(string& s, ll& i) {\n\tif (isdigit(s[i])) return number(s, i);\n\n\t// ????????§?§?????????£???????????° s[i] == '(' ??¨??????\n\ti++; // '('??????????£???°???\n\tll ret = expr(s, i);\n\ti++; // ')'??????????£???°???\n\treturn ret;\n}\n\nll term(string& s, ll& i) {\n\tll val = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = factor(s, i);\n\t\tif (op == '*') val *= val2;\n\t\telse val /= val2;\n\t}\n\treturn val;\n}\n\nll expr(string& s, ll& i) {\n\tll val = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (op == '+') val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\n\nint n;\nll pos = 0;\nstring s;\n\nint main() {\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> s;\n\t\tpos = 0;\n\t\tcout << expr(s, pos) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nbool match(char c, string s)\n{\n\trep(i, 0, s.length()) if (s[i] == c) return true;\n\treturn false;\n}\n\nstring op[2] = { \"+-\", \"*/\" };\n\nint parse(string s, int &i, int x)\n{\n\tif (x == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ans = parse(s, i, 0);\n\t\t\ti++;\n\t\t\treturn ans;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '9')\n\t\t\t{\n\t\t\t\tret = ret * 10 + s[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ans = parse(s, i, x + 1);\n\n\t\twhile (op[x].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '+': i++; ans += parse(s, i, x + 1); break;\n\t\t\tcase '-': i++; ans -= parse(s, i, x + 1); break;\n\t\t\tcase '*': i++; ans *= parse(s, i, x + 1); break;\n\t\t\tcase '/': i++; ans /= parse(s, i, x + 1); break;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\nint main()\n{\n\tint n; cin >> n;\n\trep(_n, 0, n)\n\t{\n\t\tstring s; cin >> s;\n\t\tint i = 0;\n\t\tcout << parse(s, i, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//テ・ツ??」ツ?ョテヲツ篠・テァツキツ?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//テゥツ敖「テァツゥツ??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\tテ・ツ按敕ヲツ慊淌・ツ個飽(|S|log^2|S|), テヲツ、ツ愿ァツエツ「O(|T|log|S|), テゥツォツ佚」ツ?陛ゥツ?催・ツ按療ヲツァツ凝ァツッツ碓(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nstring s;\nint pos;\nint expr();\nint section() {\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tint a = expr();\n\t\tpos++;\n\t\treturn a;\n\t}\n\tint a = 0;\n\twhile (s[pos] >= '0'&&s[pos] <= '9')a = a * 10 + s[pos++] - '0';\n\treturn a;\n}\nint factor() {\n\tint a = section(), b;\n\tfor (;;) {\n\t\tbool div = s[pos] == '/';\n\t\tif (!div&&s[pos] != '*')return a;\n\t\tpos++;\n\t\tb = section();\n\t\ta = div ? a / b : a*b;\n\t}\n}\nint expr() {\n\tint a = factor(), b;\n\tfor (;;) {\n\t\tbool neg = s[pos] == '-';\n\t\tif (!neg&&s[pos] != '+')return a;\n\t\tpos++;\n\t\tb = factor();\n\t\ta += (neg ? -b : b);\n\t}\n}\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> s;\n\t\tpos = 0;\n\t\tcout << expr() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline string sub(string str, int i) {\n    return string(str.begin() + i + 1, str.end());\n}\n\nint dfs(string);\nint get_num(string&, int&);\n\nint get_num(string& str, int& i) {\n    int num = 0;\n\n    if (str[i] == '(') {\n        string ss;\n        i++;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n\n            if (count) {\n                ss += str[i];\n            }\n        }\n\n        return dfs(ss);\n    }\n\n    for (; i < str.size(); i++) {\n        if ('0' <= str[i] && str[i] <= '9') {\n            num = num * 10 + (str[i] - '0');\n        } else {\n            return num;\n        }\n    }\n\n    return num;\n}\n\nint dfs(string str) {\n    int num = 0;\n\n    int i = 0;\n\n    if (str[i] == '-') {\n        num = -1 * get_num(str, ++i);\n    }\n\n    if (str[0] == '(') {\n        num = get_num(str, i);\n    }\n\n    for (; i < str.size(); i++) {\n        if ('0' <= str[i] && str[i] <= '9') {\n            num = num * 10 + (str[i] - '0');\n        } else {\n            if (str[i] == '*') {\n                num = num * get_num(str, ++i);\n            } else if (str[i] == '/') {\n                num = num / get_num(str, ++i);\n            } else if (str[i] == '+') {\n                return num + dfs(sub(str, i));\n            } else if (str[i] == '-') {\n                return num - dfs(sub(str, i));\n            } else {\n                return num;\n            }\n        }\n    }\n\n    return num;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        string str;\n        cin >> str;\n\n        cout << dfs(str) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <string>\nusing namespace std;\n\nint exp(string &s, int &i);\nint term(string &s, int &i);\nint factor(string &s, int &i);\nint number(string &s, int &i);\n\nint exp(string &s, int &i)\n{\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-'){\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if(op == '+') val += val2;\n    else val -= val2;\n  }\n  return val;\n}\n\nint term(string &s, int &i)\n{\n  int val = factor(s, i);\n  while(s[i] == '*' || s[i] == '/'){\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if(op == '*') val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\n\nint factor(string &s, int &i)\n{\n  if(isdigit(s[i]))\n    return number(s, i);\n  i++;\n  int val = exp(s, i);\n  i++;\n  return val;\n}\n\nint number(string &s, int &i)\n{\n  int n = s[i] = '0';\n  i++;\n  while(isdigit(s[i])){\n    n = n * 10 + (s[i] - '0');\n    i++;\n  }\n  return n;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  for(int j = 0; j < n; j++){\n    string s;\n    cin >> s;\n    int i = 0;\n    cout << exp(s, i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nvoid select_cal(char c, int *tmp, int val){\n\n\tif(c == '+') *tmp += val;\n\telse if(c == '-') *tmp -= val;\n\telse if(c == '*') *tmp = floor(*tmp * val);\n\telse if(c == '/' && val != 0) *tmp = floor(*tmp / val);\n\n}\n\nint calculation(string str, int len, int begin){\n\n\tint ans, tmp, cnt, val;\n\tchar c;\n\t\n\tans = 0;\n\ttmp = 0;\n\tc = '+';\n\n\tfor(int i=begin; i<len; i++){\n\t\tif(str[i] == '+' || str[i] == '-'){\n\t\t\tans += tmp;\n\t\t\ttmp = 0;\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '*' || str[i] == '/'){\n\t\t\tc = str[i];\n\t\t}\n\t\telse if(str[i] == '('){\n\t\t\tselect_cal(c, &tmp, calculation(str, len, i+1));\n\t\t\tcnt = 1;\n\t\t\tdo{\n\t\t\t\ti++;\n\t\t\t\tif(str[i] == '(') cnt++;\n\t\t\t\telse if(str[i] == ')') cnt--;\n\t\t\t}while(cnt != 0);\n\t\t}\n\t\telse if(str[i] == ')' || str[i] == '='){\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcnt = 1;\n\t\t\twhile(str[i+cnt] >= '0' && str[i+cnt] <= '9'){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tval = 0;\n\t\t\tfor(int j=0; j<cnt; j++){\n\t\t\t\tval += (str[i+cnt-j-1] - '0') * pow(10, j);\n\t\t\t}\n\t\t\tselect_cal(c, &tmp, val);\n\t\t}\n\t}\n\tans += tmp;\n\n\treturn ans;\n\n}\n\nint main(){\n\n\tint n;\n\tstring str;\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> str;\n\t\tcout << calculation(str, str.length(), 0) << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nusing State = string::iterator;\n\nclass Solve {\npublic:\n    void input() {\n\n    }\n\n    int expression(State &begin) {\n        int ret = term(begin);\n\n        while (true) {\n            if (*begin == '+') {\n                begin++;\n                ret += term(begin);\n            } else if (*begin == '-') {\n                begin++;\n                ret -= term(begin);\n            } else if (*begin == ' ') {\n                begin++;\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int term(State &begin) {\n        int ret = factor(begin);\n        while (true) {\n            if (*begin == '*') {\n                begin++;\n                ret *= factor(begin);\n            } else if (*begin == '/') {\n                begin++;\n                ret /= factor(begin);\n            } else if (*begin == ' ') {\n                begin++;\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int factor(State &begin) {\n        if (*begin == '(') {\n            begin++;\n            int ret = expression(begin);\n            begin++;\n            return ret;\n        } else {\n            return number(begin);\n        }\n    }\n\n    int number(State &begin) {\n        int ret = 0;\n        while (*begin == ' ') begin++;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return ret;\n    }\n\n    void deletespace(State &begin) {\n\n    }\n\n    void solve() {\n        input();\n        int n;\n        cin >> n;\n\n        for (int i = 0; i < n; ++i) {\n            string s;\n//            cin.ignore(0);\n//            getline(cin, s);\n            cin >> s;\n\n            State begin = s.begin();\n            int ans = expression(begin);\n            cout << ans << endl;\n        }\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        s[0] = '\\0';\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <math.h>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nstring S;\nsize_t cur;\nint parse();\n\nint digit(){\n    assert(isdigit(S[cur]));\n    int n=S[cur]-'0';\n    cur++;\n    return n;\n}\n\nint number(){\n    int n=digit();\n    while(cur<S.size()&&isdigit(S[cur]))\n\tn=n*10+digit();\n    return n;\n}\n\nint expression();\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\tassert(S[cur]==')');\n\tcur++;\n\treturn n;\n} \n\nint term1(){\n    int a=factor();\n    while(cur<S.size()&&S[cur]=='^'){\n\tcur++;\n\tint b=factor();\n\ta=pow(a,b);\n    }\n    return a;\n}\n\nint term2(){\n    int a=term1();\n    while(cur<S.size()&&(S[cur]=='*'||S[cur]=='/')){\n\t\tchar op=S[cur++];\n\t\tint b=term1();\n\t\tif(op=='*')a*=b; else a/=b;\n    }\n    return a;\n}\n\nint expression(){\n    int a=term2();\n    while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n\tchar op=S[cur++];\n\tint b=term2();\n\tif(op=='+')a+=b; else a-=b;\n    }\n    return a;\n}\n\nint main() {\n    while(cin>>S){\n\tcur=0;\n\tcout<<expression()<<endl;\n    }\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem0109 : Smart Calculator **/\nstring s; int pos;\nint factor();\n\nint number()\n{\n\tint ret=0;\n\twhile (isdigit(s[pos])) {\n\t\tret *= 10;\n\t\tret += s[pos++]-'0';\n\t}\n\treturn ret;\n}\n\nint term()\n{\n\tint ret = factor();\n\t\n\tfor(;;) {\n\t\tif (s[pos] == '*') {\n\t\t\tpos++;\n\t\t\tret *= factor();\n\t\t} else if (s[pos] == '/') {\n\t\t\tpos++;\n\t\t\tret /= factor();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint expression()\n{\n\tint ret=term();\n\t\n\tfor (;;) {\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tret += term();\n\t\t} else if (s[pos] == '-') {\n\t\t\tpos++;\n\t\t\tret -= term();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint factor()\n{\n\tint ret;\n\t\n\tif (s[pos]=='(') {\n\t\tpos++;\n\t\tret = expression();\n\t\tpos++;\n\t} else {\n\t\tret = number();\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint N; cin>>N;\n\t\t\n\trep(i, N) {\n\t\tcin>>s;\n\t\tpos=0;\n\t\tcout << expression() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\n//parsed fact(const char* s)\n//{\n//\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tif(s[0]=='('){\n//\t\tparsed res=expr(s+1);\n//\t\tres.second++;\n//\t\treturn res;\n//\t}\n//\telse{\n//\t\tconst char* p=s;\n//\t\tif(*p=='-')\n//\t\t\tp++;\n//\t\tll n=0;\n//\t\twhile(isdigit(*p)){\n//\t\t\tn=n*10+*p-'0';\n//\t\t\tp++;\n//\t\t}\n//\t\treturn parsed(n,p);\n//\t}\n//}\n\nparsed fact(const char *p)\n{\n  if (isdigit(*p)){\n    //int t=*(p++)-'0';\n    int t=0;\n    while(isdigit(*p)) t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if (*p=='('){\n    parsed r=expr(p+1);\n    if (*r.second!=')') exit(0); // invalid input\n    return parsed(r.first,r.second+1);\n  }\n  else\n    exit(0); // invalid input\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar str[120];\n\nint calc2(char *eq){\n\tint c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tprintf(\"return %s=%d\\n\", eq, num[0]);\n\treturn num[0];\n}\n\nint calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tint k,ret;\n\tstrcpy(cp, eq);\n\tif(p=strchr(cp, '(')){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%d%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tint i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n\nusing namespace std;\n\nqueue<string>exp;\n\nint calculate();\nint add();\nint multiply();\nint term();\n\nint calculate()\n{\n  return add();\n}\n\nint add()\n{\n  int num=multiply();\n  if(exp.empty())return num;\n  string s=exp.front();\n  if(s[0]=='+'||s[0]=='-'){\n    exp.pop();\n    int num2=calculate();\n    if(s[0]=='+')return num+num2;\n    if(s[0]=='-')return num-num2;\n  }\n  return num;\n}\n\nint multiply()\n{\n  int num=term();\n  if(exp.empty())return num;\n  string s=exp.front();\n  if(s[0]=='*'||s[0]=='/'){\n    exp.pop();\n    int num2=calculate();\n    if(s[0]=='*')return num*num2;\n    if(s[0]=='/')return num/num2;\n  }\n  return num;\n}\n\nint term()\n{\n  string s=exp.front();\n  if(isdigit(s[0])){\n    exp.pop();\n    return atoi(s.c_str());\n  }\n  if(s[0]=='('){\n    exp.pop();\n    int num=calculate();\n    assert(exp.front()==\")\");\n    exp.pop();\n    return num;\n  }\n}\n\nint main()\n{\n  int n;\n  string s;\n  cin>>n;\n  while(n-->0){\n    cin>>s;\n    while(exp.size())exp.pop();\n    for(int i=0;i<s.size();i++){\n      if(s[i]=='=')break;\n      if(isdigit(s[i])){\n\tint j;\n\tfor(j=i+1;j<s.size();j++)if(!isdigit(s[j]))break;\n\texp.push(s.substr(i,j-i));\n\ti=j-1;\n      }else{\n\texp.push(s.substr(i,1));\n      }\n    }\n    cout<<calculate()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint solve(string str){\n    vector<int>op;\n    vector<char>ope;\n    //cout<<\"str: \"<<str<<endl;\n    //cout<<str.length()<<endl;\n    for(int i=0;i<str.length();i++){\n        //cout<<\"KK\";\n        if(str[i]=='('){\n            string t;\n            i++;\n            while(str[i]!=')'){\n                t+=str[i];\n                i++;\n            }\n            i++;\n            op.push_back(solve(t));\n            //cout<<\"(): \"<<ope[ope.size()-1]<<endl;\n            if(ope.size())\n            if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                int a=op[op.size()-1];\n                op.pop_back();\n                int b=op[op.size()-1];\n                op.pop_back();\n                if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                else op.push_back(b/a);\n                ope.pop_back();\n            }\n            ope.push_back(str[i]);\n        }\n        else if(str[i]>='0'&&str[i]<='9'){\n            int g=0;\n            while(str[i]>='0'&&str[i]<='9'){\n                g=g*10+str[i]-'0';\n                i++;\n            }\n            op.push_back(g);\n            if(ope.size())\n                if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                    int a=op[op.size()-1];\n                    op.pop_back();\n                    int b=op[op.size()-1];\n                    op.pop_back();\n                    if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                    else op.push_back(b/a);\n                    ope.pop_back();\n                }\n            if(str[i])ope.push_back(str[i]);\n        }\n    }\n    //cout<<\"!\"<<endl;\n    int las=op[op.size()-1];\n    op.pop_back();\n    while(ope.size()){\n        //cout<<\"las: \"<<las<<endl;\n        char c=ope[ope.size()-1];\n        ope.pop_back();\n        if(c=='=')continue;\n        int pre=op[op.size()-1];\n        //cout<<\"pre: \"<<pre<<endl;\n        //cout<<ope.size()<<\"   c: \"<<c<<endl;\n        op.pop_back();\n        if(c=='+')las=las+pre;\n        else las=pre-las;\n    }\n    //cout<<\"returned : \"<<las<<endl;\n    return las;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        string str;\n        cin>>str;\n        cout<<solve(str)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return -1;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        string s;\n        cin >> s;\n        State tmp = s.begin();\n        int ans = expression(tmp);\n        consume(tmp, '=');\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nclass Parser {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tParser(Iter it) :it(it) {}\n\tvoid cmp(char expected) { if (*it != expected)cerr << *it << \" is not \" << expected << endl; assert(*it == expected); }\n\t/*\n\tEBNF\n\t???=???,{('+'|'-'),???}; //??°???????????????????????¨??????????¨??????§?????????\n\t???=c,{('*'|'/'),c};\n\tc ='('???')' | integer;\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\twhile (true) {\n\t\t\tif (*it == '+') {\n\t\t\t\tit++;\n\t\t\t\tret += b();\n\t\t\t}\n\t\t\telse if (*it == '-') {\n\t\t\t\tit++;\n\t\t\t\tret -= b();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\twhile (true) {\n\t\t\tif (*it == '*') {\n\t\t\t\tit++;\n\t\t\t\tret *= c();\n\t\t\t}\n\t\t\telse if (*it == '/') {\n\t\t\t\tit++;\n\t\t\t\tret /= c();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tint n; cin >> n; cin.ignore();\n\tfor (string s; getline(cin, s) && s != \"$\"; ) {\n\t\ts += \"$\";\n\t\tParser P(s.begin());\n\t\tcout << P.a() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <stdlib.h>\n\nusing namespace std;\n\nstring ex_s; //expression_string\nint n;\n\nint cal(string ex_s) //calculate expression_string\n{\n    int i;\n    int j;\n    int ans; //answer\n    int cnt_p=0; //count_parentheses\n    int cnt_pp=1;\n    int cnt_as=0; //count_add subtract\n    int cnt_md=0; //count_nultiply divide\n    for(i=0;i<ex_s.size();i++)\n    {\n        if(ex_s[i]=='(')\n        {\n            for(j=i+1;j<ex_s.size();j++)\n            {\n                if(ex_s[j]=='(') cnt_pp+=1;\n                else if(ex_s[j]==')')\n                {\n                    cnt_pp-=1;\n                    if(cnt_pp==0)\n                    {\n                        cnt_pp=1;\n                        break;\n                    }\n                }\n            }\n            ans=cal(ex_s.substr(i+1,j-i-1));\n            ex_s=ex_s.substr(0,i)+to_string(ans)+ex_s.substr(j+1);\n            i=j;\n            cnt_p+=1;\n        }\n    }\n    if(cnt_p!=0)\n    {\n        return cal(ex_s);\n    }\n    else\n    {   for(i=0;i<ex_s.size();i++)\n        {\n            if(ex_s[i]=='+')\n            {\n                ans=cal(ex_s.substr(0,i))+cal(ex_s.substr(i+1));\n                cnt_as+=1;\n                return ans;\n                break;\n            }\n            else if(ex_s[i]=='-')\n            {\n                if(i==0) ans=0-cal(ex_s.substr(i+1));\n                else ans=cal(ex_s.substr(0,i))-cal(ex_s.substr(i+1));\n                cnt_as+=1;\n                return ans;\n                break;\n            }\n        }\n        if(cnt_as==0)\n        {\n            for(i=0;i<ex_s.size();i++)\n            {\n                if(ex_s[i]=='*')\n                {\n                    ans=cal(ex_s.substr(0,i))*cal(ex_s.substr(i+1));\n                    cnt_md+=1;\n                    return ans;\n                    break;\n                }\n                else if(ex_s[i]=='/')\n                {\n                    ans=cal(ex_s.substr(0,i))/cal(ex_s.substr(i+1));\n                    cnt_md+=1;\n                    return ans;\n                    break;\n                }\n            }\n            if(cnt_md==0)\n            {\n                return atoi(ex_s.c_str());\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    while(n--)\n    {\n        cin >> ex_s;\n        ex_s.pop_back();\n        cout << cal(ex_s) << endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\n\nstring str;\nint expr(int &idx);\nint factor(int &idx);\nint primary(int &idx);\nint inum(int &idx);\n\n// expr ::= factor | expr '+' factor | expr '-' factor\nint expr(int &idx){\n\tauto ret = factor(idx);\n\twhile(str[idx] != ')' && str[idx] != '='){\n\t\tauto op = str[idx];\n\t\tauto rest = factor(++idx);\n\t\tif(op == '+'){\n\t\t\tret += rest;\n\t\t}\n\t\telse if(op == '-'){\n\t\t\tret -= rest;\n\t\t}\n\t\telse{\n//\t\t\tcerr << op << endl;\n\t\t\tassert(0);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n// factor ::= primary | factor '*' primary | factor '/' primary\nint factor(int &idx){\n\tauto ret = primary(idx);\n\twhile(str[idx] == '*' || str[idx] == '/'){\n\t\tauto op = str[idx];\n\t\tauto rest = primary(++idx);\n\t\tif(op == '*') ret *= rest;\n\t\telse if(op == '/') ret /= rest;\n\t\telse{\n//\t\t\tcerr << op << endl;\n\t\t\tassert(0);\n\t\t}\n\t}\n\treturn ret;\n}\n\n// primary ::= '(' expr ')' | num\nint primary(int &idx){\n\tint ret;\n//\tcerr << idx << \":\" << str[idx] << endl;\n\tif(str[idx] == '('){\n\t\tret = expr(++idx);\n\t\tassert(str[idx] == ')');\n\t\tidx++;\n\t\treturn ret;\n\t}\n\tif(isdigit(str[idx])){\n\t\treturn inum(idx);\n\t}\n\tassert(0);\n\treturn -1;\n}\n\nint inum(int &idx){\n\tassert(isdigit(str[idx]));\n\tint i = idx;\n\twhile(isdigit(str[idx]))idx++;\n\treturn stoi(str.substr(i,idx-i));\n}\n\nsigned main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> str;\n\t\tint idx =0 ;\n\t\tcout << expr(idx) << endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstddef>\n#include <cassert>\n#include<cctype>\n\nusing namespace std;\n\nstring S;\nsize_t cur=0;\nint n;\nvoid init_S(){\n    cur=0;\n    \n}\nchar readchar(){\n    assert(cur<S.size());\n    char ret=S[cur];\n    cur+=1;\n    return ret;\n}\nchar peek(){\n    return S[cur];\n}\nint digit(){\n    assert(isdigit(peek()));\n    int n=readchar() - '0';\n    return n;\n}\nint number(){\n    int n=digit();\n    while(cur<S.size()&&isdigit(peek()))\n        n=n*10+digit();\n    return n;\n}\nint factor();\nint term(){\n    int sum=factor();\n    while(cur<S.size()&&(peek()=='*'||peek()=='/')){\n        char op=readchar();\n        int b=factor();\n        if(op=='*')sum*=b;\n        else sum/=b;\n    }\n    return sum;\n}\nint b;\n\nint expression(){\n    int sum=term();\n    while(cur<S.size() && (peek()=='+'||peek()=='-')){\n        char op=readchar();\n        int b=term();\n        if(op=='+')sum+=b;\n        else sum-=b;\n    }\n    return sum;\n}\n           \nint factor(){\n    if(peek()!='('){\n        return number();\n    }\n    cur++;\n    int n=expression();\n    assert(peek()==')');\n    cur++;\n    return n;\n}\n\nint parse(){\n    return expression();\n}\n\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>S;\n        int a=parse();\n        cout<<a<<endl;\n        S.clear();\n        init_S();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size()-1; flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    //if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    //if(!isNum(s[pos])){flag=true;}\n\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),z;\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      z=getNum();\n      if(z==0){flag=true;z=1;}\n      else if(res%z!=0)flag=true;\n      return res/z;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint expr(char *& s);\n\nint val(char *& s){\n\tif(*s == '('){\n\t\ts++;\n\t\tint ret = expr(s);\n\t\ts++;\n\t\treturn ret;\n\t}\n\n\tint v = 0;\n\twhile(*s >= '0' && *s <= '9'){\n\t\tv *= 10;\n\t\tv += *s - '0';\n\t\ts++;\n\t}\n\treturn v;\n}\n\nint pri(char *& s){\n\tif(*s == '-'){\n\t\ts++;\n\t\treturn val(s);\n\t}\n\tint l = val(s);\n\tchar ope = *s;\n\tif(ope != '*' && ope != '/')\n\t\treturn l;\n\ts++;\n\tint r = pri(s);\n\tif(ope == '*')\n\t\treturn l*r;\n\telse\n\t\treturn l/r;\n}\n\nint expr(char *& s){\n\tint l = pri(s);\n\tchar ope = *s;\n\tif(ope != '+' && ope != '-')\n\t\treturn l;\n\ts++;\n\tint r = expr(s);\n\tif(ope == '+')\n\t\treturn l+r;\n\telse\n\t\treturn l-r;\n}\n\nvoid solve()\n{\n\tchar s[101];\n\tcin>>s;\n\tchar *p = s;\n\tcout << expr(p) << endl;\n}\n\nint main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\nchar s[200];\nchar *p;\n\nint E();\nint F();\nint T();\nint N();\n\n#ifdef DEBUG\n#define dump(s) cerr << s << endl\n#else\n#define dump(...)\n#endif\n\nint E(){\n    int res = F();\n    while(*p=='+' || *p=='-'){\n        if(*p=='+') p++, res += F();\n        else if(*p=='-') p++, res -= F();\n    }\n    return res;\n}\n\nint F(){\n    int res = T();\n    while(*p=='*' || *p=='/'){\n        if(*p=='*') p++, res *= T();\n        else if(*p=='/') p++, res /= T();\n    }\n    dump(res);\n    return res;\n}\n\nint T(){\n    int res;\n    if(*p=='(') p++, res = E(), p++;\n    else res = N();\n    return res;\n}\n\nint N(){\n    int res = 0;\n    while(isdigit(*p)){\n        res = res*10 + *p - '0';\n        p++;\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> s;\n        p = s;\n        cout << E() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr double INFD = 1e100;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ios::sync_with_stdio(false);\n// cin.tie(nullptr);\n// ---------------------------------------------------------------------------\n\ntypedef string::const_iterator State;\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\n// 四則演算の式をパースして、その評価結果を返す\nint expression(State &begin){\n    int ret = term(begin);\n    while(1){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\n// 乗算除算の式をパースして、その評価結果を返す\nint term(State &begin){\n    int ret = factor(begin);\n    while(1){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\n// 括弧か数をパースして、その評価を返す\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\n// 数字の列をパースして、その数を返す\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N;\n    cin >> N;\n    cin.ignore();\n    for(int i=0; i<N; i++){\n        string S;\n        getline(cin,S);\n        State begin = S.begin();\n        int ans = expression(begin);\n        cout << ans << enld;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\n#define REP1(i,n)   for(ll i=1,i##_len=(n);i<=i##_len;++i)\nusing ll = long long;\nusing namespace std;\n\nll calculate_expression_without_brackets(const string&exprwb)\n{\n\tauto my_stoll = [](const string&str) {\n\t\tif (str[0] != '-') {\n\t\t\treturn stoll(str);\n\t\t} else {\n\t\t\tfor (ll i = 0;; ++i) {\n\t\t\t\tif (str[i] != '-') {\n\t\t\t\t\treturn stoll(str.substr(i - i % 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tvector<ll>arg;\n\tvector<char>opr;\n\tll head = 0;\n\tREP1(i, exprwb.size() - 2) {\n\t\tif (exprwb[i] == '+' || exprwb[i] == '-' && i != 0 && [](char c) {return '0' <= c && c <= '9'; }(exprwb[i - 1]) || exprwb[i] == '*' || exprwb[i] == '/') {\n\t\t\targ.push_back(my_stoll(exprwb.substr(head, i - head)));\n\t\t\topr.push_back(exprwb[i]);\n\t\t\thead = i + 1;\n\t\t}\n\t}\n\targ.push_back(my_stoll(exprwb.substr(head)));\n\tif (arg.size() == 1) {\n\t\treturn arg[0];\n\t} else {\n\t\tfor (ll i = 0; i < opr.size(); ++i) {\n\t\t\tif (opr[i] == '*') {\n\t\t\t\targ[i] *= arg[i + 1];\n\t\t\t\targ.erase(arg.begin() + i + 1);\n\t\t\t\topr.erase(opr.begin() + i);\n\t\t\t\t--i;\n\t\t\t} else if (opr[i] == '/') {\n\t\t\t\targ[i] /= arg[i + 1];\n\t\t\t\targ.erase(arg.begin() + i + 1);\n\t\t\t\topr.erase(opr.begin() + i);\n\t\t\t\t--i;\n\t\t\t}\n\t\t}\n\t\tif (arg.size() == 1) {\n\t\t\treturn arg[0];\n\t\t} else {\n\t\t\tfor (ll i = 0; i < opr.size(); ++i) {\n\t\t\t\tif (opr[i] == '+') {\n\t\t\t\t\targ[i] += arg[i + 1];\n\t\t\t\t\targ.erase(arg.begin() + i + 1);\n\t\t\t\t\topr.erase(opr.begin() + i);\n\t\t\t\t\t--i;\n\t\t\t\t} else if (opr[i] == '-') {\n\t\t\t\t\targ[i] -= arg[i + 1];\n\t\t\t\t\targ.erase(arg.begin() + i + 1);\n\t\t\t\t\topr.erase(opr.begin() + i);\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arg[0];\n\t\t}\n\t}\n}\nstring calculate_expression(const string&expr) {\n\tll open = expr.find('(');\n\tif (open != string::npos) {\n\t\tll close = [expr, open]() {\n\t\t\tll cnt = 0;\n\t\t\tfor (ll i = open + 1;; ++i) {\n\t\t\t\tif (expr[i] == '(') {\n\t\t\t\t\t++cnt;\n\t\t\t\t} else if (expr[i] == ')') {\n\t\t\t\t\tif (cnt == 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t\t--cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}();\n\t\treturn calculate_expression(expr.substr(0, open) + calculate_expression(expr.substr(open + 1, close - open - 1)) + expr.substr(close + 1));\n\t} else {\n\t\treturn to_string(calculate_expression_without_brackets(expr));\n\t}\n}\nsigned main()\n{\n\tll n;\n\tcin >> n;\n\tfor (ll i = 0; i < n; ++i) {\n\t\tstring expr;\n\t\tcin >> expr;\n\t\texpr.pop_back();\n\t\tcout << calculate_expression(expr) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (int i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nint calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = int(St.top()); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    return int(St.top());\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        cout << calculate(t, B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline string sub(string str, int i) {\n    return string(str.begin() + i + 1, str.end());\n}\n\nint dfs(string);\nint get_num(string&, int&);\n\nint get_num(string& str, int& i) {\n    int num = 0;\n\n    if (str[i] == '(') {\n        string ss;\n        i++;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n\n            if (count) {\n                ss += str[i];\n            }\n        }\n\n        i--;\n        return dfs(ss);\n    }\n\n    for (; i < str.size(); i++) {\n        if ('0' <= str[i] && str[i] <= '9') {\n            num = num * 10 + (str[i] - '0');\n        } else {\n            return num;\n        }\n    }\n    i--;\n\n    return num;\n}\n\nint dfs(string str) {\n    int num = 0;\n\n    int i = 0;\n\n    if (str[i] == '-') {\n        num = -1 * get_num(str, ++i);\n    }\n\n    if (str[0] == '(') {\n        num = get_num(str, i);\n    }\n\n    for (; i < str.size(); i++) {\n        if ('0' <= str[i] && str[i] <= '9') {\n            num = num * 10 + (str[i] - '0');\n        } else {\n            if (str[i] == '*') {\n                num = num * get_num(str, ++i);\n            } else if (str[i] == '/') {\n                num = num / get_num(str, ++i);\n            } else if (str[i] == '+') {\n                return num + dfs(sub(str, i));\n            } else if (str[i] == '-') {\n                return num - dfs(sub(str, i));\n            } else {\n                return num;\n            }\n        }\n    }\n\n    return num;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        string str;\n        cin >> str;\n\n        cout << dfs(str) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\nstring inputting;\n\ncin >> inputting;\ncerr << inputting << endl;\n\nreturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <stack>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint calculate(string expr) {\n\tmap<char,int> op_pd {{'+',0},{'-',0},{'*',1},{'/',1}}; // operator precedence\n\tvector<string> pf; // postfix expression\n\tstack<char> op_s;\n\t// turn infix to postfix\n\tstring unit;\n\tfor (char ch : expr) {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tunit.push_back(ch);\n\t\t} else {\n\t\t\tif (!unit.empty()) {\n\t\t\t\tpf.push_back(unit);\n\t\t\t\tunit.clear();\n\t\t\t}\n\t\t\tif (ch == '(') {\n\t\t\t\top_s.push('(');\n\t\t\t} else if (ch == ')') {\n\t\t\t\twhile (op_s.top() != '(') {\n\t\t\t\t\tpf.push_back(string().assign(1,op_s.top()));\n\t\t\t\t\top_s.pop();\n\t\t\t\t}\n\t\t\t\top_s.pop();\n\t\t\t} else { // '+','-','*','/'\n\t\t\t\twhile (!op_s.empty() && op_s.top() != '(' && op_pd[ch] <= op_pd[op_s.top()]) {\n\t\t\t\t\tpf.push_back(string().assign(1,op_s.top()));\n\t\t\t\t\top_s.pop();\n\t\t\t\t}\n\t\t\t\top_s.push(ch);\n\t\t\t}\n\t\t}\n\t}\n\tif (!unit.empty()) {\n\t\tpf.push_back(unit);\n\t}\n\twhile (!op_s.empty()) {\n\t\tpf.push_back(string().assign(1,op_s.top()));\n\t\top_s.pop();\n\t}\n\t// calculate the postfix expression\n\tstack<int> num_s;\n\tnum_s.push(stoi(pf.front()));\n\tfor (auto i = pf.begin() + 1;i != pf.end();++i) {\n\t\tif (i->front() >= '0' && i->front() <= '9') {\n\t\t\tnum_s.push(stoi(*i));\n\t\t} else {\n\t\t\tint second = num_s.top();\n\t\t\tnum_s.pop();\n\t\t\tint first = num_s.top();\n\t\t\tnum_s.pop();\n\t\t\tswitch (i->front()) {\n\t\t\t\tcase '+':\n\t\t\t\t\tnum_s.push(first + second);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tnum_s.push(first - second);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tnum_s.push(first*second);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: // '/'\n\t\t\t\t\tnum_s.push(first/second);\n\t\t\t}\n\t\t}\n\t}\n\treturn num_s.top();\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tstring expr;\n\t\tcin >> expr;\n\t\tcout << calculate(expr.substr(0,expr.size()-1)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\nint n;\nstring expr;\n\ncin >> n;\nfor  (int i = 0; i < n; i++){\n    cin >> expr;\n    cerr << expr << endl;\n}\nreturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nstd::string find(std::vector<std::string>&v, int a, bool b){\n\n\tstd::string res;\n\n\tif (b){\n\t\tfor (int i = a - 1; i >= 0; i--){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!b){\n\t\tfor (int i = a + 1; i < v.size(); i++){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint toint(std::string str){\n\n\tint res;\n\tstd::stringstream z;\n\n\tz << str;\n\tz >> res;\n\n\treturn res;\n\n}\n\nstd::string tostring(int a){\n\n\tstd::string str;\n\tstd::stringstream z;\n\n\tz << a;\n\tz >> str;\n\n\treturn str;\n\n}\n\nstd::string keisan(std::string lhs, std::string rhs, int t){\n\n\tint a, b, c;\n\n\ta = toint(lhs);\n\tb = toint(rhs);\n\n\tif (t == 1)c = a + b;\n\tif (t == 2)c = a - b;\n\tif (t == 3)c = a * b;\n\tif (t == 4)c = a / b;\n\n\treturn tostring(c);\n\n}\n\nstd::string keisan2(std::vector<std::string> &v){\n\n\tint res = 0;\n\n\tfor (int i = 0, j = 0, c = 0; i < v.size(); i++){\n\n\t\tif (v[i] == \"(\"){\n\t\t\tif (c == 0)j = i;\n\t\t\tc++;\n\t\t}\n\n\t\tif (v[i] == \")\"){\n\t\t\tc--;\n\t\t\tif (c == 0){\n\t\t\t\tstd::vector<std::string>w;\n\t\t\t\tfor (int p = j + 1; p < i; p++)w.push_back(v[p]);\n\t\t\t\tv[j] = keisan2(w);\n\t\t\t\tfor (int p = j + 1; p <= i; p++)v[p] = \"T\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"*\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 3);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"/\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 4);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"+\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 1);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\n\t\tif (v[i] == \"-\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 2);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tv[v.size() - 1] = \"T\";\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] != \"T\")res = toint(v[i]);\n\t}\n\treturn tostring(res);\n\n}\n\n\nint main(){\n\n\tint n;\n\tstd::cin >> n;\n\n\tfor (int i = 0; i < n; i++){\n\n\t\tstd::string str;\n\n\t\tstd::cin >> str;\n\n\t\tstd::vector<std::string> v;\n\n\t\tfor (int i = 0, j = 0; i < str.size(); i++){\n\n\t\t\tif (!(str[i] >= '0'&&str[i] <= '9')){\n\t\t\t\tif (i - j > 0)v.push_back(str.substr(j, i - j));\n\t\t\t\tv.push_back(str.substr(i, 1));\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << keisan2(v) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<vector>\nusing namespace std;\nint main(){\n  stringstream ss;\n  int n;\n  string line;\n  for(cin>>n;n>0;n--){\n    ss.str(\"\");\n    ss.clear(stringstream::goodbit);\n    cin>>line;\n    vector<int> form,f_nums;\n    vector<char> f_signs;\n    if(line[0]=='-')line = \"0\"+line;\n    ss<<line;\n    stack<char> sg;\n    int num;\n    char sign;\n    for(int i=0;i<line.size();i++){\n      if('0'<=ss.str()[i]&&ss.str()[i]<='9'){\n\tss>>num;\n\tfor(int d=10;d<=num;i++)d*=10;\n\tf_nums.push_back(num);\n\tform.push_back(f_nums.size()-1);\n      }\n      else{\n\tss>>sign;\n\tif(sign=='=')break;\n\tif(sign==')'){\n\t  while(sg.top()!='('){\n\t    f_signs.push_back(sg.top());\n\t    form.push_back(-f_signs.size());\n\t    sg.pop();\n\t  }\n\t  sg.pop();\n\t}\n\telse{\n\t  if(sign!='('){\n\t    while(!sg.empty()&&sg.top()!='('&&((sign=='+'||sign=='-')||(sg.top()=='*'||sg.top()=='/'))){\n\t      f_signs.push_back(sg.top());\n\t      form.push_back(-f_signs.size());\n\t      sg.pop();\n\t    }\n\t  }\n\t  sg.push(sign);\n\t}\n      }\n    }\n    while(!sg.empty()){\n      f_signs.push_back(sg.top());\n      form.push_back(-f_signs.size());\n      sg.pop();\n    }\n    stack<int> calc;\n    for(int i=0;i<form.size();i++){\n      if(form[i]>=0){\n\tcalc.push(f_nums[form[i]]);\n      }\n      else{\n\tdouble a,b,c;\n\tb = calc.top();\n\tcalc.pop();\n\ta = calc.top();\n\tcalc.pop();\n\tif(f_signs[-form[i]-1]=='+')c = a+b;\n\tif(f_signs[-form[i]-1]=='-')c = a-b;\n\tif(f_signs[-form[i]-1]=='*')c = a*b;\n\tif(f_signs[-form[i]-1]=='/')c = a/b;\n\tcalc.push(c);\n      }\n    }\n    cout<<calc.top()<<endl;\n  }\n  return 0;\n}\n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <cmath>\nusing namespace std;\n\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nvoid calc(string st, stack<double> &s) {\t\n\tif(st == \"*\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(floor(a * b));\n\t} else if(st == \"+\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(a + b);\n\t} else if(st == \"-\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(b - a);\n\t} else if(st == \"/\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(floor(b / a));\n\t} else {\n\t\ts.push(atof(st.c_str()));\n\t}\n}\nint getPriority(string s) {\n\tif(s == \"(\") {\n\t\treturn 5;\n\t} else if(s == \"*\" || s == \"/\") {\n\t\treturn 3;\n\t} else if(s == \"+\" || s == \"-\") {\n\t\treturn 2;\n\t} else if(s == \")\") { \n\t\treturn 1;\n\t} else return 4;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(--str.end());\n\t\t\n\t\tvector<string> v;\n\t\t\n\t\tint f = 0;\n\t\tchar prev = '(';\n\t\tbool minus = 0;\n\t\trep(i, str.size()) {\t\t\n\t\t\tif(isdigit(str[i])) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif(f) {\n\t\t\t\t\tstring st;\n\t\t\t\t\tif(minus) {\n\t\t\t\t\t\tst += '-';\n\t\t\t\t\t\tminus = 0;\n\t\t\t\t\t}\n\t\t\t\t\trep(j,f) {\n\t\t\t\t\t\tst += str[i - f + j];\n\t\t\t\t\t}\t\n\t\t\t\t\tv.push_back(st);\n\t\t\t\t\tstring st2;\n\t\t\t\t\tst2 += str[i];\n\t\t\t\t\tv.push_back(st2);\n\t\t\t\t\tf = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif(prev == '(' && str[i] == '-') {\n\t\t\t\t\t\tminus = 1;\n\t\t\t\t\t\tprev = str[i];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstring st3;\n\t\t\t\t\tst3 += str[i];\n\t\t\t\t\tv.push_back(st3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = str[i];\n\t\t}\n\t\tif(f) {\n\t\t\tstring st;\n\t\t\trep(j,f) {\n\t\t\t\tst += str[str.size() - f + j];\n\t\t\t}\n\t\t\tv.push_back(st);\n\t\t}\n\n\t\tstack<string> s;\n\t\tvector<string> nv;\n\t\tstack<double> ret;\n\t\tint p = 0;\n\t\trep(i,v.size()) {\n\t\t\tcout << v[i] << endl;\n\t\t}\n\t\trep(i,v.size()) {\n\t\t\tp = getPriority(v[i]);\n\t\t\twhile(!s.empty() && getPriority(s.top()) > p && s.top() != \"(\") {\n\t\t\t\tnv.push_back(s.top());\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(v[i] == \")\") {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(v[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()) {\n\t\t\tnv.push_back(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\trep(i,nv.size()) {\n\t\t\tcalc(nv[i], ret);\n\t\t}\n\t\tcout << ret.top() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\n#if 0\n所用時間:\n\n感想:\n\n#endif\n\nstring S;\nsize_t cur;\n\nint expression();\nint factor();\n\nchar readchar(){\n    assert(cur < S.size());\n    char ret =  S[cur];\n    cur += 1;\n    return ret;\n} \n\nchar peek(){\n    // assert(cur < S.size());\n    return S[cur];\n}\n\nint digit(){\n    // assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while( cur < S.size() && isdigit(peek()))\n        n = n * 10 + digit();\n    return n;\n}\n\nint term(){\n    int a = factor();\n    while(cur < S.size() && (peek()=='*' || peek()=='/')){\n        char op = readchar();\n        int b = factor();\n        if(op=='*') a*= b;\n        else a /= b;\n        // cout << \"calc: \" << a << \" \" << op << \" \" << b << endl;\n    }\n    return a;\n}\n\nint factor(){\n    if (peek() == '('){\n        cur += 1;\n        int n = expression();\n        assert(peek() == ')');\n        cur += 1;\n        return n;\n        }\n    else return number();\n}\n\nint expression(){\n    int a = term();\n    while(cur < S.size() && (peek()=='+' || peek()=='-')){\n        char op = readchar();\n        int b = term();\n        cout << \"calc: \" << a << \" \" << op << \" \" << b << endl;\n        if(op == '+'){\n            a += b;\n        }else{\n            a -= b;\n            }\n    }\n    return a;\n}\n\n\nint parse(){\n    return expression();\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i){\n        cin >> S;\n        cur = 0;\n        S.resize(S.size()-1); // 最後の=を無視\n        int a = parse();\n        cout << a << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 0;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 0;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\n\nstring cal_mul (string str, int sym) {\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    while (str[sym+R] >= '0' && str[sym+R] <= '9') {\n        R++;\n    }\n    rep(i ,R-1) {\n        sumR += mul10(i, str[sym+R-i-1] - '0');\n    }\n    //cout << sumL << endl;\n    //cout << sumR << endl;\n    stringstream str_tmp;\n    rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length(); i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            //cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        while(true){\n            str = cal_mul(str, find_muldiv(str));\n            if ( prev == str ) break;\n            else prev = str;\n        }\n        while(true){\n            str = cal_mul(str, find_addsub(str));\n            if ( prev == str ) break;\n            else prev = str;\n        }\n        //?????????????????????\n        cout << str << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s, int& i) {\n    int val = term(s, i);\n    while(s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        i++;\n        int val2 = term(s, i);\n        if (op == '+') val += val2;\n        else val -= val2;\n    }\n    return val;\n}\n\nint term(string& s, int& i) {\n    int val = factor(s, i);\n    while(s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        i++;\n        int val2 = factor(s, i);\n        if (op == '*') val *= val2;\n        else val /= val2;\n    }\n    return val;\n}\n\nint factor(string& s, int& i) {\n    if (isdigit(s[i])) return number(s, i);\n\n    // ここで構文が正しければ s[i] == '(' となる\n    i++; // '('を読み飛ばす\n    int ret = expr(s, i);\n    i++; // ')'を読み飛ばす\n    return ret;\n}\n\nint number(string& s, int& i) {\n    int n = s[i++] - '0';\n    while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n    return n;\n}\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        string str;\n        cin >> str;\n        int j = 0;\n        cout << expr(str, j) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n\n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    int ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=number(begin);\n\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n    return ret;\n  }\n  else return number(begin);\n}\n\nint number(State &begin){\n  int ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nconst string op = \"+-*/()=\";\nll RPN(string str){\n  string s,s2;\n  double ans;\n  stack<ll> n;\n  s = str;\n  ans = 0;\n  s += \" \" ;\n  rep(i,s.size()){\n    if(s[i] != ' '){\n      s2 += s[i];\n    }\n    else{\n      double a,b;\n      if(s2 == \"+\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a + b;\n        n.push(ans);\n      }\n      else if(s2 == \"-\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a - b;\n        n.push(ans);\n      }\n      else if(s2 == \"*\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a * b;\n        n.push(ans);\n      }\n      else if(s2 == \"/\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a / b;\n        n.push(ans);\n      }\n      else{\n        n.push(ston(s2,1.0));\n      }\n      s2.clear();\n    }\n  }\n  return n.top();\n}\n\nvector<string> Split(char c,string s){\n  vector<string> res(0);\n  string str = \"\";\n  rep(i,s.size()){\n    if(s[i] == c){\n      if(str.size()){\n        res.push_back(str);\n      }\n      str.clear();\n    }\n    else{\n      str += s[i];\n    }\n  }\n  res.push_back(str);\n  return res;\n}\nbool check(string s1,string s2){\n  if(((s1 == \"+\" || s1 == \"-\" ) && s2 != \"(\")|| s1 == s2) return true;\n  if((s1 == \"*\" || s1 == \"/\")&& (s2 == \"+\" || s2 == \"-\")) return false;\n  if(s2 == \"(\") return false;\n}\nstring ConvertRPN(string s){\n  const string notnumber = \"+-*/() \";\n  stack<string> fom;\n  auto str = Split(' ',s);\n  string res = \"\";\n  rep(i,str.size()){\n    if(notnumber.find(str[i]) == string::npos){\n      res += str[i];\n      res += \" \";\n    }\n    else if(str[i] == \")\"){\n      while(fom.top() != \"(\"){\n        if(fom.top() != \" \"){\n          res += fom.top();\n          res += \" \";\n        }\n        fom.pop();\n      }\n      fom.pop();\n    }\n    else if(str[i] == \"(\" || fom.empty()){\n      fom.push(str[i]);\n    }\n    else if(check(str[i],fom.top())){\n      while(!fom.empty() && check(str[i],fom.top())){\n        if(fom.top() != \" \"){\n          res += fom.top();\n          res += \" \";\n        }\n        fom.pop();\n      }\n      fom.push(str[i]);\n    }\n    else{\n      fom.push(str[i]);\n    }\n  }\n  while(fom.size()){\n    if(fom.top() != \" \"){\n      res += fom.top();\n      res += \" \";\n    }\n    fom.pop();\n  }\n  res.resize(res.size()-1);\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  rep(i,n){\n    string s,res = \"\";\n    cin >> s;\n    rep(i,s.size()){\n      if(find(all(op),s[i]) == op.end()){\n        res += s[i];\n      }\n      else{\n        if(res[res.size()-1] != ' ' )\n        res += \" \";\n        res += s[i] ;\n        res += \" \";\n      }\n    }\n    res.resize(res.size()-3);\n    res = ConvertRPN(res);\n    cout << RPN(res)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring input;\nint pos;\n\nint fact();\nint term();\nint expr();\n\nint fact() {\n\tint result = 0;\n\tif (input[pos] == '(') {\n\t\tpos++;\n\t\tresult = expr();\n\t\tpos++;\n\t} else {\n\t\twhile (isdigit(input[pos])) {\n\t\t\tresult = result * 10 + input[pos] - '0';\n\t\t\tpos++;\n\t\t}\n\t}\n//\tcout << \"fact: \" << result << endl;\n\treturn result;\n}\n\nint term() {\n\tint result = fact();\n\twhile (input[pos] == '*' || input[pos] == '/') {\n\t\tif (input[pos] == '*') {\n\t\t\tpos++;\n\t\t\tresult *= fact();\n\t\t} else {\n\t\t\tpos++;\n\t\t\tresult /= fact();\n\t\t}\n\t}\n//\tcout << \"term: \" << result << endl;\n\treturn result;\n}\n\nint expr() {\n\tint result = term();\n\twhile (input[pos] == '+' || input[pos] == '-') {\n\t\tif (input[pos] == '+') {\n\t\t\tpos++;\n\t\t\tresult += term();\n\t\t} else {\n\t\t\tpos++;\n\t\t\tresult -= term();\n\t\t}\n\t}\n//\tcout << \"expr: \" << result << endl;\n\treturn result;\n}\n\nint main() {\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tpos = 0;\n\t\tcout << expr() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring s;\nint parse(int l, int r){\n  int k = 0;\n \n  for(int i = r - 1; i >= l; i--){\n    if(s[i] == ')') k++;\n    if(s[i] == '(') k--;\n    if(!k && s[i] == '+')return parse(l, i) + parse(i + 1, r);\n    if(!k && s[i] == '-')return parse(l, i) - parse(i + 1, r);\n  }\n \n  for(int i = r - 1; i >= l; i--){\n    if(s[i] == ')') k++;\n    if(s[i] == '(') k--;\n    if(!k && s[i] == '*')return parse(l, i) * parse(i + 1, r);\n    if(!k && s[i] == '/')return parse(l, i) / parse(i + 1, r);\n  }\n \n  if(s[l] == '(' && s[r - 1] == ')')return parse(l + 1, r - 1);\n \n  return stoi( s.substr(l, r - l) );\n}\n \nint main()\n{\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> s;\n    cout << parse(0, (int)s.size() - 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring S;\nsize_t cur;\n\n\nint digit();\nint number();\nint factor();\nint term();\nint expression();\n\nint digit(){\n\treturn S[cur++]-'0';\n}\n\nint number(){\n\tint res=digit();\n\twhile(cur<S.size()&&isdigit(S[cur])){\n\t\tres*=10;\n\t\tres+=digit();\n\t}\n\treturn res;\n}\nint factor() {\n    if (S[cur] != '(') return number();\n\tcur++;\n    int res=expression();\n\tcur++;\n    return res;\n}\n\nint term(){\n\tint a=factor();\n\twhile(S[cur]=='*'||S[cur]=='/'){\n\t\tchar op=S[cur];\n\t\tcur++;\n\t\tint b=factor();\n\t\tswitch(op){\n\t\t\tcase '*':\n\t\t\t\ta*=b;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\ta/=b;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint a=term();\n\twhile(S[cur]=='+'||S[cur]=='-'){\n\t\tchar op=S[cur];\n\t\tcur++;\n\t\tint b=term();\n\t\tswitch(op){\n\t\t\tcase '+':\n\t\t\t\ta+=b;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\ta-=b;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> S;\n\t\tcur=0;\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define sc(x) cin >> x\n#define sc2(x, y) cin >> x >> y\n#define sc3(x, y, z) cin >> x >> y >> z\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstring s;\nint sp;\n\nint expr(void);\n\nint nextin(void){\n  int res = 0;\n  for(;;sp++){\n    if('0' > s[sp] || s[sp] > '9')break;\n    res *= 10;\n    res += (int)(s[sp] - '0');\n  }\n  return res;\n}\nint nextint(void){\n  if(s[sp] == '-'){\n    sp++;\n    return -1 * nextin();\n  }\n  return nextin();\n}\n\nint term(void){\n  int res = 0;\n  if(s[sp] == '('){\n    ++sp; res += expr(); ++sp;\n  }else res += nextint();\n  return res;\n}\n\nint factor(void){\n  int res = term();\n  for(;;){\n    if(s[sp] == '*'){\n      ++sp; res *= term();\n    }else if(s[sp] == '/'){\n      ++sp; res /= term();\n    }else break;\n  }\n  return res;\n}\n\nint expr(void){\n  int res = factor();\n  for(;;){\n    if(s[sp] == '+'){\n      ++sp; res += factor();\n    }else if(s[sp] == '-'){\n      ++sp; res -= factor();\n    }else break;\n  }\n  return res;\n}\n\nint solve(void){\n  sp = 0;\n  int res = expr();\n  return res;\n}\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    int(n);\n    for(;n--;){\n      sc(s);\n      pri(solve());\n      s.clear();\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tint ret = expression(begin);\n\t\tconsume(begin,')');\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass calc{\n  string s;\n  string::iterator it;\npublic:\n  calc(string str){\n    s = str;\n    it = str.begin();\n  }\n\n  int fact(){\n    if(*it == '('){\n      *it++;\n      int ret = exp();\n      *it++;\n      return ret;\n    } else {\n      int ret = 0;\n      while('0' <= *it && *it <= '9'){\n\tret *= 10;\n\tret += *it-'0';\n\t++it;\n      }\n      return ret; \n    }\n}\n\n  int turm(){\n    int ret = fact();\n    while(*it == '*' || *it == '/'){\n      if(*it == '*'){\n\t*it++;\n\tret *= fact();\n \n      } else if(*it == '/'){\n\t*it++;\n\tret /= fact(); \n      }\n    }\n    return ret;\n  }\n  int exp(){\n    int ret = turm();\n    while(*it == '+' || *it == '-'){\n      if(*it == '+'){\n\t*it++;\n\tret += turm();\n \n      } else if(*it == '-'){\n\t*it++;\n\tret -= turm(); \n      }\n    }\n    return ret;\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    string str;\n    cin >> str;\n    calc ans(str);\n    cout << ans.exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tState s = str.begin();\n\t\tcout << expression(s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nstd::string find(std::vector<std::string>&v, int a, bool b){\n\n\tstd::string res;\n\n\tif (b){\n\t\tfor (int i = a - 1; i >= 0; i--){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!b){\n\t\tfor (int i = a + 1; i < v.size(); i++){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint toint(std::string str){\n\n\tint res;\n\tstd::stringstream z;\n\n\tz << str;\n\tz >> res;\n\n\treturn res;\n\n}\n\nstd::string tostring(int a){\n\n\tstd::string str;\n\tstd::stringstream z;\n\n\tz << a;\n\tz >> str;\n\n\treturn str;\n\n}\n\nstd::string keisan(std::string lhs, std::string rhs, int t){\n\n\tint a, b, c;\n\n\ta = toint(lhs);\n\tb = toint(rhs);\n\n\tif (t == 1)c = a + b;\n\tif (t == 2)c = a - b;\n\tif (t == 3)c = a * b;\n\tif (t == 4)c = a / b;\n\n\treturn tostring(c);\n\n}\n\nstd::string keisan2(std::vector<std::string> &v){\n\n\tint res = 0;\n\n\tfor (int i = 0, j = 0, k = 0; i < v.size(); i++){\n\t\tif (v[i] == \"(\")j = i, k++;\n\t\tif (v[i] == \")\"){\n\t\t\tk--;\n\t\t\tif (k == 0){\n\t\t\t\tstd::vector<std::string>w;\n\t\t\t\tfor (int p = j + 1; p < i; p++)w.push_back(v[p]);\n\t\t\t\tv[j] = keisan2(w);\n\t\t\t\tfor (int p = j + 1; p <= i; p++)v[p] = \"T\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"*\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 3);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"/\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 4);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"+\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 1);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"-\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 2);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tv[v.size() - 1] = \"T\";\n\tfor (int i = 0; i < v.size(); i++)if (v[i] != \"T\")res = toint(v[i]);\n\n\treturn tostring(res);\n\n}\n\n\nint main(){\n\n\tint n;\n\tstd::cin >> n;\n\n\tfor (int i = 0; i < n; i++){\n\n\t\tstd::string str;\n\n\t\tstd::cin >> str;\n\n\t\tstd::vector<std::string> v;\n\n\t\tfor (int i = 0, j = 0; i < str.size(); i++){\n\n\t\t\tif (!(str[i] >= '0'&&str[i] <= '9')){\n\t\t\t\tif (i - j > 0)v.push_back(str.substr(j, i - j));\n\t\t\t\tv.push_back(str.substr(i, 1));\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << toint(keisan2(v)) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring s;\n\nint stoi(string str){\n  stringstream ss(str);\n  int n;\n  ss >> n;\n  return n;\n}\n\nint parse(int l, int r){\n  int n = 0, i;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')n++;\n    if(s[i] == '(')n--;\n    if(!n){\n      if(s[i] == '+')return parse(l,i) + parse(i+1,r);\n      if(s[i] == '-')return parse(l,i) - parse(i+1,r);\n    }\n  }\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')n++;\n    if(s[i] == '(')n--;\n    if(!n){\n      if(s[i] == '*')return parse(l,i) * parse(i+1,r);\n      if(s[i] == '/')return parse(l,i) / parse(i+1,r);\n    }\n  }\n\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  return stoi( s.substr(l,r-l) );\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint factor(State &begin);\n\nint number(State &begin){\n    int ret=0;\n\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin -'0';\n        begin++;\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n\n    while(true){\n        if(*begin=='*')ret*=factor(++begin);\n        else if(*begin=='/')ret/=factor(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret=term(begin);\n    while(true){\n        if(*begin=='+')ret+=term(++begin);\n        else if(*begin=='-')ret-=term(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    int ret;\n    if(*begin=='('){\n        ret=expression(++begin);\n        begin++;\n    }else{\n        ret =number(begin);\n    }\n    return ret;\n}\n\nint main(){\n\n    int N;\n    cin>>N;\n    cin.ignore();\n    string s[N];\n    REP(i,N)getline(cin,s[i]);\n    REP(i,N){\n        s[i]=s[i].substr(0,s[i].size()-1);\n        State begin=s[i].begin();\n        int ret=expression(begin);\n        cout<<ret<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nP equation(const string &str, int pos=0);\nP factor(const string &str, int pos = 0);\nP term(const string &str, int pos = 0);\n\nP equation(const string &str, int pos){\n\tP res = factor(str,pos);\n\twhile(str[res.second] == '+' || str[res.second] == '-'){\n\t\tP res_ = factor(str,res.second+1);\n\t\tif(str[res.second] == '+') res.first += res_.first;\n\t\telse res.first -= res_.first;\n\t\tres.second = res_.second;\n\t}\n\treturn res;\n}\n\nP factor(const string &str, int pos) {\n\tP res = term(str, pos);\n\twhile (str[res.second] == '*' || str[res.second] == '/') {\n\t\tP res_ = term(str, res.second+1);\n\t\tif(str[res.second] == '*') res.first *= res_.first;\n\t\telse res.first /= res_.first;\n\t\tres.second = res_.second;\n\t}\n\treturn res;\n}\n\nP term(const string &str, int pos) {\n\tif(str[pos] == '('){\n\t\tP res = equation(str,pos+1);\n\t\tres.second += 1;\n\t\treturn res;\n\t} else {\n\t\tint val = 0;\n\t\twhile(isdigit(str[pos])){\n\t\t\tval = val * 10 + (str[pos++]-'0');\n\t\t}\n\t\treturn P(val,pos);\n\t}\n}\n\n\nint main(){\n\tstring str;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>str;\n\t\tP res = equation(str);\n\t\tcout << res.first << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\nstring toRPN(string s){\n\tstack<char> ope;\n\tstring ret;\n\t\n\trep(i,s.size()){\n\t\tif( isdigit(s[i]) ) ret+=s[i];\n\t\t\n\t\telse{\n\t\t\tswitch(s[i]){\n\t\t\t\tcase '(' :\n\t\t\t\t\tope.push(s[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')' :\n\t\t\t\t\twhile(ope.top()!='('){\n\t\t\t\t\t\tret+=ope.top();\n\t\t\t\t\t\tope.pop();\n\t\t\t\t\t}\n\t\t\t\t\tope.pop();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*' :\n\t\t\t\tcase '/' :\n\t\t\t\t\twhile( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n\t\t\t\t\t\tret+=ope.top();\n\t\t\t\t\t\tope.pop();\n\t\t\t\t\t}\n\t\t\t\t\tope.push(s[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+' :\n\t\t\t\tcase '-' :\n\t\t\t\t\twhile( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n\t\t\t\t\t\tret+=ope.top();\n\t\t\t\t\t\tope.pop();\n\t\t\t\t\t}\n\t\t\t\t\tope.push(s[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\treturn \"invalid\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\twhile(ope.size()){\n\t\tret+=ope.top();\n\t\tope.pop();\n\t}\n\t\n\treturn ret;\n}\n\nstring solveRPN(string s){\n\tstack<int> stk;\n\t\n\t\n\tfor(int i=0;i<s.size();i++){\n\t\tif( isdigit(s[i]) )stk.push( s[i]-'0'  );\n\t\telse{\n\t\t\tint b=stk.top(); stk.pop();\n\t\t\tint a=stk.top(); stk.pop();\n\t\t\t\n\t\t\tif(s[i]=='+')stk.push(a+b);\n\t\t\tif(s[i]=='-')stk.push(a-b);\n\t\t\tif(s[i]=='*')stk.push(a*b);\n\t\t\tif(s[i]=='/')stk.push(a/b);\n\t\t}\n\t}\n\t\n\tstringstream ret;\n\tret<<stk.top();\n\t\n\treturn ret.str();\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\t\n\t\ts.erase(s.size()-1);\n\t\t\n\t\ts=toRPN(s);\n\t\ts=solveRPN(s);\n\t\t\n\t\tcout<<s<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  // while (isdigit(s.peek())) {\n  //   val *= 10;\n  //   val += s.peek() - '0';\n  //   s.next();\n  // }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nstring st;\nint a;\n\nint plmi();\n\nint num() {\n\tint n = 0;\n\twhile (1) {\n\t\tif (isdigit(st[a])) {\n\t\t\tn *= 10;\n\t\t\tn += st[a] - '0';\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn n;\n\t\t}\n\t}\n}\n\nint siki() {\n\tint n;\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tn=plmi();\n\t\ta++;\n\t}\n\telse {\n\t\tn = num();\n\t}\n\treturn n;\n}\n\nint evdi() {\n\tint n = siki();\n\twhile (1) {\n\t\tif (st[a] == '*') {\n\t\t\ta++;\n\t\t\tn *= siki();\n\t\t}\n\t\telse if (st[a] == '/') {\n\t\t\ta++;\n\t\t\tn /= siki();\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}\n\nint plmi() {\n\tint n=evdi();\n\twhile (1) {\n\t\tif (st[a] == '+') {\n\t\t\ta++;\n\t\t\tn += evdi();\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta++;\n\t\t\tn -= evdi();\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn n;\n}\n\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> st;\n\t\ta = 0;\n\t\tint ans=plmi();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nint parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')'){\n\t\tbool f=true;\n\t\tfor(int i=1,d=1;i<s.length()-1;i++){\n\t\t\tif     (s[i]=='(')\td++;\n\t\t\telse if(s[i]==')')\td--;\n\t\t\tif(d==0){\tf=false;\tbreak;\t}\n\t\t}\n\t\tif(f)\treturn parse(s.substr(1,s.length()-2));\n\t}\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=0,d=0;i<s.length();i++){\n\t\tif     (s[i]=='(')\td++;\n\t\telse if(s[i]==')')\td--;\n\n\t\telse if(d==0 && prior[s[i]]!=0){\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoi(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(string delim,string str){\n\tvector<string> res;\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ) res.push_back(str.substr(i,j-1));\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstring calc(vector<string> v){\n\tstack<string> stk;\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"-\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2-num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2+num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"*\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2*num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"/\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint num1;\n\t\t\tsscanf(str1.c_str(),\"%d\",&num1);\n\t\t\t\n\t\t\tint num2;\n\t\t\tsscanf(str2.c_str(),\"%d\",&num2);\n\n\t\t\tstring res;\n\t\t\tchar buf[64];\n\t\t\tsprintf(buf,\"%d\",num2/num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse{\n\t\t\tstk.push(v[i]);\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nvector<string> rvs_polish(string str){\n\tstack<string> stk;\n\tvector<string> v;\n\n\tstring tmp=\"\";\n\tvector<string> res;\n\tif(str[0]=='-'){\n\t\tstr='0'+str;\n\t}\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='*'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"*\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='-'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"-\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='/'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"/\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='+'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"+\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='='){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"=\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse{\n\t\t\ttmp+=str.substr(i,1);\n\t\t}\n\t}\n\n\tv.push_back(tmp);\n\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"*\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\"){\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"/\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"/\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\" || opr == \"*\"){\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"-\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres.push_back(v[i]);\n\t\t}\n\t}\n\n\twhile(!stk.empty()){\n\t\tres.push_back(stk.top());\n\t\tstk.pop();\n\t}\n\n\treturn res;\n}\n\nvoid dfs(string str){\n\tstack<P> stk;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='(') {stk.push(P('(',i));}\n\t\telse if(str[i]==')') {\n\t\t\tchar sym = stk.top().first;\n\t\t\tif(sym != '(') continue;\n\n\t\t\tint pos = stk.top().second;\n\t\t\tstk.pop();\n\n\t\t\tif(str.substr(pos+1,(i-1)-(pos+1)+1).find('(') == string::npos\n\t\t\t\t&& str.substr(pos+1,(i-1)-(pos+1)+1).find(')') == string::npos){\n\t\t\t\t\tvector<string> pol = rvs_polish(str.substr(pos+1,(i-1)-(pos+1)+1));\n\t\t\t\t\tstring num = calc(pol);\n\t\t\t\t\tstr.replace(pos,i-pos+1,num);\n\t\t\t\t\t//cout << str << endl;\n\t\t\t\t\twhile(!stk.empty()) stk.pop();\n\t\t\t\t\ti=-1;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<string> ans = rvs_polish(str);\n\n\tcout << calc(ans) << endl;\n}\n\nint main(){\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tint n;\n\t\tsscanf(str.c_str(),\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\t\t\tdfs(str.substr(0,str.size()-1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parser{\n    typedef string::const_iterator itr;\n    itr begin;\n    T ans;\n    Parser(const string &s){\n        begin=s.begin();\n        ans=expr(begin);\n        // cerr<<s<<\" \"<<ans<<\"\\n\";\n    }\n    T expr(itr &begin){\n        T ret=term(begin);\n        while(1){\n            if((*begin)=='+'){\n                consume(begin,'+');\n                ret+=term(begin);\n            }else if((*begin)=='-'){\n                consume(begin,'-');\n                ret-=term(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    T numb(itr &begin){\n        T ret=0;\n        while('0'<=(*begin)&&(*begin)<='9'){\n            ret*=10;\n            ret+=(*begin)-'0';\n            begin++;\n        }\n        return ret;\n    }\n    T fact(itr &begin){\n        T ret=0;\n        if((*begin)=='('){\n            consume(begin,'(');\n            ret=expr(begin);\n            consume(begin,')');\n        }else{\n            ret=numb(begin);\n        }\n        return ret;\n    }\n    T term(itr &begin){\n        T ret=fact(begin);\n        while(1){\n            if((*begin)=='*'){\n                consume(begin,'*');\n                ret*=fact(begin);\n            }else if((*begin)=='/'){\n                consume(begin,'/');\n                ret/=fact(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n        }\n    }\n};\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>>s;\n        Parser<int> parse(s);\n        cout<<parse.ans<<\"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(char *s, char *end)\n{\n\t/*for (char *p = s; p != end; p++) printf(\"%c\", *p);\n\tputs(\"\");*/\n\t\n\tbool f = false;\n\t\n\tvector<int> st;\n\tvector<char> op;\n\t\n\tchar *p = s;\n\twhile (p != end){\n\t\tif (!f) if (*p == '('){\n\t\t\tchar *e = p + 1;\n\t\t\tint cnt = 1;\n\t\t\twhile (true){\n\t\t\t\tif (*e == '(') cnt++;\n\t\t\t\tif (*e == ')') cnt--;\n\t\t\t\tif (cnt == 0) break;\n\t\t\t\te++;\n\t\t\t}\n\t\t\tst.push_back(calc(p + 1, e));\n\t\t\tp = e;\n\t\t}\n\t\tif (f) if (*p == '+' || *p == '-' || *p == '*' || *p == '/'){\n\t\t\top.push_back(*p);\n\t\t\tp++;\n\t\t\tf ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!f) if (*p >= '0' && *p <= '9'){\n\t\t\tint n = atoi(p);\n\t\t\tst.push_back(n);\n\t\t\tstringstream ss;\n\t\t\tss << n;\n\t\t\tp += ss.str().size() - 1;\n\t\t}\n\t\tif (!f) if (*p == '-'){\n\t\t\tint n = atoi(p);\n\t\t\tst.push_back(n);\n\t\t\tstringstream ss;\n\t\t\tss << n;\n\t\t\tp += ss.str().size() - 1;\n\t\t\t//printf(\"%s\\n\", ss.str().c_str());\n\t\t}\n\t\tif (op.size() && (op.back() == '*' || op.back() == '/')){\n\t\t\tint b = st.back(); st.pop_back();\n\t\t\tint a = st.back(); st.pop_back();\n\t\t\tif (op.back() == '*') a *= b;\n\t\t\tif (op.back() == '/') a /= b;\n\t\t\tst.push_back(a);\n\t\t\top.pop_back();\n\t\t}\n\t\tp++;\n\t\tf = !f;\n\t\t/*printf(\"__\");\n\t\tfor (auto a : st) printf(\"%d \", a);\n\t\tputs(\"\");*/\n\t}\n\t\n\twhile (op.size()){\n\t\tint t = st.front(); st.erase(st.begin());\n\t\t/*if (st.size() == 0){\n\t\t\tif (op.front() == '-') st.push_back(-t);\n\t\t\telse st.push_back(t);\n\t\t\top.erase(op.begin());\n\t\t\tbreak;\n\t\t}*/\n\t\tif (op.front() == '+') st[0] = t + st[0];\n\t\tif (op.front() == '-') st[0] = t - st[0];\n\t\top.erase(op.begin());\n\t}\n\t\n\treturn st[0];\n}\n\nint main()\n{\n\tint n;\n\tchar str[1024];\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%s\", str);\n\t\tstr[strlen(str) - 1] = '\\0';\n\t\tprintf(\"%d\\n\", calc(str, str + strlen(str)));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\ntypedef string::const_iterator iter;\n\nint expr(iter &p);\nint term(iter& p);\nint factor(iter& p);\nint number(iter& p);\n\nint expr(iter& p) {\n    int r = term(p);\n    while(true) {\n        if(*p == '+') {\n            ++p;\n            int rs = term(p);\n            r += rs;\n        }\n        else if(*p == '-') {\n            ++p;\n            int rs = term(p);\n            r -= rs;\n        }\n        else {\n            break;\n        }\n    }\n    return r;\n}\n\nint term(iter& p) {\n    int r = factor(p);\n    while(true) {\n        if(*p == '*') {\n            ++p;\n            int rs = term(p);\n            r *= rs;\n        }\n        else if(*p == '/') {\n            ++p;\n            int rs = term(p);\n            r /= rs;\n        }\n        else {\n            break;\n        }\n    }\n    return r;\n}\n\nint factor(iter& p) {\n    if(*p == '(') {\n        ++p; // skip (\n        int r = expr(p);\n        ++p; // skip )\n        return r;\n    }\n    \n    return number(p);\n}\n\nint number(iter& p) {\n    int r = 0;\n    while(isdigit(*p)) {\n        r *= 10;\n        r += *p -'0';\n        p++;\n    }\n    return r;\n}\n\nint main() {\n    int n; cin >> n;\n    while(n--) {\n        string s; cin >> s;\n        iter it = s.begin();\n        int res = expr(it);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\t\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\t// cout << \"number :: \" << ret << endl;\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\t\n\twhile(1) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\t// cout << \"go factor // *\" << endl;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\t// cout << \"go factor // /\" << endl;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse break;\n\t}\n\t// // cout << \"term :: \" << ret << endl;\n    return ret;\n}\nint expression(State &begin) {\n\tint ret = term(begin);\n\t\n\twhile(1) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\t// // cout << \"go term // +\" << endl;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\t// // cout << \"go term // -\" << endl;\n\t\t\tret -= term(begin);\n        }\n        else break;\n\t}\n\t// // cout << \"expression :: \" << ret << endl;\n\treturn ret;\n}\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++; \n\t\t// // cout << \"go expression\" << endl;\n\t\tint ret = expression(begin);\n\t\t// // cout << \"factor :: \" << ret << endl;\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse return number(begin);\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\t\n\t\tState begin = s.begin();\n\t\t // cout << \"Start !!!\" << endl;\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if('0' > s[i] || s[i] > '9') return false;\n  \n  return true;\n}\n\nint solve(string s){\n\n  // cout << s << endl;\n\n  // if(s[0] == '-') return -1*solve(s.substr(1));\n  if(isnum(s)){\n    stringstream ss(s);\n    int tmp;\n    ss >> tmp;\n    return tmp;\n    \n  }else{\n    int para = 0;\n\n    for(int i = s.length()-1; i >= 0; i--){\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n\n      if((s[i] == '+' || s[i] == '-') && para == 0 && i)\n\tif(s[i] == '+') return solve(s.substr(0,i))+solve(s.substr(i+1));\n\telse return solve(s.substr(0,i))-solve(s.substr(i+1));\n    }\n\n    para = 0;\n\n    for(int i = s.length()-1; i >= 0; i--){\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n      \n      if((s[i] == '*' || s[i] == '/') && para == 0 && i)\n\tif(s[i] == '*') return solve(s.substr(0,i))*solve(s.substr(i+1));\n\telse return solve(s.substr(0,i))/solve(s.substr(i+1));\n    }\n\n    if(s[0] == '(' && s[s.length()-1] == ')')\n      return solve(s.substr(1,s.length()-2));\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    string s;\n    cin >> s;\n    if(s[0] == '-') cout << solve(\"0\"+s.substr(0,s.length()-1)) << endl;\n    else cout << solve(s.substr(0,s.length()-1)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\nbool isnum(string s){\n  for(int i = 0; i < s.length(); i++)\n    if('0' > s[i] || s[i] > '9') return false;\n  \n  return true;\n}\n\nint solve(string s){\n\n  if(s[0] == '-') return -1*solve(s.substr(1));\n  if(isnum(s)){\n    stringstream ss(s);\n    int tmp;\n    ss >> tmp;\n    return tmp;\n    \n  }else{\n    int para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n\n      if((s[i] == '+' || s[i] == '-') && para == 0 && i)\n\tif(s[i] == '+') return solve(s.substr(0,i))+solve(s.substr(i+1));\n\telse return solve(s.substr(0,i))-solve(s.substr(i+1));\n    }\n\n    para = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') para++;\n      if(s[i] == ')') para--;\n      \n      if((s[i] == '*' || s[i] == '/') && para == 0 && i)\n\tif(s[i] == '*') return solve(s.substr(0,i))*solve(s.substr(i+1));\n\telse return solve(s.substr(0,i))/solve(s.substr(i+1));\n    }\n\n    if(s[0] == '(' && s[s.length()-1] == ')')\n      return solve(s.substr(1,s.length()-2));\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    string s;\n    cin >> s;\n    cout << solve(s.substr(0,s.length()-1)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = number(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= number(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= number(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n\nint main(void){\n\tint N;\n    cin >> N;\n    cin.ignore()\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing pii = pair<int,int>;\n#define FOR(i,a,b) for(ll i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define pb push_back\n#define fst first\nstring s;\nint id;\n\nbool left(){\n  return id < (int)s.size()-1;\n}\nchar peek(){\n  return s[id];\n}\nchar pop(){\n  return s[id++];\n}\nvoid eat(char c){\n  assert(s[id] == c);\n  id++;\n}\nint expr();\nint number(){\n  int res = 0;\n  while (left() && isdigit(peek())) {\n    res = res * 10 + pop() - '0';\n  }\n  return res;\n}\nint fact(){\n  int res;\n  if (isdigit(peek())) {\n    return res = number();\n  } else {\n    eat('(');\n    res = expr();\n    eat(')');\n    return res;\n  }\n}\nint term(){\n  int res = fact();\n  while (left() && (peek() == '*' || peek() == '/')) {\n    if (peek() == '*') {\n      eat('*');\n      res *= fact();\n    } else {\n      eat('/');\n      res /= fact();\n    }\n  }\n  return res;\n}\nint expr(){\n  int res = term();\n  while (left() && (peek() == '+' || peek() == '-')) {\n    if (peek() == '+') {\n      eat('+');\n      res += term();\n    } else {\n      eat('-');\n      res -= term();\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  REP(i,n){\n    id = 0;\n    cin >> s;\n    cout << expr() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nint number(const string &s, int &k);\nint fact(const string &s, int &k);\nint term(const string &s, int &k);\n\nint expr(const string &s, int &k){\n  int result = term(s,k);\n  while(k < s.size()-1){\n    if(s[k]=='+')return result + term(s,++k);\n    else return result - term(s,++k);\n  }\n}\n\nint term(const string &s, int &k){\n  int res = fact(s,k);\n  while(k<s.size()-1){\n    if(s[k]=='*')return res * fact(s,++k);\n    else if(s[k]=='/')return res / fact(s,++k);\n    else return res;\n  }\n}\n\nint fact(const string &s, int &k){\n  if(s[k]=='('){\n    int res = 0;    \n    res = expr(s,++k);\n    k++;\n    return res;\n  }\n  return number(s,k);\n}\n\nint number(const string &s, int &k){\n  int res = 0;\n  while(isdigit(s[k])){\n    res *= 10;\n    res += (int)(s[k++] - '0');\n  }\n  return res;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  while(n--){\n    string s;\n    cin >> s;\n    int k = 0;\n    cout << expr(s, k) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\n\nstring cal_mul (string str, int sym) {\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    if (str[0] = '-') sumL = -sumL;\n    while (str[sym+R] >= '0' && str[sym+R] <= '9') {\n        R++;\n    }\n    rep(i ,R-1) {\n        sumR += mul10(i, str[sym+R-i-1] - '0');\n    }\n    //dump(sumL);\n    //dump(sumR);\n    stringstream str_tmp;\n    if (str[0] = '-') rep(i, sym-L) str_tmp << str[i+1];\n    else rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length(); i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        while(true){\n            str = cal_mul(str, find_muldiv(str));\n            if ( prev == str ) break;\n            else prev = str;\n        }\n        while(true){\n            str = cal_mul(str, find_addsub(str));\n            if ( prev == str ) break;\n            else prev = str;\n        }\n        //?????????????????????\n        cout << str << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int Int;\ntypedef string::const_iterator Iter;\n\nInt eval(const string&);\nInt expr(Iter&);\nInt term(Iter&);\nInt factor(Iter&);\nInt number(Iter&);\n\nInt eval(const string &s){\n\tIter it = s.begin();\n\treturn expr(it);\n}\n\nInt expr(Iter &it){\n\tInt res = term(it);\n\twhile (true){\n\t\tif (*it == '+'){\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t}\n\t\telse if (*it == '-'){\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt term(Iter &it){\n\tInt res = factor(it);\n\twhile (true){\n\t\tif (*it == '*'){\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t}\n\t\telse if (*it == '/'){\n\t\t\t++it;\n\t\t\tres /= factor(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt factor(Iter &it){\n\tif (*it == '('){\n\t\t++it;\n\t\tInt res = expr(it);\n\t\t++it;\n\t\treturn res;\n\t}\n\telse return number(it);\n}\n\nInt number(Iter &it){\n\tInt res = 0;\n\twhile (isdigit(*it)){\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tcout << eval(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Smart Calculator\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\nusing namespace std;\nstring S;\nsize_t cur = 0;\nbool isdigit(char);\nint digit();\nint number();\nint term();\nint expression();\nint factor();\nint parse(){\n    return expression();\n}\n\nint main(){\n    int n;\n    cin >> n;\n    rep(i,n){\n        cur = 0;\n        cin >> S;\n        S.resize(S.size()-1);\n        cout << parse() << endl;\n    }\n}\n\nbool isdigit(char c){\n    return c >= '0' && c <= '9';\n}\nint digit(){\n    assert(isdigit(S[cur]));\n    int n = S[cur] - '0';\n    cur = cur + 1;\n    return n;\n}\nint number(){\n    int n = digit();\n    while(cur<S.size()&&isdigit(S[cur])){\n        n = n*10+digit();\n    }\n    return n;\n}\n\nint expression(){\n    int mult = 1;\n    if(S[cur]=='-'){\n        mult = -1;\n        cur++;\n    }\n    int sum = term()*mult;\n    while(cur < S.size()&&(S[cur]=='+'||S[cur]=='-')){\n        char op = S[cur];\n        cur++;\n        if(op == '+'){\n            sum += term();\n        }else{\n            sum -= term();\n        }\n    }\n    return sum;\n}\nint term(){\n    int ret = factor();\n    while(cur < S.size() &&( S[cur]=='*'||S[cur]=='/')){\n        char op = S[cur];\n        cur++;\n        if(op == '*'){\n            ret *= factor();\n        }else{\n            ret /= factor();\n        }\n    }\n    return ret;\n}\nint factor(){\n    if(S[cur]!='(')\n        return number();\n    cur += 1;\n    int n = expression();\n    assert(S[cur]==')');\n    cur++;\n    return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring S;\n\nint expr(int& p);\nint term(int& p);\nint factor(int& p);\nint number(int& p);\n\nint expr(int& p) {\n    int v1 = term(p); \n    while(S[p] == '+' || S[p] == '-') {\n        char op = S[p];\n        p++;\n        int v2 = term(p); \n        if(op == '+') {\n            v1 += v2;\n        } else {\n            v1 -= v2;\n        }\n    }\n    return v1;\n}\n\nint term(int& p) {\n    int v1 = factor(p);\n    while(S[p] == '*' || S[p] == '/') {\n        char op = S[p];\n        p++;\n        int v2 = factor(p);\n        if(op == '*') {\n            v1 *= v2;\n        } else {\n            v1 /= v2;\n        }\n    }\n    return v1;\n}\n\nint factor(int& p) {\n    if(isdigit(S[p])) {\n        return number(p);\n    }\n\n    p++;\n    int res = expr(p);\n    p++;\n    return res;\n}\n\nint number(int& p) {\n    int res = 0;\n    while(isdigit(S[p])) {\n        res *= 10;\n        res += S[p] - '0';\n        ++p;\n    }\n    return res;\n}\n\n\nint main() {\n    int n;\n    cin >> n;\n    for(int i=0; i<n; ++i) {\n        cin >> S;\n        int p = 0;\n        cout << expr(p) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <utility>\n#include <functional>\n#include <stack>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0');return m?-n:n;} //&&c<='9'\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nstruct calc {\n\tstack<int> s;\n\tchar c;\n\n\tcalc() {\n\t\tc = gcu();\n\t}\n\tbool consume(char e) {\n\t\tif (c != e)\n\t\t\treturn false;\n\t\telse {\n\t\t\tc = gcu();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tvoid eval(function<int(int, int)> f) {\n\t\tint b = s.top(); s.pop();\n\t\tint a = s.top(); s.pop();\n\t\ts.push(f(a, b));\n\t}\n\n\tvoid number() {\n\t\tif (isdigit(c)) {\n\t\t\tint d;\n\t\t\tungetc(c, stdin);\n\t\t\tscanf(\"%d\", &d);\n\t\t\ts.push(d);\n\t\t\tc = gcu();\n\t\t} else {\n\t\t\tfprintf(stderr,\"ERROR: expected number\\n, but got %c\\n\", c);\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tvoid mul() {\n\t\tterm();\n\t\tfor (;;)\n\t\t\tif (consume('*')) {\n\t\t\t\tterm();\n\t\t\t\teval([](int a, int b) {return a * b;});\n\t\t\t} else if (consume('/')) {\n\t\t\t\tterm();\n\t\t\t\teval([](int a, int b) {return a / b;});\n\t\t\t} else\n\t\t\t\treturn;\n\t}\n\n\tvoid add() {\n\t\tmul();\n\t\tfor (;;)\n\t\t\tif (consume('+')) {\n\t\t\t\tmul();\n\t\t\t\teval([](int a, int b) {return a + b;});\n\t\t\t} else if (consume('-')) {\n\t\t\t\tmul();\n\t\t\t\teval([](int a, int b) {return a - b;});\n\t\t\t} else\n\t\t\t\treturn;\n\t}\n\n\tvoid term() {\n\t\tif (consume('(')) {\n\t\t\tadd();\n\t\t\tconsume(')');\n\t\t\treturn;\n\t\t}\n\t\tnumber();\n\t}\n\n\n\tint exec() {\n\t\tadd();\n\t\tif (consume('=')) {\n\t\t\treturn s.top();\n\t\t} else {\n\t\t\tfprintf(stderr,\"ERROR: expected =, but got %c\\n\", c);\n\t\t\texit(0);\n\t\t}\n\t}\n};\n\nint main() {\n\tfor (int n = in(); n; n--) {\n\t\tcalc c = calc();\n\t\toutl(c.exec());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nint expression();\nint term();\nint factor();\nint number();\n\nint now;\nstring s;\n\nint expression(){\n\tint res=term();\n\t\twhile(true){\n\t\tif(s[now]=='+')now++,res+=term();\n\t\telse if(s[now]=='-')now++,res-=term();\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint term(){\n\tint res=factor();\n\twhile(true){\n\t\tif(s[now]=='(')res+=factor();\n\t\telse if(s[now]=='*')now++,res*=factor();\n\t\telse if(s[now]=='/')now++,res/=factor();\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint factor(){\n\tint res=0;\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tres=expression();\n\t\tnow++;\n\t}\n\telse return number();\n\t\n\treturn res;\n}\n\nint number(){\n\tint res=0;\n\twhile('0'<=s[now] && s[now]<='9'){\n\t\tres*=10;\n\t\tres+=s[now++]-'0';\n\t}\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\t\n\twhile(n--){\n\t\tcin >> s;\n\t\tnow=0;\n\t\tcout << expression() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n        f=1;\n        break;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  int n;\n  cin>>n;\n  while(n--){\n    string s;\n    int p=0;\n    cin>>s;s.pop_back();\n    cout<<expression(s,p)<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2017/11/20\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id=0109\n*/\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\nstring S;\nint cur;\nint expression();\nchar readerchar()\n{\n    assert(cur < S.size());\n    char ret = S[cur];\n    cur += 1;\n    return ret;\n}\nchar peek()\n{\n    assert(cur < S.size());\n    return S[cur];\n}\nint digit()\n{\n    assert(isdigit(peek()));\n    int n = readerchar() - '0';\n    return n;\n}\nint number()\n{\n    int n=digit();\n    while(cur<S.size() && isdigit(peek()))\n        n = n*10 + digit();\n    return n;\n}\nint factor()\n{\n    if(peek()!='(')\n        return number();\n    cur += 1;\n    int n = expression();\n    assert(peek() == ')');\n    cur += 1;\n    return n;\n}\nint term()\n{\n    int a = factor();\n    while(cur < S.size() && (peek()=='*' || peek()=='/'))\n    {\n        char op = readerchar();\n        int b = factor();\n        if(op == '*')\n            a *= b;\n        else    a /= b;\n    }\n    return a;\n}\nint expression()\n{\n    int a = term();\n    while(cur < S.size() && (peek()=='+' || peek()=='-'))\n    {\n        char op = readerchar();\n        int b = term();\n        if(op == '+')\n            a += b;\n        else\n            a -= b;\n    }\n    return a;\n}\n\n\nint main()\n{\n    int n,i;\n    cin >> n;\n    for(i=0;i<n;i++)\n    {\n        cur = 0;\n        cin >> S;\n        S.resize(S.size()-1);\n        cout << expression() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n      \n      // else if(str[i] == '+' || str[i] == '-'){\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = tmp;\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n      // else{\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = string(tmp);\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  //  getline(cin,s);\n  //  n = atoi(s.c_str());\n  cin >> n;\n    //  scanf(\"%d\\n\",&n);\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\n\n/*\n  <expr>   ::= <term> [ ('+'|'-') <term> ]*\n  <term>   ::= <factor> [ ('*'|'/') <factor> ]*\n  <factor> ::= <number> | '(' <expr> ')'\n  <number> :== 1?????\\????????°???\n*/\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while (s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if (op == '+')\n      val += val2;\n    else\n      val -= val2;\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while (s[i] == '*' || s[i] == '/') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*')\n      val *= val2;\n    else\n      val /= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n  int val;\n  if (s[i] != '(') {\n    val = number(s, i);\n  } else {\n    i++;\n    val = expr(s, i);\n    i++;\n  }\n  return val;\n}\n\nint number(string& s, int& i) {\n  int val = 0;\n  while(isdigit(s[i])) {\n    val = val*10 + (s[i] - '0');\n    i++;\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for (int j=0; j<n; j++) {\n    int i = 0;\n    string str;\n    cin >> str;\n    cout << expr(str, i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nll stol(string s){\n  stringstream ss(s);\n  ll n;\n  ss >> n;\n  return n;\n}\n\nll parse(int l, int r){\n  int n = 0,i;\n  for(i=r-1;i>=l;i--){\n    if(s[i] == ‘)‘)n++;  if(s[i] == ‘(’)n--;\n    if(!n){\n      if(s[i] == ‘+’)return parse(l,i)+parse(i+1,r);\n      if(s[i] == ‘-’)return parse(l,i)-parse(i+1,r);\n    }\n  }\n  for(i=r-1;i>=l;i--){\n    if(s[i] == ‘)‘)n++;  if(s[i] == ‘(’)n--;\n    if(!n){\n      if(s[i] == ‘*’)return parse(l,i)*parse(i+1,r);\n      if(s[i] == ‘/’)return parse(l,i)/parse(i+1,r);\n    }\n  }\n\n  if(s[l] == ‘(‘ && s[r-1] == ‘)’)return parse(l+1,r-1);\n  return stol(s.substr(l,r-l));\n}\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 1;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\n\nstring cal_mul (string str, int sym) {\n    //cout << str << endl;\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    if (str[0] == '-') sumL = -sumL; \n    while (str[sym+R] >= '0' && str[sym+R] <= '9') {\n        R++;\n    }\n    rep(i ,R-1) {\n        sumR += mul10(i, str[sym+R-i-1] - '0');\n    }\n    //dump(sumL);\n    //dump(sumR);\n    stringstream str_tmp;\n    if (str[0] == '-') rep(i, sym-L) str_tmp << str[i+1];\n    else rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length(); i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            //cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        str = cal_all(str);\n        //?????????????????????\n        cout << str << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\nint p;\n\nint exp(string str);\nint term(string str);\nint fact(string str);\n\nint exp(string str)\n{\n\tint val = term(str);\n\twhile(str[p] == '+' || str[p] == '-'){\n\t\tif(str[p++] == '+'){\n\t\t\tval += term(str);\n\t\t} else {\n\t\t\tval -= term(str);\n\t\t}\n\t}\n\t\n\treturn val;\n}\n\nint term(string str)\n{\n\tint val = fact(str);\n\twhile(str[p] == '*' || str[p] == '/'){\n\t\tif(str[p++] == '*'){\n\t\t\tval *= fact(str);\n\t\t} else {\n\t\t\tval *= fact(str);\n\t\t}\n\t}\n\t\n\treturn val;\n}\n\nint fact(string str)\n{\n\tint val = 0;\n\tif(str[p] == '('){\n\t\tp++;\n\t\tval = exp(str);\n\t\tp++;\n\t} else {\n\t\tstring s = \"\";\n\t\twhile('0' <= str[p] && str[p] <= '9'){\n\t\t\ts += str[p++];\n\t\t}\n\t\tval = atoi(s.c_str());\n\t}\n\t\n\treturn val;\n}\n\nint main()\n{\n\tint n;\n\tstring str;\n\t\n\twhile(cin >> n && n){\n\t\twhile(n--){\n\t\t\tcin >> str;\n\t\t\tp = 0;\n\t\t\tcout << exp(str) << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cctype>\n#include <iostream>\nusing namespace std;\nclass ParseError {};\n\nint exp(char* & p);\n\nint num(char* & p) {\n    int ret = 0;\n    while (isdigit(*p)) {\n        ret *= 10;\n        ret += *p - '0';\n        p++;\n    }\n    return ret;\n}\n\nint fac(char* & p) {\n    int ret = 0;\n    if (*p == '(') {\n        p++;\n        ret += exp(p);\n        p++;\n    } else {\n        ret += num(p);\n    }\n    return ret;\n}\n\nint term(char* & p) {\n    int ret = fac(p);\n    while(1) {\n        if (*p == '*') {\n            p++;\n            ret *= fac(p);\n        } else if (*p == '/') {\n            p++;\n            ret /= fac(p);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint exp(char* & p) {\n    int ret = term(p);\n    while(1) {\n        if (*p == '+') {\n            p++;\n            ret += term(p);\n        } else if (*p == '-') {\n            p++;\n            ret -= term(p);\n        } else break;\n    }\n    return ret;\n}\n\nint eval(const string & s){\n    char* p = (char*)s.c_str();\n    return exp(p);\n}\n\nint eval(const char* str){\n    char* p = (char*)str;\n    return exp(p);\n}\n\nusing namespace std;\n\nint main(){\n    char str[128];\n    while(gets(str))\n        cout << eval(str) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring::const_iterator it;\n\nint number();\nint factor();\nint term();\nint expression();\n\nint number()\n{\n    int ret = 0;\n    \n    while(isdigit(*it)) {\n        ret *= 10;\n        ret += *it - '0';\n        it++;\n    }\n    \n    return ret;\n}\n\nint factor()\n{\n    int ret;\n\n    if (*it == '(') {\n        it++;\n        ret = expression();\n        it++;\n    } else {\n        return number();\n    }\n    \n    return ret;\n}\n\nint term()\n{\n    int ret = factor();\n    \n    for (;;) {\n        \n        if (*it == '*') {\n            it++;\n            ret *= factor();\n        } else if (*it == '/') {\n            it++;\n            ret /= factor();\n        } else {\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nint expression()\n{\n    int ret = term();\n    \n    for (;;) {\n        \n        if (*it == '+') {\n            it++;\n            ret += term();\n        } else if (*it == '-') {\n            it++;\n            ret -= term();\n        } else {\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nint main()\n{\n    int data_num;\n\n    cin >> data_num;\n    cin.ignore();\n    \n    for (int i = 0; i < data_num; ++i) {\n        string calc_formula;\n\n        cin >> calc_formula;\n\n        it = calc_formula.begin();\n\n        cout << expression() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n\t/*const*/ string s;\n\tstack<int> num;\n\tstack<int> mar;\n\tint n1, n2;\n\tcin >> s;\n\tfor ( int i = 0; i < 100; i++ ) {\n\t\tif ( s.substr( i, 1 ) == \"+\" ) {\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t\tmar.push(0);\n\t\t} else if ( s.substr( i, 1 ) == \"-\" ) {\n\t\t\tmar.push(1);\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t} else if ( s.substr( i, 1 ) == \"*\" ) mar.push(2);\n\t\telse if ( s.substr( i, 1 ) == \"/\" ) mar.push(3);\n\t\telse if ( s.substr( i, 1 ) == \"(\" ) mar.push(4);\n\t\telse if ( s.substr( i, 1 ) == \")\" ) {\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t\t\tmar.pop();\n\t\t} else if ( s.substr( i, 1 ) == \"=\" ) {\n\t\t\tif ( mar.top() == 0 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 + n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 1 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 - n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t\tcout << num.top();\n\t\t\tbreak;\n\t\t} else {\n\t\t\tn2 = atoi( s.c_str() );\n\t\t\tif ( mar.top() == 2 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 * n2 );\n\t\t\t\tmar.pop();\n\t\t\t} else if ( mar.top() == 3 ) {\n\t\t\t\tn1 = num.top();\n\t\t\t\tnum.pop();\n\t\t\t\tnum.push( n1 / n2 );\n\t\t\t\tmar.pop();\n\t\t\t}\n\t\t}\n\t}\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint p;\nstring S;\n\nint num();\nint factor();\nint term();\nint calc();\n\nint num(){\n\tint n = 0;\n\twhile(p<S.size()){\n\t\tif(isdigit(S[p])) n = n*10+S[p]-'0';\n\t\telse break;\n\t\tp++;\n\t}\n\treturn n;\n}\n\nint factor(){\n\tint n;\n\tif(S[p]=='('){\n\t\tp++; n = calc(); p++;\n\t}\n\telse n = num();\n\treturn n;\n}\n\nint term(){;\n\tint n = factor();\n\twhile(p<S.size()){\n\t\tif(S[p]=='*') p++, n *= factor();\n\t\telse if(S[p]=='/') p++, n /= factor();\n\t\telse break;\n\t}\n\treturn n;\n}\n\nint calc(){\n\tint n = term();\n\twhile(p<S.size()){\n\t\tif(S[p]=='+') p++, n += term();\n\t\telse if(S[p]=='-') p++, n -= term();\n\t\telse break;\n\t}\n\treturn n;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>S; S.pop_back();\n\t\tp = 0;\n\t\tprintf(\"%d\\n\",calc());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\tif(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse{\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cstdlib>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '*')\n\t\treturn 1;\n\tif(a == '/')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<long long> & num_stack, stack<char> & op_stack) {\n\tlong long a, b;\n\tlong long c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nlong long clac(string str) {\n\tstack<long long> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tlong long tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t}\n\n\tif(op_stack.size() != 1)\n\t\texit(1);\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(string delim,string str){\n\tvector<string> res;\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ) res.push_back(str.substr(i,j-1));\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstring calc(vector<string> v){\n\tstack<string> stk;\n\tfor(int i=0;i<v.size();i++){\n\t\tll num1;\n\t\tll num2;\n\t\tchar buf[256];\n\t\tstring res;\n\t\tif(v[i]==\"-\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2-num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2+num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"*\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2*num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"/\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2/num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse{\n\t\t\tstk.push(v[i]);\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nvector<string> rvs_polish(string str){\n\tstack<string> stk;\n\tvector<string> v;\n\n\tstring tmp=\"\";\n\tvector<string> res;\n\tif(str[0]=='-'){\n\t\tstr='0'+str;\n\t}\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='*'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"*\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='/'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"/\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]=='*' || str[i-1]=='/')){\n\t\t\ttmp+='-';\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]!='*' && str[i-1]!='/')){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"-\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='+'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"+\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='='){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"=\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse{\n\t\t\ttmp+=str.substr(i,1);\n\t\t}\n\t}\n\n\tv.push_back(tmp);\n\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"*\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\"){\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"/\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"/\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\" || opr == \"*\"){\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"-\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres.push_back(v[i]);\n\t\t}\n\t}\n\n\twhile(!stk.empty()){\n\t\tres.push_back(stk.top());\n\t\tstk.pop();\n\t}\n\n\treturn res;\n}\n\nvoid dfs(string str){\n\tstack<P> stk;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='(') {stk.push(P('(',i));}\n\t\telse if(str[i]==')') {\n\t\t\tchar sym = stk.top().first;\n\t\t\tif(sym != '(') continue;\n\n\t\t\tint pos = stk.top().second;\n\t\t\tstk.pop();\n\n\t\t\tif(str.substr(pos+1,(i-1)-(pos+1)+1).find('(') == string::npos\n\t\t\t\t&& str.substr(pos+1,(i-1)-(pos+1)+1).find(')') == string::npos){\n\t\t\t\t\tvector<string> pol = rvs_polish(str.substr(pos+1,(i-1)-(pos+1)+1));\n\t\t\t\t\tstring num = calc(pol);\n\t\t\t\t\tstr.replace(pos,i-pos+1,num);\n\t\t\t\t\t//cout << str << endl;\n\t\t\t\t\twhile(!stk.empty()) stk.pop();\n\t\t\t\t\ti=-1;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<string> ans = rvs_polish(str);\n\n\tcout << calc(ans) << endl;\n}\n\nint main(){\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tint n;\n\t\tsscanf(str.c_str(),\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\t\t\tdfs(str.substr(0,str.size()-1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint n;\nstring str;\n\nint factor(State &begin);\nint number(State &begin);\nint term(State &begin);\nint expressin(State &begin);\n\nint factor(State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nll ex1(string input,ll& i);\nll ex2(string input,ll& i);\nll ex3(string input,ll& i);\nll exnum(string input,ll& i);\nll ex1(string input,ll& i){\n  ll a=0;;\n  a=+ex2(input,i);\n  while(true){\n    if(input[i]=='+')\n      a= a+ex2(input,++i);\n    else if(input[i]=='-')\n      a=a-ex2(input,++i);\n    else return a;\n  }\n}\n\nll ex2(string input,ll& i){\n  ll a=ex3(input,i);\n  while(true){\n    if(input[i]=='*')\n      a*=ex3(input,++i);\n    else if(input[i]=='/')\n      a/=ex3(input,++i);\n    else return a;\n  }\n}\nll ex3(string input,ll& i){\n  ll a;\n  if(input[i]=='('){\n    a=ex1(input,++i);\n    i++;\n  }\n  else a=exnum(input,i);\n  return a;\n}\nll exnum(string input,ll &i){\n  ll a=0;\n  while(isdigit(input[i])){\n    //  cout<<\"i:\"<<i<<endl;\n    a*=10;\n    a+=input[i]-'0';\n    i++;\n  }\n  //  cout<<\"a:\"<<a<<endl;\n  return a;\n}\n\nint main(){\n  ll n;\n  cin>>n;\n  repn(k,n){\n    ll i=0;\n    string input;\n    cin>>input;\n    cout<<ex1(input,i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '*')\n\t\treturn 1;\n\tif(a == '/')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<int> & num_stack, stack<char> & op_stack) {\n\tint a, b;\n\tint c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nint clac(string str) {\n\tstack<int> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tint tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t\telse if(str[i] == '-') {\n\t\t\tint tmp = 0;\n\t\t\ti++;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp * -1);\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority('+')) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push('+');\n\t\t}\n\t}\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef string::const_iterator State;\n\nint ctoi(const char &c)\n{\n\treturn c - '0';\n}\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint expression(State &itr)\n{\n\tint ret=term(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '+')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret + term(itr);\n\t\t}\n\t\telse if (*itr == '-')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret - term(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint term(State &itr)\n{\n\tint ret=number(itr);\n\n\twhile (true)\n\t{\n\t\tif (*itr == '*')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret*factor(itr);\n\t\t}\n\t\telse if (*itr == '/')\n\t\t{\n\t\t\titr++;\n\t\t\tret = ret / factor(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor(State &itr)\n{\n\tint ret;\n\n\tif (*itr == '(')\n\t{\n\t\titr++;\n\t\tret = expression(itr);\n\t\titr++;\n\t}\n\telse\n\t{\n\t\tret = number(itr);\n\t}\n\n\treturn ret;\n}\n\nint number(State &itr)\n{\n\tint ret = 0;\n\n\twhile (isdigit(*itr))\n\t{\n\t\tret *= 10;\n\t\tret += ctoi(*itr);\n\t\titr++;\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tREP(i, n)\n\t{\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tState begin = str.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint fact();\nstring s;\nint id;\n\nint main(void){\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> s;\n    id = 0;\n    cout << exp() << endl;\n  }\n}\n\n\nint exp(){\n  int res = term();\n  while(1){\n    char c = s[id];\n    id++;\n    if(c == '+') res += term();\n    else if(c == '-') res -= term();\n    else break;\n  }\n  return res;\n}\n\nint term(){\n  int res = fact();\n  while(1){\n    char c = s[id];\n    id++;\n    if(c == '*') res *= fact();\n    else if(c=='/') res /= fact();\n    else break;\n  }\n  id--;\n  return res;\n}\n\nint fact(){\n  char c = s[id];\n  id++;\n  if(c == '(') return exp();\n  if(c == '+') return fact();\n  if(c == '-') return -fact();\n\n  int res = c - '0';\n  while(1){\n    c = s[id];\n    id++;\n    if('0' <= c && c <= '9'){\n      res *= 10;\n      res += c - '0';\n    }\n    else break;\n  }\n  id--;\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint roc = 0;\nstring s;\nint insu();\nint kou();\nint shiki();\n\nint insu() {\n\tif(s[roc] >= '0' && s[roc] <= '9') {\n\t\tint j = roc;\n\t\twhile(roc < s.size() && s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\treturn stoi(s.substr(j, roc - j));\n\t} else {\n\t\t++roc;\n\t\tint res = shiki();\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint kou() {\n\tint res = insu();\n\twhile (s[roc] == '*' || s[roc] == '/') {\n\t\tif(s[roc] == '*') res *= insu();\n\t\telse res /= insu();\n\t}\n\treturn res;\n}\n\nint shiki() {\n\tint res = kou();\n\twhile (s[roc] == '+' || s[roc] == '-') {\n\t\tif(s[roc] == '+') res += insu();\n\t\telse res -= insu();\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n;\n\tcin>>n;\n\tREP(roop, n) {\n\t\troc = 0;\n\t\tcin>>s;\n\t\ts.pop_back();\n\t\tcout<<shiki()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tconsume(begin,'(');\n\t\tint ret = expression(begin);\n\t\tconsume(begin,')');\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (int i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint p;\n\nint exp();\nint factor();\nint term();\n\nint factor() {\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n\n  if (str[p] == '('){\n    p++;\n    num = exp();\n  }\n  if(str[p] == ')')  p++;\n\n   \n  return num;\n}\n\nint term(){\n int val = factor();\n  while(str[p] == '*' || str[p] == '/') {\n    if(str[p] == '*') {\n      p++;\n      val *= factor();\n    } else if(str[p] == '/'){\n      p++;\n      val /= factor();\n    }\n  }\n\n  return val;\n}\n \nint exp() {\n  int val = term();\n  while(str[p] == '+' || str[p] == '-') {\n    if(str[p] == '+') {\n      p++;\n      val += term();\n    } else if(str[p] == '-'){\n      p++;\n      val -= term();\n    }\n  }\n\n  return val;\n}\n\nint main() {\n  int n;\n\n  cin >> n;\n  \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define for(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\nstatic const double eps = 1e-9;\n\ntypedef pair<int, int> p;\ntypedef long long ll;\n\ntemplate<class t>\ninline t sq(t a){return a*a;}\n\nint expr();\nint term();\nint num();\n\n//式 ::= 項 | 項+式 | 項-式\n//項 ::= (式) | 因子*項 | 因子/項\n//因子 ::= 数字\nstring s;\nint ptr;\nint expr(){\n\tint x = term();\n\tif(s[ptr] == '+'){\n\t\tptr++;\n\t\tx += expr();\n\t}else if(s[ptr] == '-'){\n\t\tptr++;\n\t\tx -= expr();\n\t}\n\treturn x;\n}\n\nint term(){\n\tint x;\n\tif(s[ptr] == '('){\n\t\tptr++;\n\t\tx = expr();\n\t\tptr++;\n\t}else{\n\t\tx = num();\n\t\tif(s[ptr] == '*'){\n\t\t\tptr++;\n\t\t\tx *= term();\n\t\t}\n\t\telse if(s[ptr] == '/'){\n\t\t\tptr++;\n\t\t\tx/= term();\n\t\t}\n\t}\n\treturn x;\n}\n\nint num(){\n\tint x = 0;\n\tint y = 1;\n\tif(s[ptr] == '-'){\n\t\ty = -1;\n\t\tptr++;\n\t}\n\twhile('0' <= s[ptr] && s[ptr] <= '9'){\n\t\tx *= 10;\n\t\tx += (s[ptr]-'0');\n\t\tptr++;\n\t}\n\treturn x*y;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\tptr = 0;\n\t\tcout << expr() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<cassert>\nusing namespace std;\n\nstring s;\nint cur;\n\nint factor();\n\nchar readchar(){\n  assert(cur <s.size());\n  char ret =s[cur];\n  cur += 1;\n  return ret;\n}\n\nchar peak(){\n  assert(cur<s.size());\n  return s[cur];\n}\n\nint digit(){\n  assert(isdigit(peak()));\n  int n = readchar() - '0';\n  return n;\n}\n\nint number(){\n  int n= digit();\n  while(cur<s.size()&&isdigit(peak()))\n    n=n*10+digit();\n  return n;\n}\n\nint term(){\n  int a = factor();\n  while((cur <s.size()) && (peak()=='*' || peak() == '/')){\n    char op = readchar();\n    int b = factor();\n    if(op=='*') a*=b; else a/=b;\n  }\n\n  return a;\n}\n    \nint expression(){\n  int a=term();\n  while((cur<s.size())&& (peak()=='+' || peak() == '-')){\n    char op = readchar();\n    int b= term();\n    if(op == '+') a+=b;else a-=b;\n  }\n  return a;\n}\n\nint factor(){\n  if(peak() != '(') return number();\n  cur += 1;\n  int n = expression();\n  assert(peak() == ')');\n  cur+=1;\n  return n;\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cur=0;\n    cin>>s;\n    s.resize(s.size()-1);\n    cout<<expression() <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\n#define all(v) v.begin(), v.end()\n#define inputv(v, n)                                                           \\\n    vl v;                                                                      \\\n    rep(i, n) {                                                                \\\n        ll x;                                                                  \\\n        cin >> x;                                                              \\\n        v.push_back(x);                                                        \\\n    }\nbool chmin(ll& a, ll  b) { if (b < a) { a = b; return 1; } return 0; }\nbool chmax(ll& a, ll b) { if (b > a) { a = b; return 1; } return 0; }\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nconst ll MAX_N = 500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\ntypedef string::const_iterator State;\nint expression(State& begin);\nint factor(State& begin);\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State& begin);\n// 数字の列をパースして、その数を返す。\nint number(State& begin);\nint number(State& begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\nint factor(State& begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす。\n        int ret = expression(begin);\n        begin++; // ')'を飛ばす。\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\nint term(State& begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\nint expression(State& begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else{\n            break;\n        }\n        \n    }\n\n    return ret;\n}\nint main() {\n\tcin>>n;\n\trep(i,n){\n    string S;\n    cin >> S;\n    S=S.substr(0,S.length()-1);\n    State s=S.begin();\n    cout << expression(s) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\nsize_t cur;\nstring s;\n\ndouble expression();\n\nint digit(){\n  assert(cur < s.size());\n  return s[cur++] - '0';\n}\ndouble number(){\n  double n = 0.0;\n  assert(cur < s.size());\n  while(cur < s.size() && isdigit(s[cur])){\n    n = n * 10 + digit();\n  }\n  return n;\n}\n\ndouble factor(){\n  assert(cur < s.size());\n  if(isdigit(s[cur])){\n    return number();\n  }else{\n    cur++;\n    double a = expression();\n    assert(s[cur] == ')');\n    cur++;\n    return a;\n  }\n}\n\ndouble term(){\n  assert(cur < s.size());\n  double a = factor();\n    while(cur < s.size() && (s[cur] == '*' || s[cur] == '/')){\n    char op = s[cur++];\n    double b = factor();\n    if(op == '*') a *= b; else a /= b;\n  }\n  return a;\n}\n\ndouble expression(){\n  assert(cur < s.size());\n  double a = term();\n  while(cur < s.size() && (s[cur] == '-' || s[cur] == '+')){\n    char op = s[cur++];\n    double b = term();\n    if(op == '-') a -= b; else a += b;\n  }\n  return a;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cur = 0;\n    cin >> s;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint solve(string& s, int& i)\n{\n    int a = 0;\n    int b = 0;\n    char prev = '+';\n    for(;;){\n        int x = 0;\n        if(s[i] == '('){\n            ++ i;\n            x += solve(s, i);\n        }else{\n            while('0' <= s[i] && s[i] <= '9'){\n                x *= 10;\n                x += s[i] - '0';\n                ++ i;\n            }\n        }\n\n        if(prev == '+'){\n            a += b;\n            b = x;\n        }else if(prev == '-'){\n            a += b;\n            b = -x;\n        }else if(prev == '*'){\n            b *= x;\n        }else{\n            b /= x;\n        }\n\n        if(s[i] == ')' || s[i] == '=')\n            break;\n\n        prev = s[i];\n        ++ i;\n    }\n\n    return a + b;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        string s;\n        cin >> s;\n        int i = 0;\n        cout << solve(s, i) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstruct State{\n  int result,backpos;\n  State(int a,int b){\n    result=a;\n    backpos=b;\n  }\n};\n\nbool is_numchar(char c){\n  if('1'<=c&&c<='9') return true;\n  if(c=='0') return true;\n  return false;\n}\n\nint strtoint(std::string s){\n  int result=0;\n  for(int i=0;i<s.size();i++){\n    result+=(s[i]-'0')*(int)std::pow(10,s.size()-1-i);\n  }\n  return result;\n}\n\n\n\nState expr(const std::string& s,int frontpos);\nState factor(const std::string& s,int frontpos);\nState term(const std::string& s,int frontpos);\nState number(const std::string& s,int frontpos);\n\nState expr(const std::string& s,int frontpos){\n  State state=term(s,frontpos);\n  while(1){\n    int op_pos=state.backpos+1;\n    if(op_pos<s.size()&&s[op_pos]=='+'){\n      State new_state=term(s,op_pos+1);\n      state.result+=new_state.result;\n      state.backpos=new_state.backpos;\n    }else if(op_pos<s.size()&&s[op_pos]=='-') {\n      State new_state = term(s, op_pos + 1);\n      state.result -= new_state.result;\n      state.backpos = new_state.backpos;\n    }else break;\n  }\n  return state;\n}\n\nState term(const std::string& s,int frontpos){\n  State state=factor(s,frontpos);\n  while(1){\n    int op_pos=state.backpos+1;\n    if(op_pos<s.size()&&s[op_pos]=='*'){\n      State new_state=factor(s,op_pos+1);\n      state.result*=new_state.result;\n      state.backpos=new_state.backpos;\n    }else if(op_pos<s.size()&&s[op_pos]=='/') {\n      State new_state = factor(s, op_pos + 1);\n      state.result /= new_state.result;\n      state.backpos = new_state.backpos;\n    }else break;\n  }\n  return state;\n}\n\nState factor(const std::string& s,int frontpos){\n  if(s[frontpos]=='('){\n    State result=expr(s,frontpos+1);\n    result.backpos++;// ')'を読み飛ばす\n    return result;\n  }else{\n    return number(s,frontpos);\n  }\n}\n\nState number(const std::string& s,int frontpos){\n  int result;\n  int backpos=frontpos;\n  std::string numstr;\n  for(int i=frontpos;i<s.size();i++){\n    if(is_numchar(s[i])){\n      numstr+=s[i];\n      backpos++;\n    }else {\n      backpos--;\n      break;\n    }\n  }\n  result=strtoint(numstr);\n  return State(result,backpos);\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    std::string s;\n    cin>>s;\n    std::string throw_s;\n    for(int j=0;j<s.size()-1;j++){\n      throw_s+=s[j];\n    }\n    cout<<expr(throw_s,0).result<<endl;\n\n  }\n\n\n\n\n\n  \n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n\n  void init(){ pos=0;len=s.size();}\n\n  int head2Num(){\n    bool f=false;\n    if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    int res;\n    if(s[pos]=='('){\n      pos++;\n      res = getAns();\n    }else if(s[pos]=='-'||isNum(s[pos])){\n      res=head2Num();\n    }else{\n      //cout<<s[pos]<<endl;\n      assert(0);\n    }\n    \n    if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }else{\n      return res;\n    }\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else assert(0);\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <cctype>\n\nusing namespace std;\n\nusing State = string::const_iterator;\n\nint number(State &begin);\nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else{\n        return number(begin);\n    }\n}\n\nint expression(State &begin){\n    int ret = term(begin);\n\n    while(true){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint term(State &begin){\n    int ret = factor(begin);\n\n    while(true){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }\n        else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n\n    int N;\n    cin >> N;\n    string s;\n    for(int i = 0; i < N; i++){\n        cin >> s;\n        State begin = s.begin();\n        cout << expression(begin) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n  //  string hand;                                                                   \n  //  string side;                                                                   \n\n  vector<string> hand;\n  vector<string> side;\n\n  // ÊàtO                                                                    \n  bool isInside = false;\n\n  for(int i = 0; i < str.size(); i++){\n    //    cout << str[i] << endl;                                                    \n    //    cout << hand << endl;                                                      \n    //    cout << side << endl;                                                      \n\n    if(str[i] >= '0' && str[i] <= '9'){\n      //      cout << str[i] << endl;                                                \n      string num;\n      while(i < str.size()){\n        if(str[i] < '0' || str[i] > '9'){\n          //      hand += str[i];                                                    \n  \t  break;\n        }\n        num += str[i];\n        i++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      isInside = true;\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n\n    else if(isInside && str[i] == ')'){\n      // EÊÜÅZqðêÂ¸Âè³Éß·                                        \n      //      cout << side << endl;                                                  \n      for(int j = side.size()-1 ; ;j--){\n        if(side[j] == \"(\"){\n          if(j != 0){\n            vector<string> tmp;\n            for(int k = 0; k < j; k++){\n              tmp.push_back(side[k]);\n            }\n            side = tmp;\n          }\n          else\n  \t    side.clear();\n          break;\n        }\n        else{\n          string tmp = side[j];\n          hand.push_back(tmp);\n        }\n      }\n      isInside = false;\n    }\n\n    else{\n      if(side.size() == 0){\n        string tmp;\n        tmp += str[i];\n        side.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n        if(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n          hand.push_back(side[side.size()-1]);\n          string tmp;\n          tmp += str[i];\n          side[side.size()-1] = tmp;\n        }\n  \telse{\n          string tmp;\n          tmp += str[i];\n          side.push_back(tmp);\n\t}\n      }\n      else{\n        if(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n          hand.push_back(side[side.size()-1]);\n          string tmp;\n          tmp += str[i];\n          side[side.size()-1] = string(tmp);\n        }\n        else{\n          string tmp;\n          tmp += str[i];\n          side.push_back(tmp);\n        }\n      }\n    }\n\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n\n  return hand;\n}\n\nint calc(vector<string> str){\n\n  //  cout << str << endl;                                                           \n  //  string stack;                                                                  \n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n        st.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n        st.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n        st.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n        st.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n = 1;\n  //  cin >> n;                                                                      \n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n  char h;\n  //  cin >> h;                                                                      \n\n  for(int i = 0; i < n; i++){\n    string str;\n    getline(cin,str);\n    str = str.substr(0,str.size()-1);\n    vector<string> vec = toReversePorland(str);\n    cout << calc(toReversePorland(str)) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint expr(State& begin);\nint term(State& begin);\nint number(State& begin);\nint fact(State& begin);\n\nint number(State& begin){\n    int res = 0;\n    while(isdigit(*begin)){\n        res *= 10;\n        res += *begin - '0';\n        begin++;\n    }\n    return res;\n}\n\nint term(State& begin){\n    int res = fact(begin);\n    while(true){\n        if(*begin == '*'){\n            begin++;\n            res *= fact(begin);\n        }else if(*begin == '/'){\n            begin++;\n            res /= fact(begin);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint expr(State& begin){\n    int res = term(begin);\n    while(true){\n        if(*begin == '+'){\n            begin++;\n            res += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            res -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint fact(State& begin){\n    if(*begin == '('){\n        begin++;\n        int res = expr(begin);\n        begin++;\n        return res;\n    }\n    return number(begin);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0;i < n;i++){\n        string s;\n        cin >> s;\n        s = s.substr(0,s.size()-1);\n        State begin = s.begin();\n        cout << expr(begin) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\n#include <complex>\n#include <utility>\n#include <numeric>\n#define  rep(i,n) for(int i=0;i<(n);i++)\n#define  REP(i,a,n) for(int i=a;i<(n);i++)\n#define  rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define  VI\tvector<int>\n#define\t VS vector<string>\n#define  all(a) (a).begin(),(a).end()\n#define  debug(x) cout<<#x<<\": \"<<x<<endl\nusing namespace std;\ntypedef long long ll;\n\nconst int INF=1e9;\nchar fi[101][101];\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\ndouble EPS = 1e-10;\nint N,M;\nint sx,sy;\nint gx,gy;\nint w,h;\nint ans;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int MAX_V=100;\nconst int MAX_N=100;\nchar o[3]={'+','-','*'};\n#define md 1000003\n\n\nint dp[353][353]={0};\nint bow[353][353]={0};\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))\n\treturn 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\t\tP(double x,double y):x(x),y(y){\n\t\t}\n\t\tP operator + (P p){\n\t\t\treturn P(add(x,p.x),add(y,p.y));\n\t\t}\n\t\tP operator - (P p){\n\t\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t\t}\n\t\tP operator *(double d){\n\t\t\treturn P(x*d,y*d);\n\t\t}\n\t\tdouble dot(P p){\n\t\t\treturn add(x*p.x,y*p.y);\n\t\t}\n\t\tdouble det(P p){\n\t\t\treturn add(x*p.y,-y*p.x);\n\t\t}\n};\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x) return p.x<q.x;\n\treturn p.y<q.y;\n}\n\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps,ps+n,cmp_x);\n\tint k=0;\n\tvector<P> \tqs(n*2);\n\t\n\trep(i,n){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint n,m;\nvector<double> p;\nP ps[101];\nchar c[520][520];\nlong long mod=1000000007;\nlong long pow(ll i,ll j){\n\tll tmp=1;\n\twhile(j){\n\t\tif(j%2) tmp=tmp*i%mod;\n\t\ti=i*i%mod;\n\t\tj/=2;\n\t}\n\treturn tmp;\n}\nint cards[10];\nbool ok;\nvoid saiki(int deep){\n\tif(deep==4){\n\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i=1;i<=7;i++){\n\t\tif(cards[i]>0&&cards[i+1]>0&&cards[i+2]>0){\n\t\t\tcards[i]--;\n\t\t\tcards[i+1]--;\n\t\t\tcards[i+2]--;\n\t\t\tsaiki(deep+1);\n\t\t\tcards[i]++;\n\t\t\tcards[i+1]++;\n\t\t\tcards[i+2]++;\n\t\t}\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tif(cards[i]>2){\n\t\t\t\tcards[i]-=3;\n\t\t\t\tsaiki(deep+1);\n\t\t\t\tcards[i]+=3;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\t\n\tint n;\n\tcin>>n;\n\twhile(n>0){\n\t\tstack<string> a;\n\tstring s;\n\t\tcin>>s;\n\t\tstring tmp=\"\";\n\t\trep(i,s.size()){\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\t\t\t\ttmp+=s[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!a.empty()&&s[i]!='('){\n\t\t\t\tstring o=a.top();\n\t\t\t\t\tint k=0;\n\t\t\t\tif(o==\"*\"){\n\t\t\t\t\ta.pop();\n\t\t\t\t\tk=stoi(tmp)*stoi(a.top());\n\t\t\t\t\ta.pop();\n\t\t\t\t\ttmp=to_string(k);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(o==\"/\"){\n\t\t\t\t\ta.pop();\n\t\t\t\t\tk=stoi(a.top())/stoi(tmp);\n\t\t\t\t\ta.pop();\n\t\t\t\t\ttmp=to_string(k);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(tmp!=\"\"){\n\t\t\t\ta.push(tmp);\n\t\t\t\ttmp=\"\";\n\t\t\t\t}\n\t\t\t\t\tif(s[i]==')'){\n\t\t\t\t\t\tint k=stoi(a.top());\n\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\tif(a.top()==\"(\"){\n\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\tif(!a.empty()){\n\t\t\t\t\t\t\t\t\t\t\tif(a.top()==\"*\"){\n\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tk=stoi(a.top())*k;\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if(a.top()==\"/\"){\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tk=stoi(a.top())/k;\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta.push(to_string(k));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tif(a.top()==\"+\"){\n\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\tk=k+stoi(a.top());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(a.top()==\"-\"){\n\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\tk=stoi(a.top())-k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\telse if(s[i]!='='){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i==0&&s[i]=='-')\n\t\t\t\t\t\t\t\ttmp+=s[i];\n\t\t\t\t\t\t\telse if(s[i+1]=='-'){\n\t\t\t\t\t\t\t\ttmp+=s[i+1];\n\t\t\t\t\t\t\t\tstring c=\"\";\n\t\t\t\t\t\t\tc+=s[i++];\n\t\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstring c=\"\";\n\t\t\t\t\t\t\tc+=s[i];\n\t\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\tint ans=stoi(a.top());\n\t\t\ta.pop();\n\t\t\twhile(!a.empty()){\n\t\t\t\tif(a.top()==\"+\"){\n\t\t\t\ta.pop();\n\t\t\t\t\tans=ans+stoi(a.top());\n\t\t\t\t}\n\t\t\t\telse if(a.top()==\"-\"){\n\t\t\t\ta.pop();\n\t\t\t\t\tans=stoi(a.top())-ans;\n\t\t\t\t}\n\t\t\t\ta.pop();\n\t\t\t\t\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t\tn--;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    return 0;\n}\n\n// class Mycin {\n// \tbool flag = true;\n// public:\n// \tMycin& operator >> (int& a) {flag = scanf(\"%lld\", &a) != EOF; return *this;}\n// \tMycin& operator >> (char& a) {flag = scanf(\"%c\", &a) != EOF; return *this;}\n// \tMycin& operator >> (string& s) {flag = (bool)(cin >> s); return *this;}\n// \toperator bool() {return flag;}\n// } mycin;\n \n// class Mycout {\n// public:\n// \tMycout& operator << (const int& a) {printf(\"%lld\", a); return *this;}\n// \tMycout& operator << (const char c) {printf(\"%c\", c); return *this;}\n// \tMycout& operator << (const string& s) {printf(\"%s\", s.c_str()); return *this;}\n// } mycout;\n \n// #define cin mycin\n// #define cout mycout\n// #define endl '\\n'\n\nint number(const string& s, int& i);\nint factor(const string& s, int& i);\nint term(const string& s, int& i);\nint expr(const string& s, int& i);\n\nint number(const string& s, int& i) {\n    int res = 0;\n    bool minus_flag = false;\n    if (s[i] == '-') {\n        minus_flag = true;\n        i++;\n    }\n    for (; isdigit(s[i]); i++) {\n        res *= 10;\n        res += s[i] - '0';\n    }\n    if (minus_flag) res *= -1;\n    return res;\n}\n\nint factor(const string& s, int& i) {\n    if (isdigit(s[i]) || s[i] == '-') return number(s, i);\n    i++;\n    int res = expr(s, i);\n    i++;\n    return res;\n}\n\nint term(const string& s, int& i) {\n    int res = factor(s, i);\n    while (s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        i++;\n        int a = factor(s, i);\n        if (op == '*') res *= a;\n        else           res /= a;\n    }\n    return res;\n}\n\nint expr(const string& s, int& i) {\n    int res = term(s, i);\n    while (s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        i++;\n        int a = term(s, i);\n        if (op == '+') res += a;\n        else           res -= a;\n    }\n    return res;\n}\n\nint eval(const string& s) {\n    int i = 0;\n    return expr(s, i);\n}\n\nvoid solve() {\n    int N;\n    string s;\n    cin >> N;\n    rep(i, N) {\n        cin >> s;\n        cout << eval(s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n// 1+(4-25)*3= => [\"1\", \"+\", \"(\", \"4\", \"-\", \"25\", \")\", \"*\", \"3\", \"=\"]\nvoid str2arr(string s, string A[]) {\n    int n = 0;\n    string tmp = \"\";\n\n    for (int i = 0; s[i] != '=' ; i++) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            tmp += s[i];\n        }\n        else {\n            if (tmp != \"\") { \n                A[n++] = tmp;\n                tmp = \"\";\n            }\n            A[n++] = s[i];\n        }\n    }\n    if (tmp != \"\") { A[n++] = tmp; }\n    A[n++] = \"=\";\n}\n\n// generate Reverse Polish Notation\n\nvoid Generate_RPN(string A[], string B[]) {\n    map<string, int> table;\n    stack<string> St;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n\n    int i, j = 0;\n    for (i = 0; A[i] != \"=\"; i++) {\n        if ('0' <= A[i][0] && A[i][0] <= '9') {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\") {\n            St.push(A[i]);\n        }\n        else if (A[i] == \")\") {\n            while (St.top() != \"(\") {\n                B[j++] = St.top(); St.pop();\n            }\n            St.pop();\n        }\n        else {\n            while ((!St.empty()) && (table[St.top()] >= table[A[i]])) {\n                B[j++] = St.top(); St.pop();\n            }\n            St.push(A[i]);\n        }\n    }\n    while (!St.empty()) {\n        B[j++] = St.top(); St.pop();\n    }\n    B[j] = \"=\";\n}\n\nint Calculate_RPN(string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; s[i] != \"=\"; i++) {\n        if (s[i] == \"+\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = int(St.top()); St.pop();\n            a = int(St.top()); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = int(St.top()); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    return int(St.top());\n}\n\nint main() {\n    int n;\n    string A[100], B[100];\n    string in;\n\n    cin >> n;\n\n    while (n--) {\n        cin >> in;\n        str2arr(in, A);\n        Generate_RPN(A, B);\n        cout << Calculate_RPN(B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\n#include<cassert>\n#include<cctype>\n#include<stdio.h>\nusing namespace std;\n\nstring S=\"4*(8+4+3)\";\nsize_t cur=0;\n\nint expression(); //????????£?¨?\n\n//??°????????\\???\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\n//??°?????\\???\nint number(){\n\tint n= digit();\n\twhile(cur<S.size() && isdigit(S[cur])) n=n*10+digit();\n\treturn n;\n}\n\n//()???????¨????\nint factor(){\n\tif(S[cur] !='(' ) return number();\n\telse{\n\t\tcur++;\n\t\tint n=expression();\n\t\tassert(S[cur]==')');\n\t\tcur++;\n\t\treturn n;\n\t}\n}\n\n//*,/????????????????¨????\nint term(){\n\tint a=factor();\n\twhile(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n\t\tchar op=S[cur++];\n\t\tint b=factor();\n\t\tif(op=='*') a *=b;\n\t\telse if(op=='/') a /=b;\n\t}\n\treturn a;\n}\n\n//+,-????¨????\nint expression(){\n\tint sum=term();\n\twhile(S[cur]=='+' || S[cur]=='-'){\n\t\tchar op=S[cur++];\n\t\tint b=term();\n\t\tif(op=='+') sum+=b;\n\t\telse if(op=='-') sum -=b;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i=0;i<N;i++){\n\t\tcur =0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1); //?????????=?????????\n\t\tcout<< expression() <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &);\nint term(State &);\nint number(State &);\nint factor(State &);\n\nint main(void) {\n    int N;\n    cin >> N;\n    cin.ignore();\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint expression(State &begin) {\n    int ret = (term(begin));\n\n    while (1) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint term(State &begin) {\n    int ret = number(begin);\n\n    while (1) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n\n    return number(begin);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(string delim,string str){\n\tvector<string> res;\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ) res.push_back(str.substr(i,j-1));\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstring calc(vector<string> v){\n\tstack<string> stk;\n\tfor(int i=0;i<v.size();i++){\n\t\tll num1;\n\t\tll num2;\n\t\tchar buf[256];\n\t\tstring res;\n\t\tif(v[i]==\"-\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2-num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2+num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"*\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2*num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"/\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2/num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse{\n\t\t\tstk.push(v[i]);\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nvector<string> rvs_polish(string str){\n\tstack<string> stk;\n\tvector<string> v;\n\n\tstring tmp=\"\";\n\tvector<string> res;\n\tif(str[0]=='-'){\n\t\tstr='0'+str;\n\t}\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='*'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"*\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='/'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"/\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]=='*' || str[i-1]=='/' || str[i-1]=='-')){\n\t\t\ttmp+='-';\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]!='*' && str[i-1]!='/' && str[i-1]!='-')){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"-\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='+'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"+\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='='){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"=\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse{\n\t\t\ttmp+=str.substr(i,1);\n\t\t}\n\t}\n\n\tv.push_back(tmp);\n\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"*\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\"){\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"/\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"/\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\" || opr == \"*\"){\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"-\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres.push_back(v[i]);\n\t\t}\n\t}\n\n\twhile(!stk.empty()){\n\t\tres.push_back(stk.top());\n\t\tstk.pop();\n\t}\n\n\treturn res;\n}\n\nvoid dfs(string str){\n\tstack<P> stk;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='(') {stk.push(P('(',i));}\n\t\telse if(str[i]==')') {\n\t\t\tchar sym = stk.top().first;\n\t\t\tif(sym != '(') continue;\n\n\t\t\tint pos = stk.top().second;\n\t\t\tstk.pop();\n\n\t\t\tif(str.substr(pos+1,(i-1)-(pos+1)+1).find('(') == string::npos\n\t\t\t\t&& str.substr(pos+1,(i-1)-(pos+1)+1).find(')') == string::npos){\n\t\t\t\t\tvector<string> pol = rvs_polish(str.substr(pos+1,(i-1)-(pos+1)+1));\n\t\t\t\t\tstring num = calc(pol);\n\t\t\t\t\tstr.replace(pos,i-pos+1,num);\n\t\t\t\t\t//cout << str << endl;\n\t\t\t\t\twhile(!stk.empty()) stk.pop();\n\t\t\t\t\ti=-1;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<string> ans = rvs_polish(str);\n\n\tcout << calc(ans) << endl;\n}\n\nint main(){\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tint n;\n\t\tsscanf(str.c_str(),\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\t\t\tdfs(str.substr(0,str.size()-1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nchar num[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n\nint exp(char a[]);\nint term(char a[]);\nint factor(char a[]);\nint p;\n\nbool func(char a)\n{\n\tfor(int i = 0; i < 10; i++){\n\t\tif(a == num[i]){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint exp(char a[])\n{\n\tint x = term(a);\n\twhile(a[p] == '+' || a[p] == '-'){\n\t\tif(a[p] == '+'){\n\t\t\tp++;\n\t\t\tx += term(a);\n\t\t} else {\n\t\t\tp++;\n\t\t\tx -= term(a);\n\t\t}\n\t}\n\t\n\treturn x;\n}\n\nint term(char a[])\n{\n\tint x = factor(a);\n\twhile(a[p] == '*' || a[p] == '/'){\n\t\tif(a[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= factor(a);\n\t\t} else {\n\t\t\tp++;\n\t\t\tx /= factor(a);\n\t\t}\n\t}\n\t\n\treturn x;\n}\n\nint factor(char a[])\n{\n\twhile(a[p] == '(' || func(a[p])){\n\t\tif(a[p] == '('){\n\t\t\tp++;\n\t\t\treturn exp(a);\n\t\t} else {\n\t\t\tfor(int i = 0; i < 10; i++){\n\t\t\t\tif(a[p] == num[i]){\n\t\t\t\t\tp++;\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint n;\n\tchar a[100];\n\t\n\tcin >> n;\n\twhile(n--){\n\t\tscanf(\"%s\", a);\n\t\tp = 0;\n\t\tcout << exp(a) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <iostream>\n#include <string>\ntypedef std::string::const_iterator State;\nusing namespace std;\n\nint number(State &begin) {\n  int ret = 0;\n  while (isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin);\n\nint term(State &begin) {\n  int ret = factor(begin);\n\n  for (;;) {\n    if (*begin == '*') {\n      begin++;\n      ret *= factor(begin);\n    } else if (*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression(State &begin) {\n  int ret = term(begin);\n\n  for (;;) {\n    if (*begin == '+') {\n      begin++;\n      ret += term(begin);\n    } else if (*begin == '-') {\n      begin++;\n      ret -= term(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nint factor(State &begin) {\n  if (*begin == '(') {\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  } else {\n    return number(begin);\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while (n--) {\n    string s;\n    cin >> s;\n    State begin = s.begin();\n    cout << expression(begin) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\nusing namespace std;\nstring s;\nlong id;\nlong ev1(void);\nlong num(void){\nlong v=0;\nwhile(isdigit(s[id])){v=v*10+(s[id]-48);id++;}\nreturn v;\n}\nlong ev3(void){\nif(s[id]=='('){\nid++;\nlong v=ev1();\nid++;\nreturn v;\n}else return num();\n}\nlong ev2(void){\nlong v=ev3();\nwhile(1){\nif(s[id]=='*'){id++;v*=ev3();}\nelse if(s[id]=='/'){id++;v/=ev3();}\nelse break;\n}\nreturn v;\n}\nlong ev1(void){\nlong v=ev2();\nwhile(1){\nif(s[id]=='+'){id++;v+=ev2();}\nelse if(s[id]=='-'){id++;v-=ev2();}\nelse break;\n}\nreturn v;\n}\nint main(){\nlong n,i;\ncin>>n;\nfor(i=0;i<n;i++){\ncin>>s;\nid=0;\ncout<<ev1()<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int calc(string ex){\n\tlong long int str,cnt,ans=0,now=0,addn=1,addd=1,n=ex.length(),i;\n\tbool sus=false,minus=false;\n\tchar pm='+',md='*';\n\tfor(i=0; i<n; i++){\n\t\tif(sus){\n\t\t\tif(ex[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}else if(ex[i]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tnow = calc(ex.substr(str,i-str));\n\t\t\t\tsus = false;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(ex[i]){\n\t\t\t\tcase '(':\n\t\t\t\t\tstr = i+1;\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tsus = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif(i==0 || ex[i-1]== '+' || ex[i-1]== '-' || ex[i-1]== '*' || ex[i-1]== '/'){\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase '+':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\taddn *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\taddd *= now;\n\t\t\t\t\t}\n\t\t\t\t\tif(pm == '+'){\n\t\t\t\t\t\tans += addn/addd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans -= addn/addd;\n\t\t\t\t\t}\n\t\t\t\t\tpm = ex[i];\n\t\t\t\t\tmd = '*';\n\t\t\t\t\tnow = 0;\n\t\t\t\t\taddn = 1;\n\t\t\t\t\taddd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\taddn *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\taddd *= now;\n\t\t\t\t\t}\n\t\t\t\t\tmd = ex[i];\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tnow *= 10;\n\t\t\t\t\tnow += ex[i]-'0';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(minus){\n\t\tnow *= -1;\n\t\tminus = false;\n\t}\n\tif(md == '*'){\n\t\taddn *= now;\n\t}else{\n\t\taddd *= now;\n\t}\n\tif(pm == '+'){\n\t\tans += addn/addd;\n\t}else{\n\t\tans -= addn/addd;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n,i;\n\tlong long int ans;\n\tstring str;\n\tcin >> n;\n\tfor(i=0; i<n; i++){\n\t\tcin >> str;\n\t\tans = calc(str);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ lex_parser.hpp\n#ifndef INCLUDE_LEX_PARSER_HPP\n#define INCLUDE_LEX_PARSER_HPP\n#include <iostream>\n#include <string>\n#include <cctype>\nnamespace orislib {\ntemplate<typename T, bool Check=false>\nstruct LexParser {\n  typedef T expr_t;\n  typedef std::string::const_iterator state_t;\n  LexParser(){}\n  expr_t eval(const std::string& expr){\n    auto s = std::begin(expr);\n    auto r = expression(s);\n    consume(s, '=');\n    return r;\n  }\n  void consume(state_t& s, char expected){\n    if (!Check || *s == expected){\n      s++;\n      return;\n    }\n    std::cerr << \"Expected '\" << expected << \"' but got '\" << *s << \"'\" << std::endl;\n    std::cerr << \"Rest string is '\";\n    while (*s) std::cerr << *s;\n    std::cerr << \"'\" << std::endl;\n  }\n  expr_t number(state_t& s){\n    expr_t r = 0;\n    while (std::isdigit(*s)){\n      r = r * 10 + (*s - '0');\n      s++;\n    }\n    return r;\n  }\n  expr_t term(state_t& s){\n    expr_t r = factor(s);\n    while (1){\n      if (*s == '*'){\n        consume(s, '*');\n        r *= factor(s);\n      }\n      else if (*s == '/'){\n        consume(s, '/');\n        r /= factor(s);\n      }\n      else break;\n    }\n    return r;\n  }\n  expr_t factor(state_t& s){\n    expr_t r;\n    if (*s == '('){\n      consume(s, '(');\n      r = expression(s);\n      consume(s, ')');\n    }\n    else r = number(s);\n    return r;\n  }\n  expr_t expression(state_t& s){\n    expr_t r = term(s);\n    while (1){\n      if (*s == '+'){\n        consume(s, '+');\n        r += term(s);\n      }\n      else if (*s == '-'){\n        consume(s, '-');\n        r -= term(s);\n      }\n      else break;\n    }\n    return r;\n  }\n};\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nint main()\n{\n  LexParser<int> parser;\n  for (int n = in(); n--;){\n    string s;\n    cin >> s;\n    cout << parser.eval(s) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int n = 0;\n    for (int i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i+j])) {\n                t += s[i+j];\n                if (i+j == l-1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nint calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a-b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    if (int(St.top()) == -0)\n        return 0;\n    else\n        return int(St.top());\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0';\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        cout << calculate(t, B) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint term(State &begin);\n\nint factor(State &begin);\n\nint number(State &begin);\n\nvoid consume(State &begin,char expected);\n\nint main(){\n  int n;\n  cin>>n;\n  cin.ignore();\n  for(int i=0;i<n;i++){\n    string s;\n    getline(cin,s);\n\n    State begin = s.begin();\n    int ans=expression(begin);\n    consume(begin,'=');\n    cout<<ans<<endl;\n  }\n\n}\n\n\nint number(State &begin){\n  int ret = 0;\n\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  if(*begin =='('){\n    consume(begin,'(');\n    int ret = expression(begin);\n    consume(begin,')');\n    return ret;\n  }\n  else{\n    return number(begin);\n  }\n}\n\n\nint term(State &begin){\n  int ret = number(begin);\n\n  for(;;){\n    if(*begin =='*'){\n      consume(begin,'*');\n      ret *= factor(begin);\n    }\n    else if(*begin =='/'){\n      consume(begin,'/');\n      ret /= factor(begin);\n    }\n    else break;\n  }\n\n  return ret;\n}\n\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  for(;;){\n    if(*begin =='+'){\n      consume(begin,'+');\n      ret += term(begin);\n    }\n    else if(*begin =='-'){\n      consume(begin,'-');\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\n\nvoid consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n      << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\n#define loop(lp) for(int lp2 = 0; lp2 < lp; lp2 ++) \n#define ascent(i,a,b) for(int i = a; i < b; i ++)\n\n#define pb push_back\n\n#define MAX 10000010\n\nusing namespace std;\n\nbool flg[200000];\nint  isprime[MAX];\n\nint main() {\n  //  vector<int> p1,p2;\n  vector<int> p;\n\n  ascent(i, 0, MAX) {\n     isprime[i] = 1;\n  }\n   isprime[0] =  isprime[1] = 0;\n  \n  int cnt = 0;\n  ascent(i, 2, MAX) {\n    if(isprime[i]) {\n      for(int j = 2*i; j <= MAX; j += i) {\n\t isprime[j] = 0;\n      }\n    }\n  }\n  \n  int N, P;\n  while(cin >> N >> P) {\n    if(N == -1 && P == -1) break;\n\n    memset(flg, true, sizeof(flg));\n\n    int k = N+1;\n    int l = 0;\n    p.clear();\n    while(l < P) {\n      if(isprime[k]) {\n\tp.pb(k);\n\tl ++;\n      }\n      k ++;\n    }\n\n    vector<int> vec;\n    vec.clear();\n    ascent(i, 0, p.size()) {\n      ascent(j, i, p.size()) {\n\t  vec.pb(p[i] + p[j]);\n\t  //\t  cout << p[i] + p[j] << endl;\n      }\n    }\n\n    sort(vec.begin(), vec.end());\n    cout << vec[P-1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iter;\n\nint expr(Iter &p);\nint term(Iter &p);\nint factor(Iter &p);\nint number(Iter &p);\n\nint expr(Iter &p) {\n\tint r = term(p);\n\tfor(;;)  {\n\t\tif(*p == '+') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr += rs;\n\t\t}\n\t\telse if(*p == '-') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr -= rs;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nint term(Iter &p) {\n\tint r = factor(p);\n\tfor(;;) {\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr *= rs;\n\t\t}\n\t\telse if(*p == '/') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr /= rs;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nint factor(Iter &p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\tint r = expr(p);\n\t\tp++;\n\t\treturn r;\n\t}\n\telse\n\t\treturn number(p);\n}\n\nint number(Iter &p) {\n\tint r = 0;\n\twhile(isdigit(*p)) {\n\t\tr *= 10;\n\t\tr += *p - '0';\n\t\tp++;\n\t}\n\treturn r;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\twhile(N--) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tline = line += \"|\";\n\t\tIter begin = line.begin();\n\t\tcout << expr(begin) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cassert>\nusing namespace std;\nstring S;\nint cur=0;\nint factor();\nbool isdigit();\nint number();\nint term();\nint expression();\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>S;\n    cur=0;\n    cout<<expression()<<endl;\n  }\n}\n\nbool isdigit(){\n  return '0'<=S[cur]&&S[cur]<='9';\n}\nint digit(){\n  assert(isdigit());\n  int ret=(int)(S[cur]-'0');\n  cur++;\n  return ret;\n}\nint number(){\n  int ret=1;\n  while(!isdigit()){\n    ret=(S[cur]=='-')?-1:1;\n    cur++;\n  }\n  ret*=digit();\n  while(isdigit()){\n    ret=ret*10+digit();\n  }\n  return ret;\n}\n\nint factor(){\n  int ret=0;\n  if(S[cur]=='('){\n    cur++;\n    ret=expression();\n    cur++;//')'\n  }else{\n    ret=number();\n  }\n  return ret;\n}\nint term(){\n  int ans=factor();\n  while(cur<(int)S.size()-1&&S[cur]!='+'&&S[cur]!='-'&&S[cur]!=')'){\n    char op=S[cur];\n    cur++;\n    int right=factor();\n    //cout<<\"TERMop==\"<<op<<\" \"<<right<<endl;\n    switch(op){\n    case '*':\n      ans*=right;\n      break;\n    case '/':\n      ans/=right;\n      break;\n    default ://///\n      break;\n    } \n  }\n  return ans;\n}\nint expression(){\n  int ans=term();\n  while(cur<(int)S.size()-1&&S[cur]!=')'){\n    char op=S[cur];\n    cur++;\n    int right=term();\n    //cout<<\"EXop==\"<<op<<\" \"<<right<<endl;\n    switch(op){\n    case '+':\n      ans+=right;\n      break;\n    case '-':\n      ans-=right;\n      break;\n    default ://///\n      break;\n    } \n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\treturn(stoi(in[0]));\n}\nint main()\n{\n\tstring input;\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](string s) { return stoi(s); }, many1(digit));\n\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                          || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                        || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <cctype>\nusing namespace std;\ntypedef long long ll;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nvoid calc(string st, stack<ll> &s) {\t\n\tif(st == \"*\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(a * b);\n\t} else if(st == \"+\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(a + b);\n\t} else if(st == \"-\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(b - a);\n\t} else if(st == \"/\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(b / a);\n\t} else {\n\t\ts.push(atoi(st.c_str()));\n\t}\n}\nint getPriority(string s) {\n\tif(s == \"(\") {\n\t\treturn 5;\n\t} else if(s == \"*\" || s == \"/\") {\n\t\treturn 3;\n\t} else if(s == \"+\" || s == \"-\") {\n\t\treturn 2;\n\t} else if(s == \")\") { \n\t\treturn 1;\n\t} else return 4;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(--str.end());\n\t\t\n\t\tvector<string> v;\n\t\t\n\t\tint f = 0;\n\t\trep(i, str.size()) {\t\t\t\n\t\t\tif(isdigit(str[i])) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif(f) {\n\t\t\t\t\tstring st;\n\t\t\t\t\trep(j,f) {\n\t\t\t\t\t\tst += str[i - f + j];\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(st);\n\t\t\t\t\tstring st2;\n\t\t\t\t\tst2 += str[i];\n\t\t\t\t\tv.push_back(st2);\n\t\t\t\t\tf = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstring st3;\n\t\t\t\t\tst3 += str[i];\n\t\t\t\t\tv.push_back(st3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) {\n\t\t\tstring st;\n\t\t\trep(j,f) {\n\t\t\t\tst += str[str.size() - f + j];\n\t\t\t}\n\t\t\tv.push_back(st);\n\t\t}\n\n\t\tstack<string> s;\n\t\tvector<string> nv;\n\t\tstack<ll> ret;\n\t\tint p = 0;\n\t\trep(i,v.size()) {\n\t\t\tp = getPriority(v[i]);\n\t\t\twhile(!s.empty() && getPriority(s.top()) > p && s.top() != \"(\") {\n\t\t\t\tnv.push_back(s.top());\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(v[i] == \")\") {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(v[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()) {\n\t\t\tnv.push_back(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\trep(i,nv.size()) {\n\t\t\tcalc(nv[i], ret);\n\t\t}\n\t\tcout << ret.top() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(s[0]=='-' || isdigit(s[0])){\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\telse if(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse\n\t\texit(0);\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t}\n\t//string s;\n\t//getline(cin,s);\n\t//while(getline(cin,s))\n\t//\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nconst int MOD = 1e9 + 7, INF = 1e17;\nusing vi = vector <int>;\nusing vvi = vector <vi>;\n//g++ -std==c++14\n\n\nint expr(const char **);\nint term(const char **);\nint factor(const char **);\nint number(const char **);\n\nint expr(const char **p) {\n  int val = term(p);\n  while (1) {\n    if (**p == '+') {\n      (*p)++;\n      val += term(p);\n    } else if (**p == '-') {\n      (*p)++;\n      val -= term(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(const char **p) {\n  int val = factor(p);\n  while (1) {\n    if (**p == '*') {\n      (*p)++;\n      val *= factor(p);\n    } else if (**p == '/') {\n      (*p)++;\n      val /= factor(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(const char **p) {\n  if (**p == '(') {\n    (*p)++;\n    int val = expr(p);\n    (*p)++;\n    return val;\n  }\n  return number(p);\n}\n\nint number(const char **p) {\n  int val = 0;\n  while ('0' <= **p && **p <= '9') {\n    val = val * 10 + **p - '0';\n    (*p)++;\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    const char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for (int i = 0; i < int(n); i++)\n//typedef long long ll;\ntypedef int ll;\n\nint it, n;\nstring input;\n\nll expr();\nll term();\nll fact();\n\nll expr() {\n    int v = term();\n    while (input[it] == '+' || input[it] == '-') {\n        if (input[it++] == '+') {\n            v += term();\n        } else {\n            v -= term();\n        }\n    }\n    return v;\n}\n\nll term() {\n    int v = fact();\n    while (input[it] == '*' || input[it] == '/') {\n        if (input[it++] == '*') {\n            v *= term();\n        } else {\n            v = (int)trunc(1.0*v/term());\n            //v /= term();\n        }\n    }\n    return v;\n}\n\nll fact() {\n    int v = 0;\n    if (input[it] == '(') {\n        ++it; // '('\n        v = expr();\n        ++it; // ')'\n    } else {\n        int sign = input[it] == '-' ? ++it, -1 : 1;\n        while ('0' <= input[it] && input[it] <= '9') {\n            v = 10*v + input[it]-'0';\n            ++it;\n        }\n        v *= sign;\n    }\n    return v;\n}\n\nint main() {\n    cin >> n;\n    rep (i,n) {\n        cin >> input;\n        it = 0;\n        cout << expr() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef string::const_iterator State;\n\nstring s;\n\nint eval(State &beg);\n\nint number( State &beg ){\n    string ret=\"\";\n    while( *beg!='=' && isdigit(*beg) ){\n        ret+=string(1,*beg);\n        beg++;\n    }\n    \n    return stoi(ret);\n}\n\nint term(State &beg){\n    int ret = 0;\n    if( *beg=='(' ){\n        beg++;\n        ret = eval(beg);\n        beg++;\n    }\n    else{\n        ret = number(beg);\n    }\n    while( *beg!='=' && *beg!=')' && *beg!='+' && *beg!='-' ){\n        beg++;\n        if( *(beg-1)=='*' )         ret*=term(beg);\n        else if( *(beg-1)=='/' )    ret/=term(beg);\n        else throw(string(1,*(beg-1)));\n    }\n    return ret;\n}\n\nint eval(State &beg){\n    int ret=term(beg);\n    \n    while(*beg!='=' && *beg!=')'){\n        beg++;\n        if(*(beg-1)=='+')       ret+=term(beg);\n        else if(*(beg-1)=='-')  ret-=term(beg);\n        else throw(\"error\");\n    }\n    return ret;\n}\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        cin>>s;\n        \n        State beg = s.begin();\n        try{\n            cout<<eval(beg)<<endl;\n        }catch(string s){\n            cout<<s<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint exp();\nint term();\nint factor();\nstring str;\nint p;\nint factor(){\n  int val=0;\n  while(str[p]>='0' && str[p]<='9'){ \n    val*=10;\n    val+=str[p]-'0';\n    p++;\n  }\n  \n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }\n  return val;\n}\n\nint term(){\n  int val=factor();\n  while(str[p]=='*' || str[p]=='/'){\n  if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n }\n return val;\n}\n\nint exp(){\n  int val=term();\n  while(str[p]=='+' || str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\n\n\nint main(){\n  int n;\n  \n  cin>>n;\n  for(int i=0;i<n;i++){\n    p=0;\n    cin>>str;\n    cout<<exp()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint exp(string&, int&);\nint term(string&, int&);\nint factor(string&, int&);\n\nint exp(string& str, int& p){\n  int res = term(str, p);\n  while(str[p] == '+' || str[p] == '-'){\n    if(str[p] == '+'){\n      p++;\n      res += term(str, p);\n    }else{\n      p++;\n      res -= term(str, p);\n    }\n  }\n  return res;\n}\n\nint term(string& str, int& p){\n  int res = factor(str, p);\n  while(str[p] == '*' || str[p] == '/'){\n    if(str[p] == '*'){\n      p++;\n      res *= factor(str, p);\n    }else{\n      p++;\n      res /= factor(str, p);\n    }\n  }\n  return res;\n}\n\nint factor(string& str, int& p){\n  int res = 0;\n  int keta = 1;\n  int initp = p;\n  if(str[p] == '('){\n    while(str[p] != ')'){\n      p++;\n      res = exp(str, p);\n    }\n    p++;\n  }else{\n    while(isdigit(str[p])){\n      p++;\n    }\n    for(int i=p-1; i >= initp; i--){\n      res += keta * (str[i] - '0');\n      keta *= 10;\n    }\n  }\n  return res;\n}\n\n\nint main(void){\n  int n; cin >> n;\n  while(n--){\n    int p=0;\n    string str;\n    cin >> str;\n    cout << exp(str, p) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator Iter;\n\nint express(Iter &p);\nint term(Iter &p);\nint factor(Iter &p);\nint number(Iter &p);\n\nint express(Iter &p) {\n\tint r = term(p);\n\tfor(;;) {\n\t\tif(*p == '+') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr += rs;\n\t\t}\n\t\telse if(*p == '-') {\n\t\t\tp++;\n\t\t\tint rs = term(p);\n\t\t\tr -= rs;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\n\nint term(Iter &p) {\n\tint r = factor(p);\n\tfor(;;) {\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr *= rs;\n\t\t}\n\t\telse if(*p == '/') {\n\t\t\tp++;\n\t\t\tint rs = factor(p);\n\t\t\tr /= rs;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nint factor(Iter &p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\tint r = express(p);\n\t\tp++; // skip )\n\t\treturn r;\n\t}\n\telse\n\t\treturn number(p);\n}\n\nint number(Iter &p) {\n\tint r = 0;\n\twhile(isdigit(*p)) {\n\t\tr *= 10;\n\t\tr += (*p) - '0';\n\t\tp++;\n\t}\n\treturn r;\n}\n\nint main() {\n\tint N; cin >> N;\n\tcin.ignore();\n\twhile(N--) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tIter begin = line.begin();\n\t\tint ans = express(begin);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint calc2(char *eq){\n\tint c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(int j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nint calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tint k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%d%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nint main(){\n\tint i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nconst string op = \"+-*/()=\";\ndouble RPN(string str){\n  string s,s2;\n  double ans;\n  stack<double> n;\n  s = str;\n  ans = 0;\n  s += \" \" ;\n  rep(i,s.size()){\n    if(s[i] != ' '){\n      s2 += s[i];\n    }\n    else{\n      double a,b;\n      if(s2 == \"+\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a + b;\n        n.push(ans);\n      }\n      else if(s2 == \"-\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a - b;\n        n.push(ans);\n      }\n      else if(s2 == \"*\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a * b;\n        n.push(ans);\n      }\n      else if(s2 == \"/\"){\n        b = n.top(),n.pop();\n        a = n.top(),n.pop();\n        ans = a / b;\n        n.push(ans);\n      }\n      else{\n        n.push(ston(s2,1.0));\n      }\n      s2.clear();\n    }\n  }\n  return n.top();\n}\n\nvector<string> Split(char c,string s){\n  vector<string> res(0);\n  string str = \"\";\n  rep(i,s.size()){\n    if(s[i] == c){\n      if(str.size()){\n        res.push_back(str);\n      }\n      str.clear();\n    }\n    else{\n      str += s[i];\n    }\n  }\n  res.push_back(str);\n  return res;\n}\nbool check(string s1,string s2){\n  if(((s1 == \"+\" || s1 == \"-\" ) && s2 != \"(\")|| s1 == s2) return true;\n  if((s1 == \"*\" || s1 == \"/\")&& (s2 == \"+\" || s2 == \"-\")) return false;\n  if(s2 == \"(\") return false;\n}\nstring ConvertRPN(string s){\n  const string notnumber = \"+-*/() \";\n  stack<string> fom;\n  auto str = Split(' ',s);\n  string res = \"\";\n  rep(i,str.size()){\n    if(notnumber.find(str[i]) == string::npos){\n      res += str[i];\n      res += \" \";\n    }\n    else if(str[i] == \")\"){\n      while(fom.top() != \"(\"){\n        if(fom.top() != \" \"){\n          res += fom.top();\n          res += \" \";\n        }\n        fom.pop();\n      }\n      fom.pop();\n    }\n    else if(str[i] == \"(\" || fom.empty()){\n      fom.push(str[i]);\n    }\n    else if(check(str[i],fom.top())){\n      while(!fom.empty() && check(str[i],fom.top())){\n        if(fom.top() != \" \"){\n          res += fom.top();\n          res += \" \";\n        }\n        fom.pop();\n      }\n      fom.push(str[i]);\n    }\n    else{\n      fom.push(str[i]);\n    }\n  }\n  while(fom.size()){\n    if(fom.top() != \" \"){\n      res += fom.top();\n      res += \" \";\n    }\n    fom.pop();\n  }\n  res.resize(res.size()-1);\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  rep(i,n){\n    string s,res = \"\";\n    cin >> s;\n    rep(i,s.size()){\n      if(find(all(op),s[i]) == op.end()){\n        res += s[i];\n      }\n      else{\n        if(res[res.size()-1] != ' ' )\n        res += \" \";\n        res += s[i] ;\n        res += \" \";\n      }\n    }\n    res.resize(res.size()-3);\n    res = ConvertRPN(res);\n    cout << RPN(res)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 構文解析の練習\n// https://gist.github.com/draftcode/1357281\n#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef string::const_iterator State;\nclass ParseError{};\nint number(State&);\nint term(State&);\nint expression(State&);\nint factor(State&);\n\nint number(State& begin) {\n    int ret = 0;\n    while(isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\nint term(State& begin) {\n    int ret = number(begin);\n\n    while(1) {\n        if(*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n\n}\nint expression(State& begin) {\n    int ret = term(begin);\n    \n    while(1) {\n        if(*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n\n}\nint factor(State& begin) {\n    int ret = 0;\n    if(*begin == '(') {\n        begin++; // ( を飛ばす\n        ret = expression(begin);\n        begin++; // ) を飛ばす\n    }\n    else {\n        ret = number(begin);\n    }\n\n    return ret;\n}\n\nint main() {\n    int N;\n    cin>>N;\n    cin.ignore();\n    rep(i,N) {\n        string s;\n        getline(cin,s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parse{\n    typedef string::const_iterator itr;\n    itr begin;\n    T ans;\n    Parse(const string &s){\n        begin=s.begin();\n        ans=expr(begin);\n        cerr<<s<<\" \"<<ans<<\"\\n\";\n    }\n    T expr(itr &begin){\n        T ret=term(begin);\n        while(1){\n            if((*begin)=='+'){\n                consume(begin,'+');\n                ret+=term(begin);\n            }else if((*begin)=='-'){\n                consume(begin,'-');\n                ret-=term(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    T numb(itr &begin){\n        T ret=0;\n        while('0'<=(*begin)&&(*begin)<='9'){\n            ret*=10;\n            ret+=(*begin)-'0';\n            begin++;\n        }\n        return ret;\n    }\n    T fact(itr &begin){\n        T ret=0;\n        if((*begin)=='('){\n            consume(begin,'(');\n            ret=expr(begin);\n            consume(begin,')');\n        }else{\n            ret=numb(begin);\n        }\n        return ret;\n    }\n    T term(itr &begin){\n        T ret=fact(begin);\n        while(1){\n            if((*begin)=='*'){\n                consume(begin,'*');\n                ret*=fact(begin);\n            }else if((*begin)=='/'){\n                consume(begin,'/');\n                ret/=fact(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n            throw;\n        }\n    }\n};\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>>s;\n        Parse<int> parse(s);\n        cout<<parse.ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n\nusing namespace std;\n\nint calc(string s){\n\t// ©gªÊÉÍÜêÄ¢éêÆAÅ éÆ«Ì\n\tif(s[0]>='0'&&s[0]<='9'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(!(s[i]>='0'&&s[i]<='9')){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f){\n\t\t\treturn atoi(s.c_str());\n\t\t}\n\t}\n\telse if(s[0]=='('){\n\t\tstack<char> sc;\n\t\tsc.push('(');\n\t\tfor(int i = 1; i < s.size(); i++){\n\t\t\tif(s[i]==')')\n\t\t\t\tsc.pop();\n\t\t\telse if(s[i]=='('){\n\t\t\t\tsc.push('(');\n\t\t\t}\n\t\t\tif(sc.size()==0){\n\t\t\t\tif(i==s.size()-1){\n\t\t\t\t\treturn calc(s.substr(1,s.size()-2));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstack<char> sc;\n\t// \\¶ðÍÆÓ¡ðÍ\n\tfor(int i = 0; i < s.size(); i++){\n\t\t// ÊÌÌZqÍ³·é\n\t\tif(s[i]=='(')\n\t\t\tsc.push('(');\n\t\telse if(s[i]==')'){\n\t\t\tsc.pop();\n\t\t}\n\t\telse if(s[i]=='+'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) + calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='-'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) - calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='*'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) * calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='/'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) / calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tstring str;\n\t\tcin>>str;\n\t\tcout<<calc(str.substr(0,str.size()-1))<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "n=gets.to_i;n.times{puts eval gets.strip[0..-2]}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint calc(string ex){\n\tint str,cnt,ans=0,now=0,add=1,n=ex.length(),i;\n\tbool sus=false,minus=false;\n\tchar pm='+',md='*';\n\tfor(i=0; i<n; i++){\n\t\tif(sus){\n\t\t\tif(ex[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}else if(ex[i]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tnow = calc(ex.substr(str,i-str));\n\t\t\t\tsus = false;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(ex[i]){\n\t\t\t\tcase '(':\n\t\t\t\t\tstr = i+1;\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tsus = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif(i==0 || ex[i-1]== '+' || ex[i-1]== '-' || ex[i-1]== '*' || ex[i-1]== '/'){\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase '+':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\tadd *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tadd /= now;\n\t\t\t\t\t}\n\t\t\t\t\tif(pm == '+'){\n\t\t\t\t\t\tans += add;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans -= add;\n\t\t\t\t\t}\n\t\t\t\t\tpm = ex[i];\n\t\t\t\t\tmd = '*';\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tadd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\tadd *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tadd /= now;\n\t\t\t\t\t}\n\t\t\t\t\tmd = ex[i];\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tnow *= 10;\n\t\t\t\t\tnow += ex[i]-'0';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(minus){\n\t\tnow *= -1;\n\t\tminus = false;\n\t}\n\tif(md == '*'){\n\t\tadd *= now;\n\t}else{\n\t\tadd /= now;\n\t}\n\tif(pm == '+'){\n\t\tans += add;\n\t}else{\n\t\tans -= add;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n,i,ans;\n\tstring str;\n\tcin >> n;\n\tfor(i=0; i<n; i++){\n\t\tcin >> str;\n\t\tans = calc(str);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])==-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=s[oi];\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while{\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string>\n#include <sstream>\n\nusing namespace std;\nstring s;\nint idx;\nint term();\nint expr();\nint fact();\nint number();\n\n// <term> = <fact> { (‘*’|‘/’) <fact> } \nint term(){\n  int res = fact();\n  while(s[idx] == '*' || s[idx] == '/'){\n    char op = s[idx++];\n    int tmp = fact(); \n    if(op == '*')\n      res *= tmp;\n    else res /= tmp;\n  }\n  return res;\n}\n\n\n// <expr> = <term> { (‘+’|‘-’) <term> }\nint expr(){\n  int res = term();\n  while(s[idx] == '+' || s[idx] == '-'){\n    char op = s[idx++];\n    int tmp = term();\n    if(op == '+') res += tmp;\n    else res -= tmp;\n  }\n  return res;\n}\n\n\n// <number> = { <digit> }\n// <digit> = ‘0’ | ‘1’ | ... | ‘9’\nint number(){\n  int res = 0;\n  while('0' <= s[idx] && s[idx] <= '9'){\n    res = res*10 + s[idx] - '0';\n    idx++;\n  }\n  return res;\n}\n\n// <fact> = ‘(’ <expr> ‘)’ | <number> \nint fact(){ \n  int res; \n  if(s[idx] == '('){\n    idx++; \n    res = expr();\n    //assert( s[idx] == ')' ); \n    idx++;\n  } \n  else{ \n    res = number(); \n  } \n  return res;\n}\n\n\nint main()\n{\n  int n;\n  \n  cin>>n;\n  for(;n--;)\n    {\n      idx=0;\n      cin>>s;\n      cout << expr()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    cout << number(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nchar siki[200];\nint cur;\n\n\nint digit(){\n  int n=siki[cur]-'0';\n  ++cur;\n  return n;\n}\n\nint number(){\n  int n=digit();\n  while(cur<strlen(siki) && isdigit(siki[cur]))\n    n=n*10+digit();\n\n  return n;\n}\n\nint factor();\n\nint term(){\n  int a=factor();\n  while(cur<strlen(siki) && (siki[cur]=='*' || siki[cur]=='/')){\n    char op=siki[cur];\n    ++cur;\n    int b=factor();\n    if(op=='*')a*=b;else a/=b;\n  }\n  return a;\n}\n\nint expression(){\n  int a=term();\n  while(cur<strlen(siki) && (siki[cur]=='+' || siki[cur]=='-')){\n    char op=siki[cur];\n    cur++;\n    int b=term();\n    if(op=='+')a+=b;else a-=b;\n  }\n  return a;\n}\n\nint factor(){\n  if(siki[cur]!='(')return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint main(){\n  int n;\n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>siki;\n    cur=0;\n    cout<<expression()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef int number;\n\nint c;\nstring str;\n\nnumber Z();\nnumber Expr();\nnumber Factor();\nnumber Term();\nnumber Num();\n\nvoid debug(string str) {\n//  cout << str << endl;\n}\n\nnumber Z() {\n  debug(\"Z: \" + str.substr(c));\n  number ans = Expr();\n  c++; // read =\n  debug(\"Z(\" + to_string(ans) + \"): \" + str.substr(c));\n  return ans;\n}\n\nnumber Expr() {\n  debug(\"Expr: \" + str.substr(c));\n  number val = Factor();\n  int p;\n  while (p = c, (str[p] == '+' || str[p] == '-')) {\n    if (str[c] == '+') {\n      c++; // read +\n      number expr = Expr();\n      val += expr;\n    } else {\n      // c++; // read -\n      number expr = Expr();\n      // val -= expr;\n      val += expr;\n    }\n  }\n  debug(\"Expr(\" + to_string(val) + \"): \" + str.substr(c));\n  return val;\n}\n\nnumber Factor() {\n  debug(\"Factor: \" + str.substr(c));\n  number val = Term();\n  int p;\n  while (p = c, (str[p] == '*' || str[p] == '/')) {\n    if (str[c] == '*') {\n      c++; // read *\n      number factor = Term();\n      val *= factor;\n    } else {\n      c++; // read /\n      number factor = Term();\n      val /= factor;\n    }\n  }\n  debug(\"Factor(\" + to_string(val) + \"): \" + str.substr(c));\n  return val;\n}\n\nnumber Term() {\n  debug(\"Term: \" + str.substr(c));\n  if (str[c] == '-') {\n    c++; // read -\n    number term = Term();\n    return -term;\n  } else if (str[c] == '(') {\n    c++; // read (\n    number expr = Expr();\n    c++; // read )\n    return expr;\n  } else {\n    number num = Num();\n    return num;\n  }\n}\n\nnumber Num() {\n  debug(\"Num: \" + str.substr(c));\n  number val = 0;\n  while (isdigit(str[c])) {\n    val = val * 10 + (str[c] - '0');\n    c++;\n  }\n  debug(\"Num(\" + to_string(val) + \"): \" + str.substr(c));\n  return val;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i, n) {\n    c = 0;\n    cin >> str;\n    cout << Z() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n/*\n<四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n<乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n<括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n<数>           ::= ...\n*/\n\n// 構文解析\nusing State = string::const_iterator;\nclass ParseError{};\n\nint number(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\n// 数字の列をパースして，その数を返す\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// 乗算除算の式をパースして，その評価結果を返す\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n\n// 四則演算の式をパースして，その評価結果を返す\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    }\n    else {\n        cerr << \"Expected \" << expected << \" but got \" << *begin << endl;\n        cerr << \"Rest string is \";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << endl;\n        throw ParseError();\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    cin.ignore();\n    rep(i, N) {\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        //consume(begin, '=');\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef string::iterator state;\n\nlli addsub(state& s);\nlli muldiv(state& s);\nlli parent(state& s);\nlli number(state& s);\n\nlli number(state& s){\n\tlli res = 0;\n\tif(*s=='('){\n\t\tres = parent(s);\n\t}\n\telse if('0'<=*s && *s<='9'){\n\t\twhile('0'<=*s && *s<='9'){\n\t\t\tres*=10;\n\t\t\tlli nc = *s-'0';\n\t\t\tres += nc;\n\t\t\ts++;\n\t\t}\n\t}\n\telse printf(\"error number\\n\");\n\treturn res;\n}\n\nlli parent(state& s){\n\tif(*s!='(')printf(\"error kakko\\n\");\n\ts++;\n\tlli res = addsub(s);\n\tif(*s!=')')printf(\"error kokka\\n\");\n\ts++;\n\treturn res;\n}\n\nlli muldiv(state& s){\n\tlli res = number(s);\n\twhile(1){\n\t\tif(*s=='*'){\n\t\t\ts++;\n\t\t\tres *= number(s);\n\t\t}\n\t\telse if(*s=='/'){\n\t\t\ts++;\n\t\t\tres /= number(s);\n\t\t}\n\t\telse break;\n\t}\n\treturn res;\n}\n\nlli addsub(state& s){\n\tlli res = muldiv(s);\n\twhile(1){\n\t\tif(*s=='+'){\n\t\t\ts++;\n\t\t\tres += muldiv(s);\n\t\t}\n\t\telse if(*s=='-'){\n\t\t\ts++;\n\t\t\tres -= muldiv(s);\n\t\t}\n\t\telse break;\n\t}\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tchar s[105];\n\t\tscanf(\"%s\",s);\n\t\tstring ns(s);\n\t\tstate is = ns.begin();\n\t\tprintf(\"%lld\\n\",addsub(is));\n\t\tif(*is!='=')printf(\"error finish\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parse{\n    typedef string::const_iterator itr;\n    itr begin;\n    T ans;\n    Parse(const string &s){\n        begin=s.begin();\n        ans=expr(begin);\n        cerr<<s<<\" \"<<ans<<\"\\n\";\n    }\n    T expr(itr &begin){\n        T ret=term(begin);\n        while(1){\n            if((*begin)=='+'){\n                consume(begin,'+');\n                ret+=term(begin);\n            }else if((*begin)=='-'){\n                consume(begin,'-');\n                ret-=term(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    T numb(itr &begin){\n        T ret=0;\n        while('0'<=(*begin)&&(*begin)<='9'){\n            ret*=10;\n            ret+=(*begin)-'0';\n            begin++;\n        }\n        return ret;\n    }\n    T fact(itr &begin){\n        T ret=0;\n        if((*begin)=='('){\n            consume(begin,'(');\n            ret=expr(begin);\n            consume(begin,')');\n        }else{\n            ret=numb(begin);\n        }\n        return ret;\n    }\n    T term(itr &begin){\n        T ret=fact(begin);\n        while(1){\n            if((*begin)=='*'){\n                consume(begin,'*');\n                ret*=fact(begin);\n            }else if((*begin)=='/'){\n                consume(begin,'/');\n                ret/=fact(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n            return;\n        }\n    }\n};\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>>s;\n        Parse<int> parse(s);\n        cout<<parse.ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cctype>\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,n) FOR(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst ll INF = 1e15;\ntypedef pair<ll,ll> P;\ntypedef string::const_iterator State;\nclass ParseError {};\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\nint expression(State &begin){\n    int ret = term(begin);\n    for(;;){\n        if (*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }\n        else if (*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }\n        else{\n            break;\n        }\n    }\n    return ret;\n}\nint factor(State &begin){\n    if (*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else{\n        return number(begin);\n    }\n}\nint term(State &begin){\n    int ret = factor(begin);\n    for(;;){\n        if (*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }\n        else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    cin.ignore();\n    rep(i,N){\n        string s;\n        getline(cin,s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing State = string::const_iterator;\n\nint expr(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint expr(State &begin) {\n  int val = term(begin);\n  forever {\n    if (*begin == '+') {\n      begin++;\n      val += term(begin);\n    } else if (*begin == '-') {\n      begin++;\n      val -= term(begin);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(State &begin) {\n  int val = factor(begin);\n  forever {\n    if (*begin == '*') {\n      begin++;\n      val *= factor(begin);\n    } else if (*begin == '/') {\n      begin++;\n      val /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(State &begin) {\n  if (*begin == '(') {\n    begin++;\n    int val = expr(begin);\n    begin++;\n    return val;\n  }\n  return number(begin);\n}\n\nint number(State &begin) {\n  int val = 0;\n  while (isdigit(*begin)) {\n    val *= 10;\n    val += *begin - '0';\n    begin++;\n  }\n  return val;\n}\n\nmain {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    State begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    p=0;\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val=number();\n  if(str[p]=='('){\n    p++;\n    val=exp();\n  }else if(str[p]==')'){\n    p++;\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  return val;\n}\nint digit(){\n  if(str[p]=='0'){\n    p++;\n    return 0;\n  }\n  else if(str[p]=='1'){\n    p++;\n    return 1;\n  }\n  else if(str[p]=='2'){\n    p++;\n    return 2;\n  }\n  else if(str[p]=='3'){\n    p++;\n    return 3;\n  }\n  else if(str[p]=='4'){\n    p++;\n    return 4;\n  }\n  else if(str[p]=='5'){\n    p++;\n    return 5;\n  }\n  else if(str[p]=='6'){\n    p++;\n    return 6;\n  }\n  else if(str[p]=='7'){\n    p++;\n    return 7;\n  }\n  else if(str[p]=='8'){\n    p++;\n    return 8;\n  }\n  else if(str[p]=='9'){\n    p++;\n    return 9;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<\"foo2 \"<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\t\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\t// string tmp=\"123456\";\n\t// cout<<tmp.substr(5)<<endl;;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr<s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\t\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nstring S = \"3*(12+3)\";\nsize_t cur = 0;\n\nint expression();\n\nint digit() {\n  assert(isdigit(S[cur]));\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\n\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur]))\n    n = n*10 + digit();\n  return n;\n}\n\nint factor() {\n  if (S[cur] != '(') return number();\n  cur += 1;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur++;\n  return n;\n}\n\nint term() {\n  int a = factor();\n  while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    int b = factor();\n    if (op == '*') a *= b; else a/= b;\n  }\n  return a;\n}\n\nint expression() {\n  int a = term();\n  while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++];\n    int b = term();\n    if (op == '+') a += b; else a -= b;\n  }\n  return a;\n}\n\nint parse() {\n  cur = 0;\n  return expression();\n}\n\nint main (int argc, char const* argv[]) {\n  int n; cin>>n;\n  rep(i,n) {\n    cin>>S;\n    S.erase(S.size()-1);\n    //cout<<S<<endl;\n    cout<<parse()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//A Reward for a Carpenter\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define mp make_pair\nusing namespace std;\nstring S;\nsize_t cur = 0;\nbool isdigit(char);\nint digit();\nint number();\nint term();\nint expression();\nint factor();\nint parse(){\n    return expression();\n}\n\nint main(){\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> S;\n        cout << parse() << endl;\n    }\n}\n\nbool isdigit(char c){\n    return c >= '0' && c <= '9';\n}\nint digit(){\n    assert(isdigit(S[cur]));\n    int n = S[cur] - '0';\n    cur = cur + 1;\n    return n;\n}\nint number(){\n    int n = digit();\n    while(cur<S.size()&&isdigit(S[cur])){\n        n = n*10+digit();\n    }\n    return n;\n}\n\nint expression(){\n    int mult = 1;\n    if(S[cur]=='-'){\n        mult = -1;\n        cur++;\n    }\n    int sum = term()*mult;\n    while(cur < S.size()&&(S[cur]=='+'||S[cur]=='-')){\n        char op = S[cur];\n        cur++;\n        if(op == '+'){\n            sum += term();\n        }else{\n            sum -= term();\n        }\n    }\n    return sum;\n}\nint term(){\n    int ret = factor();\n    while(cur < S.size() &&( S[cur]=='*'||S[cur]=='/')){\n        char op = S[cur];\n        cur++;\n        if(op == '*'){\n            ret *= factor();\n        }else{\n            ret /= factor();\n        }\n    }\n    return ret;\n}\nint factor(){\n    if(S[cur]!='(')\n        return number();\n    cur += 1;\n    int n = expression();\n    assert(S[cur]==')');\n    cur++;\n    return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <stack>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n\nint cal(){\n  stack<int> st;\n  int ope=0;\n  int num;\n  while(true){\n    char c = getchar();\n    if(c == '\\n' || c == ')' ) break;\n    if(c == '(' || ('0'<=c && c<= '9') ) {\n      if(c == '(') num = cal();\n      else num = (c - '0');\n      if(ope==0){\n        st.push(num);\n      }else if(ope == 1){\n        st.push(-num);\n        ope = 0;\n      }else if(ope == 2){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp * num);\n        ope = 0;\n      }else if(ope == 3){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp / num);\n        ope = 0;\n      }\n    }\n    if(c == '+') ope = 0;\n    if(c == '-') ope = 1;\n    if(c == '*') ope = 2;\n    if(c == '/') ope = 3;\n  }\n  int sum=0;\n  while(!st.empty()){\n    sum += st.top();\n    st.pop();\n  }\n  return sum;\n}\n\nint main(void){  \n  int n;\n  cin >> n;\n  getchar();\n  REP(i,n)\n    cout << cal() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nusing LL = long long;\nconst LL LINF = 1e18;\nusing namespace std;\n#define COUT(v) cout<<(v)<<endl\n#define CIN(n)  int(n);cin >> (n)\n#define SCIN(n) string(n);cin >> (n)\n#define YES(n) cout<<((n)? \"YES\" : \"NO\")<<endl\n#define Yes(n) cout<<((n)? \"Yes\" : \"No\")<<endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) <<endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define P pair<int,int>\n#define I vector<int>\n#define S set<int>\n#define pb(v) push_back(v)\n#define V vector\n#define rt return\n#define rmsame(a) sort(ALL(a)),a.erase(unique(ALL(a)), a.end())\n\ntypedef string::const_iterator State;\nclass PalseError {};\nclass Edge{\npublic:\n    int from,to,value;\n    Edge(int a,int b,int c){\n        from = a;\n        to = b;\n        value = c;\n    }\n    Edge(int a,int b){\n        from = a;\n        to = b;\n    }\n};\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\nint term(State &begin){\n    int ret = number(begin);\n    while(1){\n        if(*begin == '*'){\n            begin++;\n            ret *=  number(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= number(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint expression(State &begin){\n    int ret = term(begin);\n    while(1){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint main(){\n    string s;\n    CIN(N);\n    REP(a,N){\n        cin >> s;\n        State w = s.begin();\n        COUT(expression(w));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int n;\n    string q, a, sop;\n    stack<int> numstack;\n    stack<string> opstack;\n    map<string, int> oprank;\n\tvector<string> exq;\n    oprank[\"/\"] = oprank[\"*\"] = 2;\n    oprank[\"+\"] = oprank[\"-\"] = 1;\n\toprank[\"(\"] = 0;\n    cin >> n;\n    for(int i(0);i < n;++i){\n        cin >> q;\n\t\texq.clear();\n        a = \"\";\n        for(int j(0);j < q.length();++j){\n            if(q[j] < '0' || '9' < q[j]){\n                if(a.length() > 0) exq.push_back(a);\n                a = \"\";\n\t\t\t\tsop = string(1, q[j]);\n                if(opstack.empty()){\n\t\t\t\t\topstack.push(sop);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(sop == \")\"){\n\t\t\t\t\twhile(opstack.top() != \"(\"){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t\topstack.pop();\n\t\t\t\t}\n\t\t\t\telse if(sop == \"(\") opstack.push(sop);\n\t\t\t\telse if(sop == \"=\"){\n\t\t\t\t\twhile(!opstack.empty()){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(oprank[sop] <= oprank[opstack.top()]){\n\t\t\t\t\twhile(!opstack.empty() && oprank[sop] <= oprank[opstack.top()]){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t\topstack.push(sop);\n\t\t\t\t}\n\t\t\t\telse opstack.push(sop);\n            }\n            else a += q[j];\n        }\n\t\tfor(string s : exq){\n\t\t\tif(s[0] < '0' || '9' < s[0]){\n\t\t\t\tint x, y;\n\t\t\t\ty = numstack.top();\n\t\t\t\tnumstack.pop();\n\t\t\t\tx = numstack.top();\n\t\t\t\tnumstack.pop();\n\t\t\t\tif(s == \"+\"){\n\t\t\t\t\tnumstack.push(x + y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"-\"){\n\t\t\t\t\tnumstack.push(x - y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"*\"){\n\t\t\t\t\tnumstack.push(x * y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"/\"){\n\t\t\t\t\tnumstack.push(x / y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse numstack.push(stoi(s));\n\t\t}\n\t\tcout << numstack.top() << endl;\n\t\tnumstack.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#define _USE_MATH_DEFINES\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nll inf = llmax / 2;\ndouble eps = 1e-11;\n\nstring S = \"12+1290\";\nint cur = 0;\n\nint digit() {\n    assert(isdigit(S[cur]));\n    int n = S[cur] - '0';\n    cur++;\n    return n;\n}\n\nll number() {\n    ll n = digit();\n    while (cur < S.size() && isdigit(S[cur])) {\n        n = n * 10 + digit();\n    }\n    return n;\n}\n\nll expression();\n\nll factor() {\n    if (S[cur] != '(') {\n        return number();\n    }\n    cur++;\n    int n = expression();\n    assert(S[cur] == ')');\n    cur += 1;\n    return n;\n}\n\nll term() {\n    ll a = factor();\n    while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n        char op = S[cur];\n        cur++;\n        ll b = factor();\n        if (op == '*') {\n            a *= b;\n        } else {\n            a /= b;\n        }\n    }\n    return a;\n}\n\nll expression() {\n    ll a = term();\n    while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n        char op = S[cur];\n        cur++;\n        ll b = term();\n        if (op == '+') {\n            a += b;\n        } else {\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> S;\n        cur = 0;\n        ll ans = expression();\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\nint expression();\nint digit();\nint number();\nint parse();\nint term();\nint factor();\n\nint main(){\n  int n;\n  cin >> n;\n  for (int i=0; i<n; i++){\n    cin >> S;\n    int a = parse();\n    //  assert (a == 15);\n    assert (cur == S.size()-1);\n    cout << a << endl;\n    cur = 0;\n  }\n}\n\nint digit(){\n  assert (isdigit(S[cur]));\n  int n = S[cur] - '0';\n  cur = cur+1;\n  return n;\n}\n\nint number(){\n  int n = digit();\n  while(cur < S.size()-1 && isdigit(S[cur]))\n    n = n*10 + digit();\n  return n;\n}\n\nint expression(){\n  int sum = term();\n  while (S[cur] == '+' || S[cur] == '-'){\n    char op = S[cur];\n    cur += 1;\n    int b = term();\n    assert(op == '+' || op == '-');\n    if (op == '+')  sum += b;\n    else sum -= b;\n  }\n  return sum;\n}\n\nint term(){\n  int a = factor();\n  while ( cur < S.size()-1 && (S[cur] == '*' || S[cur] == '/') ){\n    char op = S[cur++];\n    int b = factor();\n    if (op == '*') a *= b; else a /= b;\n  }\n  return a;\n}\n\nint factor(){\n  if (S[cur] != '(') return number();\n  cur += 1;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur += 1;\n  return n;\n}\n\nint parse(){\n  return expression();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint exp();\nint term();\nint factor();\nint number();\nint digit();\n\nstring str;\n\nint p,len,val;\n\nint exp(){\n  int val = term();\n  while( str[p] == '+' || str[p] == '-' ){\n    if( str[p] == '+' ){\n      p++;\n      val += term();\n    }else if( str[p] == '-' ){\n      p++;\n      val -= term();\n    }\n  }\n  return val;\n}\n\nint term(){\n  int val=factor();\n  while( str[p] == '*' || str[p] == '/' ){\n    if( str[p] == '*' ){\n      p++;\n      val *= factor();\n    }else if( str[p] == '/' ){\n      p++;\n      val /= factor();\n    }\n  }\n  return val;\n}\n\nint factor(){\n  int val;\n  if( str[p] == '(' ){\n      p++;\n      val =  exp();\n      p++;\n  }else{\n    val = number();\n  }\n\n  return val;\n}\n\nint number(){\n  int val = 0;\n  while( digit() ){\n    int num = str[p] - '0';\n    val = val * 10 + num;\n    p++;\n  }\n  return val;\n}\n\nint digit(){\n  if( str[p] == '1' || str[p] == '2' || str[p] == '3' || str[p] == '4' ||\n      str[p] == '5' || str[p] == '6' || str[p] == '7' || str[p] == '8' ||\n      str[p] == '9' || str[p] == '0' ) return 1;\n  return 0;\n}\n\n  \nint main(){\n  int n; cin >> n;\n  \n  for(int i = 0; i < n; i++ ){\n    p = 0;\n    cin >> str;\n    \n    int ans = exp();      \n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nLL plusub(void);\nLL muldiv(void);\nLL parent(void);\nLL number(void);\n\nint ind;\nstring str;\n\nLL plusub(void){\n  LL a=muldiv();\n  if(str[ind]=='+'){\n    ++ind;\n    return a+plusub();\n  }else if(str[ind]=='-'){\n    ++ind;\n    return a-plusub();\n  }else return a;\n}\n\nLL muldiv(void){\n  LL a=parent();\n  if(str[ind]=='*'){\n    ++ind;\n    return a*muldiv();\n  }else if(str[ind]=='/'){\n    ++ind;\n    return a/muldiv();\n  }else return a;\n}\n\nLL parent(void){\n  if(str[ind]=='('){\n    ++ind;\n    LL a=plusub();\n    ++ind;\n    return a;\n  }else return number();\n}\n\nLL number(void){\n  if('0'<=str[ind] && str[ind]<='9'){\n    LL a=str[ind]-'0';\n    ++ind;\n    LL b=number();\n    if(0<=b&&b<=9) return a*10+b;\n    else return a;\n  }else return -1;\n}\n\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(i,n){\n    ind=0;\n    cin >> str;\n    cout << plusub() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &begin);// 四則演算の式をパースして、その評価結果を返す。\nint term(State &begin);// 乗算除算の式をパースして、その評価結果を返す。\nint factor(State &begin);// 括弧か数をパースして、その評価結果を返す。\nint number(State &begin);//数字の列をパースして、その数を返す\n\n\n\n//数字の列をパースして、その数を返す\nint number(State &begin){\n\tint ret =0;\n\twhile(isdigit(*begin)){\n\t\tret *=10;\n\t\tret += *begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\n\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(State &begin) {\n\tint ret =factor(begin);\n\n\tfor(;;){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret *=factor(begin);\n\t\t}else if(*begin =='/'){\n\t\t\tbegin++;\n\t\t\tret /=factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin) {\n\tint ret =term(begin);\n\n\tfor(;;){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret +=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret -=term(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin){\n\tint ret = 0;\n\tif(*begin=='('){\n\t\tbegin++;//'('を飛ばす\n\t\tret =expression(begin);\n\t\tbegin++;//')'を飛ばす\n\t}else{\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tcin.ignore();\n\tfor(int i =0;i <n;i++){\n\t\tstring s;\n\t\tgetline(cin, s);\n\n\t\tState begin= s.begin();\n\t\tint ans =expression(begin);\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef string::const_iterator State;\nclass ParseError {};\n \ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n \nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n \nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n \nint number(State &begin) {\n    int ret = 0;\n \n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n \nint term(State &begin) {\n    int ret = factor(begin);\n \n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n \nint expression(State &begin) {\n    int ret = term(begin);\n \n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n \n    return ret;\n}\n \nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('?????£???????´\\????????£????´???£??????°?????£?????????£?????\n        int ret = expression(begin);\n        begin++; // ')'?????£???????´\\????????£????´???£??????°?????£?????????£?????\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n \nint main(void) {\n    int N;\n    cin >> N;\n    cin.ignore();\n    for (int i = 0; i < N; i++) {\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        cout << expression(begin) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <math.h>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nstring S;\nsize_t cur=0;\nint parse();\n\nint digit(){\n    assert(isdigit(S[cur]));\n    int n=S[cur]-'0';\n    cur++;\n    return n;\n}\n\nint number(){\n    int n=digit();\n    while(cur<S.size()&&isdigit(S[cur]))\n\tn=n*10+digit();\n    return n;\n}\n\nint expression();\nint factor(){\n\tif(S[cur]!='(')return number();\n\tcur++;\n\tint n=expression();\n\tassert(S[cur]==')');\n\tcur++;\n\treturn n;\n}\n\nint term(){\n    int a=factor();\n    while(cur<S.size()&&(S[cur]=='*'||S[cur]=='/')){\n\t\tchar op=S[cur++];\n\t\tint b=factor();\n\t\tif(op=='*')a*=b; else a/=b;\n    }\n    return a;\n}\n\nint expression(){\n    int a=term();\n    while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n\tchar op=S[cur++];\n\tint b=term();\n\tif(op=='+')a+=b; else a-=b;\n    }\n    return a;\n}\n\nint main() {\n    while(cin>>S){\n\tcur=0;\n\tcout<<expression()<<endl;\n    }\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    p=0;\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val;\n  if(str[p]=='('){\n    p++;\n    val=exp();\n    p++;\n  }else{\n    val=digit();\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  return val;\n}\nint digit(){\n  int ret,cnt=0;\n  while(1){\n    if(cnt==0&&'0'<=str[p]&&str[p]<='9'){\n      ret=str[p]-'0';\n      p++;\n      cnt=1;\n    }\n    else if(cnt==1&&'0'<=str[p]&&str[p]<='9'){\n      ret=ret*10+(str[p]-'0');\n      p++;\n    }\n    else{\n      break;\n    }\n  }\n  /*  if('0' <= str[p] && str[p] <= '9') {\n    if(cnt==0){\n      ret=str[p]-'0';\n      cnt=1;\n    }\n    p++;\n    if('0' <= str[p] && str[p] <= '9') {\n      ret=ret*10+(str[p]-'0');\n      digit();\n    }\n    return ret;\n    }*/\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\treturn(stoi(in[0]));\n}\nint main()\n{\n\tstring input;\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint cur;\nstring s;\n\nint digit();\nint number();\nint factor();\nint term();\nint expression();\n\nint digit() {\n\treturn ( s[cur++] - '0' );\n}\n\nint number() {\n\tint n = digit();\n\twhile ( isdigit( s[cur] ) )\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint factor() {\n\tint n;\n\tif ( s[cur] == '(' ) {\n\t\tcur++;\n\t\tn = expression();\n\t\tcur++;\n\t} else\n\t\tn = number();\n\treturn n;\n}\n\nint term() {\n\tint n = factor();\n\twhile ( s[cur] == '*' || s[cur] == '/' ) {\n\t\tcur++;\n\t\tif ( s[cur - 1] == '*' )\n\t\t\tn *= factor();\n\t\telse\n\t\t\tn /= factor();\n\t}\n\treturn n;\n}\n\nint expression() {\n\tint n = term();\n\twhile ( s[cur] == '+' || s[cur] == '-' ) {\n\t\tcur++;\n\t\tif ( s[cur - 1] == '+' )\n\t\t\tn += term();\n\t\telse\n\t\t\tn -= term();\n\t}\n\treturn n;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcur = 0;\n\t\tcin >> s;\n\t\tint m = expression();\n\t\tcout << m << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])!=-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=isNum(s[oi]);\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int n;\n    string q, a, sop;\n    stack<int> numstack;\n    stack<string> opstack;\n    map<string, int> oprank;\n\tvector<string> exq;\n    oprank[\"/\"] = oprank[\"*\"] = 2;\n    oprank[\"+\"] = oprank[\"-\"] = 1;\n\toprank[\"(\"] = 0;\n    cin >> n;\n    for(int i(0);i < n;++i){\n        cin >> q;\n\t\texq.clear();\n\t\topstack.push(\"NOP\");\n        a = \"\";\n        for(int j(0);j < q.length();++j){\n            if(q[j] < '0' || '9' < q[j]){\n                if(a.length() > 0) exq.push_back(a);\n                a = \"\";\n\t\t\t\tsop = string(1, q[j]);\n                if(!opstack.empty() && opstack.top() == \"NOP\"){\n\t\t\t\t\topstack.pop();\n\t\t\t\t\topstack.push(sop);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(sop == \")\"){\n\t\t\t\t\twhile(opstack.top() != \"(\"){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t\topstack.pop();\n\t\t\t\t}\n\t\t\t\telse if(sop == \"(\") opstack.push(sop);\n\t\t\t\telse if(sop == \"=\"){\n\t\t\t\t\twhile(!opstack.empty()){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(oprank[sop] <= oprank[opstack.top()]){\n\t\t\t\t\twhile(!opstack.empty() && oprank[sop] <= oprank[opstack.top()]){\n\t\t\t\t\t\texq.push_back(opstack.top());\n\t\t\t\t\t\topstack.pop();\n\t\t\t\t\t}\n\t\t\t\t\topstack.push(sop);\n\t\t\t\t}\n\t\t\t\telse opstack.push(sop);\n            }\n            else a += q[j];\n        }\n\t\tfor(string s : exq){\n\t\t\tif(s[0] < '0' || '9' < s[0]){\n\t\t\t\tint x, y;\n\t\t\t\ty = numstack.top();\n\t\t\t\tnumstack.pop();\n\t\t\t\tx = numstack.top();\n\t\t\t\tnumstack.pop();\n\t\t\t\tif(s == \"+\"){\n\t\t\t\t\tnumstack.push(x + y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"-\"){\n\t\t\t\t\tnumstack.push(x - y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"*\"){\n\t\t\t\t\tnumstack.push(x * y);\n\t\t\t\t}\n\t\t\t\telse if(s == \"/\"){\n\t\t\t\t\tnumstack.push(x / y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse numstack.push(stoi(s));\n\t\t}\n\t\tcout << numstack.top() << endl;\n\t\tnumstack.pop();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= term(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= term(begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tState s = str.begin();\n\t\tcout << expression(s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::iterator si;\n\nint expr(si& cur, si end);\n\nint num(si& cur, si end){\n    int ans = 0;\n    while(cur != end && isdigit(*cur)){\n        ans *= 10;\n        ans += *cur-'0';\n        cur++;\n    }\n    return ans;\n}\n\nint fact(si& cur, si end){\n    int ans = 1;\n    if(*cur == '('){\n        cur++;\n        ans *= expr(cur, end);\n        cur++;\n    } else {\n        ans *= num(cur, end);\n    }\n    return ans;\n}\n\nint term(si& cur, si end){\n    int ans = 1;\n    char op = '*';\n    while(1){\n        int f = fact(cur,end);\n\n        if(op == '*') ans *= f;\n        else ans /= f;\n        if(cur == end || *cur == ')' ||  (*cur != '*' && *cur != '/')) break;\n        else op = *cur;\n        cur++;\n    }\n    return ans;\n}\n\nint expr(si& cur, si end){\n    int ans = 0;\n    char op = '+';\n    while(1){\n        int t = term(cur, end);\n\n        if(op == '+') ans += t;\n        else ans -= t;\n\n        if(cur == end || *cur == ')') break;\n        else op = *cur;\n        cur++;\n    }\n    return ans;\n}\n\n\n\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>> s;\n        si b = s.begin();\n        cout << expr(b, s.end()-1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nclass Parser {\npublic:\n\tusing Iter = string::const_iterator;\n\tIter it;\n\tParser(Iter it) :it(it) {}\n\tvoid cmp(char expected) { assert(*it == expected); }\n\t/*\n\tEBNF\n\t???=???,[\"+\"|\"-\",???] | \"(\",???,[\"+\"|\"-\",???],\")\"\n\t???=c,[\"*\"|\"/\",???]\n\tc=??°|\"(\",???,\")\"\n\t*/\n\tint a() {\n\t\tint ret = b();\n\t\tif (*it == '+') {\n\t\t\tit++;\n\t\t\tret += a();\n\t\t}\n\t\telse if (*it == '-') {\n\t\t\tit++;\n\t\t\tret -= a();\n\t\t}\n\t\treturn ret;\n\t}\n\tint b() {\n\t\tint ret = c();\n\t\tif (*it == '*') {\n\t\t\tit++;\n\t\t\tret *= b();\n\t\t}\n\t\telse if (*it == '/') {\n\t\t\tit++;\n\t\t\tret /= b();\n\t\t}\n\t\treturn ret;\n\t}\n\tint c() {\n\t\tint ret;\n\t\tif (*it == '(') {\n\t\t\tit++;\n\t\t\tret = a();\n\t\t\tcmp(')');\n\t\t\tit++;\n\t\t}\n\t\telse ret = integer();\n\t\treturn ret;\n\t}\n\tint integer() {\n\t\tint ret = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tret *= 10;\n\t\t\tret += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tint n; cin >> n; cin.ignore();\n\tfor (string s; getline(cin, s) && s != \"$\"; ) {\n\t\ts += \"$\";\n\t\tParser P(s.begin());\n\t\tcout << P.a() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint n;\nstring str;\n\nint factor(State &begin);\nint number(State &begin);\nint term(State &begin);\nint expressin(State &begin);\n\nint factor(State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(string& s,State &i);\nDef term(string& s,State &i);\nDef factor(string& s,State &i);\nDef number(string& s,State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(string& s,State &i){\n\tDef out=term(s,i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(s,i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(string& s,State &i){\n\tDef out=factor(s,i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(s,i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(string& s,State &i){\n\tif(isdigit(*i))return number(s,i);\n\t//'('\n\ti++;\n\tDef out=expr(s,i);\n\ti++;\n\treturn out;\n}\nDef number(string& s,State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s,s.begin())<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nclass CalcExpression\n{\n\ttypedef string::const_iterator State;\n\tclass ParseError {};\n\n\npublic:\n\n\tint expression(State& begin)\n\t{\n\t\tint ret = term(begin);\n\n\t\twhile(true)\n\t\t{\n\t\t\tif(*begin == '+')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret += term(begin);\n\t\t\t}\n\t\t\telse if(*begin == '-')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret -= term(begin);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\nprivate:\n\n\tint term(State& begin)\n\t{\n\t\tint ret = factor(begin);\n\n\t\twhile(true)\n\t\t{\n\t\t\tif(*begin == '*')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret *= factor(begin);\n\t\t\t}\n\t\t\telse if(*begin == '/')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret /= factor(begin);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tint factor(State &begin)\n\t{\n\t\tint ret = 0;\n\n\t\tif(*begin == '(')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret = expression(begin);\n\t\t\tbegin++;\n\t\t}\n\t\telse return number(begin);\n\n\t\treturn ret;\n\t}\n\n\tint number(State& begin)\n\t{\n\t\tint ret = 0;\n\n\t\twhile(isdigit(*begin))\n\t\t{\n\t\t\tret *= 10;\n\t\t\tret += *begin - '0';\n\t\t\tbegin++;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tCalcExpression ce;\n\twhile(n--)\n\t{\n\t\tstring expression, buf;\n\n\t\tcin >> expression;\n\t\tstring::const_iterator it = expression.begin();\n\n\t\tcout << ce.expression(it) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\n#include <complex>\n#include <utility>\n#include <numeric>\n#define  rep(i,n) for(int i=0;i<(n);i++)\n#define  REP(i,a,n) for(int i=a;i<(n);i++)\n#define  rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define  VI\tvector<int>\n#define\t VS vector<string>\n#define  all(a) (a).begin(),(a).end()\n#define  debug(x) cout<<#x<<\": \"<<x<<endl\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\nclass ParseError {};\nconst int INF=1e9;\nchar fi[101][101];\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\ndouble EPS = 1e-10;\nint N,M;\nint sx,sy;\nint gx,gy;\nint w,h;\nint ans;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int MAX_V=100;\nconst int MAX_N=100;\nchar o[3]={'+','-','*'};\n#define md 1000003\n\n\nint dp[353][353]={0};\nint bow[353][353]={0};\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))\n\treturn 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\t\tP(double x,double y):x(x),y(y){\n\t\t}\n\t\tP operator + (P p){\n\t\t\treturn P(add(x,p.x),add(y,p.y));\n\t\t}\n\t\tP operator - (P p){\n\t\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t\t}\n\t\tP operator *(double d){\n\t\t\treturn P(x*d,y*d);\n\t\t}\n\t\tdouble dot(P p){\n\t\t\treturn add(x*p.x,y*p.y);\n\t\t}\n\t\tdouble det(P p){\n\t\t\treturn add(x*p.y,-y*p.x);\n\t\t}\n};\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x) return p.x<q.x;\n\treturn p.y<q.y;\n}\n\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps,ps+n,cmp_x);\n\tint k=0;\n\tvector<P> \tqs(n*2);\n\t\n\trep(i,n){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint n,m;\nvector<double> p;\nP ps[101];\nchar c[520][520];\nlong long mod=1000000007;\nlong long pow(ll i,ll j){\n\tll tmp=1;\n\twhile(j){\n\t\tif(j%2) tmp=tmp*i%mod;\n\t\ti=i*i%mod;\n\t\tj/=2;\n\t}\n\treturn tmp;\n}\nint cards[10];\nbool ok;\nvoid saiki(int deep){\n\tif(deep==4){\n\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i=1;i<=7;i++){\n\t\tif(cards[i]>0&&cards[i+1]>0&&cards[i+2]>0){\n\t\t\tcards[i]--;\n\t\t\tcards[i+1]--;\n\t\t\tcards[i+2]--;\n\t\t\tsaiki(deep+1);\n\t\t\tcards[i]++;\n\t\t\tcards[i+1]++;\n\t\t\tcards[i+2]++;\n\t\t}\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tif(cards[i]>2){\n\t\t\t\tcards[i]-=3;\n\t\t\t\tsaiki(deep+1);\n\t\t\t\tcards[i]+=3;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\nint expression(State&);\nint term(State&);\nint factor(State&);\nint number(State&);\nint expression(State &begin){\n\tint ret = term(begin);\n\t\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\t\n\tfor(;;){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tint ret;\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse\n\tret = number(begin);\n\t\n\treturn ret;\n\n}\n\nint number(State &begin){\n\tint ret =0;\n\t\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\t\n\tint n;\n\tcin>>n;\n\tcin.ignore();\n\trep(i,n){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\t\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x);\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\twhile (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\twhile (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '(') {\n\t\ti++;\n\t\tval1 = siki(str, i);\n\t\ti += 2;\n\t}\n\telse {\n\t\t val1 = number(str, i);\n\t}\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tval1 = val1 * 10;\n\t\t\tval1 += number(str, i);\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint p;\nstring exp;\n\nint term();\nint expression();\nint factor();\n\n\nint expression(){\n     int value;\n\t value=term();\n\t while(exp[p]=='+' || exp[p]=='-'){\n\t\t if(exp[p]=='+'){\n\t\t\t p++;\n\t\t\t value+=term();\n\t\t }\n\t\t else{\n\t\t\t p++;\n\t\t\t value-=term();\n\t\t }\n\t }\n\t p++;\n\t return value;\n}\n\n\nint term(){\n\tint value;\n\tvalue=factor();\n\twhile(exp[p]=='*' || exp[p]=='/'){\n\t\tif(exp[p]=='*'){\n\t\t\tp++;\n\t\t\tvalue*=factor();\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\tvalue/=factor();\n\t\t}\n\t}\n\n\treturn value;\n}\n\nint factor(){\n\tint value=0;\n\tif(exp[p]=='('){\n\t\tvalue=expression();\n\t}\n\telse{\n\t\twhile(isdigit(exp[p])){\n\t\t\tvalue=value*10+exp[p++]-'0';\n\t\t}\n\t}\n\treturn value;\n}\n\n\n\nint main()\n{\n\tint i,c;\n\tcin>>c;\n\tfor(i=0;i<c;i++){\n\t\tcin>>exp;\n\t\tp=0;\n\t\tcout<<expression()<<\"\\n\";\n\t\t}\n\tcout<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint n;\nstring str;\n\nint factor(const State &begin);\nint number(const State &begin);\nint term(const State &begin);\nint expressin(const State &begin);\n\nint factor(const State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(const State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(const State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(const State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define all(a) (a).begin() ,(a).end()\n\nconst double eps = 1e-10;\nconst double inf = (int)1e8;\n \nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n    int ret = 0;\n    \n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin ++;\n    }\n    return ret;\n}\n\nint term(State & begin){\n    int ret = factor(begin);\n    \n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret = term(begin);\n    \n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++; \n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint main(void){\n    int n;\n    string s;\n    cin>>n;\n    getline(cin,s);\n    while(n--){\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint expression(State &begin){\n    int ret = term(begin);\n\n    while(1){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint term(State &begin){\n    int ret = factor(begin);\n\n    while(1){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;    // (\n        int ret = expression(begin);\n        begin++;    // )\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nint number(State &begin){\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret = ret*10 + (*begin - '0');\n        begin++;\n    }\n\n    return ret;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    cin.ignore();\n\n    for(int i = 0; i < n; i++){\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint factor(State &begin);\n\n// ??°?????????????????????\nint number(State &begin) {\n    int ret = 0;\n    while(isdigit(*begin)) {\n        ret *= 10;\n        ret += (*begin - '0');\n        begin++;\n    }\n    return ret;\n}\n\n// ??¬??§?????°????????????\nint factor(State &begin) {\n    if(*begin == '(') {\n        begin++; // '(' ????£???°???\n        int ret = expression(begin);\n        begin++; // ')' ????£???°???\n        return ret;\n    }\n    else return number(begin);\n}\n\n// ??????????????????????????????\nint term(State &begin) {\n    // ????????????????????¨????????£????????°??????????????§???????????????\n    // begin ?????????????????°?????§???????????????\n    int ret = factor(begin);\n\n    while(1) {\n        if(*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else break;\n    }\n\n    return ret;\n}\n\n// ??????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n    while(1) {\n        if(*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else break;\n    }\n    return ret;\n}\n\nsigned main() {\n    int N; cin >> N;\n    rep(i,0,N) {\n        string s; cin >> s;\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <numeric>\n#include <queue>\n#include <complex>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef complex<double> Point;\n\nint calculate(const char* str, int begin, int end);\nint getNumber(const char* str, int begin, int end)\n{\n\tbool minus = false;\n\t\n\tif(str[begin] == '('){\n\t\tint depth = 1;\n\t\tint index;\n\t\tfor(index=begin+1; depth; ++index){\n\t\t\tdepth += str[index] == '(';\n\t\t\tdepth -= str[index] == ')';\n\t\t}\n\t\treturn calculate(str, begin+1, index-1);\n\t}\n\telse if(str[begin] == '-'){\n\t\tminus = true;\n\t\t++begin;\n\t}else if(str[begin] == '+')\n\t\t++begin;\n\t\n\tint num = 0;\n\tfor(int i=begin; i<end && isdigit(str[i]); ++i)\n\t\tnum = num*10 + str[i] - '0';\n\tif(minus)\n\t\tnum *= -1;\n\treturn num;\n}\n\nint getTerm(const char* str, int begin, int end)\n{\n\tint num = 1;\n\tint index = begin;\n\tint depth = 0;\n\tchar operation = '*';\n\tfor(int i=begin; i<=end; ++i){\n\t\tif(i<end){\n\t\t\tdepth += str[i] == '(';\n\t\t\tdepth -= str[i] == ')';\n\t\t}\n\t\t\n\t\tif(depth == 0){\n\t\t\tif(i==end || str[i] == '*' || str[i] == '/'){\n\t\t\t\tif(operation == '*')\n\t\t\t\t\tnum *= getNumber(str, index, i);\n\t\t\t\tif(operation == '/')\n\t\t\t\t\tnum /= getNumber(str, index, i);\n\t\t\t\tif(i<end)\n\t\t\t\t\toperation = str[i];\n\t\t\t\tindex = i+1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn num;\n}\n\nint calculate(const char* str, int begin, int end)\n{\n\tint num = 0;\n\tint index = begin;\n\tint depth = 0;\n\tchar operation = '+';\n\tfor(int i=begin; i<=end; ++i){\n\t\tif(i<end){\n\t\t\tdepth += str[i] == '(';\n\t\t\tdepth -= str[i] == ')';\n\t\t}\n\t\tif(depth == 0){\n\t\t\tif(i==end || str[i] == '+' || str[i] == '-'){\n\t\t\t\tif(operation == '+')\n\t\t\t\t\tnum += getTerm(str, index, i);\n\t\t\t\tif(operation == '-')\n\t\t\t\t\tnum -= getTerm(str, index, i);\n\t\t\t\tif(i<end)\n\t\t\t\t\toperation = str[i];\n\t\t\t\tindex = i+1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn num;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tchar str[128];\n\t\tscanf(\"%s\", str);\n\t\tprintf(\"%d\\n\", calculate(str, 0, strlen(str)-1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n\n//const string S = \"1+2+3\";\n//const string S = \"1*5+2+3\";\n/*const*/ string S;\nsize_t cur = 0; //解析開始位置\n\nint digit() {\n  assert(isdigit(S[cur])); //S[cur]が数字であることの確認\n  int n = S[cur] - '0'; //'0'を0に変換\n  cur = cur + 1;\n  return n;\n  }\n  \nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur])) //次も数字か1文字先読\n   n = n*10 + digit();\n  return n;\n  }\n  \nint term() {\n  int a = number();\n  while (cur < S.size()\n    && (S[cur] == '*' || S[cur] == '/')) {\n\t  char op = S[cur++];\n\t  int b = number();\n\t  if (op == '*') a *= b; else a /= b;\n\t  }\n  return a;\n  }\n  \nint expression() {\n  int a = term();\n  while ((cur < S.size())&&(S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++];\n\tint b = term();\n\tif (op == '+'){\n      a += b;\n\t }\n\telse{\n\t  a -= b;\n\t  }\n\t}\n  return a;\n  }\n  \nint ezpression(); //前方宣言\n\nint factor() {\n  if (S[cur] != '(') return number();\n  cur += 1;\n  int n = expression();\n  assert(S[cur] == ')');\n  cur += 1;\n  return n;\n  }\n\nint parse() {return expression(); }\n\nint main() {\n   int N;\n   cin >> N;\n   for (int i=0; i<N; ++i){\n     cur = 0;\n\t cin >> S;\n\t S.resize(S.size()-1); //最後の=属性を無視\n\t cout << expression() << endl;\n  }\n }\n  \n/*\n\n コンパイルは通るが、\nAssertion failed: (isdigit(S[cur])), function digit, file 12-1-1-1.cc, line 10.\nAbort trap: 6\nと表示されてうまくいかない。\nどうしてでしょうか?\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    // s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << number(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(string delim,string str){\n\tvector<string> res;\n\tstr += delim;\n\tfor(int i=0;i<str.size();i++){\n\t\tfor(int j=1;i+j<=str.size();j++){\n\t\t\tif(str.substr(i,j).find_first_of(delim) != string::npos){\n\t\t\t\t//cout << str.substr(i,j) << endl;\n\t\t\t\tif(str.substr(i,j-1).size() > 0 ) res.push_back(str.substr(i,j-1));\n\t\t\t\ti+=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstring calc(vector<string> v){\n\tstack<string> stk;\n\tfor(int i=0;i<v.size();i++){\n\t\tll num1;\n\t\tll num2;\n\t\tchar buf[256];\n\t\tstring res;\n\t\tif(v[i]==\"-\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2-num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2+num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"*\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2*num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse if(v[i]==\"/\"){\n\t\t\tstring str1 = stk.top();\n\t\t\tstk.pop();\n\t\t\tstring str2 = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tsscanf(str1.c_str(),\"%lld\",&num1);\n\t\t\tsscanf(str2.c_str(),\"%lld\",&num2);\n\n\t\t\tsprintf(buf,\"%lld\",num2/num1);\n\t\t\tres = buf;\n\t\t\t\n\t\t\tstk.push(res);\n\t\t}\n\t\telse{\n\t\t\tstk.push(v[i]);\n\t\t}\n\t}\n\treturn stk.top();\n}\n\nvector<string> rvs_polish(string str){\n\tstack<string> stk;\n\tvector<string> v;\n\n\tstring tmp=\"\";\n\tvector<string> res;\n\tif(str[0]=='-'){\n\t\tstr='0'+str;\n\t}\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='*'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"*\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='/'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"/\");\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]=='*' || str[i-1]=='/' || str[i-1]=='-')){\n\t\t\ttmp+='-';\n\t\t}\n\n\t\telse if(str[i]=='-' && (str[i-1]!='*' && str[i-1]!='/' && str[i-1]!='-')){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"-\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse if(str[i]=='+'){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"+\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\t\telse if(str[i]=='='){\n\t\t\tv.push_back(tmp);\n\t\t\tv.push_back(\"=\");\t\t\t\n\t\t\ttmp=\"\";\n\t\t}\n\n\t\telse{\n\t\t\ttmp+=str.substr(i,1);\n\t\t}\n\t}\n\n\tv.push_back(tmp);\n\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i]==\"*\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\"){\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"*\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"/\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"/\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring opr = stk.top();\n\t\t\t\tif(opr == \"-\" || opr == \"+\" || opr == \"*\"){\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstk.push(\"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if(v[i]==\"-\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"-\");\n\t\t\t}\n\t\t}\n\t\telse if(v[i]==\"+\"){\n\t\t\tif(stk.empty()){\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(!stk.empty()){\n\t\t\t\t\tres.push_back(stk.top());\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tstk.push(\"+\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tres.push_back(v[i]);\n\t\t}\n\t}\n\n\twhile(!stk.empty()){\n\t\tres.push_back(stk.top());\n\t\tstk.pop();\n\t}\n\n\treturn res;\n}\n\nvoid dfs(string str){\n\tstack<P> stk;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='(') {stk.push(P('(',i));}\n\t\telse if(str[i]==')') {\n\t\t\tchar sym = stk.top().first;\n\t\t\tif(sym != '(') continue;\n\n\t\t\tint pos = stk.top().second;\n\t\t\tstk.pop();\n\n\t\t\tif(str.substr(pos+1,(i-1)-(pos+1)+1).find('(') == string::npos\n\t\t\t\t&& str.substr(pos+1,(i-1)-(pos+1)+1).find(')') == string::npos){\n\t\t\t\t\tvector<string> pol = rvs_polish(str.substr(pos+1,(i-1)-(pos+1)+1));\n\t\t\t\t\tstring num = calc(pol);\n\t\t\t\t\tstr.replace(pos,i-pos+1,num);\n\t\t\t\t\t//cout << str << endl;\n\t\t\t\t\twhile(!stk.empty()) stk.pop();\n\t\t\t\t\ti=-1;\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<string> ans = rvs_polish(str);\n\n\tcout << calc(ans) << endl;\n}\n\nint main(){\n\tstring str;\n\twhile(getline(cin,str)){\n\t\tint n;\n\t\tsscanf(str.c_str(),\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\t\t\tdfs(str.substr(0,str.size()-1));\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\n// Parser<int> number = [](Source &s) {\n//   int val = 0;\n//   while (isdigit(s.peek())) {\n//     val *= 10;\n//     val += s.peek() - '0';\n//     s.next();\n//   }\n//   return val;\n// };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << number(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cassert>\n#include <iostream>\nusing namespace std;\nstring S;\nsize_t cur; //?§£???????§???????\nint digit() {\n  assert(isdigit(S[cur])); //S[cur]?????°?????§???????????¨????¢????\n  int n = S[cur] - '0'; // '0'???0?????????\n  cur = cur + 1; //??????????????????\n  return n;\n}\nint number() {\n  int n = digit();\n  while(cur < S.size() && isdigit(S[cur])) { //?¬??????°??????1???????????????\n    n = n*10 + digit();\n  }\n  return n;\n}\nint expression(); //????????£?¨?\nint factor() {\n  if(S[cur] != '(') {\n    return number();\n  }\n  cur += 1;\n  int n = expression ();\n  assert(S[cur] == ')');\n  cur +=1;\n  return n;\n}\nint term() {\n  int a = factor();\n  while(cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    int b = factor();\n    if(op == '*') {\n      a *= b;\n    }\n    else {\n      a /= b;\n    }\n  }\n  return a;\n}\nint expression() {\n  int a = term();\n  while(cur < S.size() && (S[cur] == '+' || S[cur] =='-')) { //?¶???????????????????????¶???????\n    char op = S[cur++];\n    int b = term();\n    assert(op == '+' || op == '-');\n    if(op == '+') {\n      a += b;\n    }\n    else {\n      a -= b;\n    }\n  }\n  return a;\n}\nint main() {\n  int N;\n  cin >> N;\n  for(int i=0; i<N; ++i) {\n    cur = 0;\n    cin >> S;\n    S.resize(S.size() - 1); //?????????=?????????\n    cout << expression() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <stack>\n#include <regex>\n#include <cctype>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<long long>\n#define vvl vector<vector<long long>>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef string::const_iterator State;\n\n// <四則演算の式>をパース\nint expression(State &);\n// <乗算除算の式>をパース\nint term(State &);\n// <数>をパース\nint number(State &);\n// カッコの中\nint factor(State &);\n\nint main()\n{\n  int N;\n  cin >> N;\n  cin.ignore();\n  REP(i, N)\n  {\n    string s;\n    getline(cin, s);\n    size_t pos;\n    while ((pos = s.find_first_of(\" \")) != string::npos)\n    {\n      s.erase(pos, 1);\n    }\n    State begin = s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint number(State &begin)\n{\n  int res = 0;\n\n  while (isdigit(*begin))\n  {\n    res *= 10;\n    res += *begin - '0';\n    begin++;\n  }\n\n  return res;\n}\n\nint term(State &begin)\n{\n  int res = factor(begin);\n\n  while (true)\n  {\n    switch (*begin)\n    {\n    case '*':\n      begin++;\n      res *= factor(begin);\n      break;\n    case '/':\n      begin++;\n      res /= factor(begin);\n      break;\n    default:\n      return res;\n    }\n  }\n}\n\nint expression(State &begin)\n{\n  int res = term(begin);\n\n  while (true)\n  {\n    switch (*begin)\n    {\n    case '+':\n      begin++;\n      res += term(begin);\n      break;\n    case '-':\n      begin++;\n      res -= term(begin);\n      break;\n    default:\n      return res;\n    }\n  }\n}\n\nint factor(State &begin)\n{\n  if (*begin == '(')\n  {\n    begin++;\n    int res = expression(begin);\n    begin++;\n    return res;\n  }\n  else\n  {\n    return number(begin);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n/*\nDigit := '0' | '1' | ... | '9'\nNumber := Digit { Digit }\nExpression := Term { ('+'|'-') Term }\nTerm := Factor { ('*'|'/') Factor }\nFactor := '(' Expression ')' | Number\n*/\n\nstring S;\nsize_t cur=0;\n\nint digit();\nint number();\nint expression();\nint term();\nint factor();\n\nint digit(){\n    assert(isdigit(S[cur]));\n    int n=S[cur]-'0';\n    cur++;\n\n    return n;\n}\n\nint number(){\n    int n=digit();\n    while(cur<S.length() && isdigit(S[cur]))\n        n=n*10+digit();\n    \n    return n;\n}\n\nint expression(){\n    int n=term();\n    while(cur<S.length() && (S[cur]=='+' || S[cur]=='-')){\n        if(S[cur]=='+'){\n            cur++;\n            n=n+term();\n        }else{\n            cur++;\n            n=n-term();\n        }\n    }\n\n    return n;\n}\n\nint term(){\n    int n=factor();\n    while(cur<S.length() && (S[cur]=='*' || S[cur]=='/')){\n        if(S[cur]=='*'){\n            cur++;\n            n=n*factor();\n        }else{\n            cur++;\n            n=n/factor();\n        }\n    }\n\n    return n;\n}\n\nint factor(){\n    if(S[cur]=='('){\n        cur++;\n        int n=expression();\n        assert(S[cur]==')');\n        cur++;\n\n        return n;\n    }else{\n        return number();\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cur=0;\n        cin >> S;\n        S.resize(S.length()-1);\n\n        cout << expression() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    return 0;\n}\n\n// class Mycin {\n// \tbool flag = true;\n// public:\n// \tMycin& operator >> (int& a) {flag = scanf(\"%lld\", &a) != EOF; return *this;}\n// \tMycin& operator >> (char& a) {flag = scanf(\"%c\", &a) != EOF; return *this;}\n// \tMycin& operator >> (string& s) {flag = (bool)(cin >> s); return *this;}\n// \toperator bool() {return flag;}\n// } mycin;\n \n// class Mycout {\n// public:\n// \tMycout& operator << (const int& a) {printf(\"%lld\", a); return *this;}\n// \tMycout& operator << (const char c) {printf(\"%c\", c); return *this;}\n// \tMycout& operator << (const string& s) {printf(\"%s\", s.c_str()); return *this;}\n// } mycout;\n \n// #define cin mycin\n// #define cout mycout\n// #define endl '\\n'\n\nint number(const string& s, int& i);\nint factor(const string& s, int& i);\nint term(const string& s, int& i);\nint expr(const string& s, int& i);\n\nint number(const string& s, int& i) {\n    int res = 0;\n    for (; isdigit(s[i]); i++) {\n        res *= 10;\n        res += s[i] - '0';\n    }\n    return res;\n}\n\nint factor(const string& s, int& i) {\n    if (isdigit(s[i])) return number(s, i);\n    i++;\n    int res = expr(s, i);\n    i++;\n    return res;\n}\n\nint term(const string& s, int& i) {\n    int res = factor(s, i);\n    while (s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        i++;\n        int a = factor(s, i);\n        if (op == '*') res *= a;\n        else           res /= a;\n    }\n    return res;\n}\n\nint expr(const string& s, int& i) {\n    int res = term(s, i);\n    while (s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        i++;\n        int a = term(s, i);\n        if (op == '+') res += a;\n        else           res -= a;\n    }\n    return res;\n}\n\nint eval(const string& s) {\n    int i = 0;\n    return expr(s, i);\n}\n\nvoid solve() {\n    int N;\n    string s;\n    cin >> N;\n    rep(i, N) {\n        cin >> s;\n        cout << eval(s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint factor(State &begin);\n\n// ??°?????????????????????\nint number(State &begin) {\n    int ret = 0;\n    while(isdigit(*begin)) {\n        ret *= 10;\n        ret += (*begin - '0');\n        begin++;\n    }\n    return ret;\n}\n\n// ??¬??§?????°????????????\nint factor(State &begin) {\n    if(*begin == '(') {\n        begin++; // '(' ????£???°???\n        int ret = expression(begin);\n        begin++; // ')' ????£???°???\n        return ret;\n    }\n    else return number(begin);\n}\n\n// ??????????????????????????????\nint term(State &begin) {\n    // ????????????????????¨????????£????????°??????????????§???????????????\n    // begin ?????????????????°?????§???????????????\n    int ret = factor(begin);\n\n    while(1) {\n        if(*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else break;\n    }\n\n    return ret;\n}\n\n// ??????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n    while(1) {\n        if(*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else break;\n    }\n    return ret;\n}\n\nsigned main() {\n    int N; cin >> N;\n    rep(i,0,N) {\n        string s; cin >> s;\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  while(n--){\n    string s;\n    int p=0;\n    cin>>s;\n    s.pop_back();\n    cout<<expression(s,p)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0])){\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\t//else if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else\n\t//\texit(0);\n\telse{\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\texpr(\"hoge\");\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <stack>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \nint tenp(int n){\n  int ret = 1;\n  REP(i,n)\n    ret *= 10;\n  return ret;\n}\n\nint cal(){\n  stack<int> st;\n  int ope=0;\n  int num;\n  while(true){\n    char c = getchar();\n    if(c == '(' || ('0'<=c && c<= '9') ) {\n      if(c == '(') num = cal();\n      else{\n        int dig=0;\n        int numd[10]={0};\n        numd[0] = (c - '0');\n        while(true){\n          c = getchar();\n          if(!('0'<=c&&c<='9')) break;\n          dig++;\n          numd[dig] = (c - '0');\n        }\n        num = 0;\n        for(int i=dig; i>=0; i--)\n          num+=numd[dig-i] * tenp(i);\n      }\n      if(ope==0){\n        st.push(num);\n      }else if(ope == 1){\n        st.push(-num);\n        ope = 0;\n      }else if(ope == 2){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp * num);\n        ope = 0;\n      }else if(ope == 3){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp / num);\n        ope = 0;\n      }\n    }\n    if(c == ')' ) break;\n    if(c == '=' ){\n      getchar();\n      break;\n    }\n    if(c == '+') ope = 0;\n    if(c == '-') ope = 1;\n    if(c == '*') ope = 2;\n    if(c == '/') ope = 3;\n  }\n  int sum=0;\n  while(!st.empty()){\n    sum += st.top();\n    st.pop();\n  }\n  return sum;\n}\n\nint main(void){  \n  int n;\n  cin >> n;\n  getchar();\n  REP(i,n)\n    cout << cal() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t//cout << t << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tint num1, pos1, pos2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tint pos1, pos2;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc{\nprivate:\n  int idx;\n  string s;\npublic:\n  Calc(string s) : s(s) {\n    idx = 0;\n  }\n  int fact(){\n    int res = 0;\n    if(s[idx] == '('){\n      idx++;\n      res = exp();\n      idx++;\n    }else{\n      while(isdigit(s[idx])){\n        res *= 10;\n        res += s[idx++]-'0';\n      }\n    }\n    return res;\n  }\n\n  int term(){\n    int res = fact();\n    while(s[idx] == '*' || s[idx] == '/'){\n      if(s[idx] == '*'){\n        idx++;\n        res *= fact();\n      }else{\n        idx++;\n        res /= fact();\n      }\n    }\n    return res;\n  }\n\n  int exp(){\n    int res = term();\n    while(s[idx] == '+' || s[idx] == '-'){\n      if(s[idx] == '+'){\n        idx++;\n        res += term();\n      }else{\n        idx++;\n        res -= term();\n      }\n    }\n    return res;\n  }\n\n};\n\nint main(){\n  int Tc;\n  string s;\n  cin >> Tc;\n  while(Tc--){\n    cin >> s;\n    s.resize(s.size()-1);\n    Calc c(s);\n    cout << c.exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstring s;\n\nint conv_stoi(string str){\n  stringstream ss(str);\n  int n;\n  ss >> n;\n  return n;\n}\n\nint parse(int l, int r){\n  int n = 0;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')') n++;\n    if(s[i] == '(') n--;\n    if(!n){\n      if(s[i] == '+') return parse(l,i) + parse(i+1,r);\n      if(s[i] == '-') return parse(l,i) - parse(i+1,r);\n    }\n  }\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')') n++;\n    if(s[i] == '(') n--;\n    if(!n){\n      if(s[i] == '*') return parse(l,i) * parse(i+1,r);\n      if(s[i] == '/') return parse(l,i) / parse(i+1,r);\n    }\n  }\n\n  if(s[l] == '(' && s[r-1] == ')') return parse(l+1,r-1);\n  return conv_stoi(s.substr(l,r-l));\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nbool isdigit(char a){\n    if(a =='0' or a=='1' or a=='2' or a=='3' or a=='4' or a=='5' or a=='6' or a=='7' or a=='8' or a=='9'){\n        return true;\n    }\n    else return false;\n}\n\nint digit(){\n    int n = S[cur] - '0';\n    cur = cur + 1;\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while(cur < S.size() && isdigit(S[cur]))\n        n = n*10 + digit();\n    return n;\n}\nint factor();\n\nint term(){\n    int a = factor();\n    while(cur < S.size() && (S[cur] == '*'|| S[cur] == '/')){\n        char op = S[cur];\n        cur +=1;\n        int b = factor();\n        if(op == '*') a *= b;\n        else a /= b;\n    }\n    return a;\n}\n\nint expression(){\n    int a = term();\n    while(S[cur] == '+'|| S[cur] == '-'){\n        char op = S[cur];\n        cur += 1;\n        int b = term();\n        if (op == '+') a += b;\n        else a -= b;\n    }\n    return a;\n}\n\nint factor(){\n    if (S[cur] !='(') return number();\n    cur += 1;\n    int n = expression();\n    assert(S[cur] == ')');\n    cur += 1;\n    return n;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i=0; i<N; ++i){\n        cur = 0;\n        cin >> S;\n        S.resize(S.size()-1);\n        cout << expression() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint ???(string& s, int& i);\nint ???(string& s, int& i);\nint ?????°(string& s, int& i);\nint ??°(string& s, int& i);\n\nint ???(string& s,int& i) {\n\tint a = ???(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint b = ???(s, i);\n\t\tif (op == '+') {\n\t\t\ta = a+b;\n\t\t}\n\t\telse {\n\t\t\ta = a - b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint ???(string& s, int& i) {\n\tint a = ?????°(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint b = ?????°(s, i);\n\t\tif (op == '*') {\n\t\t\ta = a*b;\n\t\t}\n\t\telse {\n\t\t\ta = a / b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint ?????°(string& s, int& i) {\n\tif (isdigit(s[i])) {\n\t\tint a = ??°(s, i);\n\t\treturn a;\n\t}\n\telse {\n\t\ti++;//(\n\t\tint a = ???(s, i);\n\t\ti++;//)\n\t\treturn a;\n\t}\n}\n\nint ??°(string& s, int& i) {\n\tint a = s[i]-'0';\n\ti++;\n\twhile (isdigit(s[i])) {\n\t\ta = a * 10 + (s[i] - '0');\n\t\ti++;\n\t}\n\treturn a;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tREP(j, n) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tint k = 0;\n\t\tcout << ???(ss, k) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\n/*\n  <num> ::= '1'|'2'|...|'0'\n  <term> ::= <num or kakko> ('*' or '/' ) <num or kakko>\n  <exp> ::= <term> ('+' or '-' ) <term>\n  <kakko> ::= '(' <exp> ')'\n  <factor> ::= <num> or <kakko>\n*/\n\nint number(State&);\nint kakko(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\nint main(){\n  string input;\n  int n,ret;\n  cin >> n;\n  cin.ignore();\n  for(int i = 0;i < n;i++){\n    getline(cin, input);\n    State begin = input.begin();\n    ret = expression(begin);\n    cout << ret << endl;\n  }\n  return 0;\n}\n\n\nint number(State &begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    ++begin;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  int ret = 0;\n  if(*begin == '('){\n    begin++;\n    ret += expression(begin);\n    begin++;\n  }else{\n    return number(begin);\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret = factor(begin);\n  while(true){\n    if(*begin == '*'){\n      ++begin;\n      ret *= factor(begin);\n    }else if(*begin == '/'){\n      ++begin;\n      ret /= factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression(State &begin){\n  int ret = term(begin);\n  while(true){\n    if(*begin == '+'){\n      ++begin;\n      ret += term(begin);\n    }else if(*begin == '-'){\n      ++begin;\n      ret -= term(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\tif(!op.empty())\n\t\tcalc();\n\t//cout << num.top() << endl;//\n\t//int tmp=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring get_term(string, int&);\nint get_num(string);\nint get_exp(string);\n\nint get_num(string str) {\n    int num = 0;\n\n    if (str.size() == 0) return 0;\n\n    int i = 0;\n    if (str[i] == '(') {\n        i++;\n        string exp;\n        for (int count = 1; count; i++) {\n            if (str[i] == '(') count++;\n            if (str[i] == ')') count--;\n            if (count) exp += str[i];\n        }\n\n        num = get_exp(exp + \"=\");\n    } else {\n        for (; i < str.size() && '0' <= str[i] && str[i] <= '9'; i++) {\n            num = num * 10 + (str[i] - '0');\n        }\n    }\n\n    for (; i < str.size(); i++) {\n        if (str[i] == '*') {\n            i++;\n            int tmp = 0;\n            if (str[i] == '(') {\n                i++;\n                string exp;\n                for (int count = 1; count; i++) {\n                    if (str[i] == '(') count++;\n                    if (str[i] == ')') count--;\n                    if (count) exp += str[i];\n                }\n\n                tmp = get_exp(exp + \"=\");\n            } else {\n                for (; i < str.size() && '0' <= str[i] && str[i] <= '9'; i++) {\n                    tmp = tmp * 10 + (str[i] - '0');\n                }\n            }\n            num *= tmp;\n            i--;\n        } else {\n            i++;\n            int tmp = 0;\n            if (str[i] == '(') {\n                i++;\n                string exp;\n                for (int count = 1; count; i++) {\n                    if (str[i] == '(') count++;\n                    if (str[i] == ')') count--;\n                    if (count) exp += str[i];\n                }\n\n                tmp = get_exp(exp + \"=\");\n            } else {\n                for (; i < str.size() && '0' <= str[i] && str[i] <= '9'; i++) {\n                    tmp = tmp * 10 + (str[i] - '0');\n                }\n            }\n            num /= tmp;\n            i--;\n        }\n    }\n\n    return num;\n}\n\n\nvoid solve(string str) {\n    cout << get_exp(str) << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    while (N--) {\n        string str;\n        cin >> str;\n        solve(str);\n    }\n\n    return 0;\n}\n\nstring get_term(string str, int& i) {\n    string init_str;\n    for (int count = 0; i < str.size(); i++) {\n        if (str[i] == '(') count++;\n        if (count > 0 || ('0' <= str[i] && str[i] <= '9') || str[i] == '/' || str[i] == '*') {\n            init_str += str[i];\n        }\n        if (str[i] == ')') count--;\n\n        if (count == 0 && (str[i] == '+'|| str[i] == '-' || str[i] == '=')) {\n            break;\n        }\n    }\n\n    return init_str;\n}\n\nint get_exp(string str) {\n    int num  = 0;\n    int i = 0;\n\n    string init_str = get_term(str, i);\n    num = get_num(init_str);\n\n    while (str[i] != '=') {\n        if (str[i] == '-') {\n            i++;\n            string term = get_term(str, i);\n            num -= get_num(term);\n        } else if (str[i] == '+') {\n            i++;\n            string term = get_term(str, i);\n            num += get_num(term);\n        }\n    }\n\n    return num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Factor();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\n//<expr>   :: = <term>[('+' | '-') <term>] *\n//<term>   :: = <factor>[('*' | '/') <factor>] *\n//<factor> :: = <number> | '(' <expr> ')'\n//<number> : == 1?????\\????????°???\n\n\nll number(string& s, ll& i);\nll term(string& s, ll& i);\nll factor(string& s, ll& i);\nll expr(string& s, ll& i);\n\nll number(string& s, ll& i) {\n\tll n = s[i++] - '0';\n\twhile (isdigit(s[i])) n = n * 10 + s[i++] - '0';\n\treturn n;\n}\n\nll factor(string& s, ll& i) {\n\tif (isdigit(s[i])) return number(s, i);\n\n\t// ????????§?§?????????£???????????° s[i] == '(' ??¨??????\n\ti++; // '('??????????£???°???\n\tll ret = expr(s, i);\n\ti++; // ')'??????????£???°???\n\treturn ret;\n}\n\nll term(string& s, ll& i) {\n\tll val = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = factor(s, i);\n\t\tif (op == '*') val *= val2;\n\t\telse val /= val2;\n\t}\n\treturn val;\n}\n\nll expr(string& s, ll& i) {\n\tll val = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (op == '+') val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\n\nint n;\nll pos = 0;\nstring s;\n\nint main() {\n\tcin >> n;\n\tREP(i,2){\n\t\tcin >> s;\n\t\tpos = 0;\n\t\tcout << expr(s, pos) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint expr();\nint term();\nint factor();\nint num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nint expr(){\n\tdebug(\"expr\");\n\tint x = term();\n\twhile(c < N && (s[c] == '+' || s[c] == '-')){\n\t\tif(s[c] == '+'){\n\t\t\tc++;\n\t\t\tx += term();\n\t\t}\n\t\telse{\n\t\t\tc++;\n\t\t\tx -= term();\n\t\t}\n\t}\n\treturn x;\n}\n\nint term(){\n\tdebug(\"term\");\n\n\tint x = factor();\n\twhile(c < N && (s[c] == '*' || s[c] == '/')){\n\t\tif(s[c] == '*'){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse{\n\t\t\tc++;\n\t\t\tx /= factor();\n\t\t}\n\t}\n\treturn x;\n}\n\nint factor(){\n\tdebug(\"factor\");\n\n\tif(s[c] == '('){\n\t\tc++;\n\t\tint ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nint num(){\n\tdebug(\"num\");\n\n\tint ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tN = s.size();\n\t\tc = 0;\n\t\tcout << expr() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint q,n;\nstring s;\n\nclass Analysis{\n\tpublic:\n\tint Num(int &I){\n\t\tint res=0;\n\t\twhile(I<n&&isdigit(s[I])) res=10*res+(s[I]-'0'),I++;\n\t\treturn res;\n\t}\n\tint Fact(int &I){\n\t\tint res;\n\t\tif(s[I]=='(') res=Exp(++I),I++;\n\t\telse res=Num(I);\n\t\treturn res;\n\t}\n\tint Term(int &I){\n\t\tint res=Fact(I);\n\t\twhile(I<n){\n\t\t\tif(s[I]=='*') res*=Fact(++I);\n\t\t\telse if(s[I]=='/') res/=Fact(++I);\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\tint Exp(int &I){\n\t\tint res=Term(I);\n\t\twhile(I<n){\n\t\t\tif(s[I]=='+') res+=Term(++I);\n\t\t\telse if(s[I]=='-') res-=Term(++I);\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nAnalysis A;\n\nint main(){\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>s;\n\t\ts.pop_back();\n\t\tn=s.size();\n\t\tint I=0;\n\t\tcout<<A.Exp(I)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include<cctype>\n#include<cstdio>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &begin);\n\nint number(State &begin){\n  int ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n\nint term(State &begin){\n  int ret = factor(begin);\n\n  for(;;){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n\n  for(;;){\n    if(*begin=='+'){\n      begin++;\n      ret +=term(begin);\n    }else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int N;\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    char s[105];\n    scanf(\"%s\",s);\n    string S(s);\n\n    State begin=S.begin();\n    int ans=expression(begin);\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n// const string S = \"(1+1)*2\";\nstring S;\nint cur = 0;\nint digit();\nint number();\nint factor();\nint term();\nint _term(int m);\nint exp();\nint _exp(int m);\nint parse();\nbool isdigit(char);\nbool is_plu_min(char);\nbool is_tim_div(char);\nint main() {\n  int N;\n  cin >> N;\n  for (int i=0;i<N;i++) {\n    cin >> S;\n    cur = 0;\n    S.resize(S.size()-1);\n    cout << parse() << endl;\n  }\n  return 0;\n}\nint digit() {\n  int n = S[cur] - '0';\n  cur++;\n  return n;\n}\nint number() {\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur]))\n    n = n*10 + digit();\n  return n;\n}\nbool isdigit(char c) {\n  if (c <= '9' and c >= '0') return true;\n  else return false;\n}\nbool is_plu_min(char c) {\n  if (c == '+' || c == '-') return true;\n  else return false;\n}\nbool is_tim_div(char c) {\n  if (c == '*' || c == '/') return true;\n  else return false;\n}\n// exp    = term exp`\n// exp`   = + term exp` | eps\n// term   = factor term`\n// term`  = * factor term` | eps\n// factor = ( exp ) | num\nint term() {\n  int n = factor();\n  return _term(n);\n}\nint _term(int m) {\n  int n = m;\n  switch (S[cur]) {\n    case '*':\n      cur++;\n      n *= factor();\n      return _term(n);\n    case '/':\n      cur++;\n      n /= factor();\n      return _term(n);\n    default:\n      return n;\n  }\n}\nint factor() {\n  if (S[cur] != '(') return number();\n  else {\n    cur++;\n    int n = exp();\n    cur++;\n    return n;\n  }\n}\nint exp() {\n  int n = term();\n  return _exp(n);\n}\nint _exp(int m) {\n  int n = m;\n  switch (S[cur]) {\n    case '+':\n      cur++;\n      n += term();\n      return _exp(n);\n    case '-':\n      cur++;\n      n -= term();\n      return _exp(n);\n    default:\n      return n;\n  }\n}\nint parse() {\n  return exp();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cassert>\n#include<cctype>\n#include<stdio.h>\n#include<stdlib.h>\n//#include<math.h>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint term();\nint factor();\nint expression();\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur = cur + 1;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur]))\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint expression(){\n\tint a = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur];\n\t\tcur = cur + 1;\n\t\tint b = term();\n\t\tif (op == '+') a += b;\n\t\telse a -= b;\n\t}\n\treturn a;\n}\n\nint term(){\n\tint a = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur];\n\t\tcur = cur + 1;\n\t\tint b = factor();\n\t\tif (op == '*') a *= b;\n\t\telse a /= b;\n\t}\n\treturn a;\n}\n\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size() - 1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\n#define rep(i,n)  for(int i=0;i<n;++i)\n\nusing namespace std;\n\nstring src;\nint pos;\n\nbool end() { return pos >= src.length(); }\nchar peek() { return src[pos]; }\nvoid succ() { if (!end()) ++pos; }\n\nint parse_expr();\n\nint lex_number()\n{\n\tint val = 0;\n\tchar c = peek();\n\tdo\n\t{\n\t\tval = 10 * val + (c - '0');\n\t\tsucc();\n\t}\n\twhile (!end() && isdigit(c = peek()));\n\treturn val;\n}\n\nint parse_primary()\n{\n\tint ret;\n\n\tchar c = peek();\n\tswitch (c)\n\t{\n\tcase '(':\n\t\tsucc();\n\t\tret = parse_expr();\n\t\tsucc();\n\t\tbreak;\n\tdefault:\n\t\tret = lex_number();\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint parse_term()\n{\n\tint x = parse_primary();\n\twhile (!end() && (peek() == '*' || peek() == '/'))\n\t{\n\t\tchar op = peek();\n\t\tsucc();\n\t\tint y = parse_primary();\n\t\tx = (op == '*' ? x * y : x / y);\n\t}\n\treturn x;\n}\n\nint parse_expr()\n{\n\tint x = parse_term();\n\twhile (!end() && (peek() == '+' || peek() == '-'))\n\t{\n\t\tchar op = peek();\n\t\tsucc();\n\t\tint y = parse_term();\n\t\tx = (op == '+' ? x + y : x - y);\n\t}\n\treturn x;\n}\n\nint parse()\n{\n\tpos = 0;\n\treturn parse_expr();\n}\n\nint main()\n{\n\tint N;\n\tcin>>N;\n\twhile(N--)\n\t{\n\t\tcin >> src;\n\t\tcout << parse() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if (op == '+') val += val2;\n    else val -= val2;\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*' || s[i] == '/') {\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if (op == '*') val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n  if (isdigit(s[i])) return number(s, i);\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n  return ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\n\nint main() {\n  int n = 0;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    s = s.substr(0, s.size() - 1);\n    int i = 0;\n    cout << expr(s, i) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n//Vector2D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec2D {\n    T x, y;\n\n    Vec2D() = default;\n\n    constexpr Vec2D(T x, T y)\n            : x{x}, y{y} {}\n\n    static constexpr T Dot(const Vec2D &lhs, const Vec2D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y;\n    }\n\n    static constexpr T Cross(const Vec2D &lhs, const Vec2D &rhs) {\n        return {lhs.x * rhs.y - lhs.y * rhs.x};\n    }\n\n    constexpr T dot(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec2D cross(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y;\n    }\n\n    Vec2D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec2D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0;\n    }\n\n    constexpr Vec2D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec2D operator-() const {\n        return {-x, -y};\n    }\n\n\n    constexpr Vec2D operator+(Vec2D rhs) const {\n        return {x + rhs.x, y + rhs.y};\n    }\n\n    constexpr Vec2D operator-(Vec2D rhs) const {\n        return {x - rhs.x, y - rhs.y};\n    }\n\n    template<class U>\n    constexpr Vec2D operator*(U rhs) const {\n        return {x * rhs, y * rhs};\n    }\n\n    template<class U>\n    constexpr Vec2D operator/(U rhs) const {\n        return {x / rhs, y / rhs};\n    }\n\n    constexpr Vec2D &operator+=(const Vec2D &other) {\n        x += other.x;\n        y += other.y;\n        return *this;\n    }\n\n    constexpr Vec2D &operator-=(const Vec2D &other) {\n        x -= other.x;\n        y -= other.y;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec2D<T> operator*(U s, Vec2D<T> v) {\n    return {s * v.x, s * v.y};\n}\n\n//Vector3D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec3D {\n    T x, y, z;\n\n    Vec3D() = default;\n\n    constexpr Vec3D(T x, T y, T z)\n            : x{x}, y{y}, z{z} {}\n\n    constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0) {}\n\n    static constexpr T Dot(const Vec3D &lhs, const Vec3D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n    }\n\n    static constexpr Vec3D Cross(const Vec3D &lhs, const Vec3D &rhs) {\n        return {\n                lhs.y * rhs.z - lhs.z * rhs.y,\n                lhs.z * rhs.x - lhs.x * rhs.z,\n                lhs.x * rhs.y - lhs.y * rhs.x\n        };\n    }\n\n    constexpr T dot(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec3D cross(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y + z * z;\n    }\n\n    Vec3D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec3D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0 && z == 0;\n    }\n\n    constexpr Vec3D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec3D operator-() const {\n        return {-x, -y, -z};\n    }\n\n\n    constexpr Vec3D operator+(Vec3D rhs) const {\n        return {x + rhs.x, y + rhs.y, z + rhs.z};\n    }\n\n    constexpr Vec3D operator-(Vec3D rhs) const {\n        return {x - rhs.x, y - rhs.y, z - rhs.z};\n    }\n\n    template<class U>\n    constexpr Vec3D operator*(U rhs) const {\n        return {x * rhs, y * rhs, z * rhs};\n    }\n\n    template<class U>\n    constexpr Vec3D operator/(U rhs) const {\n        return {x / rhs, y / rhs, z / rhs};\n    }\n\n    constexpr Vec3D &operator+=(const Vec3D &other) {\n        x += other.x;\n        y += other.y;\n        z += other.z;\n        return *this;\n    }\n\n    constexpr Vec3D &operator-=(const Vec3D &other) {\n        x -= other.x;\n        y -= other.y;\n        z -= other.z;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        z *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        z /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec3D<T> operator*(U s, Vec3D<T> v) {\n    return {s * v.x, s * v.y, s * v.z};\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n//構文解析\ntypedef string::const_iterator ParseState;\n\nclass ParseError {\n};\n\nvoid cunsume(ParseState &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n             << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        throw ParseError();\n    }\n}\n\nint expression(ParseState &begin);\n\nint term(ParseState &begin);\n\nint factor(ParseState &begin);\n\nint number(ParseState &begin);\n\nint expression(ParseState &begin) {\n    int ret = term(begin);\n\n    while (true) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint term(ParseState &begin) {\n    int ret = factor(begin);\n\n    while (true) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint factor(ParseState &begin) {\n    if (*begin == '(') {\n        //(を飛ばす\n        begin++;\n\n        int ret = expression(begin);\n\n        //)を飛ばす\n        begin++;\n\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint number(ParseState &begin) {\n    int ret = 0;\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += (*begin - '0');\n        begin++;\n    }\n\n    return ret;\n}\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\n\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    cin.ignore();\n\n    REP(i, N){\n        string str;\n        GL(str);\n        ParseState begin = str.begin();\n        int ans = expression(begin);\n        OUT_L(ans);\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "n=int(input())\nfor i in range(n):\n    print(input())\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint num(string&, int&);\nint term(string&, int&);\nint mul(string&, int&);\nint expr(string&, int&);\n\nint num(string &s, int &k) {\n    int ret = 0;\n    while ('0' <= s[k] && s[k] <= '9') {\n        ret *= 10;\n        ret += s[k] - '0';\n        k ++;\n    }\n    return ret;\n}\n\nint term(string &s, int &k) {\n    int sym = 1;\n    if (s[k] == '+') {\n        sym = 1;\n        k ++;\n    } else if (s[k] == '-') {\n        sym = -1;\n        k ++;\n    }\n    int ret;\n    if (s[k] == '(') {\n        k ++;\n        ret = expr(s, k);\n        k ++;\n    } else {\n        ret = num(s, k);\n    }\n    return sym * ret;\n}\n\nint mul(string &s, int &k) {\n    int ret = term(s, k);\n    if (s[k] == '*') {\n        k ++;\n        return ret * mul(s, k);\n    } else if (s[k] == '/') {\n        k ++;\n        return ret / mul(s, k);\n    }\n    return ret;\n}\n\nint expr(string &s, int &k) {\n    int ret = mul(s, k);\n    if (s[k] == '+') {\n        k ++;\n        return ret + expr(s, k);\n    } else if (s[k] == '-') {\n        k ++;\n        return ret - expr(s, k);\n    }\n    return ret;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string s;\n    while (n--) {\n        cin >> s;\n        int pos = 0;\n        cout << expr(s, pos) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint expr(char *& s);\n\nint val(char *& s){\n\tif(*s == '('){\n\t\ts++;\n\t\tint ret = expr(s);\n\t\ts++;\n\t\treturn ret;\n\t}\n\n\tint v = 0;\n\twhile(*s >= '0' && *s <= '9'){\n\t\tv *= 10;\n\t\tv += *s - '0';\n\t\ts++;\n\t}\n\treturn v;\n}\n\nint pri(char *& s){\n\tint l = val(s);\n\twhile(true){\n\t\tchar ope = *s;\n\t\tif(ope != '*' && ope != '/')\n\t\t\treturn l;\n\t\ts++;\n\t\tint r = val(s);\n\t\tif(ope == '*')\n\t\t\tl *= r;\n\t\telse\n\t\t\tl /= r;\n\t}\n}\n\nint expr(char *& s){\n\tint l = pri(s);\n\twhile(true){\n\t\tchar ope = *s;\n\t\tif(ope != '+' && ope != '-')\n\t\t\treturn l;\n\t\ts++;\n\t\tint r = pri(s);\n\t\tif(ope == '+')\n\t\t\tl+=r;\n\t\telse\n\t\t\tl-=r;\n\t}\n}\n\nvoid solve()\n{\n\tchar s[256];\n\tcin>>s;\n\tchar *p = s;\n\tcout << expr(p) << endl;\n}\n\nint main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int calc(string ex){\n\tlong long int str,cnt,ans=0,now=0,addn=1,addd=1,n=ex.length(),i;\n\tbool sus=false,minus=false;\n\tchar pm='+',md='*';\n\tfor(i=0; i<n; i++){\n\t\tif(sus){\n\t\t\tif(ex[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}else if(ex[i]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt == 0){\n\t\t\t\t\tnow = calc(ex.substr(str,i-str));\n\t\t\t\t\tsus = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(ex[i]){\n\t\t\t\tcase '(':\n\t\t\t\t\tstr = i+1;\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tsus = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif(i==0 || ex[i-1]== '+' || ex[i-1]== '-' || ex[i-1]== '*' || ex[i-1]== '/'){\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase '+':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\taddn *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\taddd *= now;\n\t\t\t\t\t}\n\t\t\t\t\tif(pm == '+'){\n\t\t\t\t\t\tans += addn/addd;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans -= addn/addd;\n\t\t\t\t\t}\n\t\t\t\t\tpm = ex[i];\n\t\t\t\t\tmd = '*';\n\t\t\t\t\tnow = 0;\n\t\t\t\t\taddn = 1;\n\t\t\t\t\taddd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\taddn *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\taddd *= now;\n\t\t\t\t\t}\n\t\t\t\t\tmd = ex[i];\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tnow *= 10;\n\t\t\t\t\tnow += ex[i]-'0';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(minus){\n\t\tnow *= -1;\n\t\tminus = false;\n\t}\n\tif(md == '*'){\n\t\taddn *= now;\n\t}else{\n\t\taddd *= now;\n\t}\n\tif(pm == '+'){\n\t\tans += addn/addd;\n\t}else{\n\t\tans -= addn/addd;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n,i;\n\tlong long int ans;\n\tstring str;\n\tcin >> n;\n\tfor(i=0; i<n; i++){\n\t\tcin >> str;\n\t\tans = calc(str);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\nstring query;\nconst char *p;\n\nint exprs();\n\nint factor() {\n  char *e;\n  int ret;\n\n  if(*p == '(') {\n    p ++;\n    ret = exprs();\n    p ++;\n    return ret;\n  }\n  \n  ret = strtol(p, &e, 10);\n  // cout << \"factor: \" << ret << endl;\n  p = e;\n  //cout << *p << endl;\n  \n  return ret;\n}\n\nint term() {\n  int ret = factor();\n\n  for(;;) {\n    if(*p == '*') {\n      p++;\n      ret *= factor();\n    } else if(*p == '/') {\n      p++;\n      ret /= factor();\n    } else {\n      break;\n    }\n  }\n  \n  return ret;\n}\n\nint exprs() {\n  \n  int ret = term();\n  for(;;) {\n    if(*p == '+') {\n      p ++;\n      ret += term();\n    } else if(*p == '-') {\n      p ++;\n      ret -= term();\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int n;\n  \n  cin >> n; cin.ignore();\n  for(int i=0; i<n; i++) {\n    getline(cin, query);\n    query = query.substr(0, query.size()-1);\n    p = query.c_str();\n    cout << exprs() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 0;\n  case '/':\n    return 1;\n  case '*':\n    return 1;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) <= getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    hand.push_back(side[i]);\n  }\n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      long long val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  cin >> n;\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint roc = 0;\nstring s;\nint insu();\nint kou();\nint shiki();\n\nint insu() {\n\tif(s[roc] >= '0' && s[roc] <= '9') {\n\t\tint j = roc;\n\t\twhile(roc < s.size() && s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\treturn stoi(s.substr(j, roc - j));\n\t} else {\n\t\t++roc;\n\t\tint res = shiki();\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint kou() {\n\tint res = insu();\n\twhile (s[roc] == '*' || s[roc] == '/') {\n\t\tif(s[roc] == '*') {\n\t\t\t++roc;\n\t\t\tres *= insu();\n\t\t}\n\t\telse {\n\t\t\t++roc;\n\t\t\tres /= insu();\n\t\t}\n\t}\n\treturn res;\n}\n\nint shiki() {\n\tint res = kou();\n\twhile (s[roc] == '+' || s[roc] == '-') {\n\t\tif(s[roc] == '+') {\n\t\t\t++roc;\n\t\t\tres += kou();\n\t\t}\n\t\telse {\n\t\t\t++roc;\n\t\t\tres -= kou();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n;\n\tcin>>n;\n\tREP(roop, n) {\n\t\troc = 0;\n\t\tcin>>s;\n\t\ts.pop_back();\n\t\tcout<<shiki()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint n;\nstring str;\n\nint factor(State &begin);\nint number(State &begin);\nint term(State &begin);\nint expressin(State &begin);\n\nint factor(State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint culc1();\nint culc2();\nint culc3();\nint culc4();\n\nint n;\nstring str;\nint cur;\n\nint main() {\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> str;\n\t\tcur = 0;\n\t\tcout << culc1() << endl;\n\t}\n\treturn 0;\n}\n\n\nint culc1() {\n\tint val = culc2();\n\twhile (str[cur] == '+' || str[cur] == '-') {\n\t\tchar op = str[cur++];\n\t\tint val2 = culc2();\n\n\t\tif (op == '+') val += val2;\n\t\telse val -= val2;\n\t}\n\treturn val;\n}\n\nint culc2() {\n\tint val = culc3();\n\twhile (str[cur] == '*' || str[cur] == '/') {\n\t\tchar op = str[cur++];\n\t\tint val2 = culc3();\n\t\t\n\t\tif (op == '*') val *= val2;\n\t\telse val /= val2;\n\t}\n\treturn val;\n}\n\nint culc3() {\n\tif (isdigit(str[cur])) return culc4();\n\tcur++;\n\tint res = culc1();\n\tcur++;\n\treturn res;\n}\n\nint culc4() {\n\tint num = str[cur++] - '0';\n\twhile (isdigit(str[cur]))\n\t\tnum = num*10 + str[cur++] - '0';\n\treturn num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <sstream>\n\nusing namespace std;\n\ntypedef string::const_iterator Cursor;\nclass ParseError{};\n\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\nint expression(Cursor&);\nint term(Cursor&);\nint factor(Cursor&);\nint number(Cursor&);\n\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\nint expression(Cursor &c){\n    int ret = term(c);\n    while(*c == '+' or *c == '-'){\n        if(*c == '+'){\n            c++;\n            ret += term(c);\n        }else{\n            c++;\n            ret -= term(c);\n        }\n    }\n    return ret;\n}\n\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\nint term(Cursor &c){\n    int ret = factor(c);\n    while(*c == '*' or *c == '/'){\n        if(*c == '*'){\n            c++;\n            ret *= term(c);\n        }else{\n            c++;\n            ret /= term(c);\n        }\n    }\n    return ret;\n}\n\n// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\nint factor(Cursor &c){\n    if(*c == '('){\n        c++;\n        int ret = expression(c);\n        // ')'\n        c++;\n        return ret;\n    }else{\n        return number(c);\n    }\n}\n\n// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\nint number(Cursor &c){\n    stringstream ss;\n    while(isdigit(*c)){\n        ss << *c;\n        c++;\n    }\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nint main(){\n    int test_case;\n    cin >> test_case;\n    cin.ignore();\n    for(int i=0;i<test_case;i++){\n        string s;\n        getline(cin,s);\n        Cursor c = s.begin();\n        cout << expression(c) << endl;\n        if(*c != '='){\n            cerr  << 'n' << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nlong calc2(char *eq){\n\tlong c=0,num[100]={0}, sign[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(long i=0;i<c;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(long i=0;i<c;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn calc2(cp);\n}\n\nlong main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define INF 1000000\n\n\nint ar[2][14];\nint main(){\n\tstring str;\n\tint N;\n\tcin>>N;\n\tVI res;\n\tstack <string>st;\n\tREP(ii,N){\n\t\tcin>>str;\n\t\tpriority_queue<pair<int,char> > buf;\n\t\tpriority_queue<pair<int,char> > buf2;\n\t\t\n\t\tbool ch=false;\n\t\tint t=0;\n\t\tstring temp=\"\";\n\t\tREP(i,SZ(str)){\n\t\t\tif(str[i]=='+'||str[i]=='-'){\n\t\t\t\tif((!ch&&(buf.empty()||(buf.top()).first<i))||(ch&&(buf2.empty()||(buf2.top()).first<i))){\n\t\t\t\t\tif(!ch)buf.push(MP(i,str[i]));\n\t\t\t\t\telse buf2.push(MP(i,str[i]));\n\t\t\t\t}else{\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\ttemp+=(buf.top()).second;\n\t\t\t\t\t\tbuf.pop();\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp+=(buf2.top()).second;\n\t\t\t\t\t\tbuf2.pop();\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(str[i]=='*'||str[i]=='/'){\n\t\t\t\tif(!ch){\n\t\t\t\t\tbuf.push(MP(300-i,str[i]));\n\t\t\t\t}else{\n\t\t\t\t\tbuf2.push(MP(300-i,str[i]));\n\t\t\t\t}\n\t\t\t}else if(str[i]=='('){\n\t\t\t\tch=true;\n\t\t\t}else if(str[i]==')'){\n\t\t\t\twhile(!buf2.empty()){\n\t\t\t\t\ttemp+=(buf2.top()).second;\n\t\t\t\t\tbuf2.pop();\n\t\t\t\t}\n\t\t\t\tch=false;\n\t\t\t}else if(str[i]=='='){\n\t\t\t\twhile(!buf.empty()){\n\t\t\t\t\ttemp+=(buf.top()).second;\n\t\t\t\t\tbuf.pop();\n\t\t\t\t}\n\t\t\t}else if(str[i]>='0'&&str[i]<='9'){\n\t\t\t\tif(i+1<SZ(str)&&str[i+1]>='0'&&str[i+1]<='9'){\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\tt*=10;\n\t\t\t\t}else{\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\t//cout<<t<<endl;\n\t\t\t\t\ttemp+=toString(t);\n\t\t\t\t\tt=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack <int> st;\n\t\tREP(i,SZ(temp)){\n\t\t\tif(temp[i]>='0'&&temp[i]<='9'){\n\t\t\t\tst.push((unsigned int)(temp[i]-'0'));\n\t\t\t}else if(temp[i]=='+'){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1+t2);\n\t\t\t}else if(temp[i]=='-'){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2-t1);\n\t\t\t}else if(temp[i]=='*'){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2*t1);\n\t\t\t}else if(temp[i]=='/'){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2/t1);\n\t\t\t}\n\t\t}\n\t\tres.PB(st.top());\n\t}\n\tREP(i,N)cout<<res[i]<<endl;\n\treturn 0;\n}\n\n//5+4*3+2/6=\n//(1+4)*(3+7)/5=\n//5+4-3=\n//(1+5)*(2+3)="
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint n;\nstring str;\n\nint factor(State &begin);\nint number(State &begin);\nint term(State &begin);\nint expressin(State &begin);\n\nint factor(State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\n#define ans pair<int, int>\nstring s;\nans equation(int p);\nans factor(int p);\nans term(int p);\nint main(){\n  int n;\n  cin >>n;\n  while(n--){\n    cin >>s;\n    ans r = equation(0);\n    cout <<r.first<<endl;\n  }\n  return 0;\n}\nans equation(int p){\n  ans r = factor(p);\n  while(s[r.second] == '+' || s[r.second] == '-'){\n    ans r_dash = factor(r.second+1);\n    if(s[r.second] == '+'){r.first += r_dash.first;}\n    if(s[r.second] == '-'){r.first -= r_dash.first;}\n    r.second = r_dash.second;\n  }\n  return r;\n}\nans factor(int p){\n  ans r = term(p);\n  while(s[r.second] == '*' || s[r.second] == '/'){\n    ans r_dash = term(r.second+1);\n    if(s[r.second] == '*'){r.first *= r_dash.first;}\n    if(s[r.second] == '/'){r.first /= r_dash.first;}\n    r.second = r_dash.second;\n  }\n  return r;\n}\nans term(int p){\n  if(s[p] == '('){\n    ans r = equation(p+1);\n    r.second++;\n    return r;\n  }\n  else{\n    int v = 0;\n    while(isdigit(s[p])){\n      v = v*10+s[p++]-'0';\n    }\n    return ans(v,p);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tif(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\tif(!op.empty())\n\t\tcalc();\n\t//cout << num.top() << endl;//\n\t//int tmp=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\nusing namespace std;\n \nstring S;\nsize_t cur = 0;\nchar readchar();\nchar peek();\nint digit();\nint number();\nint term();\nint expression();\nint factor();\n \nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i){\n        cur = 0;\n        cin >> S;\n        S.resize(S.size()-1);\n        cout << expression() << endl;\n    }\n    return 0;\n}\n \nchar readchar(){\n    assert(cur < S.size());\n    char ret = S[cur];\n    cur += 1;\n    return ret;\n}\n \nchar peek(){\n    assert(cur < S.size());\n    return S[cur];\n}\n \nint digit(){\n    assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n \nint number(){\n    int n = digit();\n    while(cur < S.size() && isdigit(peek()))\n        n = n*10 +digit();\n    return n;\n}\n \nint term()\n{\n    int a = factor();\n    while(cur < S.size() && (peek() == '*' || peek() == '/')){\n        char op = readchar();\n        int b = factor();\n        if (op == '*') a *= b; else a /= b;\n    }\n    return a;\n}\n \nint expression(){\n    int a = term();\n    while(cur < S.size() && (peek() == '+' || peek() =='-'))\n    {\n        char op =readchar();\n        int b = term();\n        if(op == '+')\n        {\n            a += b;\n        }\n        else a -= b;\n    }\n    return a;\n}\nint factor() {\n    if (peek() != '(') return number();\n    cur += 1;\n    int n = expression();\n    assert(peek() == ')');\n    cur += 1;\n    return n;\n}\nint parse() {return expression();}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // only for GCC\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef string::const_iterator State;\n\nclass ParseError{};\n\n//container util\n//------------------------------------------\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n//repetition\n//------------------------------------------\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\nint number(State &begin);\nint term(State &begin);\nint expression(State &begin);\nint expression(State &begin);\n\nint number(State &begin){\n    int ret = 0;\n\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else {\n        return number(begin);\n    }\n}\n\nint term(State &begin){\n    int ret = factor(begin);\n    for(;;){\n        if(*begin =='*'){\n            begin++;\n            ret *= factor(begin);\n        } else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\n\nint expression(State &begin){\n    int ret = term(begin);\n\n    for(;;){\n        if (*begin == '+'){\n            begin++;\n            ret += term(begin);\n        } else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    cin.ignore();\n    rep(i, N){\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint expr(char *& s);\n\nint val(char *& s){\n\tif(*s == '-'){\n\t\ts++;\n\t\treturn -val(s);\n\t}\n\n\tif(*s == '('){\n\t\ts++;\n\t\tint ret = expr(s);\n\t\ts++;\n\t\treturn ret;\n\t}\n\n\tint v = 0;\n\twhile(*s >= '0' && *s <= '9'){\n\t\tv *= 10;\n\t\tv += *s - '0';\n\t\ts++;\n\t}\n\treturn v;\n}\n\nint pri(char *& s){\n\tint l = val(s);\n\tchar ope = *s;\n\tif(ope != '*' && ope != '/')\n\t\treturn l;\n\ts++;\n\tint r = pri(s);\n\tif(ope == '*')\n\t\treturn l*r;\n\telse\n\t\treturn l/r;\n}\n\nint expr(char *& s){\n\tint l = pri(s);\n\tchar ope = *s;\n\tif(ope != '+' && ope != '-')\n\t\treturn l;\n\ts++;\n\tint r = expr(s);\n\tif(ope == '+')\n\t\treturn l+r;\n\telse\n\t\treturn l-r;\n}\n\nvoid solve()\n{\n\tchar s[101];\n\tcin>>s;\n\tchar *p = s;\n\tcout << expr(p) << endl;\n}\n\nint main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(string& s,State &i);\nDef term(string& s,State &i);\nDef factor(string& s,State &i);\nDef number(string& s,State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(string& s,State &i){\n\tDef out=term(s,i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(s,i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(string& s,State &i){\n\tDef out=factor(s,i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(s,i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(string& s,State &i){\n\tif(isdigit(*i))return number(s,i);\n\t//'('\n\ti++;\n\tDef out=expr(s,i);\n\ti++;\n\treturn out;\n}\nDef number(string& s,State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tcout<<expr(s,s.begin())<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\nint number(State &begin);\n\nint expression(State &begin){\n    int ret = term(begin);\n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret = number(begin);\n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    cin.ignore();\n    for(int i = 0; i < N; i++){\n        string s;\n        getline(cin, s);\n        cout << s << endl;\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring str;\nint cur = 0;\n\nint expression();\nint term();\nint factor();\n\nint digit() {\n    int a = str[cur] - '0';\n    cur++;\n    return a;\n}\n\nint number() {\n    int a = digit();\n    while (cur < str.size() && isdigit(str[cur])) {\n        a = a * 10 + digit();\n    }\n    return a;\n}\n\nint expression() {\n    cout<<\"expression\"<<endl;\n    int a = term();\n    cout<<\"a=\"<<a<<endl;\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        if (str[cur] == '+') {\n            cur++;\n            int b = term();\n            a += b;\n        } else if (str[cur] == '-') {\n            cur++;\n            int b = term();\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint term() {\n    cout<<\"term\"<<endl;\n    int a = ((str[cur] == '(') ? factor() : number());\n    cout<<\"a=\"<<a<<endl;\n    cout<<str[cur]<<endl;\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        if (str[cur] == '*') {\n            cur++;\n            int b = ((str[cur] == '(') ? factor() : term());\n            a *= b;\n        } else if (str[cur] == '/') {\n            cur++;\n            int b = ((str[cur] == '(') ? factor() : term());\n            a /= b;\n        }\n    }\n    return a;\n}\n\nint factor() {\n    cout<<\"factor\"<<endl;\n    cur++;\n    int a = expression();\n    cur++;\n    return a;\n}\n\nint main() {\n    int N = 0;\n    cin>>N;\n    for (int n = 0; n < N; n++) {\n        cin>>str;\n        cur = 0;\n        cout<<expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nLL plusub(void);\nLL muldiv(void);\nLL parent(void);\nLL number(void);\n\nint ind;\nstring str;\n\nLL plusub(void){\n  LL a=muldiv();\n  if(str[ind]=='+'){\n    ++ind;\n    return a+plusub();\n  }else if(str[ind]=='-'){\n    ++ind;\n    return a-plusub();\n  }else return a;\n}\n\nLL muldiv(void){\n  LL a=parent();\n  if(str[ind]=='*'){\n    ++ind;\n    return a*muldiv();\n  }else if(str[ind]=='/'){\n    ++ind;\n    return a/muldiv();\n  }else return a;\n}\n\nLL parent(void){\n  if(str[ind]=='('){\n    ++ind;\n    LL a=plusub();\n    ++ind;\n    return a;\n  }else return number();\n}\n\nLL number(void){\n  if('0'<=str[ind] && str[ind]<='9'){\n    LL a=str[ind]-'0';\n    ++ind;\n    LL b=number();\n    if(0<=b) return a*10+b;\n    else return a;\n  }else return -1;\n}\n\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(i,n){\n    ind=0;\n    cin >> str;\n    cout << plusub() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '/':\n    return 2;\n  case '*':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif((cs == '*' || cs == '/') && (str[i] == '*' || str[i] == '/')){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\tif((cs == '+' || cs == '-') && (str[i] == '+' || str[i] == '-')){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse if(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    hand.push_back(side[i]);\n  }\n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      long long val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  cin >> n;\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0])){\n\t\tconst char* p=s;\n\t\t//if(*p=='-')\n\t\t//\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\t//else if(s[0]=='('){\n\telse{\n\t\tparsed res=expr(s+1);\n\t\t//if (*res.second!=')') exit(0);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\t//else\n\t//\texit(0);\n}\n\n//parsed fact(const char *p)\n//{\n//  if (isdigit(*p)){\n//    int t=0;\n//    while(isdigit(*p)) t=t*10+*(p++)-'0';\n//    return parsed(t,p);\n//  }\n//  else if (*p=='('){\n//    parsed r=expr(p+1);\n//    if (*r.second!=')') exit(0); // invalid input\n//    return parsed(r.first,r.second+1);\n//  }\n//  else\n//    exit(0); // invalid input\n//}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    // s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << number(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#include <bits/stdc++.h>\n#define rep(i ,n) for(int i=0;i<(int)(n);++i)\n#define repr(i ,n) for(int i=n;i>(int)(n);--i)\n#define rep1(i ,n) for(int i=1;i<=(int)(n);++i)\n#define ALL(a) a.begin(), a.end()\n#define RSORT(a) sort(ALL(a),greater<>())\n#define SORT(a) sort(ALL(a))\n#define bit_check(bit, i) ((bit>>(i)) & 1)\n#define PRINT(x) cout << (x) << endl\n#define ENDL printf(\"\\n\")\nusing namespace std;\ntypedef long long int i64;\ntypedef unsigned long long u64;\ntemplate<class T> using V = vector<T>;\nusing VI = V<int>;\nconst int INF = 2e9;\nconst i64 MOD = 1e9 + 7;\n \ntemplate <class T> inline bool chmin(T& a, T b){if(a>b){a=b; return true;} return false;}\ntemplate <class T> inline bool chmax(T& a, T b){if(a<b){a=b; return true;} return false;}\nstruct Init_On{\n    Init_On(){\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(16);\n    }\n};\n \nint calc(string& s){\n    int num_of_op = 0;\n    s.insert(s.begin(),'s');\n    int len = s.size();\n    string operand;\n    operand.clear();\n    rep( i , len){\n        if((s[i] > '9' || s[i] < '0') && s[i]!='s') {\n            if( s[i] == '-' && (s[i-1] >'9' || s[i-1] <'0' && i-1 >=0 )) continue;\n            ++num_of_op;\n        }\n    }\n    vector<int> num(num_of_op+1);\n    vector<char> op(num_of_op);\n    int x = 0;\n    rep(i , len){\n        if((s[i] > '9' || s[i] < '0') && s[i] != 's'){\n            if(s[i] == '-' && (s[i-1] > '9' || s[i-1] < '0' && i-1 >=0)) continue;\n            op[x++] = s[i];\n        }\n    }\n    s += 'e';\n    int j = 0;\n    bool flag = false;\n    for( int i = 0 ; i < num_of_op + 1  ; ++i){\n        for( ; (s[j] <= '9' && s[j] >= '0') || s[j] == 's' || flag ; ++j){\n            if(s[j] =='s' && s[j+1] == '-') { operand += '-'; ++j; continue; }\n            if((s[j-1] >'9' || s[j-1] < '0' ) && s[j] == '-' && j-1 >= 0 ) { operand += '-'; flag = true; continue;}\n            if(s[j] != 's' && ( s[j]<='9' && s[j]>='0') ) { operand += s[j]; flag = false; }\n        }\n        num[i] = stoi(operand);\n        operand.clear();\n        ++j;\n        if(s[j]=='-') flag = true;\n    }\n    int muldiv = 0 , sumdiff = 0;\n    rep( i , num_of_op){\n        \n        if (op[i] == '+' || op[i] == '-') ++sumdiff;\n        else if (op[i] == '*' || op[i] == '/') ++muldiv;\n    }\n    while(muldiv){\n        rep( i , num_of_op){\n            if(op[i] == '*'){\n                num[i+1] = num[i] * num[i+1];\n                num.erase(num.begin()+i); op.erase(op.begin()+i); --i; --num_of_op;\n                --muldiv;\n            } else if(op[i] == '/'){\n                num[i+1] = num[i] / num[i+1];\n                num.erase(num.begin()+i); op.erase(op.begin()+i); --i; --num_of_op;\n                --muldiv;\n            }\n        }\n    }\n    while(sumdiff){\n        rep(i , num_of_op){\n            if( op[i] == '+'){\n                { num[i+1] = num[i] + num[i+1]; num.erase(num.begin()+i); op.erase(op.begin()+i); --num_of_op; --i; --sumdiff; }\n            }\n            else if (op[i] == '-'){\n                { num[i+1] = num[i] - num[i+1]; num.erase(num.begin()+i); op.erase(op.begin()+i); --num_of_op; --i; --sumdiff; }\n            }\n        }\n\n    }\n    return num[0];\n}\n \nsigned main(){\n    Init_On start;\n    int n; cin >> n;\n    int t = n;\n    VI ans(t);\n    while(t){\n        string s; cin >> s;\n        string tmp;\n        auto itr = s.end(); --itr; s.erase(itr);\n        int i , j;\n        int num_br = 0;\n        rep( k , s.size()) {\n            if(s[k] == ')') ++num_br;\n        }\n        if( num_br == 0) { ans.push_back(calc(s)); --t; continue; }\n        while(num_br){\n            for( i = 0 ; i < s.size() ; ++i){\n                if(s[i]==')'){\n                    auto itr1 = s.begin();\n                    rep( k , i) ++itr1;\n                    s.erase(itr1);\n                    j = i;\n                    for( ; s[j]!='('; --j ){}\n                    auto itr2 = s.begin();\n                    rep( k , j) ++itr2;\n                    s.erase(itr2);\n                    break; \n                }\n            }\n                tmp = s.substr(j , i-j-1);\n                tmp = to_string(calc(tmp));\n                s.replace( j , i-j-1 , tmp);\n                --num_br;\n        }\n        bool f = true;\n        for(int i = 0 ; i < s.size() ; ++i){\n            if(s[i]>'9' || s[i]<'0' ) f = false; \n        }\n        if(f) ans.push_back(stoi(s)); \n        else ans.push_back(calc(s));\n        --t;\n    }\n    reverse(ALL(ans));\n    for(int i = n - 1 ; i >=0 ; --i) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Calc{\npublic:\n  string s;\n  string::iterator it;\n  \n  Calc(string s) : s(s) {\n    it = s.begin();\n  }\n  \n  int fact(){\n    int res = 0;\n    if(*it == '('){\n      ++it;\n      res = exp();\n      ++it;\n    }else{\n      while(isdigit(*it)){\n        res *= 10;\n        res += (*it-'0');\n        ++it;\n      }\n    }\n    return res;\n  }\n  \n  int term(){\n    int res = fact();\n    while(*it == '*' || *it == '/'){\n      if(*it == '*'){\n        ++it;\n        res *= fact();\n      }else{\n        ++it;\n        res /= fact();\n      }\n    }\n    return res;\n  }\n\n  int exp(){\n    int res = term();\n    while(*it == '+' || *it == '-'){\n      if(*it == '+'){\n        ++it;\n        res += term();\n      }else{\n        ++it;\n        res -= term();\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int N;\n  cin >> N;\n  while(N--){\n    string s;\n    cin >> s; s.resize(s.size()-1);\n    Calc calc(s);\n    cout << calc.exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint cal1();\nint cal2();\nint cal3();\n\nint index;\nstring s;\n\nint getNum(){\n\tint n = 0;\n\tfor (; '0' <= s[index] && s[index] <= '9'; index++) n = n * 10 + s[index] - '0';\n\treturn n;\n}\n\nint cal1(){\n\tint ret = cal2();\n\twhile (1){\n\t\tif (s[index] == '+') {\n\t\t\tindex++;\n\t\t\tret += cal2();\n\t\t}\n\t\telse if (s[index] == '-') {\n\t\t\tindex++;\n\t\t\tret -= cal2();\n\t\t}\n\t\telse return ret;\n\t}\n}\n\nint cal2(){\n\tint ret = cal3();\n\twhile (1){\n\t\tif (s[index] == '*') {\n\t\t\tindex++;\n\t\t\tret *= cal3();\n\t\t}\n\t\telse if (s[index] == '/') {\n\t\t\tindex++;\n\t\t\tret /= cal3();\n\t\t}\n\t\telse return ret;\n\t}\n}\n\nint cal3(){\n\tint ret = 0;\n\tint old = index;\n\tif (s[index] == '('){\n\t\tindex++;\n\t\tret = cal1();\n\t\tindex++;\n\t}\n\telse {\n\t\tret = getNum();\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tgetchar();\n\tfor (int i = 0; i < n; i++){\n\t\tindex = 0;\n\t\tgetline(cin, s);\n\t\ts.pop_back();\n\t\tcout << cal1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nstring toRPN(string s){\n    stack<char> ope;\n    string ret;\n    int len=s.size();\n    \n    for(int i=0;i<len;i++){\n        if( isdigit(s[i]) ) ret+=s[i];\n        \n        else{\n            if(s[i]=='('){\n                ope.push(s[i]);\n                \n            }else if(s[i]==')'){\n                while(ope.top()!='('){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.pop();\n                \n            }else if( s[i]=='*' || s[i]=='/' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else if( s[i]=='+' || s[i]=='-' ){\n                while( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n                    ret+=ope.top();\n                    ope.pop();\n                }\n                ope.push(s[i]);\n                \n            }else{\n                return \"invalid\";\n            }\n        }\n    }\n    while(ope.size()){\n        ret+=ope.top();\n        ope.pop();\n    }\n\n    return ret;\n}\n\n\nstring solveRPN(string s){\n    stack<int> stk;\n\n    \n    for(int i=0;i<s.size();i++){\n        if( isdigit(s[i]) )stk.push( s[i]-'0'  );\n        else{\n            int b=stk.top(); stk.pop();\n            int a=stk.top(); stk.pop();\n            \n            if(s[i]=='+')stk.push(a+b);\n            if(s[i]=='-')stk.push(a-b);\n            if(s[i]=='*')stk.push(a*b);\n            if(s[i]=='/')stk.push(a/b);\n        }\n    }\n    \n    stringstream ret;\n    ret<<stk.top();\n    \n    return ret.str();\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        string s;\n        cin>>s;\n        \n        s.erase(s.size()-1);\n        \n        s=toRPN(s);\n        s=solveRPN(s);\n    \n        cout<<s<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nlong long parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')'){\n\t\tbool f=true;\n\t\tfor(int i=1,d=1;i<s.length()-1;i++){\n\t\t\tif     (s[i]=='(')\td++;\n\t\t\telse if(s[i]==')')\td--;\n\t\t\tif(d==0){\tf=false;\tbreak;\t}\n\t\t}\n\t\tif(f)\treturn parse(s.substr(1,s.length()-2));\n\t}\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=s.length()-1,d=0;i>=1;i--){\n\t\tif     (s[i]==')')\td--;\n\t\telse if(s[i]=='(')\td++;\n\n\t\telse if(d==0 && prior[s[i]]!=0){\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atoll(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n\n\twhile(1);\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nint sum(string s,int& i);\nint mul(string s,int& i);\nint bracket(string s,int& i);\nint num(string s,int& i);\n\nbool isdigit(char c){\n    int x=c-'0';\n    return 0<=x&&x<=9;\n}\n\nint sum(string s,int& i){\n    int ret=mul(s,i);\n    while(s[i]=='+'||s[i]=='-'){\n        char op=s[i];\n        i++;\n        int res=mul(s,i);\n        if(op=='+')ret+=res;\n        else ret-=res;\n    }\n    return ret;\n}\nint mul(string s,int& i){\n    int ret=bracket(s,i);\n    while(s[i]=='*'||s[i]=='/'){\n        char op=s[i];\n        i++;\n        int res=bracket(s,i);\n        if(op=='*')ret*=res;\n        else ret/=res;\n    }\n    return ret;\n}\n\nint bracket(string s,int& i){\n    if(isdigit(s[i]))return num(s,i);\n    i++;\n    int ret=sum(s,i);\n    i++;\n    return ret;\n}\n\nint num(string s,int& i){\n    int ret=s[i]-'0';\n    i++;\n    while(isdigit(s[i])){\n        ret=10*ret+(int)(s[i]-'0');\n        i++;\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(j,n){\n        string s;\n        cin>>s;\n        int i=0;\n        cout<<sum(s,i)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cassert>\n#include<cctype>\nusing namespace std;\n\nstring s;\nint cur=0;\n\nchar readchar()\n{\n    assert(cur<s.size());\n    char ret=s[cur];\n    cur+=1;\n    return ret;\n}\n\nchar peek()\n{\n    assert(cur<s.size());\n    return s[cur];\n}\n\nint digit()\n{\n    assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n\nint number()\n{\n    int n=digit();\n    while (cur < s.size() && isdigit(peek()))\n       n=n*10+digit();\n    return n;\n}\n\nint expression();\n\nint factor()\n{\n    if(peek()!='(')  \n      return number();\n    cur+=1;\n    int n=expression();\n    assert(peek()==')');\n    cur+=1;\n    return n;\n}\n\nint term()\n{\n    int a=factor();\n    while((cur<s.size()) && (peek()=='*'||peek()=='/'))\n    {\n        char op=readchar();\n        int b=factor();\n        if(op =='*')  a *=b;\n        else a /=b;\n    }\n    return a;\n}\n\nint expression()\n{\n    int a=term();\n    while(cur<s.size()&&(peek()=='+'||peek()=='-'))\n    {\n        char op=readchar();\n        int b=term();\n        if(op=='+')  a +=b;\n        else  a -=b;\n    }\n    return a;\n}\n\nint parse()\n{\n    return expression();\n}\n\nint main()\n{\n    int n,a;\n    cin >> n;\n    for(int i=0;i<n;i++)\n    {\n        cin >> s;\n        cur=0;\n        a=parse();\n        cout << a << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nstring s;\n \ntypedef string::const_iterator State;\nint expression(State&);\nint term(State&);\nint number(State&);\nint factor(State&);\n \nint expression(State &begin){\n  int ret = term(begin);\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      ret += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n \n \nint term(State &begin){\n  int ret = factor(begin);\n  while(1){\n    if(*begin == '*'){\n      begin++;\n      ret *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      int tmp = factor(begin);\n      ret /= tmp;\n    }\n    else break;\n  }\n  return ret;\n}\n \nint number(State &begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin-'0';\n    begin++;\n  }\n  return ret;\n}\n \nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++;\n    return ret;\n  }\n  else return number(begin);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int i = 0 ; i < n ; i++){\n    cin >> s;\n    State ss = s.begin();\n    int ans = expression(ss);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\nint pos;\nstring str;\n\nint str_to_int(string str) {\n\tif (str == \"\") return 0;\n\n\tint ret = 0;\n\n\tstringstream ss;\n\tss << str;\n\tss >> ret;\n\n\treturn ret;\n}\n\nint keisan();\nint kou();\nint number();\n\nint keisan() {\n\tint left = kou();\n\n\twhile (str[pos] != '=' && str[pos] != ')') {\n\t\tchar c = str[pos++];\n\t\tint right = kou();\n\n\t\tif (c == '+') left += right;\n\t\telse left -= right;\n\t}\n\t++pos;\n\n\treturn left;\n}\nint kou() {\n\tint left = number();\n\n\twhile (str[pos] == '*' || str[pos] == '/') {\n\t\tchar c = str[pos++];\n\t\tint right = number();\n\n\t\tif (c == '*') left *= right;\n\t\telse left /= right;\n\t}\n\n\treturn left;\n}\nint number() {\n\tstring ret = \"\";\n\n\tif (str[pos] == '(') {\n\t\t++pos;\n\t\treturn keisan();\n\t}\n\twhile (str[pos] >= '0' && str[pos] <= '9')\n\t\tret += str[pos++];\n\n\treturn str_to_int(ret);\n}\n\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> str;\n\n\t\tpos = 0;\n\n\t\tcout << keisan() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tsize1 = res.substr(j + 1, i - j - 1).size();\n\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t}\n\n\t//cout << \"!!\" << res << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tif (i == 0)continue;\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = res.substr(j, i - j).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\t//cout << \"!!\" << i  << endl;\n\t\t//cout << res << endl;\n\t\tint pos1, pos2, size;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\t//cout << res.substr(pos1 + 1, pos2 - pos1 - 1) << endl;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tsize = buf.size();\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2 + 1, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = pos1 + size - 1;\n\t\t\t//cout << \"!\" << i << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nstruct RevPolElement\n{\n\tRevPolElement(int type, int n) : type(type), n(n) { }\n\tint type;\n\tint n;\n};\n\ndeque<RevPolElement> make_revpol(char* s)\n{\n\tmap<char, int> pr;\n\tpr['w'] = -1;\n\tpr['('] = 0;\n\n\tpr['+'] = pr['-'] = 1;\n\tpr['*'] = pr['/'] = 2;\n\n\tdeque<RevPolElement> res;\n\tstack<char> t;\n\tt.push('w');\n\tfor (int i = 0; s[i] != '='; ++i)\n\t{\n\t\tif (isdigit(s[i]))\n\t\t{\n\t\t\tint t = s[i] - '0';\n\t\t\twhile (isdigit(s[i+1]))\n\t\t\t\tt = t*10 + s[i++] - '0';\n\t\t\tres.push_back(RevPolElement(0, t));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar op = s[i];\n\t\t\tif (op == ')')\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tchar topOp = t.top();\n\t\t\t\t\tt.pop();\n\t\t\t\t\tif (topOp == '(')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tres.push_back(RevPolElement(1, topOp));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (op == '(')\n\t\t\t\tt.push(op);\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (pr[op] <= pr[t.top()])\n\t\t\t\t{\n\t\t\t\t\tres.push_back(RevPolElement(1, t.top()));\n\t\t\t\t\tt.pop();\n\t\t\t\t}\n\t\t\t\tt.push(op);\n\t\t\t}\n\t\t}\n\t}\n\twhile (t.size() > 1)\n\t{\n\t\tres.push_back(RevPolElement(1, t.top()));\n\t\tt.pop();\n\t}\n\n\treturn res;\n}\n\nint calculate_revpol(deque<RevPolElement> revpol)\n{\n\tstack<int> t;\n\twhile (!revpol.empty())\n\t{\n\t\tif (revpol.front().type)\n\t\t{\n\t\t\tchar op = revpol.front().n;\n\t\t\tint a, b;\n\t\t\tb = t.top(); t.pop();\n\t\t\ta = t.top(); t.pop();\n\t\t\tint c;\n\t\t\tif (op == '+')\n\t\t\t\tc = a + b;\n\t\t\telse if (op == '-')\n\t\t\t\tc = a - b;\n\t\t\telse if (op == '*')\n\t\t\t\tc = a * b;\n\t\t\telse if (op == '/')\n\t\t\t\tc = a / b;\n\n\t\t\tt.push(c);\n\t\t}\n\t\telse\n\t\t\tt.push(revpol.front().n);\n\n\t\trevpol.pop_front();\n\t}\n\n\treturn t.top();\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcin.get();\n\t\twhile (n--)\n\t\t{\n\t\t\tchar buf[256];\n\t\t\tcin.getline(buf, sizeof(buf));\n\t\t\tprintf(\"%d\\n\", calculate_revpol(make_revpol(buf)));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &begin);\n\nint number(State &begin) {\n    int ret = 0;\n    \n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    \n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n\nint term(State &cur) {\n    int ret = factor(cur);\n    \n    while(*cur=='*' || *cur=='/'){\n        if (*cur == '*') {\n            cur++;\n            ret *= factor(cur);\n        } else if (*cur == '/') {\n            cur++;\n            ret /= factor(cur);\n        }\n    }\n    \n    return ret;\n}\n\nint expression(State &cur) {\n    int ret = term(cur);\n    \n    while(*cur=='+' || *cur=='-'){\n        if (*cur == '+') {\n            cur++;\n            ret += term(cur);\n        } else if (*cur == '-') {\n            cur++;\n            ret -= term(cur);\n        }\n    }\n    \n    return ret;\n}\n\nint main(void) {\n    int N; cin >> N;\n    while(N--){\n        string s;\n        cin >> s;\n        State cur = s.begin();\n        cout << expression(cur) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 構文解析の練習\n// https://gist.github.com/draftcode/1357281\n#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef string::const_iterator State;\nclass ParseError{};\nint number(State&);\nint term(State&);\nint expression(State&);\nint factor(State&);\n\nint number(State& begin) {\n    int ret = 0;\n    while(isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\nint term(State& begin) {\n    int ret = factor(begin);\n\n    while(1) {\n        if(*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n\n}\nint expression(State& begin) {\n    int ret = term(begin);\n    \n    while(1) {\n        if(*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n\n}\nint factor(State& begin) {\n    int ret = 0;\n    if(*begin == '(') {\n        begin++; // ( を飛ばす\n        ret = expression(begin);\n        begin++; // ) を飛ばす\n    }\n    else {\n        ret = number(begin);\n    }\n\n    return ret;\n}\n\nint main() {\n    int N;\n    cin>>N;\n    cin.ignore();\n    rep(i,N) {\n        string s;\n        getline(cin,s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '/':\n    return 2;\n  case '*':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif((cs == '*' || cs == '/') && (str[i] == '*' || str[i] == '/')){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\tif((cs == '+' || cs == '-') && (str[i] == '+' || str[i] == '-')){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse if(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    hand.push_back(side[i]);\n  }\n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      long long val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  cin >> n;\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return -1;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    string s;\n    while(cin >> s){\n        if(s.back() == '='){\n            s.erase(--s.end());\n        }\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nint number(const string &s, int &k);\nint fact(const string &s, int &k);\nint term(const string &s, int &k);\n\nint expr(const string &s, int &k){\n  int result = term(s,k);\n  while(true){\n    if(s[k]=='+')result += term(s,++k);\n    else if(s[k]=='-')result -= term(s,++k);\n    else break;\n  }\n  return result;\n}\n\nint term(const string &s, int &k){\n  int res = fact(s,k);\n  while(true){\n    if(s[k]=='*')return res *= fact(s,++k);\n    else if(s[k]=='/')return res /= fact(s,++k);\n    else break;\n  }\n  return res;\n}\n\nint fact(const string &s, int &k){\n  if(s[k]=='('){\n    int res = 0;\n    ++k;\n    res = expr(s,k);\n    k++;\n    return res;\n  }\n  return number(s,k);\n}\n\nint number(const string &s, int &k){\n  int res = 0;\n  while(isdigit(s[k])){\n    res *= 10;\n    res += (int)(s[k++] - '0');\n  }\n  return res;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  while(n--){\n    string s;\n    cin >> s;\n    int k = 0;\n    cout << expr(s, k) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parse{\n    typedef string::const_iterator itr;\n    itr begin;\n    T ans;\n    Parse(const string &s){\n        begin=s.begin();\n        ans=expr(begin);\n        cerr<<s<<\" \"<<ans<<\"\\n\";\n    }\n    T expr(itr &begin){\n        T ret=term(begin);\n        while(1){\n            if((*begin)=='+'){\n                consume(begin,'+');\n                ret+=term(begin);\n            }else if((*begin)=='-'){\n                consume(begin,'-');\n                ret-=term(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    T numb(itr &begin){\n        T ret=0;\n        while('0'<=(*begin)&&(*begin)<='9'){\n            ret*=10;\n            ret+=(*begin)-'0';\n            begin++;\n        }\n        return ret;\n    }\n    T fact(itr &begin){\n        T ret=0;\n        if((*begin)=='('){\n            consume(begin,'(');\n            ret=expr(begin);\n            consume(begin,')');\n        }else{\n            ret=numb(begin);\n        }\n        return ret;\n    }\n    T term(itr &begin){\n        T ret=fact(begin);\n        while(1){\n            if((*begin)=='*'){\n                consume(begin,'*');\n                ret*=fact(begin);\n            }else if((*begin)=='/'){\n                consume(begin,'/');\n                ret/=fact(begin);\n            }else{\n                return ret;\n            }\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n            throw;\n        }\n    }\n};\n\nint main(){\n    int n; cin>>n;\n    while(n--){\n        string s; cin>>s;\n        Parse<int> parse(s);\n        cout<<parse.ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nstring str;\nint cnt;\n\nint digit(){\n    assert(isdigit(str[cnt]));\n    int n=str[cnt++]-'0';\n    return n;\n}\nint number(){\n    int n=digit();\n    while(cnt<str.size()&&isdigit(str[cnt])){\n        n*=10;\n        n+=digit();\n    }\n    return n;\n}\nint term(void);\nint fact(void);\n\nint exp(void){\n    int s0=term();\n    while(cnt<str.size()){\n        char op=str[cnt];\n        if(op!='+'&&op!='-')\n            break;\n        cnt++;\n        int s1=term();\n        switch(op){\n            case '+':\n                s0+=s1;\n                break;\n            case '-':\n                s0-=s1;\n                break;\n            default:\n                assert(0);\n        }\n    }\n    return s0;\n}\nint term(void){\n    int s0=fact();\n    while(cnt<str.size()){\n        char op=str[cnt];\n        if(op!='*'&&op!='/')\n            break;\n        cnt++;\n        int s1=fact();\n        switch(op){\n            case '*':\n                s0*=s1;\n                break;\n            case '/':\n                s0/=s1;\n                break;\n            default:\n                assert(0);\n        }\n    }\n    return s0;\n}\n\nint fact(void){\n    if(str[cnt]=='('){\n        cnt++;\n        int n=exp();\n        assert(str[cnt]==')');\n        cnt++;\n        return n;\n    }\n    return number();\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>str;\n        cnt=0;\n        cout<<exp()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    return 0;\n}\n\n// class Mycin {\n// \tbool flag = true;\n// public:\n// \tMycin& operator >> (int& a) {flag = scanf(\"%lld\", &a) != EOF; return *this;}\n// \tMycin& operator >> (char& a) {flag = scanf(\"%c\", &a) != EOF; return *this;}\n// \tMycin& operator >> (string& s) {flag = (bool)(cin >> s); return *this;}\n// \toperator bool() {return flag;}\n// } mycin;\n \n// class Mycout {\n// public:\n// \tMycout& operator << (const int& a) {printf(\"%lld\", a); return *this;}\n// \tMycout& operator << (const char c) {printf(\"%c\", c); return *this;}\n// \tMycout& operator << (const string& s) {printf(\"%s\", s.c_str()); return *this;}\n// } mycout;\n \n// #define cin mycin\n// #define cout mycout\n// #define endl '\\n'\n\nint number(const string& s, int& i);\nint factor(const string& s, int& i);\nint term(const string& s, int& i);\nint expr(const string& s, int& i);\n\nint number(const string& s, int& i) {\n    int res = 0;\n    bool minus_flag = false;\n    if (s[i] == '-') {\n        minus_flag = true;\n        i++;\n    }\n    for (; isdigit(s[i]); i++) {\n        res *= 10;\n        res += s[i] - '0';\n    }\n    if (minus_flag) res *= -1;\n    return res;\n}\n\nint factor(const string& s, int& i) {\n    if (isdigit(s[i]) || s[i] == '-') return number(s, i);\n    i++;\n    int res = expr(s, i);\n    i++;\n    return res;\n}\n\nint term(const string& s, int& i) {\n    int res = factor(s, i);\n    while (s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        i++;\n        int a = factor(s, i);\n        if (op == '*') res *= a;\n        else           res /= a;\n    }\n    return res;\n}\n\nint expr(const string& s, int& i) {\n    int res = term(s, i);\n    while (s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        i++;\n        int a = term(s, i);\n        if (op == '+') res += a;\n        else           res -= a;\n    }\n    return res;\n}\n\nint eval(const string& s) {\n    int i = 0;\n    return expr(s, i);\n}\n\nvoid solve() {\n    int N;\n    string s;\n    cin >> N;\n    rep(i, N) {\n        cin >> s;\n        cout << eval(s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint digits(auto& i) {\n  int res = 0;\n  while (isdigit(*i)) res = 10 * res + *i++ - '0';\n  return res;\n}\nint expr(auto& i);\nint num(auto& i) {\n  switch (*i) {\n    case '+': return num(++i);\n    case '-': return -num(++i);\n    case '(': {\n      int res = expr(++i);\n      return ++i, res;\n    }\n    default: return digits(i);\n  }\n}\nint term(auto& i) {\n  int res = num(i);\n  while (true) switch (*i) {\n    case '*': res *= num(++i); break;\n    case '/': res /= num(++i); break;\n    default: return res;\n  }\n}\nint expr(auto& i) {\n  int res = term(i);\n  while (true) switch (*i) {\n    case '+': res += term(++i); break;\n    case '-': res -= term(++i); break;\n    default: return res;\n  }\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  while (n--) {\n    string s; cin >> s;\n    auto i = begin(s);\n    cout << expr(i) << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n#include <cctype>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5+10;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\ntypedef string::const_iterator SC;\n\nint factor(SC&);\n\n// ??°????????????\nint number(SC& begin){\n  int res = 0;\n\n  while(isdigit(*begin)){\n    res *= 10;\n    res += *begin - '0';\n    begin++;\n  }\n\n  return res;\n}\n\n// ??????\nint term(SC& begin){\n  int res = factor(begin);\n\n  while(1){\n    if(*begin == '*'){\n      begin++;\n      res *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      res /= factor(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return res;\n}\n\n// ????????????\nint expression(SC& begin){\n  int res = term(begin);\n\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      res += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      res -= term(begin);\n    }\n    else{\n      break;\n    }\n  }\n  return res;\n}\n\n// ??¬??§?????°????????????\nint factor(SC& begin){\n  if (*begin == '('){\n    begin++;\n    int res = expression(begin);\n    begin++;\n    return res;\n  }\n  else{\n    return number(begin);\n  }\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tREP(i,n){\n\t\tcin >> s;\n\t\tSC begin = s.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\n//parsed expr(const char* s)\n//{\n//\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tparsed now=term(s);\n//\t//while(*now.second!='=' && *now.second!=')'){\n//\twhile(*now.second=='+' || *now.second=='-'){\n//\t\tchar op=*now.second;\n//\t\tparsed next=term(now.second+1);\n//\t\tif(op=='+')\n//\t\t\tnow=parsed(now.first+next.first,next.second);\n//\t\telse\n//\t\t\tnow=parsed(now.first-next.first,next.second);\n//\t}\n//\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n//\treturn now;\n//}\n//\n//parsed term(const char* s)\n//{\n//\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tparsed now=fact(s);\n//\t//while(*now.second!='=' && *now.second!=')' && *now.second!='+' && *now.second!='-'){\n//\twhile(*now.second=='*' || *now.second=='/'){\n//\t\tchar op=*now.second;\n//\t\tparsed next=fact(now.second+1);\n//\t\tif(op=='*')\n//\t\t\tnow=parsed(now.first*next.first,next.second);\n//\t\telse\n//\t\t\tnow=parsed(now.first/next.first,next.second);\n//\t}\n//\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n//\treturn now;\n//}\n//\n//parsed fact(const char* s)\n//{\n//\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tif(s[0]=='('){\n//\t\tparsed res=expr(s+1);\n//\t\tres.second++;\n//\t\treturn res;\n//\t}\n//\telse{\n//\t\tconst char* p=s;\n//\t\tif(*p=='-')\n//\t\t\tp++;\n//\t\tll n=0;\n//\t\twhile(isdigit(*p)){\n//\t\t\tn=n*10+*p-'0';\n//\t\t\tp++;\n//\t\t}\n//\t\treturn parsed(n,p);\n//\t}\n//}\n\nparsed expr(const char *p)\n{\n  parsed r=term(p);\n  while(*r.second=='+'||*r.second=='-'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=term(r.second+1);\n    if (op=='+') r.first=tmp+r.first;\n    else r.first=tmp-r.first;\n  }\n  return r;\n}\n\nparsed term(const char *p)\n{\n  parsed r=fact(p);\n  while(*r.second=='*'||*r.second=='/'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=fact(r.second+1);\n    if (op=='*') r.first=tmp*r.first;\n    else r.first=tmp/r.first;\n  }\n  return r;\n}\n\nparsed fact(const char *p)\n{\n  if (isdigit(*p)){\n    int t=*(p++)-'0';\n    while(isdigit(*p)) t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if (*p=='('){\n    parsed r=expr(p+1);\n    if (*r.second!=')') exit(0); // invalid input\n    return parsed(r.first,r.second+1);\n  }\n  else\n    exit(0); // invalid input\n}\n\nint main()\n{\n\t//const char* s=\"-6/-4=\";\n\t//parsed p=expr(s);\n\t//cout<<p.first<<\",\"<<p.second<<endl;\n\t\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\n#if 0\n所用時間:\n\n感想:\n\n#endif\n\nstring S;\nsize_t cur;\n\nint expression();\nint factor();\n\nchar readchar(){\n    assert(cur < S.size());\n    char ret =  S[cur];\n    cur += 1;\n    return ret;\n} \n\nchar peek(){\n    // assert(cur < S.size());\n    return S[cur];\n}\n\nint digit(){\n    // assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while( cur < S.size() && isdigit(peek()))\n        n = n * 10 + digit();\n    return n;\n}\n\nint term(){\n    int a = factor();\n    while(cur < S.size() && (peek()=='*' || peek()=='/')){\n        char op = readchar();\n        int b = factor();\n        if(op=='*') a*= b;\n        else a /= b;\n        cout << \"calc: \" << a << \" \" << op << \" \" << b << endl;\n    }\n    return a;\n}\n\nint factor(){\n    if (peek() == '('){\n        cur += 1;\n        int n = expression();\n        assert(peek() == ')');\n        cur += 1;\n        return n;\n        }\n    else return number();\n}\n\nint expression(){\n    int a = term();\n    while(cur < S.size() && (peek()=='+' || peek()=='-')){\n        char op = readchar();\n        int b = term();\n        cout << \"calc: \" << a << \" \" << op << \" \" << b << endl;\n        if(op == '+'){\n            a += b;\n        }else{\n            a -= b;\n            }\n    }\n    return a;\n}\n\n\nint parse(){\n    return expression();\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i){\n        cin >> S;\n        cur = 0;\n        S.resize(S.size()-1); // 最後の=を無視\n        int a = parse();\n        cout << a << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nstring toReversePorland(string str){\n  string hand;\n  string side;\n\n  // ÊàtO                                                                          \n  bool isInside = false;\n\n  for(int i = 0; i < str.size(); i++){\n    //    cout << str[i] << endl;                                                          \n    //    cout << hand << endl;                                                            \n    //    cout << side << endl;                                                            \n\n    if(str[i] >= '0' && str[i] <= '9'){\n      hand += str[i];\n    }\n    else if(str[i] == '('){\n      isInside = true;\n      side += str[i];\n    }\n    else if(isInside && str[i] == ')'){\n      // EÊÜÅZqðêÂ¸Âè³Éß·                                              \n      //      cout << side << endl;                                                        \n      for(int j = side.size()-1 ; ;j--){\n        if(side[j] == '('){\n          if(j != 0){\n            side = side.substr(0,j) + \"\";\n            //      cout << side << endl;                                                  \n          }\n          else\n            side = \"\";\n          break;\n        }\n\telse{\n          hand += side[j];\n        }\n      }\n      isInside = false;\n    }\n\n    else{\n      if(side.size() == 0){\n        side += str[i];\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n        if(side[side.size()-1] == '*' || side[side.size()-1] == '/'){\n          hand += side[side.size()-1];\n          side[side.size()-1] = str[i];\n        }\n        else{\n          //      cout << str[i] << endl;                                                  \n          side += str[i];\n        }\n      }\n      else{\n        if(side[side.size()-1] == '*' || side[side.size()-1] == '/'){\n          hand += side[side.size()-1];\n          side[side.size()-1] = str[i];\n        }\n        else\n          side += str[i];\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand += side[i];\n  }\n  return hand;\n}\n\nint calc(string str){\n\n  cout << str << endl;\n  //  string stack;                                                                        \n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] >= '0' && str[i] <= '9'){\n      st.push(str[i] - '0');\n    }\n    else{\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == '+'){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == '-'){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == '*'){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == '/'){\n\tst.push(val[1] / val[0]);\n      }\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  string str;\n  getline(cin,str);\n\n  cout << calc(toReversePorland(str)) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nenum Symbol { EXPS,EXPE,TERMS,TERME,FACTOR };\n\nint exp(string &s,int &cur){\n\n  stack<Symbol> sstack;\n  stack<int> vstack;\n  stack<char> ostack;\n  sstack.push(EXPS);\n  ostack.push('@'); // dammy;\n  while( !sstack.empty() ){\n    Symbol syb = sstack.top();\n    char opr;\n    int v1,v2,value;\n    switch(syb){\n    case EXPS:\n      sstack.pop();\n      sstack.push(EXPE);\n      sstack.push(TERMS);\n      break;\n\n    case EXPE:\n      opr = ostack.top();\n      if( opr == '+' || opr == '-' ) {\n        ostack.pop();\n        v1 = vstack.top(); vstack.pop();\n        v2 = vstack.top(); vstack.pop();\n        vstack.push(((opr=='+')?(v2+v1):(v2-v1)));\n      }\n      if( s[cur] == '+' || s[cur] == '-' ){\n        sstack.push(TERMS);\n        ostack.push(s[cur++]);\n      } else {\n        sstack.pop();\n      }\n      break;\n\n    case TERMS:\n      sstack.pop();\n      sstack.push(TERME);\n      sstack.push(FACTOR);\n      break;\n\n    case TERME:\n      opr = ostack.top();\n      if( opr == '*' || opr == '/' ){\n        ostack.pop();\n        v1 = vstack.top(); vstack.pop();\n        v2 = vstack.top(); vstack.pop();\n        vstack.push(((opr=='*')?(v2*v1):(v2/v1)));\n      }\n\n      if( s[cur] == '*' || s[cur] == '/' ){\n        sstack.push(FACTOR);\n        ostack.push(s[cur++]);\n      } else {\n        sstack.pop();\n      }\n      break;\n\n    case FACTOR:\n      if( s[cur] == '(' ){\n        ++cur;\n        sstack.push(EXPS);\n        ostack.push('(');\n      } else if( s[cur] == ')' ){\n        ++cur;\n        sstack.pop();\n        ostack.pop();\n      } else if( '0' <= s[cur] && s[cur] <= '9' ) {\n        value = 0;\n        while( '0' <= s[cur] && s[cur] <= '9' )( value *= 10 ) += s[cur++] - '0';\n        vstack.push(value);\n        sstack.pop();\n      } else assert(false); // invalid form\n      break;\n\n    default:\n      break;\n    }\n\n  }\n  assert(vstack.size() == 1);\n  return vstack.top();\n}\n\nint main(){\n  int T;\n  cin >> T;\n  cin.ignore();\n  while(T--){\n    string s;\n    int cur = 0;\n    getline(cin,s);\n    cout << exp(s,cur) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint p;\nstring exp;\n\nint term();\nint expression();\nint factor();\n\n\nint expression(){\n     int value;\n\t value=term();\n\t while(exp[p]=='+' || exp[p]=='-'){\n\t\t if(exp[p]=='+'){\n\t\t\t p++;\n\t\t\t value+=term();\n\t\t }\n\t\t else{\n\t\t\t p++;\n\t\t\t value-=term();\n\t\t }\n\t }\n\t return value;\n}\n\n\nint term(){\n\tint value;\n\tvalue=factor();\n\twhile(exp[p]=='*' || exp[p]=='/'){\n\t\tif(exp[p]=='*'){\n\t\t\tp++;\n\t\t\tvalue*=factor();\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\tvalue/=factor();\n\t\t}\n\t}\n\n\treturn value;\n}\n\nint factor(){\n\tint value=0;\n\tif(exp[p]=='('){\n\t\tp++;\n\t\tvalue=expression();\n\t\tp++;\n\t}\n\telse{\n\t\twhile(isdigit(exp[p])){\n\t\t\tvalue=value*10+exp[p++]-'0';\n\t\t}\n\t}\n\treturn value;\n}\n\n\n\nint main()\n{\n\tint i,c;\n\tcin>>c;\n\tfor(i=0;i<c;i++){\n\t\tcin>>exp;\n\t\tp=0;\n\t\tcout<<expression()<<\"\\n\";\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// 再帰的下向き構文解析\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint expression(void);\n\nstring str;\nint pos;\n\nint factor(void){\n\n  int num = 0;\n  if( isdigit( str[pos] ) ){ // '0' <= str[pos] && str[pos] <= '9' \n    while( isdigit( str[pos] ) ){\n      num *= 10;\n      num += str[pos] - '0';\n      pos++;\n    }\n    return num;\n  }else if( str[pos] == '(' ){\n    pos++;\n    int res = expression();\n    pos++; // ')' の分\n    return res;\n  }\n\n}\n\nint term(void){\n\n  int res = factor();\n  while(1){\n\n    if( str[pos] == '*' ){\n      pos++;\n      res *= factor();\n    }else if( str[pos] == '/' ){\n      pos++;\n      res /= factor();\n    }else break;\n\n  }\n  return res;\n}\n\nint expression(void){\n\n  int res = term();\n  while(1){\n\n    if( str[pos] == '+' ){\n      pos++;\n      res += term();\n    }else if( str[pos] == '-' ){\n      pos++;\n    res -= term();\n    }else break;\n\n  }\n  return res;\n}\n\nint main(void){\n\n  int dn;\n  cin >> dn;\n\n  while(dn--){\n    pos = 0;\n    cin >> str;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\n\n/*\nequation := equation + factor | factor\nfactor   := factor   * term   | term\nterm     := (equation) | Number \n\n↓\n\nequation := factor (+ factor)*\nfactor   := term (* term)*\nterm     := (equation) | Number \n */\nint equation();\nint term();\nint factor();\nint id;\nstring s;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\t\n\twhile(n--)\n\t{\n\t\tcin >> s;\n\t\tid = 0;\n\t\tcout << equation() << endl;\n\t}\n}\n\nint equation()\n{\n\tint left = term();\n\twhile(s[id] == '+' || s[id] == '-')\n\t{\n\t\tif(s[id] == '+')\n\t\t{\n\t\t\tid++;\n\t\t\tint right = term();\n\t\t\tleft += right;\n\t\t}\n\t\tif(s[id] == '-')\n\t\t{\n\t\t\tid++;\n\t\t\tint right = term();\n\t\t\tleft -= right;\n\t\t}\n\t}\n\treturn left;\n}\nint term()\n{\n\tint left = factor();\n\twhile(s[id] == '*' || s[id] == '/')\n\t{\n\t\tif(s[id] == '*')\n\t\t{\n\t\t\tid++;\n\t\t\tint right = factor();\n\t\t\tleft *= right;\n\t\t}\n\t\tif(s[id] == '/')\n\t\t{\n\t\t\tid++;\n\t\t\tint right = factor();\n\t\t\tleft /= right;\n\t\t}\n\t}\n\treturn left;\n}\nint factor()\n{\n\tchar c = s[id];\n\tif(c == '(')\n\t{\n\t\tid++;\n\t\tint res = equation();\n\t\tid++;\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\tint res = 0;\n\t\twhile(isdigit(s[id]))\n\t\t{\n\t\t\tres = res*10 + (s[id++]-'0');\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nclass CalcExpression\n{\n\ttypedef string::const_iterator State;\n\tclass ParseError {};\n\n\npublic:\n\n\tint expression(State& begin)\n\t{\n\t\tint ret = term(begin);\n\n\t\twhile(true)\n\t\t{\n\t\t\tif(*begin == '+')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret += term(begin);\n\t\t\t}\n\t\t\telse if(*begin == '-')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret -= term(begin);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\nprivate:\n\n\tint term(State& begin)\n\t{\n\t\tint ret = number(begin);\n\n\t\twhile(true)\n\t\t{\n\t\t\tif(*begin == '*')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret *= factor(begin);\n\t\t\t}\n\t\t\telse if(*begin == '/')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret /= factor(begin);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tint factor(State &begin)\n\t{\n\t\tint ret = 0;\n\n\t\tif(*begin == '(')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret = expression(begin);\n\t\t\tbegin++;\n\t\t}\n\t\telse return number(begin);\n\n\t\treturn ret;\n\t}\n\n\tint number(State& begin)\n\t{\n\t\tint ret = 0;\n\n\t\twhile(isdigit(*begin))\n\t\t{\n\t\t\tret *= 10;\n\t\t\tret += *begin - '0';\n\t\t\tbegin++;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tCalcExpression ce;\n\twhile(n--)\n\t{\n\t\tstring expression, buf;\n\n\t\tcin >> expression;\n\t\tstring::const_iterator it = expression.begin();\n\n\t\tcout << ce.expression(it) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\ntypedef pair<int,const char*>parsed;\nparsed expr(const char *p);\nparsed term(const char *p);\nparsed fact(const char *p);\nparsed expr(const char *p){\n  parsed r=term(p);\n while(*r.second=='+'||*r.second=='-'){\n    char op =*r.second;\n    int tmp=r.first;\n    r=term(r.second+1);\n    if(op=='+')r.first=tmp+r.first;\n    else r.first=tmp-r.first;\n  }\n  return r;\n}\nparsed term(const char *p){\n  parsed r=fact(p);\n  while(*r.second=='*'||*r.second=='/'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=fact(r.second+1);\n    if(op=='*')r.first=tmp*r.first;\n    else r.first=tmp/r.first;\n  }\n  return r;\n}\nparsed fact(const char *p){\n  if(isdigit(*p)){\n    int t=*(p++)-'0';\n    while(isdigit(*p))t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if(*p=='('){\n    parsed r=expr(p+1);\n    if(*r.second!=')')exit(0);\n    return parsed(r.first,r.second+1);\n  }\n  else exit(0);\n}\nmain(n){\n  string str;\n  cin>>n;\n  while(n--){\n\t  cin>>str;\n    cout<<expr(str.c_str()).first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\tif(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\treturn foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\t// return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn s;\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x) << endl;\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\tif (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\tif (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\n\tif(str[i] != '(')val1 = number(str, i);\n\tif(str[i] == '(') {\n\t\ti++;\n\t\tval1 += siki(str, i);\n\t\ti += 1;\n\t}\n\n\t\n\t\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tval1 = val1 * 10;\n\t\t\tval1 += number(str, i);\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin(); it!=(c).end(); it++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pr(a) cout << (a) << endl\n#define PR(a,b) cout << (a) << \" \" << (b) << endl;\n#define F first\n#define S second\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAX=1000000001;\nconst ll MAXL=1000000000000000001LL;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nstring s;\nstring::iterator p;\nint fact();\nint term();\nint exp();\n\nint fact() {\n  int x;\n  string num;\n  while(isdigit(*p)) {\n    num += *p;\n    ++p;\n  }\n  if(num.size()) {\n    x = atoi(num.c_str());\n  } else {\n    ++p;\n    x = exp();\n    ++p;\n  }\n  return x;\n}\n \nint term() {\n  int x = fact();\n  while(*p == '*' || *p == '/') {\n    if(*p == '*') {\n      ++p;\n      x *= fact();\n    } else {\n      ++p;\n      x /= fact();\n    }\n  }\n  return x;\n \n}\n \nint exp() {\n  int x = term();\n  while(*p == '+' || *p == '-') {\n    if(*p == '+') {\n      ++p;\n      x += term();\n    } else {\n      ++p;\n      x -= term();\n    }\n  }\n  return x;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    cin >> s;\n    p = s.begin();\n    cout << exp() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\nint expr(string& s, int& i) {\n    int val = term(s, i);\n    while (s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        ++i;\n        int val2 = term(s, i);\n        if (op == '+') val += val2;\n        else val -= val2;\n    }\n    return val;\n}\n\nint term(string& s, int& i) {\n    int val = factor(s, i);\n    while (s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        ++i;\n        int val2 = factor(s, i);\n        if (op == '*') val *= val2;\n        else val /= val2;\n    }\n    return val;\n}\n\nint factor(string& s, int& i) {\n    if (isdigit(s[i])) return number(s, i);\n    ++i;\n    int res = expr(s, i);\n    ++i;\n    return res;\n}\n\nint number(string& s, int& i) {\n    int res = s[i++] - '0';\n    while (isdigit(s[i])) res = res * 10 + s[i++] - '0';\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        string s;\n        cin >> s;\n        s = s.substr(0, s.size() - 1);\n        int j = 0;\n        cout << expr(s, j) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\n\nusing namespace std;\nint cur = 0;\nstring S;\nint expression();\nint term();\nint main() {\n  int times;\n  cin >>times;\n  for(int i = 0 ; i < times; i++){\n      cin >> S;\n      cur = 0;\n      S.resize(S.size()-1);\n      cout << expression() <<endl;\n  }\n\n}\nint digit() {\n  assert(isdigit(S[cur]));\n  int n = S[cur] -'0';\n  cur = cur+1;\n  return n;\n}\nint number() {\n  int n = digit();\n  while(cur <S.size() && isdigit(S[cur])){\n      n = n*10 + digit();\n  }\n  return n;\n}\nint expression() {\n  int sum = term();\n  while (S[cur] == '+' || S[cur] == '-'){\n    char op = S[cur];\n    cur +=1;\n    int b = term();\n    if(op ==  '+') sum +=b;\n    else sum -= b;\n  }\n  return sum;\n}\nint term() {\n  int a = number();\n  while(cur < S.size()\n        && (S[cur] == '*' || S[cur] == '/')){\n          char op = S[cur];\n          cur +=1;\n          int b = number();\n          if(op == '*') a *=b;\n          else a/=b;\n        }\n  return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <char> VC;\n\nstring toNums( string s ) {\n    string R = \"*/+\";\n    for ( int i = 0; i < 3; ++ i ) {\n        replace( s.begin(), s.end(), R[i], ' ' );\n    }\n    return s;\n}\n\nstring toOps( string s ) {\n    string R = \"0123456789-\";\n    for ( int i = 0; i < 11; ++ i ) {\n        replace( s.begin(), s.end(), R[i], ' ' );\n    }\n    return s;\n}\n\nint eval( string expr ) {\n    stack <int> S;\n    for ( int i = 0; i < (int)expr.size(); ++ i ) {\n        if ( expr[i] == '(' ) {\n            S.push( i );\n        } else if ( expr[i] == ')' ) {\n            int left = S.top();\n            int right = i;\n            string L = expr.substr( 0, left );\n            string M = expr.substr( left, right - left + 1 );\n            string R = expr.substr( right + 1 );\n            ostringstream os;\n            os << eval( M.substr( 1, M.size()-2 ) );\n            expr = L + os.str() + R;\n            i = -1;\n            S = stack <int>();\n            continue;\n        }\n    }\n    string nums = toNums( expr );\n    string ops = toOps( expr );\n    VI N;\n    int num;\n    istringstream is1( nums );\n    while ( is1 >> num ) {\n        N.push_back( num );\n    }\n    VC O;\n    char op;\n    istringstream is2( ops );\n    while ( is2 >> op ) {\n        O.push_back( op );\n    }\n    for ( int i = 0; i + 1 < (int)N.size(); ++ i ) {\n        int a = N[i], b = N[i+1];\n        char c = O[i];\n        if ( c == '*' ) {\n            N.erase( N.begin() + i );\n            char cc = O[i+1];\n            O.erase( O.begin() + i );\n            N[i] = a * b;\n            O[i] = cc;\n            i --;\n        } else if ( c == '/' ) {\n            N.erase( N.begin() + i );\n            char cc = O[i+1];\n            O.erase( O.begin() + i );\n            N[i] = a / b;\n            O[i] = cc;\n            i --;\n        }\n    }\n    int answer = accumulate( N.begin(), N.end(), 0 );\n    return answer;\n}\n\nbool isOp( char c ) {\n    string O = \"+-*/\";\n    for ( int i = 0; i < 4; ++ i ) {\n        if ( c == O[i] ) return true;\n    }\n    return false;\n}\n\nstring convert( string s ) {\n    for ( int i = 0; i < (int)s.size(); ++ i ) {\n        if ( s[i] != '-' ) continue;\n        string L = s.substr( 0, i );\n        string R = s.substr( i );\n        s = L + ( (i>0 && isOp( s[i-1] )) || i == 0 ? \" \" : \"+\" ) + R;\n        i ++;\n    }\n    return s;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        if ( n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            string line;\n            cin >> line;\n            line = convert( line );\n            cout << eval( line.substr( 0, line.size() - 1 ) ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstring S;\nchar U[11]=\"0123456789\";\nint junjo[4]={0,0,1,1};\n\nlong long STOI(string V){\n\tint LEN=V.size();\n\tif(LEN==0){return 0;}\n\treturn (V[LEN - 1] - '0') + 10 * ( STOI(V.substr(0, LEN - 1)) );\n}\nlong long calc(int L,int R){\n\tint K=0;\n\tvector<int>junjo2[4];\n\tfor(int i=0;i<4;i++){\n\t\tjunjo2[junjo[i]].push_back(i);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tif(junjo2[i].size()>=1){\n\t\t\tfor(int j=R-1;j>=L;j--){\n\t\t\t\tif(S[j]=='('){K++;}\n\t\t\t\tif(S[j]==')'){K--;}\n\t\t\t\tfor(int k=0;k<junjo2[i].size();k++){\n\t\t\t\t\tif(junjo2[i][k]==0){\n\t\t\t\t\t\tif(S[j]=='+' && K==0){\n\t\t\t\t\t\t\treturn calc(L,j)+calc(j+1,R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(junjo2[i][k]==1){\n\t\t\t\t\t\tif(S[j]=='-' && K==0){\n\t\t\t\t\t\t\treturn calc(L,j)-calc(j+1,R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(junjo2[i][k]==2){\n\t\t\t\t\t\tif(S[j]=='*' && K==0){\n\t\t\t\t\t\t\treturn calc(L,j)*calc(j+1,R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(junjo2[i][k]==3){\n\t\t\t\t\t\tif(S[j]=='/' && K==0){\n\t\t\t\t\t\t\treturn calc(L,j)/calc(j+1,R);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n\treturn STOI(S.substr(L,R-L));\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>S;\n\t\tcout<<calc(0,S.size()-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cctype>\n\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State &begin);\n\n//数字の列をパースして、その数を返す。\nint number(State &begin){\n\tint ret=0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin -'0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t        begin++; // '('を飛ばす。\n\t        int ret = expression(begin);\n\t        begin++; // ')'を飛ばす。\n\t\treturn ret;\n\t} else {\n        \treturn number(begin);\n\t}\n}\n\n//乗除の式をパースして、その評価結果を返す。\nint term(State &begin){\n\tint ret = factor(begin);\n\n\twhile(1){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n//四則演算の式をパースして、その評価結果を返す。\nint expression(State &begin){\n\tint ret = term(begin);\n\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else if(*begin=='='){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\tint I[100],Ii=0,n;\n\tstring s;\n\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s;\n\t\t\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tI[Ii++] = ans;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tcout << I[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\tif(!op.empty())\n\t\tcalc();\n\t//cout << num.top() << endl;//\n\t//int tmp=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long int calc(string ex){\n\tlong long int str,cnt,ans=0,now=0,add=1,n=ex.length(),i;\n\tbool sus=false,minus=false;\n\tchar pm='+',md='*';\n\tfor(i=0; i<n; i++){\n\t\tif(sus){\n\t\t\tif(ex[i]=='('){\n\t\t\t\tcnt++;\n\t\t\t}else if(ex[i]==')'){\n\t\t\t\tcnt--;\n\t\t\t\tnow = calc(ex.substr(str,i-str));\n\t\t\t\tsus = false;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(ex[i]){\n\t\t\t\tcase '(':\n\t\t\t\t\tstr = i+1;\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tsus = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif(i==0 || ex[i-1]== '+' || ex[i-1]== '-' || ex[i-1]== '*' || ex[i-1]== '/'){\n\t\t\t\t\t\tminus = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase '+':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\tadd *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tadd /= now;\n\t\t\t\t\t}\n\t\t\t\t\tif(pm == '+'){\n\t\t\t\t\t\tans += add;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans -= add;\n\t\t\t\t\t}\n\t\t\t\t\tpm = ex[i];\n\t\t\t\t\tmd = '*';\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tadd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\tif(minus){\n\t\t\t\t\t\tnow *= -1;\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(md == '*'){\n\t\t\t\t\t\tadd *= now;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tadd /= now;\n\t\t\t\t\t}\n\t\t\t\t\tmd = ex[i];\n\t\t\t\t\tnow = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tnow *= 10;\n\t\t\t\t\tnow += ex[i]-'0';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(minus){\n\t\tnow *= -1;\n\t\tminus = false;\n\t}\n\tif(md == '*'){\n\t\tadd *= now;\n\t}else{\n\t\tadd /= now;\n\t}\n\tif(pm == '+'){\n\t\tans += add;\n\t}else{\n\t\tans -= add;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n,i;\n\tlong long int ans;\n\tstring str;\n\tcin >> n;\n\tfor(i=0; i<n; i++){\n\t\tcin >> str;\n\t\tans = calc(str);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\nusing namespace std;\n\nclass CAL{\nprivate:\n  string m_str;\n  size_t m_cur;\n  int digit();\n  int number();\n  int term();\n  int expression();\n  int factor();\n  int calterm();\npublic:\n  CAL(string str);\n  int cal();\n};\n\nCAL::CAL(string str)\n{\n  m_str = str;\n  m_cur = 0;\n  m_str.resize(m_str.size() - 1);\n}\n\nint CAL::digit()\n{\n  assert(isdigit(m_str[m_cur]));\n  int n = m_str[m_cur++] - '0';\n  return n;\n}\n\nint CAL::number()\n{\n  int n = digit();\n  while(m_cur < m_str.size() && isdigit(m_str[m_cur]))\n    n = n*10 + digit();\n  return n;\n}\n\nint CAL::term()\n{\n  int a = number();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = number();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\nint CAL::expression()\n{\n  int a = term();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = term();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\nint CAL::factor()\n{\n  if(m_str[m_cur] != '(') return number();\n  m_cur += 1;\n  int n = expression();\n  assert(m_str[m_cur] == ')');\n  m_cur += 1;\n  return n;\n}\n\nint CAL::calterm()\n{\n  int a = factor();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '*' || m_str[m_cur] == '/')){\n    char op = m_str[m_cur++];\n    int b = factor();\n    if(op == '*') a *= b; else if(op == '/') a /= b;\n  }\n  return a;\n}\n\nint CAL::cal()\n{\n  int a = calterm();\n  while(m_cur < m_str.size() && (m_str[m_cur] == '+' || m_str[m_cur] == '-')){\n    char op = m_str[m_cur++];\n    int b = calterm();\n    if(op == '+') a += b; else if(op == '-') a -= b;\n  }\n  return a;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  queue<int> answer;\n  string str;\n  for(int i = 0; i < N; ++i){\n    cin >> str;\n    CAL a(str);\n    answer.push(a.cal());\n  }\n  while(!answer.empty()){\n    cout << answer.front() << endl;\n    answer.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint lp=0;\nint solve(string str){\n    vector<int>op;\n    vector<char>ope;\n    //cout<<str.length()<<endl;\n    //cout<<\"str: \"<<str<<endl;\n    int i=0;\n    if(str[0]=='-'){\n        i++;\n        int g=0;\n        while(str[i]>='0'&&str[i]<='9'){\n            g=g*10+str[i]-'0';\n            i++;\n        }\n        op.push_back(g*(-1));\n        if(ope.size())\n            if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                int a=op[op.size()-1];\n                op.pop_back();\n                int b=op[op.size()-1];\n                op.pop_back();\n                if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                else op.push_back(b/a);\n                ope.pop_back();\n            }\n        if(str[i])ope.push_back(str[i]);\n    }\n    for(;i<str.length();i++){\n        //cout<<\"KK\";\n        if(str[i]=='('){\n            string t;\n            i++;\n            lp++;\n            while(lp){\n                t+=str[i];\n                i++;\n                if(str[i]=='(')lp++;\n                if(str[i]==')')lp--;\n            }\n            i++;\n            op.push_back(solve(t));\n            //cout<<\"(): \"<<ope[ope.size()-1]<<endl;\n            if(ope.size())\n            if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                int a=op[op.size()-1];\n                op.pop_back();\n                int b=op[op.size()-1];\n                op.pop_back();\n                if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                else op.push_back(b/a);\n                ope.pop_back();\n            }\n            ope.push_back(str[i]);\n        }\n        else if(str[i]>='0'&&str[i]<='9'){\n            int g=0;\n            while(str[i]>='0'&&str[i]<='9'){\n                g=g*10+str[i]-'0';\n                i++;\n            }\n            op.push_back(g);\n            if(ope.size())\n                if(ope[ope.size()-1]=='*'||ope[ope.size()-1]=='/'){\n                    int a=op[op.size()-1];\n                    op.pop_back();\n                    int b=op[op.size()-1];\n                    op.pop_back();\n                    if(ope[ope.size()-1]=='*')op.push_back(a*b);\n                    else op.push_back(b/a);\n                    ope.pop_back();\n                }\n            if(str[i])ope.push_back(str[i]);\n        }\n    }\n    //cout<<\"!\"<<endl;\n    int las=op[op.size()-1];\n    op.pop_back();\n    while(ope.size()){\n      //  cout<<\"las: \"<<las<<endl;\n        char c=ope[ope.size()-1];\n        ope.pop_back();\n        if(c=='=')continue;\n        int pre=op[op.size()-1];\n      //  cout<<\"pre: \"<<pre<<endl;\n      //  cout<<ope.size()<<\"   c: \"<<c<<endl;\n        op.pop_back();\n        if(c=='+')las=las+pre;\n        else las=pre-las;\n    }\n    //cout<<\"returned : \"<<las<<endl;\n    return las;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        string str;\n        cin>>str;\n        cout<<solve(str)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£?????????????´??????????\n?????????pdf????????????????????????????°????????????????????????????\n??????????????¨???????????????????????????????????????????????????\n#endif\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\nstring S=\"\";\nint cur=0;\nchar readchar()\n{\n  assert(cur<S.size());\n  return S[cur++];\n}\n\nchar peek()\n{\n  assert(cur<S.size());\n  return S[cur];\n}\n\nint digit()\n{\n  assert(isdigit(peek()));\n  int n=readchar()-'0';\n  return n;\n}\n\nint number()\n{\n  int n=digit();\n  while(cur<S.size()&&isdigit(peek()))\n  {\n    n=n*10+digit();\n  }\n  return n;\n}\n\nint expression();\n\nint factor()\n{\n  if(peek()!='(') return number();\n  cur+=1;\n  int n=expression();\n  assert(peek()==')');\n  cur+=1;\n  return n;\n}\n\nint term()\n{\n  int a=factor();\n  while(cur<S.size()&&(peek()=='*'||peek()=='/'))\n  {\n    char op=readchar();\n    int b=factor();\n    if(op=='*')\n    {\n      a*=b;\n    }\n    else\n    {\n      a/=b;\n    }\n  }\n  return a;\n}\n\nint expression()\n{\n  int sum=term();\n  while(cur<S.size()&&(peek()=='+'||peek()=='-'))\n  {\n    char op=readchar();\n    int b=term();\n    if(op=='+')\n    {\n      sum+=b;\n    }\n    else\n    {\n      sum-=b;\n    }\n  }\n  return sum;\n}\n\n\n\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++)\n  {\n    cur=0;\n    cin>>S;\n    S.resize(S.size()-1);\n    cout<<expression()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nusing LL = long long;\nconst LL LINF = 1e18;\nusing namespace std;\n#define COUT(v) cout<<(v)<<endl\n#define CIN(n)  int(n);cin >> (n)\n#define SCIN(n) string(n);cin >> (n)\n#define YES(n) cout<<((n)? \"YES\" : \"NO\")<<endl\n#define Yes(n) cout<<((n)? \"Yes\" : \"No\")<<endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) <<endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define P pair<int,int>\n#define I vector<int>\n#define S set<int>\n#define pb(v) push_back(v)\n#define V vector\n#define rt return\n#define rmsame(a) sort(ALL(a)),a.erase(unique(ALL(a)), a.end())\n\ntypedef string::const_iterator State;\nclass PalseError {};\nclass Edge{\npublic:\n    int from,to,value;\n    Edge(int a,int b,int c){\n        from = a;\n        to = b;\n        value = c;\n    }\n    Edge(int a,int b){\n        from = a;\n        to = b;\n    }\n};\nint number(State &begin);\nint expression(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\nint term(State &begin){\n    int ret = factor(begin);\n    while(1){\n        if(*begin == '*'){\n            begin++;\n            ret *=  factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= number(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint expression(State &begin){\n    int ret = term(begin);\n    while(1){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n    }else{\n        return number(begin);\n    }\n}\nint main(){\n    string s;\n    CIN(N);\n    REP(a,N){\n        cin >> s;\n        State w = s.begin();\n        COUT(expression(w));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\nstring input;\n\ninline bool is_all_digit(string in)\n{\n\tfor (auto i : in)\n\t{\n\t\tif (!isdigit(i))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<string> split(string in)\n{\n\tvector<string> spl;\n\tint pos = 0;\n\tif (in[pos] == '-') \n\t{\n\t\tpos++;\n\t\twhile (pos < in.size()) {\n\t\t\tif (isdigit(in[pos])) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspl.push_back(in.substr(0, pos));\n\t\tin.erase(0, pos);\n\t\tpos = 0;\n\t}\n\twhile ( pos < in.size())\n\t{\n\t\tif (!isdigit(in[pos]))\n\t\t{\n\t\t\tif (pos != 0)\n\t\t\t{\n\t\t\t\tspl.push_back(in.substr(0, pos));\n\t\t\t\tin.erase(0, pos);\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (in[0] == '(')\n\t\t\t\t{\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tint r_pos = 1;\n\t\t\t\t\tfor (r_pos = 1; r_pos < in.size(); r_pos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (in[r_pos] == '(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif (in[r_pos] == ')')\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tspl.push_back(in.substr(pos + 1, r_pos - 0 - 1));\n\t\t\t\t\tin.erase(0, r_pos + 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (in[0] == '+' || in[0] == '-' || in[0] == '*' || in[0] == '/')\n\t\t\t\t{\n\t\t\t\t\tspl.push_back(in.substr(0, 1));\n\t\t\t\t\tin.erase(0, 1);\n\t\t\t\t\tpos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t}\n\t}\n\tif (in.size() != 0) spl.push_back(in);\n\treturn spl;\n}\nint cal(string &in_str) {\n\tauto in = split(in_str);\n\twhile (in.size() == 1) {\n\t\tif (in[0][0] == '-'&&is_all_digit(in[0].substr(1))) break;\n\t\tif (is_all_digit(in[0])) break;\n\t\tin = split(in[0]);\n\t}\n\twhile (in.size() != 1) {\n\t\tauto pos = in.begin();\n\t\twhile (pos != in.end()) \n\t\t{\n\t\t\tif (*pos == \"*\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)*cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1 , pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"/\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)/cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif (pos != in.end()) pos++;\n\t\t}\n\t\tpos = in.begin();\n\t\twhile (pos != in.end()) {\n\t\t\tif (*pos == \"+\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos)+cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\telse if (*pos == \"-\") {\n\t\t\t\tpos--;\n\t\t\t\t*pos = to_string(cal(*pos) - cal(*(pos + 2)));\n\t\t\t\tin.erase(pos+1, pos + 3);\n\t\t\t}\n\t\t\tif (in.size()==1) break;\n\t\t\tif(pos != in.end()) pos++;\n\t\t}\n\t}\n\ttry {\n\t\treturn(stoi(in[0]));\n\t}\n\tcatch (const std::invalid_argument& a) {\n\t\tcerr << a.what() << input << endl;\n\t}\n}\nint main()\n{\n\t\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> input;\n\t\tinput.erase(input.end() - 1);\n\t\tcout << cal(input) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nvector<char> buf;\nstack<char> tmp;\nchar t;\nvoid add_buf(char x)\n{\n\tbuf.pb(x);\n\treturn;\n}\nvoid add_tmp(char x)\n{\n\ttmp.push(x);\n\treturn;\n}\nvoid move()\n{\n\tchar x=tmp.top();\n\ttmp.pop();\n\tbuf.pb(x);\n\treturn;\n}\nvoid reset()\n{\n\twhile(1)\n\t{\n\t\tchar x=tmp.top();\n\t\tif(x=='(')\n\t\t{\n\t\t\ttmp.pop();\n\t\t\tbreak;\n\t\t}\n\t\tbuf.pb(x);\n\t\ttmp.pop();\n\t}\n\treturn;\n}\nint priority(char x)\n{\n\tif(x=='+'||x=='-')return 0;\n\tif(x=='*'||x=='/')return 1;\n\tif(x==')')return 2;\n\tif(x=='(')return 3;\n\treturn 4;\n}\nvoid end()\n{\n\twhile(!tmp.empty())\n\t{\n\t\tchar x=tmp.top();\n\t\ttmp.pop();\n\t\tbuf.pb(x);\n\t}\n\treturn;\n}\nbool is_num(char x)\n{\n\treturn priority(x)==4;\n}\nint calc()\n{\n\tstack<char> c;\n\tfor(int i=0;i<buf.size();i++)\n\t{\n\t\tif(is_num(buf[i]))\n\t\t{\n\t\t\tc.push(buf[i]-'0');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint a=c.top();\n\t\t\tc.pop();\n\t\t\tint b=c.top();\n\t\t\tc.pop();\n\t\t\tcout << a << ' '<< b << endl;\n\t\t\tswitch(buf[i])\n\t\t\t{\n\t\t\t\tcase '+':c.push(b+a);break;\n\t\t\t\tcase '-':c.push(b-a);break;\n\t\t\t\tcase '*':c.push(a*b);break;\n\t\t\t\tcase '/':c.push(b/a);break;\n\t\t\t}\n\t\t}\n\t}\n\treturn c.top();\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbuf.clear();\n\t\twhile(!tmp.empty())\n\t\t{\n\t\t\ttmp.pop();\n\t\t}\n\t\tchar s[101];\n\t\tscanf(\"%s\",s);\n\t\tfor(int i=0;i<strlen(s)-1;i++)\n\t\t{\n\t\t\tif(is_num(s[i]))\n\t\t\t{\n\t\t\t\tadd_buf(s[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(priority(s[i])==2)\n\t\t\t{\n\t\t\t\treset();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(priority(s[i])==3)\n\t\t\t{\n\t\t\t\tadd_tmp(s[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(!tmp.empty())\n\t\t\t{\n\t\t\t\tif(priority(tmp.top())==1&&priority(s[i])==0)\n\t\t\t\t{\n\t\t\t\t\tmove();\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tadd_tmp(s[i]);\n\t\t}\n\t\tend();\n\t\tfor(int i=0;i<buf.size();i++)\n\t\t{\n\t\t\tcout << buf[i] << ' ';\n\t\t}\n\t\tcout << endl;\n\t\tcout << calc() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint n;\nstring str;\n\nint factor(State &begin);\nint number(State &begin);\nint term(State &begin);\nint expressin(State &begin);\n\nint factor(State &begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State &begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State &begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstack<int> DigitStack;\nstack<char> OpStack;\nstring Formulation;\n\nvoid calculation() {\n\tint num2, result;\n\tchar ch;\n\n\tch = OpStack.top();\n\tOpStack.pop();\n\tswitch (ch)\n\t{\n\tcase '+': \n\t\tnum2 = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult += num2; \n\t\tbreak;\n\tcase '-': \n\t\tnum2 = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult = DigitStack.top();\n\t\tDigitStack.pop(); \n\t\tresult -= num2; \n\t\tbreak;\n\tcase '*':\n\t\tnum2 = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult *= num2; \n\t\tbreak;\n\tcase '/': \n\t\tnum2 = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tresult /= num2; break;\n\tdefault:return;\n\t}\n\tDigitStack.push(result);\n}\n\nint calculateNumber(int *pIndex) {\n\tint sum;\n\tstring tmp;\n\tstringstream ss;\n\n\ttmp += Formulation[(*pIndex)++];\n\twhile (isdigit(Formulation[*pIndex])) {\n\t\ttmp += Formulation[*pIndex];\n\t\t(*pIndex)++;\n\t}\n\t//cout << tmp << endl;\n\tss << tmp;\n\tss >> sum;\n\tss.clear();\n\t(*pIndex)--;\n\n\treturn sum;\n}\n\nint priorityOfOperator(char ch)\n{\n\tswitch (ch)\n\t{\n\tcase '(':\n\t\treturn 3;\n\tcase '*':\n\tcase '/':\n\t\treturn 2;\n\tcase '+':\n\tcase '-':\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid solve() {\n\tint i, num, len;\n\tchar cTmp;\n\n\tlen = Formulation.size() - 1;\n\tfor (i = 0; i < len; i++) {\n\t\tcTmp = Formulation[i];\n\t\t\n\t\tif (isdigit(cTmp)) {\n\t\t\tnum = calculateNumber(&i);\n\t\t\tDigitStack.push(num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( cTmp == '(' || OpStack.empty() || OpStack.top() == '(' ) {\n\t\t\tOpStack.push(cTmp);\n\t\t\tcontinue;\n\t\t}\n\n\t    if (priorityOfOperator(cTmp) > priorityOfOperator(OpStack.top())) {\n\t\t\tOpStack.push(cTmp);\n\t\t}\t\t\n\t\telse {\n\t\t\tdo {\n\t\t\t\tcalculation();\n\t\t\t} while ( !OpStack.empty() && OpStack.top() != '(' && priorityOfOperator(cTmp) <= priorityOfOperator(OpStack.top()));\n\n\t\t\tif (cTmp == ')') {\n\t\t\t\tOpStack.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tOpStack.push(cTmp);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!OpStack.empty()) {\n\t\tcalculation();\n\t}\n\n}\n\nint main() {\n\tint n, result;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> Formulation;\n\t\t//cout << Formulation << endl;\n\t\tsolve();\n\t\tresult = DigitStack.top();\n\t\tDigitStack.pop();\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\nstring its(int n){\n  stringstream s;\n  s<<n;\n  return s.str();\n}\nstack<string> mep(stack<string> me,string s){\n  int a,b;\n  b=atoi(me.top().c_str());\n  me.pop();\n  a=atoi(me.top().c_str());\n  me.pop();\n  if(s==\"+\")\n    me.push(its(a+b));\n  else if(s==\"-\")\n    me.push(its(a-b));\n  else if(s==\"*\")\n    me.push(its(a*b));\n  else if(s==\"/\")\n    me.push(its(a/b));\n  return me;\n}\nint main(){\n  int h,i,j;\n  int n,len;\n  string s;\n  stack<string> me,st;\n  cin>>n;\n  for(h=0;h<n;h++){\n    cin>>s;\n    len=s.length()-1;\n    for(i=0;i<len;i++){\n      if('1'<=s[i]&&s[i]<='9'){\n\tfor(j=i;j<len;j++)\n\t  if(s[j]<'0'||'9'<s[j])\n\t    break;\t\n\tme.push(s.substr(i,j-i));\n\ti=j-1;\n      }else if(s[i]=='('){\n\tst.push(s.substr(i,1));\n      }else if(s[i]==')'){\n\twhile(st.top()!=\"(\"){\n\t  me=mep(me,st.top());\n\t  st.pop();\n\t}\n\tst.pop();\n      }else if(s[i]=='+'||s[i]=='-'){\n\tif(st.empty());\n\telse if(st.top()==\"(\");\n\telse{\n\t  while(st.empty()==0){\n\t    if(st.top()==\"(\")\n\t      break;\n\t    else{\n\t      me=mep(me,st.top());\n\t      st.pop();\n\t    }\n\t  }\n\t}\n\tst.push(s.substr(i,1));\n      }else if(s[i]=='*'||s[i]=='/'){\n\tif(st.empty());\n\telse if(st.top()==\"(\");\n\telse if(st.top()==\"+\"||st.top()==\"-\");\n\telse{\n\t  while(st.empty()==0){\n\t    if(st.top()==\"(\")\n\t      break;\n\t    else if(st.top()==\"+\"||st.top()==\"-\")\n\t      break;\n\t    else{\n\t      me=mep(me,st.top());\n\t      st.pop();\n\t    }\n\t  }\n\t}\n\tst.push(s.substr(i,1));\n      }\n    }\n    while(st.empty()==0){\n      me=mep(me,st.top());\n      st.pop();\n    }\n    cout<<me.top()<<endl;\n    me.pop();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nvoid calc(string st, stack<ll> &s) {\t\n\tif(st == \"*\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(a * b);\n\t} else if(st == \"+\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(a + b);\n\t} else if(st == \"-\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(b - a);\n\t} else if(st == \"/\") {\n\t\tint a = s.top();\n\t\ts.pop();\n\t\tint b = s.top();\n\t\ts.pop();\n\t\ts.push(b / a);\n\t} else {\n\t\ts.push(atoi(st.c_str()));\n\t}\n}\nint getPriority(string s) {\n\t// ?????????\n\tif(s == \"(\") {\n\t\treturn 5;\n\t} else if(s == \"*\" || s == \"/\") {\n\t\treturn 3;\n\t} else if(s == \"+\" || s == \"-\") {\n\t\treturn 2;\n\t} else if(s == \")\") { \n\t\treturn 1;\n\t} else return 4;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(--str.end());\n\t\t\n\t\tvector<string> v;\n\t\t\n\t\tint f = 0;\n\t\trep(i, str.size()) {\t\t\t\n\t\t\tif(isdigit(str[i])) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif(f) {\n\t\t\t\t\tstring st;\n\t\t\t\t\trep(j,f) {\n\t\t\t\t\t\tst += str[i - f + j];\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(st);\n\t\t\t\t\tstring st2;\n\t\t\t\t\tst2 += str[i];\n\t\t\t\t\tv.push_back(st2);\n\t\t\t\t\tf = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstring st3;\n\t\t\t\t\tst3 += str[i];\n\t\t\t\t\tv.push_back(st3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<string> s;\n\t\tvector<string> nv;\n\t\tstack<ll> ret;\n\t\tint p = 0;\n\t\trep(i,v.size()) {\n\t\t\tp = getPriority(v[i]);\n\t\t\twhile(!s.empty() && getPriority(s.top()) > p && s.top() != \"(\") {\n\t\t\t\tnv.push_back(s.top());\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(v[i] == \")\") {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(v[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()) {\n\t\t\tnv.push_back(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\trep(i,nv.size()) {\n\t\t\tcalc(nv[i], ret);\n\t\t\trep(j,ret.size())\n\t\t\t\tcout << ret.top() << endl;\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << ret.top() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n\nusing namespace std;\n\nstring s;\nint id;\n\nint exp();\nint term();\nint fact();\n\nint exp()\n{\n\tint r = term();\n\twhile(true)\n\t{\n\t\tchar c = s[id++];\n\t\tif(c == '+')r += term();\n\t\telse if(c == '-')r -= term();\n\t\telse break;\n\t}\n\treturn r;\n}\n\nint term()\n{\n\tint r = fact();\n\twhile(true)\n\t{\n\t\tchar c = s[id++];\n\t\tif(c=='*') r*=fact();\n\t\telse if(c=='/')r/=fact();\n\t\telse break;\n\t}\n\tid--;\n\treturn r;\n}\n\nint fact()\n{\n\tchar c = s[id++];\n\tif(c=='(')return exp();\n\tif(c=='-')\n\t{\n\t\treturn -fact();\n\t}\n\tif(c=='+')\n\t{\n\t\treturn fact();\n\t}\n\tint x = c-'0';\n\twhile(true)\n\t{\n\t\tc = s[id++];\n\t\tif('0' <= c && c <= '9')\n\t\t{\n\t\t\tx *= 10;\n\t\t\tx += c-'0';\n\t\t}\n\t\telse break;\n\t}\n\tid--;\n\treturn x;\n}\n\nvoid solve()\n{\n\tint N;\n\tscanf(\"%d\\n\", &N);\n\twhile(N--)\n\t{\n\t\tgetline(cin, s);\n\t\tid = 0;\n\t\tcout << exp() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint r;\nint i;\nint sd(char *s, int m){\n    int n = 0, d = 0;\n    for(;s[i] != '\\0';){\n        switch(s[i]){\n        case '=':\n            return n;\n        case '+':\n            if(m == 1)\n                return n;\n            i++;\n            return n + sd(s, 2);\n        case '-':\n            if(m == 1)\n                return n;\n            i++;\n            return n - sd(s, 2);\n        case '*':\n            i++;\n            return n * sd(s, 1);\n        case '/':\n            i++;\n            return n / sd(s, 1);\n        case '(':\n            i++;\n            return sd(s, 0);\n        case ')':\n            i++;\n            return n;\n        default:\n            n = n * 10 + s[i] - '0';\n            i++;\n            break;\n        }\n    }\n}\n\nint main(void)\n{\n    int N;\n\n    char str[1024];\n\n    cin >> N;\n\n    for(int k = 0; k < N; k++){\n        r = 0;\n        i = 0;\n        cin >> str;\n        printf(\"%d\", sd(str, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    // ??°?????????????????????\n    int number(State &begin) {\n        int ret = 0;\n        while(isdigit(*begin)) {\n            ret *= 10;\n            ret += (*begin - '0');\n            begin++;\n        }\n        return ret;\n    }\n\n    // ??¬??§?????°????????????\n    int factor(State &begin) {\n        if(*begin == '(') {\n            begin++; // '(' ????£???°???\n            int ret = expression(begin);\n            begin++; // ')' ????£???°???\n            return ret;\n        }\n        else return number(begin);\n    }\n\n    // ??????????????????????????????\n    int term(State &begin) {\n        // ????????????????????¨????????£????????°??????????????§???????????????\n        // begin ?????????????????°?????§???????????????\n        int ret = factor(begin);\n\n        while(1) {\n            if(*begin == '*') {\n                begin++;\n                ret *= factor(begin);\n            }\n            else if(*begin == '/') {\n                begin++;\n                ret /= factor(begin);\n            }\n            else break;\n        }\n\n        return ret;\n    }\n\n    // ??????????????????????????????\n    int expression(State &begin) {\n        int ret = term(begin);\n        while(1) {\n            if(*begin == '+') {\n                begin++;\n                ret += term(begin);\n            }\n            else if(*begin == '-') {\n                begin++;\n                ret -= term(begin);\n            }\n            else break;\n        }\n        return ret;\n    }\n};\n\nsigned main() {\n    int N; cin >> N;\n    rep(i,0,N) {\n        Parser ps;\n        string s; cin >> s;\n        State begin = s.begin();\n        int ans = ps.expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\nusing namespace std;\ntypedef pair<const char *, int > parsed;\n\nparsed expr(const char *);\nparsed term(const char *);\nparsed fact(const char *);\n\nparsed expr(const char *p){\n\tparsed r = term(p);\n\twhile( *(r.first)=='+' || *(r.first)=='-' ){\n\t\tconst char *op = r.first;\n\t\tparsed l = term(op+1);\n\n\t\tif( *op=='+' ){\n\t\t\tr.first = l.first;\n\t\t\tr.second = r.second + l.second;\n\t\t}else{\n\t\t\tr.first = l.first;\n\t\t\tr.second = r.second - l.second;\n\t\t}\n\t}\n\treturn r;\n}\nparsed term(const char *p){\n\tparsed r = fact(p);\n\twhile( *(r.first)=='*' || *(r.first)=='/' ){\n\t\tconst char *op = r.first;\n\t\tparsed l = fact(op+1);\n\n\t\tif( *op=='*' ){\n\t\t\tr.first = l.first;\n\t\t\tr.second = r.second * l.second;\n\t\t}else{\n\t\t\tr.first = l.first;\n\t\t\tr.second = (int)floor(r.second / (double)l.second);\n\t\t}\n\t}\n\treturn r;\n}\nparsed fact(const char *p){\n\tif( *p=='(' ){\n\t\t// new expression\n\t\tparsed tp = expr(p+1);\n\t\treturn parsed(tp.first+1, tp.second);\n\t}\n\tif( *p=='-' ){\n\t\t// negative fact\n\t\tparsed tp = fact(p+1);\n\t\ttp.second *= -1;\n\t\treturn tp;\n\t}\n\tif( isdigit(*p) ){\n\t\t// number\n\t\tint num = *p - '0';\n\t\twhile( isdigit(*(++p)) ){\n\t\t\tnum *= 10;\n\t\t\tnum += *p - '0';\n\t\t}\n\t\treturn parsed(p,num);\n\t}else assert(0); return parsed(NULL,0);\n}\nint main(void){\n\tint n;\n\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tcout << expr(s.c_str()).second << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://gist.github.com/draftcode/1357281 を参考にした\n// キーボード入力とファイルからの入力で結果が異なっているのは，改行コードのせい\n#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\ntypedef string::const_iterator State;\n\nclass ParseError{};\n\nvoid consume(State &begin, char expected);\nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n\t\t\t<< endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\tthrow ParseError();\n\t}\n}\n\n// 四則演算の式をパースして，その評価結果を返す．\nint expression(State &begin) {\n\tint ret = term(begin);\n\t\n\twhile (true) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n// 乗算除算の式をパースして，その評価結果を返す．\nint term(State &begin) {\n\t//int ret = number(begin);\n\tint ret = factor(begin); // 括弧がある式に対応\n\t\n\twhile (true) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\t//ret *= number(begin);\n\t\t\tret *= factor(begin); // 括弧がある式に対応\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\t//ret /= number(begin);\n\t\t\tret /= factor(begin); // 括弧がある式に対応\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n// 括弧か数をパースして，その評価結果を返す．\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす．\n\t\tint ret = expression(begin);\n\t\tbegin++; // ')'を飛ばす．\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\n// 数字の列をパースして，その数を返す．\nint number(State &begin) {\n\tint ret = 0;\n\t\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\t\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tconsume(begin, '=');\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint number(State &begin){\n  int num=0;\n  while(isdigit(*begin)){\n    num*=10;\n    num+=(*begin-'0');\n    begin++;\n  }\n  return num;\n}\n\nint program(State &begin){\n  int num;\n  if(*begin=='('){\n    begin++;\n    num=expression(begin);\n    begin++;\n  }\n  else num=number(begin);\n  return num;\n}\n\nint term(State &begin){\n  int num=program(begin);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      num*=program(begin);\n    }else if(*begin=='/'){\n      begin++;\n      num/=program(begin);\n    }else break;\n  }\n  return num;\n}\n\nint expression(State &begin){\n  int num=term(begin);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      num+=term(begin);\n    }else if(*begin=='-'){\n      begin++;\n      num-=term(begin);\n    }\n    else break;\n      \n  }\n  return num;\n}\n\n\n\n\nsigned main(){\n  cin.tie(0);\t\n  //ios::sync_with_stdio(false);\n  int n;\n  cin>>n;\n  rep(i,n){\n    string s;\n    cin>>s;\n    State begin=s.begin();\n    cout<<expression(begin)<<endl;\n  }\n\n  return 0;\n}\n\n\n\n    \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass calc{\n  string s;\n  string::iterator it;\n\npublic:\n  calc(const string&str){\n    s = str;\n    it = s.begin();\n  }\n\n  int fact(){\n    if(*it == '('){\n      ++it;\n      int ret = exp();\n      ++it;\n      return ret;\n    }\n    else{\n      int ret = 0;\n      while('0' <= *it && *it <= '9'){\n\tret *= 10;\n\tret += *it - '0';\n\t++it;\n      }\n      return ret;\n    }\n  }\n\n  int term(){\n    int ret = fact();\n    while(*it == '*' || *it == '/'){\n      if(*it == '*'){\n\t++it;\n\tret *= fact();\n      }\n      else if(*it == '/'){\n\t++it;\n\tret /= fact();\n      }\n    }\n    return ret;\n  }\n  \n  int exp(){\n    int ret = term();\n\n    while(*it == '+' || *it == '-'){\n      if(*it == '+'){\n\t++it;\n\tret += term();\n      }\n      else if(*it == '-'){\n\t++it;\n\tret -= term();\n      }\n    }\n    return ret;\n  }\n};\n\nint main(){\n  string str;\n  int n;\n\n  cin >> n;\n  while(n--){\n    cin >> str;\n    calc ans(str);\n    cout << ans.exp() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<25)\n#define P(a,b) make_pair(a,b)\n\nint id = 0;\nstring s;\n\nint exp();\nint term();\nint fact();\n\nint exp(){\n\tint ans = term();\n\twhile(true){\n\t\tchar c = s[id++];\n\t\tif(c == '+'){\n\t\t\tans += term();\n\t\t}else if(c=='-'){\n\t\t\tans -= term();\n\t\t}else{\n\t\t\treturn ans;\n\t\t}\n\t}\n}\nint term(){\n\tint ans = fact();\n\twhile(true){\n\t\tchar c = s[id++];\n\t\tif(c == '*'){\n\t\t\tans *= fact();\n\t\t}else if(c=='/'){\n\t\t\tans /= fact();\n\t\t}else{\n\t\t\tid--;\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\n}\nint fact(){\n\tchar c = s[id++];\n\tif(c=='(') return exp();\n\tif(c=='-') return -exp();\n\tif(c=='+') return  exp();\n\tint x = c - '0';\n\twhile(true){\n\t\tc = s[id++];\n\t\tif('0' <= c && c <= '9'){\n\t\t\tx = x*10 + c - '0';\n\t\t}else{\n\t\t\tid--;\n\t\t\treturn x;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\tid = 0;\n\t\tcout << exp() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nclass Parser{\n    public:\n\n    string s;\n    int i, n;\n\n    Parser(string s): s(s) {}\n\n    int parse(){\n        i = 0;\n        n = s.length();\n        return expr();\n    }\n\n    private:\n\n    int expr(){\n        int ret = term();\n        while(s[i] != '='){\n            if(s[i] == '+'){\n                i++;\n                ret += term();\n            }else if(s[i] == '-'){\n                i++;\n                ret -= term();\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int term(){\n        int ret = fac();\n        while(i < n){\n            if(s[i] == '*'){\n                i++;\n                ret *= fac();\n            }else if(s[i] == '/'){\n                i++;\n                ret /= fac();\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n\n    int fac(){\n        if(isdigit(s[i])) return num();\n        i++;\n        int ret = num();\n        while(s[i] != ')'){\n            if(s[i] == '+'){\n                i++;\n                ret += num();\n            }else if(s[i] =='-'){\n                i++;\n                ret -= num();\n            }else{\n                break;\n            }\n        }\n        i++;\n        return ret;\n    }\n\n    int num(){\n        int ret = s[i] - '0';\n        i++;\n        while(isdigit(s[i])){\n            ret = ret * 10 + (s[i] - '0');\n            i++;\n        }\n        return ret;\n    }\n\n};\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        string s;\n        cin >> s;\n        Parser p = Parser(s);\n        cout << p.parse() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nclass Parser{\npublic:\n    int expression(State &begin){\n        int ret = term(begin);\n        for(;;){\n            if(*begin == '+'){\n                begin++;\n                ret += term(begin);\n            }else if(*begin == '-'){\n                begin++;\n                ret -= term(begin);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int term(State &begin){\n        int ret = factor(begin);\n        for(;;){\n            if(*begin == '*'){\n                begin++;\n                ret *= factor(begin);\n            }else if(*begin == '/'){\n                begin++;\n                ret /= factor(begin);\n            }else{\n                break;\n            }\n        }\n        return ret;\n    }\n    int factor(State &begin){\n        int ret;\n        if(*begin == '('){\n            begin++;//'('?????????\n            ret = expression(begin);\n            begin++;//')'?????????\n        }else{\n            ret = number(begin);\n        }\n        return ret;\n    }\n    int number(State &begin){\n        int ret = 0;\n        while(isdigit(*begin)){\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return ret;\n    }\n};\n\nint main(void){\n    int n; cin >> n;\n    rep(i, n){\n        Parser ps;\n        string s; cin >> s;\n        string tmp = s.substr(0, s.size() - 1);\n        cout << tmp << endl;\n        State begin = s.begin();\n        int ret = ps.expression(begin);\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint roc = 0;\nstring s;\nint insu();\nint kou();\nint shiki();\n\nint insu() {\n\tif(s[roc] >= '0' && s[roc] <= '9') {\n\t\tint j = roc;\n\t\twhile(roc < s.size() && s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\treturn stoi(s.substr(j, roc - j));\n\t} else {\n\t\t++roc;\n\t\tint res = shiki();\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint kou() {\n\tint res = insu();\n\twhile (s[roc] == '*' || s[roc] == '/') {\n\t\tif(s[roc] == '*') res *= insu();\n\t\telse res /= insu();\n\t}\n\treturn res;\n}\n\nint shiki() {\n\tint res = kou();\n\twhile (s[roc] == '+' || s[roc] == '-') {\n\t\tif(s[roc] == '+') res += insu();\n\t\telse res -= insu();\n\t}\n\treturn res;\n}\n\nint main(void) {\n\tint n;\n\tcin>>n;\n\tREP(roop, n) {\n\t\troc = 0;\n\t\tcin>>s;\n\t\ts.pop_back();\n\t\tcout<<shiki()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nstring s;\nint p;\n\nint expression();\nint term();\nint factor();\nint number();\n\nint expression() {\n\tint value = term();\n\twhile(true) {\n\t\tif(s[p] == '+') {\n\t\t\tp++;\n\t\t\tvalue += term();\n\t\t} else if(s[p] == '-') {\n\t\t\tp++;\n\t\t\tvalue -= term();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn value;\n}\n\nint term() {\n\tint value = factor();\n\twhile(true) {\n\t\tif(s[p] == '*') {\n\t\t\tp++;\n\t\t\tvalue *= factor();\n\t\t} else if(s[p] == '/') {\n\t\t\tp++;\n\t\t\tvalue /= factor();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn value;\n}\n\nint factor() {\n\tint value = 0;\n\tif(s[p] == '(') {\n\t\tp++;\n\t\tvalue = expression();\n\t\tp++;\n\t} else {\n\t\tvalue = number();\n\t}\n\treturn value;\n}\n\nint number() {\n\tint value = 0;\n\twhile(isdigit(s[p])) {\n\t\tvalue = value*10 + (s[p] - '0');\n\t\tp++;\n\t}\n\treturn value;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tp = 0;\n\t\tcin >> s;\n\t\tcout << expression() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <string>\n\nclass Parser {\npublic:\n  std::string str;\n  int idx;\n  Parser (std::string str):str(str),idx(0)\n  {\n  }\n  int evalas();\n  int evalmd();\n  int evalexpr();\n  int evalnum();\n};\n\nint Parser::evalas() {\n  //  printf(\"evalas begin: idx=%d\\n\",idx);\n\n  int left = evalmd(), right;\n  while(true) {\n    switch(str[idx]) {\n    case '+':\n      idx++;\n      right = evalmd();\n      left = left+right;\n      break;\n    case '-':\n      idx++;\n      right = evalmd();\n      left = left-right;\n      break;\n    default:\n      goto hoge;\n    }\n  }\n hoge:\n\n  //  printf(\"evalas end: idx=%d\\n\",idx);\n  return left;\n}\n\nint Parser::evalmd() {\n//  printf(\"evalmd begin: idx=%d\\n\",idx);  \n\n  int left = evalexpr(),right;\n  while(true) {\n    switch(str[idx]) {\n    case '*':\n      idx++;\n      right = evalexpr();\n      left = left*right;\n      break;\n    case '/':\n      idx++;\n      right = evalexpr();\n      left = left/right;\n      break;\n    default:\n      goto hoge;\n    }\n  }\n hoge:\n  //  printf(\"evalmd end: idx=%d\\n\",idx);  \n  return left;\n}\n\nint Parser::evalexpr() {\n  //  printf(\"evalexpr: idx=%d\\n\",idx);\n\n  int n;\n  if (str[idx] == '(') {\n    idx++;\n    n = evalas();\n    idx++;\n  } else {\n    n = evalnum();\n  }\n//  printf(\"returned: %d\\n\",n);\n  return n;\n}\n\nint Parser::evalnum() {\n  //  printf(\"evalnum begin: idx=%d\\n\",idx);\n\n  int ans=0;\n  char ch;\n  while (isdigit(ch=str[idx])) {\n    idx++;\n    ans = ans*10+(int)ch-(int)'0';\n  }\n\n  //  printf(\"evalnum　end: idx=%d\\n\",idx);\n  return ans;\n}\n\nint main() {\n  int time;\n  scanf(\"%d\\n\",&time);\n\n  while(time--) {\n    char str[100];\n    fgets(str,100,stdin);\n    //    printf(\"expr: %s\\n\",str);\n    printf(\"%d\\n\",Parser(std::string(str)).evalas());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//AOJ vol1 109\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n//2017/07/10\n//640009E\n//Yang Bo\n//\n\n#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\n//string?????°??????int???\"??°???\"???????????????\nint digit()\n{\n  int n = S[cur] - '0';\n  cur++; //cur?????????????????????????????????(?¬??????°??????)\n  //cout << \"cur_digit = \" << cur << endl;\n  return n;\n}\n\n//?????????????????????????????????????????????????????????\nint number()\n{\n  int n = digit();\n  while (cur < S.size() && isdigit(S[cur])) //?????¨?????¨???????????°\n    n = n * 10 + digit();\n  //cout << \"cur_number = \" << cur << endl;\n  return n;\n}\n\nint expression(); //??£?¨?\n\n//??¬??§????????§?????????\nint brackets()\n{\n  //??¬??§???????????´???\n  if (S[cur] != '(')\n    return number();\n  //??¬??§???????????´???\n  cur++;\n  int n = expression();\n  cur++; //')'??????????????????????????????\n  //cout << \"cur_brackets = \" << cur << endl;\n  //cout << \"n = \" << n << endl;\n  return n;\n}\n\n//????????????????????????\nint term()\n{\n  int a = brackets(); //????????????????????°\n  while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n    char op = S[cur++];\n    int b = brackets(); //???????????????????????°(?¶????????????°?????????)\n    if (op == '*')\n      a *= b;\n    else if (op == '/')\n      a /= b;\n  }\n  //cout << \"cur_term = \" << cur << endl;\n  //cout << \"a_term = \" << a << endl;\n  return a;\n}\n\n//????????????????????????\nint expression()\n{\n  int a = term(); //????????????????????°\n  while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n    char op = S[cur++]; //cur?????????????????????????????????(?????????????????????)\n    int b = term(); //???????????????????????°(?¶????????????°?????????)\n    if (op == '+')\n      a += b;\n    else if (op == '-')\n      a -= b;\n  }\n  //cout << \"cur_expression = \" << cur << endl;\n  //cout << \"a_expression = \" << a << endl;\n  return a;\n}\n\nint main()\n{\n  int n; cin >> n;\n  while (n-- > 0) {\n    cur = 0;\n    cin >> S;\n    int a = expression();\n    cout << a << endl;\n  }\n}\n\n/*\n  ?????£??¨?????????????????´??\\??\\??????????????????????????????????????¨????????????????????§????????????????????????????????£????????§?????????\n  ?????????????????????????§????????????§????????±????????????????????????????§£???????????????\n  11.A??????????????????????????§????????????????§£?????????????????????????????£???????????£??????????????????????????????\n  ???????????????????????????????????°???2??\\????????????cur?????°?????????????????°?????¨?°???\\???????????????cur???0??????????????????????????°?????????????????¨????°???\\?????????????????????????????£??????\n  ????????¨?????\\????????????????????£???Encryption System?????¢??????????????£????????§????????????????????¨???????§£??????????????????\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstring s;\nint INDEX;\nint number();\nint factor();\nint term();\nint expr();\nint number(){\n    int n = s[INDEX] - '0';\n    INDEX++;\n    while(isdigit(s[INDEX])){\n        n = n*10 + s[INDEX] - '0';\n        INDEX++;\n    }\n    return n;\n}\nint factor(){\n    if(isdigit(s[INDEX])) return number();\n    INDEX++;\n    int ret = expr();\n    INDEX++;\n    return ret;\n}\nint term(){\n    int val = factor();\n    while(s[INDEX] == '*' || s[INDEX] == '/'){\n        char op = s[INDEX];\n        INDEX++;\n        int tmp = factor();\n        if(op == '*') val *= tmp;\n        else val /= tmp;\n    }\n    return val;\n}\nint expr(){\n    int val = term();\n    while(s[INDEX] == '+' || s[INDEX] == '-'){\n        char op = s[INDEX];\n        INDEX++;\n        int tmp = term();\n        if(op == '+')val += tmp;\n        else val -= tmp;\n    }\n    return val;\n}\nint main(){\n    int N;\n    cin >> N;\n    while(N--){\n        INDEX = 0;\n        cin >> s;\n        cout << expr() << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<int,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second!='=' && *now.second!=')'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second!='=' && *now.second!=')' && *now.second!='+' && *now.second!='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\tif(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse{\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\twhile(isdigit(*p))\n\t\t\tp++;\n\t\treturn parsed(atoi(s),p);\n\t}\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\ntypedef string::const_iterator iter;\n\nint expr(iter &p);\nint term(iter& p);\nint factor(iter& p);\nint number(iter& p);\n\nint expr(iter& p) {\n    int r = term(p);\n    while(true) {\n        if(*p == '+') {\n            ++p;\n            int rs = term(p);\n            r += rs;\n        }\n        else if(*p == '-') {\n            ++p;\n            int rs = term(p);\n            r -= rs;\n        }\n        else {\n            break;\n        }\n    }\n    return r;\n}\n\nint term(iter& p) {\n    int r = factor(p);\n    while(true) {\n        if(*p == '*') {\n            p++;\n            int rs = factor(p);\n            r *= rs;\n        }\n        else if(*p == '/') {\n            p++;\n            int rs = factor(p);\n            r /= rs;\n        }\n        else {\n            break;\n        }\n    }\n    return r;\n}\n\nint factor(iter& p) {\n    if(*p == '(') {\n        ++p; // skip (\n        int r = expr(p);\n        ++p; // skip )\n        return r;\n    }\n    \n    return number(p);\n}\n\nint number(iter& p) {\n    int r = 0;\n    while(isdigit(*p)) {\n        r *= 10;\n        r += *p -'0';\n        p++;\n    }\n    return r;\n}\n\nint main() {\n    int n; cin >> n;\n    while(n--) {\n        string s; cin >> s;\n        iter it = s.begin();\n        int res = expr(it);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 0109 wa solution?????§\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <cctype>\nusing namespace std;\ntypedef long long ll;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nvoid calc(string st, stack<ll> &s) {\t\n\tif(st == \"*\") {\n\t\tll a = s.top();\n\t\ts.pop();\n\t\tll b = s.top();\n\t\ts.pop();\n\t\ts.push(a * b);\n\t} else if(st == \"+\") {\n\t\tll a = s.top();\n\t\ts.pop();\n\t\tll b = s.top();\n\t\ts.pop();\n\t\ts.push(a + b);\n\t} else if(st == \"-\") {\n\t\tll a = s.top();\n\t\ts.pop();\n\t\tll b = s.top();\n\t\ts.pop();\n\t\ts.push(b - a);\n\t} else if(st == \"/\") {\n\t\tll a = s.top();\n\t\ts.pop();\n\t\tll b = s.top();\n\t\ts.pop();\n\t\ts.push(b / a);\n\t} else {\n\t\ts.push(atoi(st.c_str()));\n\t}\n}\nint getPriority(string s) {\n\tif(s == \"(\") {\n\t\treturn 5;\n\t} else if(s == \"*\" || s == \"/\") {\n\t\treturn 3;\n\t} else if(s == \"+\" || s == \"-\") {\n\t\treturn 2;\n\t} else if(s == \")\") { \n\t\treturn 1;\n\t} else return 4;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(--str.end());\n\t\t\n\t\tvector<string> v;\n\t\t\n\t\tint f = 0;\n\t\tchar prev = '(';\n\t\tbool minus = 0;\n\t\trep(i, str.size()) {\t\t\n\t\t\tif(isdigit(str[i])) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif(f) {\n\t\t\t\t\tstring st;\n\t\t\t\t\tif(minus) {\n\t\t\t\t\t\tst += '-';\n\t\t\t\t\t\tminus = 0;\n\t\t\t\t\t}\n\t\t\t\t\trep(j,f) {\n\t\t\t\t\t\tst += str[i - f + j];\n\t\t\t\t\t}\t\n\t\t\t\t\tv.push_back(st);\n\t\t\t\t\tstring st2;\n\t\t\t\t\tst2 += str[i];\n\t\t\t\t\tv.push_back(st2);\n\t\t\t\t\tf = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif(prev == '(' && str[i] == '-') {\n\t\t\t\t\t\tminus = 1;\n\t\t\t\t\t\tprev = str[i];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstring st3;\n\t\t\t\t\tst3 += str[i];\n\t\t\t\t\tv.push_back(st3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = str[i];\n\t\t}\n\t\tif(f) {\n\t\t\tstring st;\n\t\t\trep(j,f) {\n\t\t\t\tst += str[str.size() - f + j];\n\t\t\t}\n\t\t\tv.push_back(st);\n\t\t}\n\n\t\tstack<string> s;\n\t\tvector<string> nv;\n\t\tstack<ll> ret;\n\t\tint p = 0;\n\t\trep(i,v.size()) {\n\t\t\tcout << v[i] << endl;\n\t\t}\n\t\trep(i,v.size()) {\n\t\t\tp = getPriority(v[i]);\n\t\t\twhile(!s.empty() && getPriority(s.top()) > p && s.top() != \"(\") {\n\t\t\t\tnv.push_back(s.top());\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(v[i] == \")\") {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(v[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()) {\n\t\t\tnv.push_back(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\trep(i,nv.size()) {\n\t\t\tcalc(nv[i], ret);\n\t\t}\n\t\tcout << ret.top() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing State = string::const_iterator;\nclass ParseError {};\n\n//-------------------------------------\n\nint expr(State &);\nint term(State &);\nint number(State &);\nint factor(State &);\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--) {\n        string s;\n        cin >> s;\n        State now = s.begin();\n        int ans = expr(now);\n        cout << ans << endl;\n    }\n}\n\nint number(State &now) {\n    int res = 0;\n    while(isdigit(*now)) {\n        res *= 10;\n        res += *now - '0';\n        now++;\n    }\n    return res;\n}\n\nint term(State &now) {\n    int res = factor(now);\n    while(1) {\n        if(*now == '*') {\n            now++;\n            res *= factor(now);\n        } else if(*now == '/') {\n            now++;\n            res /= factor(now);\n        } else {\n            break;\n        }\n    }\n    return res;\n}\n\nint expr(State &now) {\n    int res = term(now);\n    while(1) {\n        if(*now == '+') {\n            now++;\n            res += term(now);\n        } else if(*now == '-') {\n            now++;\n            res -= term(now);\n        } else {\n            break;\n        }\n    }\n    return res;\n}\n\nint factor(State &now) {\n    if(*now == '(') {\n        now++;\n        int res = expr(now);\n        now++;\n        return res;\n    } else {\n        return number(now);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\ntypedef pair<int,const char*>parsed;\nparsed expr(const char *p);\nparsed term(const char *p);\nparsed fact(const char *p);\nparsed expr(const char *p){\n  parsed r=term(p);\n while(*r.second=='+'||*r.second=='-'){\n    char op =*r.second;\n    int tmp=r.first;\n    r=term(r.second+1);\n    if(op=='+')r.first=tmp+r.first;\n    else r.first=tmp-r.first;\n  }\n  return r;\n}\nparsed term(const char *p){\n  parsed r=fact(p);\n  while(*r.second=='*'||*r.second=='/'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=fact(r.second+1);\n    if(op=='*')r.first=tmp*r.first;\n    else r.first=tmp/r.first;\n  }\n  return r;\n}\nparsed fact(const char *p){\n  if(isdigit(*p)){\n    int t=*(p++)-'0';\n    while(isdigit(*p))t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if(*p=='('){\n    parsed r=expr(p+1);\n    if(*r.second!=')')exit(0);\n    return parsed(r.first,r.second+1);\n  }\n  else exit(0);\n}\nmain(){\n  string str;\n  int n;\n  cin>>n;\n  while(n--){\n\t  cin>>str;\n    cout<<expr(str.c_str()).first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0])){\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\telse if(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\t//if (*res.second!=')') exit(0);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse\n\t\texit(0);\n}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <char> VC;\n\nstring toNums( string s ) {\n    string R = \"+-*/\";\n    for ( int i = 0; i < 4; ++ i ) {\n        replace( s.begin(), s.end(), R[i], ' ' );\n    }\n    return s;\n}\n\nstring toOps( string s ) {\n    string R = \"0123456789\";\n    for ( int i = 0; i < 10; ++ i ) {\n        replace( s.begin(), s.end(), R[i], ' ' );\n    }\n    return s;\n}\n\nint eval( string expr ) {\n    stack <int> S;\n    for ( int i = 0; i < (int)expr.size(); ++ i ) {\n        if ( expr[i] == '(' ) {\n            S.push( i );\n        } else if ( expr[i] == ')' ) {\n            int left = S.top();\n            int right = i;\n            string L = expr.substr( 0, left );\n            string M = expr.substr( left, right - left + 1 );\n            string R = expr.substr( right + 1 );\n            ostringstream os;\n            os << eval( M.substr( 1, M.size()-2 ) );\n            expr = L + os.str() + R;\n            i = -1;\n            S = stack <int>();\n            continue;\n        }\n    }\n    string nums = toNums( expr );\n    string ops = toOps( expr );\n    VI N;\n    int num;\n    istringstream is1( nums );\n    while ( is1 >> num ) {\n        N.push_back( num );\n    }\n    VC O;\n    char op;\n    istringstream is2( ops );\n    while ( is2 >> op ) {\n        O.push_back( op );\n    }\n    for ( int i = 0; i + 1 < (int)N.size(); ++ i ) {\n        int a = N[i], b = N[i+1];\n        char c = O[i];\n        if ( c == '*' ) {\n            N.erase( N.begin() + i );\n            N[i] = a * b;\n            O[i] = O[i+1];\n            i --;\n        } else if ( c == '/' ) {\n            N.erase( N.begin() + i );\n            N[i] = a / b;\n            O[i] = O[i+1];\n            i --;\n        }\n    }\n    int answer = N[0];\n    for ( int i = 0; i + 1 < (int)N.size(); ++ i ) {\n        if ( O[i] == '+' ) {\n            answer += N[i+1];\n        } else {\n            answer -= N[i+1];\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        if ( n == 0 ) break;\n        for ( int i = 0; i < n; ++ i ) {\n            string line;\n            cin >> line;\n            cout << eval( line.substr( 0, line.size() - 1 ) ) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    return 0;\n}\n\n// class Mycin {\n// \tbool flag = true;\n// public:\n// \tMycin& operator >> (int& a) {flag = scanf(\"%lld\", &a) != EOF; return *this;}\n// \tMycin& operator >> (char& a) {flag = scanf(\"%c\", &a) != EOF; return *this;}\n// \tMycin& operator >> (string& s) {flag = (bool)(cin >> s); return *this;}\n// \toperator bool() {return flag;}\n// } mycin;\n \n// class Mycout {\n// public:\n// \tMycout& operator << (const int& a) {printf(\"%lld\", a); return *this;}\n// \tMycout& operator << (const char c) {printf(\"%c\", c); return *this;}\n// \tMycout& operator << (const string& s) {printf(\"%s\", s.c_str()); return *this;}\n// } mycout;\n \n// #define cin mycin\n// #define cout mycout\n// #define endl '\\n'\n\nint number(const string& s, int& i);\nint factor(const string& s, int& i);\nint term(const string& s, int& i);\nint expr(const string& s, int& i);\n\nint number(const string& s, int& i) {\n    int res = 0;\n    for (; isdigit(s[i]); i++) {\n        res *= 10;\n        res += s[i] - '0';\n    }\n    return res;\n}\n\nint factor(const string& s, int& i) {\n    if (isdigit(s[i])) return number(s, i);\n    i++;\n    int res = expr(s, i);\n    i++;\n    return res;\n}\n\nint term(const string& s, int& i) {\n    int res = factor(s, i);\n    while (s[i] == '*' || s[i] == '/') {\n        char op = s[i];\n        i++;\n        int a = factor(s, i);\n        if (op == '*') res *= a;\n        else           res /= a;\n    }\n    return res;\n}\n\nint expr(const string& s, int& i) {\n    int res = term(s, i);\n    while (s[i] == '+' || s[i] == '-') {\n        char op = s[i];\n        i++;\n        int a = term(s, i);\n        if (op == '+') res += a;\n        else           res -= a;\n    }\n    return res;\n}\n\nint eval(const string& s) {\n    int i = 0;\n    return expr(s, i);\n}\n\nvoid solve() {\n    int N;\n    string s;\n    cin >> N;\n    rep(i, N) {\n        cin >> s;\n        cout << eval(s) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\ntypedef int Val;\ntypedef pair<Val,int> Res;\n#define val first\n#define idx second\n\nRes readExpr(string &s, int idx);\nRes readTerm(string &s, int idx);\nRes readFctr(string &s, int idx);\n\nRes readQuery(string &s, int idx){\n  //cout << \"Q[\";\n  Res r = readExpr(s, idx);\n  // skip '=';\n  //cout << \"]\";\n  return r;\n}\nRes readExpr(string &s, int idx){\n  //cout << \"E[\";\n  Res r = readTerm(s, idx);\n  while (s[r.idx]=='+' || s[r.idx]=='-'){\n    Res r2 = readTerm(s, r.idx+1);\n    if (s[r.idx]=='+') r.val += r2.val;\n    else r.val -= r2.val;\n    r.idx = r2.idx;\n  }\n  //cout << \"]\";\n  return r;\n}\nRes readTerm(string &s, int idx){\n  //cout << \"T[\";\n  Res r = readFctr(s, idx);\n  while (s[r.idx]=='*' || s[r.idx]=='/'){\n    Res r2 = readFctr(s, r.idx+1);\n    if (s[r.idx]=='*') r.val *= r2.val;\n    else r.val /= r2.val;\n    r.idx = r2.idx;\n  }\n  //cout << \"]\";\n  return r;\n}\nRes readFctr(string &s, int idx){\n  Res r;\n  //cout << \"F[\";\n  if (s[idx]=='('){\n    r = readExpr(s, idx+1);\n    r.idx++; // skip ')'\n  } else {\n    int sgn=1,num=0;\n    if (s[idx]=='-'){\n      sgn=-1;\n      idx++;\n    }\n    while (s[idx]>='0'&&s[idx]<='9'){\n      num = num*10 + (s[idx]-'0');\n      idx++;\n    }\n    r.val = num*sgn; r.idx = idx;\n  }\n  //cout<<\"]\";\n  return r;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  for (int i=0; i<n; i++){\n    string str; cin >> str;\n    cout << readQuery(str,0).val << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    int number(State &begin) {\n\t    int ret = 0;\n\t    while(isdigit(*begin)) {\n\t    \tret *= 10;\n\t    \tret += *begin - '0';\n\t    \tbegin++;\n\t    }\n\t    return ret;\n    }\n\n    int factor(State &begin) {\n\t    if(*begin == '(') {\n\t\t    begin++;\n\t\t    int ret = expression(begin);\n\t\t    begin++;\n            return ret;\n\t    } else {\n\t\t    return number(begin);\n\t    }\n    }\n\n    int term(State &begin) {\n\t    int ret = factor(begin);\n\t    while(1) {\n\t    \tif(*begin == '*') {\n\t    \t\tbegin++;\n\t    \t\tret *= factor(begin);\n\t    \t} else if(*begin == '/') {\n                begin++;\n\t    \t\tret /= factor(begin);\n\t    \t} else {\n\t    \t\tbreak;\n\t    \t}\n    \t}\n    \treturn ret;\n    }\n\n    int expression(State &begin) {\n\t    int ret = term(begin);\n\t    while(1) {\n\t    \tif(*begin == '+') {\n\t\t    \tbegin++;\n\t\t    \tret += term(begin);\n\t    \t} else if(*begin == '-') {\n\t    \t\tbegin++;\n\t\t    \tret -= term(begin);\n\t    \t} else {\n\t    \t\tbreak;\n\t    \t}\n    \t}\n    \treturn ret;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        Parser ps;\n        string s;\n        cin >> s;\n        State begin = s.begin();\n        int ans = ps.expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <stdlib.h>\n\nusing namespace std;\n\nstring ex_s; //expression_string\nint n;\n\nint cal(string ex_s) //calculate expression_string\n{\n    int i;\n    int j;\n    int ans; //answer\n    int cnt_p=0; //count_parentheses\n    int cnt_pp=1;\n    int cnt_as=0; //count_add subtract\n    int cnt_md=0; //count_nultiply divide\n    for(i=0;i<ex_s.size();i++)\n    {\n        if(ex_s[i]=='(')\n        {\n            for(j=i+1;j<ex_s.size();j++)\n            {\n                if(ex_s[j]=='(') cnt_pp+=1;\n                else if(ex_s[j]==')')\n                {\n                    cnt_pp-=1;\n                    if(cnt_pp==0)\n                    {\n                        cnt_pp=1;\n                        break;\n                    }\n                }\n            }\n            ans=cal(ex_s.substr(i+1,j-i-1));\n            ex_s=ex_s.substr(0,i)+to_string(ans)+ex_s.substr(j+1);\n            i=j;\n            cnt_p+=1;\n        }\n    }\n    if(cnt_p!=0)\n    {\n        return cal(ex_s);\n    }\n    else\n    {   for(i=0;i<ex_s.size();i++)\n        {\n            if(ex_s[i]=='+')\n            {\n                ans=cal(ex_s.substr(0,i))+cal(ex_s.substr(i+1));\n                cnt_as+=1;\n                return ans;\n                break;\n            }\n            else if(ex_s[i]=='-')\n            {\n                if(i==0) ans=0-cal(ex_s.substr(i+1));\n                else ans=cal(ex_s.substr(0,i))-cal(ex_s.substr(i+1));\n                cnt_as+=1;\n                return ans;\n                break;\n            }\n        }\n        if(cnt_as==0)\n        {\n            for(i=0;i<ex_s.size();i++)\n            {\n                if(ex_s[i]=='*')\n                {\n                    ans=cal(ex_s.substr(0,i))*cal(ex_s.substr(i+1));\n                    cnt_md+=1;\n                    return ans;\n                    break;\n                }\n                else if(ex_s[i]=='/')\n                {\n                    ans=cal(ex_s.substr(0,i))/cal(ex_s.substr(i+1));\n                    cnt_md+=1;\n                    return ans;\n                    break;\n                }\n            }\n            if(cnt_md==0)\n            {\n                return atoi(ex_s.c_str());\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    while(n--)\n    {\n        cin >> ex_s;\n        ex_s.pop_back();\n        cout << cal(ex_s) << endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n      \n      // else if(str[i] == '+' || str[i] == '-'){\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = tmp;\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n      // else{\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = string(tmp);\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    //    tmp += side[i];\n    hand.push_back(side[i]);\n  }\n  \n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  //  getline(cin,s);\n  //  n = atoi(s.c_str());\n  cin >> n;\n    //  scanf(\"%d\\n\",&n);\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    //  getline(cin,str);\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cassert>\n#include <string>\n#include <iostream>\nusing namespace std;\n\n\nstring S;\nsize_t cur = 0;\nint parse();\nint expression();\n\n\nint digit(){\n  assert(isdigit(S[cur]));\n  int n = S[cur]-'0';\n  cur =cur+1;\n  // cout << n <<endl;\n  return n;\n}\n\nint number (){\n  int n = digit();\n  // cout << n << endl;\n  while(cur<S.size() && isdigit(S[cur])) n=n*10 + digit();\n  // cout << n<<endl;\n  return n;\n}\n\nint factor(){\n  if(S[cur] != '('){\n    return number();\n  }\n  cur += 1;\n  int n = expression();\n  assert(S[cur]==')');\n  cur+=1;\n  return n;\n}\n\nint term(){\n  int a=factor();\n  while(cur<S.size() && (S[cur]=='*' || S[cur]=='/')){\n    char op = S[cur++];\n    int b = number();\n    if(op=='*') a*=b; else a/=b;\n  }\n  return a;\n}\n\nint expression(){\n  int a;\n  a= term();\n  while(cur<S.size()&&(S[cur]=='+'||S[cur]=='-')){\n    char op = S[cur++];\n    int b = term();\n    if(op == '+') a += b;else a -=b;\n  }\n  return a;\n  // int sum = number();\n  // while(S[cur] == '+'|| S[cur] == '-'||S[cur]=='*'||S[sur]=='/'){\n  //   char op = S[cur];\n  //   cur += 1;\n  //   int b = number();\n  //   if(op=='+'){\n\n  //   }\n\n  // }\n\n\n  // int a = number();\n  // char op = S[cur];\n  // cur += 1;\n  // int b = number();\n  // assert(op == '+');\n  // return a + b;\n}\n\n\n\nint main(){\n  int N;\n  cin >> N;\n  for (int i=0;i<N;++i){\n    cur=0;\n    cin>>S;\n    S.resize(S.size()-1);\n    cout << expression()<<endl;\n  }\n}\n// int parse(){return expression();}\n// int main(){\n//   int a = parse();\n//   // assert(a==15);\n//   cout << a << endl;\n//   assert(cur == S.size());\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint add();\n\nstring s;\nint p;\n\nint num()\n{\n\tint res;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = add();\n\t\tassert(s[p] == ')');\n\t\tp++;\n\t}\n\telse if (isdigit(s[p]))\n\t{\n\t\tres = 0;\n\t\twhile (p < s.size() && isdigit(s[p]))\n\t\t{\n\t\t\tres *= 10;\n\t\t\tres += s[p] - '0';\n\t\t\tp++;\n\t\t}\n\t}\n\telse assert(false);\n\treturn res;\n}\n\nint mul()\n{\n\tint res = num();\n\twhile (p < s.size() && (s[p] == '*' || s[p] == '/'))\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tint r = num();\n\t\tif (c == '*')\n\t\t{\n\t\t\tres *= r;\n\t\t}\n\t\telse if (c == '/')\n\t\t{\n\t\t\tres /= r;\n\t\t}\n\t}\n\treturn res;\n}\n\nint add()\n{\n\tint res = mul();\n\twhile (p < s.size() && (s[p] == '+' || s[p] == '-'))\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tint r = mul();\n\t\tif (c == '+')\n\t\t{\n\t\t\tres += r;\n\t\t}\n\t\telse if (c == '-')\n\t\t{\n\t\t\tres -= r;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve()\n{\n\tp = 0;\n\treturn add();\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n; cin >> n;\n\tREP(cs, n)\n\t{\n\t\tcin >> s;\n\t\ts = s.substr(0, s.size() - 1);\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint exp();\nint term();\nint factor();\nint number();\nint digit();\nint p=0;\nstring str;\nint main(){\n  int n,re;\n  cin >> n;\n  while(n){\n    p=0;\n    cin >> str;\n    re=exp();\n    cout << re << endl;\n    n--;\n  }\n  return 0;\n}\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\nint term(){\n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\nint factor(){\n  int val;\n  if(str[p]=='('){\n    p++;\n    val=exp();\n    p++;\n  }else{\n      val=digit();\n  }\n  return val;\n}\nint number(){\n  int val=digit();\n  return val;\n}\nint digit(){\n  int ret,cnt=0;\n  while(1){\n    if(cnt==0&&'0'<=str[p]&&str[p]<='9'){\n      ret=str[p]-'0';\n      p++;\n      cnt=1;\n    }\n    else if(cnt==1&&'0'<=str[p]&&str[p]<='9'){\n      ret=ret*10+(str[p]-'0');\n      p++;\n    }\n    else{\n      break;\n    }\n  }\n  /*  if('0' <= str[p] && str[p] <= '9') {\n    if(cnt==0){\n      ret=str[p]-'0';\n      cnt=1;\n    }\n    p++;\n    if('0' <= str[p] && str[p] <= '9') {\n      ret=ret*10+(str[p]-'0');\n      digit();\n    }\n    return ret;\n    }*/\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint calc(char *s, int &i){\n  int ret = 0;\n  bool flag = i >= 0 && s[i-1] == '(';\n\n  //debug(s[i]);\n  \n  for(;s[i];){\n    \n    if(s[i] == ')'){\n      if(flag) i++;\n      return ret;\n    }\n    \n    if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/'){\n\n      i++;\n      \n      if(s[i] == '('){\n        i++;\n\n        if(i-2 < 0) ret += calc(s,i);\n        if(s[i-2] == '+') ret += calc(s,i);\n        if(s[i-2] == '-') ret -= calc(s,i);\n        if(s[i-2] == '*') ret *= calc(s,i);\n        if(s[i-2] == '/') ret /= calc(s,i);\n\n        continue;\n      }\n\n            \n      if(s[i-1] == '+') ret += calc(s,i);\n      if(s[i-1] == '-') ret -= calc(s,i);\n      \n    }else{\n      int start = i-1;\n      int sum = 0;\n      \n      while(!(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '\\0' || s[i] == ')')){\n        sum *= 10;\n        sum += s[i] - '0';\n        i++;\n      }\n\n      if(start < 0){\n        ret += sum;\n      }else{\n        if(s[start] == '(') ret += sum;\n        if(s[start] == '+') ret += sum;\n        if(s[start] == '-') ret += sum;\n        if(s[start] == '*') ret *= sum;\n        if(s[start] == '/') ret /= sum;\n      }\n    }\n  }\n  \n  return ret;\n}\n\n\nint main(){\n  char s[SIZE];\n  int t = 0;\n\n  int n;\n\n  scanf(\"%d\",&n);\n\n  while(n--){\n    char s2[SIZE] = {};\n    t = 0;\n    scanf(\"%s\",s);\n\n    s[strlen(s)-1] = '\\0';\n\n    strcat(s2,\"0+\");\n    strcat(s2,s);\n    \n    printf(\"%d\\n\",calc(s2,t));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://gist.github.com/draftcode/1357281 を参考にした\n#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\ntypedef string::const_iterator State;\n\nclass ParseError{};\n\nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\n\n// 四則演算の式をパースして，その評価結果を返す．\nint expression(State &begin) {\n\tint ret = term(begin);\n\t\n\twhile (true) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n// 乗算除算の式をパースして，その評価結果を返す．\nint term(State &begin) {\n\tint ret = number(begin);\n\t\n\twhile (true) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\t//ret *= number(begin);\n\t\t\tret *= factor(begin); // 括弧がある式に対応\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\t//ret /= number(begin);\n\t\t\tret /= factor(begin); // 括弧がある式に対応\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n// 括弧か数をパースして，その評価結果を返す．\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('を飛ばす．\n\t\tint ret = expression(begin);\n\t\tbegin++; // ')'を飛ばす．\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\n// 数字の列をパースして，その数を返す．\nint number(State &begin) {\n\tint ret = 0;\n\t\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\t\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long Int;\ntypedef string::const_iterator Iter;\n\nInt eval(const string&);\nInt expr(Iter&);\nInt term(Iter&);\nInt factor(Iter&);\nInt number(Iter&);\n\nInt eval(const string &s){\n\tIter it = s.begin();\n\treturn expr(it);\n}\n\nInt expr(Iter &it){\n\tInt res = term(it);\n\twhile (true){\n\t\tif (*it == '+'){\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t}\n\t\telse if (*it == '-'){\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt term(Iter &it){\n\tInt res = factor(it);\n\twhile (true){\n\t\tif (*it == '*'){\n\t\t\t++it;\n\t\t\tres *= term(it);\n\t\t}\n\t\telse if (*it == '/'){\n\t\t\t++it;\n\t\t\tres /= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt factor(Iter &it){\n\tif (*it == '('){\n\t\t++it;\n\t\tInt res = expr(it);\n\t\t++it;\n\t\treturn res;\n\t}\n\telse return number(it);\n}\n\nInt number(Iter &it){\n\tInt res = 0;\n\twhile (isdigit(*it)){\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\ts.resize(s.size() - 1);\n\t\tcout << eval(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nint expression();\nint term();\nint factor();\nint number();\n\nint now;\nstring s;\n\nint expression(){\n\tint res=term();\n\t\twhile(true){\n\t\tif(s[now]=='+')now++,res+=term();\n\t\telse if(s[now]=='-')now++,res-=term();\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint term(){\n\tint res=factor();\n\twhile(true){\n\t\tif(s[now]=='(')res+=factor();\n\t\telse if(s[now]=='*')now++,res*=factor();\n\t\telse if(s[now]=='/')now++,res/=factor();\n\t\telse break;\n\t}\n\treturn res;\n}\n\nint factor(){\n\tint res=0;\n\tif(s[now]=='(')now++,res=expression(),now++;\n\telse return number();\n\treturn res;\n}\n\nint number(){\n\tint res=0;\n\twhile('0'<=s[now] && s[now]<='9')res*=10,res+=s[now++]-'0';\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\t\n\twhile(n--){\n\t\tcin >> s;\n\t\tnow=0;\n\t\tcout << expression() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0])){\n\t\tconst char* p=s;\n\t\t//if(*p=='-')\n\t\t//\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\telse if(s[0]=='('){\n\t\tparsed res=expr(s+1);\n\t\tif (*res.second!=')') exit(0);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse\n\t\texit(0);\n}\n\n//parsed fact(const char *p)\n//{\n//  if (isdigit(*p)){\n//    int t=0;\n//    while(isdigit(*p)) t=t*10+*(p++)-'0';\n//    return parsed(t,p);\n//  }\n//  else if (*p=='('){\n//    parsed r=expr(p+1);\n//    if (*r.second!=')') exit(0); // invalid input\n//    return parsed(r.first,r.second+1);\n//  }\n//  else\n//    exit(0); // invalid input\n//}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include <string>\nusing namespace std;\n\nint weak(string& s, int& i);\nint strong(string& s, int& i);\nint fc(string& s, int& i);\nint inte(string& s, int& i);\n\nint weak(string& s, int& i) {\n\tint buf = strong(s, i);\n\twhile (s[i] == '+' || s[i] == '-') {\n\t\tif (s[i] == '+') {\n\t\t\ti++;\n\t\t\tbuf += strong(s, i);\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tbuf -= strong(s, i);\n\t\t}\n\t}\n\treturn buf;\n}\n\nint strong(string& s, int& i) {\n\tint buf = fc(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tif (s[i] == '*') {\n\t\t\ti++;\n\t\t\tbuf *= fc(s, i);\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tbuf /= fc(s, i);\n\t\t}\n\t}\n\treturn buf;\n}\n\nint fc(string& s, int& i) {\n\tif ('0' <= s[i] && '9' >= s[i])return inte(s, i);\n\telse {\n\t\ti++;\n\t\tint re = weak(s, i);\n\t\ti++;\n\t\treturn re;\n\t}\n}\n\nint inte(string& s, int& i) {\n\tint buf = s[i] - '0';\n\ti++;\n\twhile ('0' <= s[i] && '9' >= s[i]) {\n\t\tbuf = buf * 10 + s[i];\n\t\ti++;\n\t}\n\treturn buf;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s; int j = 0;\n\t\tcin >> s;\n\t\tcout << weak(s, j) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint factor(State &begin);\n\n// ??°?????????????????????\nint number(State &begin) {\n    int ret = 0;\n    while(isdigit(*begin)) {\n        ret *= 10;\n        ret += (*begin - '0');\n        begin++;\n    }\n    return ret;\n}\n\n// ??¬??§?????°????????????\nint factor(State &begin) {\n    if(*begin == '(') {\n        begin++; // '(' ????£???°???\n        int ret = expression(begin);\n        begin++; // ')' ????£???°???\n        return ret;\n    }\n    else return number(begin);\n}\n\n// ??????????????????????????????\nint term(State &begin) {\n    // ????????????????????¨????????£????????°??????????????§???????????????\n    // begin ?????????????????°?????§???????????????\n    int ret = factor(begin);\n\n    while(1) {\n        if(*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        }\n        else if(*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        }\n        else break;\n    }\n\n    return ret;\n}\n\n// ??????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n    while(1) {\n        if(*begin == '+') {\n            begin++;\n            ret += term(begin);\n        }\n        else if(*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        }\n        else break;\n    }\n    return ret;\n}\n\nsigned main() {\n    int N; cin >> N;\n    rep(i,0,N) {\n        string s; cin >> s;\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n\nstring str,t;\n\nstring calc(string s){\n\n\tvector<char> otr;\n\totr.reserve(1000);\n\tvector<int> ond;\n\tond.reserve(1000);\n\tstring tmp;\n\tsize_t now = 0;\n\t\n\twhile( ~s.find_first_of(\"*/-+=\",now) ){\n\t\ttmp = s.substr(now,s.find_first_of(\"*/-+=\",now)-now);\n\t\tond.push_back( atoi(tmp.c_str() ) );\n\t\totr.push_back( s[s.find_first_of(\"*/-+=\",now)] );\n\t\tnow = s.find_first_of(\"*/-+=\",now)+1;\n\t}\n\n\tfor(int i=0;i<otr.size();i++){\n\t\tif(otr[i]=='*'){\n\t\t\tond[i] = ond[i] * ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}else if(otr[i]=='/'){\n\t\t\tond[i] = ond[i] / ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t\ti--;\n\t\t}\n\t}\n\n\t/*cout << ond[0];\n\tfor(int j=0;j<otr.size();j++){\n\t\tif(otr[j]=='=')break;\n\t\tcout << \" \" << otr[j] << \" \";\n\t\tcout << ond[j+1];\n\t}\n\tcout << endl;\n\t*/\n\tfor(int i=0;i<otr.size();i++){\n\t\tif(otr[i]=='+'){\n\t\t\tond[i] = ond[i] + ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t}else if(otr[i]=='-'){\n\t\t\tond[i] = ond[i] - ond[i+1] ;\n\t\t\tond.erase(ond.begin()+i+1) ;\n\t\t\totr.erase(otr.begin()+i)   ;\n\t\t}\n\t}\n\tstringstream ret;\n\tif(otr[0]=='+')ret << ond[0]+ond[1];\n\telse if(otr[0]=='-')ret << ond[0]-ond[1];\n\telse if(otr[0]=='*')ret << ond[0]*ond[1];\n\telse if(otr[0]=='/')ret << ond[0]/ond[1];\n\telse ret << ond[0];\n\treturn ret.str();\n}\n\nstring parent(string s){\t\n\tint st,en;\n\tif(~s.find(\"(\")){\n\t\t\tst = s.find(\"(\");\n\t\t\ten = s.rfind(\")\");\n\t\t\tt = s.substr(st+1,en-st-1);\n\t\t\ts.replace( st , en-st+1 , parent(t+string(\"=\")) );\n\t}\n\treturn calc(s);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(cin >> str){\n\t\t/*\n\t\tif(~s.find(\"(\")){\n\t\t\tst = s.find(\"(\");\n\t\t\ten = s.rfind(\")\");\n\t\t\tt = s.substr(st+1,en-st-1);\n\t\t}*/\n\t\tcout << parent(str) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//18\n#include<iostream>\n#include<cctype>\n\nusing namespace std;\n\nchar s[101];\nchar *p;\n\nint pp();\nint pm();\nint pb();\n\nint pp(){\n  int a=pm();\n  while(*p=='+'||*p=='-'){\n    char o=*p++;\n    int b=pm();\n    if(o=='+'){\n      a+=b;\n    }else{\n      a-=b;\n    }\n  }\n  return a;\n}\n\nint pm(){\n  int a=pb();\n  while(*p=='*'||*p=='/'){\n    char o=*p++;\n    int b=pb();\n    if(o=='*'){\n      a*=b;\n    }else{\n      a/=b;\n    }\n  }\n  return a;\n}\n\nint pb(){\n  if(*p=='('){\n    p++;\n    int a=pp();\n    p++;\n    return a;\n  }else{\n    int a=0;\n    while(isdigit(*p)){\n      a=a*10+*p-'0';\n      p++;\n    }\n    return a;\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>s;\n    p=s;\n    cout<<pp()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n      \n      // else if(str[i] == '+' || str[i] == '-'){\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = tmp;\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n      // else{\n      // \tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n      // \t  hand.push_back(side[side.size()-1]);\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side[side.size()-1] = string(tmp);\n      // \t}\n      // \telse{\n      // \t  string tmp;\n      // \t  tmp += str[i];\n      // \t  side.push_back(tmp);\n      // \t}\n      // }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  //  getline(cin,s);\n  //  n = atoi(s.c_str());\n  //  cin >> n;\n  scanf(\"%d\\n\",&n);\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tret *= term(++begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tret /= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tret += term(++begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tret -= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\nState s = str.begin();\n\t\tcout << expression(s) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\nstring query;\nconst char *p;\n\nint exprs();\n\nint factor() {\n  char *e;\n  int ret;\n\n  if(*p == '(') {\n    p ++;\n    ret = exprs();\n    return ret;\n  }\n  \n  ret = strtol(p, &e, 10);\n  // cout << \"factor: \" << ret << endl;\n  p = e;\n  \n  return ret;\n}\n\nint term() {\n  int ret = factor();\n\n  for(;;) {\n    if(*p == '*') {\n      p++;\n      ret *= factor();\n    } else if(*p == '/') {\n      p++;\n      ret /= factor();\n    } else {\n      break;\n    }\n  }\n  \n  return ret;\n}\n\nint exprs() {\n  \n  int ret = term();\n  for(;;) {\n    if(*p == '+') {\n      p ++;\n      ret += term();\n    } else if(*p == '-') {\n      p ++;\n      ret -= term();\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int n;\n  \n  cin >> n; cin.ignore();\n  for(int i=0; i<n; i++) {\n    getline(cin, query);\n    query = query.substr(0, query.size()-1);\n    p = query.c_str();\n    cout << exprs() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nstring S;\nsize_t cur;\nint x;\n\nchar readchar(){\n\tassert(cur < S.size());\n\treturn S[cur++];\n}\n\nchar peek(){\n\tassert(cur < S.size());\n\treturn S[cur];\n}\n\nint digit(){\n\tassert(isdigit(peek()));\n\tint n = readchar() - '0';\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(peek())){\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor(){\n\tif (peek() != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(peek()==')');\n\tcur+=1;\n\treturn n;\n}\n\nint term(){\n\tint a = factor();\n\twhile(cur < S.size() && (peek()=='*' || peek()=='/')){\n\t\tchar op = readchar();\n\t\tint b = factor();\n\t\tif (op=='*'){\n\t\t\ta = a*b;\n\t\t}else{\n\t\t\ta = a/b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint a = term();\n\twhile(cur < S.size() && (peek()=='+' || peek()=='-')){\n\t\tchar op = readchar();\n\t\tint b = term();\n\t\tif (op == '+'){\n\t\t\ta = a+b;\n\t\t}else{\n\t\t\ta = a-b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint main() {\n\tcin >> x;\n\tfor (int i=1; i<=x; i++){\n\t\tcin >> S;\n\t\tcur = 0;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\n\t\treturn foo2(foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1)));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vecpll vector<pll>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),(x)))\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvec iota(int n){vec a(n);iota(all(a),0);return a;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n// #define _GLIBCXX_DEBU\n#define endl '\\n'\n#ifdef _MY_DEBUG\n    #undef endl\n    #define debug(x) cout<<#x<<\": \"<<x<<endl\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint number(State &);\nint factor(State &);\nint expression(State &);\nint term(State &);\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin-'0';\n        begin++;\n    }\n    return ret;\n}\nint expression(State &begin){\n    int ret = term(begin);\n    for(;;){\n        if(*begin=='+'){\n            begin++;\n            ret+=term(begin);\n        }\n        else if(*begin=='-'){\n            begin++;\n            ret-=term(begin);\n        }\n        else break;\n    }\n    return ret;\n}\nint term(State &begin){\n    int ret = factor(begin);\n    for(;;){\n        if(*begin=='*'){\n            begin++;\n            ret*=factor(begin);\n        }\n        else if(*begin=='/'){\n            begin++;\n            ret/=factor(begin);\n        }\n        else{\n            break;\n        }\n    }\n    return ret;\n}\nint factor(State &begin){\n    if(*begin=='('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else{\n        return number(begin);\n    }\n}\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    string s;\n    int n=in();\n    cin.ignore();\n    rep(i,n){\n        getline(cin,s);\n        State begin = s.begin();\n        cout << expression(begin) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nsigned main(){\n  string s;\n  while(cin>>s){\n    int p=0;\n    cin>>s;\n    if(s.back()=='=') s.pop_back();\n    cout<<expression(s,p)<<endl;\n  }\n  return 0;\n}\n\n/*\nverified on 2017/04/26\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id=0109\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cctype>\nusing namespace std;\nstring S;\nsize_t cur;\nint expression();\n\nint digit() {\n    //  Digit := '0' | '1' | ... | '9'\n    assert(isdigit(S[cur]));    // S[cur] が数字であることを確認\n    int n = S[cur] - '0';       // '0' を 0 に変換\n    cur = cur + 1;              // 一文字進める\n    return n;\n}\n\nint number() {\n    //  Number := Digit の繰り返し\n    int n = digit();\n    while (cur < S.size() && isdigit(S[cur])) {     // 次も数字が 1 文字先読み\n        n = n * 10 + digit();\n    }\n    return n;\n}\n\nint factor() {\n    //  Factor := '(' Expression ')' | Number\n    if (S[cur] != '(') return number();\n    cur += 1;\n    int n = expression();\n    assert(S[cur] == ')');\n    cur += 1;\n    return n;\n}\n\nint term() {\n    //  Term := Factor { ('*'|'/') Factor }\n    int a = factor();\n    while (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n        char op = S[cur++];\n        int b = factor();\n        if (op == '*') a *= b; else a /= b;\n    }\n    return a;\n}\n\nint expression() {\n    //  Expression := Term { ('+'|'-') Term }\n    int a = term();\n    while (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n        char op = S[cur++];\n        int b = term();\n        if (op == '+') a += b; else a -= b;\n    }\n    return a;\n}\n\nint parse() { return expression(); }\n\nint main() {\n    int n; cin >> n;\n    while (n--) {\n        cin >> S;\n        cur = 0;\n        S.resize(S.size() - 1);     // 最後の = を無視\n        cout << expression() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n#include<queue>\n#define int long long\nusing namespace std;\n\nstring Erase(string a, int b, int c,string e) {//b???????????????c??????????????§????¶????\n\tstring d;\n\tfor (int i = 0; i < b; i++) {\n\t\td += a[i];\n\t}\n\td += e;\n\tfor (int i = c+1; i < a.length(); i++) {\n\t\td += a[i];\n\t}\n\treturn d;\n}\nstring kake(string a) {\n\tint b = 1; a = \"*\" + a;\n\tfor (int c = 0; c < a.length(); c++) {\n\t\tint e = c+1;\n\t\tif (a[c] == '*') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9' || a[e] == '-')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb *= stoi(d);\n\t\t}\n\t\telse if (a[c] == '/') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9' || a[e] == '-')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb /= stoi(d);\n\t\t}\n\t\tc = e - 1;\n\t}\n\treturn to_string(b);\n}\nstring tasi(string a) {\n\tint b = 0; a = \"+\" + a;\n\tfor (int c = 0; c < a.length(); c++) {\n\t\tint e = c + 1;\n\t\tif (a[c] == '+') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9'||a[e]=='-')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb += stoi(d);\n\t\t}\n\t\telse if (a[c] == '%') {\n\t\t\tstring d;\n\t\t\tfor (; e < a.length(); e++) {\n\t\t\t\tif (a[e] >= '0'&&a[e] <= '9' || a[e] == '-')d += a[e];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tb -= stoi(d);\n\t\t}\n\t\tc = e - 1;\n\t}\n\treturn to_string(b);\n}\nstring keisan(string a) {\n\tvector<string>V;\n\tstring b;\n\tfor (char c : a) {\n\t\tif (c == '+' || c == '%') {\n\t\t\tV.push_back(b);\n\t\t\tb = \"\"; b += c;\n\t\t\tV.push_back(b);\n\t\t\tb = \"\";\n\t\t}\n\t\telse b += c;\n\t}\n\tV.push_back(b);\n\tfor (int i = 0; i < V.size(); i += 2) {\n\t\tV[i] = kake(V[i]);\n\t}\n\tstring S;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tS += V[i];\n\t}\n\treturn tasi(S);\n}\nsigned main(){\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tstring c; cin >> c;\n\t\tfor (int d = 1; d < c.length(); d++) {\n\t\t\tif (c[d - 1] >= '0'&&c[d - 1] <= '9') {\n\t\t\t\tif (c[d] == '-') {\n\t\t\t\t\tc[d] = '%';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = c.substr(0, c.length() - 1);\n\t\tc = \"(\" + c + \")\";\n\t\twhile (1) {\n\t\t\tbool s = false;//????????????????????? ( ?????????0\n\t\t\tint last = 0;\n\t\t\tfor (int i = 0; i < c.length(); i++) {\n\t\t\t\tif (c[i] == '(') {\n\t\t\t\t\ts = false;\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t\tif (c[i] == ')') {\n\t\t\t\t\tif (!s) {\n\t\t\t\t\t\tc = Erase(c, last, i, keisan(c.substr(last+1,i-last-1)));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts = true;\n\t\t\t\t}\n\t\t\t\tif (i == c.length() - 1) { goto l; }\n\t\t\t}\n\t\t}\n\tl:;\n\t\tcout << c << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\n\n\nint calculator(const string &s){\n\tint sta[100],sp=0;\n\tbool isnum[100];\n\tfor(int i=0;i<s.size();){\n\t\tif(s[i]=='=')break;\n\t\tif(s[i]=='('){\n\t\t\tsta[sp]='(';\n\t\t\tisnum[sp++]=false;\n\t\t\ti++;\n\t\t}else if(s[i]==')'){\n\t\t\tint a,b;\n\t\t\tb=sta[--sp];\n\t\t\twhile(sta[sp-1]!='('){\n\t\t\t\tchar op=sta[--sp];\n\t\t\t\ta=sta[--sp];\n\t\t\t\tif(op=='+')b=a+b;\n\t\t\t\telse b=a-b;\n\t\t\t}\n\t\t\tsp--;\n\t\t\twhile(sp&&!isnum[sp-1]&&(sta[sp-1]=='*'|| sta[sp-1]=='/') ){\n\t\t\t\tchar op=sta[--sp];\n\t\t\t\ta=sta[--sp];\n\t\t\t\tif(op=='*')b=a*b;\n\t\t\t\telse b=a/b;\n\t\t\t}\n\t\t\tsta[sp]=b;\n\t\t\tisnum[sp++]=true;\n\t\t\ti++;\n\t\t}else if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/'){\n\t\t\tsta[sp]=s[i];\n\t\t\tisnum[sp++]=false;\n\t\t\ti++;\n\t\t}else {\n\t\t\tint n=0;\n\t\t\tbool minus=false;\n\t\t\tif(s[i]=='-')minus=true,i++;\n\t\t\twhile(isdigit(s[i]))n+=n*10+s[i++]-'0';\n\t\t\tif(minus)n=-n;\n\t\t\tint a,b=n;\n\t\t\tif(2<=sp&&!isnum[sp-2]&&sta[sp-1]=='-'){\n\t\t\t\tsta[sp-1]=-n;\n\t\t\t\tisnum[sp-1]=true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile(sp&&!isnum[sp-1]&&(sta[sp-1]=='*'|| sta[sp-1]=='/') ){\n\t\t\t\t\tchar op=sta[--sp];\n\t\t\t\t\ta=sta[--sp];\n\t\t\t\t\tif(op=='*')b=a*b;\n\t\t\t\t\telse b=a/b;\n\t\t\t\t}\n\t\t\t\tsta[sp++]=b;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tint a,b;\n\tb=sta[--sp];\n\twhile(sp){\n\t\tchar op=sta[--sp];\n\t\ta=sta[--sp];\n\t\tif(op=='+')b=a+b;\n\t\telse b=a-b;\n\t}\n\treturn b;\n}\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n;\n\twhile(n--){\n\t\tcin>>s;\n\t\tcout<<calculator(s)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nstruct Parsing {\n\tint expression(State& it) {\n\t\tint res = term(it);\n\t\twhile (true) {\n\t\t\tif (*it == '+') res += term(++it);\n\t\t\telse if (*it == '-') res -= term(++it);\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint factor(State& it) {\n\t\tint res = 0;\n\t\tif (*it == '(') {\n\t\t\tres = expression(++it);\n\t\t\t++it;\n\t\t} else res = number(it);\n\t\treturn res;\n\t}\n\n\tint term(State& it) {\n\t\tint res = factor(it);\n\t\twhile (true) {\n\t\t\tif (*it == '*') res *= factor(++it);\n\t\t\telse if (*it == '/') res /= factor(++it);\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint number(State& it) {\n\t\tint res = 0;\n\t\twhile (isdigit(*it)) {\n\t\t\tres *= 10;\n\t\t\tres += *it - '0';\n\t\t\t++it;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint n; cin >> n;\n\tParsing solve;\n\twhile (n--) {\n\t\tstring s; cin >> s;\n\t\tState begin = s.begin();\n\t\tcout << solve.expression(begin) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem0109 : Smart Calculator **/\nstring s; int pos;\nint factor();\n\nint number()\n{\n\tint ret=0;\n\twhile (isdigit(s[pos])) {\n\t\tret *= 10;\n\t\tret += s[pos++]-'0';\n\t}\n\treturn ret;\n}\n\nint term()\n{\n\tint ret = number();\n\t\n\tfor(;;) {\n\t\tif (s[pos] == '*') {\n\t\t\tpos++;\n\t\t\tret *= factor();\n\t\t} else if (s[pos] == '/') {\n\t\t\tpos++;\n\t\t\tret /= factor();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint expression()\n{\n\tint ret=term();\n\t\n\tfor (;;) {\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tret += term();\n\t\t} else if (s[pos] == '-') {\n\t\t\tpos++;\n\t\t\tret -= term();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint factor()\n{\n\tint ret;\n\t\n\tif (s[pos]=='(') {\n\t\tpos++;\n\t\tret = expression();\n\t\tpos++;\n\t} else {\n\t\tret = number();\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint N; cin>>N;\n\trep(i, N) {\n\t\tcin>>s;\n\t\tpos=0;\n\t\tcout << expression() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\nchar readchar();\nchar peek();\nint digit();\nint number();\nint term();\nint expression();\nint factor();\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i){\n        cur = 0;\n        cin >> S;\n        S.resize(S.size()-1);\n        cout << expression() << endl;\n    }\n    return 0;\n}\n\nchar readchar(){\n    assert(cur < S.size());\n    char ret = S[cur];\n    cur += 1;\n    return ret;\n}\n\nchar peek(){\n    assert(cur < S.size());\n    return S[cur];\n}\n\nint digit(){\n    assert(isdigit(peek()));\n    int n = readchar() - '0';\n    return n;\n}\n\nint number(){\n    int n = digit();\n    while(cur < S.size() && isdigit(peek()))\n        n = n*10 +digit();\n    return n;\n}\n\nint term()\n{\n    int a = factor();\n    while(cur < S.size() && (peek() == '*' || peek() == '/')){\n        char op = readchar();\n        int b = factor();\n        if (op == '*') a *= b; else a /= b;\n    }\n    return a;\n}\n\nint expression(){\n    int a = term();\n    while(cur < S.size() && (peek() == '+' || peek() =='-'))\n    {\n        char op =readchar();\n        int b = term();\n        if(op == '+')\n        {\n            a += b;\n        }\n        else a -= b;\n    }\n    return a;\n}\nint factor() {\n    if (peek() != '(') return number();\n    cur += 1;\n    int n = expression();\n    assert(peek() == ')');\n    cur += 1;\n    return n;\n}\nint parse() {return expression();}"
  },
  {
    "language": "C++",
    "code": "//???2:negFLG?°???\\???\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\t/*\n\t * ????????????????????¬??§???)??????????????§???????????????????????????????????????\n\t * ??°?????????????????????????????????????????????????????????????????????????????????????¨?????????????????????????\n\t * )????????????????????????????????¬??§?????????????????§<<???????????§>>?¨??????????\n\t * ?????¨?????°???6-8+6 ????§£???4??§??????????????????????????????????????????????????¨6-(8+6)??§-8????????£????????????\n\t * ????????§?????°?????¨?????????????????????????????????????????´?????????????????§?¨??????????\t *\n\t */\n\n\tint n,tmp,op1,work,count;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\t//?????????-???????????????????????????WA??¨?????????????????§?????????\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){ //??°????????´???\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t\t}else{ //??°?????§????????´???\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){ //???????????????????????????????????????????????????????????????????¨???????????????????\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\t//?¬???????-??§????????´?????¨???????????????????????????????????§????????´???????????\\??????????????°????????????!!\n\n\t\t\t\t\tif(((k == 0) || line[k-1] == '(') && (line[k+1] >= '0' && line[k+1] <= '9')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else if(line[k+1] == '('){\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\t\t\t\t\t/*if(k == 0){\n\t\t\t\t\t\tif(line[k+1] != '('){\n\t\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(line[k-1] == '(' && line[k+1] == '('){\n\t\t\t\t\t\tNUM.push(-1);\n\t\t\t\t\t\tOP.push('*');\n\t\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}*/\n\t\t\t\t}else if(line[k] == ')'){ //????????????????????§???????????¬??§?????§????????????????????????????????????????????¨????????????????????§??¨???!!!! 8*(2+3)/4= ??????\n\n\t\t\t\t\t//????????£???:??????????????????????????????????????????????????¬??§?????§????????????????????¨??°???????????????????????????\n\t\t\t\t\twork = NUM.top(); //???????????°????????°???????????????????????°??????????????????1??????\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\t//????????¬??§?????°????????????????????????\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count == 0){ // 123*(-1)+122= ?????????????????????\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\t//??????????????????????????§?????????????????????\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//??????????????§work_num??¨work_op?????????empty????????£???????????????\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work); //?????????????????¬??¶????????????????????????\n\n\t\t\t\t}else{\t//line[k] == '=' ????????????????????§???????????¬??§?????§????????????????????????????????????????????¨????????????????????§??¨???!!!! 8*(2+3)/4= ??????\n\n\t\t\t\t\t//????????£???:??????????????????????????????????????????????????¬??§?????§????????????????????¨??°???????????????????????????\n\t\t\t\t\twork = NUM.top(); //???????????°????????°???????????????????????°??????????????????1??????\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\t//??????????????????????????§?????????????????????\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t//??????????????§work_num??¨work_op?????????empty????????£???????????????\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  char c = buf[pos];\n\n  if ('0' <= c && c <= '9') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  if (buf[pos] == '*') {\n    Pair q = EvalTerm(pos+1);\n    return Pair(p.first*q.first, q.second);\n  }\n\n  if (buf[pos] == '/') {\n    Pair q = EvalTerm(pos+1);\n    return Pair(p.first/q.first, q.second);\n  }\n\n  return p;\n}\n\nPair EvalExp(int pos) {\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n  int res = p.first;\n  if (buf[pos] == '=' || buf[pos] == ')') {\n    return Pair(res, pos);\n  }\n\n  Pair q = EvalExp(pos+1);\n  if (buf[pos] == '+') res += q.first;\n  else if (buf[pos] == '-') res -= q.first;\n  else assert(0);\n\n  return Pair(res, q.second);\n}\n\nint main() {\n  scanf(\"%d\", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <vector>\n\nnamespace {\n  \nint operate(char op, int arg1, int arg2)\n{\n  switch (op) {\n  case ')':\n  case '=': return arg1;\n  case '+': return arg1 + arg2;\n  case '-': return arg1 - arg2;\n  case '*': return arg1 * arg2;\n  case '/': assert(arg2 != 0); return arg1 / arg2;\n  }\n  assert(0);\n}\n\nint evaluate(std::string& str, size_t first, size_t last)\n{\n  size_t current = 0;\n  std::vector<int> arg;\n  std::vector<char> op;\n\n  arg.push_back(0);\n  \n  for (size_t pos = first; pos <= last; ) {\n  \t\n    // 数字\n    if (isdigit(str[pos])) {\n      arg[current] = (arg[current] * 10) + (str[pos] - '0');\n       ++pos;\n      continue;\n    }\n\n    // 括弧\n    if (str[pos] == '(') {\n      size_t paren_end = pos + 1;\n      int nest = 0;\n\n      // 括弧に対応する閉じ括弧の場所を検索\n      for (; paren_end <= last; ++paren_end) {\n        if (str[paren_end] == ')') {\n          if (!nest) break;\n          else --nest;\n        }\n        else if (str[paren_end] == '(') {\n          ++nest;\n        }\n      }\n\n      assert(paren_end != last + 1);\n      arg[current] = evaluate(str, pos + 1, paren_end);\n      pos = paren_end + 1;\n      continue;\n    }\n\n    // 演算子\n    op.push_back(char(str[pos]));\n    if (current == 0) {\n      ++current;\n      arg.push_back(0);\n      ++pos;\n      continue;\n    }\n\n    if (op[current - 1] == '*' || op[current - 1] == '/') {\n      arg[current - 1] = operate(op[current - 1], arg[current - 1], arg[current]);\n      op[current - 1] = op[current];\n      arg[current] = 0;\n      op.pop_back();\n    } \n    else {\n      ++current;\n      arg.push_back(0);\n    }\n    ++pos;\n  }\n  \n  // + -\n  \n  for (size_t i = 1; i < current; ++i) {\n  \targ[0] = operate(op[i - 1], arg[0], arg[i]);\n  }\n  \n  return arg[0];\n}\n\n} // unnamed namespace\n\nint main()\n{\n  int n;\n  std::cin >> n;\n  \n  for (int i = 0; i < n; ++i) {\n    std::string exp;\n    std::cin >> exp;\n\n    std::cout << evaluate(exp, 0, exp.size()) << std::endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint p;\n\nint exp();\nint factor();\nint term();\n\nint factor() {\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n\n  //  cout <<\"one\"<< num << endl;\n  if(num != 0) return num;\n\n  else if (str[p] == '('){\n    p++;\n    num = exp();\n  }\n  if(str[p] == ')'){\n    // cout <<\"two\"<< num << endl;\n    p++;\n    return num;\n  } \n  return 0;\n}\n\nint term(){\n int val = factor();\n  while(str[p] == '*' || str[p] == '/') {\n    if(str[p] == '*') {\n      p++;\n      val *= factor();\n    } else if(str[p] == '/'){\n      p++;\n      val /= factor();\n    }\n  }\n\n  return val;\n}\n \nint exp() {\n  int val = term();\n  while(str[p] == '+' || str[p] == '-') {\n    if(str[p] == '+') {\n      p++;\n      val += term();\n    } else if(str[p] == '-'){\n      p++;\n      val -= term();\n    }\n  }\n\n  return val;\n}\n\nint main() {\n  int n;\n\n  cin >> n;\n  \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nint expression(State&);\nint term(State&);\nint factor(State&);\nint number(State&);\n\nint expression(State &begin){\n\tint ret = term(begin);\n\twhile (1){\n\t\tif (*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}else if (*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\twhile (1){\n\t\tif (*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if (*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif (*begin == '('){\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint number(State &begin){\n\tint ret = 0;\n\twhile (isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\twhile (n--){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\t//std::cin>>s;\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\t//consume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tint ret;\n\tif(*begin == '('){\n\t\t//consume(begin,'(');\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\t//consume(begin,')');\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<string>\n#include<cctype>\nusing namespace std;\n\nconst string S = \"(1+((12+2)*3-5)/37)*2-4\";\nsize_t cur = 0;\nint parse();\nint digit();\nint number();\nint expression();\nint term();\nint factor();\n\nint main() {\n\tint a = parse();\n\tassert(cur == S.size());\n\tcout << a << endl;\n\treturn 0;\n}\n\nint digit() {\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur++;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur]))\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint expression() {\n\tint a = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif (op == '+') a += b;\n\t\telse a -= b;\n\t}\n\treturn a;\n\n}\n\nint parse() {\n\treturn expression();\n}\n\nint term() {\n\tint a = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif (op == '*') a *= b;\n\t\telse a /= b;\n\t}\n\treturn a;\n}\n\nint factor() {\n\tif (S[cur] != '(') return number();\n\tcur++;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur++;\n\treturn n;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint p;\nstring exp;\n\nint term();\nint expression();\nint factor();\n\n\nint expression(){\n     int value;\n\t value=term();\n\t while(exp[p]=='+' || exp[p]=='-'){\n\t\t if(exp[p]=='+'){\n\t\t\t p++;\n\t\t\t value+=term();\n\t\t }\n\t\t else{\n\t\t\t p++;\n\t\t\t value-=term();\n\t\t }\n\t }\n\t return value;\n}\n\n\nint term(){\n\tint value;\n\tvalue=factor();\n\twhile(exp[p]=='*' || exp[p]=='/'){\n\t\tif(exp[p]=='*'){\n\t\t\tp++;\n\t\t\tvalue*=factor();\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\tvalue/=factor();\n\t\t}\n\t}\n\n\treturn value;\n}\n\nint factor(){\n\tint value=0;\n\tif(exp[p]=='('){\n\t\tvalue=expression();\n\t\tp++;\n\t}\n\telse{\n\t\twhile(isdigit(exp[p])){\n\t\t\tvalue=value*10+exp[p++]-'0';\n\t\t}\n\t}\n\treturn value;\n}\n\n\n\nint main()\n{\n\tint i,c;\n\tcin>>c;\n\tfor(i=0;i<c;i++){\n\t\tcin>>exp;\n\t\tp=0;\n\t\tcout<<expression()<<\"\\n\";\n\t\t}\n\tcout<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\n\t\t\t\t\tif(line[k-1] >= '0' && line[k-1] <= '9'){\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}else if(line[k-1] == ')'){\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << number(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype> // isdigit\n#include<cassert> // assert\nusing namespace std;\n\nstruct Result{int value,pos;};\n\nint calculate(string expression);\nResult equation(string expression,int pos);\nResult factor(string expression,int pos);\nResult term(string expression,int pos);\n\nint calculate(string expression)\n{\n  return equation(expression,0).value;\n}\n\nResult equation(string expression,int pos)\n{\n  Result r=factor(expression,pos);\n  // Á¸Z\n  while(expression[r.pos]=='+' || expression[r.pos]=='-'){\n    Result _r=factor(expression,r.pos+1);\n    if(expression[r.pos]=='+')r.value += _r.value;\n    if(expression[r.pos]=='-')r.value -= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult factor(string expression,int pos)\n{\n  Result r=term(expression,pos);\n  // æZ\n  while(expression[r.pos]=='*' || expression[r.pos]=='/'){\n    Result _r=term(expression,r.pos+1);\n    if(expression[r.pos]=='*')r.value *= _r.value;\n    if(expression[r.pos]=='/')r.value /= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult term(string expression,int pos)\n{\n  Result r;\n  // l\n  if(isdigit(expression[pos])){\n    int value=0;\n    while(isdigit(expression[pos]))value = value*10 + expression[pos++]-'0';\n    r.value=value;\n    r.pos=pos;\n    return r;\n  }\n  // PZqÌ}CiX\n  if(expression[pos]=='-'){\n    r=equation(expression,pos+1);\n    r.value*=-1;\n    return r;\n  }\n  // Ê\n  if(expression[pos]=='('){\n    r=equation(expression,pos+1);\n    assert(expression[r.pos++]==')');\n    return r;\n  }\n}\n\nint main()\n{\n  int n;\n  string s;\n  cin>>n;\n  while(n-->0){\n    cin>>s;\n    s=s.substr(0,s.size()-1);\n    cout<<calculate(s)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nstring mozi\n;\nint koko\n;\n// mae ni tukutta raiburari *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\nint koubunnkaiseki();\nint koubunnkaiseki2();\nint koubunnkaiseki3();\n\nint koubunnkaiseki3()\n{\n  int atai;\n  if( mozi[koko] == '(' ) \n    {\n      koko = koko + 1;\n      atai = koubunnkaiseki();\n      koko = koko + 1;\n    }\n  else\n    {\n      atai = 0;\n      while( koko < mozi.size() && '0' <= mozi[koko] && mozi[koko] <= '9' )\n\t{\n\t  atai = atai * 10;\n\t  atai = atai + ( mozi[koko] - '0' );\n\t  koko = koko + 1;\n\t}\n    }\n  return atai;\n}\n\nint koubunnkaiseki2()\n{\n  int atai = koubunnkaiseki3();\n  for(;mozi[koko]=='*'||mozi[koko]=='/';)\n    {\n      if( mozi[koko] == '*' )\n\t{\n\t  koko = koko + 1;\n\t  atai = atai * koubunnkaiseki3();\n\t}\n      else\n\t{\n\t  koko = koko + 1;\n\t  atai = atai / koubunnkaiseki3();\n\t}\n    }\n  return atai;\n}\n\nint koubunnkaiseki()\n{\n  int atai = koubunnkaiseki2();\n  for(;mozi[koko]=='+'||mozi[koko]=='-';)\n    {\n      if( mozi[koko] == '+' ) \n\t{\n\t  koko = koko + 1;\n\t  atai = atai + koubunnkaiseki2();\n\t}\n      else \n\t{\n\t  koko = koko + 1;\n\t  atai = atai - koubunnkaiseki2();\n\t}\n    }\n  return atai;\n}\n\nint main(int argc,char *argv) \n{\n  int dataset;\n  cin >> dataset;\n  for(int kaisuu=0;kaisuu<dataset;kaisuu++)\n    {\n      cin >> mozi;\n      koko = 0;\n      cout << koubunnkaiseki() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype> // for isdigit\n#include <string>\nusing namespace std;\n// ?§?????§£??????????????°????????§?????¢??°???????????????????????£?¨????????????¨\nint exp(string s, int &i);\nint term(string s, int &i);\nint factor(string s, int &i);\nint number(string s, int &i);\nint exp(string s, int &i)\n{\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-'){ // 0 ?????\\?????°?????????????????¨???????????????\n    char op = s[i];\n    i++;\n    int val2 = term(s, i);\n    if(op == '+') val += val2;\n    else val -= val2;\n  }\n  return val;\n}\nint term(string s, int &i)\n{\n  int val = factor(s, i);\n  while(s[i] == '*' || s[i] == '/'){ // 0 ?????\\?????°?????????????????¨???????????????\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if(op == '*') val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\nint factor(string s, int &i)\n{\n  // ??????????????????????????°????????´???\n  // isdigit ?????¢??????????????\\????¬????????????????????????§???????????¨\n  if(isdigit(s[i]))\n    return number(s, i);\n  // ??°?????§???????????´??????????????§?§?????????£???????????°???????????????'(' ??¨??????\n  i++; // '(' ??????????£???°???\n  int val = exp(s, i);\n  i++; // ')' ??????????£???°???\n  return val;\n}\nint number(string s, int &i)\n{\n  // ??°??????1 ????????¨???\n  int n = s[i] - '0';\n  i++;\n  // ??°??????2 ?????\\????????¨???\n  while(isdigit(s[i])){\n    n = n * 10 + (s[i] - '0');\n    i++;\n  }\n  return n;\n}\nint main()\n{\n  int n;\n  cin >> n;\n  for(int j = 0; j < n; ++j){\n    string s;\n    cin >> s;\n    int i = 0;\n    cout << exp(s, i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring s;\nint N;\nint c;\n\nint expr();\nint term();\nint factor();\nint num();\n\nvoid debug(string text){\n\treturn;\n\tcout << text + \" \";\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == c) cout << '[' << s[i] << ']';\n\t\telse cout << s[i];\n\t}\n\tcout << endl;\n}\n\nint expr(){\n\tdebug(\"expr\");\n\tint x = term();\n\twhile(c < N){\n\t\tif(s[c] == '+'){\n\t\t\tc++;\n\t\t\tx += term();\n\t\t}\n\t\telse if(s[c] == '-'){\n\t\t\tc++;\n\t\t\tx -= term();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nint term(){\n\tdebug(\"term\");\n\tint x = factor();\n\twhile(c < N){\n\t\tif(s[c] == '*'){\n\t\t\tc++;\n\t\t\tx *= factor();\n\t\t}\n\t\telse if(s[c] == '/'){\n\t\t\tc++;\n\t\t\tx /= factor();\n\t\t}\n\t\telse break;\n\t}\n\treturn x;\n}\n\nint factor(){\n\tdebug(\"factor\");\n\tif(s[c] == '('){\n\t\tc++;\n\t\tint ret = expr();\n\t\tassert(s[c] == ')');\n\t\tc++;\n\t\treturn ret;\n\t}\n\treturn num();\n}\n\nint num(){\n\tdebug(\"num\");\n\tint ret = 0;\n\twhile(c < N && isdigit(s[c])){\n\t\tret = ret * 10 + s[c] - '0';\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tN = s.size();\n\t\tc = 0;\n\t\tcout << expr() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State&);\nint number(State&);\nint factor(State&);\nint term(State&);\n\nint expression(State &begin){\n  //cout <<\"expression\"<<endl;\n  int ret = term(begin);\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      ret += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  //cout <<\"term\"<<endl;\n  int ret = factor(begin);\n  \n  while(1){\n    if(*begin == '*'){\n      begin++;\n      ret *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      ret /= factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint number(State &begin){\n  //cout <<\"number\"<<endl;\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  //cout <<\"factor\"<<endl;\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++; // ')' をスキップ\n    return ret;\n  }\n\n  if(*begin == '-'){\n    begin++;\n    return -factor(begin);\n  }\n  return number(begin);\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\n/*void consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n\t << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n    throw ParseError();\n    }\n    }*/\n\nint main(){\n  int n;\n  cin >> n;\n  cin.ignore();\n  for(int i = 0 ; i < n ; i++){\n    string s;\n    getline(cin, s);\n    //cout << s << endl;\n    State begin = s.begin();\n    int ans = expression(begin);\n    //consume(begin, '=');\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long Int;\ntypedef string::const_iterator Iter;\n\nInt eval(const string&);\nInt expr(Iter&);\nInt term(Iter&);\nInt factor(Iter&);\nInt number(Iter&);\n\nInt eval(const string &s){\n\tIter it = s.begin();\n\treturn expr(it);\n}\n\nInt expr(Iter &it){\n\tInt res = term(it);\n\twhile (true){\n\t\tif (*it == '+'){\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t}\n\t\telse if (*it == '-'){\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt term(Iter &it){\n\tInt res = factor(it);\n\twhile (true){\n\t\tif (*it == '*'){\n\t\t\t++it;\n\t\t\tres *= term(it);\n\t\t}\n\t\telse if (*it == '/'){\n\t\t\t++it;\n\t\t\tres /= term(it);\n\t\t}\n\t\telse return res;\n\t}\n}\n\nInt factor(Iter &it){\n\tif (*it == '('){\n\t\t++it;\n\t\tInt res = expr(it);\n\t\t++it;\n\t\treturn res;\n\t}\n\telse return number(it);\n}\n\nInt number(Iter &it){\n\tInt res = 0;\n\twhile (isdigit(*it)){\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\ts.resize(s.size() - 1);\n\t\tcout << eval(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n\n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    int ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=number(begin);\n\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\nreturn ret;\n}\nif(*begin=='-'){\nbegin++;\nreturn -factor(begin);\n}\nreturn number(begin);\n}\n\nint number(State &begin){\n  int ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ntemplate <class _Tt>\nclass calculate {\npublic:\n    enum op {NUM,ADD,SUB,MUL,DIV,LPA,RPA};\nprivate:\n    typedef pair<op, _Tt> pt; \n    deque<pt> mq;\n    void popf(deque<pt> &q, op &type, _Tt &num){\n        type = q.front().first; num = q.front().second;\n        q.pop_front();\n    }\n    void popb(deque<pt> &q, op &type, _Tt &num){\n        type = q.back().first; num = q.back().second;\n        q.pop_back();\n    }\n    _Tt cal2(deque<pt> &q){\n        op sop, qop, dop; _Tt snum, dnum;\n        popf(q, sop, snum); dbgchk(sop != 0);\n        while(!q.empty()){\n            popf(q, qop, dnum); dbgchk(qop != 1 && qop != 2);\n            popf(q, dop, dnum); dbgchk(dop != 0);\n            snum = (qop == 1) ? snum+dnum : snum-dnum;\n        }\n        return snum;\n    }\n    _Tt cal(deque<pt> &q){\n        deque<pt> s;\n        while(!q.empty()){\n            op qop; _Tt num;\n            popf(q, qop, num);\n            switch(qop){\n            case NUM: case ADD: case SUB:\n                s.pb(mp(qop,num)); break;\n            case LPA:\n                s.pb(mp(NUM,cal(q))); break;\n            case RPA:\n                return cal2(s); break;\n            case MUL: case DIV:\n                op sop, dop; _Tt snum, dnum;\n                popb(s, sop, snum); dbgchk(sop != 0);\n                popf(q, dop, dnum); dbgchk(dop != NUM && dop != LPA);\n                if(dop == LPA) dnum = cal(q);\n                _Tt r = (qop == MUL) ? snum*dnum : snum/dnum;\n                s.pb(mp(NUM,r));\n                break;\n            }\n        }\n        return cal2(s);\n    }\npublic:\n    void add(_Tt n){ mq.pb(mp(NUM,n)); }\n    void add(op opr){ mq.pb(mp(opr,0)); }\n    _Tt result(){ return cal(mq); }\n};\n\nvoid solve(string s){\n    int n = s.length();\n    calculate<int> calc;\n    REP(i,n){\n        if(isdigit(s[i])){\n            calc.add(atoi(s.c_str()+i));\n            continue;\n        }\n        if(s[i] == '=') break;\n        switch(s[i]){\n        case '+': calc.add(calc.ADD); break;\n        case '-': calc.add(calc.SUB); break;\n        case '*': calc.add(calc.MUL); break;\n        case '/': calc.add(calc.DIV); break;\n        case '(': calc.add(calc.LPA); break;\n        case ')': calc.add(calc.RPA); break;\n        }\n    }\n    cout << calc.result() << endl;\n}\n\nint main(){\n    int n;\n    string s; getline(cin, s);\n    istringstream ss(s); ss >> n;\n    REP(i,n){\n        getline(cin, s);\n        solve(s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\nint expression(State &begin){\n\tint ret=term(begin);\n\twhile(true){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nint term(State &begin){\n\tint ret=factor(begin);\n\twhile(true){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret/=factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+= (*begin) -'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tint ret=expression(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tState begin=s.begin();\n\t\tint ans=expression(begin);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    cout << number(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing State = string::const_iterator;\n             \nint expression(State& s);\n\nint number(State& s)\n{\n\tint res = 0;\n\twhile (isdigit(*s)) {\n\t\tres *= 10;\n\t\tres += *s - '0';\n\t\ts++;\n\t}\n\treturn res;\n}\n\nint factor(State& s)\n{\n\tif (*s == '(') {\n\t\ts++;\n\t\tint res = expression(s);\n\t\ts++;\n\t\treturn res;\n\t} else {\n\t\treturn number(s);\n\t}\n}\n\nint term(State& s)\n{\n\tint res = factor(s);\n\twhile (true) {\n\t\tif (*s == '*') {\n\t\t\ts++;\n\t\t\tres *= factor(s);\n\t\t} else if (*s == '/') {\n\t\t\ts++;\n\t\t\tres /= factor(s);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint expression(State& s)\n{\n\tint res = term(s);\n\twhile (true) {\n\t\tif (*s == '+') {\n\t\t\ts++;\n\t\t\tres += term(s);\n\t\t} else if (*s == '-') {\n\t\t\ts++;\n\t\t\tres -= term(s);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n    int q;\n    cin >> q;\n    while (q--) {\n        string st;\n        cin >> st;\n\t\tState s = st.begin();\n        cout << expression(s) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#ifndef HELLO_HPP_\n#define HELLO_HPP_\n\n// This file was automatically generated by Caper.\n// (http://jonigata.github.io/caper/caper.html)\n\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n\nnamespace calc {\n\nenum Token {\n token_eof,\n token_Add,\n token_Digit,\n token_Div,\n token_LBranket,\n token_Mul,\n token_RBranket,\n token_Sub,\n};\n\ninline const char* token_label(Token t) {\n static const char* labels[] = {\n \"token_eof\",\n \"token_Add\",\n \"token_Digit\",\n \"token_Div\",\n \"token_LBranket\",\n \"token_Mul\",\n \"token_RBranket\",\n \"token_Sub\",\n };\n return labels[t];\n}\n\ntemplate <class T, unsigned int StackSize>\nclass Stack {\npublic:\n Stack() { gap_ = 0; }\n\n void rollback_tmp() {\n gap_ = stack_.size();\n tmp_.clear();\n }\n\n void commit_tmp() {\n // may throw\n stack_.reserve(gap_ + tmp_.size());\n \n // expect not to throw\n stack_.erase(stack_.begin()+ gap_, stack_.end());\n stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());\n tmp_.clear();\n }\n bool push(const T& f) {\n if (StackSize != 0 &&\n int(StackSize) <= int(stack_.size() + tmp_.size())) {\n return false;\n }\n tmp_.push_back(f);\n return true;\n }\n \n void pop(size_t n) {\n if (tmp_.size() < n) {\n n -= tmp_.size();\n tmp_.clear();\n gap_ -= n;\n } else {\n tmp_.erase(tmp_.end() - n, tmp_.end());\n }\n }\n\n T& top() {\n assert(0 < depth());\n if (!tmp_.empty()) {\n return tmp_.back();\n } else {\n return stack_[gap_ - 1];\n }\n }\n \n const T& get_arg(size_t base, size_t index) {\n size_t n = tmp_.size();\n if (base - index <= n) {\n return tmp_[n - (base - index)];\n } else {\n return stack_[gap_ - (base - n) + index];\n }\n }\n \n void clear() {\n stack_.clear();\n tmp_.clear();\n gap_ = 0; \n }\n \n bool empty() const {\n if (!tmp_.empty()) {\n return false;\n } else {\n return gap_ == 0;\n }\n }\n \n size_t depth() const {\n return gap_ + tmp_.size();\n }\n \n T& nth(size_t index) {\n if (gap_ <= index) {\n return tmp_[index - gap_];\n } else {\n return stack_[index];\n }\n }\n\n void swap_top_and_second() {\n int d = depth();\n assert(2 <= d);\n T x = nth(d - 1);\n nth(d - 1) = nth(d - 2);\n nth(d - 2) = x;\n }\n\nprivate:\n std::vector<T> stack_;\n std::vector<T> tmp_;\n size_t gap_;\n \n};\n\ntemplate <class _Value, class _SemanticAction,\n unsigned int _StackSize = 0>\nclass Parser {\npublic:\n typedef Token token_type;\n typedef _Value value_type;\n\n enum Nonterminal {\n Nonterminal_Expr,\n Nonterminal_Factor,\n Nonterminal_Number,\n Nonterminal_Term,\n };\n\npublic:\n Parser(_SemanticAction& sa) : sa_(sa) { reset(); }\n\n void reset() {\n error_ = false;\n accepted_ = false;\n clear_stack();\n rollback_tmp_stack();\n if (push_stack(0, value_type())) {\n commit_tmp_stack();\n } else {\n sa_.stack_overflow();\n error_ = true;\n }\n }\n\n bool post(token_type token, const value_type& value) {\n rollback_tmp_stack();\n error_ = false;\n while ((this->*(stack_top()->entry->state))(token, value))\n ; // may throw\n if (!error_) {\n commit_tmp_stack();\n } else {\n recover(token, value);\n }\n return accepted_ || error_;\n }\n\n bool accept(value_type& v) {\n assert(accepted_);\n if (error_) { return false; }\n v = accepted_value_;\n return true;\n }\n\n bool error() { return error_; }\n\nprivate:\n typedef Parser<_Value, _SemanticAction, _StackSize> self_type;\n\n typedef bool (self_type::*state_type)(token_type, const value_type&);\n typedef int (self_type::*gotof_type)(Nonterminal);\n\n bool accepted_;\n bool error_;\n value_type accepted_value_;\n _SemanticAction& sa_;\n\n struct table_entry {\n state_type state;\n gotof_type gotof;\n bool handle_error;\n };\n\n struct stack_frame {\n const table_entry* entry;\n value_type value;\n int sequence_length;\n\n stack_frame(const table_entry* e, const value_type& v, int sl)\n : entry(e), value(v), sequence_length(sl) {}\n };\n\n Stack<stack_frame, _StackSize> stack_;\n\n bool push_stack(int state_index, const value_type& v, int sl = 0) {\n bool f = stack_.push(stack_frame(entry(state_index), v, sl));\n assert(!error_);\n if (!f) { \n error_ = true;\n sa_.stack_overflow();\n }\n return f;\n }\n\n void pop_stack(size_t n) {\n stack_.pop(n);\n }\n\n stack_frame* stack_top() {\n return &stack_.top();\n }\n\n const value_type& get_arg(size_t base, size_t index) {\n return stack_.get_arg(base, index).value;\n }\n\n void clear_stack() {\n stack_.clear();\n }\n\n void rollback_tmp_stack() {\n stack_.rollback_tmp();\n }\n\n void commit_tmp_stack() {\n stack_.commit_tmp();\n }\n\n void recover(token_type, const value_type&) {\n }\n\n bool call_nothing(Nonterminal nonterminal, int base) {\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, value_type());\n }\n\n bool call_0_Identity(Nonterminal nonterminal, int base, int arg_index0) {\n int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n int r = sa_.Identity(arg0);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_Combine(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n int r = sa_.Combine(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeAdd(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n int r = sa_.MakeAdd(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeSub(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n int r = sa_.MakeSub(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeDiv(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n int r = sa_.MakeDiv(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeMul(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n int arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n int arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n int r = sa_.MakeMul(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool state_0(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 16, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 2, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_0(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Expr: return 1;\n case Nonterminal_Term: return 3;\n case Nonterminal_Factor: return 9;\n case Nonterminal_Number: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_1(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n // accept\n accepted_ = true;\n accepted_value_ = get_arg(1, 0);\n return false;\n case token_Add:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Sub:\n // shift\n push_stack(/*state*/ 7, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_1(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_2(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 16, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 2, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_2(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Expr: return 4;\n case Nonterminal_Term: return 3;\n case Nonterminal_Factor: return 9;\n case Nonterminal_Number: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_3(token_type token, const value_type& value) {\n switch(token) {\n case token_Div:\n // shift\n push_stack(/*state*/ 12, value);\n return false;\n case token_Mul:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_eof:\n case token_Add:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_Identity(Nonterminal_Expr, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_3(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_4(token_type token, const value_type& value) {\n switch(token) {\n case token_Add:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_RBranket:\n // shift\n push_stack(/*state*/ 15, value);\n return false;\n case token_Sub:\n // shift\n push_stack(/*state*/ 7, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_4(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_5(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 16, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 2, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_5(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Term: return 6;\n case Nonterminal_Factor: return 9;\n case Nonterminal_Number: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_6(token_type token, const value_type& value) {\n switch(token) {\n case token_Div:\n // shift\n push_stack(/*state*/ 12, value);\n return false;\n case token_Mul:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_eof:\n case token_Add:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_MakeAdd(Nonterminal_Expr, /*pop*/ 3, 0, 2);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_6(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_7(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 16, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 2, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_7(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Term: return 8;\n case Nonterminal_Factor: return 9;\n case Nonterminal_Number: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_8(token_type token, const value_type& value) {\n switch(token) {\n case token_Div:\n // shift\n push_stack(/*state*/ 12, value);\n return false;\n case token_Mul:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_eof:\n case token_Add:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_MakeSub(Nonterminal_Expr, /*pop*/ 3, 0, 2);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_8(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_9(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_Identity(Nonterminal_Term, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_9(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_10(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 16, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 2, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_10(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Factor: return 11;\n case Nonterminal_Number: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_11(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_MakeMul(Nonterminal_Term, /*pop*/ 3, 0, 2);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_11(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_12(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 16, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 2, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_12(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Factor: return 13;\n case Nonterminal_Number: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_13(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_MakeDiv(Nonterminal_Term, /*pop*/ 3, 0, 2);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_13(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_14(token_type token, const value_type& value) {\n switch(token) {\n case token_Digit:\n // shift\n push_stack(/*state*/ 17, value);\n return false;\n case token_eof:\n case token_Add:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_Identity(Nonterminal_Factor, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_14(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_15(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_Identity(Nonterminal_Factor, /*pop*/ 3, 1);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_15(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_16(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_Digit:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_Identity(Nonterminal_Number, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_16(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_17(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_Digit:\n case token_Div:\n case token_Mul:\n case token_RBranket:\n case token_Sub:\n // reduce\n return call_0_Combine(Nonterminal_Number, /*pop*/ 2, 0, 1);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_17(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n const table_entry* entry(int n) const {\n static const table_entry entries[] = {\n { &Parser::state_0, &Parser::gotof_0, false },\n { &Parser::state_1, &Parser::gotof_1, false },\n { &Parser::state_2, &Parser::gotof_2, false },\n { &Parser::state_3, &Parser::gotof_3, false },\n { &Parser::state_4, &Parser::gotof_4, false },\n { &Parser::state_5, &Parser::gotof_5, false },\n { &Parser::state_6, &Parser::gotof_6, false },\n { &Parser::state_7, &Parser::gotof_7, false },\n { &Parser::state_8, &Parser::gotof_8, false },\n { &Parser::state_9, &Parser::gotof_9, false },\n { &Parser::state_10, &Parser::gotof_10, false },\n { &Parser::state_11, &Parser::gotof_11, false },\n { &Parser::state_12, &Parser::gotof_12, false },\n { &Parser::state_13, &Parser::gotof_13, false },\n { &Parser::state_14, &Parser::gotof_14, false },\n { &Parser::state_15, &Parser::gotof_15, false },\n { &Parser::state_16, &Parser::gotof_16, false },\n { &Parser::state_17, &Parser::gotof_17, false },\n };\n return &entries[n];\n }\n\n};\n\n} // namespace calc\n\n#endif // #ifndef HELLO_HPP_\n\n\n\nclass unexpected_char : public std::exception {};\n\nclass scanner {\npublic:\n using char_type = char;\n\nprivate:\n string s;\n int pos;\npublic:\n scanner(string s) : s(s), pos(0) {}\n\n calc::Token get(int& v) {\n char c;\n do {\n c = getc();\n } while (isspace(c));\n // ?¨???????\n switch( c ) {\n case '+': return calc::token_Add;\n case '-': return calc::token_Sub;\n case '*': return calc::token_Mul;\n case '/': return calc::token_Div;\n case '(': return calc::token_LBranket;\n case ')': return calc::token_RBranket;\n case '=': return calc::token_eof;\n }\n\n // ??´??°\n if( isdigit( c ) ) {\n v = c - '0';\n return calc::token_Digit;\n }\n\n cerr << c << endl;\n throw unexpected_char();\n }\n\nprivate:\n char_type getc() {\n if (pos == s.size()) return EOF;\n return s[pos++];\n }\n};\n\nstruct SemanticAction {\n void syntax_error(){}\n void stack_overflow(){}\n void downcast( int& x, int y ) { x = y; }\n void upcast( int& x, int y ) { x = y; }\n\n int Identity( int n ) { return n; }\n int Combine(int x, int y) {\n return x*10 + y;\n }\n int MakeAdd(int x, int y) {\n// cerr << \"expr \" << x << \" + \" << y << endl;\n return x + y; \n }\n int MakeSub(int x, int y) {\n// cerr << \"expr \" << x << \" - \" << y << endl;\n return x - y; \n }\n int MakeMul(int x, int y) {\n// cerr << \"expr \" << x << \" * \" << y << endl;\n return x * y;\n }\n int MakeDiv(int x, int y) {\n// cerr << \"expr \" << x << \" / \" << y << endl;\n return x / y;\n }\n};\n\nint main() {\n int n;\n cin >> n; cin.ignore();\n for (int i = 0; i < n; i++) {\n string s;\n getline(cin, s);\n scanner scn(s);\n SemanticAction sa;\n calc::Parser<int, SemanticAction> parser(sa);\n calc::Token token;\n while (true) {\n int v;\n token = scn.get(v);\n if (parser.post(token, v)) { break; }\n }\n int v;\n if (parser.accept(v)) {\n cout << v << endl;\n }\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n#include <stack>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \nint cal(){\n  stack<int> st;\n  int ope=0;\n  int num;\n  while(true){\n    char c = getchar();\n    if(c == '(' || ('0'<=c && c<= '9') ) {\n      if(c == '(') num = cal();\n      else{\n        int dig=0;\n        int numd[10]={0};\n        numd[0] = (c - '0');\n        while(true){\n          c = getchar();\n          if(!('0'<=c&&c<='9')) break;\n          dig++;\n          numd[dig] = (c - '0');\n        }\n        num = 0;\n        for(int i=dig; i>=0; i--)\n          num+=numd[dig-i] * pow(10,(double)i);\n      }\n      if(ope==0){\n        st.push(num);\n      }else if(ope == 1){\n        st.push(-num);\n        ope = 0;\n      }else if(ope == 2){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp * num);\n        ope = 0;\n      }else if(ope == 3){\n        int tmp = st.top();\n        st.pop();\n        st.push(tmp / num);\n        ope = 0;\n      }\n    }\n    if(c == ')' ) break;\n    if(c == '=' ){\n      getchar();\n      break;\n    }\n    if(c == '+') ope = 0;\n    if(c == '-') ope = 1;\n    if(c == '*') ope = 2;\n    if(c == '/') ope = 3;\n  }\n  int sum=0;\n  while(!st.empty()){\n    sum += st.top();\n    st.pop();\n  }\n  return sum;\n}\n\nint main(void){  \n  int n;\n  cin >> n;\n  getchar();\n  REP(i,n)\n    cout << cal() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin) {\n\tint ret = factor(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++; // '('テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\tint ret = expression(begin);\n\t\tbegin++; // ')'テ」ツつ津ゥツ」ツ崚」ツ?ーテ」ツ?凖」ツ??\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tState begin = s.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\n\t\treturn foo2(s.substr(0,xl)+foo1(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\t//std::getline(std::cin, s);\n\t\tstd::cin>>s;\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\t//consume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\t//consume(begin,'(');\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\t//consume(begin,')');\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint p;\nstring s;\nint number();\nint factor();\nint term();\n\nint expression(){\n    int num=term();\n    while(s.size()>p){\n        if(s[p]=='+'){\n            p++;\n            num+=term();\n        }else if(s[p]=='-'){\n            p++;\n            num-=term();\n        }else{\n            break;\n        }\n    }\n    return num;\n}\n\nint term(){\n    int num=factor();\n    while(s.size()>p){\n        if(s[p]=='*'){\n            p++;\n            num*=factor();\n        }else if(s[p]=='/'){\n            p++;\n            num/=factor();\n        }else{\n            break;\n        }\n    }\n    return num;\n}\n\nint factor(){\n    int num;\n    if(s.size()>p and s[p]=='('){\n        p++;\n        num=expression();\n        p++;\n    }else{\n        return number();\n    }\n    return num;\n}\n\nint number(){\n    int num=0;\n    while(s.size()>p and isdigit(s[p])){\n        num*=10;\n        num+=s[p]-'0';\n        p++;\n    }\n    return num;\n}\n\nint main(void){\n    int n,i;\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>s;\n        p=0;\n        cout<<expression()<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tret *= term(++begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tret /= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tret += term(++begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tret -= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tcout << expression(str.begin()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <valarray>\n#include <utility>\n#include <tuple>\n#include <cmath>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <cctype>\n\n#if (__cplusplus >= 201703L)\n#include <filesystem>\nnamespace fs = std::filesystem;\n#endif\n\n// boost\n//#define USE_BOOST_IN_CODE\n#ifdef USE_BOOST_IN_CODE\n#include <boost/range.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/strided.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/format.hpp>\n#endif\n\nnamespace {\n\n    using ll = long long;\n    using ull = unsigned long long;\n\n    //vector\n    template <class T>\n    using vec = std::vector<T>;\n\n    template <class T>\n    using vv = vec<vec<T>>;\n\n    constexpr std::size_t operator\"\"_sz(ull n) { return std::size_t (n); }\n        \n    template <class T, class BinaryOperation>\n    constexpr T fold(std::initializer_list<T> args, T init, BinaryOperation op)\n    {\n        return std::accumulate(args.begin(), args.end(), init, op);\n    }\n\n    // numeric_low\n    namespace numeric\n    {\n        template<typename T>\n        constexpr bool isOdd(T x)\n        {\n            return x % 2 != 0;\n        }\n\n        template<typename T>\n        constexpr bool isEven(T x)\n        {\n            return x % 2 == 0;\n        }\n\n        // 最大公約数\n        template<class T>\n        constexpr T gcd(const T x, const T y)\n        {\n            if (x < 0)return gcd(-x, y);\n            if (y < 0)return gcd(x, -y);\n            return (!y) ? x : gcd(y, x % y);\n        }\n\n        // 最小公倍数\n        template<class T>\n        constexpr T lcm(const T x, const T y)\n        {\n            if (x < 0)return lcm(-x, y);\n            if (y < 0)return lcm(x, -y);\n            return x * (y / gcd(x, y));\n        }\n\n        // 素数判定\n        template<class T>\n        constexpr bool isPrime(const T x)\n        {\n            if (x <= 1)return false;\n            for (T i = 2; i * i <= x; ++i)\n                if (x % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    // ビット演算\n    namespace bitOp\n    {\n\n        template <int N>\n        constexpr std::size_t distanceBetween(const std::bitset<N> bit, std::size_t current, bool isNext = true)\n        {\n            if (current > N || current < 0) \n                return -1;\n            const int dir = isNext ? 1 : -1;\n            for (auto i = current + dir; i >= 0 && i < N; i += dir)\n                if (bit[i]) \n                    return (i - current) * dir;\n            return -1;\n        }\n\n        // 次の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenNext(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, true);\n        }\n\n        // 前の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenPrev(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, false);\n        }\n    }\n\n\n#ifdef _MSVC_LANG\n#pragma region Vector\n#endif\n    ///////////////////////////////////////////////////////////\n    // Vector\n\n    template <class T>\n    struct Vec3D\n    {\n        T x, y, z;\n\n        Vec3D() = default;\n\n        constexpr Vec3D(T x, T y, T z)\n            : x {x}, y {y}, z {z}\n        {}\n\n        constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0)\n        {}\n\n        static constexpr T Dot(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n        }\n\n        static constexpr Vec3D Cross(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return {\n                lhs.y*rhs.z - lhs.z*rhs.y,\n                lhs.z*rhs.x - lhs.x*rhs.z,\n                lhs.x*rhs.y - lhs.y*rhs.x\n            };\n        }\n\n        constexpr T dot(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        constexpr Vec3D cross(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        T magnitude() const\n        {\n            return std::sqrt(sqrMagnitude());\n        }\n\n        constexpr T sqrMagnitude() const\n        {\n            return x * x + y * y + z * z;\n        }\n\n        Vec3D normalized() const\n        {\n            return *this / magnitude();\n        }\n\n        Vec3D normalize()\n        {\n            *this = normalized();\n            return *this;\n        }\n\n        constexpr bool isZero() const\n        {\n            return x == 0 && y == 0 && z == 0;\n        }\n\n        constexpr Vec3D operator+() const\n        {\n            return *this;\n        }\n\n        constexpr Vec3D operator-() const\n        {\n            return {-x, -y, -z};\n        }\n\n\n        constexpr Vec3D operator+(Vec3D rhs) const\n        {\n            return {x + rhs.x, y + rhs.y, z + rhs.z};\n        }\n\n        constexpr Vec3D operator-(Vec3D rhs) const\n        {\n            return {x - rhs.x, y - rhs.y, z - rhs.z};\n        }\n\n        template <class U>\n        constexpr Vec3D operator*(U rhs) const\n        {\n            return {x * rhs, y * rhs, z * rhs};\n        }\n\n        template <class U>\n        constexpr Vec3D operator/(U rhs) const\n        {\n            return {x / rhs, y / rhs, z / rhs};\n        }\n\n        constexpr Vec3D& operator+=(const Vec3D& other)\n        {\n            x += other.x;\n            y += other.y;\n            z += other.z;\n            return *this;\n        }\n\n        constexpr Vec3D& operator-=(const Vec3D& other)\n        {\n            x -= other.x;\n            y -= other.y;\n            z -= other.z;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator*=(U s)\n        {\n            x *= s;\n            y *= s;\n            z *= s;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator/=(U s)\n        {\n            x /= s;\n            y /= s;\n            z /= s;\n            return *this;\n        }\n\n    };\n\n    template<class T, class U>\n    inline constexpr Vec3D<T> operator*(U s, Vec3D<T> v)\n    {\n        return {s * v.x, s * v.y, s * v.z};\n    }\n\n    // Vector\n    ///////////////////////////////////////////////////////////\n#ifdef _MSVC_LANG\n#pragma endregion Vector\n#endif\n\n    // argsからハッシュ値を作成\n    template <class... Args>\n    std::size_t hash(Args... args)\n    {\n        return fold({static_cast<std::size_t>(args)...}, 0_sz,\n            [](std::size_t seed, std::size_t x)\n            {\n                // uses magic number from boost\n                return seed ^= x + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n            });\n    }\n\n    template <class Begin, class End>\n    void printAll(Begin beginIter, End endIter, std::string delimiter)\n    {\n        for (auto iter {beginIter}; iter != endIter; ++iter)\n        {\n            std::cout << *iter;\n            if (std::distance(iter, endIter) != 1)\n                std::cout << delimiter;\n        }\n    }\n\n    template <class Container>\n    void printAll(const Container& c, std::string delimiter)\n    {\n        printAll(std::cbegin(c), std::cend(c), delimiter);\n    }\n\n    template<class T>\n    void printAll(const std::initializer_list<T>& ini, std::string delimiter)\n    {\n        printAll(ini.begin(), ini.end(), delimiter);\n    }\n\n    //template <class Container>\n    //std::istream& operator>>(std::istream& is, Container& c)\n    //{\n    //    const auto end = std::end(c);\n    //    for (auto iter = std::begin(c); iter != end; ++iter)\n    //        is >> *iter;\n    //    return is;\n    //}\n\n    \n\n    using State = std::string::const_iterator;\n    class ParseError{};\n\n    int expression(State& begin);\n    int term(State& begin);\n    int number(State& begin);\n    int factor(State& begin);\n\n\n    // 四則演算の式をパースして、その評価結果を返す\n    int expression(State& begin)\n    {\n        int ret {term(begin)};\n\n        while (true)\n        {\n            if (*begin == '+')\n            {\n                ++begin;\n                ret += term(begin);\n            }\n            else if (*begin == '-')\n            {\n                ++begin;\n                ret -= term(begin);\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return ret;\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    int term(State &begin)\n    {\n        int ret {number(begin)};\n        while (true)\n        {\n\n            if (*begin == '*')\n            {\n                ++begin;\n                ret *= factor(begin);\n            }\n            else if (*begin == '/')\n            {\n                ++begin;\n                ret /= factor(begin);\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return ret;\n    }\n\n    // 数をパースして、数を返す。\n    int number(State& begin)\n    {\n        int ret {};\n        while (isdigit(*begin))\n        {\n            ret *= 10;\n            ret += *begin - '0';\n            ++begin;\n        }\n\n        return ret;\n    }\n\n    int factor(State& begin)\n    {\n        if (*begin == '(')\n        {\n            ++begin;\n            int ret = expression(begin);\n            ++begin;\n            return ret;\n        }\n        else\n        {\n            return number(begin);\n        }\n    }\n\n\n    void solve()\n    {\n        using namespace std;\n\n        int n;\n        cin >> n;\n        cin.ignore();\n\n        for (int i = 0; i < n; ++i)\n        {\n            string s;\n            getline(cin, s);\n            auto begin = s.cbegin();\n            cout << expression(begin) << endl;\n        }\n\n\n\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &begin);\n\nint term(State &begin);\n\nint factor(State &begin);\n\nint number(State &begin);\n\nvoid consume(State &begin,char expected);\n\nint main(){\n  int n;\n  cin>>n;\n  cin.ignore();\n  for(int i=0;i<n;i++){\n    string s;\n    getline(cin,s);\n\n    State begin = s.begin();\n    int ans=expression(begin);\n    consume(begin,'=');\n    cout<<ans<<endl;\n  }\n\n}\n\n\nint number(State &begin){\n  int ret = 0;\n\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  if(*begin =='('){\n    consume(begin,'(');\n    int ret = expression(begin);\n    consume(begin,')');\n    return ret;\n  }\n  else{\n    return number(begin);\n  }\n}\n\n\nint term(State &begin){\n  int ret = number(begin);\n\n  for(;;){\n    if(*begin =='*'){\n      consume(begin,'*');\n      ret *= factor(begin);\n    }\n    else if(*begin =='/'){\n      consume(begin,'/');\n      ret /= factor(begin);\n    }\n    else break;\n  }\n\n  return ret;\n}\n\n\nint expression(State &begin){\n  int ret = term(begin);\n\n  for(;;){\n    if(*begin =='+'){\n      consume(begin,'+');\n      ret += term(begin);\n    }\n    else if(*begin =='-'){\n      consume(begin,'-');\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\n\n\nvoid consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n      << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\n\nstring tranceRPN(string in_formula, string out_formula, stack<char> st){\n    \n    if(in_formula.size() == 0){\n        while(!st.empty()){\n            out_formula+=st.top();\n            st.pop();\n        }\n        //cout<<st.top()<<endl;;;\n        return out_formula;//処理終了\n    }\n    \n    char top = in_formula[0];\n    in_formula.erase(0,1);\n    //cout<<in_formula<<endl;\n    \n    if(top=='=')return tranceRPN(in_formula,out_formula,st);\n    \n    if(('0'<=top&&top<='9')||top==' ')out_formula+=top;\n    else if(top==')'){\n        while(1){\n            if(st.top()=='('){\n                st.pop();\n                break;\n            }\n            out_formula+=st.top();\n            st.pop();\n        }\n    }else if(top=='(')st.push(top);\n    else if(st.empty())st.push(top);\n    else if(((st.top()=='*'||st.top()=='/')&&(top=='+'||top=='-'))\n            ||((st.top()=='*'||st.top()=='/')&&(top=='*'||top=='/'))\n            ||((st.top()=='+'||st.top()=='-')&&(top=='+'||top=='-'))\n            ){\n        out_formula+=st.top();\n        st.pop();\n        in_formula=top+in_formula;\n    }else{\n        st.push(top);\n    }\n    return tranceRPN(in_formula,out_formula,st);\n    \n    \n}\n\nint RPN(string s){\n    int x=0;\n    stack<int> st;\n    bool flag=false;\n    while(1){\n        if(s.size()==0){\n            break;\n        }else if('0'<=s[0]&&s[0]<='9'){\n            x=x*10+s[0]-'0';\n            flag=true;\n            s.erase(0,1);\n        }else if(s[0]==' '&&flag){\n            flag=false;\n            st.push(x);\n            x=0;\n            s.erase(0,1);\n        }else if(s[0]=='+'){\n            s.erase(0,1);\n            int y,z;\n            y=st.top();\n            st.pop();\n            z=st.top();\n            st.pop();\n            st.push(y+z);\n        }else if(s[0]=='-'){\n            s.erase(0,1);\n            int y,z;\n            y=st.top();\n            st.pop();\n            z=st.top();\n            st.pop();\n            st.push(z-y);\n        }else if(s[0]=='*'){\n            s.erase(0,1);\n            int y,z;\n            y=st.top();\n            st.pop();\n            z=st.top();\n            st.pop();\n            st.push(y*z);\n        }else if(s[0]=='/'){\n            s.erase(0,1);\n            int y,z;\n            y=st.top();\n            st.pop();\n            z=st.top();\n            st.pop();\n            st.push(z/y);\n        }else{\n            s.erase(0,1);\n        }\n    }\n    return st.top();\n}\n/*\n(1+4)*(3+7)/5\n \n \n*/\n\nint main(){\n    \n    int n;\n    cin>>n;\n    for(int i=0; i<n; i++){\n        string s,rs;\n        stack<char> st;\n        cin>>s;\n        \n        for(int i=0; i<s.length(); i++){\n            if(s[i]=='+'||s[i]=='*'||s[i]=='-'||s[i]=='/'||s[i]==')'||s[i]=='('||s[i]=='=')s.insert(i++, \" \");\n        }\n        s+=\" \";\n        //cout<<s<<endl;\n        \n        rs=tranceRPN(s,rs,st);\n        //cout<<rs<<endl;\n        \n        cout<<RPN(rs)<<endl;\n    }\n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint expression();\nint term();\nint factor();\nint number();\n\nint now;\nstring s;\n\nint expression(){\n  int res=term();\n  while(true){\n    if(s[now]=='+'){\n      now++;\n      res+=term();\n    }else if(s[now]=='-'){\n      now++;\n      res-=term();\n    }else\n      break;\n  }\n  return res;\n}\n\nint term(){\n  int res=factor();\n  while(true){\n    if(s[now]=='(')\n      res+=factor();\n    else if(s[now]=='*'){\n      now++;\n      res*=factor();\n    }else if(s[now]=='/'){\n      now++;\n      res/=factor();\n    }else break;\n  }\n  return res;\n}\n\nint factor(){\n  int res=0;\n  if(s[now]=='('){\n    now++;\n    res=expression();\n    now++;\n  }else\n    return number();\n  return res;\n}\n\nint number(){\n  int res=0;\n  while('0'<=s[now] && s[now]<='9'){\n    res*=10;\n    res+=s[now++]-'0';\n  }\n  return res;\n}\n\n\nint main(void){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    now=0;\n    cout << expression() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n  //   #define int long long\n            #define mod  1000000009\n            #define pa pair<int,int>\n            #define ll long long\n            #define pal pair<double,int>\n            #define ppa pair<int,pa>\n            #define ssa pair<string,int>\n            #define  mp make_pair\n            #define  pb push_back\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     //priority_queue<int, vector<int>, greater<int> > que;\n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \nstring itos( int i ) {\nostringstream s ;\ns << i ;\nreturn s.str() ;\n}\n\nint gcd(int v,int b){\n\tif(v>b) return gcd(b,v);\n\tif(v==b) return b;\n\tif(b%v==0) return v;\n\treturn gcd(v,b%v);\n}\n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \ndouble distans(double x1,double y1,double x2,double y2){\n\tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n\treturn sqrt(rr);\n\t\n}\n            //----------------kokomade tenpure------------\nstring s;\nint kakko(string &t ,int &b);\n\nint suuji(string &t, int &b){\n\tint r=0;\n\tif(isdigit(t[b])){\n\twhile(isdigit(t[b])){\n\t\tr *=10;\n\t\tr += t[b]-'0';\n\t\t(b)++;\n\t}\n\t}\n\telse if(t[b]=='('){\n\t\n\t\tr=kakko(t,b);\n\t\t\n\t}\n\t\n\treturn r;\n}\n\n\nint kake(string &t, int &b){\n\t\n\t\tint i=suuji(t,b);\n\t//cout<<i<<endl;\n\t\twhile((t[b]=='*')||(t[b]=='/')){\n\t\t\tb++;\n\t\t\tif(t[b-1]=='*')i *= suuji(t,b);\n\t\t\telse i /= suuji(t,b);\n\t\t}\n\t\treturn i;\n\t\n}\n\nint tashi(string &t ,int &b){\n\n\t\tint i=kake(t,b);\n\t\twhile((t[b]=='+')||(t[b]=='-')){\n\t\tb++;\n\t\t\tif(t[b-1]=='+')\ti += kake(t,b);\n\t\t\telse i -= kake(t,b);\n\t\t}\n\t\treturn i;\n\t\n}\n\nint kakko(string &t ,int &b){\n\t\n\tif(t[b]=='('){\n\t\tint y;\n\t\tb++;\n\t\ty=tashi(t,b);\n//\t\tcout<<y<<endl;\n\t\tb++;\n\t\treturn y;\n\t}\n\telse{\n\t\treturn tashi(t,b);\n\t}\n}\n    signed  main(){\n    \tint n;\n    \tcin>>n;\n    \tfor(int g=0;g<n;g++){\ncin>>s;\n    \tint i=0;\n    \tcout<<tashi(s,i)<<endl;\n    \t}\n    \n  //  \tprintf(\"%.10f\\n\",ans[n-1]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF (1<<26)\nusing namespace std;\nint n;\n\n\n\nint compute(int a,int b,string str){\n  int i=a,sum=0,tmp=INF,tmp2=INF,cnt=0;\n  while(1){\n    sum=0;\n    if(str[i]=='('){\n      sum=compute(i+1,0,str);\n      for(i=a+1;i<(int)str.size();i++){\n\tif(str[i]==')')cnt--;\n\tif(str[i]=='(')cnt++;\n\tif(cnt<0)break;\n      }\n      i++;\n    }else{\n      while(1){\n\tif('0'<=str[i]&&str[i]<='9'){\n\t  sum*=10;\n\t  sum+=(str[i]-'0');\n\t  i++;\n\t}else{\n\t  break;\n\t}\n      }\n    }\n    \n    if(b==1){\n      sum*=-1;\n      b=0;\n    }\n    if(tmp!=INF){\n      sum*=tmp;\n      tmp=INF;\n    }\n    if(tmp2!=INF){\n      sum=tmp2/sum;\n      tmp2=INF;\n    }\n    \n    if(str[i]=='\\0'||str[i]==')'||str[i]=='=')return sum;\n    if(str[i]=='+')return sum + compute(i+1,0,str);\n    if(str[i]=='-')return sum + compute(i+1,1,str);\n    if(str[i]=='*'){\n      i++;\n      tmp=sum;\n    }else if(str[i]=='/'){\n      i++;\n      tmp2=sum;\n    }\n  }\n      \n}\n\n\nint main(){\n  string str;\n  cin>>n;\n  while(n--){\n    cin>>str;\n\n    //cout<<str<<endl;\n    cout<<compute(0,0,str)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n\nusing namespace std;\n\nint getPriority(char ch){\n  switch(ch){\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  default:\n    return -1;\n  }\n}\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else{\n\tchar cs = side[side.size()-1][0];\n\tif(cs != '+' && cs != '-' && cs != '*' && cs != '/'){\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n\telse{\n\t  if(getPriority(str[i]) < getPriority(cs)){\n\t    hand.push_back(side[side.size()-1]);\n\t    string tmp;\n\t    tmp += str[i];\n\t    side[side.size()-1] = tmp;\n\t  }\n\t  else{\n\t    string tmp;\n\t    tmp += str[i];\n\t    side.push_back(tmp);\n\t  }\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    string tmp;\n    hand.push_back(side[i]);\n  }\n  return hand;\n}\n\n\nlong long calc(vector<string> str){\n  stack<long long> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      long long val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  cin >> n;\n  \n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    cin >> str;\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  try {\n    for (;;) {\n      if (isdigit(s.peek()))\n      val *= 10;\n      val += s.peek() - '0';\n      s.next();\n    }\n  } catch (const std::string &) {}\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint pri(char ch) \n{\n    if (ch == '*' || ch == '/')\n        return 2;\n    if (ch == '+' || ch == '-')\n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    while (n--) {\n        string exp, cha;\n        stack<char> pol;\n        stack<int> cal;\n\n        cin >> exp;\n        for (int i = 0; i < exp.size() - 1; i++) {\n            if ('0' <= exp[i] && exp[i] <= '9') {\n                while (true) {\n                    cha.push_back(exp[i]);\n                    if ('0' > exp[i + 1] || exp[i + 1] > '9') {\n                        cha.push_back('.');\n                        break;\n                    }\n                    else\n                        i++;\n                }\n            }\n            else if (exp[i] == '(')\n                pol.push(exp[i]);\n            else if (exp[i] == ')') {\n                while (true) {\n                    if (pol.top() == '(') {\n                        pol.pop();\n                        break;\n                    }\n                    cha.push_back(pol.top());\n                    pol.pop();\n\n                }\n            }\n            else {\n                while (!pol.empty()) {\n                    if (pri(exp[i]) < pri(pol.top())) {\n                        cha.push_back(pol.top());\n                        pol.pop();\n                    }\n                    else \n                        break;\n                }\n                pol.push(exp[i]);\n            }\n        }\n\n        while (!pol.empty()) {\n            cha.push_back(pol.top());\n            pol.pop();\n        }\n\n        for (int i = 0; i < cha.size(); i++) {\n            if ('0' <= cha[i] && cha[i] <= '9') {\n                int tmp = cha[i] - '0';\n\n                while (true) {\n                    i++;\n                    if (cha[i] == '.') \n                        break;\n                    tmp *= 10;\n                    tmp += cha[i] - '0';\n                }\n                cal.push(tmp);\n            }\n            else {\n                int a, b;\n\n                b = cal.top();\n                cal.pop();\n                a = cal.top();\n                cal.pop();\n\n                if (cha[i] == '*') \n                    cal.push(a * b);\n                else if (cha[i] == '/') \n                    cal.push(a / b);\n                else if (cha[i] == '+') \n                    cal.push(a + b);\n                else if (cha[i] == '-') \n                    cal.push(a - b);\n            }\n        }\n        cout << cal.top() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define LOOP(i) while(i--)\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nint main(){\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\tint N=in();\n\tLOOP(N){\n\t\tstring S=in<string>();\n\t\tvector<string> TA;\n\t\tstack<int> IP;\n\t\tstack<string> SIP;\n\n\t\tint M=S.size();\n\t\tstring buf;\n\t\tS.insert(0,\"(\");\n\t\tS.insert(M,\")\");\n\t\tREP(i,M+1){\n\t\t\tchar ch=S[i];\n\t\t\tif(ch!='+' && ch!='-' && ch!='*' && ch!='/' && ch!='(' && ch!=')'){\n\t\t\t\tbuf.push_back(ch);\n\t\t\t}\n\t\t\telse if(ch!='('){\n\t\t\t\tif(!buf.empty()) TA.push_back(buf);\n\t\t\t\tbuf.clear();\n\t\t\t\tif(ch=='+' || ch=='-'){\n\t\t\t\t\twhile(!SIP.empty()){\n\t\t\t\t\t\tif(SIP.top()==\"(\"){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTA.push_back(SIP.top());\n\t\t\t\t\t\tSIP.pop();\n\t\t\t\t\t}\n\t\t\t\t\tSIP.push(string(1,ch));\n\t\t\t\t}\n\t\t\t\telse if(ch=='*' || ch=='/'){\n\t\t\t\t\tif(!SIP.empty() && (SIP.top()==\"*\" || SIP.top()==\"/\")){\n\t\t\t\t\t\tTA.push_back(SIP.top());\n\t\t\t\t\t\tSIP.pop();\n\t\t\t\t\t}\n\t\t\t\t\tSIP.push(string(1,ch));\n\t\t\t\t}\n\t\t\t\telse if(ch==')'){\n\t\t\t\t\twhile(!SIP.empty()){\n\t\t\t\t\t\tif(SIP.top()==\"(\"){\n\t\t\t\t\t\t\tSIP.pop();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTA.push_back(SIP.top());\n\t\t\t\t\t\tSIP.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch=='('){\n\t\t\t\tSIP.push(\"(\");\n\t\t\t}\n\t\t}\n\t\tif(!buf.empty()) TA.push_back(buf);\n\t\twhile(!SIP.empty()){\n\t\t\tTA.push_back(SIP.top());\n\t\t\tSIP.pop();\n\t\t}\n\t\tfor(auto& x:TA){\n\t\t\tif(x!=\"+\" && x!=\"-\" && x!=\"*\" && x!=\"/\"){\n\t\t\t\tint V;\n\t\t\t\tsscanf(x.c_str(),\"%d\",&V);\n\t\t\t\tIP.push(V);\n\t\t\t}\n\t\t\telse if(x==\"+\"){\n\t\t\t\tint V=IP.top();IP.pop();\n\t\t\t\tint U=IP.top();IP.pop();\n\t\t\t\tIP.push(V+U);\n\t\t\t}\n\t\t\telse if(x==\"*\"){\n\t\t\t\tint V=IP.top();IP.pop();\n\t\t\t\tint U=IP.top();IP.pop();\n\t\t\t\tIP.push(V*U);\n\t\t\t}\n\t\t\telse if(x==\"-\"){\n\t\t\t\tint V=IP.top();IP.pop();\n\t\t\t\tint U=IP.top();IP.pop();\n\t\t\t\tIP.push(U-V);\n\t\t\t}\n\t\t\telse if(x==\"/\"){\n\t\t\t\tint V=IP.top();IP.pop();\n\t\t\t\tint U=IP.top();IP.pop();\n\t\t\t\tIP.push(U/V);\n\t\t\t}\n\t\t}\n\t\tout(IP.top());\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    s.next();\n  }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    // cout << expr(begin) << endl;\n    try {\n      cout << number(begin) << endl;\n    } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\nstring in;\n\nint calc(int l,int r)\n{\n\tint pa=0;\n\tfor(int i = r; i >= l; --i)\n\t{\n\t\tif(in[i]==')') pa++;\n\t\telse if(in[i]=='(') pa--;\n\t\telse if(!pa)\n\t\t{\n\t\t\tif(in[i]=='+') return calc(l,i-1)+calc(i+1,r);\n\t\t\tif(in[i]=='-') return calc(l,i-1)-calc(i+1,r);\n\t\t}\n\t}\n\tpa=0;\n\tfor(int i = r; i >= l; --i)\n\t{\n\t\tif(in[i]==')') pa++;\n\t\telse if(in[i]=='(') pa--;\n\t\telse if(!pa)\n\t\t{\n\t\t\tif(in[i]=='*') return calc(l,i-1)*calc(i+1,r);\n\t\t\tif(in[i]=='/') return calc(l,i-1)/calc(i+1,r);\n\t\t}\n\t}\n\t\n\tif(in[l]=='('&&in[r]==')') return calc(l+1,r-1);\n\n\tstringstream ss(in.substr(l,r-l+1));\n\tint res; ss>>res;\n\treturn res;\n}\n\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\twhile(n--) \n\t{\n\t\tcin>>in;\n\t\tcout<<calc(0,in.size()-2)<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????????\n//??????00-440415D???Smart_Calculator.cpp\n\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\n#include <stdio.h>\n\nusing namespace std;\n\nstring S = \"1+2*(3+4)\";\nsize_t cur = 0;\n\nint expression();\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur<S.size() && isdigit(S[cur])){\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint factor(){\n\tif(S[cur] != '('){\n\t\treturn number();\n\t}else{\n\t\tcur++;\n\t\tint n = expression();\n\t\tassert(S[cur])==')');\n\t\tcur++;\n\t\treturn n;\n\t}\n}\n\n//??????????????????????????????\nint term(){\n\tint a = factor();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*'){\n\t\t\ta *= b;\n\t\t}else if(op == '/'){\n\t\t\ta /= b;\n\t\t}\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(S[cur] == '+' || S[cur] == '-'){\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+'){\n\t\t\tsum += b;\n\t\t}else if(op == '-'){\n\t\t\tsum -= b;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\t//while(*now.second!='=' && *now.second!=')'){\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\t//while(*now.second!='=' && *now.second!=')' && *now.second!='+' && *now.second!='-'){\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\n//parsed fact(const char* s)\n//{\n//\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n//\tif(s[0]=='('){\n//\t\tparsed res=expr(s+1);\n//\t\tres.second++;\n//\t\treturn res;\n//\t}\n//\telse{\n//\t\tconst char* p=s;\n//\t\tif(*p=='-')\n//\t\t\tp++;\n//\t\tll n=0;\n//\t\twhile(isdigit(*p)){\n//\t\t\tn=n*10+*p-'0';\n//\t\t\tp++;\n//\t\t}\n//\t\treturn parsed(n,p);\n//\t}\n//}\n\n//parsed expr(const char *p)\n//{\n//  parsed r=term(p);\n//  while(*r.second=='+'||*r.second=='-'){\n//    char op=*r.second;\n//    int tmp=r.first;\n//    r=term(r.second+1);\n//    if (op=='+') r.first=tmp+r.first;\n//    else r.first=tmp-r.first;\n//  }\n//  return r;\n//}\n//\n//parsed term(const char *p)\n//{\n//  parsed r=fact(p);\n//  while(*r.second=='*'||*r.second=='/'){\n//    char op=*r.second;\n//    int tmp=r.first;\n//    r=fact(r.second+1);\n//    if (op=='*') r.first=tmp*r.first;\n//    else r.first=tmp/r.first;\n//  }\n//  return r;\n//}\n\nparsed fact(const char *p)\n{\n  if (isdigit(*p)){\n    int t=*(p++)-'0';\n    while(isdigit(*p)) t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if (*p=='('){\n    parsed r=expr(p+1);\n    if (*r.second!=')') exit(0); // invalid input\n    return parsed(r.first,r.second+1);\n  }\n  else\n    exit(0); // invalid input\n}\n\nint main()\n{\n\t//const char* s=\"-6/-4=\";\n\t//parsed p=expr(s);\n\t//cout<<p.first<<\",\"<<p.second<<endl;\n\t\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <sstream>\n\nusing namespace std;\n\ntypedef string::const_iterator Cursor;\nclass ParseError{};\n\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\nint expression(Cursor&);\nint term(Cursor&);\nint factor(Cursor&);\nint number(Cursor&);\n\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\nint expression(Cursor &c){\n    int ret = term(c);\n    while(*c == '+' or *c == '-'){\n        if(*c == '+'){\n            c++;\n            ret += term(c);\n        }else{\n            c++;\n            ret -= term(c);\n        }\n    }\n    return ret;\n}\n\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\nint term(Cursor &c){\n    int ret = factor(c);\n    while(*c == '*' or *c == '/'){\n        if(*c == '*'){\n            c++;\n            ret *= factor(c);\n        }else{\n            c++;\n            ret /= factor(c);\n        }\n    }\n    return ret;\n}\n\n// <括弧か数>     ::= '(' <四則演算の式> ')' or <数>\nint factor(Cursor &c){\n    if(*c == '('){\n        c++;\n        int ret = expression(c);\n        // ')'\n        c++;\n        return ret;\n    }else{\n        return number(c);\n    }\n}\n\n// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\nint number(Cursor &c){\n    stringstream ss;\n    while(isdigit(*c)){\n        ss << *c;\n        c++;\n    }\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nint main(){\n    int test_case;\n    cin >> test_case;\n    cin.ignore();\n    for(int i=0;i<test_case;i++){\n        string s;\n        getline(cin,s);\n        Cursor c = s.begin();\n        cout << expression(c) << endl;\n        if(*c != '='){\n            cerr  << 'n' << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  char c = buf[pos];\n  if ('0' <= c && c <= '9') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  int res = p.first;\n  while (1) {\n    char c = buf[pos];\n    if (c != '*' && c != '/') break;\n\n    if (c == '*') {\n      Pair q = EvalElem(pos+1);\n      res *= q.first;\n      pos = q.second;\n    } else {\n      Pair q = EvalElem(pos+1);\n      res /= q.first;\n      pos = q.second;\n    }\n  } \n\n  return Pair(res, pos);\n}\n\nPair EvalExp(int pos) {\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n\n  char c = buf[pos];\n  int res = p.first;\n  if (c == '=' || c == ')') {\n    return Pair(res, pos);\n  }\n\n  Pair q = EvalExp(pos+1);\n  if (c == '+') res += q.first;\n  else if (c == '-') res -= q.first;\n  else assert(0);\n\n  return Pair(res, q.second);\n}\n\nint main() {\n  scanf(\"%d \", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nusing namespace std;\n\n \nint number(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\nint main(void){\n  int N;\n  std::cin >> N;\n\n  while(N--){\n    std::string s;\n    std::cin>>s;\n    State begin = s.begin();\n    int ans = expression(begin);\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}\n \nint number(State &begin){\n  int ret = 0;\n \n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n \n  return ret;\n}\n \nint factor(State &begin){\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    return ret;\n  }else{\n    return number(begin);\n  }\n}\n \n\n \nint expression(State &begin){\n  int num = factor(begin);\n  int sum = 0;\n  \n  for(;;){\n    char ch = *begin;\n    begin++;\n    if(ch == '+'){\n      num += factor(begin);\n    } else if(ch == '-'){\n      num -= factor(begin);\n    }else if(ch == '*'){\n      sum += num;\n      num = factor(begin);\n    }else if(ch == '/'){\n      sum += num;\n      num = factor(begin);\n    }else{\n      break;\n    }\n  }\n  return sum+num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\ntypedef string::const_iterator State;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nclass Parser{\npublic:\n\tint expression(State &begin){\n\t\tint ret = term(begin);\n\t\tfor(;;){\n\t\t\tif(*begin == '+'){\n\t\t\t\tbegin++;\n\t\t\t\tret += term(begin);\n\t\t\t}else if(*begin == '-'){\n\t\t\t\tbegin++;\n\t\t\t\tret -= term(begin);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint term(State &begin){\n\t\tint ret = factor(begin);\n\t\tfor(;;){\n\t\t\tif(*begin == '*'){\n\t\t\t\tbegin++;\n\t\t\t\tret *= factor(begin);\n\t\t\t}else if(*begin == '/'){\n\t\t\t\tbegin++;\n\t\t\t\tret /= factor(begin);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint factor(State &begin){\n\t\tif(*begin == '('){\n\t\t\tbegin++;//'('?????????\n\t\t\tint ret = expression(begin);\n\t\t\tbegin++;//')'?????????\n\t\t}else{\n\t\t\treturn number(begin);\n\t\t}\n\t}\n\tint number(State &begin){\n\t\tint ret = 0;\n\t\twhile(isdigit(*begin)){\n\t\t\tret *= 10;\n\t\t\tret += *begin - '0';\n\t\t\tbegin++;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main(void){\n\tint n; cin >> n;\n\trep(i, n){\n\t\tParser ps;\n\t\tstring s; cin >> s;\n\t\tstring tmp = s.substr(0, s.size() - 1);\n\t\t// cout << tmp << endl;\n\t\tState begin = s.begin();\n\t\tint ret = ps.expression(begin);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a){\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\trep(i, s.first)rep(j, s.second)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a=0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}　\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nint g(string &s, int &p);\nint f(string &s, int &p) {\n\tint k = 0;\n\tint m = 1;\n\twhile (s[p] != ')' && s[p] != '=') {\n\t\tswitch (s[p]) {\n\t\t//case '(':\n\t\t//\tp++;\n\t\t//\tk += m*f(s, p);\n\t\t//\tp++;\n\t\t//\tbreak;\n\t\tcase '-':\n\t\t\tm = -1;\n\t\t\tp++;\n\t\t\tk -= g(s, p);\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tm = 1;\n\t\t\tp++;\n\t\t\tk += g(s, p);\n\t\t\tbreak;\n\t\t//default:\n\t\t//\tk += m*g(s, p);\n\t\t}\n\t}\n\treturn k;\n}\nint g(string &s, int &p) {\n\tint k = 1;\n\tbool div = 0;\n\twhile (s[p] != ')' && s[p] != '+' && s[p] != '-' && s[p] != '=') {\n\t\tswitch (s[p]) {\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tif (div)k /= f(s, p);\n\t\t\telse k *= f(s, p);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tdiv = 0;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tdiv = 1;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tint num = 0;\n\t\t\twhile (isdigit(s[p])) {\n\t\t\t\tnum = num * 10 + s[p] - '0';\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (div)k /= num;\n\t\t\telse k *= num;\n\t\t}\n\t}\n\treturn k;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint p = 0;\n\t\tcout << f(s, p) << endl;\n\t}\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\n\tstruct node {\n\t\tmap<char,unique_ptr<node>> next;\n\t\tnode* fail = nullptr, *match_list = nullptr;\n\t\tstd::vector<int> match;\n\t}root;\n\tint pattern;\n\t//template<class string>\n\tAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\n\t\troot.fail = &root;\n\t\tfor (int i = 0; i < vs.size(); i++) {\n\t\t\tnode* now = &root;\n\t\t\tfor (auto c : vs[i]) {\n\t\t\t\tif (!now->next[c])now->next[c]=make_unique<node>();\n\t\t\t\tnow = now->next[c].get();\n\t\t\t}\n\t\t\tnow->match.push_back(i);\n\t\t}\n\t\tstd::queue<node*> que;\n\t\tque.push(&root);\n\t\twhile (!que.empty()) {\n\t\t\tauto now = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto &next : now->next) {\n\t\t\t\tif (!next.second)continue;\n\t\t\t\tif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\n\t\t\t\telse next.second->fail = now->fail->fail;\n\t\t\t\t//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\n\t\t\t\tif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\n\t\t\t\telse next.second->match_list = next.second->fail;\n\t\t\t\tque.push(next.second.get());\n\t\t\t}\n\t\t}\n\t}\n\tauto match_n(string str) {\n\t\tvector<int> num(pattern);\n\t\t\n\t}\n\tauto match_list(string str) {\n\t\tvector<pair<int, int>> list;\n\t\tauto now = &root;\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\tif (now->next.count(str[i]))now = now->next[str[i]].get();\n\t\t\telse now = now->fail;\n\t\t\tauto match = now->match_list;\n\t\t\tdo {\n\t\t\t\tmatch\n\t\t\t}\n\t\t}\n\t}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nusing LL = long long;\nconst LL LINF = 1e18;\nusing namespace std;\n#define COUT(v) cout<<(v)<<endl\n#define CIN(n)  int(n);cin >> (n)\n#define SCIN(n) string(n);cin >> (n)\n#define YES(n) cout<<((n)? \"YES\" : \"NO\")<<endl\n#define Yes(n) cout<<((n)? \"Yes\" : \"No\")<<endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) <<endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define P pair<int,int>\n#define I vector<int>\n#define S set<int>\n#define pb(v) push_back(v)\n#define V vector\n#define rt return\n#define rmsame(a) sort(ALL(a)),a.erase(unique(ALL(a)), a.end())\n\ntypedef string::const_iterator State;\nclass PalseError {};\nclass Edge{\npublic:\n    int from,to,value;\n    Edge(int a,int b,int c){\n        from = a;\n        to = b;\n        value = c;\n    }\n    Edge(int a,int b){\n        from = a;\n        to = b;\n    }\n};\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\nint term(State &begin){\n    int ret = number(begin);\n    while(1){\n        if(*begin == '*'){\n            begin++;\n            ret *=  number(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= number(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint expression(State &begin){\n    int ret = term(begin);\n    while(1){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\nint main(){\n    string s;\n    CIN(N);\n    REP(a,N){\n        cin >> s;\n        State w = s.begin();\n        COUT(expression(w));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstring S; int n, junjo[4] = { 0, 0, 1, 1 };\nlong long calc(int L,int R){\n    int K=0;\n    vector<int>junjo2[4];\n    for(int i=0;i<4;i++){\n        junjo2[junjo[i]].push_back(i);\n    }\n    for(int i=0;i<4;i++){\n        if(junjo2[i].size()>=1){\n            for(int j=R-1;j>=L;j--){\n                if(S[j]=='('){K++;}\n                if(S[j]==')'){K--;}\n                for(int k=0;k<junjo2[i].size();k++){\n                    if(junjo2[i][k]==0){\n                        if(S[j]=='+' && K==0){\n                            return calc(L,j)+calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==1){\n                        if(S[j]=='-' && K==0){\n                            return calc(L,j)-calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==2){\n                        if(S[j]=='*' && K==0){\n                            return calc(L,j)*calc(j+1,R);\n                        }\n                    }\n                    if(junjo2[i][k]==3){\n                        if(S[j]=='/' && K==0){\n                            return calc(L,j)/calc(j+1,R);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(S[L]=='(' && S[R-1]==')'){return calc(L+1,R-1);}\n    return stoi(S.substr(L,R-L));\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) cin >> s, printf(\"%d\\n\", calc(0, s.size() - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <stdlib.h>\n\nusing namespace std;\n\nstring ex_s; //expression_string\nint n;\n\nint cal(string ex_s) //calculate expression_string\n{\n    int i;\n    int j;\n    int ans; //answer\n    int cnt_p=0; //count_parentheses\n    int cnt_pp=1;\n    int cnt_as=0; //count_add subtract\n    int cnt_md=0; //count_nultiply divide\n    for(i=0;i<ex_s.size();i++)\n    {\n        if(ex_s[i]=='(')\n        {\n            for(j=i+1;j<ex_s.size();j++)\n            {\n                if(ex_s[j]=='(') cnt_pp+=1;\n                else if(ex_s[j]==')')\n                {\n                    cnt_pp-=1;\n                    if(cnt_pp==0)\n                    {\n                        cnt_pp=1;\n                        break;\n                    }\n                }\n            }\n            ans=cal(ex_s.substr(i+1,j-i-1));\n            ex_s=ex_s.substr(0,i)+to_string(ans)+ex_s.substr(j+1);\n            i=j;\n            cnt_p+=1;\n        }\n    }\n    if(cnt_p!=0)\n    {\n        return cal(ex_s);\n    }\n    else\n    {   for(i=ex_s.size()-1;i>0;i--)\n        {\n            if(ex_s[i]=='+')\n            {\n                ans=cal(ex_s.substr(0,i))+cal(ex_s.substr(i+1));\n                cnt_as+=1;\n                return ans;\n                break;\n            }\n            else if(ex_s[i]=='-')\n            {\n                if(!isdigit(ex_s[i-1])) continue;\n                ans=cal(ex_s.substr(0,i))-cal(ex_s.substr(i+1));\n                cnt_as+=1;\n                return ans;\n                break;\n            }\n        }\n        if(cnt_as==0)\n        {\n            for(i=ex_s.size()-1;i>0;i--)\n            {\n                if(ex_s[i]=='*')\n                {\n                    ans=cal(ex_s.substr(0,i))*cal(ex_s.substr(i+1));\n                    cnt_md+=1;\n                    return ans;\n                    break;\n                }\n                else if(ex_s[i]=='/')\n                {\n                    ans=cal(ex_s.substr(0,i))/cal(ex_s.substr(i+1));\n                    cnt_md+=1;\n                    return ans;\n                    break;\n                }\n            }\n            if(cnt_md==0)\n            {\n                return atoi(ex_s.c_str());\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    while(n--)\n    {\n        cin >> ex_s;\n        ex_s.pop_back();\n        cout << cal(ex_s) << endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-6;\ndouble add(double a,double b){\n    if(abs(a+b)<eps)return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\n    vector<int>ans;\n    while(cin>>n,n!=0){\n        P a[n];\n        double r[n];\n        rep(i,n)cin>>a[i].first>>a[i].second>>r[i];\n        P b[n-1][2];\n        rep(i,n-1){\n            P v=(a[i+1]-a[i])*(1.0/d(a[i+1],a[i]));\n            P h={v.second,-v.first};\n            double l=(r[i]*r[i]+d(a[i],a[i+1])*d(a[i],a[i+1])-r[i+1]*r[i+1])/2/d(a[i],a[i+1]);\n            b[i][0]=a[i]+v*l+h*sqrt(r[i]*r[i]-l*l);\n            b[i][1]=a[i]+v*l-h*sqrt(r[i]*r[i]-l*l);\n        }\n        double x[2*n][2*n];\n        rep(i,2*n)rep(j,2*n)x[i][j]=inf;\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            rep(k,i)if(!cross(a[0],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[0][2*i+j+1]=d(a[0],b[i][j]);\n        }\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            REP(k,i+1,n-1)if(!cross(a[n-1],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[2*n-1][2*i+j+1]=d(a[n-1],b[i][j]);\n        }\n        rep(i,n-1)REP(j,i+1,n-1)rep(k,2)rep(l,2){\n            bool ok=true;\n            REP(m,i+1,j)if(!cross(b[i][k],b[j][l],b[m][0],b[m][1]))ok=false;\n            if(ok)x[2*i+k+1][2*j+l+1]=d(b[i][k],b[j][l]);\n        }\n        bool ok=true;\n        rep(i,n-1)if(!cross(a[0],a[n-1],b[i][0],b[i][1]))ok=false;\n        if(ok)x[0][2*n-1]=d(a[0],a[n-1]);\n        rep(i,2*n)x[i][i]=0;\n        rep(i,n)x[2*i+1][2*i+2]=d(b[i][0],b[i][1]);\n        rep(i,2*n)rep(j,2*n)x[i][j]=min(x[i][j],x[j][i]);\n        rep(i,2*n)rep(j,2*n)rep(k,2*n)x[j][k]=min(x[i][j]+x[i][k],x[j][k]);\n        cout<<setprecision(10)<<x[0][2*n-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ntemplate <class _Tt>\nclass calculate {\npublic:\n    enum op {NUM,ADD,SUB,MUL,DIV,LPA,RPA};\nprivate:\n    typedef pair<op, _Tt> pt; \n    deque<pt> mq;\n    void popf(deque<pt> &q, op &type, _Tt &num){\n        type = q.front().first; num = q.front().second;\n        q.pop_front();\n    }\n    void popb(deque<pt> &q, op &type, _Tt &num){\n        type = q.back().first; num = q.back().second;\n        q.pop_back();\n    }\n    _Tt cal2(deque<pt> &q){\n        op sop, dop; _Tt snum, dnum, num = 0;\n        while(!q.empty()){\n            popf(q, sop, snum);\n            switch(sop){\n            case NUM: num = snum; break;\n            case ADD: case SUB:\n                popf(q, dop, dnum); dbgchk(dop != NUM);\n                num = (sop == ADD) ? num+dnum : num-dnum;\n                break;\n            default: throw;\n            }\n        }\n        return num;\n    }\n    _Tt cal(deque<pt> &q){\n        deque<pt> s;\n        while(!q.empty()){\n            op qop; _Tt num;\n            popf(q, qop, num);\n            switch(qop){\n            case NUM: case ADD: case SUB:\n                s.pb(mp(qop,num)); break;\n            case LPA:\n                s.pb(mp(NUM,cal(q))); break;\n            case RPA:\n                return cal2(s); break;\n            case MUL: case DIV:\n                op sop, dop; _Tt snum, dnum;\n                popb(s, sop, snum); dbgchk(sop != NUM);\n                popf(q, dop, dnum); dbgchk(dop != NUM && dop != LPA);\n                if(dop == LPA) dnum = cal(q);\n                _Tt r = (qop == MUL) ? snum*dnum : snum/dnum;\n                s.pb(mp(NUM,r));\n                break;\n            }\n        }\n        return cal2(s);\n    }\npublic:\n    void add(_Tt n){ mq.pb(mp(NUM,n)); }\n    void add(op opr){ mq.pb(mp(opr,0)); }\n    _Tt result(){ return cal(mq); }\n};\n\nvoid solve(string s){\n    int n = s.length();\n    calculate<int> calc;\n    int num = 0;\n    bool f = false;\n    REP(i,n){\n        if(isdigit(s[i])){\n            num = num * 10 + (s[i]-'0'); f = true;\n            continue;\n        }\n        if(f) calc.add(num);\n        if(s[i] == '=') break;\n        switch(s[i]){\n        case '+': calc.add(calc.ADD); break;\n        case '-': calc.add(calc.SUB); break;\n        case '*': calc.add(calc.MUL); break;\n        case '/': calc.add(calc.DIV); break;\n        case '(': calc.add(calc.LPA); break;\n        case ')': calc.add(calc.RPA); break;\n        }\n        num = 0; f = false;\n    }\n    cout << calc.result() << endl;\n}\n\nint main(){\n    int n;\n    string s; getline(cin, s);\n    istringstream ss(s); ss >> n;\n    REP(i,n){\n        getline(cin, s);\n        solve(s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint cal1();\nint cal2();\nint cal3();\n\nint index;\nstring s;\n\nint getNum(){\n\tint n = 0;\n\tfor (; '0' <= s[index] && s[index] <= '9'; index++) n = n * 10 + s[index] - '0';\n\treturn n;\n}\n\nint cal1(){\n\tint ret = cal2();\n\twhile (1){\n\t\tif (s[index] == '+') {\n\t\t\tindex++;\n\t\t\tret += cal2();\n\t\t}\n\t\telse if (s[index] == '-') {\n\t\t\tindex++;\n\t\t\tret -= cal2();\n\t\t}\n\t\telse return ret;\n\t}\n}\n\nint cal2(){\n\tint ret = cal3();\n\twhile (1){\n\t\tif (s[index] == '*') {\n\t\t\tindex++;\n\t\t\tret *= cal3();\n\t\t}\n\t\telse if (s[index] == '/') {\n\t\t\tindex++;\n\t\t\tret /= cal3();\n\t\t}\n\t\telse return ret;\n\t}\n}\n\nint cal3(){\n\tint ret = 0;\n\tint old = index;\n\tif (s[index] == '('){\n\t\tindex++;\n\t\tret = cal1();\n\t\tindex++;\n\t}\n\telse {\n\t\tret = getNum();\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tgetchar();\n\tfor (int i = 0; i < n; i++){\n\t\tindex = 0;\n\t\tgetline(cin, s);\n\t\ts.pop_back();\n\t\tcout << cal1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint number(State& begin);\nint term(State& begin);\nint expr(State& begin);\nint factor(State& begin);\n\nint number(State& begin){\n    int res = 0;\n    while( isdigit(*begin) ){\n        res *= 10;\n        res += *begin - '0';\n        begin++;\n    }\n    return res;\n}\n\nint term(State& begin){\n    int res = factor(begin);\n    for(;;){\n        if( *begin == '*' ){\n            begin++;\n            res *= factor(begin);\n        }else if( *begin == '/' ){\n            begin++;\n            res /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint expr(State& begin){\n    int res = term(begin);\n    for(;;){\n        if( *begin == '+' ){\n            begin++;\n            res += term(begin);\n        }else if( *begin == '-' ){\n            begin++;\n            res -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nint factor(State& begin){\n    if(*begin == '('){\n        begin++;\n        int res = expr(begin);\n        begin++;\n        return res;\n    }else{\n        return number(begin);\n    }\n}\n\nint main(void){\n    int N;\n    cin >> N;\n    cin.ignore();\n    for(string s;N--;){\n        getline(cin, s);\n        State begin = s.begin();\n        cout << expr(begin) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<string.h>\n#include<math.h>\n#include<time.h>\nconst char symbollist[] = \"+-*/()$;\" ;//??????????????????\nchar SymbolJudge(char c, const char* str)//?????????????????¢??°\n{\n  for(size_t i = 0; str[i] != '\\0'; ++i )\n  {\n    if( c == str[i])\n    {\n      return str[i] ;\n    }\n  }\n  return 0 ;\n}\n\nint Judge(char *str)//()????????????????????????????????¢??°\n{\n  int pa_n = 0;\n  for(size_t i = 0; str[i] != '\\0'; ++i )\n  {\n    if(str[i] == '('){\n      ++pa_n ;\n    }\n  }\n  return pa_n ;\n}\n\nint Str(const char* str,const char* tar,const char* bul){//?????????????????¢??°\n  char *temp ;\n  size_t slen = strlen(str) ;\n  size_t tlen = strlen(tar) ;\n  size_t blen = strlen(bul) ;\n  if((temp = strstr(str,tar)) == NULL){\n    return 0 ;\n  }\n  memmove(temp + blen,temp + tlen,slen - (temp + tlen - str) + 1 ) ;\n  memcpy(temp, bul , blen) ;\n  return 1 ;\n}\nconst int N = 200;\ndouble EasyCalc(char *string){//()??????????¨????????????¢??°\n  char formula[100] = {}, operators[N], temp[N], c ;\n  size_t i, j = 0, nu_n = 0, op_n = 0 ;\n  int tmp = 0  ;\n  double num[N] ;\n  strcpy(formula,string ) ;\n  while(Str(formula,\" \",\"\")) ;\n  strcat(formula,\";\") ;\n  for(i = 0,j = 0; formula[i] != '\\0'; ++ i){\n    if(SymbolJudge(formula[i], symbollist) == '-'){\n      if(i == 0 || SymbolJudge(formula[i-1], symbollist) != 0){\n        temp[j] = formula[i] ;\n        ++j ;\n        operators[op_n] = '+';\n      }\n      else{\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else if((c =SymbolJudge(formula[i], symbollist)) != 0){\n      if(c != '('){\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else{\n      temp[j] = formula[i] ;\n      ++j ;\n    }\n  }\n  tmp = 0 ;\n  while(1){\n    if((c=SymbolJudge(operators[tmp], symbollist) ) == ';'){\n      break ;\n    }\n    switch(c){\n      case '*':\n        num[tmp] *= num[tmp + 1];\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '/':\n        num[tmp] /= num[tmp + 1];\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        ++tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == 0){\n        num[j] = num[j + 1] ;\n        num[j + 1] = 0 ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  tmp = 0 ;\n  while(1){\n    if((c=SymbolJudge(operators[0],symbollist)) == ';'){\n      break ;\n    }\n    switch(c){\n      case '+':\n        num[tmp] += num[tmp + 1] ;\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '-':\n        num[tmp] -= num[tmp + 1] ;\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        ++ tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == 0){\n        num[j] = num[j + 1] ;\n        num[j + 1] = 0 ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  return num[0] ;\n}\ndouble Calculation(char *string)//???????????£??????????¨??????????\n{\n//   char* string = const_cast<char*>(str.c_str());\n  bool flag = false ;\n  char formula[N], formula1[N] = {}, operators[N], temp[N], c, buf[N] ;\n  int flag_p = 0, pa_n = 0 ;\n  size_t i, j = 0, nu_n = 0, op_n = 0, tmp = 0 ;\n  double num[N] , ans;\n  strcpy(formula,string ) ;\n  while(1){//()??????????¨????????????¨???\n    flag_p = Judge(formula) ;//()??????????????????????????????\n    if(flag_p == 0 ){\n      break ;\n    }\n    for(i = 0,j = 0,pa_n =0; formula[i] != '\\0' ; ++ i){\n      c = SymbolJudge(formula[i],symbollist) ;\n      if(c == '('){\n        ++pa_n ;\n        if(flag_p == pa_n){\n          formula[i] = '$' ;\n          flag = true ;\n        }\n        j = 0;\n        memset(formula1,'\\0',N) ;\n      }\n      if(flag_p == pa_n){\n        if(c == ')'){\n          formula[i] = ' ' ;\n          while(Str(formula1,\" \",\"\")) ;\n          while(Str(formula1,\"\\n\",\"\")) ;\n          ans = EasyCalc(formula1) ;\n          break ;\n        }\n        else{\n          if(flag){\n            flag = !flag ;\n          }\n          else{\n            formula1[j] = formula[i] ;\n            formula[i] = ' ' ;\n            ++ j ;\n          }\n        }\n      }\n    }\n    while(Str(formula,\" \",\"\")) ;\n    for(i = 0,j = 0; formula[i] != '\\0' ; ++ i){\n      c = SymbolJudge(formula[i],symbollist) ;\n      if(c == '$'){\n        sprintf(buf,\"%lf\",ans) ;\n        Str(formula,\"$\", buf) ;\n        break ;\n      }\n    }\n  }\n\n  strcat(formula,\";\") ;//????°?????????????????????§???????????¨???????????????????????????????¨?\n\n  Str(formula,\")\",\"\") ;\n  for(i = 0,j = 0; formula[i] != '\\0'; ++ i){\n    if(SymbolJudge(formula[i], symbollist) == '-'){\n      if(formula[i+1] != '\\0' && SymbolJudge(formula[i+1], symbollist) == '-'){\n        num[nu_n] = -1 ;\n        ++nu_n ;\n        operators[op_n] = '*' ;\n        ++op_n ;\n      }\n      else if(i == 0 || SymbolJudge(formula[i-1], symbollist) != 0){//????????°??????????????????\n        temp[j] = formula[i] ;\n        ++j ;\n        operators[op_n] = '+';\n      }\n      else{//???????????°?????¨???????????????????????????\n        operators[op_n] = formula[i] ;//????????????????´?\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else if((c =SymbolJudge(formula[i], symbollist)) != 0){//????????????????????°??§???????????§??????\n      if(c != '('){\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else{//???????????§??????????????°??§??????\n      temp[j] = formula[i] ;\n      ++j ;\n    }\n  }\n  while(1){//*/??????????????????\n//         printf(\"%lf\\n\",num[nu_n-1]) ;\n    if((c=SymbolJudge(operators[tmp], symbollist) ) == ';'){//???????????????????????????\n      break ;\n    }\n    switch(c){//????´?????????????????????????????????£?????????????????????\n      case '*':\n        num[tmp] *= num[tmp + 1];\n        num[tmp + 1] = INFINITY ;//????????¨?????\\?????????????????¨??????\n        operators[tmp] = '\\0' ;//????????¨?????\\???\n        break ;\n      case '/':\n        num[tmp] /= num[tmp + 1];\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default://+-???????????§????¨?????????????\n        ++tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){//????????¨?????\\????????????????????????????????°????????????\n      if(num[j] == INFINITY){\n        num[j] = num[j + 1] ;\n        num[j + 1] = INFINITY ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){//????§????\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  tmp = 0 ;\n  while(1){//+-?????????\n    if((c=SymbolJudge(operators[0],symbollist)) == ';'){\n      break ;\n    }\n    switch(c){//*/??¨?????????????????§??????\n      case '+':\n        num[tmp] += num[tmp + 1] ;\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '-':\n        num[tmp] -= num[tmp + 1] ;\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == INFINITY){\n        num[j] = num[j + 1] ;\n        num[j + 1] = INFINITY ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  return num[0] ;//??°????????????????????????????????????????´??????????\n}\n\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  char str[N];\n  for(int i = 0; i < n; ++i){\n    scanf(\"%s\",str);\n    int ans = Calculation(str);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint atoi(string s);\nint calc(string in);\n\nint main(){\n    int n;cin>>n;\n    for(int lop=0; lop<n; lop++){\n        string in;cin>>in;\n        cout<<calc(in.substr(0,in.size()-1))<<endl;\n    }\n}\n\nint calc(string in){\n    //cout<<in<<endl;\n    bool f=true;\n    for(int i=1; i<in.size();i++){\n        if(in[i]<'0'||'9'<in[i]){\n            f=false;\n            break;\n        }\n    }\n    if(f){\n        if(in[0]=='-')\n            return -atoi(in.substr(1,in.size()-1));\n        if(in[0]=='+')\n            return atoi(in.substr(1,in.size()-1));\n        return atoi(in);\n    }\n    for(int i=0; i<in.size(); i++){\n        if(in[i]=='+'||in[i]=='-'||in[i]=='('||in[i]==')'){\n            f=true;\n            break;\n        }\n    }\n    if(!f){\n        int num=1,start=0;\n        // if op * , else /\n        bool op=true;\n        for(int i=0; i<in.size(); i++){\n            if(in[i]=='*'||in[i]=='/'){\n                if(op)\n                    num*=atoi(in.substr(start,i-start));\n                else\n                    num/=atoi(in.substr(start,i-start));\n                start=i+1;\n                if(in[i]=='*')\n                    op=true;\n                else\n                    op=false;\n            }\n            if(i==in.size()-1){\n                if(op)\n                    num*=atoi(in.substr(start,1+i-start));\n                else\n                    num/=atoi(in.substr(start,1+i-start));\n                break;\n            }\n        }\n        return num;\n    }\n    for(int i=0; i<in.size(); i++){\n        if(in[i]=='('||in[i]==')'){\n            f=false;\n            break;\n        }\n    }\n    if(f){\n        int start=0,num=0;\n        // if op + , else - \n        bool op=true;\n        for(int i=0; i<in.size(); i++){\n            if(in[i]=='+'||in[i]=='-'){\n                if (op)\n                    num+=calc(in.substr(start,i-start));\n                else\n                    num-=calc(in.substr(start,i-start));\n                start=i+1;\n                if(in[i]=='+')\n                    op=true;\n                else\n                    op=false;\n            }\n            if(i==in.size()-1){\n                if(op)\n                    num+=calc(in.substr(start,1+i-start));\n                else\n                    num-=calc(in.substr(start,1+i-start));\n                break;\n            }\n        }\n        return num;\n    }\n    //cout<<in<<endl;\n    if(in[0]!='('||in[in.size()-1]!=')')\n        f=true;\n    if(!f){\n        for(int i=1; i<in.size()-1; i++){\n            if(in[i]=='('){\n                f=true;\n                break;\n            }\n        }\n        if(!f)\n            return calc(in.substr(1,in.size()-2));\n    }\n    int level=0;\n    for(int i=0; i<in.size(); i++){\n        if(in[i]=='('){\n            level++;\n            continue;\n        }\n        if(in[i]==')'){\n            level--;\n            continue;\n        }\n        if(level==0&&(in[i]=='+'||in[i]=='-'))\n            f=false;\n    }\n    if(f){\n        //cout<<in<<endl;\n        level=0;\n        int start=0;\n        int num=1;\n        bool op=true;\n        for(int i=0; i<in.size(); i++){\n            if(i==in.size()-1){\n                if(op)\n                    num*=calc(in.substr(start,1+i-start));\n                else\n                    num/=calc(in.substr(start,1+i-start));\n            }\n            if(in[i]=='('){\n                level++;\n                continue;\n            }\n            if(in[i]==')'){\n                level--;\n                continue;\n            }\n            if(level==0&&(in[i]=='*'||in[i]=='/')){\n                if(op)\n                    num*=calc(in.substr(start,i-start));\n                else\n                    num/=calc(in.substr(start,i-start));\n                start=i+1;\n                if(in[i]=='*')\n                    op=true;\n                else\n                    op=false;\n            }\n        }\n        return num;\n    }    \n    int start=0,num=0;\n    level=0;\n    bool op=true;\n    for(int i=0; i<in.size(); i++){\n        if(i==in.size()-1){\n            if(op)\n                num+=calc(in.substr(start,1+i-start));\n            else\n                num-=calc(in.substr(start,1+i-start));\n        }\n        if(in[i]=='('){\n            level++;\n            continue;\n        }\n        if(in[i]==')'){\n            level--;\n            continue;\n        }\n        if(level==0&&(in[i]=='+'||in[i]=='-')){\n            if(op)\n                num+=calc(in.substr(start,i-start));\n            else\n                num-=calc(in.substr(start,i-start));\n            start=i+1;\n            if(in[i]=='+')\n                op=true;\n            else\n                op=false;\n        }\n    }\n    return num;\n}\n\nint atoi(string s){\n    int n=0;\n    for(int i=0; i<s.size(); i++){\n        n=n*10+s[i]-'0';\n    }\n    return n;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '*')\n\t\treturn 1;\n\tif(a == '/')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<int> & num_stack, stack<char> & op_stack) {\n\tint a, b;\n\tint c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nint clac(string str) {\n\tstack<int> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tint tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t\telse if(str[i] == '-') {\n\t\t\tint tmp = 0;\n\t\t\tif(('0' <= str[i - 1] && str[i - 1] <= '9') || !i)\n\t\t\t\top_stack.push('+');\n\t\t\ti++;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp * -1);\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])){\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n  \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n  \n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\ntypedef long double Real;\n#define EPS 1e-13\n#define EQ(x) (-EPS<x && x<EPS)\ntypedef complex<Real> P;\nReal dot(P a,P b){return real(conj(a)*b);}\nReal cross(P a,P b){return imag(conj(a)*b);}\n\n#define MP make_pair<int,int>\n\nstring s;\nint iter;\n\nll dfs();\n\nll dfs2(ll val,int op){\n  ll tmp = 0;\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      tmp = dfs();\n    }else if(s[iter]==')' || s[iter]=='=' || s[iter]=='+' || s[iter]=='-'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      --iter;\n      return val;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      if(op) val *= tmp;\n      else val /= tmp;\n      op = s[iter]=='*'?1:0;\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nll dfs(){\n  ll val = 0;\n  ll tmp = 0;\n  int op = 1; // op==1?'+':'-'\n  while(true){\n    if('0'<=s[iter]&&s[iter]<='9'){\n      tmp *= 10;\n      tmp += s[iter]-'0';\n    }else if(s[iter]=='('){\n      ++iter;\n      tmp = dfs();\n    }else if(s[iter]==')' || s[iter]=='='){\n      val += op*tmp;\n      tmp = 0;\n      return val;\n    }else if(s[iter]=='+'){\n      val += op*tmp;\n      tmp = 0;\n      op = 1;\n    }else if(s[iter]=='-'){\n      val += op*tmp;\n      tmp = 0;\n      op = -1;\n    }else if(s[iter]=='*' || s[iter]=='/'){\n      ++iter;\n      val += op*dfs2(tmp,s[iter-1]=='*'?1:0);\n      tmp = 0;\n    }\n    if(iter>=s.size()){\n      --iter;--iter;\n      return val;\n    }\n    ++iter;\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>s;\n    iter = 0;\n    cout<<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint expression(State &begin) {\n  int ret = term(begin);\n  for (;;) {\n    if (*begin == '+') {\n      begin++;\n      ret += term(begin);\n    } else if (*begin == '-') {\n      begin++;\n      ret -= term(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nint term(State &begin) {\n  int ret = factor(begin);\n  for (;;) {\n    if (*begin == '*') {\n      begin++;\n      ret *= factor(begin);\n    } else if (*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nint factor(State &begin) {\n  int ret = 0;\n  if (*begin == '(') {\n    begin++;\n    ret = expression(begin);\n    begin++;\n    return ret;\n  } else {\n    ret = number(begin);\n  }\n  return ret;\n}\n\nint number(State &begin) {\n  int ret = 0;\n  while (isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  cin.ignore();\n  for (int i = 0; i < N; i++) {\n    string s;\n    getline(cin, s);\n    State begin = s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  // while (isdigit(s.peek())) {\n    val *= 10;\n    val += s.peek() - '0';\n    // s.next();\n  // }\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint p;\n\nint exp();\nint factor();\nint term();\n\nint factor() {\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n\n  if (str[p] == '('){\n    p++;\n    num = exp();\n  }\n  if(str[p] == ')'){\n    p++;\n  } \n  return num;\n}\n\nint term(){\n int val = factor();\n  while(str[p] == '*' || str[p] == '/') {\n    if(str[p] == '*') {\n      p++;\n      val *= factor();\n    } else if(str[p] == '/'){\n      p++;\n      val /= factor();\n    }\n  }\n\n  return val;\n}\n \nint exp() {\n  int val = term();\n  while(str[p] == '+' || str[p] == '-') {\n    if(str[p] == '+') {\n      p++;\n      val += term();\n    } else if(str[p] == '-'){\n      p++;\n      val -= term();\n    }\n  }\n\n  return val;\n}\n\nint main() {\n  int n;\n\n  cin >> n;\n  \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\n#include <complex>\n#include <utility>\n#include <numeric>\n#define  rep(i,n) for(int i=0;i<(n);i++)\n#define  REP(i,a,n) for(int i=a;i<(n);i++)\n#define  rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define  VI\tvector<int>\n#define\t VS vector<string>\n#define  all(a) (a).begin(),(a).end()\n#define  debug(x) cout<<#x<<\": \"<<x<<endl\nusing namespace std;\ntypedef long long ll;\n\nconst int INF=1e9;\nchar fi[101][101];\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\ndouble EPS = 1e-10;\nint N,M;\nint sx,sy;\nint gx,gy;\nint w,h;\nint ans;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int MAX_V=100;\nconst int MAX_N=100;\nchar o[3]={'+','-','*'};\n#define md 1000003\n\n\nint dp[353][353]={0};\nint bow[353][353]={0};\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))\n\treturn 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\t\tP(double x,double y):x(x),y(y){\n\t\t}\n\t\tP operator + (P p){\n\t\t\treturn P(add(x,p.x),add(y,p.y));\n\t\t}\n\t\tP operator - (P p){\n\t\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t\t}\n\t\tP operator *(double d){\n\t\t\treturn P(x*d,y*d);\n\t\t}\n\t\tdouble dot(P p){\n\t\t\treturn add(x*p.x,y*p.y);\n\t\t}\n\t\tdouble det(P p){\n\t\t\treturn add(x*p.y,-y*p.x);\n\t\t}\n};\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x) return p.x<q.x;\n\treturn p.y<q.y;\n}\n\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps,ps+n,cmp_x);\n\tint k=0;\n\tvector<P> \tqs(n*2);\n\t\n\trep(i,n){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint n,m;\nvector<double> p;\nP ps[101];\nchar c[520][520];\nlong long mod=1000000007;\nlong long pow(ll i,ll j){\n\tll tmp=1;\n\twhile(j){\n\t\tif(j%2) tmp=tmp*i%mod;\n\t\ti=i*i%mod;\n\t\tj/=2;\n\t}\n\treturn tmp;\n}\nint cards[10];\nbool ok;\nvoid saiki(int deep){\n\tif(deep==4){\n\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i=1;i<=7;i++){\n\t\tif(cards[i]>0&&cards[i+1]>0&&cards[i+2]>0){\n\t\t\tcards[i]--;\n\t\t\tcards[i+1]--;\n\t\t\tcards[i+2]--;\n\t\t\tsaiki(deep+1);\n\t\t\tcards[i]++;\n\t\t\tcards[i+1]++;\n\t\t\tcards[i+2]++;\n\t\t}\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tif(cards[i]>2){\n\t\t\t\tcards[i]-=3;\n\t\t\t\tsaiki(deep+1);\n\t\t\t\tcards[i]+=3;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\t\n\tint n;\n\tcin>>n;\n\twhile(n>0){\n\t\tstack<string> a;\n\tstring s;\n\t\tcin>>s;\n\t\tstring tmp=\"\";\n\t\trep(i,s.size()){\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\t\t\t\ttmp+=s[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!a.empty()&&s[i]!='('){\n\t\t\t\tstring o=a.top();\n\t\t\t\t\tint k=0;\n\t\t\t\tif(o==\"*\"){\n\t\t\t\t\ta.pop();\n\t\t\t\t\tk=stoi(tmp)*stoi(a.top());\n\t\t\t\t\ta.pop();\n\t\t\t\t\ttmp=to_string(k);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(o==\"/\"){\n\t\t\t\t\ta.pop();\n\t\t\t\t\tk=stoi(a.top())/stoi(tmp);\n\t\t\t\t\ta.pop();\n\t\t\t\t\ttmp=to_string(k);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(tmp!=\"\"){\n\t\t\t\ta.push(tmp);\n\t\t\t\ttmp=\"\";\n\t\t\t\t}\n\t\t\t\t\tif(s[i]==')'){\n\t\t\t\t\t\tint k=stoi(a.top());\n\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\t\tif(a.top()==\"(\"){\n\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\tif(!a.empty()){\n\t\t\t\t\t\t\t\t\t\t\tif(a.top()==\"*\"){\n\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tk=stoi(a.top())*k;\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if(a.top()==\"/\"){\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t\tk=stoi(a.top())/k;\n\t\t\t\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ta.push(to_string(k));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\t\tif(a.top()==\"+\"){\n\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\tk=k+stoi(a.top());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(a.top()==\"-\"){\n\t\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\tk=stoi(a.top())-k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ta.pop();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\telse if(s[i]!='='){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i==0&&s[i]=='-')\n\t\t\t\t\t\t\t\ttmp+=s[i];\n\t\t\t\t\t\t\telse if(s[i+1]=='-'){\n\t\t\t\t\t\t\t\ttmp+=s[i+1];\n\t\t\t\t\t\t\t\tstring c=\"\";\n\t\t\t\t\t\t\tc+=s[i++];\n\t\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstring c=\"\";\n\t\t\t\t\t\t\tc+=s[i];\n\t\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\tint ans=stoi(a.top());\n\t\t\ta.pop();\n\t\t\twhile(!a.empty()){\n\t\t\t\tif(a.top()==\"+\"){\n\t\t\t\ta.pop();\n\t\t\t\t\tans=ans+stoi(a.top());\n\t\t\t\t}\n\t\t\t\telse if(a.top()==\"-\"){\n\t\t\t\ta.pop();\n\t\t\t\t\tans=stoi(a.top())-ans;\n\t\t\t\t}\n\t\t\t\ta.pop();\n\t\t\t\t\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t\tn--;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,char> P;\n\nint calc(int a, int b, char ope) {\n\tint ret;\n\tswitch(ope) {\n\tcase '+': ret = a + b; break;\n\tcase '-': ret = a - b; break;\n\tcase '*': ret = a * b; break;\n\tcase '/': ret = a / b; break;\n\tdefault: ret = 0;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n, v, sv; string s; char c, ope, sope;\n\tstack<P> st;\n\tcin >> n;\n\twhile(n--) {\n\t\tcin >> s; v = 0; ope = '#';\n\t\tfor(int i=0; i<(signed)s.length(); ++i) {\n\t\t\tc = s[i];\n\t\t\tif('0'<=c && c<='9') {\n\t\t\t\t\n\t\t\t\tv = v*10+(int)(c-'0');\n\t\t\t}else if(c=='('){\n\t\t\t\tst.push(P(0,'#'));\n\t\t\t\tv = 0;\n\t\t\t}else if(c==')'){\n\t\t\t\twhile(!st.empty()) {\n\t\t\t\t\tsv=st.top().first; sope=st.top().second; st.pop();\n\t\t\t\t\tif(sope=='#') break;\n\t\t\t\t\tv = calc(sv, v, sope);\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tif(c=='=') break;\n\t\t\t\tope = c;\n\t\t\t\tif(st.empty()) {\n\t\t\t\t\tst.push(P(v,ope)); v=0;\n\t\t\t\t}else {\n\t\t\t\t\tsv=st.top().first; sope=st.top().second;\n\t\t\t\t\tif(((sope=='+'||sope=='-')&&(ope=='*'||ope=='/'))||sope=='#') {\n\t\t\t\t\t\tst.push(P(v,ope)); v=0;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tv = calc(sv, v, sope);\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tst.push(P(v,ope));\n\t\t\t\t\t\tv=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!st.empty()) {\n\t\t\tsv=st.top().first; sope=st.top().second; st.pop();\n\t\t\tv = calc(sv, v, sope);\n\t\t}\n\t\tcout << v << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {-1,0,1,0};\n\nP equation(const string &str, int pos=0);\nP factor(const string &str, int pos = 0);\nP term(const string &str, int pos = 0);\n\nP equation(const string &str, int pos){\n\tP res = factor(str,pos);\n\twhile(str[res.second] == '+'){\n\t\tP res_ = factor(str,res.second+1);\n\t\tres.first += res_.first;\n\t\tres.second = res_.second;\n\t}\n\n\twhile(str[res.second] == '-'){\n\t\tP res_ = factor(str,res.second+1);\n\t\tres.first -= res_.first;\n\t\tres.second = res_.second;\n\t}\n\treturn res;\n}\n\nP factor(const string &str, int pos) {\n\tP res = term(str, pos);\n\twhile (str[res.second] == '*') {\n\t\tP res_ = term(str, res.second+1);\n\t\tres.first *= res_.first;\n\t\tres.second = res_.second;\n\t}\n\n\twhile (str[res.second] == '/') {\n\t\tP res_ = term(str, res.second+1);\n\t\tres.first /= res_.first;\n\t\tres.second = res_.second;\n\t}\n\treturn res;\n}\n\nP term(const string &str, int pos) {\n\tif(str[pos] == '('){\n\t\tP res = equation(str,pos+1);\n\t\tres.second += 1;\n\t\treturn res;\n\t} else {\n\t\tint val = 0;\n\t\twhile(isdigit(str[pos])){\n\t\t\tval = val * 10 + (str[pos++]-'0');\n\t\t}\n\t\treturn P(val,pos);\n\t}\n}\n\n\nint main(){\n\tstring str;\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>str;\n\t\tP res = equation(str);\n\t\tcout << res.first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::const_iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\tfor(int i = 0; i < N; ++i){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\tState begin = s.begin();\n\t\ts[s.size()-1]='\\0';\n\t\tint ans = expression(begin);\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nint formula(string &s, int &i);\nint term(string &s, int &i);\nint factor(string &s, int &i);\nint number(string &s, int &i);\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint num = 0;\n\t\tcout << formula(s, num) << endl;\n\t}\n\treturn 0;\n}\n\nint formula(string &s, int &i) {\n\tint res = term(s, i);\n\twhile(s[i]=='+' || s[i]=='-'){\n\t\tchar op = s[i];\n\t\ti++;\n\t\tif (op == '+') {\n\t\t\tres += term(s, i);\n\t\t}\n\t\telse {\n\t\t\tres -= term(s, i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint term(string &s, int &i) {\n\tint res = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tif (op == '*') {\n\t\t\tres *= factor(s, i);\n\t\t}\n\t\telse {\n\t\t\tres /= factor(s, i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint factor(string &s, int &i) {\n\tint res;\n\tif (s[i] == '(') {\n\t\ti++;\n\t\tres = formula(s, i);\n\t\ti++;\n\t}\n\telse {\n\t\tres = number(s, i);\n\t}\n\treturn res;\n}\n\nint number(string &s, int &i) {\n\tint res = 0;\n\tfor (; isdigit(s[i]); i++) {\n\t\tres = (s[i]-'0')+ res * 10;\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint r;\nint i;\nint sd(char *s, int m){\n    int n = 0, d = 0;\n    for(;s[i] != '\\0';){\n        switch(s[i]){\n        case '=':\n            return n;\n        case '+':\n            if(m == 1)\n                return n;\n            i++;\n            return n + sd(s, 2);\n        case '-':\n            if(m == 1)\n                return n;\n            i++;\n            return n - sd(s, 2);\n        case '*':\n            i++;\n            return n * sd(s, 1);\n        case '/':\n            i++;\n            return n / sd(s, 1);\n        case '(':\n            i++;\n            return sd(s, 0);\n        case ')':\n            i++;\n            return n;\n        default:\n            n = n * 10 + s[i] - '0';\n            i++;\n            break;\n        }\n    }\n}\n\nint main(void)\n{\n    int N;\n\n    char str[1024];\n\n    cin >> N;\n\n    for(int k = 0; k < N; k++){\n        r = 0;\n        i = 0;\n        cin >> str;\n        printf(\"%d\\n\", sd(str, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<string>\n \n using namespace std;\n \n int expression();\n int term();\n int factor();\n \n string exp;\n int p;\n \n int expression(){\n     int value = term();\n     while( exp[p] == '+' || exp[p] == '-' ){\n         if ( exp[p] == '+' ) { p++; value += term(); }\n         else { p++; value -= term(); }\n     }\n     return value;\n }\n \n int term(){\n     int value = factor();\n     while( exp[p] == '*' || exp[p] == '/' ){\n         if ( exp[p] == '*' ) { p++; value *= factor(); }\n         else { p++; value /= factor(); }\n     }\n     return value;\n }\n \n int factor(){\n     int value = 0;\n     if ( exp[p] == '(' ){\n         p++; value = expression(); p++;\n     } else {\n         while( isdigit(exp[p]) ) { value = value*10 + exp[p++] - '0';}\n     }\n     return value;\n }\n \n int main(){\n     int tcase; cin >> tcase;\n     for ( int i = 0; i < tcase; i++ ){\n         cin >> exp;\n         p = 0;\n         cout << expression() << endl;\n     }\n     return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\nusing namespace std;\nstring S;\nsize_t cur = 0;\n\nint digit() {\n    assert(isdigit(S[cur]));\n    int n = S[cur++] - '0';\n    return n;\n}\n\nint number() {\n    int n = digit();\n    while(cur < S.size() && isdigit(S[cur])) {\n        n = n*10 + digit();\n    }\n    return n;\n}\n\nint expression();\nint factor() {       //Factor := '(' Expression ')' | Number\n    if(S[cur] != '(') return number();\n    cur++;\n    int n = expression();\n    assert(S[cur] == ')');\n    cur++;\n    return n;\n}\n\nint term() {       //Term := Factor { ('*'|'/') Factor }\n    int a = factor();\n    while(cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n        char op = S[cur++];\n        int b = factor();\n        if(op =='*') { a *= b; } else { a /= b; }\n    }\n    return a;\n}\n\nint expression() {       //Expression := Term { ('+'|'-') Term}\n    int a = term();\n    while(cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n        char op = S[cur++];\n        int b = term();\n        if(op == '+') { a += b; } else { a -= b;}\n    }\n    return a;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for(int i=0; i<N; i++) {\n        cur = 0;\n        cin >> S;\n        S.resize(S.size() - 1);\n        cout << expression() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint factor(State &begin);\n\nint number(State &begin){\n    int ret=0;\n\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin -'0';\n        begin++;\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n\n    while(true){\n        if(*begin=='*')ret*=factor(++begin);\n        else if(*begin=='/')ret/=factor(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret=term(begin);\n\n    while(true){\n        if(*begin=='+')ret+=term(++begin);\n        else if(*begin=='-')ret-=term(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin=='('){\n        int ret=expression(++begin++);\n    }else{\n        return number(begin);\n    }\n}\n\n\n\n\n\nint main(){\n\n    int N;\n    cin>>N;\n    cin.ignore();\n    REP(i,N){\n\n        string s;\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\tif(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\n\tif(op.size()>=2){\n\t\tchar op1,op2;\n\t\top1=op.top();op.pop();op2=op.top();\n\t\top.push(op1);\n\t\tif(order[op1]<order[op2])\n\t\t\tcalc();\n\t}\n\t//cout << num.top() << endl;//\n\t//int tmp=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\ndouble calc2(char *eq){\n\tlong c=0, sign[100]={0};\n\tdouble num[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\nlong calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\twhile((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tbuf[p2-p]=0;\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn (long)calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint expression(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\n\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n\n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    int ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=number(begin);\n\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n  }\n  else return number(begin);\n}\n\nint number(State &begin){\n  int ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst signed INF_=1001001001; const ll INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\n/*\n<expression> ::= <term> | <term> ('+' | '-') <term>\n<term> ::= <factor> | <factor> ('*' | '/') <factor>\n<factor> ::= <number> | '(' <expression> ')'\n<number> ::= 0~9 | <number> <number>\n*/\nint expression(string &s,int &i);\nint term(string &s,int &i);\nint factor(string &s,int &i);\nint number(string &s,int &i);\n\nint expression(string &s,int &i) {\n    int ret=term(s,i);\n    while(s[i]=='+' || s[i]=='-') {\n        char op=s[i++];\n        int right=term(s,i);\n        if(op=='+') ret+=right;\n        else ret-=right;\n    }\n    return ret;\n}\nint term(string &s,int &i) {\n    int ret=factor(s,i);\n    while(s[i]=='*' || s[i]=='/') {\n        char op=s[i++];\n        int right=factor(s,i);\n        if(op=='*') ret*=right;\n        else ret/=right;\n    }\n    return ret;\n}\nint factor(string &s,int &i) {\n    if(s[i]=='(') {\n        i++;\n        int expr=expression(s,i);\n        i++;\n        return expr;\n    } else {\n        return number(s,i);\n    }\n}\nint number(string &s,int &i) {\n    int num=0;\n    while('0'<=s[i] && s[i]<='9') {\n        num*=10;\n        num+=s[i]-'0';\n        i++;\n    }\n    return num;\n}\n\nint solve() {\n    string s=IN;\n    int i=0;\n    return expression(s,i);\n}\nsigned main() {\n    int n=IN;\n    while(n--) {\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype> // isdigit\n#include<cassert> // assert\nusing namespace std;\n\nstruct Result{int value,pos;};\n\nint calculate(string expression);\nResult equation(string expression,int pos);\nResult factor(string expression,int pos);\nResult term(string expression,int pos);\n\nint calculate(string expression)\n{\n  return equation(expression,0).value;\n}\n\nResult equation(string expression,int pos)\n{\n  Result r=factor(expression,pos);\n  // Á¸Z\n  while(expression[r.pos]=='+' || expression[r.pos]=='-'){\n    Result _r=factor(expression,r.pos+1);\n    if(expression[r.pos]=='+')r.value += _r.value;\n    if(expression[r.pos]=='-')r.value -= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult factor(string expression,int pos)\n{\n  Result r=term(expression,pos);\n  // æZ\n  while(expression[r.pos]=='*' || expression[r.pos]=='/'){\n    Result _r=term(expression,r.pos+1);\n    if(expression[r.pos]=='*')r.value *= _r.value;\n    if(expression[r.pos]=='/')r.value /= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult term(string expression,int pos)\n{\n  Result r;\n  // l\n  if(isdigit(expression[pos])){\n    int value=0;\n    while(isdigit(expression[pos]))value += value*10 + expression[pos++]-'0';\n    r.value=value;\n    r.pos=pos;\n    return r;\n  }\n  // PZqÌ}CiX\n  if(expression[pos]=='-'){\n    r=equation(expression,pos+1);\n    r.value*=-1;\n    return r;\n  }\n  // Ê\n  if(expression[pos]=='('){\n    r=equation(expression,pos+1);\n    assert(expression[r.pos++]==')');\n    return r;\n  }\n}\n\nint main()\n{\n  int n;\n  string s;\n  cin>>n;\n  while(n-->0){\n    cin>>s;\n    s=s.substr(0,s.size()-1);\n    cout<<calculate(s)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<ll, string> PLS;\n\nint n;\nstring s;\n\nint changei(string t){\n\tint res;\n\tstringstream ss;\n\tss << t;\n\tss >> res;\n\treturn res;\n}\n\nstring changes(int num){\n\tstring res;\n\tstringstream ss;\n\tss << num;\n\tss >> res;\n\treturn res;\n}\n\nstring s_calc(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\tif (res[i] == '*' || res[i] == '/'){\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\tif (j != 0){\n\t\t\t\t\t\tsize1 = res.substr(j + 1, i - j - 1).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = i;\n\t\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (j != i + 1){\n\t\t\t\t\tif (res[j] == '+' || res[j] == '-' || res[j] == '*' || res[j] == '/'){\n\t\t\t\t\t\tif (res[i] == '*')num1 *= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '*'){\n\t\t\t\t\t\tnum1 *= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\t}\n\t\t\t\t\telse num1 /= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t}\n\n\t//cout << \"!!\" << res << endl;\n\n\tREP(i, res.size()){\n\t\tif (res[i] == '+' || res[i] == '-'){\n\t\t\tif (i == 0)continue;\n\t\t\tint num1, pos1, pos2, size1, size2;\n\t\t\tfor (int j = i - 1;; j--){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (j != 0)num1 = changei(res.substr(j + 1, i - j - 1));\n\t\t\t\t\telse {\n\t\t\t\t\t\tpos1 = j;\n\t\t\t\t\t\tsize1 = res.substr(j, i - j).size();\n\t\t\t\t\t\tnum1 = changei(res.substr(j, i - j));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == 0){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\tsize1 = res.substr(0, i).size();\n\t\t\t\t\tnum1 = changei(res.substr(0, i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos1 = j;\n\t\t\t}\n\t\t\tfor (int j = i + 1;; j++){\n\t\t\t\tif (res[j] == '+' || res[j] == '-'){\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1)));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == res.size() - 1){\n\t\t\t\t\tpos2 = j;\n\t\t\t\t\tif (res[i] == '+')num1 += changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\telse num1 -= changei(res.substr(i + 1, j - (i + 1) + 1));\n\t\t\t\t\tsize2 = changes(num1).size();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos2 = j;\n\t\t\t}\n\t\t\tif (pos2 != res.size() - 1){\n\t\t\t\tres = res.substr(0, pos1) + changes(num1)\n\t\t\t\t\t+ res.substr(pos2 + 1, res.size() - 1 - pos2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = res.substr(0, pos1) + changes(num1);\n\t\t\t}\n\t\t\ti = i - size1 + size2 - 1;\n\t\t}\n\t\t//cout << t << endl;\n\t}\n\treturn res;\n}\n\nstring solve(string t){\n\tstring res = t;\n\tREP(i, res.size()){\n\t\t//cout << \"!!\" << i  << endl;\n\t\t//cout << res << endl;\n\t\tint pos1, pos2, size;\n\t\tif (res[i] == ')'){\n\t\t\tpos2 = i;\n\t\t\tfor (int j = i; j >= 0; j--){\n\t\t\t\tif (res[j] == '('){\n\t\t\t\t\tpos1 = j;\n\t\t\t\t\t//cout << res.substr(pos1 + 1, pos2 - pos1 - 1) << endl;\n\t\t\t\t\tstring buf = s_calc(res.substr(pos1 + 1, pos2 - pos1 - 1));\n\t\t\t\t\tsize = buf.size();\n\t\t\t\t\tif (pos2 == res.size() - 1)res = res.substr(0, pos1) + buf;\n\t\t\t\t\telse res = res.substr(0, pos1) + buf + res.substr(pos2 + 1, res.size() - pos2 - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = pos1 + size - 1;\n\t\t\t//cout << \"!\" << i << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main(){\n\tcin >> n;\n\tREP(i, n){\n\t\tcin >> s;\n\t\ts.pop_back();\n\t\tcout << s_calc(solve(s)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num;\nstack<char> op;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&& order[S[cur]] > order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\twhile(!op.empty()&&op.top()!='(')\n\t\t\t\tcalc();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\t//cout << op.top() << endl;\n\twhile(!op.empty())\n\t\tcalc();\n\treturn num.top();\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n             int nu;\n             cin >> nu;\n\twhile(nu--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ntemplate <class _Tt>\nclass calculate {\npublic:\n    enum op {NUM,ADD,SUB,MUL,DIV,LPA,RPA};\nprivate:\n    typedef pair<op, _Tt> pt; \n    deque<pt> mq;\n    void popf(deque<pt> &q, op &type, _Tt &num){\n        type = q.front().first; num = q.front().second;\n        q.pop_front();\n    }\n    void popb(deque<pt> &q, op &type, _Tt &num){\n        type = q.back().first; num = q.back().second;\n        q.pop_back();\n    }\n    _Tt cal2(deque<pt> &q){\n        op sop, dop; _Tt snum, dnum, num = 0;\n        while(!q.empty()){\n            popf(q, sop, snum);\n            switch(sop){\n            case NUM: num = snum; break;\n            case ADD: case SUB:\n                popf(q, dop, dnum); dbgchk(dop != NUM);\n                num = (sop == ADD) ? num+dnum : num-dnum;\n                break;\n            default: throw;\n            }\n        }\n        return num;\n    }\n    _Tt cal(deque<pt> &q){\n        deque<pt> s;\n        while(!q.empty()){\n            op qop; _Tt num;\n            popf(q, qop, num);\n            switch(qop){\n            case NUM: case ADD: case SUB:\n                s.pb(mp(qop,num)); break;\n            case LPA:\n                s.pb(mp(NUM,cal(q))); break;\n            case RPA:\n                return cal2(s); break;\n            case MUL: case DIV:\n                op sop, dop; _Tt snum, dnum;\n                popb(s, sop, snum); dbgchk(sop != NUM);\n                popf(q, dop, dnum); dbgchk(dop != NUM && dop != LPA);\n                if(dop == LPA) dnum = cal(q);\n                _Tt r = (qop == MUL) ? snum*dnum : snum/dnum;\n                s.pb(mp(NUM,r));\n                break;\n            }\n        }\n        return cal2(s);\n    }\npublic:\n    void add(_Tt n){ mq.pb(mp(NUM,n)); }\n    void add(op opr){ mq.pb(mp(opr,0)); }\n    _Tt result(){ return cal(mq); }\n};\n\nvoid solve(string s){\n    int n = s.length();\n    calculate<int> calc;\n    int num = 0;\n    REP(i,n){\n        if(isdigit(s[i])){\n            num = num * 10 + (s[i]-'0');\n            continue;\n        }\n        calc.add(num);\n        if(s[i] == '=') break;\n        switch(s[i]){\n        case '+': calc.add(calc.ADD); break;\n        case '-': calc.add(calc.SUB); break;\n        case '*': calc.add(calc.MUL); break;\n        case '/': calc.add(calc.DIV); break;\n        case '(': calc.add(calc.LPA); break;\n        case ')': calc.add(calc.RPA); break;\n        }\n        num = 0;\n    }\n    cout << calc.result() << endl;\n}\n\nint main(){\n    int n;\n    string s; getline(cin, s);\n    istringstream ss(s); ss >> n;\n    REP(i,n){\n        getline(cin, s);\n        solve(s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nclass calculate {\nprivate:\n    typedef string::const_iterator st;\n    int num(st &s){\n        int ret = 0;\n        while(isdigit(*s)){\n            ret = ret * 10 + (*s - '0'); s++;\n        }\n        return ret;\n    }\n    int factor(st &s){\n        int ret = 0;\n        if(*s == '('){\n            s++;\n            ret = expr(s);\n            s++;\n        } else {\n            ret = num(s);\n        }\n        return ret;\n    }\n    int term(st &s){\n        int ret = factor(s);\n        while(1){\n            if(*s == '*'){\n                s++; ret *= factor(s);\n            } else if(*s == '/') {\n                s++; ret /= factor(s);\n            } else break;\n        }\n        return ret;\n    }\n    int expr(st &s){\n        int ret = term(s);\n        while(1){\n            if(*s == '+'){\n                s++; ret += term(s);\n            } else if(*s == '-'){\n                s++; ret -= term(s);\n            } else break;\n        }\n        return ret;\n    }\npublic:\n    int calc(string s){ st ss = s.begin(); return expr(ss); }\n};\n\nint main(){\n    int n;\n    cin >> n; cin.ignore();\n    calculate c;\n    REP(i,n){\n        string s;\n        getline(cin, s);\n        cout << c.calc(s) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <cstddef>\n\nusing namespace std;\n\n\n// ?????????????§?????§£???????????????????????¨???????????????\nclass MathExpress\n{\nprivate:\n    string m_express;\n    size_t m_cur = 0;\n\npublic:\n    MathExpress(string str) : m_express(str) \n    {\n        m_express.resize(m_express.size() - 1);\n    }\n\n    int digit(); // ???????????°???\n    int number(); // ??°??????????????°????????´???\n    int term();\n    int factor(); \n    int expression();\n};\n\n\nint MathExpress::digit()\n{\n    assert(isdigit(m_express.at(m_cur)));\n\n    int n = m_express.at(m_cur) - '0';\n\n    m_cur += 1;\n\n    //cout << \"digit: \" << n << endl;\n\n    return n;\n}\n\n\nint MathExpress::number()\n{\n    int num = digit();\n\n    while ( m_cur < m_express.size() && isdigit(m_express.at(m_cur)) )\n    {\n        num = num * 10 + digit();\n    }\n\n    //cout << \"number: \" << num << endl;\n\n    return num;\n}\n\n\nint MathExpress::term()\n{\n    int left = factor();\n\n    while (m_cur < m_express.size() \n         && (m_express.at(m_cur) == '*' || m_express.at(m_cur) == '/'))\n    {\n        char op = m_express.at(m_cur++);\n\n        //cout << op << endl;\n\n        int right = number();\n\n        switch (op) {\n            case '*':\n                left *= right;\n                break;\n            case '/':\n                left /= right;\n                break;\n            default:\n                break;\n        }\n\n    }\n\n    //cout << \"term: \" << left << endl;\n\n    return left;\n}\n\n\nint MathExpress::expression()\n{\n    int left = term();\n\n    while (m_cur < m_express.size() \n         && (m_express.at(m_cur) = '+' || m_express.at(m_cur) == '-'))\n    {\n        //cout << m_cur << \" \" << m_express.at(m_cur) << endl;\n        char op = m_express.at(m_cur);\n\n        m_cur += 1;\n\n        //cout << op << endl;\n        //cout << \"hoge\" << endl;\n\n        int right = term();\n\n        //cout << \"hoge\" << endl;\n\n        switch (op) {\n            case '+':\n                //cout << \"hoge\" << endl;\n                left += right;\n                break;\n            case '-':\n                left -= right;\n                break;\n            default:\n                //cout << \"hoge\" << endl;\n                break;\n        }\n\n        //cout << \"left : right = \" << left << \" \" << right << endl;\n    }\n\n    return left;\n}\n\n\nint MathExpress::factor()\n{\n    if (m_express.at(m_cur) != '(') return number();\n\n    m_cur += 1;\n\n    int exp = expression();\n\n    assert (m_express.at(m_cur) == ')');\n\n    m_cur += 1;\n\n    return exp;\n}\n\n\nint main()\n{\n    int data_num;\n    \n    cin >> data_num;\n    \n    cin.clear();\n\n    string val; \n    for (int i = 0; i < data_num; ++i) {\n        cin >> val;\n\n        MathExpress mathexp(val);\n        cout << mathexp.expression() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nsigned main(){\n  string s;\n  int p=0;\n  cin>>s;\n  cout<<expression(s,p)<<endl;\n  return 0;\n}\n\n/*\nverified on 2017/04/26\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id=0109\n*/"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<string>\n \n using namespace std;\n \n int expression();\n int term();\n int factor();\n \n string exp;\n int p;\n \n int expression(){\n     int value = term();\n     if( exp[p] == '+' || exp[p] == '-' ){\n         if ( exp[p] == '+' ) { p++; value += term(); }\n         else { p++; value -= term(); }\n     }\n     return value;\n }\n \n int term(){\n     int value = factor();\n     if( exp[p] == '*' || exp[p] == '/' ){\n         if ( exp[p] == '*' ) { p++; value *= factor(); }\n         else { p++; value /= factor(); }\n     }\n     return value;\n }\n \n int factor(){\n     int value = 0;\n     if ( exp[p] == '(' ){\n         p++; value = expression(); p++;\n     } else {\n         while( isdigit(exp[p]) ) { value = value*10 + exp[p++] - '0';}\n     }\n     return value;\n }\n \n int main(){\n     int tcase; cin >> tcase;\n     for ( int i = 0; i < tcase; i++ ){\n         cin >> exp;\n         p = 0;\n         cout << expression() << endl;\n     }\n     return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n  \n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == ' ')\n      continue;\n    else if(str[i] == '=')\n      break;\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<string>\nusing namespace std;\nint i;\nstring str;\nint Expression();\nint Term();\nint Factor();\nint No(int);\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> str;\n    i = 0;\n    cout << Expression() << endl;\n  }\n}\nint Expression(){\n  int res = Term();\n  while(1){\n    switch(str[i]){\n    case '+':\n      i++;\n      res += Term();\n      break;\n    case '-':\n      i++;\n      res -= Term();\n      break;\n    default:\n      return res;\n    }\n  }\n}\nint Term(){\n  int res = Factor();\n  while(true){\n    switch(str[i]){\n    case '(':\n      i++;\n      res += Factor();\n      break;\n    case '*':\n      i++;\n      res *= Factor();\n      break;\n    case '/':\n      i++;\n      res /= Factor();\n      break;\n    default:\n      return res;\n    }\n  }\n}\nint Factor(){\n  int res = 0;\n  switch(str[i]){\n  case '(':\n    i++;\n    res = Expression();\n    i++;\n    return res;\n  default:\n    return No(i);\n  }\n}\nint No(int old){\n  while(isdigit(str[i])) i++;\n  return atoi((str.substr(old,i)).c_str());\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = fmap<string, int>([](string s) { return stoi(s); }, many1(digit));\n\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                          || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                        || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nint main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint r;\nint i;\nint sd(char *s, int m){\n    int n = 0, d = 0;\n    for(;s[i] != '\\0';){\n        switch(s[i]){\n        case '=':\n            return n;\n        case '+':\n            if(m == 1)\n                return n;\n            i++;\n            return n + sd(s, 2);\n        case '-':\n            if(m == 1)\n                return n;\n            i++;\n            return n - sd(s, 2);\n        case '*':\n            i++;\n            return n * sd(s, 1);\n        case '/':\n            i++;\n            return n / sd(s, 1);\n        case '(':\n            i++;\n            return sd(s, 0);\n        case ')':\n            i++;\n            return n;\n        default:\n            n = n * 10 + s[i] - '0';\n            i++;\n            break;\n        }\n    }\n}\n\nint main(void)\n{\n    int N;\n\n    cin >> N;\n    char str[1024];\n\n\n    for(int k = 0; k < N; k++){\n        r = 0;\n        i = 0;\n        cin >> str;\n        printf(\"%d\", sd(str, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <cstdlib>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '/')\n\t\treturn 1;\n\tif(a == '*')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<long long> & num_stack, stack<char> & op_stack) {\n\tlong long a, b;\n\tlong long c;\n\tchar op;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nlong long clac(string str) {\n\tstack<long long> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tlong long tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t}\n\n\tif(op_stack.size() != 1)\n\t\texit(1);\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst char op[] = \"()*/+-=N\";\n\n\nstring line;\nint cur;\nchar readchar() {\n\treturn line[cur++];\n}\nchar peek() {\n\treturn line[cur];\n}\n\n\nint digit() {\n\treturn readchar() - '0';\n}\nint number() {\n\tint n = digit();\n\twhile ( peek() >= '0' && peek()<='9' ) {\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor() {\n\tif ( peek() != '(' ) { return number(); }\n\tassert( readchar() == '(' );\n\tint ret = expression();\n\tassert( readchar() == ')' );\n\t\n\treturn ret;\n}\n\nint term() {\n\tint ret = factor();\n\twhile( peek() == '*' || peek() == '/' ) {\n\t\tchar op = readchar();\n\t\tint fac = factor();\n\t\t\n\t\tif ( op == '*' ) { ret *= fac; }\n\t\telse { ret /= fac; }\n\t}\n\t\n\treturn ret;\n}\n\nint expression() {\n\tint ret = term();\n\twhile( peek() == '+' || peek() == '-' ) {\n\t\tchar op = readchar();\n\t\tint ter = term();\n\t\t\n\t\tif ( op == '+' ) { ret += ter; }\n\t\telse { ret -= ter; }\n\t}\n\t\n\treturn ret;\n}\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\twhile(N--) {\n\t\tcin >> line;\n\t\tcur = 0;\n\t\t\n\t\tcout << expression() << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef string::const_iterator State;\nint expression(State &begin);\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\nint number(State &begin){\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return -1;\n}\n\nint term(State & begin){\n  int ret = factor(begin);\n  while(true){\n    if(*begin == '*'){\n      begin++;\n      ret *= factor(begin);\n    } else if (*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nint expression(State &begin){\n  int ret = term(begin);\n  while(true){\n    if(*begin == '+'){\n      begin++;\n      ret += term(begin);\n    } else if (*begin == '-') {\n      begin++;\n      ret -= term(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  rep(i,N){\n    string s;\n    cin >> s;\n    if(s.size() > 0) s = s.substr(0,s.size()-1);\n    State begin = s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n// <expression> := <fomula>( ( '+' | '-' )<fomula> )+ '='\n// <fomula> := <atom>( ( '*' | '/' )<atom> )+\n// <atom> := '('<expression>')' | <number>\n// <number> := ( '0' | '1' | ... | '9' )+\n\nPII expression( const string &, int p );\nPII fomula( const string &, int p );\nPII atom( const string &, int p );\nPII number( const string &, int p );\n\nPII expression( const string &s, int p = 0 )\n{\n\tPII res = fomula( s, p );\n\twhile ( string( \"+-\" ).find( s[ res.snd ] ) != string::npos )\n\t{\n\t\tPII r = fomula( s, res.snd + 1 );\n\t\tres.fst += ( s[ res.snd ] == '+' ? 1 : -1 ) * r.fst;\n\t\tres.snd = r.snd;\n\t}\n\treturn res;\n}\n\nPII fomula( const string &s, int p = 0 )\n{\n\tPII res = atom( s, p );\n\twhile ( string( \"*/\" ).find( s[ res.snd ] ) != string::npos )\n\t{\n\t\tPII r = s[ res.snd + 1 ] == '(' ? expression( s, res.snd + 2 ) : number( s, res.snd + 1 );\n\t\tif ( s[ res.snd ] == '*' )\n\t\t{\n\t\t\tres.fst *= r.fst;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres.fst /= r.fst;\n\t\t}\n\t\tres.snd = r.snd;\n\t}\n\treturn res;\n}\n\nPII atom( const string &s, const int p = 0 )\n{\n\tif ( s[p] == '(' )\n\t{\n\t\tPII res = expression( s, p + 1 );\n\t\tres.snd ++;\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\treturn number( s, p );\n\t}\n}\n\nPII number( const string &s, int p )\n{\n\tint res = 0;\n\twhile ( isdigit( s[p] ) )\n\t{\n\t\tres *= 10;\n\t\tres += s[ p++ ] - '0';\n\t}\n\treturn MP( res, p );\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n;\n\tcin >> n;\n\n\tREP( i, 0, n )\n\t{\n\t\tstring line;\n\t\tcin >> line;\n\t\tcout << expression( line ).fst << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstring str;\nint cur = 0;\n\nint expression();\nint term();\nint factor();\n\nint digit() {\n    int a = str[cur] - '0';\n    cur++;\n    return a;\n}\n\nint number() {\n    int a = digit();\n    while (cur < str.size() && isdigit(str[cur])) {\n        a = a * 10 + digit();\n    }\n    return a;\n}\n\nint expression() {\n    int a = term();\n    while (cur < str.size() && (str[cur] == '+' || str[cur] == '-')) {\n        if (str[cur] == '+') {\n            cur++;\n            int b = term();\n            a += b;\n        } else if (str[cur] == '-') {\n            cur++;\n            int b = term();\n            a -= b;\n        }\n    }\n    return a;\n}\n\nint term() {\n    int a = ((str[cur] == '(') ? factor() : number());\n    while (cur < str.size() && (str[cur] == '*' || str[cur] == '/')) {\n        if (str[cur] == '*') {\n            cur++;\n            int b = ((str[cur] == '(') ? factor() : term());\n            a *= b;\n        } else if (str[cur] == '/') {\n            cur++;\n            int b = ((str[cur] == '(') ? factor() : term());\n            a /= b;\n        }\n    }\n    return a;\n}\n\nint factor() {\n    cur++;\n    int a = expression();\n    cur++;\n    return a;\n}\n\nint main() {\n    int N = 0;\n    cin>>N;\n    for (int n = 0; n < N; n++) {\n        cin>>str;\n        cur = 0;\n        cout<<expression()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint p;\nstring exp;\n\nint term();\nint expression();\nint factor();\n\n\nint expression(){\n     int value;\n\t value=term();\n\t while(exp[p]=='+' || exp[p]=='-'){\n\t\t if(exp[p]=='+'){\n\t\t\t p++;\n\t\t\t value+=term();\n\t\t }\n\t\t else{\n\t\t\t p++;\n\t\t\t value-=term();\n\t\t }\n\t }\n\t return value;\n}\n\n\nint term(){\n\tint value;\n\tvalue=factor();\n\twhile(exp[p]=='*' || exp[p]=='/'){\n\t\tif(exp[p]=='*'){\n\t\t\tp++;\n\t\t\tvalue*=factor();\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\tvalue/=factor();\n\t\t}\n\t}\n\n\treturn value;\n}\n\nint factor(){\n\tint value=0;\n\tif(exp[p]=='('){\n\t\tp++;\n\t\tvalue=expression();\n\t\tp++;\n\t}\n\telse{\n\t\twhile(isdigit(exp[p])){\n\t\t\tvalue=value*10+exp[p++]-'0';\n\t\t}\n\t}\n\treturn value;\n}\n\n\n\nint main()\n{\n\tint i,c;\n\tcin>>c;\n\tfor(i=0;i<c;i++){\n\t\tcin>>exp;\n\t\tp=0;\n\t\tcout<<expression()<<\"\\n\";\n\t\t}\n\tcout<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n\n  void init(){ pos=0;len=s.size();}\n\n  int head2Num(){\n    bool f=false;\n    if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    int res;\n    if(s[pos]=='('){\n      pos++;\n      res = getAns();\n    }else if(s[pos]=='-'||isNum(s[pos])){\n      res=head2Num();\n    }\n    \n    if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }else{\n      return res;\n    }\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else assert(0);\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n\ntypedef std::stringstream sst;\n\nint ToInt(std::string str){\n\tint i;\n\tsst ss;\n\tss<<str;\n\tss>>i;\n\treturn i;\n}\nstd::string ToStr(int i){\n\tstd::string str;\n\tsst ss;\n\tss<<i;\n\tss>>str;\n\treturn str;\n}\n\nstd::string SubStr(std::string str,int x,int y){\n\treturn str.substr(x,y-x+1);\n}\nint Third(std::string str){\n\tint fres,Ans;\n\twhile( ( fres=str.find_first_of(\"+-\") ) != std::string::npos && fres!=0 ){\n\t\tint aRes;\n\t\t\n\t\tif( (aRes=str.find_first_of(\"+-\",fres+2)) == std::string::npos )\n\t\t\taRes=str.size()-1;\n\t\telse --aRes;\n\t\t\n\t\tif( str[fres] =='+' ){\n\t\t\tAns=ToInt(SubStr(str,0,fres-1))+ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n\t\t}else{\n\t\t\tAns=ToInt(SubStr(str,0,fres-1))-ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n\t\t}\n\t}\n\treturn ToInt(str);\n}\n\nint Second(std::string str){\n\tint fres,Ans;\n\twhile( ( fres=str.find_first_of(\"*/\") ) != std::string::npos ){\n\t\tint bRes,aRes;\n\t\tif( (bRes=str.find_last_of(\"+-\",fres)) == std::string::npos  || bRes==0 )\n\t\t\tbRes=0;\n\t\telse ++bRes;\n\t\t\n\t\tif( (aRes=str.find_first_of(\"+-*/\",fres+2)) == std::string::npos )\n\t\t\taRes=str.size()-1;\n\t\telse --aRes;\n\t\t\n\t\tif( str[fres] =='*' ){\n\t\t\tAns=ToInt(SubStr(str,bRes,fres-1))*ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n\t\t}else{\n\t\t\tAns=ToInt(SubStr(str,bRes,fres-1))/ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n\t\t}\n\t}\n\tAns=Third(str);\n\treturn Ans;\n}\n\nint First(std::string str){\n\tint fres;\n\twhile( (fres = str.find(\")\") ) != std::string::npos ){\n\t\tint rfres=str.rfind(\"(\",fres);\n\t\tstd::string Next=SubStr(str,rfres+1,fres-1);\n\t\tint cRes=Second(Next);\n\t\tstr.replace(rfres,Next.size()+2,ToStr(cRes).c_str());\n\t}\n\tint lRes = Second(str);\n\t\n\treturn lRes;\n}\n\nint main(){\n\tint n;\n  std::string str;\n\tstd::cin>>n;\n\twhile( n-- ){\n\t\tstd::cin>>str;\n\t  std::cout<<First(str)<<std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a){\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\trep(i, s.first)rep(j, s.second)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a=0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}　\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nint g(string &s, int &p);\nint f(string &s, int &p) {\n\tint k = 0;\n\tint m = 1;\n\twhile (s[p] != ')' && s[p] != '=') {\n\t\tswitch (s[p]) {\n\t\t//case '(':\n\t\t//\tp++;\n\t\t//\tk += m*f(s, p);\n\t\t//\tp++;\n\t\t//\tbreak;\n\t\tcase '-':\n\t\t\tm = -1;\n\t\t\tp++;\n\t\t\tk -= g(s, p);\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tm = 1;\n\t\t\tp++;\n\t\t\tk += g(s, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tk += m*g(s, p);\n\t\t}\n\t}\n\treturn k;\n}\nint g(string &s, int &p) {\n\tint k = 1;\n\tbool div = 0;\n\twhile (s[p] != ')' && s[p] != '+' && s[p] != '-' && s[p] != '=') {\n\t\tswitch (s[p]) {\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tif (div)k /= f(s, p);\n\t\t\telse k *= f(s, p);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tdiv = 0;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tdiv = 1;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tint num = 0;\n\t\t\twhile (isdigit(s[p])) {\n\t\t\t\tnum = num * 10 + s[p] - '0';\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (div)k /= num;\n\t\t\telse k *= num;\n\t\t}\n\t}\n\treturn k;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint p = 0;\n\t\tcout << f(s, p) << endl;\n\t}\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\n\tstruct node {\n\t\tmap<char,unique_ptr<node>> next;\n\t\tnode* fail = nullptr, *match_list = nullptr;\n\t\tstd::vector<int> match;\n\t}root;\n\tint pattern;\n\t//template<class string>\n\tAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\n\t\troot.fail = &root;\n\t\tfor (int i = 0; i < vs.size(); i++) {\n\t\t\tnode* now = &root;\n\t\t\tfor (auto c : vs[i]) {\n\t\t\t\tif (!now->next[c])now->next[c]=make_unique<node>();\n\t\t\t\tnow = now->next[c].get();\n\t\t\t}\n\t\t\tnow->match.push_back(i);\n\t\t}\n\t\tstd::queue<node*> que;\n\t\tque.push(&root);\n\t\twhile (!que.empty()) {\n\t\t\tauto now = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto &next : now->next) {\n\t\t\t\tif (!next.second)continue;\n\t\t\t\tif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\n\t\t\t\telse next.second->fail = now->fail->fail;\n\t\t\t\t//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\n\t\t\t\tif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\n\t\t\t\telse next.second->match_list = next.second->fail;\n\t\t\t\tque.push(next.second.get());\n\t\t\t}\n\t\t}\n\t}\n\tauto match_n(string str) {\n\t\tvector<int> num(pattern);\n\t\t\n\t}\n\tauto match_list(string str) {\n\t\tvector<pair<int, int>> list;\n\t\tauto now = &root;\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\tif (now->next.count(str[i]))now = now->next[str[i]].get();\n\t\t\telse now = now->fail;\n\t\t\tauto match = now->match_list;\n\t\t\tdo {\n\t\t\t\tmatch\n\t\t\t}\n\t\t}\n\t}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint expr(string& s, int& i);\nint number(string& s, int& i){\n\tint val=0;\n\tdo {\n\tval*=10;\n\tval += s[i] - '0';\n\ti++;\n\t} while ('0'<=s[i]&&s[i]<='9');\nreturn val;\n}\nint factor(string& s, int& i){\n\tif (s[i] >= '0'&&s[i] <= '9')return number(s, i);\n\n\ti++;\n\tint val = expr(s, i);\n\ti++;\n\treturn val;\n\n}\nint term(string& s, int& i){\n\tint val1 = factor(s, i);\n\twhile (s[i] == '*' || s[i] == '/'){\n\t\tchar c = s[i];\n\t\ti++;\n\t\tint val2 = factor(s, i);\n\t\tif (c == '*')\n\t\t\tval1 *= val2;\n\t\telse\n\t\t\tval1 /= val2;\n\t}\n\treturn val1;\n\n}\nint expr(string& s, int& i){\n\tint val1 = term(s, i);\n\twhile (s[i] == '+' || s[i] == '-'){\n\t\tchar c = s[i];\n\t\ti++;\n\t\tint val2 = term(s, i);\n\t\tif (c == '+')\n\t\t\tval1 += val2;\n\t\telse\n\t\t\tval1 -= val2;\n\t}\n\treturn val1;\n}\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--){\n\t\tstring s;\n\t\tcin >> s;\n\t\tint i = 0;\n\t\tif (s[s.length()-1]=='=')\n\t\t\ts=s.substr(0,s.length()-1);\n\t\tcout << expr(s, i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define all(a) (a).begin() ,(a).end()\n\nconst double eps = 1e-10;\nconst double inf = (int)1e8;\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n    int ret = 0;\n    \n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin ++;\n    }\n    return ret;\n}\n\nint term(State & begin){\n    int ret = factor(begin);\n    \n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret = term(begin);\n    \n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n    }else{\n        return number(begin);\n    }\n}\n\nint main(void){\n    int n;\n    string s;\n    cin>>n;\n    getline(cin,s);\n    while(n--){\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<cstdlib>\n#include<iomanip>\n#include<queue>\n#include<set>\n\n\n\n//expr(at the last, operate + or -)\n//term(then, judge the symble * and / next to digit first)\n//fact(first, judge the symble if () or digit)\n\nusing namespace std;\n\nstring str;\nstring::iterator it;\n\nint term();\nint fact();\n\nint expr()\n{\n    int p = term();\n    \n    while( *it == '+' || *it == '-' )\n    {\n        if( *it == '+' )\n        {\n            it++;\n            \n            int q = term();\n            \n            p += q;\n        }\n        else\n        {\n            it++;\n            int q = term();\n            p -= q;\n        }\n    }\n    \n    return p;\n}\n\nint term()\n{\n    int p = fact();\n    \n    while( *it == '*' || *it == '/' )\n    {\n        if( *it == '*' )\n        {\n            it++;\n            \n            int q = fact();\n            \n            p *= q;\n        }\n        else\n        {\n            it++;\n            \n            int q = fact();\n            \n            p /= q;\n        }\n    }\n    \n    return p;\n}\n\nint fact()\n{\n    if( *it == '(' )\n    {\n        it++;         //turn to the number next to \"(\"\n        \n        int p = expr();\n        \n        it++;\n        \n        return p;\n    }\n    else\n    {\n        int p = 0;\n        \n        while(isdigit(*it))\n        {\n            p *= 10;\n            p += *it - '0';\n            it++;\n        }\n        \n        return p;\n    }\n}\n\nint main()\n{\n    int n;\n    \n    cin>>n;\n    \n    while(n--)\n    {\n        cin>>str;\n        \n        str[str.size() - 1] = '\\0';\n        \n        it = str.begin();\n        \n        cout<<expr()<<endl;\n    }\n    \n    return 0;\n}\n\n/**\n * expr ::= term { ( '+' | '-' ) term }\n * term ::= fact { ( '*' | '/' ) fact }\n * fact ::= '(' expr ')' | digit\n **/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\ntypedef vector<vector<int> > VVI;\nconst int INF = 1e9;\n\nstring S;\n\nint expr(int &pos);\n\n// 数\nint number(int &pos)\n{\n\tint res=0;\n\twhile (isdigit(S[pos])) {\n\t\tres *= 10;\n\t\tres += S[pos]-'0';\n\t\tpos++;\n\t}\n\treturn res;\n}\n\n// ()か数\nint factor(int &pos)\n{\n\tint res=0;\n\t\n\tif (S[pos] == '(') {\n\t\tpos++; // skip '('\n\t\tres = expr(pos);\n\t\tpos++; // skip ')'\n\t} else {\n\t\tres = number(pos);\n\t}\n\t\n\treturn res;\n}\n\n// 乗算\nint term(int &pos)\n{\n\tint res = factor(pos);\n\twhile (1) {\n\t\tif (S[pos] == '*') {\n\t\t\tpos++; // skip '*'\n\t\t\tres *= factor(pos);\n\t\t} else if (S[pos] == '/') {\n\t\t\tpos++; // skip '/'\n\t\t\tres /= factor(pos);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\n// 四則演算\nint expr(int &pos)\n{\n\tint res = term(pos);\n\t\n\twhile (1) {\n\t\tif (S[pos] == '+') {\n\t\t\tpos++; // skip '+'\n\t\t\tres += term(pos);\n\t\t} else if (S[pos] == '-') {\n\t\t\tpos++; // skip'-'\n\t\t\tres -= term(pos);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint N;\n\tcin>>N;\n\tcin.ignore();\n\trep(i, N) {\n\t\tgetline(cin, S);\n\t\tint pos = 0;\n\t\tcout << expr(pos) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 0109 wa solution?????§\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nvoid calc(string st, stack<double> &s) {\t\n\tif(st == \"*\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(a * b);\n\t} else if(st == \"+\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(a + b);\n\t} else if(st == \"-\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(b - a);\n\t} else if(st == \"/\") {\n\t\tdouble a = s.top();\n\t\ts.pop();\n\t\tdouble b = s.top();\n\t\ts.pop();\n\t\ts.push(b / a);\n\t} else {\n\t\ts.push(atof(st.c_str()));\n\t}\n}\nint getPriority(string s) {\n\tif(s == \"(\") {\n\t\treturn 5;\n\t} else if(s == \"*\" || s == \"/\") {\n\t\treturn 3;\n\t} else if(s == \"+\" || s == \"-\") {\n\t\treturn 2;\n\t} else if(s == \")\") { \n\t\treturn 1;\n\t} else return 4;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tstr.erase(--str.end());\n\t\t\n\t\tvector<string> v;\n\t\t\n\t\tint f = 0;\n\t\tchar prev = '(';\n\t\tbool minus = 0;\n\t\trep(i, str.size()) {\t\t\n\t\t\tif(isdigit(str[i])) {\n\t\t\t\tf++;\n\t\t\t} else {\n\t\t\t\tif(f) {\n\t\t\t\t\tstring st;\n\t\t\t\t\tif(minus) {\n\t\t\t\t\t\tst += '-';\n\t\t\t\t\t\tminus = 0;\n\t\t\t\t\t}\n\t\t\t\t\trep(j,f) {\n\t\t\t\t\t\tst += str[i - f + j];\n\t\t\t\t\t}\t\n\t\t\t\t\tv.push_back(st);\n\t\t\t\t\tstring st2;\n\t\t\t\t\tst2 += str[i];\n\t\t\t\t\tv.push_back(st2);\n\t\t\t\t\tf = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif(prev == '(' && str[i] == '-') {\n\t\t\t\t\t\tminus = 1;\n\t\t\t\t\t\tprev = str[i];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstring st3;\n\t\t\t\t\tst3 += str[i];\n\t\t\t\t\tv.push_back(st3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = str[i];\n\t\t}\n\t\tif(f) {\n\t\t\tstring st;\n\t\t\trep(j,f) {\n\t\t\t\tst += str[str.size() - f + j];\n\t\t\t}\n\t\t\tv.push_back(st);\n\t\t}\n\n\t\tstack<string> s;\n\t\tvector<string> nv;\n\t\tstack<double> ret;\n\t\tint p = 0;\n\t\trep(i,v.size()) {\n\t\t\tcout << v[i] << endl;\n\t\t}\n\t\trep(i,v.size()) {\n\t\t\tp = getPriority(v[i]);\n\t\t\twhile(!s.empty() && getPriority(s.top()) > p && s.top() != \"(\") {\n\t\t\t\tnv.push_back(s.top());\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif(v[i] == \")\") {\n\t\t\t\ts.pop();\n\t\t\t} else {\n\t\t\t\ts.push(v[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()) {\n\t\t\tnv.push_back(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\trep(i,nv.size()) {\n\t\t\tcalc(nv[i], ret);\n\t\t}\n\t\tcout << ret.top() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\n\nusing namespace std;\n\nint calc(string s){\n\t// ©gªÊÉÍÜêÄ¢éêÆAÅ éÆ«Ì\n\tif(s[0]>='0'&&s[0]<='9'){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(!(s[i]>='0'&&s[i]<='9')){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!f){\n\t\t\treturn atoi(s.c_str());\n\t\t}\n\t}\n\telse if(s[0]=='('){\n\t\tstack<char> sc;\n\t\tsc.push('(');\n\t\tfor(int i = 1; i < s.size(); i++){\n\t\t\tif(s[i]==')')\n\t\t\t\tsc.pop();\n\t\t\telse if(s[i]=='('){\n\t\t\t\tsc.push('(');\n\t\t\t}\n\t\t\tif(sc.size()==0){\n\t\t\t\tif(i==s.size()-1){\n\t\t\t\t\treturn calc(s.substr(1,s.size()-2));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstack<char> sc;\n\t// \\¶ðÍÆÓ¡ðÍ\n\tfor(int i = s.size()-1; i >= 0; i--){\n\t\t// ÊÌÌZqÍ³·é\n\t\tif(s[i]=='(')\n\t\t\tsc.pop();\n\t\telse if(s[i]==')'){\n\t\t\tsc.push(')');\n\t\t}\n\t\telse if(s[i]=='+'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) + calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='-'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) - calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t}\n\n\tfor(int i = s.size()-1; i >= 0; i--){\n\t\t// ÊÌÌZqÍ³·é\n\t\tif(s[i]=='(')\n\t\t\tsc.pop();\n\t\telse if(s[i]==')'){\n\t\t\tsc.push(')');\n\t\t}\n\t\telse if(s[i]=='*'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) * calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t\telse if(s[i]=='/'&&sc.size()==0){\n\t\t\treturn calc(s.substr(0,i)) / calc(s.substr(i+1,s.size()-i-1));\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tstring str;\n\t\tcin>>str;\n\t\tcout<<calc(str.substr(0,str.size()-1))<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define P int\nusing namespace std;\nstring s;\nint p;\nP bns1();\nP g_A(){\n  P r=0;\n  if(s[p]=='('){\n    p++;\n    r=bns1();\n    p++;\n  }\n  else{\n    while(isdigit(s[p])){\n      r=r*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return r;\n}\nP bns2(){\n  P res=g_A();\n  while(s[p]=='*'||s[p]=='/'){\n    int t=p++;\n    if(s[t]=='*')res*=g_A();\n    if(s[t]=='/')res/=g_A();\n  }\n  return res;\n}\nP bns1(){\n  P res=bns2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bns2();\n    if(s[t]=='-')res-=bns2();\n  }\n  return res;\n}\nint main(){\n  int ans,n;\n  cin>>n;\n  while(n--){\n    cin>>s;\n    p=0;\n    P ans=bns1();\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nint expr(string &s, int &i);\nint term(string &s, int &i);\nint factor(string &s, int &i);\nint number(string &s, int &i);\n\nint expr(string &s, int &i){\n    int val = term(s, i);          // <term>\n    while(s[i] == '+' || s[i] == '-'){  // [\n        char opr = s[i];            // ('+' | '-')\n        ++i;\n        int val2 = term(s, i);      // <term>\n        if(opr == '+') val += val2;\n        else val -= val2;\n    }                               // ]*\n    return val;\n}\n\nint term(string &s, int &i){\n    int val = factor(s, i);\n    while(s[i] == '*' || s[i] == '/'){\n        char opr = s[i];\n        ++i;\n        int val2 = factor(s, i);\n        if(opr == '*') val *= val2;\n        else val /= val2;\n    }\n    return val;\n}\n\nint factor(string &s, int &i){\n    if(isdigit(s[i])) return number(s, i);\n    ++i;    // '('\n    int val = expr(s, i);\n    ++i;    // ')'\n    return val;\n}\n\nint number(string &s, int &i){\n    int n = s[i++] - '0';\n    while(isdigit(s[i])) n = n*10 + (s[i++]-'0');\n    return n;\n}\n\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    REP(x, N){\n        string s;\n        s = s.substr(0, s.size()-1);\n        cin >> s;\n        int i = 0;\n        cout << expr(s, i) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Name: Smart Calculator\n//Level: 2\n//Category: 構文解析\n//Note:\n\n/**\n * オーソドックスな四則演算の構文解析。\n *\n * オーダーは O(|S|)。\n */\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nvoid skip(Iterator &it, char c) {\n    if(*it != c) {\n        cout << \"Expected \" << c << \" but got \" << *it << endl;\n        cout << \"Parse error near: \";\n        while(*it) {\n            cout << *it;\n            ++it;\n        }\n        cout << endl;\n        abort();\n    }\n    ++it;\n}\n\nlong long factor(Iterator&);\nlong long term(Iterator&);\n\nlong long number(Iterator &it) {\n    long long val = 0;\n    while(isdigit(*it)) {\n        val *= 10;\n        val += *it - '0';\n        ++it;\n    }\n    return val;\n}\n\nlong long expr(Iterator &it) {\n    long long lhs = term(it);\n    while(*it == '+' || *it == '-') {\n        const char op = *it;\n        skip(it, op);\n        const long long rhs = term(it);\n        if(op == '+') lhs += rhs;\n        else lhs -= rhs;\n    }\n    return lhs;\n}\n\nlong long term(Iterator &it) {\n    long long lhs = factor(it);\n    while(*it == '*' || *it == '/') {\n        const char op = *it;\n        skip(it, op);\n        const long long rhs = factor(it);\n        if(op == '*') lhs *= rhs;\n        else lhs /= rhs;\n    }\n    return lhs;\n}\n\nlong long factor(Iterator &it) {\n    if(*it == '(') {\n        skip(it, '(');\n        const long long val = expr(it);\n        skip(it, ')');\n        return val;\n    } else {\n        return number(it);\n    }\n}\n\nbool solve() {\n    string line;\n    cin >> line;\n    Iterator it = line.begin();\n    cout << expr(it) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int N;\n    cin >> N;\n    while(N--) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='+'||*i=='-'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=term(i);\n\t\tif(op=='+')out+=out1;\n\t\telse out-=out1;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tDef out=factor(i);\n\twhile(*i=='*'||*i=='/'){\n\t\tchar op=*i;\n\t\ti++;\n\t\tDef out1=factor(i);\n\t\tif(op=='*')out*=out1;\n\t\telse out/=out1;\n\t}\n\treturn out;\n}\nDef factor(State &i){\n\tif(isdigit(*i))return number(i);\n\t//'('\n\ti++;\n\tDef out=expr(i);\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\ntypedef long long ll;\nconst int MODULO = 1000000007;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nint expr(char *& s);\n\nint val(char *& s){\n\tif(*s == '('){\n\t\ts++;\n\t\tint ret = expr(s);\n\t\ts++;\n\t\treturn ret;\n\t}\n\n\tint v = 0;\n\twhile(*s >= '0' && *s <= '9'){\n\t\tv *= 10;\n\t\tv += *s - '0';\n\t\ts++;\n\t}\n\treturn v;\n}\n\nint pri(char *& s){\n\tint l = val(s);\n\tchar ope = *s;\n\tif(ope != '*' && ope != '/')\n\t\treturn l;\n\ts++;\n\tint r = pri(s);\n\tif(ope == '*')\n\t\treturn l*r;\n\telse\n\t\treturn l/r;\n}\n\nint expr(char *& s){\n\tint l = pri(s);\n\tchar ope = *s;\n\tif(ope != '+' && ope != '-')\n\t\treturn l;\n\ts++;\n\tint r = expr(s);\n\tif(ope == '+')\n\t\treturn l+r;\n\telse\n\t\treturn l-r;\n}\n\nvoid solve()\n{\n\tchar s[256];\n\tcin>>s;\n\tchar *p = s;\n\tcout << expr(p) << endl;\n}\n\nint main(){\n\tint t; cin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <stack>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint calculate(string expr) {\n\tmap<char,int> op_pd {{'+',0},{'-',0},{'*',1},{'/',1}}; // operator precedence\n\tvector<string> pf; // postfix expression\n\tstack<char> op_s;\n\t// turn infix to postfix\n\tstring unit;\n\tcout << expr.size() << endl;\n\tfor (char ch : expr) {\n\t\tif (ch >= '0' && ch <= '9') {\n\t\t\tunit.push_back(ch);\n\t\t} else {\n\t\t\tif (!unit.empty()) {\n\t\t\t\tpf.push_back(unit);\n\t\t\t\tunit.clear();\n\t\t\t}\n\t\t\tif (ch == '(') {\n\t\t\t\top_s.push('(');\n\t\t\t} else if (ch == ')') {\n\t\t\t\twhile (op_s.top() != '(') {\n\t\t\t\t\tpf.push_back(string().assign(1,op_s.top()));\n\t\t\t\t\top_s.pop();\n\t\t\t\t}\n\t\t\t\top_s.pop();\n\t\t\t} else { // '+','-','*','/'\n\t\t\t\twhile (!op_s.empty() && op_s.top() != '(' && op_pd[ch] <= op_pd[op_s.top()]) {\n\t\t\t\t\tpf.push_back(string().assign(1,op_s.top()));\n\t\t\t\t\top_s.pop();\n\t\t\t\t}\n\t\t\t\top_s.push(ch);\n\t\t\t}\n\t\t}\n\t}\n\tif (!unit.empty()) {\n\t\tpf.push_back(unit);\n\t}\n\twhile (!op_s.empty()) {\n\t\tpf.push_back(string().assign(1,op_s.top()));\n\t\top_s.pop();\n\t}\n\t// calculate the postfix expression\n\tstack<int> num_s;\n\tnum_s.push(stoi(pf.front()));\n\tfor (auto i = pf.begin() + 1;i != pf.end();++i) {\n\t\tif (i->front() >= '0' && i->front() <= '9') {\n\t\t\tnum_s.push(stoi(*i));\n\t\t} else {\n\t\t\tint second = num_s.top();\n\t\t\tnum_s.pop();\n\t\t\tint first = num_s.top();\n\t\t\tnum_s.pop();\n\t\t\tswitch (i->front()) {\n\t\t\t\tcase '+':\n\t\t\t\t\tnum_s.push(first + second);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tnum_s.push(first - second);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tnum_s.push(first*second);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: // '/'\n\t\t\t\t\tnum_s.push(first/second);\n\t\t\t}\n\t\t}\n\t}\n\treturn num_s.top();\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tstring expr;\n\t\tcin >> expr;\n\t\tcout << calculate(expr.substr(0,expr.size()-1)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n\n  void init(){ pos=0;len=s.size();}\n\n  int head2Num(){\n    //bool f=false;\n    //if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    //if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    if(s[pos]=='('){\n      pos++;\n      return getAns();\n    }\n    int res=head2Num();\n    if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }else{\n      return res;\n    }\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else assert(0);\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n\ntypedef std::stringstream sst;\n\nint ToInt(std::string str){\n\tint i;\n\tsst ss;\n\tss<<str;\n\tss>>i;\n\treturn i;\n}\nstd::string ToStr(int i){\n\tstd::string str;\n\tsst ss;\n\tss<<i;\n\tss>>str;\n\treturn str;\n}\n\nstd::string SubStr(std::string str,int x,int y){\n\treturn str.substr(x,y-x+1);\n}\nint Third(std::string str){\n\tint fres,Ans;\n\twhile( ( fres=str.find_first_of(\"+-\",1) ) != std::string::npos ){\n\t\tint aRes;\n\t\t\n\t\tif( (aRes=str.find_first_of(\"+-\",fres+2)) == std::string::npos )\n\t\t\taRes=str.size()-1;\n\t\telse --aRes;\n\t\t\n\t\tif( str[fres] =='+' ){\n\t\t\tAns=ToInt(SubStr(str,0,fres-1))+ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n\t\t}else{\n\t\t\tAns=ToInt(SubStr(str,0,fres-1))-ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n\t\t}\n\t}\n\treturn ToInt(str);\n}\n\nint Second(std::string str){\n\tint fres,Ans;\n\twhile( ( fres=str.find_first_of(\"*/\") ) != std::string::npos ){\n\t\tint bRes,aRes;\n\t\tif( (bRes=str.find_last_of(\"+-\",fres)) == std::string::npos  || bRes==0 )\n\t\t\tbRes=0;\n\t\telse ++bRes;\n\t\t\n\t\tif( (aRes=str.find_first_of(\"+-*/\",fres+2)) == std::string::npos )\n\t\t\taRes=str.size()-1;\n\t\telse --aRes;\n\t\t\n\t\tif( str[fres] =='*' ){\n\t\t\tAns=ToInt(SubStr(str,bRes,fres-1))*ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n\t\t}else{\n\t\t\tAns=ToInt(SubStr(str,bRes,fres-1))/ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n\t\t}\n\t}\n\tstd::cout<<str<<std::endl;\n\tAns=Third(str);\n\treturn Ans;\n}\n\nint First(std::string str){\n\tint fres;\n\twhile( (fres = str.find(\")\") ) != std::string::npos ){\n\t\tint rfres=str.rfind(\"(\",fres);\n\t\tstd::string Next=SubStr(str,rfres+1,fres-1);\n\t\tint cRes=Second(Next);\n\t\tstr.replace(rfres,Next.size()+2,ToStr(cRes).c_str());\n\t}\n\tint lRes = Second(str);\n\t\n\treturn lRes;\n}\n\nint main(){\n\tint n;\n  std::string str;\n\tstd::cin>>n;\n\twhile( n-- ){\n\t\tstd::cin>>str;\n\t  std::cout<<First(str)<<std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n\n  void init(){ pos=0;len=s.size();}\n\n  int head2Num(){\n    //bool f=false;\n    //if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    //if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    int res;\n    if(s[pos]=='('){\n      pos++;\n      res = getAns();\n    }else res=head2Num();\n\n    if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }else{\n      return res;\n    }\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else assert(0);\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<\"foo2 \"<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xl==1&&s[0]=='-'){\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[xl-1]=='-'&&xl-2>=0&&(s[xl-2]=='+'||s[xl-2]=='-'||s[xl-2]=='*'||s[xl-2]=='/')) {\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xr==i&&s[xr+1]=='-'){\n\t\t\t\t\t\txr++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\t\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tif(i>=1&&isdigit(s[i-1])&&i<s.size()-1&&isdigit(s[i+1]));\n\t\t\telse continue;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xl==1&&s[xl-1]=='-'){\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\t// string tmp=\"123456\";\n\t// cout<<tmp.substr(5)<<endl;;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr<s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\t\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <iomanip>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define RREP(i,n) for(int i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(int i=m;i<n;++i)\n#define RFOR(i,m,n) for(int i=m-1;i>=n;--i)\n#define ALL(v) v.begin(),v.end()\n#define PB(a) push_back(a)\n#define INF 1000000001\n#define MOD 1000000007\n\nusing namespace std;\n\nint expr(string &s, int &i);\nint term(string &s, int &i);\nint factor(string &s, int&i);\nint num(string&s, int&i);\n\nint expr(string&s, int&i) {\n\tint val = term(s, i);\n\twhile(s[i] == '+' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\t++i;\n\t\tint val2 = term(s, i);\n\t\tif (op == '+') {\n\t\t\tval+=val2;\n\t\t}\n\t\telse {\n\t\t\tval-=val2;\n\t\t}\n\t}\n\treturn val;\n}\n\nint term(string &s, int&i) {\n\tint val = factor(s, i);\n\twhile (s[i] == '/' || s[i] == '*') {\n\t\tchar op = s[i];\n\t\t++i;\n\t\tint val2 = factor(s, i);\n\t\tif (op == '/') {\n\t\t\tval /= val2;\n\t\t}\n\t\telse {\n\t\t\tval *= val2;\n\t\t}\n\t}\n\treturn val;\n}\n\nint factor(string &s, int&i) {\n\tif (isdigit(s[i])) return num(s, i);\n\telse {\n\t\t++i;\n\t\tint val= expr(s, i);\n\t\t++i;\n\t\treturn val;\n\t}\n}\nint num(string &s, int&i) {\n\tint a;\n\tif (isdigit(s[i])) {\n\t\ta = s[i] - '0';\n\t\t++i;\n\t\twhile (isdigit(s[i])) {\n\t\t\ta = a * 10 + (s[i] - '0');\n\t\t\t++i;\n\t\t}\n\t}\n\treturn a;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\ts = s.substr(0, s.size() - 1);\n\t\tint index = 0;\n\t\tint ans = expr(s, index);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint p;\n\nint exp();\nint factor();\nint term();\n\nint factor() {\n\n  int num=0;\n  while('0' <= str[p] && str[p] <= '9') {\n    num*=10;\n    num += str[p] - '0';\n    p++;\n  }\n\n  if (str[p] == '('){\n    p++;\n    num = exp();\n    //p++;\n  }\n\n  if ( str[p] == ')' ) p++;\n  return num;\n}\n\nint term(){\n int val = factor();\n  while(str[p] == '*' || str[p] == '/') {\n    if(str[p] == '*') {\n      p++;\n      val *= factor();\n    } else if(str[p] == '/'){\n      p++;\n      val /= factor();\n    }\n  }\n\n  return val;\n}\n \nint exp() {\n  int val = term();\n  while(str[p] == '+' || str[p] == '-') {\n    if(str[p] == '+') {\n      p++;\n      val += term();\n    } else if(str[p] == '-'){\n      p++;\n      val -= term();\n    }\n  }\n\n  return val;\n}\n\nint main() {\n  int n;\n\n  cin >> n;\n  \n  for(int i=0;i<n;i++) {\n    p = 0;\n  cin >> str;\n  cout << exp() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define int long long\n#define range(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, a) range(i, 0, a)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nconst int MOD = 1e9 + 7, INF = 1e17;\nusing vi = vector <int>;\nusing vvi = vector <vi>;\n//g++ -std==c++14\n\n\nint expr(const char **);\nint term(const char **);\nint factor(const char **);\nint number(const char **);\n\nint expr(const char **p) {\n  int val = term(p);\n  while (1) {\n    if (**p == '+') {\n      (*p)++;\n      val += term(p);\n    } else if (**p == '-') {\n      (*p)++;\n      val -= term(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(const char **p) {\n  int val = factor(p);\n  while (1) {\n    if (**p == '*') {\n      (*p)++;\n      val *= factor(p);\n    } else if (**p == '/') {\n      (*p)++;\n      val /= factor(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(const char **p) {\n  if (**p == '(') {\n    (*p)++;\n    int val = expr(p);\n    (*p)++;\n    return val;\n  }\n  return number(p);\n}\n\nint number(const char **p) {\n  int val = 0;\n  while ('0' <= **p && **p <= '9') {\n    val = val * 10 + **p - '0';\n    (*p)++;\n  }\n  return val;\n}\n\nsigned main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    const char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nstd::string find(std::vector<std::string>&v, long long a, bool b){\n\n\tstd::string res;\n\n\tif (b){\n\t\tfor (long long i = a - 1; i >= 0; i--){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!b){\n\t\tfor (long long i = a + 1; i < v.size(); i++){\n\t\t\tif (v[i] != \"T\"){\n\t\t\t\tres = v[i];\n\t\t\t\tv[i] = \"T\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nlong long tolong long(std::string str){\n\n\tlong long res;\n\tstd::stringstream z;\n\n\tz << str;\n\tz >> res;\n\n\treturn res;\n\n}\n\nstd::string tostring(long long a){\n\n\tstd::string str;\n\tstd::stringstream z;\n\n\tz << a;\n\tz >> str;\n\n\treturn str;\n\n}\n\nstd::string keisan(std::string lhs, std::string rhs, long long t){\n\n\tlong long a, b, c;\n\n\ta = tolong long(lhs);\n\tb = tolong long(rhs);\n\n\tif (t == 1)c = a + b;\n\tif (t == 2)c = a - b;\n\tif (t == 3)c = a * b;\n\tif (t == 4)c = a / b;\n\n\treturn tostring(c);\n\n}\n\nstd::string keisan2(std::vector<std::string> &v){\n\n\tlong long res = 0;\n\n\tfor (long long i = 0, j = 0, c = 0; i < v.size(); i++){\n\n\t\tif (v[i] == \"(\"){\n\t\t\tif (c == 0)j = i;\n\t\t\tc++;\n\t\t}\n\n\t\tif (v[i] == \")\"){\n\t\t\tc--;\n\t\t\tif (c == 0){\n\t\t\t\tstd::vector<std::string>w;\n\t\t\t\tfor (long long p = j + 1; p < i; p++)w.push_back(v[p]);\n\t\t\t\tv[j] = keisan2(w);\n\t\t\t\tfor (long long p = j + 1; p <= i; p++)v[p] = \"T\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (long long i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"*\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 3);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t\tif (v[i] == \"/\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 4);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tfor (long long i = 0; i < v.size(); i++){\n\t\tif (v[i] == \"+\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 1);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\n\t\tif (v[i] == \"-\"){\n\t\t\tv[i - 1] = keisan(find(v, i, 1), find(v, i, 0), 2);\n\t\t\tv[i] = v[i + 1] = \"T\";\n\t\t}\n\t}\n\n\tv[v.size() - 1] = \"T\";\n\tfor (long long i = 0; i < v.size(); i++){\n\t\tif (v[i] != \"T\")res = tolong long(v[i]);\n\t}\n\treturn tostring(res);\n\n}\n\n\nlong long main(){\n\n\tlong long n;\n\tstd::cin >> n;\n\n\tfor (long long i = 0; i < n; i++){\n\n\t\tstd::string str;\n\n\t\tstd::cin >> str;\n\n\t\tstd::vector<std::string> v;\n\n\t\tfor (long long i = 0, j = 0; i < str.size(); i++){\n\n\t\t\tif (!(str[i] >= '0'&&str[i] <= '9')){\n\t\t\t\tif (i - j > 0)v.push_back(str.substr(j, i - j));\n\t\t\t\tv.push_back(str.substr(i, 1));\n\t\t\t\tj = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << keisan2(v) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\n\nll stol(string str){\n  stringstream ss(str);\n  ll n;\n  ss >> n;\n  return n;\n}\n\nll parse(int l, int r){\n  int n = 0, i;\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')n++;\n    if(s[i] == '(')n--;\n    if(!n){\n      if(s[i] == '+')return parse(l,i) + parse(i+1,r);\n      if(s[i] == '-')return parse(l,i) - parse(i+1,r);\n    }\n  }\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')n++;\n    if(s[i] == '(')n--;\n    if(!n){\n      if(s[i] == '*')return parse(l,i) * parse(i+1,r);\n      if(s[i] == '/')return parse(l,i) / parse(i+1,r);\n    }\n  }\n\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  return stol( s.substr(l,r-l) );\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint compute(string s) {\n    int begin;\n    int nest = 0;\n    int n = 0;\n    vector<int> children, children2;\n    vector<char> operators, operators2;\n\n    for (int i=0; i<(int)s.length(); i++) {\n        if (s[i] == '(') {\n            nest++;\n            if (nest == 1) {\n                begin = i+1;\n            }\n        }\n        else if (s[i] == ')') {\n            if (nest == 1) {\n                string substr = s.substr(begin, i-begin);\n                n = compute(substr);\n            }\n            nest--;\n        }\n        else if (nest == 0) {\n            if ('0' <= s[i] && s[i] <= '9') {\n                n *= 10;\n                n += s[i]-'0';\n            }\n            else {\n                children.push_back(n);\n                operators.push_back(s[i]);\n                n = 0;\n            }\n        }\n    }\n    children.push_back(n);\n    if (operators.size() == 0) {\n        return children[0];\n    }\n    children2.push_back(children[0]);\n    for (int i=0; i<(int)operators.size(); i++) {\n        if (operators[i] == '*') {\n            children2[children2.size()-1] *= children[i+1];\n        }\n        else if (operators[i] == '/') {\n            children2[children2.size()-1] /= children2[i+1];\n        }\n        else {\n            children2.push_back(children[i+1]);\n            operators2.push_back(operators[i]);\n        }\n    }\n    n = children2[0];\n    for (int i=0; i<(int)operators2.size(); i++) {\n        if (operators2[i] == '+') {\n            n += children2[i+1];\n        }\n        else {\n            n -= children2[i+1];\n        }\n    }\n    return n;\n}\n\nint main() {\n    int n;\n    string s;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n        cin >> s;\n        cout << compute(s.substr(0, s.length()-1)) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\nstring toRPN(string s){\n\tstack<char> ope;\n\tstring ret;\n\t\n\trep(i,s.size()){\n\t\tif( isdigit(s[i]) ) ret+=s[i];\n\t\t\n\t\telse{\n//\t\t\tswitch(s[i]){\n//\t\t\t\tcase '(' :\n//\t\t\t\t\tope.push(s[i]);\n//\t\t\t\t\tbreak;\n//\t\t\t\tcase ')' :\n//\t\t\t\t\twhile(ope.top()!='('){\n//\t\t\t\t\t\tret+=ope.top();\n//\t\t\t\t\t\tope.pop();\n//\t\t\t\t\t}\n//\t\t\t\t\tope.pop();\n//\t\t\t\t\tbreak;\n//\t\t\t\tcase '*' :\n//\t\t\t\tcase '/' :\n//\t\t\t\t\twhile( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n//\t\t\t\t\t\tret+=ope.top();\n//\t\t\t\t\t\tope.pop();\n//\t\t\t\t\t}\n//\t\t\t\t\tope.push(s[i]);\n//\t\t\t\t\tbreak;\n//\t\t\t\tcase '+' :\n//\t\t\t\tcase '-' :\n//\t\t\t\t\twhile( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n//\t\t\t\t\t\tret+=ope.top();\n//\t\t\t\t\t\tope.pop();\n//\t\t\t\t\t}\n//\t\t\t\t\tope.push(s[i]);\n//\t\t\t\t\tbreak;\n//\t\t\t\tdefault :\n//\t\t\t\t\treturn \"invalid\";\n//\t\t\t\t\tbreak;\n//\t\t\t}\n\t\t\tif(s[i]=='('){\n\t\t\t\tope.push(s[i]);\n\t\t\t\t\n\t\t\t}else if(s[i]==')'){\n\t\t\t\twhile(ope.top()!='('){\n\t\t\t\t\tret+=ope.top();\n\t\t\t\t\tope.pop();\n\t\t\t\t}\n\t\t\t\tope.pop();\n\t\t\t\t\n\t\t\t}else if( s[i]=='*' || s[i]=='/' ){\n\t\t\t\twhile( !ope.empty() && (ope.top()=='*' || ope.top()=='/') ){\n\t\t\t\t\tret+=ope.top();\n\t\t\t\t\tope.pop();\n\t\t\t\t}\n\t\t\t\tope.push(s[i]);\n\t\t\t\t\n\t\t\t}else if( s[i]=='+' || s[i]=='-' ){\n\t\t\t\twhile( !ope.empty() && (ope.top()=='*' || ope.top()=='/' || ope.top()=='+' || ope.top()=='-') ){\n\t\t\t\t\tret+=ope.top();\n\t\t\t\t\tope.pop();\n\t\t\t\t}\n\t\t\t\tope.push(s[i]);\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\treturn \"invalid\";\n\t\t\t}\n\t\t}\n\t}\n\twhile(ope.size()){\n\t\tret+=ope.top();\n\t\tope.pop();\n\t}\n\t\n\treturn ret;\n}\n\nstring solveRPN(string s){\n\tstack<int> stk;\n\t\n\t\n\tfor(int i=0;i<s.size();i++){\n\t\tif( isdigit(s[i]) )stk.push( s[i]-'0'  );\n\t\telse{\n\t\t\tint b=stk.top(); stk.pop();\n\t\t\tint a=stk.top(); stk.pop();\n\t\t\t\n\t\t\tif(s[i]=='+')stk.push(a+b);\n\t\t\tif(s[i]=='-')stk.push(a-b);\n\t\t\tif(s[i]=='*')stk.push(a*b);\n\t\t\tif(s[i]=='/')stk.push(a/b);\n\t\t}\n\t}\n\t\n\tstringstream ret;\n\tret<<stk.top();\n\t\n\treturn ret.str();\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\t\n\t\ts.erase(s.size()-1);\n\t\t\n\t\ts=toRPN(s);\n\t\ts=solveRPN(s);\n\t\t\n\t\tcout<<s<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\ntypedef long long ll;\n\nll stol(string s){\n  stringstream ss(s);\n  ll n;\n  ss >> n;\n  return n;\n}\n\nll parse(int l, int r){\n  int n = 0,i;\n  for(i=r-1;i>=l;i--){\n    if(s[i] == ‘)‘)n++;  if(s[i] == ‘(’)n--;\n    if(!n){\n      if(s[i] == ‘+’)return parse(l,i)+parse(i+1,r);\n      if(s[i] == ‘-’)return parse(l,i)-parse(i+1,r);\n    }\n  }\n  for(i=r-1;i>=l;i--){\n    if(s[i] == ‘)‘)n++;  if(s[i] == ‘(’)n--;\n    if(!n){\n      if(s[i] == ‘*’)return parse(l,i)*parse(i+1,r);\n      if(s[i] == ‘/’)return parse(l,i)/parse(i+1,r);\n    }\n  }\n\n  if(s[l] == ‘(‘ && s[r-1] == ‘)’)return parse(l+1,r-1);\n  return stol(s.substr(l,r-l));\n}\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\t// cout<<\"foo2 \"<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(s[xl-1]=='-'&&xl-2>=0&&(s[xl-2]=='+'||s[xl-2]=='-'||s[xl-2]=='*'||s[xl-2]=='/')) {\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xr==i&&s[xr+1]=='-'){\n\t\t\t\t\t\txr++;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\t\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tif(i>=1&&isdigit(s[i-1])&&i<s.size()-1&&isdigit(s[i+1]));\n\t\t\telse continue;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(xl==1&&s[xl-1]=='-'){\n\t\t\t\t\t\txl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tif(xr<s.size()-1) ss2<<s.substr(xr+1);\n\t\t\tstring tmp;\n\t\t\tss2>>tmp;\n\t\t\t// cout<<\"tmp \"<<tmp<<endl;\n\n\t\t\treturn foo2(tmp);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\t// string tmp=\"123456\";\n\t// cout<<tmp.substr(5)<<endl;;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\t// if(xr>=s.size()-1) return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1));\n\t\tif(xr<s.size()-1) return foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1)));\n\t\t// return foo1(s.substr(0,xl)+s.substr(xl+1,xr-xl-1)+s.substr(xr+1));\n\t\t\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\t// cout<<s.substr(0,0)<<endl;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<ctype.h>\n\nstd::string s;\nstd::string::iterator it;\n\nint term();\nint fact();\n\n// 計算\nint expr()\n{\n \tint p = term();\n\t\n\t// + or -\n\twhile( *it == '+' || *it == '-' ){\n\t \tif( *it == '+' ){\n\t\t \tit++;\n\t\t\tint q = term();\n\t\t\tp += q;\n\t\t}\n\t\telse{\n\t\t \tit++;\n\t\t\tint q = term();\n\t\t\tp -= q;\n\t\t}\n\t}\n\t\n\treturn p;\n}\n\n// 項を計算\nint term()\n{\n\tint p = fact();\n\t\n\twhile( *it == '*' || *it == '/' ){\n\t \tif( *it == '*' ){\n\t\t \tit++;\n\t\t\tint q = fact();\n\t\t\tp *= q;\n\t\t}\n\t\telse{\n\t\t \tit++;\n\t\t\tint q = fact();\n\t\t\tp /= q;\n\t\t}\n\t}\n\t\n\treturn p;\n}\n\n// 括弧内 or 数字\nint fact()\n{\n \tif( *it == '(' ){\n\t \tit++;\n\t\tint p = expr();\n\t\tit++;\n\t\t\n\t\treturn p;\n\t}\n\telse{\n\t \tint p = 0;\n\t\t\n\t\twhile( isdigit( *it ) ){\n\t\t\tp *= 10;\n\t\t\tp += *it - '0';\n\t\t\tit++;\n\t\t}\n\t\t\n\t\treturn p;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tstd::cin >> n;\n\t\n\twhile( n-- ){\n\t\tstd::cin >> s;\n\t\ts[s.size()-1] = '\\0';\n\t\tit = s.begin();\n\t\tstd::cout << expr() << std::endl;\n\t}\n\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint op_priority(char a) {\n\tif(a == '+' || a == '-')\n\t\treturn 0;\n\tif(a == '/')\n\t\treturn 1;\n\tif(a == '*')\n\t\treturn 2;\n\treturn -1;\n}\n\nvoid clac_once(stack<int> & num_stack, stack<char> & op_stack) {\n\tint a, b;\n\tint c;\n\tchar op;\n\n\tif(num_stack.empty()) cout << \"num_stack.empty() returns true\" << endl;\n\tif(op_stack.empty()) cout << \"op_stack.empty() returns true\" << endl;\n\n\tb = num_stack.top();\n\tnum_stack.pop();\n\ta = num_stack.top();\n\tnum_stack.pop();\n\top = op_stack.top();\n\top_stack.pop();\n\n\tswitch(op) {\n\t\tcase '+' :\n\t\t\tc = a + b;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tc = a - b;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tc = a * b;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tc = a / b;\n\t}\n\n\tnum_stack.push(c);\n}\n\nint clac(string str) {\n\tstack<int> num_stack;\n\tstack<char> op_stack;\n\n\tfor(int i = 0; i < str.size();) {\n\t\tif(str[i] == '(') {\n\t\t\tint start = ++i;\n\t\t\tint count = 1;\n\n\t\t\twhile(count) {\n\t\t\t\tif(str[i] == ')')\n\t\t\t\t\tcount--;\n\t\t\t\telse if(str[i] == '(')\n\t\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tnum_stack.push(clac(string(str.begin() + start, str.begin() + i)));\n\t\t}\n\t\telse if(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/' || str[i] == '=' || str[i] == ')') {\n\t\t\twhile(!op_stack.empty() && op_priority(op_stack.top()) >= op_priority(str[i])) {\n\t\t\t\tclac_once(num_stack, op_stack);\n\t\t\t}\n\t\t\top_stack.push(str[i]);\n\t\t\ti++;\n\t\t}\n\t\telse if('0' <= str[i] && str[i] <= '9') {\n\t\t\tint tmp = 0;\n\t\t\twhile('0' <= str[i] && str[i] <= '9') {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += str[i] - '0';\n\t\t\t\ti++;\n\n\n\t\t\t}\n\t\t\tnum_stack.push(tmp);\n\t\t}\n\t}\n\n\treturn num_stack.top();\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tstring str;\n\n\t\tcin >> str;\n\t\tcout << clac(str) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring str;\nint p;\nint exp();\nint term();\nint factor();\n\n\nint main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    p=0;  \n    cin>>str;\n    cout<<exp()<<endl;\n  }\n  return 0;\n}\n\n\nint exp(){\n  int val=term();\n  while(str[p]=='+'||str[p]=='-'){\n    if(str[p]=='+'){\n      p++;\n      val+=term();\n    }\n    else if(str[p]=='-'){\n      p++;\n      val-=term();\n    }\n  }\n  return val;\n}\n\n\nint term(){\n  \n  int val=factor();\n  while(str[p]=='*'||str[p]=='/'){\n    if(str[p]=='*'){\n      p++;\n      val*=factor();\n    }\n    else if(str[p]=='/'){\n      p++;\n      val/=factor();\n    }\n  }\n  return val;\n}\n\n\nint factor(){\n  int val=0;\n  \n  if(str[p]=='('){\n    p++;    \n    val=exp();\n    p++;\n  }\n  else{\n    while('0'<=str[p]&&str[p]<='9'){\n      val*=10;\n      val+=(str[p]-'0');   \n      p++;\n    }\n  }\n  return val;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nchar readchar() {\n  assert(cur < S.size());\n  char ret = S[cur];\n  cur++;\n  return ret;\n}\n\nchar peek() {\n  assert(cur < S.size());\n  return S[cur];\n}\n\nint digit() {\n  assert(isdigit(peek()));\n  int n = readchar() - '0';\n  return n;\n}\n\nint number() {\n  int n = digit();\n  while(cur < S.size() && isdigit(peek()))\n    n = n*10 + digit();\n  return n;\n}\n\nint expression();\n\nint factor() {\n  if(peek() != '(') return number();\n  cur++;\n  int n = expression();\n  assert(peek() == ')');\n  cur++;\n  return n;\n} \n\nint term() {\n  int a = factor();\n  while(cur < S.size() && (peek() == '*' || peek() == '/')) {\n    char op = readchar();\n    int b = factor();\n    if(op == '*') a *= b;\n    else a /= b;\n  }\n  return a;\n}\n\n\n\nint expression() {\n  int sum = term();\n  while(cur < S.size() && (peek() == '+' || peek() == '-')) {\n    char op = readchar();\n    int b = term();\n    if(op == '+') sum += b;\n    else sum -= b;\n  }\n  return sum;\n}\n\nint parse() {\n  return expression();\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin >> S;\n    int a = parse();\n    cout << a << endl;\n    cur = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<short, short> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint calc(string s)\n{\n\tvi v;\n\tREP(i, s.size())\n\t{\n\t\tif (s[i] == '+') v.push_back(0);\n\t\telse if (s[i] == '-') v.push_back(1);\n\t\telse if (s[i] == '*') v.push_back(2);\n\t\telse if (s[i] == '/') v.push_back(3);\n\t\telse\n\t\t{\n\t\t\tint tmp = s[i] - '0';\n\t\t\tint t = i+1;\n\t\t\twhile (isdigit(s[t]))\n\t\t\t{\n\t\t\t\ttmp = tmp * 10 + s[t] - '0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\ti = t - 1;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t}\n\n\twhile (v.size() > 1)\n\t{\n\t\tfor (int i = 1; i < v.size();i+=2)\n\t\t{\n\t\t\tif (v[i]==2)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] * v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (v[i] == 3)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] / v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < v.size(); i += 2)\n\t\t{\n\t\t\tif (v[i] == 0)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] + v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (v[i] == 1)\n\t\t\t{\n\t\t\t\tint tmp = v[i - 1] - v[i + 1];\n\t\t\t\tv[i - 1] = tmp;\n\t\t\t\tv.erase(v.begin() + i + 1);\n\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tnext:;\n\t\t}\n\t}\n\treturn v[0];\n}\n\nint solve(string s)\n{\n\twhile (1)\n\t{\n\t\tif (find(ALL(s), '(') == s.end())\n\t\t{\n\t\t\treturn calc(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring tmp;\n\t\t\tREP(i, s.size())\n\t\t\t{\n\t\t\t\tif (s[i] != '(') tmp.push_back(s[i]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = s.size()-1;; j--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[j] == ')')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint t = solve(s.substr(i+1, j - i - 1));\n\t\t\t\t\t\t\ttmp += to_string(t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn solve(tmp);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint sets;\n\tcin >> sets;\n\tstring s;\n\tgetline(cin, s);\n\tREP(set, sets)\n\t{\n\t\tgetline(cin, s);\n\t\tif (s.size() == 0) puts(\"0\");\n\t\telse\n\t\t{\n\t\t\ts.erase(s.size() - 1);\n\t\t\tcout << solve(s) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint p,n;\nint bnf1();\nint g_A(){\n  int r=0;\n  if(s[p]=='(')p++,r=bnf1(),p++;\n  else\n    while(isdigit(s[p])) r=r*10+(s[p++]-'0');\n  return r;\n}\nint bnf2(){\n  int res=g_A();\n  while(s[p]=='*'||s[p]=='/'){\n    int t=p++;\n    if(s[t]=='*')res*=g_A();\n    if(s[t]=='/')res/=g_A();\n  }\n  return res;\n}\nint bnf1(){\n  int res=bnf2();\n  while(s[p]=='+'||s[p]=='-'){\n    int t=p++;\n    if(s[t]=='+')res+=bnf2();\n    if(s[t]=='-')res-=bnf2();\n  }\n  return res;\n}\nint main(){\n  cin>>n;\n  while(n--){\n    cin>>s;\n    p=0;\n    cout<<bnf1()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint eval(const string & expr) {\n\tint left = 0;\n\tint right = 0;\n\tint mdtemp = 0;\n\tint ev_idx = 0;\n\tint sign = 1; // 1=+, -1=-\n\tchar c, cc;\n\n\t// 項の処理\n\twhile((c = expr[ev_idx++]) != '=' && c != '\\0') {\n\t\tif(c == '+' || c == '-') {\n\t\t\tleft += sign * right;\n\t\t\tright = 0;\n\t\t\tif(c == '+') sign = 1;\n\t\t\telse sign = -1;\n\t\t} else if(c == '*' || c == '/') { // if mul,div\n\t\t\tmdtemp = 0;\n\t\t\twhile(1) {\n\t\t\t\tif((cc = expr[ev_idx++]) == '=' || cc == '\\0' || cc == '+' || cc == '-' || cc == '*' || cc == '/') {\n\t\t\t\t\tev_idx--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cc == '(') {\n\t\t\t\t\tint clen = 0;\n\t\t\t\t\tint cstrt = ev_idx;\n\t\t\t\t\twhile(expr[ev_idx++] != ')') clen++;\n\t\t\t\t\tstring ceval = expr.substr(cstrt, clen);\n\t\t\t\t\tmdtemp = eval(ceval);\n\t\t\t\t} else {\n\t\t\t\t\tmdtemp *= 10;\n\t\t\t\t\tmdtemp += (int)(cc - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c == '*') right *= mdtemp;\n\t\t\telse right /= mdtemp;\n\t\t} else if(c == '(') {\n\t\t\tint clen = 0;\n\t\t\tint cstrt = ev_idx;\n\t\t\twhile(expr[ev_idx++] != ')') clen++;\n\t\t\tstring ceval = expr.substr(cstrt, clen);\n\t\t\tright = eval(ceval);\n\t\t} else { // if numbers\n\t\t\tright *= 10;\n\t\t\tright += (int)(c - '0');\n\t\t}\n\t}\n\tleft += sign * right;\n\t\n\treturn left;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> anss(n);\n\n\tfor(int i=0;i<n;i++) {\n\t\tstring expr;\n\t\tcin >> expr;\n\t\tint ans;\n\t\tans = eval(expr);\n\t\tanss[i] = ans;\n\t}\n\tfor(auto it = anss.begin(); it != anss.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\n\ntypedef string::const_iterator State;\n\n\nint expression(State &begin);\n\n\nint number(State &begin)\n{\n\tint ret = 0;\n\t\n\tfor(; isdigit(*begin); begin++) {\n\t\tret = ret * 10 + *begin - '0';\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin)\n{\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\tbegin++;\n\t\t\n\t\treturn ret;\n\t} else {\n\t\treturn number(begin);\n\t}\n}\n\nint term(State &begin)\n{\n\tint ret = factor(begin);\n\n\twhile(true) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t} else if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expression(State &begin)\n{\n\tint ret = term(begin);\n\n\twhile(true) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\t\t\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\n\t\tState begin = s.begin();\n\t\tcout << expression(begin) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  char c = buf[pos];\n\n  if ('0' <= c && c <= '9') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  if (buf[pos] == '*') {\n    Pair q = EvalExp(pos+1);\n    return Pair(p.first*q.first, q.second);\n  }\n\n  if (buf[pos] == '/') {\n    Pair q = EvalExp(pos+1);\n    return Pair(p.first/q.first, q.second);\n  }\n\n  return p;\n}\n\nPair EvalExp(int pos) {\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n  int res = p.first;\n  if (buf[pos] == '=' || buf[pos] == ')') {\n    return Pair(res, pos);\n  }\n\n  Pair q = EvalExp(pos+1);\n  if (buf[pos] == '+') res += q.first;\n  else if (buf[pos] == '-') res -= q.first;\n  else assert(0);\n\n  return Pair(res, q.second);\n}\n\nint main() {\n  scanf(\"%d\", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define ll long long\nusing namespace std;\n\nstring m;\nint point = 0;\nll term(void);\n\nbool left() {\n    if(point < m.size()) return true;\n    else return false;\n}\n\nchar peek() {\n    return m[point];\n} \n\nchar pop() {\n    return m[point++];\n}\n\nvoid eat(char ch) {\n    assert(left() && pop() == ch);\n}\n\nll expr() {\n    ll res = term();\n    while(left() && (peek() == '+' || peek() == '-')) {\n        if(peek() == '+') {\n            eat('+');\n            res += term();\n        } else {\n            eat('-');\n            res -= term();\n        }\n    }\n    return res;\n}\n\nll number() {\n    ll res = 0;\n    while(left() && isdigit(peek())) {\n        res *= 10;\n        res += pop() - '0';\n    }\n    return res;\n}\n\nll factor() {\n    if(peek() == '('){\n        eat('(');\n        ll res = expr();\n        eat(')');\n        return res;\n    } else {\n        return number();\n    }\n}\n\nll term() {\n    ll res = factor();\n    while(left() && (peek() == '*' || peek() == '/')) {\n        if(peek() == '*') {\n            eat('*');\n            res *= factor();\n        } else {\n            eat('/');\n            res /= factor();\n        }\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    ll ans;\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,n) {\n        cin >> m;\n        point = 0;\n        ans = expr();\n        cout << ans << endl;\n        eat('=');\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n\n  void init(){ pos=0;len=s.size();}\n\n  int head2Num(){\n    if(s[pos]=='('){pos++;return getAns();}\n    \n    bool f=false;\n    if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/')res/=num;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else assert(0);\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nstring foo2(string s){\n\tcout<<s<<endl;\n\tbool f=true;\n\trep(i,s.size()){\n\t\tif(i==0){\n\t\t\tif(s[0]=='-');\n\t\t\telse f=false;\n\t\t}\n\t\telse{\n\t\t\tif(s[i]>='0'&&s[i]<='9'){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t}\n\tif(f) return s;\n\t// bool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='*'||s[i]=='/'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\t// cout<<s.substr(xl,xr-xl+1)<<endl;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\t// cout<<\"a \"<<a<<endl;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='*'){\n\t\t\t\ttt=a*b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a/b;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\t// cout<<\"foo2 \"<<s<<\" \"<<endl;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\trep(i,s.size()){\n\t\tif(s[i]=='+'||s[i]=='-'){\n\t\t\tint xl=i,xr=i;\n\t\t\tf=true;\n\t\t\twhile(1){\n\t\t\t\tif(xl==0) break;\n\t\t\t\telse if(s[xl-1]>='0'&&s[xl-1]<='9'){\n\t\t\t\t\txl--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(xr==s.size()-1) break;\n\t\t\t\telse if(s[xr+1]>='0'&&s[xr+1]<='9'){\n\t\t\t\t\txr++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstringstream ss1,ss2;\n\t\t\tss1<<s.substr(xl,xr-xl+1);\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tss1>>a;\n\t\t\tss1>>t;\n\t\t\tss1>>b;\n\t\t\tss2<<s.substr(0,xl);\n\t\t\tint tt;\n\t\t\tif(t=='+'){\n\t\t\t\ttt=a+b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttt=a-b;\n\t\t\t\t// cout<<tt<<endl;\n\t\t\t}\n\t\t\tss2<<tt;\n\t\t\tss2<<s.substr(xr+1);\n\t\t\tss2>>s;\n\t\t\treturn foo2(s);\n\t\t}\n\t}\n\treturn s;\n}\n\nstring foo1(string s){\n\t// cout<<s<<endl;\n\tint xl=-1,xr=-1;\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\txl=i;\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\txr=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(xr!=-1){\n\t\treturn foo1(s.substr(0,xl)+foo2(s.substr(xl+1,xr-xl-1))+s.substr(xr+1));\n\t}\n\treturn foo2(s);\n}\n\nstring solve(string s){\n\treturn foo1(s);\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin>>s;\n\t\ts=s.substr(0,s.size()-1);\n\t\ts=solve(s);\n\t\tcout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cctype>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint expr(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=(*begin)-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret=factor(begin);\n\tfor(;;){\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tret*=factor(begin);\n\t\t}else if(*begin=='/'){\n\t\t\tbegin++;\n\t\t\tret/=factor(begin);\n\t\t}else break;\n\t}\n\treturn ret;\n}\n\nint expr(State &begin){\n\tint ret=term(begin);\n\tfor(;;){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tret+=term(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tret-=term(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tint ret=expr(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tcin.ignore();\n\tfor(int i=0;i<N;i++){\n\t\tstring str;\n\t\tgetline(cin,str);\n\t\tState begin=str.begin();\n\t\tint ans=expr(begin);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// @snippet<sh19910711/contest:headers.cpp>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <limits>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n// @snippet<sh19910711/contest:solution/interface.cpp>\nnamespace solution {\n    class ISolution {\n    public:\n        virtual void init() {};\n        virtual bool input() { return false; };\n        virtual void output() {};\n        virtual int run() = 0;\n    };\n}\n\n// @snippet<sh19910711/contest:math/big_integer.cpp>\nnamespace math {\n    class BigInteger {\n    public:\n        char *digits;\n        int size, capacity, sign;\n\n        BigInteger() {\n            capacity = 128;\n            sign = 0;\n            digits = new char[capacity];\n            memset( digits, 0, capacity );\n            size = 0;\n        }\n        BigInteger( int n, int cap ) {\n            cap = std::max( cap, (int)sizeof(n) * 8 );\n            capacity = cap, sign = sig(n), n *= sign, digits = new char[cap];\n            memset( digits, 0, cap );\n            for ( size = 0; n; ++ size ) digits[size] = n % 10, n /= 10;\n        }\n        BigInteger( int n ) {\n            capacity = 1024, sign = sig(n), n *= sign, digits = new char[capacity];\n            memset( digits, 0, capacity );\n            size = 0;\n            while (n) digits[size++] = n % 10, n /= 10;\n        }\n        BigInteger( std::string s ) {\n            capacity = std::max( (int)s.size(), 16 );\n            sign = 0, digits = new char[capacity];\n            memset( digits, 0, capacity );\n            std::istringstream in(s);\n            in >> (*this);\n        }\n        BigInteger( const BigInteger& n ) {\n            capacity = n.capacity;\n            sign = n.sign, size = n.size, digits = new char[capacity];\n            memcpy( digits, n.digits, capacity );\n        }\n\n        static bool isDigit( int c ) { return ( c >= (int)'0' && c <= (int)'9' ); }\n\n        friend std::istream& operator >>( std::istream& in, BigInteger& n ) {\n            n.size = 0, n.sign = 1;\n            int sign = 1, c;\n            while ( ( c = in.peek() ) >= 0 && ( c == ' ' || c == '\\t' || c == '\\r' || c == '\\n' ) )\n                in.get();\n            if ( c < 0 || ( c != (int)'-' && ! isDigit(c) ) ) {\n                in >> c; return in;      \n            }\n            if ( c == (int)'-' ) {\n                sign = -1; in.get();\n            }\n            while ( ( c = in.peek() ) >= 0 && isDigit(c) ) {\n                in.get(); n *= 10; n += ( c - (int)'0' );\n            }\n            n.sign = sign; n.normalize();\n            return in;\n        }\n\n        friend std::ostream& operator <<( std::ostream& out, BigInteger n ) {\n            return out << n.toString();\n        }\n\n        const BigInteger& operator =( const BigInteger& n ) {\n            if ( &n != this ) {\n                if ( capacity < n.size ) {\n                    capacity = n.capacity;\n                    delete[] digits;\n                    digits = new char[capacity];\n                }\n                sign = n.sign, size = n.size;\n                memcpy( digits, n.digits, size );\n                memset( digits + size, 0, capacity - size );\n            }\n            return *this;\n        }\n\n        const BigInteger& operator =( int n ) {\n            sign = sig(n), n *= sign;\n            for ( size = 0; n; ++ size ) {\n                digits[size] = n % 10;\n                n /= 10;\n            }\n            return *this;\n        }\n\n        ~BigInteger() {\n            delete[] digits;\n        }\n\n        void normalize() {\n            while ( size && ! digits[size-1] ) size --;\n            if ( ! size ) sign = 0;\n        }\n\n        int toInt() {\n            int result = 0;\n            for ( int i = size - 1; i >= 0; -- i ) {\n                result *= 10, result += digits[i];\n                if ( result < 0 ) return sign * 0x7FFFFFFF;\n            }\n            return sign * result;\n        }\n\n        std::string toString() {\n            std::string s = ( sign >= 0 ? \"\" : \"-\" );\n            for ( int i = size - 1; i >= 0; -- i ) s += ( digits[i] + '0' );\n            if ( size == 0 ) s += '0';\n            return s;\n        }\n\n        int sig( int n ) {\n            return ( n > 0 ? 1 : ( n == 0 ? 0 : -1 ) );\n        }\n\n        void grow() {\n            char* olddigits = digits;\n            int oldCap = capacity;\n            capacity *= 2;\n            digits = new char[capacity];\n            memcpy( digits, olddigits, oldCap );\n            memset( digits + oldCap, 0, oldCap );\n            delete [] olddigits;\n        }\n\n        BigInteger operator ++() { operator +=(1); return *this;}\n        BigInteger operator ++( int ) { return operator ++(); }\n        BigInteger operator --() { operator -=(1); return *this; }\n        BigInteger operator --( int ) { return operator--(); }\n        BigInteger operator -() { BigInteger result(*this); result.sign *= -1; return result; }\n        BigInteger operator +( int n ) { BigInteger result(*this); result += n; return result; }\n        BigInteger operator +( BigInteger n ) { BigInteger result(*this); result += n; return result; }\n\n        BigInteger& operator +=( int n ) {\n            if ( size == capacity ) grow();\n            int nsign = sig(n);\n            if ( ! nsign ) return *this;\n            if ( ! sign ) sign = nsign;\n            if ( sign == nsign ) {\n                n *= nsign;\n                int carry = 0, i;\n                for ( i = 0; n || carry; ++ i ) {\n                    int dig = n % 10, newdig = digits[i] + dig + carry;\n                    digits[i] = newdig % 10, carry = newdig / 10, n /= 10;\n                }\n                size = std::max( i, size );\n            } else {\n                operator -=( -n );\n            }\n            return *this;\n        }\n\n        BigInteger& operator +=( BigInteger n ) {\n            int maxS = std::max( size, n.size ) + 1;\n            while ( maxS >= capacity ) grow();\n            if ( ! n.sign ) return *this;\n            if ( ! sign ) sign = n.sign;\n            if ( sign == n.sign ) {\n                int carry = 0, i;\n                for ( i = 0; i < maxS - 1 || carry; ++ i ) {\n                    int newdig = carry;\n                    if ( i < size ) newdig += digits[i];\n                    if ( i < n.size ) newdig += n.digits[i];\n                    digits[i] = newdig % 10;\n                    carry = newdig / 10;\n                }\n                size = std::max( i, size );\n            } else {\n                n.sign *= -1, operator-=(n), n.sign *= -1;\n            }\n            return *this;\n        }\n\n        BigInteger operator-( int n ) { BigInteger result(*this); result -= n; return result; }\n        BigInteger operator-( BigInteger n ) { BigInteger result(*this); result -= n; return result; }\n        BigInteger operator-=( int n ) {\n            if ( size == capacity ) grow();\n            int nsign = sig(n);\n            if ( ! nsign ) return *this;\n            if ( ! sign ) sign = 1;\n            if ( sign == nsign ) {\n                BigInteger bin = n;\n                if ( ( sign >= 0 && *this < bin ) || ( sign < 0 && *this > bin ) ) {\n                    operator=( toInt() - n );\n                    return *this;\n                }\n                n *= nsign;\n                int carry = 0, i;\n                for ( i = 0; n || carry; ++ i ) {\n                    int dig = n % 10, newdig = digits[i] - dig + carry;\n                    if ( newdig < 0 ) newdig += 10, carry = -1;\n                    else carry = 0;\n                    digits[i] = newdig, n /= 10;\n                }\n                normalize();\n            } else {\n                operator+=(-n);\n            }\n            return *this;\n        }\n\n        BigInteger operator-=( BigInteger n ) {\n            int maxS = std::max( size, n.size ) + 1;\n            while ( maxS >= capacity ) grow();\n            if ( ! n.sign ) return *this;\n            if ( ! sign ) sign = 1;\n            if ( sign == n.sign ) {\n                if ( ( sign >= 0 && *this < n ) || ( sign < 0 && *this > n ) ) {\n                    BigInteger tmp = n;\n                    tmp -= *this, *this = tmp, sign = -sign;\n                    return *this;\n                }\n                int carry = 0, i;\n                for ( i = 0; i < maxS - 1; ++ i ) {\n                    int newdig = carry;\n                    if ( i < size ) newdig += digits[i];\n                    if ( i < n.size ) newdig -= n.digits[i];\n                    if ( newdig < 0 ) newdig += 10, carry = -1;\n                    else carry = 0;\n                    digits[i] = newdig;\n                }\n                if ( carry ) {\n                    if (i) digits[0] = 10 - digits[0];\n                    size = ( i ? 1 : 0 );\n                    for ( int j = 1; j < i; ++ j ) {\n                        digits[j] = 9 - digits[j];\n                        if ( digits[i] ) size = j + 1;\n                    }\n                    sign *= -1;\n                }\n                normalize();\n            } else {\n                n.sign *= -1; operator +=(n); n.sign *= -1;\n            }\n            return *this;\n        }\n\n        BigInteger operator*( int n ) {\n            BigInteger result( 0, size + (int)sizeof(n) * 8 );\n            int nsign = sig(n);\n            n *= nsign;\n            result.sign = sign * nsign;\n            if ( ! result.sign ) return result;\n            int i, j;\n            for ( i = 0; n; ++ i ) {\n                int dig = n % 10;\n                if ( dig ) {\n                    int carry = 0;\n                    for ( j = 0; j < size || carry; ++ j ) {\n                        int newDig = result.digits[i+j] + ( j < size ? dig * digits[j] : 0 ) + carry;\n                        result.digits[i+j] = newDig % 10, carry = newDig / 10;\n                    }\n                }\n                n /= 10;\n            }\n            result.size = i + j - 1;\n            return result;\n        }\n\n        BigInteger operator*( BigInteger n ) {\n            BigInteger result( 0, size + n.size );\n            result.sign = sign * n.sign;\n            if ( ! result.sign )\n                return result;\n\n            int i, j;\n            for ( i = 0; i < n.size; ++ i ) {\n                if ( n.digits[i] ) {\n                    int carry = 0;\n                    for ( j = 0; j < size || carry; ++ j ) {\n                        int newDig = result.digits[i+j] +\n                            ( j < size ? n.digits[i] * digits[j] : 0 ) + carry;\n                        result.digits[i+j] = newDig % 10, carry = newDig / 10;\n                    }\n                }\n            }\n            result.size = i + j - 1;\n            return result;\n        }\n\n        void operator *=( int n ) { operator=( operator*( n ) ); }\n        void operator *=( BigInteger n ) { operator=( operator*( n ) ); }\n\n        BigInteger operator/( int n ) {\n            if (!n) n /= n;\n            BigInteger result(*this);\n            result /= n;\n            return result;\n        }\n\n        BigInteger operator/( BigInteger n ) {\n            if (!n) n.size /= n.size;\n            BigInteger result(*this);\n            result /= n;\n            return result;\n        }\n\n        void operator/=( int n ) { divide(n); }\n        void operator/=( BigInteger n ) { divide(n); }\n        BigInteger operator%( BigInteger n ) { BigInteger tmp(*this); return tmp.divide(n); }\n        BigInteger operator%( int n ) { BigInteger tmp(*this); return tmp.divide(n); }\n        void operator%=( int n ) { operator=(divide(n)); }\n\n        int divide( int n ) {\n            if (!n) n /= n;\n            int nsign = sig(n);\n            n *= nsign;\n            if (!sign) return 0;\n            sign *= nsign;\n            int tmp = 0;\n            for ( int i = size - 1; i >= 0; -- i ) {\n                tmp *= 10, tmp += digits[i], digits[i] = tmp / n, tmp -= digits[i] * n;\n            }\n            normalize();\n            return tmp;\n        }\n\n        BigInteger divide( BigInteger n ) {\n            if (!n) n.size /= n.size;\n            if (!sign) return 0;\n            sign *= n.sign;\n            int oldSign = n.sign;\n            n.sign = 1;\n            BigInteger tmp( 0, size );\n            for ( int i = size - 1; i >= 0; -- i ) {\n                tmp *= 10, tmp += digits[i], digits[i] = 0;\n                while ( tmp >= n ) {\n                    tmp -= n, digits[i] ++;\n                }\n            }\n            normalize();\n            n.sign = oldSign;\n            return tmp;\n        }\n\n        BigInteger operator <<( int n ) { BigInteger result(*this); result <<= n; return result; }\n        BigInteger operator <<( BigInteger n ) { return operator <<( n.toInt() ); }\n        void operator <<=( int n ) {\n            if ( n < 0 ) {\n                operator >>=( -n );\n            } else if ( n > 0 ) {\n                BigInteger mult( 1, 4 * n );\n                for ( int i = ( 1 << 30 ); i; i >>= 1 ) {\n                    mult *= mult;\n                    if ( n & i ) mult *= 2;\n                }\n                operator*=(mult);\n            }\n        }\n\n        BigInteger operator >>( int n ) { BigInteger result(*this); result >>= n; return result; }\n        BigInteger operator >>( BigInteger n ) { return operator >>( n.toInt() ); }\n\n        void operator >>=( int n ) {\n            if ( n < 0 ) {\n                operator<<=(-n);\n            } else if ( n > 0 ) {\n                BigInteger mult( 1, 4 * n );\n                for ( int i = ( 1 << 30 ); i; i >>= 1 ) {\n                    mult *= mult;\n                    if ( n & i ) mult *= 2;\n                }\n                operator /=(mult);\n            }\n        }\n\n        bool operator!() { return !size; }\n        operator int() { return toInt(); }\n        operator bool() { std::cout << \"this = \" << (*this) << std::endl; return size != 0; }\n        operator std::string() { return toString(); }\n        bool operator <( const BigInteger& n ) const { return ( compare(n) < 0 );}\n        bool operator >( const BigInteger& n ) const { return ( compare(n) > 0 ); }\n        bool operator ==( const BigInteger& n ) const { return ( compare(n) == 0 ); }\n        bool operator !=( const BigInteger& n ) const { return ( compare(n) != 0 ); }\n        bool operator <=( const BigInteger& n ) const { return ( compare(n) <= 0 ); }\n        bool operator >=( const BigInteger& n ) const { return ( compare(n) >= 0 ); }\n        bool operator <( const int& n ) const { return ( compare(BigInteger(n)) < 0 ); }\n        bool operator >( const int& n ) const { return ( compare(BigInteger(n)) > 0 ); }\n        bool operator ==( const int& n ) const { return ( compare(BigInteger(n)) == 0 ); }\n        bool operator !=( const int& n ) const { return ( compare(BigInteger(n)) != 0 ); }\n        bool operator <=( const int& n ) const { return ( compare(BigInteger(n)) <= 0 ); }\n        bool operator >=( const int& n ) const { return ( compare(BigInteger(n)) >= 0 ); }\n\n        int compare( const BigInteger& n ) const {\n            if ( sign < n.sign ) return -1;\n            if ( sign > n.sign ) return 1;\n            if ( size < n.size ) return -sign;\n            if ( size > n.size ) return sign;\n            for ( int i = size - 1; i >= 0; -- i ) {\n                if ( digits[i] < n.digits[i] ) return -sign;\n                else if ( digits[i] > n.digits[i] ) return sign;\n            }\n            return 0;\n        }\n    };\n\n}\n\n// @snippet<sh19910711/contest:solution/multi_tests.cpp>\nnamespace solution {\n    using namespace std;\n\n    typedef vector <string> VS;\n\n    // [l,r]を削除する\n    template <class T> void erase( vector<T>& v, int l, int r ) {\n        v.erase( v.begin()+l, v.begin()+r+1 );\n    }\n\n    string join( string s ) {\n        string res;\n        for ( string::iterator it_i = s.begin(); it_i != s.end(); ++ it_i ) if ( *it_i != ' ' ) res += *it_i;\n        return res;\n    }\n\n    bool is_number( char c ) { return '0' <= c && c <= '9'; }\n\n    VS get_tokens( const string& s ) {\n        int n = s.size(); VS res; string token;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( is_number(s[i]) ) token += s[i];\n            else {\n                if ( ! token.empty() ) res.push_back(token);\n                res.push_back(string()+s[i]); token = \"\";\n            }\n        }\n        if ( ! token.empty() ) res.push_back(token);\n        return res;\n    }\n\n    // tokens[l...r]を字句解析する\n    math::BigInteger parse( VS& tokens, int l, int r ) {\n        stack<int> stack;\n        for ( int i = l; i <= r; ) {\n            if ( tokens[i] == \"(\" ) {\n                stack.push(i); i ++;\n            } else if ( tokens[i] == \")\" ) {\n                if ( ! stack.empty() ) {\n                    int lb = stack.top(), rb = i; stack.pop();\n                    math::BigInteger k = parse( tokens, lb+1, rb-1 ); erase( tokens, lb, lb+2 );\n                    tokens.insert( tokens.begin()+lb, k ); r -= rb - lb, i = lb;\n                }\n            } else i ++;\n        }\n\n        for ( int i = l; i + 2 <= r; ) {\n            if ( tokens[i+1] == \"*\" ) {\n                math::BigInteger k = math::BigInteger(tokens[i]) * math::BigInteger(tokens[i+2]);\n                tokens.insert( tokens.begin()+i, k ); r -= 2; erase( tokens, i+1, i+3 );\n            } else if ( tokens[i+1] == \"/\" ) {\n                math::BigInteger k = math::BigInteger(tokens[i]) / math::BigInteger(tokens[i+2]);\n                tokens.insert( tokens.begin()+i, k ); r -= 2; erase( tokens, i+1, i+3 );\n            } else i += 2;\n        }\n\n        while ( r - l + 1 >= 3 ) {\n            if ( tokens[l+1] == \"+\" ) {\n                math::BigInteger k = math::BigInteger(tokens[l]) + math::BigInteger(tokens[l+2]);\n                tokens.insert( tokens.begin()+l, k ); r -= 2; erase( tokens, l+1, l+3 );\n            } else if ( tokens[l+1] == \"-\" ) {\n                math::BigInteger k = math::BigInteger(tokens[l]) - math::BigInteger(tokens[l+2]);\n                tokens.insert( tokens.begin()+l, k ); r -= 2; erase( tokens, l+1, l+3 );\n            }\n        }\n\n        return math::BigInteger( tokens[l] );\n    }\n\n    math::BigInteger eval( string exp ) { \n        VS tokens = get_tokens(join(exp));\n        return parse(tokens, 0, tokens.size()-1);\n    }\n\n    class Solution: public ISolution {\n    public:\n        string s;\n        bool input() { return cin >> s; }\n        void solve() { cout << eval( s.substr(0, s.size() - 1) ) << endl; }\n        int run() {\n            int tests = 0; cin >> tests;\n            for ( int i = 0; i < tests; ++ i ) { init();input();solve();output(); }\n            return 0;\n        }\n    };\n\n}\n\n\n// @snippet<sh19910711/contest:main.cpp>\nint main() { return solution::Solution().run(); }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for( int i = 0; i < n; i++ )\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define INF 2000000000\n#define mod 1000000007\n#define INF2 1000000000000000000\n\nint mul10 (int x, int y) {\n    int ret = 1;\n    for (int i = 0; i < x; i++) {\n        ret *= 10;\n    }\n    ret *= y;\n    return ret;\n}\n\nint cal (char sym, int x, int y) {\n    if (sym == '+') {\n        return x + y;\n    } else if (sym == '*') {\n        return x * y;\n    } else if (sym == '-') {\n        return x - y;\n    } else if (sym == '/') {\n        return x / y;\n    }\n}\nint depth_parentheses (string str) {\n    int count = 0;\n    int count_max = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') count++;\n        else if (str[i] == ')') count--;\n        count_max = max(count_max, count);\n    }\n    return count_max;\n}\n\nint findL_parentheses (string str, int depth) {\n    int L = 0;\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findL_parentheses (string str) {\n    int L = 0;\n    int depth = depth_parentheses(str);\n    rep(i, str.length()) {\n        if (str[i] == '(') L++;\n        else if (str[i] == ')') L--;\n        if (L == depth) {\n            return i;\n        }\n    }\n}\n\nint findR_parentheses (string str) {\n    int R;\n    int L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\n\nint findR_parentheses (string str, int L) {\n    int R;\n    if (L == 0) L = findL_parentheses(str);\n    for (int i = L+1; i < str.length(); i++) {\n        R = i;\n        if (str[i] == ')') break;\n    }\n    return R;\n}\nstring takeout_parentheses (string str) {\n    string ret;\n    int depth = depth_parentheses(str);\n    int L = findL_parentheses(str, depth);\n    int R = findR_parentheses(str, L);\n    //dump(depth);\n    //dump(L);\n    //dump(R);\n    stringstream str_tmp;\n    for (int i = L+1; i < R; i++) str_tmp << str[i];\n    ret = str_tmp.str();\n    return ret;\n}\n\nint find_muldiv (string str) {\n    int sym = 0;\n    while (str[sym] >= '0' && str[sym] <= '9' || str[sym] == '+' || str[sym] == '-') sym++;\n    return sym;\n}\nint find_addsub (string str) {\n    int sym = 0;\n    while (str[sym] >= '0' && str[sym] <= '9') sym++;\n    return sym;\n}\n\nstring cal_mul (string str, int sym) {\n    if (sym == str.length()) return str;\n\n    int L = 1, R = 1;\n    int sumL = 0, sumR = 0;\n    while (str[sym-L] >= '0' && str[sym-L] <= '9') {\n        sumL += mul10(L-1, (str[sym-L] - '0'));\n        L++;\n    }\n    while (str[sym+R] >= '0' && str[sym+R] <= '9') {\n        R++;\n    }\n    rep(i ,R-1) {\n        sumR += mul10(i, str[sym+R-i-1] - '0');\n    }\n    //cout << sumL << endl;\n    //cout << sumR << endl;\n    stringstream str_tmp;\n    rep(i, sym-L+1) str_tmp << str[i];\n    str_tmp << cal(str[sym], sumL, sumR);\n    for(int i = sym+R; i < str.length(); i++) str_tmp << str[i];\n    str = str_tmp.str();\n    //cout << str << endl;\n    return str;\n}\n\nstring cal_all (string str) {\n    string prev = str;\n    while(true){\n        str = cal_mul(str, find_muldiv(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    while(true){\n        str = cal_mul(str, find_addsub(str));\n        if ( prev == str ) break;\n        else prev = str;\n    }\n    return str;\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    rep(i ,n){\n        string str; cin >> str;\n        str.erase( --str.end() );\n\n        //?????£?????????????¨??????????\n        while(depth_parentheses(str) > 0){\n            string sube = takeout_parentheses(str);\n            sube = cal_all(sube);\n\n            int L = findL_parentheses(str);\n            int R = findR_parentheses(str);\n            stringstream str_tmp;\n            rep(i, L) str_tmp << str[i];\n            str_tmp << sube;\n            for (int i = R+1; i < str.length(); i++) {\n                str_tmp << str[i];\n            }\n            str = str_tmp.str();\n            //cout << str << endl;\n        }\n\n        //?????£?????????????????¶?????§?¨??????????\n        string prev = str;\n        while(true){\n            str = cal_mul(str, find_muldiv(str));\n            if ( prev == str ) break;\n            else prev = str;\n        }\n        while(true){\n            str = cal_mul(str, find_addsub(str));\n            if ( prev == str ) break;\n            else prev = str;\n        }\n        //?????????????????????\n        cout << str << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing State = string::const_iterator;\nclass ParseError {};\nint expr(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint number(State &begin);\nint expr(State &begin) {\n  int ret = term(begin);\n  if(*begin == '=') return ret;\n  while(1) {\n    if(*begin == '+') {\n      begin++;\n      ret += term(begin);\n    } else if(*begin == '-') {\n      begin++;\n      ret -= term(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nint term(State &begin) {\n  int ret = factor(begin);\n  if(*begin == '=') return ret;\n  while(1) {\n    if(*begin == '*') {\n      begin++;\n      ret *= factor(begin);\n    } else if(*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nint factor(State &begin) {\n  int ret = 0;\n  if(*begin == '=') return ret;\n  if(*begin == '(') {\n    begin++;\n    ret = expr(begin);\n    begin++;\n  } else {\n    ret = number(begin);\n  }\n  return ret;\n}\nint number(State &begin) {\n  int ret = 0;\n  if(*begin == '=') return ret;\n  while(isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\nint main() {\n  int n; cin >> n;\n  cin.ignore();\n  for(int i=0;i<n;++i) {\n    string s;\n    getline(cin, s);\n    State begin = s.begin();\n    int ans = expr(begin);\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef string::const_iterator State;\n\nstring s;\n\nint eval(State &beg);\n\nint number( State &beg ){\n    if(*beg=='('){\n        beg++;\n        int ret = eval(beg);\n        beg++;\n        return ret;\n    }\n    \n    string ret=\"\";\n    while(1){\n        if( isdigit(*beg) ){\n            ret+=*beg;\n            beg++;\n        }\n        else break;\n    }\n    \n    return stoi(ret);\n}\n\nint term(State &beg){\n    int ret = number(beg);\n    \n    while(1){\n        if( *beg=='*' ){\n            beg++;\n            ret *= number(beg);\n        }\n        else if( *beg=='/' ){\n            beg++;\n            ret /= number(beg);\n        }\n        else break;\n    }\n\n    return ret;\n}\n\nint eval(State &beg){\n    int ret=term(beg);\n    \n    while(*beg!='=' && *beg!=')'){\n        beg++;\n        if(*(beg-1)=='+')       ret+=term(beg);\n        else if(*(beg-1)=='-')  ret-=term(beg);\n        else throw(\"error\");\n    }\n    return ret;\n}\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        cin>>s;\n        \n        State beg = s.begin();\n        try{\n            cout<<eval(beg)<<endl;\n        }catch(string s){\n            cout<<s<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n\nconst char *p;\nclass ParseError {};\n\nint expression();\nint term();\nint factor();\nvoid consume(char);\n\nint main() {\n  using namespace std;\n\n  int n;\n  string str;\n  int ans;\n\n  cin >> n;\n  cin.ignore();\n  for(int i = 0; i < n; i++) {\n    getline(cin, str);\n    p = str.c_str();\n    cout << *p << endl;\n\n    ans = expression();\n    consume('=');\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n\nvoid consume(char expected) {\n  if(*p == expected) {\n    p++;\n  } else {\n    std::cerr << \"Expected '\" << expected << \"' but got '\" << *p << \"'\" << std::endl;\n    std::cerr << \"Rest string is '\";\n    while(*p) {\n      std::cerr << *p++;\n    }\n    std::cerr << \"'\" << std::endl;\n    throw ParseError();\n  }\n}\n\nint factor() {\n  int ret;\n  char *e;\n  \n  if(*p == '(') {\n    consume('(');\n    ret = expression();\n    consume(')');\n  } else {\n    ret = strtol(p, &e, 10);\n    p = e;\n  }\n  \n  return ret;\n}\n\nint term() {\n  int ret = factor();\n  \n  for(;;) {\n    if(*p == '*') {\n      p++;\n      ret *= factor();\n    } else if (*p == '/') {\n      p++;\n      ret /= factor();\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint expression() {\n  int ret = term();\n  \n  for(;;) {\n    if(*p == '+') {\n      p++;\n      ret += term();\n    } else if (*p == '-') {\n      p++;\n      ret -= term();\n    } else {\n      break;\n    }\n  }\n  \n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CK(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\ntypedef string::const_iterator State;\n\nint number(State &);\nint factor(State &);\nint term(State &);\nint expression(State &);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n  int ret = 0;\n  while (isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    //??¨????????????\n    return -INF;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n  int ret = factor(begin);\n  for (;;) {\n    if (*begin == '*') {\n        begin++;\n        ret *= factor(begin);\n    } else if (*begin == '/') {\n        begin++;\n        ret /= factor(begin);\n    } else {\n        break;\n    }\n  }\n  return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n  int ret = term(begin);\n  for (;;) {\n    if (*begin == '+') {\n        begin++;\n        ret += term(begin);\n    } else if (*begin == '-') {\n        begin++;\n        ret -= term(begin);\n    } else {\n        break;\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  int N;\n  cin>>N;\n  REP(i,0,N){\n    string S;\n    cin>>S;\n    State state = S.begin();\n    cout<<expression(state)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,l,n) for(int i=l;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define MAX 100\nusing namespace std;\nint ans;\nint n,pointer;\nchar input[MAX];\nint evalE();\nint evalT();\nint evalF();\nint main(){\n  cin >> n;\n  rep(i,n){\n    pointer = 0;\n    cin >> input;\n    ans = evalE();\n    cout << ans <<endl;\n  }\n  return 0;\n}\nint evalE(){\n  int value = evalT();\n  while(true){\n    if(input[pointer] == '+'){\n      pointer++;\n      value += evalT();\n    }else if(input[pointer] == '-'){\n      pointer++;\n      value -= evalT();\n    }else{\n      break;\n    }\n  }\n  return value;\n}\nint evalT(){\n  int value = evalF();\n  while(true){\n    if(input[pointer] == '*'){\n      pointer++;\n      value *= evalF();\n    }else if(input[pointer] == '/'){\n      pointer++;\n      value /= evalF();\n    }else{\n      break;\n    }\n  }\n  return value;\n}\nint evalF(){\n  int value = 0;\n  if(input[pointer] == '('){\n    pointer++;\n    value = evalE();\n    assert(input[pointer] == ')');\n    pointer++;\n  }\n  while(input[pointer]>='0'&&input[pointer]<='9'){\n    value *= 10;\n    value += (int)(input[pointer++] - '0');\n  }\n  return value;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint number(State &begin);\nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\t\n\twhile (isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\t//cout << \"number :: \" << ret << endl;\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = number(begin);\n\t\n\twhile(1) {\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go factor // *\" << endl;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go factor // /\" << endl;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse break;\n\t}\n\t//cout << \"term :: \" << ret << endl;\n    return ret;\n}\nint expression(State &begin) {\n\tint ret = term(begin);\n\t\n\twhile(1) {\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go term // +\" << endl;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tbegin++;\n\t\t\t//cout << \"go term // -\" << endl;\n\t\t\tret -= term(begin);\n        }\n        else break;\n\t}\n\t//cout << \"expression :: \" << ret << endl;\n\treturn ret;\n}\nint factor(State &begin) {\n\tif (*begin == '(') {\n\t\tbegin++; \n\t\t//cout << \"go expression\" << endl;\n\t\tint ret = expression(begin);\n\t\t//cout << \"factor :: \" << ret << endl;\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse return number(begin);\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tcin.ignore();\n\tfor (int i = 0; i < n; i++) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\t\n\t\tState begin = s.begin();\n\t\t//cout << \"Start !!!\" << endl;\n\t\tcout << expression(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main()\n{\ncout << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string>\n#include<vector>\n#include<sstream>\n\nstd::string a;\nstd::vector<std::string>v;\nstd::vector<std::string>va;\nstd::stack<std::string>s;\nint i=0;\n\nvoid bun(){\n\tint ii=0,k=0;\n\tfor(int jj=0;jj<a.size();jj++){\n\t\tif(a[jj]=='+'||a[jj]=='-'||a[jj]=='*'||a[jj]=='/'||a[jj]==')'){\n\t\t\tif(a[jj-1]!=')'){\n\t\t\t\tv.push_back(\"1\");\n\t\t\t\tstd::stringstream z;\n\t\t\t\tz<<a.substr(ii,jj-ii);\n\t\t\t\tz>>v[k];\n\t\t\t\tk++;\n\t\t\t\tii=jj+1;\n\t\t\t}\n\t\t\tv.push_back(\"1\");\n\t\t\tv[k]=a[jj];\n\t\t\tk++;\n\t\t}else if(a[jj]=='('){\n\t\t\tv.push_back(\"1\");\n\t\t\tv[k]=a[jj];\n\t\t\tk++;\n\t\t\tii=jj+1;\n\t\t}else if(jj==a.size()-1){\n\t\t\tv.push_back(\"1\");\n\t\t\tjj++;\n\t\t\tstd::stringstream z;\n\t\t\tz<<a.substr(ii,jj-ii);\n\t\t\tz>>v[k];\n\t\t}\n\t}\n}\n\nstd::string change(double p){\n\tstd::stringstream z;\n\tstd::string str;\n\tz<<p;\n\tz>>str;\n\treturn str;\n}\n\nvoid por(int p,int q,int si){\n\tint m=0,ma=0;\n\tfor(int k=p;k<=q;k++){\n\t\tif(v[k]==\")\"){}\n\t\telse if(v[k]==\"(\"){\n\t\t\tint ky,z=1;\n\t\t\tfor(ky=k+1;ky<=q;ky++){\n\t\t\t\tif(v[ky]==\"(\")z++;\n\t\t\t\tif(v[ky]==\")\")z--;\n\t\t\t\tif(z==0)break;\n\t\t\t}\n\t\t\tpor(k+1,ky-1,s.size());\n\t\t\tk=ky;\n\t\t}else if(v[k]!=\"+\"&&v[k]!=\"-\"&&v[k]!=\"*\"&&v[k]!=\"/\"){\n\t\t\tva.push_back(\"1\");\n\t\t\tva[i]=v[k];\n\t\t\ti++;\n\t\t}else if(v[k]==\"+\"||v[k]==\"-\"||v[k]==\"*\"||v[k]==\"/\"){\n\t\t\tif(v[k]==\"+\")ma=1;\n\t\t\tif(v[k]==\"-\")ma=1;\n\t\t\tif(v[k]==\"*\")ma=2;\n\t\t\tif(v[k]==\"/\")ma=3;\n\t\t\twhile(ma<=m&&s.size()>si){\n\t\t\t\tva.push_back(\"1\");\n\t\t\t\tva[i]=s.top();\n\t\t\t\ts.pop();\n\t\t\t\ti++;\n\t\t\t\tif(s.size()>=1){\n\t\t\t\t\tif(s.top()==\"+\")m=1;\n\t\t\t\t\tif(s.top()==\"-\")m=1;\n\t\t\t\t\tif(s.top()==\"*\")m=2;\n\t\t\t\t\tif(s.top()==\"/\")m=3;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\ts.push(v[k]);\n\t\t\tm=ma;\n\t\t}if(k==q){\n\t\t\twhile(s.size()>si){\n\t\t\t\tva.push_back(\"1\");\n\t\t\t\tva[i]=s.top();\n\t\t\t\ts.pop();\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstd::string calc(){\n\tstd::stack<std::string>sa;\n\tfor(int k=0;k<va.size();k++){\n\t\tif(va[k]!=\"+\"&&va[k]!=\"-\"&&va[k]!=\"*\"&&va[k]!=\"/\")sa.push(va[k]);\n\t\telse{\n\t\t\tstd::stringstream z;\n\t\t\tstd::stringstream zz;\n\t\t\tdouble x,y;\n\t\t\tz<<sa.top();\n\t\t\tz>>x;\n\t\t\tsa.pop();\n\t\t\tzz<<sa.top();\n\t\t\tzz>>y;\n\t\t\tsa.pop();\n\t\t\tif(va[k]==\"+\")sa.push(change(y+x));\n\t\t\tif(va[k]==\"-\")sa.push(change(y-x));\n\t\t\tif(va[k]==\"*\")sa.push(change(y*x));\n\t\t\tif(va[k]==\"/\")sa.push(change(y/x));\n\t\t}\n\t}\n\treturn sa.top();\n}\n\nint main(){\n\tstd::stringstream z;\n\tdouble ans;\n\tstd::cin>>a;\n\ta.erase(a.size(),1);\n\tbun();\n\tpor(0,v.size()-1,0);\n\tz<<calc();\n\tz>>ans;\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nnamespace parser{\n\ntypedef string::const_iterator state;\nclass parse_error{};\n\nint number(state&);\nint factor(state&);\nint term(state&);\nint expression(state&);\n\n// 数字の列をパースして、その数を返す。\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\n// 括弧か数をパースして、その評価結果を返す。\nint factor(state &begin){\n    if(*begin=='('){\n        ++begin;\n        int res=parser::expression(begin);\n        ++begin;\n        return res;\n    }else return parser::number(begin);\n}\n\n// 乗算除算の式をパースして、その評価結果を返す。\nint term(state &begin){\n    int res=parser::factor(begin);\n    while(true){\n        if(*begin=='*'){\n            ++begin;\n            res*=parser::factor(begin);\n        }else if(*begin=='/'){\n            ++begin;\n            res/=parser::factor(begin);\n        }else break;\n    }\n    return res;\n}\n\n// 四則演算の式をパースして、その評価結果を返す。\nint expression(state &begin){\n    int res=parser::term(begin);\n    while(true){\n        if(*begin=='+'){\n            ++begin;\n            res+=parser::term(begin);\n        }else if(*begin=='-'){\n            ++begin;\n            res-=parser::term(begin);\n        }else break;\n    }\n    return res;\n}\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    cin.ignore();\n    rep(i,0,n){\n        string s;\n        getline(cin,s);\n        \n        parser::state begin=s.begin();\n        int ans=parser::expression(begin);\n        cout << ans << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#define I int\nI E();std::string S;I P,V;I T(){for(V=0;isdigit(S[P]);)V=V*10+S[P++]-48;return S[P]-40?V:!!++P*E()*!!++P;}I F(){I a=T();for(;S[P]==42|S[P]==47;)a=S[P++]-47?a*=T():a/=T();return a;}I E(){I a=F();for(;S[P]==43|S[P]==45;)a+=-(S[P++]==45)*F();return a;}main(){for(std::cin>>P;std::cin>>S;printf(\"%d\\n\",E()))S[S.size()-1]=P=0;}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef enum{\n\tINT,\n\tPLUS,\n\tMINUS,\n\tMUL,\n\tDIV,\n\tEQ,\n\tLPAREN,\n\tRPAREN,\n\tNL\n} token_kind_t;\n\ntypedef struct token{\n\tint c;\n\ttoken_kind_t kind;\n\tint ival;\n} *token_t;\n\nint calc_expr_add(token_t t);\n\ntoken_t next_tok(token_t t)\n{\n\twhile (t->c == ' ' || t->c == '\\n') {\n\t\tt->c = getchar();\n\t}\n\tif (isdigit(t->c)){\n\t\tt->ival = 0;\n\t\tt->kind = INT;\n\t\twhile (isdigit(t->c)){\n\t\t\tt->ival *= 10;\n\t\t\tt->ival += t->c - '0';\n\t\t\tt->c = getchar();\n\t\t}\n\t}\n\telse{\n\t\tif (t->c == '+') t->kind = PLUS;\n\t\telse if (t->c == '-') t->kind = MINUS;\n\t\telse if (t->c == '*') t->kind = MUL;\n\t\telse if (t->c == '/') t->kind = DIV;\n\t\telse if (t->c == '(') t->kind = LPAREN;\n\t\telse if (t->c == ')') t->kind = RPAREN;\n\t\telse if (t->c == '=') t->kind = EQ;\n\t\telse if (t->c == '\\n') t->kind = NL;\n\t\telse exit(1);\n\n\t\tt->c = getchar();\n\t}\n\n\treturn t;\n}\n\ntoken_t mk_tok()\n{\n\ttoken_t t;\n\tif ((t = (token_t)malloc(sizeof(struct token))) == NULL){\n\t\tperror(\"malloc\");\n\t\texit(1);\n\t}\n\n\tt->c = getchar();\n\n\treturn t;\n}\n\nint calc_expr_un(token_t t)\n{\n\tint ret = 0;\n\tif (t->kind == INT){\n\t\tret = t->ival;\n\t\tnext_tok(t);\n\t}\n\telse if (t->kind == LPAREN){\n\t\tnext_tok(t);\n\t\tret = calc_expr_add(t);\n\t\tif (t->kind != RPAREN) exit(1);\n\t\tnext_tok(t);\n\t}\n\telse if (t->kind == PLUS || t->kind == MINUS){\n\t\tif (t->kind == PLUS){\n\t\t\tnext_tok(t);\n\t\t\tret += calc_expr_un(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret -= calc_expr_un(t);\n\t\t}\n\t}\n\telse exit(1);\n\treturn ret;\n}\n\nint calc_expr_mul(token_t t)\n{\n\tint ret = 0;\n\tret = calc_expr_un(t);\n\twhile (t->kind == MUL || t->kind == DIV){\n\t\tif (t->kind == MUL){\n\t\t\tnext_tok(t);\n\t\t\tret *= calc_expr_un(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret /= calc_expr_un(t);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_expr_add(token_t t)\n{\n\tint ret = 0;\n\tret = calc_expr_mul(t);\n\twhile (t->kind == PLUS || t->kind == MINUS){\n\t\tif (t->kind == PLUS){\n\t\t\tnext_tok(t);\n\t\t\tret += calc_expr_mul(t);\n\t\t}\n\t\telse {\n\t\t\tnext_tok(t);\n\t\t\tret -= calc_expr_mul(t);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint calc_expr(token_t t)\n{\n\tint ret = 0;\n\n\tnext_tok(t);\n\tret = calc_expr_add(t);\n\tif (t->kind != EQ) exit(1);\n\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\n\tn = getchar() - '0';\n\tgetchar();\n\n\ttoken_t t = mk_tok();\n\n\tint i;\n\tfor (i = 0; i < n; i++){\n\t\tint result = calc_expr(t);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\n\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\n\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    cin >> n;\n    rep(i, n) {\n        string s;\n        cin >> s;\n\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstring str;\n\nP expr(int);\nP term(int);\nP factor(int);\nP number(int);\n\nP expr(int idx)\n{\n  P res = term(idx);\n  idx = res.first;\n  int ans = res.second;\n  \n  while (idx < str.size() && (str[idx] == '+' || str[idx] == '-')) {\n    res = term(idx + 1);\n    bool plus = (str[idx] == '+');\n    idx = res.first;\n    \n    if (plus) {\n      ans += res.second;\n    } else {\n      ans -= res.second;\n    }\n  }\n  return make_pair(idx, ans);\n}\n\nP term(int idx)\n{\n  P res = factor(idx);\n  idx = res.first;\n  int ans = res.second;\n  \n  while (idx < str.size() && (str[idx] == '*' || str[idx] == '/')) {\n    res = factor(idx + 1);\n    bool mult = (str[idx] == '*');\n    idx = res.first;\n    \n    if (mult) {\n      ans *= res.second;\n    } else {\n      ans /= res.second;\n    }\n  }\n  return make_pair(idx, ans);\n}\n\nP factor(int idx)\n{\n  if (str[idx] == '(') {\n    P res = expr(idx + 1);\n    res.first++;\n    return res;\n  } else if (isdigit(str[idx])) {\n    P res = number(idx);\n    return res;\n  }\n}\n\nP number(int idx)\n{\n  int N = 0;\n  while (idx < str.size() && isdigit(str[idx])) {\n    N *= 10;\n    N += str[idx++] - '0';\n  }\n  return make_pair(idx, N);\n}\n\nvoid solve()\n{\n  int ans = expr(0).second;\n  cout << ans << endl;\n}\n\nint main()\n{\n  int N;\n  scanf(\"%d \", &N);\n  \n  for (int i = 0; i < N; i++) {\n    getline(cin, str);\n    str.erase(str.begin() + str.size() - 1);\n    //cout << str << endl;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <ctime>\n#include <string>\n#include <map>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\nint n;\nstring S;\nint cur;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur++;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile(cur < S.size() && isdigit(S[cur])){\n\t\tn = n * 10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur++;\n\tint n = expression();\n\tcur++;\n\treturn n;\t\n}\n\nint term(){\n\tint sum = factor();\n\twhile(cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = factor();\n\t\tif(op == '*') sum *= b;\n\t\telse sum /= b;\n\t}\n\treturn sum;\n}\n\nint expression(){\n\tint sum = term();\n\twhile(cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur];\n\t\tcur++;\n\t\tint b = term();\n\t\tif(op == '+') sum += b;\n\t\telse sum -= b;\n\t}\n\treturn sum;\n\t\n}\n\n\nint main(void){\n\n\tcin >> n;\n\n\tfor(int i = 0; i < n; i++){\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\nstring str;\nint pos;\n\nint exp(void);\nint term(void);\nint factor(void);\n\nint main(){\n  int i,j,n,ans;\n  cin >> n;\n  for(i=0;i<n;i++){\n    cin >> str;\n    str.erase(str.size()-1);\n    pos = 0;\n    ans = exp();\n    cout << ans << endl;\n    str.clear();\n  }\n  return 0;\n}\n\nint exp(void){\n  int x = term();\n  while(str[pos] == '+' || str[pos] == '-'){\n    char op = str[pos++];\n    if(op == '+') x += term();\n    else if(op == '-') x -= term();\n  }\n  return x;\n}\n\nint term(void){\n  int x = factor();\n  while(str[pos] == '*' || str[pos] == '/'){\n    char op = str[pos++];\n    if(op == '*') x *= factor();\n    else if(op == '/') x /= factor();\n  }\n  return x;\n}\n\nint factor(void){\n  int x=0,c;\n  if(str[pos] == '('){\n    pos++;\n    x = exp();\n    pos++;\n  }\n  else{\n    while(str[pos] >= '0' && str[pos] <= '9'){\n      x *= 10;\n      x += str[pos++] - '0';\n    }\n  }\n  return x;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit() {\n\tint n;\n\tassert(isdigit(S[cur]));\n\tn = S[cur] -'0';\n\t++cur;\n\treturn n;\n}\n\nint number() {\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur])) {\n\t\tn = n*10 + digit();\n\t}\n\treturn n;\n}\n\nint expression();\nint factor() {\n\tint n;\n\tif (S[cur] != '(') n = number();\n\telse {\n\t\t++cur;\n\t\tn = expression();\n\t\tassert(S[cur] == ')');\n\t\t++cur;\n\t}\n\treturn n;\n}\n\nint term() {\n\tint t = factor();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')) {\n\t\tchar op = S[cur++];\n\t\tint b = factor();\n\t\tif(op == '*') t *= b; else t = (int)trunc(1.0*t/b);\n\t\tcout << t << endl;\n\t}\n\treturn t;\n}\n\n\n/*int expression() {\n\tint sum = number();\n\twhile (S[cur] == '+' || S[cur] == '-') {\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif(op == +) sum += b;\telse return sum -= b;\n\t}\n\treturn sum;\n}*/\n\nint expression() {\n\tint sum = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')) {\n\t\tchar op = S[cur++];\n\t\tint b = term();\n\t\tif(op == '+') sum += b; else sum -= b;\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor (int i=0; i<N; ++i) {\n\t\tcur = 0;\n\t\tcin >> S;\n\t\tS.resize(S.size()-1);\n\t\tcout << expression() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,l,n) for(int i=l;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define MAX 100\nusing namespace std;\nint ans;\nint n,pointer;\nchar input[MAX];\nint evalE();\nint evalT();\nint evalF();\nint main(){\n  cin >> n;\n  rep(i,n){\n    pointer = 0;\n    cin >> input;\n    ans = evalE();\n    cout << ans <<endl;\n  }\n  return 0;\n}\nint evalE(){\n  int value = evalT();\n  while(true){\n    if(input[pointer] == '+'){\n      pointer++;\n      value += evalT();\n    }else if(input[pointer] == '-'){\n      pointer++;\n      value -= evalT();\n    }else{\n      break;\n    }\n  }\n  return value;\n}\nint evalT(){\n  int value = evalF();\n  while(true){\n    if(input[pointer] == '*'){\n      pointer++;\n      value *= evalF();\n    }else if(input[pointer] == '/'){\n      pointer++;\n      value /= evalF();\n    }else{\n      break;\n    }\n  }\n  return value;\n}\nint evalF(){\n  int value = 0;\n  if(input[pointer] == '('){\n    pointer++;\n    value = evalE();\n    assert(input[pointer] == ')');\n    pointer++;\n  }\n  while(input[pointer]>='0'&&input[pointer]<='9'){\n    value *= 10;\n    value += (int)(input[pointer++] - '0');\n  }\n  return value;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHokudai Practice Contest 2014\nC - Smart Calculator\n\nティツァツ」テヲツウツ陛ッツシツ堙ヲツァツ凝ヲツ鳴?ィツァツ」テヲツ楪?\nテ・ツ?クテ・ツ楪凝ァツ堋?」ツ?ェテヲツァツ凝ヲツ鳴?ィツァツ」テヲツ楪静・ツ閉湘ゥツ。ツ古」ツ??\nテ」ツ?陛」ツ?セテ」ツ?姪」ツ?セテ」ツ?ェテヲツ可凝ヲツウツ陛」ツ?古ィツ?ε」ツ?暗」ツつ嘉」ツつ古」ツつ凝」ツ?古ゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝・ツ?催・ツクツーテァツ堋?・ツ?ヲテァツ青?」ツつ津ィツ。ツ古」ツ??ヲツ鳴ケテヲツウツ陛」ツ?古ァツーツ。テ・ツ債佚」ツ?ァテ」ツ?づ」ツつ凝」ツ??\nテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテァツュツ氾」ツ?暗」ツつ津ィツィツ暗ァツョツ療」ツ?凖」ツつ凝ゥツ鳴「テヲツ閉ーテ」ツつ津ァツ板ィテヲツ?湘」ツ?療」ツ?ヲテ」ツ??)テ」ツ?ォテ・ツ崢イテ」ツつ湘」ツつ古」ツ?淌ゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ョティツィツ暗ァツョツ療」ツつ津・ツ?催・ツクツーテ」ツ?ァテヲツアツづ」ツつ?」ツつ凝」ツ??\n\n1テ・ツコツヲテ」ツ?ョテ・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療」ツ?ョテ・ツ?ヲテァツ青?ヲツ卍づゥツ鳴禿」ツ?ッO(n)テ」ツ?ァテ」ツ?づ」ツつ凝」ツ??\n()テ」ツ?ョテ」ツδ堙」ツつ「テ」ツ?ョテヲツ閉ーテ」ツ??」ツ?妥・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療」ツ?古ィツ。ツ古」ツつ湘」ツつ古」ツつ凝」ツ?ョテ」ツ?ァテ」ツ??・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療」ツ?ョテヲツ閉ーテ」ツつづ」ツ?セテ」ツ?欅(n)テ」ツ?ァテ」ツ?づ」ツつ凝」ツ??\nテ」ツつ暗」ツ?」テ」ツ?ヲテ」ツ??ヲツ卍づゥツ鳴禿ィツィツ暗ァツョツ療ゥツ?湘」ツ?ッO(n^2)テ」ツ?ァテ」ツ?づ」ツつ凝」ツ??\n*/\n\n#include<iostream>\n#include<string>\nusing namespace std;\n\n//テヲツ鳴?・ツュツ療・ツ按療」ツつ津」ツつーテ」ツδュテ」ツδシテ」ツδ静」ツδォテ・ツ、ツ嘉ヲツ閉ーテ」ツ?ォテァツスツョテ」ツ?催」ツ??ヲツ鳴?・ツュツ療」ツ?ョテゥツ鳴凝・ツァツ凝、ツスツ催ァツスツョテ」ツ?ィテァツオツづ、ツコツ?、ツスツ催ァツスツョテ」ツつ津ゥツ鳴「テヲツ閉ーテ」ツ?ォテ、ツクツ偲」ツ?暗」ツつ凝」ツ?禿」ツ?ィテ」ツ?ァテ」ツ??\n//テゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツつ津ゥツ鳴「テヲツ閉ーテ」ツ?ォテヲツクツ。テ」ツ?凖」ツ?ョテ」ツ?ィテ・ツ青古ァツュツ嘉」ツ?ョテ・ツ?ヲテァツ青?」ツ?古」ツ?ァテ」ツ?催」ツつ?\nstring s;\n\n//テゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按耀[l,r)テ」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝・ツ?催・ツクツーテァツ堋?」ツ?ェテヲツァツ凝ヲツ鳴?ィツァツ」テヲツ楪?\n//lテヲツ鳴?・ツュツ療ァツ崢ョテ」ツ?凝」ツつ嘉・ツァツ凝」ツ?セテ」ツつ甘」ツ?〉-1テヲツ鳴?・ツュツ療ァツ崢ョテ」ツ?ァテァツオツづ」ツつ湘」ツつ凝・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴禿」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?禿」ツ?ィテ」ツ?ォテヲツウツィテヲツ??\n//(テ・ツ個コテゥツ鳴禿」ツつ津ヲツ可アテ」ツ??ヲツ卍づ」ツ?ッテ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴禿」ツ??」ツ?ィテゥツδステ・ツ青暗」ツ?古」ツつ暗」ツ??」ツ?禿」ツ?ィテ」ツ?古・ツ、ツ堙」ツ?湘」ツ?，++ STLテ」ツ?ァテ」ツつづ・ツ、ツ堙」ツ?湘」ツ?ョテ・ツ?エテ・ツ青暗」ツ?敕」ツ??」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ?\nint parse(int l, int r){\n  //テ・ツ?催・ツクツーテ・ツ?ヲテァツ青?・ツ??」ツ?ァテ」ツ?ッテ」ツ??・ツ?ェテ・ツ?暗ゥツ??、ツスツ催」ツ?ョテ、ツスツ偲」ツ??ィツィツ暗ァツョツ療」ツ?凝」ツつ嘉・ツ?暗」ツ?ォティツィツ佚ィツソツーテ」ツ?凖」ツつ?\n  //テ」ツ?ェテ」ツ?愿」ツ?ェテ」ツつ嘉」ツ??・ツ?催・ツクツーテ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?療・ツ?暗」ツ?ョティツィツ暗ァツョツ療」ツ?ョテヲツ鳴ケテ」ツ?古・ツ?ェテ・ツ?暗ァツ堋?」ツ?ォティツ。ツ古」ツつ湘」ツつ古」ツつ凝」ツ?凝」ツつ嘉」ツ?ァテ」ツ?づ」ツつ?\n  //テ」ツつ暗」ツ?」テ」ツ?ヲテ」ツ??+-\"->\"*/\"->\"()\"->\"テヲツ閉ーテ・ツュツ?テ」ツ?ョテゥツ??」ツ?ォティツィツ佚ィツソツーテ」ツ?凖」ツつ?\n\n  //k:テゥツ鳴嘉」ツ?佚ヲツ仰ャテ・ツシツァテ」ツ?ョテヲツ閉ーテ」ツ?ョテ」ツつォテ」ツつヲテ」ツδウテ」ツつソテ」ツ?Ｌ=0テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ??・ツョツ古・ツ?ィテ」ツ?ォテヲツ仰ャテ・ツシツァテ」ツ?古ゥツ鳴嘉」ツ?佚」ツ?ヲテ」ツ??」ツつ?\n  int k = 0;\n\n  //+,-テ」ツ?ョテ・ツ?ヲテァツ青?\n  //テ・ツ?ェテ・ツ?暗ゥツ??、ツスツ催」ツ?ョテ、ツスツ偲」ツ??ィツィツ暗ァツョツ療」ツ?凝」ツつ嘉・ツ?暗」ツ?ォテ・ツ?ヲテァツ青?」ツ?凖」ツつ凝」ツ?淌」ツつ?」ツ??」ツδォテ」ツδシテ」ツδ療」ツ?ョテヲツ鳴ケテ・ツ青妥」ツつづゥツ卍催ゥツ??」ツ?ォテ」ツ?凖」ツつ?\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')k++;\n    if(s[i] == '(')k--;\n    //テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴禿」ツ?ォテ」ツ?ェテ」ツつ凝」ツつ暗」ツ??」ツ?ォiテ」ツつ暗」ツつ甘・ツキツヲテ」ツ?ィテ・ツ渉ウテ」ツ?ョテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ォテ・ツ按?」ツ?妥」ツつ凝」ツ?づヲツキツサテ・ツュツ療」ツδ淌」ツつケテ」ツつ津」ツ?療」ツつ?」ツ?凖」ツ??」ツ?ョテ」ツ?ァテヲツーツ療」ツつ津」ツ?、テ」ツ?妥」ツつ凝」ツ??\n    if(!k && s[i] == '+')return parse(l,i) + parse(i+1,r);\n    if(!k && s[i] == '-')return parse(l,i) - parse(i+1,r);\n  }\n\n  //*,/テ」ツ?ョテ・ツ?ヲテァツ青?\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == ')')k++;\n    if(s[i] == '(')k--;\n    if(!k && s[i] == '*')return parse(l,i) * parse(i+1,r);\n    if(!k && s[i] == '/')return parse(l,i) / parse(i+1,r);\n  }\n\n  //()テ」ツ?ョテ・ツ?ヲテァツ青?\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n\n  //テゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?古ヲツ閉ーテ・ツュツ療」ツ?ョテ」ツ?ソテ」ツ?凝」ツつ嘉」ツ?ェテ」ツつ凝・ツ?エテ・ツ青?\n  //stoi(string)テ」ツ?ッstringテ・ツ楪凝」ツ?ァティツ。ツィテ」ツ?陛」ツつ古」ツ?淌ヲツ閉ーテ・ツュツ療」ツつ段ntテ・ツ楪凝」ツ?ォテ・ツ、ツ嘉ヲツ渉崚」ツ?凖」ツつ凝」ツ??++11テ」ツ?凝」ツつ鋭tringテ」ツδ佚」ツδε」ツδ?」ツ?ォテ・ツ?・テ」ツ?」テ」ツ?淌」ツ??\n  return stoi( s.substr(l,r-l) );\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n\nvoid erase(std::vector<std::string>&v,int e,int f){\n\tfor(int i=e;i<v.size()-f;i++)v[i]=v[i+f];\n}\n\nstd::string solve(std::string str){\n\tstd::vector<std::string>v;\n\tint a,b,c,d,v_size,j=0;\n\tfor(int i=0;i<=str.size();i++){\n\t\tif(i==str.size()||str[i]=='+'||str[i]=='-'||str[i]=='*'||str[i]=='/'){\n\t\t\tv.push_back(str.substr(j,i-j));\n\t\t\tv.push_back(str.substr(i,1));\n\t\t\tj=i+1;\n\t\t}\n\t}\n\tv_size=v.size();\n\ta=std::find(v.begin(),v.begin()+v_size,\"*\")-v.begin();\n\twhile(a!=v_size){\n\t\tint p=std::stoi(v[a-1]),q=std::stoi(v[a+1]);\n\t\tstd::stringstream z;\n\t\tz<<p*q;z>>v[a-1];\n\t\terase(v,a,2);v_size-=2;\n\t\ta=std::find(v.begin(),v.begin()+v_size,\"*\")-v.begin();\n\t}\n\tb=std::find(v.begin(),v.begin()+v_size,\"/\")-v.begin();\n\twhile(b!=v_size){\n\t\tint p=std::stoi(v[b-1]),q=std::stoi(v[b+1]);\n\t\tstd::stringstream z;\n\t\tz<<p/q;z>>v[b-1];\n\t\terase(v,b,2);v_size-=2;\n\t\tb=std::find(v.begin(),v.begin()+v_size,\"/\")-v.begin();\n\t}\n\tc=std::find(v.begin(),v.begin()+v_size,\"+\")-v.begin();\n\twhile(c!=v_size){\n\t\tint p=std::stoi(v[c-1]),q=std::stoi(v[c+1]);\n\t\tstd::stringstream z;\n\t\tz<<p+q;z>>v[c-1];\n\t\terase(v,c,2);v_size-=2;\n\t\tc=std::find(v.begin(),v.begin()+v_size,\"+\")-v.begin();\n\t}\n\td=std::find(v.begin(),v.begin()+v_size,\"-\")-v.begin();\n\twhile(d!=v_size){\n\t\tint p=std::stoi(v[d-1]),q=std::stoi(v[d+1]);\n\t\tstd::stringstream z;\n\t\tz<<p-q;z>>v[d-1];\n\t\terase(v,d,2);v_size-=2;\n\t\td=std::find(v.begin(),v.begin()+v_size,\"-\")-v.begin();\n\t}\n\treturn v[0];\n}\n\nint main(){\n\tint n;\n\tstd::string str;\n\tstd::cin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tstd::cin>>str;\n\t\tint a=str.find('('),b=str.find(')');\n\t\twhile(a!=-1){\n\t\t\tstd::string astr=str.substr(a+1,(b-1)-a);\n\t\t\tstr.erase(a,b-a+1);\n\t\t\tstr.insert(a,solve(astr));\n\t\t\ta=str.find('('),b=str.find(')');\n\t\t}\n\t\tstd::cout<<solve(str.substr(0,str.size()-1))<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint _;\nint n;\nchar buf[11451419];\n\nPair EvalElem(int pos);\nPair EvalTerm(int pos);\nPair EvalExp(int pos);\n\nPair EvalElem(int pos) {\n  if (buf[pos] == '(') {\n    Pair p = EvalExp(pos+1);\n    return Pair(p.first, p.second+1);\n  }\n\n  char c = buf[pos];\n  if ('0' <= c && c <= '9' || c == '-') {\n    char *next;\n    int res = strtol(buf+pos, &next, 10);\n    return Pair(res, next-buf);\n  }\n\n  return Pair(-1, -1);\n}\n\nPair EvalTerm(int pos) {\n  Pair p = EvalElem(pos);\n  assert(p.second != -1);\n\n  pos = p.second;\n  int res = p.first;\n  while (1) {\n    char c = buf[pos];\n    if (c != '*' && c != '/') break;\n\n    if (c == '*') {\n      Pair q = EvalElem(pos+1);\n      res *= q.first;\n      pos = q.second;\n    } else {\n      Pair q = EvalElem(pos+1);\n      res /= q.first;\n      pos = q.second;\n    }\n  } \n\n  return Pair(res, pos);\n}\n\nPair EvalExp(int pos) {\n  Pair p = EvalTerm(pos);\n  pos = p.second;\n\n  char c = buf[pos];\n  int res = p.first;\n  if (c == '=' || c == ')') {\n    return Pair(res, pos);\n  }\n\n  Pair q = EvalExp(pos+1);\n  if (c == '+') res += q.first;\n  else if (c == '-') res -= q.first;\n  else assert(0);\n\n  return Pair(res, q.second);\n}\n\nint main() {\n  scanf(\"%d \", &_);\n  while (_--) {\n    scanf(\"%s\", buf);\n    n = strlen(buf);\n\n    Pair res = EvalExp(0);\n    assert(res.second == n-1);\n    printf(\"%d\\n\", res.first);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n\n/*\n   <??????????????????> ::= <??????????????????> (+ or -) <??????????????????> (+ or -) ...\n   <??????????????????> ::= <??°> (* or /) <??°> (* or /) ...\n   <??°>           ::= ...\n   */\n\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint factor(State &begin)\n{ \n  if (*begin == '(')\n  {\n    begin++;\n    int ret = expression(begin);\n    begin++;\n  }\n  else\n  {\n    return number(begin);\n  }\n}\n\n\nint main(void) {\n  int N;\n  cin >> N;\n  cin.ignore();\n  for(int i = 0; i < N; i++)\n  {\n    string s;\n    getline(cin, s);\n    \n    State begin = s.begin();\n    int ans = expression(begin);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\nint expression(State &begin)\n{\n  int ret = term(begin);\n  for(;;) {\n    if(*begin == '+') {\n        begin++;\n        ret += term(begin);\n    } else if (*begin == '-')\n       {\n          begin++;\n          ret -= term(begin);\n       }\n    else{\n        break;\n    }\n    \n  }\n  return ret;\n}\nint term(State &begin)\n{\n  int ret = number(begin);\n  for(;;)\n  {\n    if(*begin == '*')\n    {\n      begin++;\n      ret *= factor(begin);\n    } else if(*begin == '/') {\n      begin++;\n      ret /= factor(begin);\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nint number(State &begin) {\n  int ret = 0;\n  while(isdigit(*begin)) {\n    ret *=10;\n    ret += *begin - '0';\n    begin++;\n  }\n\n  return ret;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint eval(const string & expr) {\n\tint left = 0;\n\tint right = 0;\n\tint mdtemp = 0;\n\tint ev_idx = 0;\n\tint sign = 1; // 1=+, -1=-\n\tchar c, cc;\n\n\t// 項の処理\n\twhile((c = expr[ev_idx++]) != '\\0') {\n\t\tif(c == '+' || c == '-') {\n\t\t\tleft += sign * right;\n\t\t\tright = 0;\n\t\t\tif(c == '+') sign = 1;\n\t\t\telse sign = -1;\n\t\t} else if(c == '*' || c == '/') { // if mul,div\n\t\t\tmdtemp = 0;\n\t\t\twhile(1) {\n\t\t\t\tif((cc = expr[ev_idx++]) == '\\0' || cc == '+' || cc == '-' || cc == '*' || cc == '/') {\n\t\t\t\t\tev_idx--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cc == '(') {\n\t\t\t\t\tint clen = 0;\n\t\t\t\t\tint cstrt = ev_idx;\n\t\t\t\t\twhile(expr[ev_idx++] != ')') clen++;\n\t\t\t\t\tstring ceval = expr.substr(cstrt, clen);\n\t\t\t\t\tmdtemp = eval(ceval);\n\t\t\t\t} else {\n\t\t\t\t\tmdtemp *= 10;\n\t\t\t\t\tmdtemp += (int)(cc - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c == '*') right *= mdtemp;\n\t\t\telse right /= mdtemp;\n\t\t} else if(c == '(') {\n\t\t\tint clen = 0;\n\t\t\tint cstrt = ev_idx;\n\t\t\twhile(expr[ev_idx++] != ')') clen++;\n\t\t\tstring ceval = expr.substr(cstrt, clen);\n\t\t\tright = eval(ceval);\n\t\t} else { // if numbers\n\t\t\tright *= 10;\n\t\t\tright += (int)(c - '0');\n\t\t}\n\t}\n\tleft += sign * right;\n\t\n\treturn left;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> anss(n);\n\n\tfor(int i=0;i<n;i++) {\n\t\tstring expr;\n\t\tcin >> expr;\n\t\tint ans;\n\t\tans = eval(expr);\n\t\tanss[i] = ans;\n\t}\n\tfor(auto it = anss.begin(); it != anss.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nint stoi(const string& s) {\n\tint res;\n\tistringstream is(s);\n\tis >> res;\n\treturn res;\n}\n\nstring s;\n\nint factor(int, int);\nint term(int, int);\nint formula(int, int);\n\nint factor(int l, int r) {\n\tif(s[l] == '(')\n\t\treturn formula(l + 1, r - 1);\n\n\treturn stoi(s.substr(l, r - l));\n}\n\nint term(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == '(')\n\t\t\t--cnt;\n\n\t\telse if(!cnt) {\n\t\t\tif(s[i] == '*')\n\t\t\t\treturn term(l, i) * factor(i + 1, r);\n\n\t\t\telse if(s[i] == '/')\n\t\t\t\treturn term(l, i) / factor(i + 1, r);\n\t\t}\n\t}\n\n\treturn factor(l, r);\n}\n\nint formula(int l, int r) {\n\tint cnt = 0;\n\tfor(int i = r - 1; i >= 0; --i) {\n\t\tif(s[i] == ')')\n\t\t\t++cnt;\n\n\t\telse if(s[i] == '(')\n\t\t\t--cnt;\n\n\t\telse if(!cnt) {\n\t\t\tif(s[i] == '+')\n\t\t\t\treturn formula(l, i) + term(i + 1, r);\n\n\t\t\telse if(s[i] == '-')\n\t\t\t\treturn formula(l, i) - term(i + 1, r);\n\t\t}\n\t}\n\n\treturn term(l, r);\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> s;\n\t\tcout << formula(0, s.size() - 1) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nstd::string S;\nsize_t i = 0;\nint32_t func();\nint32_t getvalue()\n{\n\tbool minus = false;\n\tif (S[i] == '-') {\n\t\tminus = true;\n\t\t++i;\n\t}\n\tint32_t nowv = 0;\n\tif (S[i] == '(') {\n\t\t++i;\n\t\tnowv = func();\n\t}\n\telse {\n\t\twhile ('0' <= S[i] && S[i] <= '9') { nowv *= 10; nowv += S[i] - '0'; ++i; }\n\t}\n\treturn nowv*(minus?-1:1);\n}\nint32_t func()\n{\n\tint32_t tmpv = 0;\n\tint32_t tmpmulv = getvalue();\n\twhile (S[i] != ')')\n\t{\n\t\tchar ope = S[i];\n\t\t++i;\n\t\tint32_t nowv = getvalue();\n\t\tif (ope == '+') {\n\t\t\ttmpv += tmpmulv;\n\t\t\ttmpmulv = nowv;\n\t\t}\n\t\telse if (ope == '-') {\n\t\t\ttmpv += tmpmulv;\n\t\t\ttmpmulv = -nowv;\n\t\t}\n\t\telse if (ope == '*') {\n\t\t\ttmpmulv *= nowv;\n\t\t}\n\t\telse if (ope == '/') {\n\t\t\ttmpmulv /= nowv;\n\t\t}\n\t}\n\t++i;\n\ttmpv += tmpmulv;\n\ttmpmulv = 1;\n\treturn tmpv;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tint32_t Q;\n\tin >> Q;\n\twhile (Q--)\n\t{\n\t\tin >> S;\n\t\tS.pop_back();\n\t\tS.push_back(')');\n\t\ti = 0;\n\t\tout << func() << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst signed INF_=1001001001; const ll INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\n/*\n<expression> ::= <term> | <term> ('+' | '-') <term>\n<term> ::= <factor> | <factor> ('*' | '/') <factor>\n<factor> ::= <number> | '(' <expression> ')'\n<number> ::= 0~9 | <number> <number>\n*/\nint expression(string &s,int &i);\nint term(string &s,int &i);\nint factor(string &s,int &i);\nint number(string &s,int &i);\n\nint expression(string &s,int &i) {\n    int ret=term(s,i);\n    while(s[i]=='+' || s[i]=='-') {\n        char op=s[i++];\n        int right=term(s,i);\n        if(op=='+') ret+=right;\n        else ret-=right;\n    }\n    return ret;\n}\nint term(string &s,int &i) {\n    int ret=factor(s,i);\n    while(s[i]=='*' || s[i]=='/') {\n        char op=s[i++];\n        int right=factor(s,i);\n        if(op=='*') ret*=right;\n        else ret/=right;\n    }\n    return ret;\n}\nint factor(string &s,int &i) {\n    if(s[i]=='(') {\n        i++;\n        int expr=expression(s,i);\n        i++;\n        return expr;\n    } else {\n        return number(s,i);\n    }\n}\nint number(string &s,int &i) {\n    int num=0;\n    while('0'<=s[i] && s[i]<='9') {\n        num*=10;\n        num+=s[i]-'0';\n        i++;\n    }\n    return num;\n}\n\nint solve() {\n    string s=IN;\n    int i=0;\n    return expression(s,i);\n}\nsigned main() {\n    int n=IN;\n    while(n--) {\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<queue>\n#include<cctype>\n#include<math.h>\n\nusing namespace std;\n\nstring S;\nsize_t cur = 0;\n\nint digit(){\n\tassert(isdigit(S[cur]));\n\tint n = S[cur] - '0';\n\tcur = cur + 1;\n\treturn n;\n}\n\nint number(){\n\tint n = digit();\n\twhile (cur < S.size() && isdigit(S[cur]))\n\t\tn = n * 10 + digit();\n\treturn n;\n}\n\nint expression();\nint factor(){\n\tif (S[cur] != '(') return number();\n\tcur += 1;\n\tint n = expression();\n\tassert(S[cur] == ')');\n\tcur += 1;\n\treturn n;\n}\n\nint term(){\n\tint a = number();\n\twhile (cur < S.size() && (S[cur] == '*' || S[cur] == '/')){\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif (op == '*') a *= b; else a /= b;\n\t}\n\treturn a;\n}\n\nint expression(){\n\tint a = term();\n\twhile (cur < S.size() && (S[cur] == '+' || S[cur] == '-')){\n\t\tchar op = S[cur++];\n\t\tint b = number();\n\t\tif (op == '+') a += b; else a -= b;\n\t}\n\treturn a;\n}\n\nint parse(){\n\treturn expression();\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++){\n\t\tcur = 0;\n\t\tscanf(\"%s\", &S);\n\t\tS.resize(S.size() - 1);\n\t\tcout << parse() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\n\t\tint size = Integer.parseInt(line);\n\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint a = SC(line);\n\t\t\tans.add(a);\n\t\t}\n\n\t\tfor(int i=0; i<ans.size(); i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\n\tpublic int SC(String line){\n\t\tList<String> eq = new ArrayList<String>();\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tString str = line.substring(count, count+1);\n\t\t\tif(str.equals(\"=\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq.add(str);\n\t\t\tcount++;\n\t\t}\n\n\t\tcount = 0;\n\t\twhile(count < eq.size()-1){\n\t\t\tif(isNumber(eq.get(count)) && isNumber(eq.get(count+1))){\n\t\t\t\tString dst = eq.get(count) + eq.get(count+1);\n\t\t\t\teq.add(count+2, dst);\n\t\t\t\teq.remove(count);\n\t\t\t\teq.remove(count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\n\t\twhile(eq.size() != 1){\n\t\t\t//ツ環古環づ個計ツ算\n\t\t\tint m;\n\t\t\tint bra_count = 0;\n\t\t\tint n = eq.indexOf(\"(\");\n\t\t\tif(n != -1){\n\t\t\t\tfor(int i=n+1; i<eq.size(); i++){\n\t\t\t\t\tif(eq.get(i).equals(\")\") && bra_count == 0){\n\t\t\t\t\t\teq = RangeReplace(eq, n, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\"(\")){\n\t\t\t\t\t\tbra_count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\")\")){\n\t\t\t\t\t\tbra_count--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ掛ツつッツ算ツ環づィツ算\n\t\t\tn = eq.indexOf(\"*\");\n\t\t\tm = eq.indexOf(\"/\");\n\n\t\t\tif(n != -1 && (m == -1 || n < m)){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) * Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(m != -1 && (n == -1 || m < n)){\n\t\t\t\tint a = Integer.parseInt(eq.get(m-1)) / Integer.parseInt(eq.get(m+1));\n\t\t\t\teq.add(m+2, Integer.toString(a));\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ堕ォツつオツ算ツ暗クツつォツ算\n\t\t\tn = eq.indexOf(\"+\");\n\t\t\tm = eq.indexOf(\"-\");\n\n\t\t\tif(n != -1 && (m == -1 || n < m)){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) + Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(m != -1 && (n == -1 || m < n)){\n\t\t\t\tint a = Integer.parseInt(eq.get(m-1)) - Integer.parseInt(eq.get(m+1));\n\t\t\t\teq.add(m+2, Integer.toString(a));\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn Integer.parseInt(eq.get(0));\n\t}\n\n\tpublic List<String> RangeReplace(List<String> eq, int s, int e){\n\t\tString part = \"\";\n\n\t\tfor(int i=s+1; i<e; i++){\n\t\t\tpart += eq.get(i);\n\t\t}\n\n\t\tpart = Integer.toString(SC(part+\"=\"));\n\n\t\teq.add(e+1, part);\n\n\t\tfor(int i=s; i<=e; i++){\n\t\t\teq.remove(s);\n\t\t}\n\n\t\treturn eq;\n\t}\n\n\tpublic boolean isNumber(String s){\n\t\ttry{\n\t\t\tint n = Integer.parseInt(s);\n\t\t}catch(NumberFormatException err){\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdlib>\n#include<iostream>\n\nusing namespace std;\n\nint prior[128];\n\nint parse(string s)\n{\n\tif(s[0]=='(' && s[s.length()-1]==')'){\n\t\tbool f=true;\n\t\tfor(int i=1,d=1;i<s.length()-1;i++){\n\t\t\tif     (s[i]=='(')\td++;\n\t\t\telse if(s[i]==')')\td--;\n\t\t\tif(d==0){\tf=false;\tbreak;\t}\n\t\t}\n\t\tif(f)\treturn parse(s.substr(1,s.length()-2));\n\t}\n\n\tint divprr=3,divpos=10000000;\n\tfor(int i=0,d=0;i<s.length();i++){\n\t\tif     (s[i]=='(')\td++;\n\t\telse if(s[i]==')')\td--;\n\n\t\telse if(d==0 && prior[s[i]]!=0){\n\t\t\tif(i==0 && prior[s[i]]==1)\tcontinue;\n\t\t\tif(divprr>prior[s[i]])\n\t\t\t\tdivprr=prior[s[i]],divpos=i;\n\t\t}\n\t}\n\n\tif(divpos==10000000)\treturn atof(s.c_str());\n\n\tswitch(s[divpos]){\n\t\tcase '+': return parse(s.substr(0,divpos)) + parse(s.substr(divpos+1));\n\t\tcase '-': return parse(s.substr(0,divpos)) - parse(s.substr(divpos+1));\n\t\tcase '*': return parse(s.substr(0,divpos)) * parse(s.substr(divpos+1));\n\t\tcase '/': return parse(s.substr(0,divpos)) / parse(s.substr(divpos+1));\n\t}\n}\n\nint main()\n{\n\tprior['+']=prior['-']=1;\n\tprior['*']=prior['/']=2;\n\n\tint n;\tcin>>n;\n\twhile(n--){\n\t\tstring s;\tcin>>s;\n\t\ts=s.substr(0,s.length()-1);\n\t\tcout<<parse(s)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef string::iterator State;\nint n;\nstring str;\n\nint factor(State begin);\nint number(State begin);\nint term(State begin);\nint expressin(State begin);\n\nint factor(State begin)\n{\n\tint ret;\n\tif (*begin == '(')\n\t{\n\t\tbegin++;\n\t\tret = expressin(begin);\n\t\tbegin++;\n\t}\n\telse\n\t{\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nint number(State begin)\n{\n\tint ret = 0;\n\twhile (isdigit(*begin))\n\t{\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint term(State begin)\n{\n\tint ret = factor(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '*')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}\n\t\telse if (*begin == '/')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint expressin(State begin)\n{\n\tint ret = term(begin);\n\twhile (true)\n\t{\n\t\tif (*begin == '+')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t}\n\t\telse if (*begin == '-')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tcin >> str;\n\t\tcout << expressin(str.begin()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype> // isdigit\n#include<cassert> // assert\nusing namespace std;\n\nstruct Result{int value,pos;};\n\nint calculate(string expression);\nResult equation(string expression,int pos);\nResult factor(string expression,int pos);\nResult term(string expression,int pos);\n\nint calculate(string expression)\n{\n  return equation(expression,0).value;\n}\n\nResult equation(string expression,int pos)\n{\n  Result r=factor(expression,pos);\n  // Á¸Z\n  while(expression[r.pos]=='+' || expression[r.pos]=='-'){\n    Result _r=factor(expression,r.pos+1);\n    if(expression[r.pos]=='+')r.value += _r.value;\n    if(expression[r.pos]=='-')r.value -= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult factor(string expression,int pos)\n{\n  Result r=term(expression,pos);\n  // æZ\n  while(expression[r.pos]=='*' || expression[r.pos]=='/'){\n    Result _r=term(expression,r.pos+1);\n    if(expression[r.pos]=='*')r.value *= _r.value;\n    if(expression[r.pos]=='/')r.value /= _r.value;\n    r.pos=_r.pos;\n  }\n  return r;\n}\nResult term(string expression,int pos)\n{\n  Result r;\n  // l\n  if(isdigit(expression[pos])){\n    int value=0;\n    while(isdigit(expression[pos]))value += value*10 + expression[pos++]-'0';\n    r.value=value;\n    r.pos=pos;\n    return r;\n  }\n  // Ê\n  if(expression[pos]=='('){\n    r=equation(expression,pos+1);\n    assert(expression[r.pos++]==')');\n    return r;\n  }\n}\n\nint main()\n{\n  int n;\n  string s;\n  cin>>n;\n  while(n-->0){\n    cin>>s;\n    s=s.substr(0,s.size()-1);\n    cout<<calculate(s)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\ndouble calc2(char *eq){\n\tlong c=0, sign[100]={0};\n\tdouble num[100]={0};\n\tchar *p = eq;\n\twhile(*p){\n\t\tif('0'<=*p && *p<='9') num[c]=num[c]*10+*p-'0';\n\t\telse{\n\t\t\tif(*p=='+') sign[c]=1;\n\t\t\telse if(*p=='-') sign[c]=2;\n\t\t\telse if(*p=='*') sign[c]=3;\n\t\t\telse if(*p=='/') sign[c]=4;\n\t\t\telse if(*p=='=') break;\n\t\t\telse printf(\"err %c\\n\", *p);\n\t\t\tc++;\n\t\t}\n\t\tp++;\n\t}\n\tc++;\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==3 || sign[i]==4){\n\t\t\tif(sign[i]==3)\tnum[i+1] = num[i] * num[i+1];\n\t\t\tif(sign[i]==4)\tnum[i+1] = num[i] / num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\tfor(int i=0;i<c-1;i++){\n\t\tif(sign[i]==1 || sign[i]==2){\n\t\t\tif(sign[i]==1)\tnum[i+1] = num[i] + num[i+1];\n\t\t\tif(sign[i]==2)\tnum[i+1] = num[i] - num[i+1];\n\t\t\tfor(long j=i+1;j<c;j++){\n\t\t\t\tnum[j-1] = num[j];\n\t\t\t\tsign[j-1] = sign[j];\n\t\t\t}\n\t\t\ti--;\n\t\t\tc--;\n\t\t}\n\t}\n\treturn num[0];\n}\n\n__int64 calc(char *eq){\n\tchar *p, *p2, buf[120]={0}, cp[120]={0};\n\tlong k,ret;\n\tstrcpy(cp, eq);\n\tif((p=strchr(cp, '('))!=NULL){\n\t\tfor(k=0,p2=p+1;;p2++)\n\t\t\tif(*p2=='(')k++;\n\t\t\telse if(*p2==')'){\n\t\t\t\tif(k)k--;\n\t\t\t\telse break;\n\t\t\t}\n\t\tmemcpy(buf, p+1, p2-p-1);\n\t\tbuf[p2-p-1]='=';\n\t\tret = calc(buf);\n\t\t*p=0;\n\t\tsprintf(buf, \"%s%ld%s\", cp, ret, p2+1);\n\t\tstrcpy(cp,buf);\n\t}\n\treturn (__int64)calc2(cp);\n}\n\nint main(){\n\tlong i,j,n;\n\tchar buf[120], p;\n\tfor(cin >> n;n;n--){\n\t\tcin >> buf;\n\t\tcout << calc(buf) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  Expr = Term { (+|-) Term}\n  Term = Fact { (*|/) Fact}\n  Fact = (Expr) | number\n\n*/\n\n#include<iostream>\n#include<cstdlib>\nusing namespace std;\n\n\ntypedef pair<int,const char*>parsed;\n\n\nparsed expr(const char *p);\nparsed term(const char *p);\nparsed fact(const char *p);\n\n\nparsed expr(const char *p)\n{\n  parsed r=term(p);\n \n while(*r.second=='+'||*r.second=='-'){\n    char op =*r.second;\n    int tmp=r.first;\n    r=term(r.second+1);\n    if(op=='+')r.first=tmp+r.first;\n    else r.first=tmp-r.first;\n  }\n  return r;\n}\n\nparsed term(const char *p)\n{\n  parsed r=fact(p);\n  while(*r.second=='*'||*r.second=='/'){\n    char op=*r.second;\n    int tmp=r.first;\n    r=fact(r.second+1);\n    if(op=='*')r.first=tmp*r.first;\n    else r.first=tmp/r.first;\n  }\n  return r;\n}\n\nparsed fact(const char *p)\n{\n  if(isdigit(*p)){\n    int t=*(p++)-'0';\n    while(isdigit(*p))t=t*10+*(p++)-'0';\n    return parsed(t,p);\n  }\n  else if(*p=='('){\n    parsed r=expr(p+1);\n    if(*r.second!=')')exit(0);\n    return parsed(r.first,r.second+1);\n  }\n  else exit(0);\n}\n\nint main()\n{\n  string str;\n  int n;\n  cin>>n;\n  while(n--){\n\t  cin>>str;\n    cout<<expr(str.c_str()).first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef string::const_iterator State;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint number(State &begin);\nint expression(State &begin);\nint factor(State &begin);\nint term(State &begin);\n\nint main(){\n  int n;\n  string s;\n  cin>>n;\n  rep(i,n){\n    cin>>s;\n    State begin=s.begin();\n    \n    int ans=expression(begin);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nint number(State &begin){\n  int ret=0;\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=(*begin-'0');\n    begin++;\n  }\n  return ret;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin); \n    }else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\n\nint factor(State &begin){\n  int ret=0;\n  if(*begin == '('){\n    begin++;\n    ret=expression(begin);\n    begin++;\n  }else{\n    return number(begin);\n  }\n  return ret;\n}\n\n\nint term(State &begin){\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin); \n    }else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint eval(const string & expr) {\n\tint left = 0;\n\tint right = 0;\n\tint mdtemp = 0;\n\tint ev_idx = 0;\n\tint sign = 1; // 1=+, -1=-\n\tchar c, cc;\n\n\t// 項の処理\n\twhile((c = expr[ev_idx++]) != '=' && c != '\\0') {\n\t\tif(c == '+' || c == '-') {\n\t\t\tleft += sign * right;\n\t\t\tright = 0;\n\t\t\tif(c == '+') sign = 1;\n\t\t\telse sign = -1;\n\t\t} else if(c == '*' || c == '/') { // if mul,div\n\t\t\tmdtemp = 0;\n\t\t\twhile(1) {\n\t\t\t\tif((cc = expr[ev_idx++]) == '=' || cc == '\\0' || cc == '+' || cc == '-' || cc == '*' || cc == '/') {\n\t\t\t\t\tev_idx--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cc == '(') {\n\t\t\t\t\tint clen = 0;\n\t\t\t\t\tint cstrt = ev_idx;\n\t\t\t\t\twhile(expr[ev_idx++] != ')') clen++;\n\t\t\t\t\tstring ceval = expr.substr(cstrt, clen);\n\t\t\t\t\tmdtemp = eval(ceval);\n\t\t\t\t} else {\n\t\t\t\t\tmdtemp *= 10;\n\t\t\t\t\tmdtemp += (int)(cc - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c == '*') right *= mdtemp;\n\t\t\telse right /= mdtemp;\n\t\t} else if(c == '(') {\n\t\t\tint clen = 0;\n\t\t\tint cstrt = ev_idx;\n\t\t\twhile(expr[ev_idx++] != ')') clen++;\n\t\t\tstring ceval = expr.substr(cstrt, clen);\n\t\t\tright = eval(ceval);\n\t\t} else { // if numbers\n\t\t\tright *= 10;\n\t\t\tright += (int)(c - '0');\n\t\t}\n\t}\n\tleft += sign * right;\n\t\n\treturn left;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> anss(n);\n\n\tfor(int i=0;i<n;i++) {\n\t\tstring expr;\n\t\tcin >> expr;\n\t\tint ans;\n\t\tans = eval(expr);\n\t\tanss[i] = ans;\n\t}\n\tfor(auto it = anss.begin(); it != anss.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nclass CalcExpression\n{\n\ttypedef string::const_iterator State;\n\tclass ParseError {};\n\n\npublic:\n\n\tint expression(State& begin)\n\t{\n\t\tint ret = term(begin);\n\n\t\twhile(true)\n\t\t{\n\t\t\tif(*begin == '+')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret += term(begin);\n\t\t\t}\n\t\t\telse if(*begin == '-')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret -= term(begin);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\nprivate:\n\n\tint term(State& begin)\n\t{\n\t\tint ret = number(begin);\n\n\t\twhile(true)\n\t\t{\n\t\t\tif(*begin == '*')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret *= factor(begin);\n\t\t\t}\n\t\t\telse if(*begin == '/')\n\t\t\t{\n\t\t\t\tbegin++;\n\t\t\t\tret /= factor(begin);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tint factor(State &begin)\n\t{\n\t\tint ret = 0;\n\n\t\tif(*begin == '(')\n\t\t{\n\t\t\tbegin++;\n\t\t\tret = expression(begin);\n\t\t\tbegin++;\n\t\t}\n\t\telse return number(begin);\n\n\t\treturn ret;\n\t}\n\n\tint number(State& begin)\n\t{\n\t\tint ret = 0;\n\n\t\twhile(isdigit(*begin))\n\t\t{\n\t\t\tret *= 10;\n\t\t\tret += *begin - '0';\n\t\t\tbegin++;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tCalcExpression ce;\n\twhile(n--)\n\t{\n\t\tstring expression, buf;\n\n\t\tcin >> expression;\n\n\t\tcout << ce.expression(expression.begin()) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tret *= term(++begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tret /= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tret += term(++begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tret -= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tcout << expression(str.begin()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    // ??°?????????????????????\n    int number(State &begin) {\n        int ret = 0;\n        while(isdigit(*begin)) {\n            ret *= 10;\n            ret += (*begin - '0');\n            begin++;\n        }\n        return ret;\n    }\n\n    // ??¬??§?????°????????????\n    int factor(State &begin) {\n        if(*begin == '(') {\n            begin++; // '(' ????£???°???\n            int ret = expression(begin);\n            begin++; // ')' ????£???°???\n            return ret;\n        }\n        else return number(begin);\n    }\n\n    // ??????????????????????????????\n    int term(State &begin) {\n        // ????????????????????¨????????£????????°??????????????§???????????????\n        // begin ?????????????????°?????§???????????????\n        int ret = factor(begin);\n\n        while(1) {\n            if(*begin == '*') {\n                begin++;\n                ret *= factor(begin);\n            }\n            else if(*begin == '/') {\n                begin++;\n                ret /= factor(begin);\n            }\n            else break;\n        }\n\n        return ret;\n    }\n\n    // ??????????????????????????????\n    int expression(State &begin) {\n        int ret = term(begin);\n        while(1) {\n            if(*begin == '+') {\n                begin++;\n                ret += term(begin);\n            }\n            else if(*begin == '-') {\n                begin++;\n                ret -= term(begin);\n            }\n            else break;\n        }\n        return ret;\n    }\n};\n\nsigned main() {\n    int N; cin >> N;\n    rep(i,0,N) {\n        Parser ps;\n        string s; cin >> s;\n        State begin = s.begin();\n        int ans = ps.expression(begin);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator State;\nclass ParseError {};\n \nint term(State &begin);\nint expression(State &begin);\nint factor(State &begin);\nint number(State &begin);\nvoid consume(State &begin, char expected);\n \n// 四則演算の式をパースして、その評価結果を返す。\n// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n// <expr>   ::= <term> [ ('+'|'-') <term> ]*\nint expression(State &begin){\n    int ret = term(begin);\n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n \n// 乗算除算の式をパースして、その評価結果を返す。\n// <乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n// <term>   ::= <factor> [ ('*'|'/') <factor> ]*\nint term(State &begin){\n    int ret = factor(begin);\n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\n// 括弧か数をパースして、その評価結果を返す。 \n// <括弧か数> ::= '(' <四則演算の式> ')' or <数>\n// <factor> ::= <number> | '(' <expr> ')'\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }else{\n        return number(begin);\n    }\n}\n \n// 数字の列をパースして、その数を返す。\n// <数> ::= ...\n// <number> :== 1つ以上の数字\nint number(State &begin){\n    int ret = 0;\n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    return ret;\n}\n \nint main(){\n    int N;\n    cin >> N;\n    cin.ignore();\n    for(int i = 0; i < N; i++){\n        string s;\n        getline(cin, s);\n        State begin = s.begin();\n        int ans = expression(begin);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\nstring str;\n\nint subj(int s, int e){\n\tint n = 0;\n\tfor(int i = s;i < e;i++){\n\t\tif(str[i] == '(')n++;\n\t\tif(str[i] == ')'){if(n == 0)return i;n--;}\n\t}\n}\n\nint calc(int s, int e, int m, int z){\n\tint p = 0;\n\tfor(p = s;p < e && str[p] >= '0' && str[p] <= '9';p++);\n\tint a = atoi(str.substr(s, p-s).c_str());\n\tif(str[s] == '('){\n\t\tp = subj(s+1, e);\n\t\ta = calc(s+1, p, 0, 0);p++;\n\t\t//cout << \"p = \" << s << p << \" \";\n\t}\n\tif(m == 1)a *= z;\n\tif(m == 2)a = z / a;\n\t\n\tif(str[p] == '+')return a + calc(p+1, e, 0, 0);\n\tif(str[p] == '-')return a - calc(p+1, e, 0, 0);\n\tif(str[p] == '*')return calc(p+1, e, 1, a);\n\tif(str[p] == '/')return calc(p+1, e, 2, a);\n\tif(str[p] == '=' || str[p] == ')')return a;\n\t\n\treturn 0;\n}\n\nint main(){\n\tint n;cin >> n;\n\twhile(n--){\n\t\tcin >> str;\n\t\tcout << calc(0, str.size(), 0, 0) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <deque>\n#include <memory.h>\n\n#define rep(idx, max)\t\t\tfor(int idx = 0, idx##Max = (max); idx < idx##Max; idx ++)\n#define rrep(idx, min, max)\tfor(int idx = (min), idx##Max = max; idx < idx##Max; idx ++)\n#define erep(idx, min, max)\tfor(int idx = (min), idx##Max = max; idx <= idx##Max; idx ++)\n\n#define rev(idx, max)\t\t\tfor(int idx = (max) - 1; idx >= 0; idx --)\n#define rrev(idx, min, max)\tfor(int idx = (max) - 1, idx##Min = (min); idx >= idx##Min; idx --)\n#define erev(idx, min, max)\tfor(int idx = (max), idx##Min = (min); idx >= idx##Min; idx --)\n\n#define foreach(it, obj)\tfor(auto it = obj.begin(), it##End = obj.end(); it >= it##End; it ++)\n\nusing namespace\tstd;\n\nclass CCalc\n{\n\tstring\ts_;\n\tint\tpos_;\n\t\n\tint\tIsDigit(int x)\t{\treturn(x <= '9' && x >= '0');\t}\n\tvoid\tSkipSpace()\n\t{\n\t\tcout << \"Skipping...\";\n\t\tfor(int c = s_[pos_]; (c == ' ' || c == '\\t') && pos_ < s_.size(); pos_ ++);\n\t\tcout << \"OK\" << endl;\n\t}\n\tint\tNumber()\n\t{\n\t\tint num = 0;\n\t\twhile(IsDigit(s_[pos_]))\t{\tnum\t= num * 10 + s_[pos_ ++] - '0';\t}\n\t\treturn(num);\n\t}\n\tint\tFactor()\n\t{\n\t\tint val;\n\t\tif(pos_ >= s_.size())\t{\tcout << \"warning: Out of bounds!\" << endl;\t}\n\t\tif(IsDigit(s_[pos_]))\n\t\t{\n\t\t\tval = Number();\n\t\t\treturn(val);\n\t\t}\n\t\tpos_ ++;\n\t\tval\t= Expr();\n\t\tpos_ ++;\n\t\treturn(val);\n\t}\n\tint\tTerm()\n\t{\n\t\tint\tval1\t= Factor();\n\t\twhile(s_[pos_] == '*' || s_[pos_] == '/')\n\t\t{\n\t\t\tchar\top\t= s_[pos_ ++];\n\t\t\tint val2\t= Factor();\n\t\t\tswitch(op)\n\t\t\t{\n\t\t\t\tcase '*':\tval1 *= val2;\tbreak;\n\t\t\t\tcase '/':\tval1 /= val2;\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn(val1);\n\t}\n\tint\tExpr()\n\t{\n\t\tint\tval1\t= Term();\n\t\twhile(s_[pos_] == '+' || s_[pos_] == '-')\n\t\t{\n\t\t\tchar\top\t= s_[pos_ ++];\n\t\t\tint val2\t= Term();\n\t\t\tswitch(op)\n\t\t\t{\n\t\t\t\tcase '+':\tval1 += val2;\tbreak;\n\t\t\t\tcase '-':\tval1 -= val2;\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn(val1);\n\t}\n\t\npublic:\n\tint\tEval(string &expression)\n\t{\n\t\tpos_\t= 0;\n\t\tint pos = 0;\n\t\ts_.resize(expression.size());\n\t\trep(i, expression.size())\n\t\t{\n\t\t\tif(expression[i] != ' ')\n\t\t\t{\ts_[pos ++] = expression[i];\t}\n\t\t}\n\t\treturn(Expr());\n\t}\n};\n\nint main()\n{\n\tCCalc\tcalc;\n\tstring\texpression;\n\tint tc;\n\t\n\tfor(cin >> tc, cin.ignore(); tc > 0; tc --)\n\t{\n\t\tgetline(cin, expression);\n\t\tcout << calc.Eval(expression) << endl;\n\t}\n\t\n//\twhile(getline(cin, expression), expression.size())\n//\t{\t::printf(\"%s = %d\\n\", expression.c_str(), calc.Eval(expression));\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0])){\n\t\tconst char* p=s;\n\t\t//if(*p=='-')\n\t\t//\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+*p-'0';\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\telse{\n\t\tparsed res=expr(s+1);\n\t\tres.second++;\n\t\treturn res;\n\t}\n}\n\n//parsed fact(const char *p)\n//{\n//  if (isdigit(*p)){\n//    int t=0;\n//    while(isdigit(*p)) t=t*10+*(p++)-'0';\n//    return parsed(t,p);\n//  }\n//  else if (*p=='('){\n//    parsed r=expr(p+1);\n//    if (*r.second!=')') exit(0); // invalid input\n//    return parsed(r.first,r.second+1);\n//  }\n//  else\n//    exit(0); // invalid input\n//}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nint hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])==-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=s[oi];\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nstruct Parser {\n    // エラー検出\n    void consume(State &begin, char expected) {\n        if(*begin == expected) begin++;\n        else {\n            cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n            cerr << \"Rest string is '\";\n            while(*begin) {\n                cerr << *begin++;\n            }\n            cerr << \"'\" << endl;\n            throw ParseError();\n        }\n    }\n\n    // 数字の列をパースして、その数を返す\n    int number(State &begin) {\n        int ret = 0;\n        while(isdigit(*begin)) {\n            ret *= 10;\n            ret += (*begin - '0');\n            begin++;\n        }\n        return ret;\n    }\n\n    // 括弧か数をパースして、その評価結果を返す\n    int factor(State &begin) {\n        if(*begin == '(') {\n            consume(begin, '(');    // '('を飛ばす\n            int ret = expression(begin);\n            consume(begin, ')');    // ')'を飛ばす\n            return ret;\n        }else return number(begin);\n    }\n\n    // 乗算除算の式をパースして、その評価結果を返す\n    int term(State &begin) {\n        int ret = factor(begin);\n        while(1) {\n            if(*begin == '*') {\n                consume(begin, '*');\n                ret *= factor(begin);\n            }else if(*begin == '/') {\n                consume(begin, '/');\n                ret /= factor(begin);\n            }else break;\n        }\n        return ret;\n    }\n\n    // 四則演算の式をパースして、その評価結果を返す\n    int expression(State &begin) {\n        int ret = term(begin);\n        while(1) {\n            if(*begin == '+') {\n                consume(begin, '+');\n                ret += term(begin);\n            }else if(*begin == '-') {\n                consume(begin, '-');\n                ret -= term(begin);\n            }else break;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    cin.ignore();\n    for(int i = 0; i < n; ++i) {\n        Parser ps;\n        string s;\n        getline(cin, s);\n\n        State begin = s.begin();\n        int ans = ps.expression(begin);\n        ps.consume(begin, '=');\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n#include <cstddef>\n\nusing namespace std;\n\n\n// ?????????????§?????§£???????????????????????¨???????????????\nclass MathExpress\n{\nprivate:\n    string m_express;\n    size_t m_cur = 0;\n\npublic:\n    MathExpress(string str) : m_express(str) \n    {\n        m_express.resize(m_express.size() - 1);\n    }\n\n    int digit(); // ???????????°???\n    int number(); // ??°??????????????°????????´???\n    int term();\n    int factor(); \n    int expression();\n};\n\n\nint MathExpress::digit()\n{\n    assert(isdigit(m_express.at(m_cur)));\n\n    int n = m_express.at(m_cur) - '0';\n\n    m_cur += 1;\n\n    //cout << \"digit: \" << n << endl;\n\n    return n;\n}\n\n\nint MathExpress::number()\n{\n    int num = digit();\n\n    while ( m_cur < m_express.size() && isdigit(m_express.at(m_cur)) )\n    {\n        num = num * 10 + digit();\n    }\n\n    //cout << \"number: \" << num << endl;\n\n    return num;\n}\n\n\nint MathExpress::term()\n{\n    int left = factor();\n\n    while (m_cur < m_express.size() \n         && (m_express.at(m_cur) == '*' || m_express.at(m_cur) == '/'))\n    {\n        char op = m_express.at(m_cur++);\n\n        //cout << op << endl;\n\n        int right = number();\n\n        switch (op) {\n            case '*':\n                left *= right;\n                break;\n            case '/':\n                left /= right;\n                break;\n            default:\n                break;\n        }\n\n    }\n\n    //cout << \"term: \" << left << endl;\n\n    return left;\n}\n\n\nint MathExpress::expression()\n{\n    int left = term();\n\n    while (m_cur < m_express.size() \n         && (m_express.at(m_cur) = '+' || m_express.at(m_cur) == '-'))\n    {\n        //cout << m_cur << \" \" << m_express.at(m_cur) << endl;\n        char op = m_express.at(m_cur);\n\n        m_cur += 1;\n\n        //cout << op << endl;\n        //cout << \"hoge\" << endl;\n\n        int right = term();\n\n        //cout << \"hoge\" << endl;\n\n        switch (op) {\n            case '+':\n                //cout << \"hoge\" << endl;\n                left += right;\n                break;\n            case '-':\n                left -= right;\n                break;\n            default:\n                //cout << \"hoge\" << endl;\n                break;\n        }\n\n        //cout << \"left : right = \" << left << \" \" << right << endl;\n    }\n\n    return left;\n}\n\n\nint MathExpress::factor()\n{\n    if (m_express.at(m_cur) != '(') return number();\n\n    m_cur += 1;\n\n    int exp = expression();\n\n    assert (m_express.at(m_cur) == ')');\n\n    m_cur += 1;\n\n    return exp;\n}\n\n\nint main()\n{\n    int data_num;\n    \n    cin >> data_num;\n    \n    cin.clear();\n\n    string val; \n    for (int i = 0; i < data_num; ++i) {\n        cin >> val;\n\n        MathExpress mathexp(val);\n        cout << mathexp.expression() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nstring st;\nint a;\n\nint plmi();\n\nint num() {\n\tint n = 0;\n\twhile (1) {\n\t\tif (isdigit(st[a])) {\n\t\t\tn *= 10;\n\t\t\tn += st[a] - '0';\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn n;\n\t\t}\n\t}\n}\n\nint siki() {\n\tint n;\n\tif (st[a] == '(') {\n\t\ta++;\n\t\tn=plmi();\n\t\ta++;\n\t}\n\telse {\n\t\tn = num();\n\t}\n\treturn n;\n}\n\nint evdi() {\n\tint n = num();\n\twhile (1) {\n\t\tif (st[a] == '*') {\n\t\t\ta++;\n\t\t\tn *= siki();\n\t\t}\n\t\telse if (st[a] == '/') {\n\t\t\ta++;\n\t\t\tn /= siki();\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}\n\nint plmi() {\n\tint n=evdi();\n\twhile (1) {\n\t\tif (st[a] == '+') {\n\t\t\ta++;\n\t\t\tn += evdi();\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta++;\n\t\t\tn -= evdi();\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn n;\n}\n\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> st;\n\t\ta = 0;\n\t\tint ans=plmi();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nmap<char,int> order;\nstring S; size_t cur=0;\nstack<int> num,rnum;\nstack<char> op,rop;\n\nint digit(){\n\tint n=S[cur++]-'0';\n\treturn n;\n}\n\nint number(){\n\tint n=digit();\n\twhile(isdigit(S[cur]))\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nvoid calc(){\n\tint b=num.top();num.pop();\n\tint a=num.top();num.pop();\n\tchar o=op.top();op.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\tnum.push(c);\n\treturn ;\n}\n\nvoid calc2(){\n\tint a=rnum.top();rnum.pop();\n\tint b=rnum.top();rnum.pop();\n\tchar o=rop.top();rop.pop();\n\tint c;\n\tswitch(o){\n\t\tcase '+' :\n\t\t\tc=a+b;\n\t\t\tbreak;\n\t\tcase '-' :\n\t\t\tc=a-b;\n\t\t\tbreak;\n\t\tcase '*' :\n\t\t\tc=a*b;\n\t\t\tbreak;\n\t\tcase '/' :\n\t\t\tc=a/b;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\trnum.push(c);\n\treturn ;\n}\n\nint exp(){\n\tcur =0;\n\tint smax=S.size();\n\twhile(cur < smax-1){\n\t\t//cout << cur << endl;\n\t\tif(isdigit(S[cur])){\n\t\t\tint a=number();\n\t\t\tnum.push(a);\n\t\t}else if(!op.empty()&&op.top()!='('&&op.top()!=')'&& order[S[cur]] >= order[op.top()]){ //計算順序については改善の余地あり (　は最小に\n\t\t\tcalc();\n\t\t\top.push(S[cur++]);\n\t\t}else if(S[cur] == ')' ){\n\t\t\trnum.push(num.top());num.pop();\n \t\t\twhile(!op.empty()&&op.top()!='('){\n\t\t\t\trop.push(op.top());op.pop();\n\t\t\t\trnum.push(num.top());num.pop();\n\t\t\t}\n\t\t\twhile(!rop.empty())\n\t\t\t\tcalc2();\n\t\t\tnum.push(rnum.top());rnum.pop();\n\t\t\t//cout << num.top() << endl;\n\t\t\top.pop();cur++;\n\t\t}else{//ひとまず終了　演算記号のチェックも入れる\n\t\t\t//\tcout << \"come\" << endl;\n\t\t\top.push(S[cur++]);\n\t\t}\n\t}\n\t//cout << num.top() << endl;//\n\t//int tmp=num.top();num.pop();\n\t//cout << num.top() << endl;//\n\t//num.push(tmp);\n\n\trnum.push(num.top());num.pop();\n\twhile(!op.empty()&&op.top()!='('){\n\t\trop.push(op.top());op.pop();\n\t\trnum.push(num.top());num.pop();\n\t}\n\twhile(!rop.empty())\n\t\tcalc2();\n\tnum.push(rnum.top());rnum.pop();\n\t//cout<< \" check \"  << op.empty() << endl;\n\tint ans=num.top();\n\tnum.pop();\n\treturn ans;\n}\n\nint main(void){\n\torder['+']=2;\n\torder['-']=2;\n\torder['*']=1;\n\torder['/']=1;\n\t//cout << order['('] << endl;\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tcin >> S;\n\t\tcout << exp() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define INF 1000000\n\n\nint ar[2][14];\nint main(){\n\tstring str;\n\tint N;\n\tcin>>N;\n\tVI res;\n\tstack <string>st;\n\tREP(ii,N){\n\t\tcin>>str;\n\t\tpriority_queue<pair<int,char> > buf;\n\t\tpriority_queue<pair<int,char> > buf2;\n\t\t\n\t\tbool ch=false;\n\t\tint t=0;\n\t\tvector<string> temp;\n\t\tREP(i,SZ(str)){\n\t\t\tif(str[i]=='+'||str[i]=='-'){\n\t\t\t\tif((!ch&&(buf.empty()||(buf.top()).first<i))||(ch&&(buf2.empty()||(buf2.top()).first<i))){\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!ch){\n\t\t\t\t\t\ttemp.PB(toString((buf.top()).second));\n\t\t\t\t\t\tbuf.pop();\n\t\t\t\t\t\tbuf.push(MP(i,str[i]));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttemp.PB(toString((buf2.top()).second));\n\t\t\t\t\t\tbuf2.pop();\n\t\t\t\t\t\tbuf2.push(MP(i,str[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(str[i]=='*'||str[i]=='/'){\n\t\t\t\tif(!ch){\n\t\t\t\t\tbuf.push(MP(300-i,str[i]));\n\t\t\t\t}else{\n\t\t\t\t\tbuf2.push(MP(300-i,str[i]));\n\t\t\t\t}\n\t\t\t}else if(str[i]=='('){\n\t\t\t\tch=true;\n\t\t\t}else if(str[i]==')'){\n\t\t\t\twhile(!buf2.empty()){\n\t\t\t\t\ttemp.PB(toString((buf2.top()).second));\n\t\t\t\t\tbuf2.pop();\n\t\t\t\t}\n\t\t\t\tch=false;\n\t\t\t}else if(str[i]=='='){\n\t\t\t\twhile(!buf.empty()){\n\t\t\t\t\ttemp.PB(toString((buf.top()).second));\n\t\t\t\t\tbuf.pop();\n\t\t\t\t}\n\t\t\t}else if(str[i]>='0'&&str[i]<='9'){\n\t\t\t\tif(i+1<SZ(str)&&str[i+1]>='0'&&str[i+1]<='9'){\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\tt*=10;\n\t\t\t\t}else{\n\t\t\t\t\tt+=(unsigned int)(str[i]-'0');\n\t\t\t\t\t//cout<<t<<endl;\n\t\t\t\t\ttemp.PB(toString(t));\n\t\t\t\t\tt=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,SZ(temp))cout<<temp[i];\n\t\tcout<<endl;\n\t\tstack <int> st;\n\t\tREP(i,SZ(temp)){\n\t\t\tif(temp[i]==\"+\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1+t2);\n\t\t\t}else if(temp[i]==\"-\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2-t1);\n\t\t\t}else if(temp[i]==\"*\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t1*t2);\n\t\t\t}else if(temp[i]==\"/\"){\n\t\t\t\tint t1=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tint t2=st.top();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(t2/t1);\n\t\t\t}else{\n\t\t\t\tst.push(toInt(temp[i]));\n\t\t\t}\n\t\t}\n\t\tcout<<st.top()<<endl;\n\t\tst.pop();\n\t\t\n\t}\n\treturn 0;\n}\n\n//5+4*3+2/6=\n//(1+4)*(3+7)/5=\n//5+4-3=\n//(1+5)*(2+3)="
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef pair<ll,const char*> parsed;\n\nparsed expr(const char*);\nparsed term(const char*);\nparsed fact(const char*);\n\nparsed expr(const char* s)\n{\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=term(s);\n\twhile(*now.second=='+' || *now.second=='-'){\n\t\tchar op=*now.second;\n\t\tparsed next=term(now.second+1);\n\t\tif(op=='+')\n\t\t\tnow=parsed(now.first+next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first-next.first,next.second);\n\t}\n\t//cout<<\"expr(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed term(const char* s)\n{\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")\"<<endl;\n\tparsed now=fact(s);\n\twhile(*now.second=='*' || *now.second=='/'){\n\t\tchar op=*now.second;\n\t\tparsed next=fact(now.second+1);\n\t\tif(op=='*')\n\t\t\tnow=parsed(now.first*next.first,next.second);\n\t\telse\n\t\t\tnow=parsed(now.first/next.first,next.second);\n\t}\n\t//cout<<\"term(\\\"\"<<s<<\"\\\")=\"<<now.first<<endl;\n\treturn now;\n}\n\nparsed fact(const char* s)\n{\n\t//cout<<\"fact(\\\"\"<<s<<\"\\\")\"<<endl;\n\t//if(s[0]=='('){\n\t//\tparsed res=expr(s+1);\n\t//\tres.second++;\n\t//\treturn res;\n\t//}\n\t//else{\n\t//\tconst char* p=s;\n\t//\tif(*p=='-')\n\t//\t\tp++;\n\t//\tll n=0;\n\t//\twhile(isdigit(*p)){\n\t//\t\tn=n*10+*p-'0';\n\t//\t\tp++;\n\t//\t}\n\t//\treturn parsed(n,p);\n\t//}\n\t\n\tif(isdigit(s[0])){\n\t\tconst char* p=s;\n\t\tif(*p=='-')\n\t\t\tp++;\n\t\tll n=0;\n\t\twhile(isdigit(*p)){\n\t\t\tn=n*10+(*p-'0');\n\t\t\tp++;\n\t\t}\n\t\treturn parsed(n,p);\n\t}\n\telse if(s[0]=='('){\n\t//else{\n\t\tparsed res=expr(s+1);\n\t\tif (*res.second!=')') exit(0);\n\t\tres.second++;\n\t\treturn res;\n\t}\n\telse\n\t\texit(0);\n}\n\n//parsed fact(const char *p)\n//{\n//  if (isdigit(*p)){\n//    int t=0;\n//    while(isdigit(*p)) t=t*10+*(p++)-'0';\n//    return parsed(t,p);\n//  }\n//  else if (*p=='('){\n//    parsed r=expr(p+1);\n//    if (*r.second!=')') exit(0); // invalid input\n//    return parsed(r.first,r.second+1);\n//  }\n//  else\n//    exit(0); // invalid input\n//}\n\nint main()\n{\n\tstring s;\n\tgetline(cin,s);\n\twhile(getline(cin,s))\n\t\tcout<<expr(s.c_str()).first<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\nusing namespace std;\n\nint num(string&, int&);\nint term(string&, int&);\nint mul(string&, int&);\nint expr(string&, int&);\n\nint num(string &s, int &k) {\n    int ret = 0;\n    while ('0' <= s[k] && s[k] <= '9') {\n        ret *= 10;\n        ret += s[k] - '0';\n        k ++;\n    }\n    return ret;\n}\n\nint term(string &s, int &k) {\n    int sym = 1;\n    if (s[k] == '+') {\n        sym = 1;\n        k ++;\n    } else if (s[k] == '-') {\n        sym = -1;\n        k ++;\n    }\n    int ret;\n    if (s[k] == '(') {\n        k ++;\n        ret = expr(s, k);\n        k ++;\n    } else {\n        ret = num(s, k);\n    }\n    return sym * ret;\n}\n\nint mul(string &s, int &k) {\n    int ret = term(s, k);\n    if (s[k] == '*') {\n        k ++;\n        return ret * mul(s, k);\n    } else if (s[k] == '/') {\n        k ++;\n        return ret / mul(s, k);\n    }\n    return ret;\n}\n\nint expr(string &s, int &k) {\n    int ret = mul(s, k);\n    if (s[k] == '+') {\n        k ++;\n        return ret + expr(s, k);\n    } else if (s[k] == '-') {\n        return ret + expr(s, k);\n    }\n    return ret;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    string s;\n    while (n--) {\n        cin >> s;\n        int pos = 0;\n        cout << expr(s, pos) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\n#define ll long long\n\nll expr();\nll term();\nll fac();\nint left();\nchar peek();\nchar pop();\nint isdeg(char z);\nint isdeg(char z);\nvoid eat(char z);\nll num();\n\nstring s;\nint t;\n\nint main(){\n  int n;\n  cin >> n;\n  cin >> s;\n  while(n){\n    long long ans=0;\n    t=0;\n    s.pop_back();\n    ans=expr();\n    n--;\n    cout << ans << endl;\n    cin >> s;\n  }\n}\n\n\nll expr(){\n  ll res=term();\n  while(left()&&(peek()=='+'||peek()=='-')){\n    if(peek()=='+'){\n      eat('+');\n      res+=term();\n    }\n    else if(peek()=='-'){\n      eat('-');\n      res-=term();\n    }\n  }\n  return res;\n}\n\nll term(){\n  ll res=fac();\n  while(left()&&(peek()=='*'||peek()=='/')){\n    if(peek()=='*'){\n      eat('*');\n      res*=fac();\n    }\n    else if(peek()=='/'){\n      eat('/');\n      res/=fac();\n    }\n  }\n  return res;\n}\n\nll fac(){\n  if(peek()=='('){\n    eat('(');\n    ll res=expr();\n    eat(')');\n    return res;\n  }\n  else{\n    return num();\n  }\n}\n\n\nint left(){                 //まだ文字列が残っているかを調べる\n  return int(s.size())>t;\n}\n\nchar peek(){                //次の文字を一文字先読みする\n  return s[t];\n}\n\nchar pop(){                 //次の文字を読みとって、インデックスを進める\n  t++;\n  return s[t-1];\n}\n\nint isdeg(char z){\n  return z>='0'&&z<='9';\n}\n\nvoid eat(char z){\n  if(s[t]!=z) cout << \"warning \" << t << endl;\n  t++;\n}\n\nll num(){\n  ll res=0;\n  while(left()&&isdeg(peek())){\n    res*=10;\n    res+=pop()-'0';\n  }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nauto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\nauto term = eval(factor, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << expr(begin) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint number(State &begin) {\n\tint ret = 0;\n\tfor (; isdigit(*begin);) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\nint factor(State &begin) {\n\tint ret;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tret = expression(begin);\n\t\tbegin++;\n\t}\n\telse {\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\nint term(State &begin) {\n\tint ret = factor(begin);\n\tfor (;;) {\n\t\tif (*begin == '*') {\n\t\t\tret *= term(++begin);\n\t\t}\n\t\telse if (*begin == '/') {\n\t\t\tret /= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint expression(State &begin) {\n\tint ret = term(begin);\n\tfor (;;) {\n\t\tif (*begin == '+') {\n\t\t\tret += term(++begin);\n\t\t}\n\t\telse if (*begin == '-') {\n\t\t\tret -= term(++begin);\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tcin.ignore();\n\tfor (int i = 0; i < N; i++) {\n\t\tstring str;\n\t\tgetline(cin, str);\nState s = str.begin();\n\t\tcout << expression(str.begin()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nint expression(State&);\nint number(State&);\nint factor(State&);\nint term(State&);\n\nint expression(State &begin){\n  //cout <<\"expression\"<<endl;\n  int ret = term(begin);\n  while(1){\n    if(*begin == '+'){\n      begin++;\n      ret += term(begin);\n    }\n    else if(*begin == '-'){\n      begin++;\n      ret -= term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  //cout <<\"term\"<<endl;\n  int ret = factor(begin);\n  \n  while(1){\n    if(*begin == '*'){\n      begin++;\n      ret *= factor(begin);\n    }\n    else if(*begin == '/'){\n      begin++;\n      ret /= factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint number(State &begin){\n  //cout <<\"number\"<<endl;\n  int ret = 0;\n  while(isdigit(*begin)){\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  //cout <<\"factor\"<<endl;\n  if(*begin == '('){\n    begin++;\n    int ret = expression(begin);\n    begin++; // ')' をスキップ\n    return ret;\n  }\n\n  if(*begin == '-'){\n    begin++;\n    return -factor(begin);\n  }\n  return number(begin);\n}\n\n// beginがexpectedを指していたらbeginを一つ進める。\n/*void consume(State &begin, char expected) {\n  if (*begin == expected) {\n    begin++;\n  } else {\n    cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n\t << endl;\n    cerr << \"Rest string is '\";\n    while (*begin) {\n      cerr << *begin++;\n    }\n    cerr << \"'\" << endl;\n    throw ParseError();\n    }\n    }*/\n\nint main(){\n  int n;\n  cin >> n;\n  cin.ignore();\n  for(int i = 0 ; i < n ; i++){\n    string s;\n    getline(cin, s);\n    cout << s << endl;\n    State begin = s.begin();\n    int ans = expression(begin);\n    //consume(begin, '=');\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <functional>\n#include <numeric>\nusing namespace std;\n#define rep(p,q) for(int i = p;i < q; i++)\n#define big (long long int)(10e9 + 7)\n\nint siki(string &str, int &i);\nint kou(string &str, int &i);\nint insu(string &str, int &i);\nint number(string &str, int &i);\n\nint main(void) {\n\tint num = 0;\n\tcin >> num;\n\trep(0, num) {\n\t\tstring str;\n\t\tint x = 0;\n\t\tcin >> str;\n\t\tcout << siki(str, x) << endl;\n\t}\n}\n\nint siki(string &str,int &i) {\n\tint val1 = kou(str,i);\n\twhile (str[i] == '+' || str[i] == '-') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = kou(str, i);\n\t\tif (op == '+') {\n\t\t\tval1 = val1 + val2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval1 = val1 - val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint kou(string &str, int &i) {\n\tint val1 = insu(str, i);\n\twhile (str[i] == '*' || str[i] == '/') {\n\t\tchar op = str[i];\n\t\ti++;\n\t\tint val2 = insu(str, i);\n\t\tif (op == '*') {\n\t\t\tval1 = val1 * val2;\n\t\t}\n\t\telse {\n\t\t\tval1 = val1 / val2;\n\t\t}\n\t}\n\treturn val1;\n}\n\nint insu(string &str, int &i) {\n\tint val1 = 0;\n\n\tif(str[i] != '(')val1 = number(str, i);\n\tif(str[i] == '(') {\n\t\ti++;\n\t\tval1 += siki(str, i);\n\t\ti += 1;\n\t}\n\n\t\n\t\n\treturn val1;\n}\n\nint number(string &str, int &i) {\n\tint val1 = 0;\n\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\t val1 = (int)str[i] - (int)'0';\n\t\ti++;\n\t\tif (str[i] == '0' || str[i] == '1' || str[i] == '2' || str[i] == '3' || str[i] == '4' || str[i] == '5' || str[i] == '6' || str[i] == '7' || str[i] == '8' || str[i] == '9') {\n\t\t\tval1 = val1 * 10;\n\t\t\tval1 += number(str, i);\n\t\t}\n\t}\n\treturn val1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<isotream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nll stol(string s){\n  stringstream ss(s);\n  ll n;\n  ss >> n;\n  return n;\n}\n\nll parse(int l, int r){\n  int n = 0,i;\n\n  for(i=r-1;i>=l;i--){\n    if(s[i] == ‘)‘)n++;  if(s[i] == ‘(’)n--;\n    if(!n){\n      if(s[i] == ‘+’)return parse(l,i)+parse(i+1,r);\n      if(s[i] == ‘-’)return parse(l,i)-parse(i+1,r);\n    }\n  }\n\n  for(i=r-1;i>=l;i--){\n    if(s[i] == ‘)‘)n++;  if(s[i] == ‘(’)n--;\n    if(!n){\n      if(s[i] == ‘*’)return parse(l,i)*parse(i+1,r);\n      if(s[i] == ‘/’)return parse(l,i)/parse(i+1,r);\n    }\n  }\n\n  if(s[l] == ‘(‘ && s[r-1] == ‘)’)return parse(l+1,r-1);\n  return stol(s.substr(l,r-l));\n}\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  while(n--){\n    cin >> s;\n    cout << parse(0,(int)s.size()-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint expression(string,int&);\nint term(string,int&);\nint factor(string,int&);\nint number(string,int&);\n\nbool f;\n\nint expression(string s,int& p){\n  int res=term(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='+'){\n      p++;\n      res+=term(s,p);\n      continue;\n    }\n    if(s[p]=='-'){\n      p++;\n      res-=term(s,p);\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint term(string s,int& p){\n  int res=factor(s,p);\n  while(p<(int)s.size()){\n    if(s[p]=='*'){\n      p++;\n      res*=factor(s,p);\n      continue;\n    }\n    if(s[p]=='/'){\n      p++;\n      int tmp=factor(s,p);\n      if(tmp==0){\n\tf=1;\n\tbreak;\n      }\n      res/=tmp;\n      continue;\n    }\n    break;\n  }\n  return res;\n}\n\nint factor(string s,int& p){\n  int res;\n  if(s[p]=='('){\n    p++;\n    res=expression(s,p);\n    p++;\n  }else{\n    res=number(s,p);\n  }\n  return res;\n}\n\nint number(string s,int& p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=res*10+s[p++]-'0';\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  while(n--){\n    string s;\n    int p=0;\n    cin>>s;s.pop_back();\n    cout<<expression(s,p)<<endl;\n  }\n  return 0;\n}\n\n/*\nverified on 2017/04/26\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?lang=jp&id=0109\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\nint factor(State &begin);\n\nint number(State &begin){\n    int ret=0;\n\n    while(isdigit(*begin)){\n        ret*=10;\n        ret+=*begin -'0';\n        begin++;\n    }\n    return ret;\n}\n\nint term(State &begin){\n    int ret=factor(begin);\n\n    while(true){\n        if(*begin=='*')ret*=factor(++begin);\n        else if(*begin=='/')ret/=factor(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret=term(begin);\n\n    while(true){\n        if(*begin=='+')ret+=term(++begin);\n        else if(*begin=='-')ret-=term(++begin);\n        else break;\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin=='('){\n        int ret=expression(++begin++);\n    }else{\n        return number(begin);\n    }\n}\n\n\n\n\n\nint main(){\n\n    int N;\n    cin>>N;\n    cin.ignore();\n    REP(i,N){\n\n        string s;\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-6;\ndouble add(double a,double b){\n    if(abs(a+b)<eps)return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\ncin>>n;\ncout<<n<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://gist.github.com/draftcode/1357281\n#include <string>\n#include <cctype>\n#include <iostream>\ntypedef std::string::iterator State;\nclass ParseError {};\n\nint number(State &begin);\nint factor(State &begin);\nint term(State &begin);\nint expression(State &begin);\nvoid consume(State &begin, char expected){\n\tif(*begin == expected){\n\t\tbegin++;\n\t}else{\n\t\tstd::cerr << \"Expected '\" << expected << \"' but got '\"<<*begin << \"'\"<<std::endl;\n\t\tstd::cerr << \"Rest string is '\";\n\t\twhile(*begin){\n\t\t\tstd::cerr << *begin++;\n\t\t}\n\t\tstd::cerr<<\"'\"<<std::endl;\n\t\tthrow ParseError();\n\t}\n}\n\nint main(void){\n\tint N;\n\tstd::cin >> N;\n\tstd::cin.ignore();\n\twhile(N--){\n\t\tstd::string s;\n\t\tstd::getline(std::cin, s);\n\t\t//std::cin>>s;\n\t\tState begin = s.begin();\n\t\tint ans = expression(begin);\n\t\t//consume(begin, '=');\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n\nint number(State &begin){\n\tint ret = 0;\n\n\twhile(isdigit(*begin)){\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin == '('){\n\t\t//consume(begin,'(');\n\t\tbegin++;\n\t\tint ret = expression(begin);\n\t\t//consume(begin,')');\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n\treturn ret;\n}\n\nint term(State &begin){\n\tint ret = factor(begin);\n\n\tfor(;;){\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret *= factor(begin);\n\t\t}else if(*begin == '/'){\n\t\t\tbegin++;\n\t\t\tret /= factor(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint expression(State &begin){\n\tint ret = term(begin);\n\n\tfor(;;){\n\t\tif(*begin == '+'){\n\t\t\tbegin++;\n\t\t\tret += term(begin);\n\t\t} else if(*begin == '-'){\n\t\t\tbegin++;\n\t\t\tret -= term(begin);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n\n/** memo\n * expr ::= term { ( '+' | '-' ) term }\n * term ::= fact { ( '*' | '/' ) fact }\n * fact ::= '(' expr ')' | digit\n **/\n\nusing namespace std;\n\nint expr();\nint term();\nint fact();\n\nchar buf[101];\nint p;\n\nint expr() {\n\tint v = term();\n\twhile(buf[p] == '+' || buf[p] == '-') {\n\t\tif(buf[p] == '+') {\n\t\t\tp++;\n\t\t\tv += term();\n\t\t}\n\t\telse {\n\t\t\tp++;\n\t\t\tv -= term();\n\t\t}\n\t}\n\treturn v;\n}\n\n\nint term() {\n\tint v = fact();\n\twhile(buf[p] == '*' || buf[p] == '/') {\n\t\tif(buf[p] == '*') {\n\t\t\tp++;\n\t\t\tv *= fact();\n\t\t}\n\t\telse {\n\t\t\tp++;\n\t\t\tv /= fact();\n\t\t}\n\t}\n\treturn v;\n}\n\nint fact() {\n\tint v = 0;\n\tif(buf[p] == '(') {\n\t\tp++;\n\t\tv = expr();\n\t\tp++; // skip ')'\n\t}\n\telse {\n\t\twhile(isdigit(buf[p])) {\n\t\t\tv = v * 10 + buf[p] - '0';\n\t\t\tp++;\n\t\t}\n\t}\n\treturn v;\n}\n\nint main() {\n\tint times;\n\tint ans;\n\n\tcin >> times;\n\tfor(int i = 0; i < times; i++) {\n\t\tcin >> buf;\n\t\tp = 0;\n\t\tans = expr();\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nchar siki[200];\nint cur;\n\n\nint digit(){\n  int n=siki[cur]-'0';\n  ++cur;\n  return n;\n}\n\nint number(){\n  int n=digit();\n  while(cur<strlen(siki) && isdigit(siki[cur]))\n    n=n*10+digit();\n\n  return n;\n}\n\nint factor();\n\nint term(){\n  int a=factor();\n  while(cur<strlen(siki) && (siki[cur]=='*' || siki[cur]=='/')){\n    char op=siki[cur];\n    ++cur;\n    int b=factor();\n    if(op=='*')a*=b;else a/=b;\n  }\n  return a;\n}\n\nint expression(){\n  int a=term();\n  while(cur<strlen(siki) && (siki[cur]=='+' || siki[cur]=='-')){\n    char op=siki[cur];\n    cur++;\n    int b=term();\n    if(op=='+')a+=b;else a-=b;\n  }\n  return a;\n}\n\nint factor(){\n  if(siki[cur]!='(')return number();\n  cur++;\n  int n=expression();\n  cur++;\n  return n;\n}\n\nint main(){\n  int n;\n  cin>>n;\n\n  for(int i=0;i<n;i++){\n    cin>>siki;\n    cur=0;\n    cout<<expression()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\n\nint expression(State &);\nint term(State &);\nint factor(State &);\nint number(State &);\n\nint main(void){\n  int N;\n  cin >> N;\n  cin.ignore();\n  \n  for(int i=0;i<N;i++){\n    string s;\n    getline(cin,s);\n\n    State begin=s.begin();\n    int ans=expression(begin);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nint expression(State &begin){\n  int ret=term(begin);\n  \n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint term(State &begin){\n  int ret=factor(begin);\n  \n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(State &begin){\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n    return ret;\n  }\n  if(*begin=='-'){\n    begin++;\n    return -factor(begin);\n  }\n  return number(begin);\n}\n\nint number(State &begin){\n  int ret=0;\n  \n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\nint main(){\n    int n;\n    string s;\n    while(cin>>n){\n        for(int i=0; i<n; i++){\n            cin>>s;\n            int j=0;\n            \n            queue<string> qu;\n            stack<string> st;\n            \n            \n            while(j<s.length()){\n                //cout<<s[j]<<endl;\n                //数値の処理\n                if(s[j]>='0'&&s[j]<='9'){\n                    string s_temp;\n                    \n                    while(s[j]>='0'&&s[j]<='9'){\n                        s_temp+=s[j];\n                        j++;\n                    }\n                    \n                    qu.push(s_temp);\n                    \n                }\n                \n                //括弧の処理\n                else if(s[j]==')'){\n                    while(1){\n                        string s_temp;\n                        s_temp = st.top();\n                        st.pop();\n                        if(s_temp==\"(\"){\n                            break;\n                        }else{\n                            qu.push(s_temp);\n                        }\n                    }\n                    j++;\n                }\n                \n                else if(s[j]=='('){\n                    string s_temp;\n                    s_temp+=s[j];\n                    st.push(s_temp);\n                    j++;\n                }\n                \n                //演算子の処理\n                else if(s[j]=='-'||s[j]=='+'||s[j]=='*'||s[j]=='/'){\n                    string s_temp;\n                    s_temp+=s[j];\n                    if(st.empty()){\n                        st.push(s_temp);\n                        j++;\n                    }else{\n                        if(!((s_temp==\"*\"||s_temp==\"/\")&&(st.top()==\"-\"||st.top()==\"+\"))){\n                            s_temp = st.top();\n                            st.pop();\n                            qu.push(s_temp);\n                        }else{\n                            st.push(s_temp);\n                            j++;\n                        }\n                    }\n                }\n                //=の処理\n                else if(s[j]=='='){\n                    j++;\n                }\n                \n                \n            }\n            while(!st.empty()){\n                qu.push((st.top()));\n                st.pop();\n            }\n            \n            stack<int> num;\n            while(!qu.empty()){\n                \n                //cout<<qu.front()<<endl;\n                \n                if(qu.front()==\"*\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b*a;\n                    num.push(a);\n                }else if(qu.front()==\"/\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b/a;\n                    num.push(a);\n                    \n                }else if(qu.front()==\"-\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b-a;\n                    num.push(a);\n                }else if(qu.front()==\"+\"){\n                    int a,b;\n                    a=num.top();\n                    num.pop();\n                    b=num.top();\n                    num.pop();\n                    a=b+a;\n                    num.push(a);\n                }else{\n                    stringstream stream;\n                    stream<<qu.front();\n                    int temp;\n                    stream>>temp;\n                    num.push(temp);\n                }\n                qu.pop();\n            }\n            cout<<num.top()<<endl;\n        }\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nvector<string> toReversePorland(string str){\n\n  vector<string> hand;\n  vector<string> side;\n\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] >= '0' && str[i] <= '9'){\n      string num;\n      while(i < str.size()){\n\tif(str[i] < '0' || str[i] > '9'){\n\t  break;\n\t}\n\tnum += str[i];\n\ti++;\n      }\n      hand.push_back(num);\n      i--;\n    }\n    else if(str[i] == '('){\n      string tmp;\n      tmp += str[i];\n      side.push_back(tmp);\n    }\n    else if(str[i] == ')'){\n      // ツ右ツ環古環づ慊づ可可算ツ子ツづーツ暗ェツづつつクツづつ偲ィツ個ウツづ可姪淞つキ\n      for(int j = side.size()-1 ; ;j--){\n\tif(side[j] == \"(\"){\n\t  if(j != 0){\n\t    vector<string> tmp;\n\t    for(int k = 0; k < j; k++){\n\t      tmp.push_back(side[k]);\n\t    }\n\t    side = tmp;\n\t  }\n\t  else\n\t    side.clear();\n\t  break;\n\t}\n\telse{\n\t  string tmp = side[j];\n\t  hand.push_back(tmp);\n\t}\n      }\n    }\n    else{\n      if(side.size() == 0){\n\tstring tmp;\n\ttmp += str[i];\n\tside.push_back(tmp);\n      }\n      else if(str[i] == '+' || str[i] == '-'){\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = tmp;\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n      else{\n\tif(side[side.size()-1] == \"*\" || side[side.size()-1] == \"/\"){\n\t  hand.push_back(side[side.size()-1]);\n\t  string tmp;\n\t  tmp += str[i];\n\t  side[side.size()-1] = string(tmp);\n\t}\n\telse{\n\t  string tmp;\n\t  tmp += str[i];\n\t  side.push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i = side.size()-1; i >= 0; i--){\n    hand.push_back(string(side[i]));\n  }\n  \n  return hand;\n}\n\n\nint calc(vector<string> str){\n  stack<int> st;\n  for(int i = 0; i < str.size(); i++){\n    if(str[i] == \"+\" || str[i] == \"-\" || str[i] == \"*\" || str[i] == \"/\"){\n      int val[2];\n      val[0] = st.top();\n      st.pop();\n      val[1] = st.top();\n      st.pop();\n      if(str[i] == \"+\"){\n\tst.push(val[0] + val[1]);\n      }\n      if(str[i] == \"-\"){\n\tst.push(val[1] - val[0]);\n      }\n      if(str[i] == \"*\"){\n\tst.push(val[0] * val[1]);\n      }\n      if(str[i] == \"/\"){\n\tst.push(val[1] / val[0]);\n      }\n    }\n    else{\n      st.push(atoi(str[i].c_str()));\n    }\n  }\n  return st.top();\n}\n\nint main(){\n\n  int n = 1;\n  string s;\n  getline(cin,s);\n  n = atoi(s.c_str());\n\n  vector<string> input;\n  string str;\n  for(int i = 0; i < n; i++){\n    getline(cin,str);\n    input.push_back(str);\n  }\n\n  for(int i = 0; i < n; i++){\n    str = input[i];\n    str = str.substr(0,str.size()-1);\n    // vector<string> vec = toReversePorland(str);\n    // for(int i = 0; i < vec.size(); i++)\n    //   cout << vec[i] << endl;\n    cout << calc(toReversePorland(str)) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    bool f=false;\n    if(s[pos]=='-'){f=true;pos++;}\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    if(f)res*=-1;\n    return res;\n  }\n  \n  int getNum(){\n    if(s[pos]=='('){\n      pos++;\n      return getAns();\n    }\n    int res=head2Num();\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      return res/getNum();\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      if(s[pos]==')'||s[pos]=='='){pos++;break;}\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    return res;\n  }\n};\n\nint main(){\n  int Tc;cin>>Tc;\n  calcStr a;\n  while(Tc--){\n    cin>>a.s;\n    a.init();\n    cout<<a.getAns()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint hyoka(string);\nint isNum(int);\n\nint main(){\n\tint n,i;\n\tstring s;\n\t\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t cin>>s;\n\t cout<<hyoka(s)<<endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n\nlong int hyoka(string s){\n\tlong int total=0,work=0;\n\tlong int tmp1,tmp2;\n\tint oi=0;\n\tchar oc;\n\tint n;\n\tstring cs;\n\t\n\tif(isNum(s[oi])!=-1){s=\"+\"+s;}\n\t\n\twhile(1){\n\t oc=s[oi];if(oc=='='){total+=work;break;}\n\t \n\t if(s[oi+1]!='('){\t//??°???????????????\n\t  tmp1=0;\n\t  while(1){\n\t   oi++;\n\t   tmp2=s[oi];\n\t   if(tmp2!=-1){tmp1=tmp1*10+tmp2;}else{break;}\n\t  }\n\t }else{\t//??????????????°\n\t  cs=\"\";n=1;oi++;\n\t  while(1){\n\t   oi++;\n\t   switch(s[oi]){\n\t\tcase '(':n++;break;\n\t\tcase ')':n--;break;\n\t   }\n\t   if(n!=0){cs+=s[oi];}else{break;}\n\t  }\n\t  cs+='=';\n\t  tmp1=hyoka(cs);\n\t }\n\t\n\t switch(oc){\n\t  case '+':total+=work;work=tmp1;break;\n\t  case '-':total+=work;work=-tmp1;break;\n\t  case '*':work*=tmp1;break;\n\t  case '/':work/=tmp1;break;\n\t }\n\t}\n\t\n\treturn total;\n}\n\nint isNum(int c){\n\tif(49<=c && c<=57){\n\t return c-49;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint exp();\nint term();\nint factor();\nint number();\nint digit();\n\nstring str;\n\nint p,len,val;\n\nint exp(){\n  int val = term();\n  while( str[p] == '+' || str[p] == '-' ){\n    if( str[p] == '+' ){\n      p++;\n      val += term();\n    }else if( str[p] == '-' ){\n      p++;\n      val -= term();\n    }\n  }\n  return val;\n}\n\nint term(){\n  int val=factor();\n  while( str[p] == '*' || str[p] == '/' ){\n    if( str[p] == '*' ){\n      p++;\n      val *= factor();\n    }else if( str[p] == '/' ){\n      p++;\n      val /= factor();\n    }\n  }\n  return val;\n}\n\nint factor(){\n  int val;\n  if( str[p] == '(' ){\n      p++;\n      val =  exp();\n      p++;\n  }else{\n    val = number();\n  }\n\n  return val;\n}\n\nint number(){\n  int val = 0;\n  while( digit() ){\n    int num = str[p] - '0';\n    val = val * 10 + num;\n    p++;\n  }\n  return val;\n}\n\nint digit(){\n  if( str[p] == '1' || str[p] == '2' || str[p] == '3' || str[p] == '4' ||\n      str[p] == '5' || str[p] == '6' || str[p] == '7' || str[p] == '8' ||\n      str[p] == '9' || str[p] == '0' ) return 1;\n  return 0;\n}\n\n  \nint main(){\n  int n; cin >> n;\n  \n  for(int i = 0; i < n; i++ ){\n    p = 0;\n    cin >> str;\n    \n    int ans = exp();      \n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define all(a) (a).begin() ,(a).end()\n\nconst double eps = 1e-10;\nconst double inf = (int)1e8;\n\nint expression(State &begin);\nint term(State &begin);\nint number(State &begin);\nint factor(State &begin);\n\nint number(State &begin){\n    int ret = 0;\n    \n    while(isdigit(*begin)){\n        ret *= 10;\n        ret += *begin - '0';\n        begin ++;\n    }\n    return ret;\n}\n\nint term(State & begin){\n    int ret = factor(begin);\n    \n    for(;;){\n        if(*begin == '*'){\n            begin++;\n            ret *= factor(begin);\n        }else if(*begin == '/'){\n            begin++;\n            ret /= factor(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint expression(State &begin){\n    int ret = term(begin);\n    \n    for(;;){\n        if(*begin == '+'){\n            begin++;\n            ret += term(begin);\n        }else if(*begin == '-'){\n            begin++;\n            ret -= term(begin);\n        }else{\n            break;\n        }\n    }\n    return ret;\n}\n\nint factor(State &begin){\n    if(*begin == '('){\n        begin++;\n        int ret = expression(begin);\n    }else{\n        return number(begin);\n    }\n}\n\nint main(void){\n    int n;\n    string s;\n    cin>>n;\n    getline(cin,s);\n    while(n--){\n        getline(cin,s);\n        State begin = s.begin();\n        cout<<expression(begin)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\nclass myCalc {\nprivate:\n\tstd::map<char, int> mOperator;\npublic:\n\tmyCalc( void ) {\n\t\tmOperator['('] = -2;\n\t\tmOperator[')'] = -1;\n\t\tmOperator['+'] = 0;\n\t\tmOperator['-'] = 1;\n\t\tmOperator['/'] = 2;\n\t\tmOperator['*'] = 3;\n\t}\n\tstd::string ToRPN( std::string str ) {\n\t\tstd::string ret;\n\t\tstd::stack<char> st;\n\t\tint len = str.size(), i = 0;\n\t\twhile(i < len) {\n\t\t\tswitch(str[i]) {\n\t\t\tcase '+' :\n\t\t\t\twhile(!st.empty() && mOperator[st.top()] > mOperator[str[i]]) {\n\t\t\t\t\t\tret += st.top(); st.pop();\n\t\t\t\t}\n\t\t\tcase '(':\n\t\t\t\tst.push(str[i++]);\n\t\t\t\tbreak;\n\t\t\tcase '-': case '/': case '*':\n\t\t\t\twhile(!st.empty() && mOperator[st.top()] >= mOperator[str[i]]) {\n\t\t\t\t\tret += st.top(); st.pop();\n\t\t\t\t}\n\t\t\t\tst.push(str[i++]);\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(!st.empty() && st.top() != '(') {\n\t\t\t\t\tret += st.top();\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.pop();\n\t\t\t\t++i;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret += '[';\n\t\t\t\twhile('0' <= str[i] && str[i] <= '9') ret += str[i++];\n\t\t\t\tret += ']';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(!st.empty()) { ret += st.top(); st.pop(); }\n\t\treturn ret;\n\t}\n\tint Calculate( std::string str ) {\n\t\tstd::stack<int> st;\n\t\tint len = str.size(), i = 0;\n\t\twhile(i < len) {\n\t\t\tint a, b;\n\t\t\tswitch(str[i]) {\n\t\t\tcase '+':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(a+b);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(b-a);\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(a*b);\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\ta = st.top(); st.pop();\n\t\t\t\tb = st.top(); st.pop();\n\t\t\t\tst.push(b/a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t++i; a = 0;\n\t\t\t\twhile(str[i] != ']') {\n\t\t\t\t\ta *= 10;\n\t\t\t\t\ta += (str[i++] - '0');\n\t\t\t\t}\n\t\t\t\tst.push(a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t\treturn st.top();\n\t}\n};\n\nint main( void )\n{\n\tlong long n;\n\tmyCalc calc;\n\tcin >> n;\n\twhile(n--) {\n\t\tstring in;\n\t\tcin >> in;\n\t\tin.erase(in.size()-1);\n\t\t//cout << in << ' ' << calc.ToRPN(in) << endl;\n\t\tcout << calc.Calculate(calc.ToRPN(in)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint p;\nstring str;\n\nint Term();\nint Factor();\nint Elem();\nint Digit();\n\nint Term() {\n  int a = Factor();\n  while (str[p] == '+' || str[p] == '-') {\n    char c = str[p];\n    p++; // read [+-]\n    int b = Factor();\n    if (c == '+') {\n      a = a + b;\n    } else {\n      a = a - b;\n    }\n  }\n  return a;\n}\n\nint Factor() {\n  int a = Elem();\n  while (str[p] == '*' || str[p] == '/') {\n    char c = str[p];\n    p++; // read [*/]\n    int b = Elem();\n    if (c == '*') {\n      a = a * b;\n    } else {\n      a = a / b;\n    }\n  }\n  return a;\n}\n\nint Elem() {\n  if (str[p] == '(') {\n    p++; // read (\n    int a = Term();\n    p++; // read )\n    return a;\n  } else {\n    int a = 0;\n    while (isdigit(str[p])) {\n      int b = Digit();\n      a = 10 * a + b;\n    }\n    return a;\n  }\n}\n\nint Digit() {\n  int a = str[p] - '0';\n  p++; // read [0-9]\n  return a;\n};\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> str;\n    p = 0;\n    cout << Term() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n\ntypedef std::stringstream sst;\n\nint ToInt(std::string str){\n\tint i;\n\tsst ss;\n\tss<<str;\n\tss>>i;\n\treturn i;\n}\nstd::string ToStr(int i){\n\tstd::string str;\n\tsst ss;\n\tss<<i;\n\tss>>str;\n\treturn str;\n}\n\nstd::string SubStr(std::string str,int x,int y){\n\treturn str.substr(x,y-x+1);\n}\nint Third(std::string str){\n\tint fres,Ans;\n\twhile( ( fres=str.find_first_of(\"+-\",1) ) != std::string::npos ){\n\t\tint aRes;\n\t\t\n\t\tif( (aRes=str.find_first_of(\"+-\",fres+2)) == std::string::npos )\n\t\t\taRes=str.size()-1;\n\t\telse --aRes;\n\t\t\n\t\tif( str[fres] =='+' ){\n\t\t\tAns=ToInt(SubStr(str,0,fres-1))+ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n\t\t}else{\n\t\t\tAns=ToInt(SubStr(str,0,fres-1))-ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n\t\t}\n\t}\n\treturn ToInt(str);\n}\n\nint Second(std::string str){\n\tint fres,Ans;\n\twhile( ( fres=str.find_first_of(\"*/\") ) != std::string::npos ){\n\t\tint bRes,aRes;\n\t\tif( (bRes=str.find_last_of(\"+-\",fres)) == std::string::npos  || bRes==0 )\n\t\t\tbRes=0;\n\t\telse ++bRes;\n\t\t\n\t\tif( (aRes=str.find_first_of(\"+-*/\",fres+2)) == std::string::npos )\n\t\t\taRes=str.size()-1;\n\t\telse --aRes;\n\t\t\n\t\tif( str[fres] =='*' ){\n\t\t\tAns=ToInt(SubStr(str,bRes,fres-1))*ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n\t\t}else{\n\t\t\tAns=ToInt(SubStr(str,bRes,fres-1))/ToInt(SubStr(str,fres+1,aRes));\n\t\t\tstr.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n\t\t}\n\t}\n\tAns=Third(str);\n\treturn Ans;\n}\n\nint First(std::string str){\n\tint fres;\n\twhile( (fres = str.find(\")\") ) != std::string::npos ){\n\t\tint rfres=str.rfind(\"(\",fres);\n\t\tstd::string Next=SubStr(str,rfres+1,fres-1);\n\t\tint cRes=Second(Next);\n\t\tstr.replace(rfres,Next.size()+2,ToStr(cRes).c_str());\n\t}\n\tint lRes = Second(str);\n\t\n\treturn lRes;\n}\n\nint main(){\n\tint n;\n  std::string str;\n\tstd::cin>>n;\n\twhile( n-- ){\n\t\tstd::cin>>str;\n\t  std::cout<<First(str)<<std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <sstream>\n#include <string>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nclass Source {\n  using iterator = std::string::iterator;\n  using const_iterator = std::string::const_iterator;\n  const_iterator begin, s;\n\npublic:\n  Source(iterator s) : begin(s), s(s) {}\n  Source(const_iterator s) : begin(s), s(s) {}\n\n  char peek() {\n    char ch = *s;\n    if (!ch) throw ex(\"too short\");\n    return ch;\n  }\n\n  void next() {\n    peek();\n    ++s;\n  }\n\n  std::string ex(const std::string &e) {\n    std::ostringstream oss;\n    oss << \"[pos: \" << s - begin << \", char: \" << *s << \"] \" << e << '\\n';\n    return oss.str();\n  }\n\n  bool operator==(const Source &t) const { return s == t.s; }\n  bool operator!=(const Source &t) const { return !(*this == t); }\n};\n\ntemplate<typename T> using Parser = std::function<T(Source &)>;\n\nParser<char> satisfy(const std::function<bool(char)> &f) {\n  return [=](Source &s) {\n    char c = s.peek();\n    if (!f(c)) throw s.ex(\"not satisfy\");\n    s.next();\n    return c;\n  };\n}\n\ntemplate<typename T> Parser<T> left(const std::string &e) {\n  return [=](Source &s) -> T { throw s.ex(e); };\n}\n\nParser<char> left(const std::string &e) { return left<char>(e); }\n\ntemplate<typename T1, typename T2> Parser<std::string> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    std::string r;\n    r += p1(s);\n    r += p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T> Parser<std::string> operator*(int n, const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    rep(i, n) r += p(s);\n    return r;\n  };\n}\ntemplate<typename T> Parser<std::string> operator*(const Parser<T> &x, int n) { return n * x; }\n\ntemplate<typename T> Parser<std::string> many_str(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::string r;\n    try {\n      for (;;) r += p(s);\n    } catch (const std::string &) {}\n    return r;\n  };\n}\n\nParser<std::string> many(const Parser<char> &p) { return many_str(p); }\nParser<std::string> many(const Parser<std::string> &p) { return many_str(p); }\ntemplate<typename T> Parser<std::list<T>> many(const Parser<T> &p) {\n  return [=](Source &s) {\n    std::list<T> v;\n    try {\n      for (;;) v.emplace_back(p(s));\n    } catch (const std::string &) {}\n    return v;\n  };\n}\n\ntemplate<typename T> Parser<std::string> many1(const Parser<T> &p) { return p + many(p); }\n\ntemplate<typename T> const Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [=](Source &s) {\n    T r;\n    Source back = s;\n    try {\n      r = p1(s);\n    } catch (const std::string &) {\n      if (s != back) throw;\n      r = p2(s);\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    T1 r = p1(s);\n    p2(s);\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [=](Source &s) {\n    p1(s);\n    return p2(s);\n  };\n}\n\ntemplate<typename T> Parser<T> tryp(const Parser<T> &p) {\n  return [=](Source &s) {\n    T r;\n    Source bak = s;\n    try {\n      r = p(s);\n    } catch (const std::string &) {\n      s = bak;\n      throw;\n    }\n    return r;\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> fmap(const std::function<T2(const T1 &)> &f, const Parser<T1> &p) {\n  return [=](Source &s) { return f(p(s)); };\n}\n\ntemplate<typename L, typename R, typename X> Parser<std::function<X(const L &)>> fmap(const std::function<X(const L &, const R &)> &f, const Parser<R> &p) {\n  return [=](Source &s) {\n    R r = p(s);\n    return [=](const L &l) { return f(l, r); };\n  };\n}\n\nParser<std::function<int(int)>> fmap(const std::function<int(int, int)> &f, const Parser<int> &p) { return fmap<int, int, int>(f, p); }\n\nParser<int> eval(const Parser<int> &p, const Parser<std::list<std::function<int(int)>>> &fs) {\n  return [=](Source &s) {\n    int x = p(s);\n    auto xs = fs(s);\n    return std::accumulate(xs.begin(), xs.end(), x, [](int a, const std::function<int(int)> &f) { return f(a); });\n  };\n}\n\nauto anyChar = satisfy([](char) { return true; });\n\nParser<char> char1(char c) {\n  return satisfy([=](char x) { return x == c; }) || left(std::string(\"not char '\") + c + \"'\");\n}\n\nauto digit = satisfy([](char c) { return '0' <= c && c <= '9'; }) || left(\"not digit\");\nauto upper = satisfy([](char c) { return 'A' <= c && c <= 'Z'; }) || left(\"not upper\");\nauto lower = satisfy([](char c) { return 'a' <= c && c <= 'z'; }) || left(\"not lower\");\nauto alpha = satisfy([](char c) { return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alpha\");\nauto alphaNum = satisfy([](char c) { return ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); }) || left(\"not alphaNum\");\n\nParser<std::string> token(const std::string &xs) {\n  return [=](Source &s) {\n    for (auto x : xs) (char1(x) || left(\"not token \\\"\" + xs + \"\\\"\"))(s);\n    return xs;\n  };\n}\n\n// clang-format off\nextern Parser<int> factor_;\nParser<int> factor = [](Source &s) { return factor_(s); };\n\nParser<int> number = [](Source &s) {\n  int val = 0;\n  try {\n    for (;;) {\n      if (isdigit(s.peek()))\n      val *= 10;\n      val += s.peek() - '0';\n      s.next();\n    }\n  } catch (const std::string &) {}\n  return val;\n};\n\n// auto number = fmap<string, int>([](const string &s) { return stoi(s); }, many1(digit));\n\n// auto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, factor)\n//                            || char1('/') >> fmap([](int l, int r) { return l / r; }, factor)));\nauto term = eval(number, many(char1('*') >> fmap([](int l, int r) { return l * r; }, number)\n                           || char1('/') >> fmap([](int l, int r) { return l / r; }, number)));\n\nauto expr = eval(term, many(char1('+') >> fmap([](int l, int r) { return l + r; }, term)\n                         || char1('-') >> fmap([](int l, int r) { return l - r; }, term)));\n\nParser<int> factor_ = char1('(') >> expr << char1(')') || number;\n// clang-format on\n\nsigned main() {\n  int n;\n  cin >> n;\n  cin.ignore();\n  while (n--) {\n    string s;\n    getline(cin, s);\n    s.pop_back();\n    Source begin = s.begin();\n    cout << number(begin) << endl;\n    // try {\n    //   cout << term(begin) << endl;\n    // } catch (const string &s) { cout << s << endl; }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\nint n;\nstring str;\nint start,goal;\nvoid kake();\nvoid tasi();\nvoid tume(int,int);\nint Getnum1(int);\nint Getnum2(int);\nstring i2s(int);\n\nstring i2s(int num){\n  stringstream ss;\n  string str;\n  ss << num;\n  ss >> str;\n  return str;\n}\n\nint Getnum1(int i){\n\n  string num = \"\";\n  while(1){\n    if(!('0'<=str[i] && str[i] <='9')||0 > i)break;\n    num+=str[i];\n    str[i] = '#';\n    i--;\n  }\n  //  cout << str << endl;\n  //  cout << \"num \"<<num << endl;\n  reverse(num.begin(),num.end());\n  return atoi(num.c_str());\n}\n\nint Getnum2(int i){\n\n  string num = \"\";\n  while(1){\n    if(!('0'<=str[i] && str[i] <='9')||str.size() < i)break;\n    num+=str[i];\n    str[i] = '#';\n    i++;\n  }\n  return atoi(num.c_str());\n}\n\nvoid tume(int s,int g){\n  string str2=\"\";\n  for(int i = 0 ; i < str.size() ; i++){\n    if(str[i] != '#'&& (s != i || g != i))str2+=str[i];\n  }\n  str= str2;\n}\n\nvoid cal(){\n  kake();\n  tasi();\n}\n\nvoid kake(){\n  for(int i = start ; i <= goal ; i++ ){\n    //    cout << start << ' ' << goal<<endl;\n    if(str[i] == '*'){\n      int t1 = Getnum1(i-1);\n      int t2 = Getnum2(i+1);\n      int t = t1*t2;\n      int len1 = i2s(t1).size();\n      int len2 = i2s(t2).size();\n      int len3 = i2s(t).size();\n      str.replace(i-len1,i+len2-start,i2s(t));\n      tume(i-1,i+1);\n      //\n      //      cout << str << endl;\n      i = start;\n      goal = goal-((len1+len2+1)-len3);\n      //      cout << \"goal \"<<goal << endl;\n    }\n    if(str[i] == '/'){\n      int t1 = Getnum1(i-1);\n      int t2 = Getnum2(i+1);\n      int t = t1/t2;\n      int len1 = i2s(t1).size();\n      int len2 = i2s(t2).size();\n      int len3 = i2s(t).size();\n      str.replace(i-len1,i+len2-start,i2s(t));\n      tume(i-1,i+1);\n      //\n      i = start;\n      goal = goal-((len1+len2+1)-len3);\n      //      cout << \"goal \"<<goal << endl;\n    }\n  }\n}\nvoid tasi(){\n  for(int i = start ; i <= goal ; i++ ){\n    if(str[i] == '+'){\n      int t1 = Getnum1(i-1);\n      int t2 = Getnum2(i+1);\n      int t = t1+t2;\n      int len1 = i2s(t1).size();\n      int len2 = i2s(t2).size();\n      int len3 = i2s(t).size();\n      str.replace(i-len1,i+len2-start,i2s(t));\n      tume(i-1,i+1);\n      //\n      i = start;\n      goal = goal-((len1+len2+1)-len3);\n      //      cout << \"goal \"<<goal << endl;\n    }\n    if(str[i] == '-'){\n      int t1 = Getnum1(i-1);\n      int t2 = Getnum2(i+1);\n      int t = t1-t2;\n      int len1 = i2s(t1).size();\n      int len2 = i2s(t2).size();\n      int len3 = i2s(t).size();\n      str.replace(i-len1,i+len2-start,i2s(t));\n      tume(i-1,i+1);\n      //      cout << '-' << endl;      cout << str << endl;\n      i = start;\n      goal = goal-((len1+len2+1)-len3);\n    }\n  }\n}\n\nint main(){\n  cin >> n;\n  while(n--){\n    str = \"\";\n    cin >> str;\n\n    if(str[0] == '#')break;\n\n    for(int i = 0 ; i < str.size() ; i++){\n      if(str[i] == '(')start = i;\n      if(str[i] == ')'){\n\tgoal = i;\n\tcal();\n\tstr[start] = '#';\n\tstr[goal] = '#';\n\ttume(start,goal);\n\ti = -1;\n\tcontinue;\n      }\n    }\n    start = 0,goal = str.size()-1;\n    cal();\n    int ans = atoi(str.c_str());\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nstruct Result {\n        int value, p;\n};\n\n#define PARSER_DECL(name) \\\n        Result name (const string &s, int p)\n\nPARSER_DECL(expr);\nPARSER_DECL(term);\nPARSER_DECL(factor);\nPARSER_DECL(number);\n\nPARSER_DECL(expr){\n        Result r = term(s, p);\n        while(s[r.p] == '+' || s[r.p] == '-'){\n                Result q = term(s, r.p + 1);\n                if(s[r.p] == '+'){\n                        r.value += q.value;\n                        r.p = q.p;\n                }else if(s[r.p] == '-'){\n                        r.value -= q.value;\n                        r.p = q.p;\n                }\n        }\n        return r;\n}\n\nPARSER_DECL(term){\n        Result r = factor(s, p);\n        while(s[r.p] == '*' || s[r.p] == '/'){\n                Result q = factor(s, r.p + 1);\n                if(s[r.p] == '*'){\n                        r.value *= q.value;\n                        r.p = q.p;\n                }else if(s[r.p] == '/'){\n                        r.value /= q.value;\n                        r.p = q.p;\n                }\n        }\n        return r;\n}\n\nPARSER_DECL(factor){\n        Result r;\n        if(s[p] == '('){\n                r = expr(s, p + 1);\n                ++r.p;\n        }else{\n                r = number(s, p);\n        }\n        return r;\n}\n\nPARSER_DECL(number){\n        Result r;\n        r.value = 0;\n        r.p = p;\n        while(isdigit(s[r.p])){\n                r.value = (r.value * 10) + (s[r.p] - '0');\n                ++r.p;\n        }\n        return r;\n}\n\nint main(){\n        int n;\n        cin >> n;\n        while(n--){\n                string s;\n                cin >> s;\n                s.resize(s.size() - 1);\n                cout << expr(s, 0).value << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\n\nchar s[125];\nint it;\n\nint dfs(){\n  int ret = 0;\n  int tail = 0;\n  int sign = 1;\n  // first operand\n  int a = 0;\n  if(s[it]=='('){\n    it++;\n    a = dfs();\n    assert(s[it]==')');\n    it++;\n  }else{\n    while(isdigit(s[it])){\n      a *= 10;\n      a += s[it]-'0';\n      it++;\n    }\n  }\n  tail = a;\n  while(true){\n    // operator\n    char op = s[it];\n    if(op == '=' || op == ')'){\n      // end\n      ret += sign * tail;\n      return ret;\n    }\n    it++;\n    // second operand\n    int b = 0;\n    if(s[it]=='('){\n      it++;\n      b = dfs();\n      assert(s[it]==')');\n      it++;\n    }else{\n      while(isdigit(s[it])){\n        b *= 10;\n        b += s[it]-'0';\n        it++;\n      }\n    }\n    if(op == '+' || op == '-'){\n      // tail end\n      ret += sign * tail;\n      tail = b;\n      sign = op=='+' ? 1 : -1;\n    }else if(op == '*'){\n      tail *= b;\n    }else if(op == '/'){\n      tail /= b;\n    }\n  }\n}\n\nvoid solve(){\n  REP(i,125)s[i] = '\\0';\n  scanf(\"%s\",s);\n  it = 0;\n  int ans = dfs();\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\nstring str;\n\nbool isNum(string s){\n  for(int i = 1; i < s.length(); i++)\n    if(s[i] < '0' || s[i] > '9') return false;\n\n  return true;\n}\n\nint solve(string s){\n\n  // cout << s << endl;\n  if(isNum(s)){\n    if(s[0] != '-'){\n      stringstream ss(s);\n      int out;\n      ss >> out;\n      return out;\n\n    }else{\n      string s1 = \"\";\n\n      for(int i = 1; i < s.length(); i++)\n\ts1+=s[i];\n      stringstream ss(s1);\n      int out;\n      ss >> out;\n      return -1*out;\n    }\n  }\n\n  int pos = -1;\n\n\n  for(int i = 0; i < s.length(); i++)\n    if((i&&(s[i] == '+' || s[i] == '-')) ||  s[i] == '('){\n      pos = i;\n      break;\n    }\n\n  if(pos == -1){\n    int now = 0;\n    string a,b;\n    a = b = \"\";\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '*' || s[i] == '/'){\n\tnow = i;\n\tbreak;\n      }\n      a += s[i];\n\n    }\n\n    for(int i = now+1; i < s.length(); i++)\n      b+=s[i];\n\n    if(s[now] == '+') return solve(a)+solve(b);\n    if(s[now] == '-') return solve(a)-solve(b);\n    if(s[now] == '*') return solve(a)*solve(b);\n    if(s[now] == '/') return solve(a)/solve(b);\n\n  }else{\n\n    string a,b;\n    a = b = \"\";\n\n    for(int i = 0; i < pos; i++)\n      a += s[i];\n    for(int i = pos+1; i < s.length(); i++)\n      b += s[i];\n\n    if(s[pos] == '+') return solve(a)+solve(b);\n    else if(s[pos] == '-') return solve(a)-solve(b);\n    else if(s[pos] == '('){\n\n      if(pos == 0){\n\n\tint par = 1;\n\ta = b = \"\";\n\tint now;\n\n\tfor(int i = 1; i < s.length(); i++){\n\t  if(s[i] == '(') par++;\n\t  if(s[i] == ')') par--;\n\t  a+=s[i];\n\t  if(par == 0){\n\t    now = i+1;\n\t    break;\n\t  }\n\t}\n\n\tif(now == s.length()){\n\t  for(int i = 1; i < s.length()-1; i++)\n\t    b += s[i];\n\n\t  return solve(b);\n\t}\n\n\tfor(int i = now+1; i < s.length(); i++)\n\t  b+=s[i];\n\n\tif(s[now] == '+') return solve(a)+solve(b);\n\tif(s[now] == '-') return solve(a)-solve(b);\n\tif(s[now] == '*') return solve(a)*solve(b);\n\tif(s[now] == '/') return solve(a)/solve(b);\n\t\n\n\n      }else{\n\ta = b = \"\";\n\n\tfor(int i = 0; i < pos-1; i++)\n\t  a+=s[i];\n\n\tfor(int i = pos; i < s.length(); i++)\n\t  b+=s[i];\n\n\tif(s[pos-1] == '+') return solve(a)+solve(b);\n\tif(s[pos-1] == '-') return solve(a)-solve(b);\n\tif(s[pos-1] == '*') return solve(a)*solve(b);\n\tif(s[pos-1] == '/') return solve(a)/solve(b);\n       \n      }\n    }\n  }\n\n}\n\nstring make(string s){\n  string out = \"\";\n\n  for(int i = 0; i < s.length()-1; i++)\n    out += s[i];\n\n  return out;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> str;\n    str = make(str);\n    cout << solve(str) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define EPS 1e-10\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\n\nbool isLeap(int y);\nll gcd(ll a, ll b);\nll lcm(ll a, ll b);\ndouble distanceAB(double xa, double ya, double xb, double yb);\nvoid trace(int A[], int N);\n\n/*\nclass Target\n{\npublic:\n\tvector <string> draw(int n)\n\t{\n\n\t}\n};\n*/\n\n\nint expr();\nint term();\nint fact();\n\nchar buf[101];\nint p;\n\nint expr()\n{\n\tint v = term();\n\twhile (buf[p] == '+' || buf[p] == '-')\n\t{\n\t\tif (buf[p] == '+')\n\t\t{\n\t\t\tp++;\n\t\t\tv += term();\n\t\t} else {\n\t\t\tp++;\n\t\t\tv -= term();\n\t\t}\n\t}\n\treturn v;\n}\n\nint term()\n{\n\tint v = fact();\n\twhile (buf[p] == '*' || buf[p] == '/')\n\t{\n\t\tif (buf[p] == '*')\n\t\t{\n\t\t\tp++;\n\t\t\tv *= fact();\n\t\t} else {\n\t\t\tp++;\n\t\t\tv /= fact();\n\t\t}\n\t}\n\treturn v;\n}\n\nint fact()\n{\n\tint v = 0;\n\tif (buf[p] == '(')\n\t{\n\t\tp++;\n\t\tv = expr();\n\t\tp++;\n\t} else {\n\t\twhile (isdigit(buf[p]))\n\t\t{\n\t\t\tv = v * 10 + buf[p] - '0';\n\t\t\tp++;\n\t\t}\n\t}\n\treturn v;\n}\n\n\nint main()\n{\n\tint times, ans;\n\t\n\tcin >> times;\n\trep(i, times)\n\t{\n\t\tcin >> buf;\n\t\tp = 0;\n\t\tans = expr();\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n\nbool isLeap(int y)\n{\n\treturn y % 400 == 0\n\t\t\t\t\t\t? true : y % 100 == 0\n\t\t\t\t\t\t? false : y % 4 == 0\n\t\t\t\t\t\t? true : false;\n}\n\nll gcd(ll a, ll b)\n{\n\treturn (b > 0) ? gcd(b, a % b) : a;\n}\n\nll lcm(ll a, ll b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nvoid trace(int A[], int N)\n{\n\tREP(N)\n\t{\n\t\tif (i > 0) cout << \" \";\n\t\tcout << A[i];\n\t}\n\tcout << endl;\n}\n\ndouble distanceAB(double xa, double ya, double xb, double yb)\n{\n\treturn sqrt((xb-xa)*(xb-xa) + (yb-ya)*(yb-ya));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint main(){\n\n\tint n,tmp,op1,work,count;\n\tchar line[101],calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG,negFLG;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%s\",line);\n\n\t\ttmp = 0;\n\t\tnumFLG = false;\n\t\tnegFLG = false;\n\n\t\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t\t}else{\n\n\t\t\t\tif(numFLG == true){\n\n\t\t\t\t\tif(negFLG){\n\t\t\t\t\t\ttmp = -1*tmp;\n\t\t\t\t\t\tnegFLG = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(OP.empty() == false && (OP.top() == '*' || OP.top() == '/')){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tNUM.push(tmp*op1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tNUM.push(op1/tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tnumFLG = false;\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\n\t\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == '/' || line[k] == '('){\n\t\t\t\t\tOP.push(line[k]);\n\t\t\t\t}else if(line[k] == '-'){\n\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else if(k > 0 && (line[k-1] == '+' || line[k-1] == '-' || line[k-1] == '*' || line[k-1] == '/' || line[k-1] == '(')){\n\t\t\t\t\t\tnegFLG = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tOP.push('-');\n\t\t\t\t\t}\n\n\t\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(count == 0){\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\twork = work_num.top();\n\t\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tNUM.push(work);\n\n\t\t\t\t}else{\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\n\t\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\n\t\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\t\twork = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork_num.push(work);\n\t\t\t\t\t}\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork += work_num.top();\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\twork -= work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork *= work_num.top();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twork /= work_num.top();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"%d\\n\",work);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <cstdlib>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint str2arr(char s[], string A[]) {\n    bool flag = true;\n    string t;\n    int l = strlen(s);\n    int i, n = 0;\n    for (i = 0; i < l; i++) {\n        if (isdigit(s[i]) && flag) {\n            t = \"\";\n            int j = 0;\n            while (isdigit(s[i + j])) {\n                t += s[i + j];\n                if (i + j == l - 1)\n                    break;\n                j++;\n            }\n            A[n++] = t;\n            flag = false;\n        }\n        else if (!isdigit(s[i])) {\n            A[n++] = s[i];\n            flag = true;\n        }\n    }\n    return n;\n}\n\nint Generate_RPN(int n, string A[], string B[]) {\n    map<string, int> table;\n    table[\"*\"] = 1;\n    table[\"/\"] = 1;\n    table[\"+\"] = 0;\n    table[\"-\"] = 0;\n    table[\"(\"] = -1;\n    table[\")\"] = -1;\n    stack<string> S;\n    int j = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (isdigit(A[i][0])) {\n            B[j++] = A[i];\n        }\n\n        else if (A[i] == \"(\")\n            S.push(A[i]);\n\n        else if (A[i] == \")\") {\n            while (S.top() != \"(\") {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.pop();\n        }\n        else {\n            while ((!S.empty()) && (table[S.top()] >= table[A[i]])) {\n                B[j++] = S.top();\n                S.pop();\n            }\n            S.push(A[i]);\n        }\n    }\n    while (!S.empty()) {\n        B[j++] = S.top();\n        S.pop();\n    }\n    return j;\n}\n\nvoid calculate(int n, string s[]) {\n    stack<double> St;\n    double a, b;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == \"+\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"-\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a+b);\n        }\n        else if (s[i] == \"*\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a*b);\n        }\n        else if (s[i] == \"/\") {\n            b = St.top(); St.pop();\n            a = St.top(); St.pop();\n            St.push(a/b);\n        }\n        else {\n            St.push(atoi(s[i].c_str()));\n        }\n    }\n    cout << int(St.top()) << endl;\n}\n\nint main()\n{\n    int n, l, t;\n    string A[101], B[101];\n    char s[101];\n\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++) {\n        s[0] = '\\0';\n        scanf(\"%s\", s);\n        s[strlen(s)-1] = '\\0'; //????°????=?????????\n\n        l = str2arr(s, A);\n        t = Generate_RPN(l, A, B);\n\n        calculate(t, B);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "-- ?????????\n-- http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109\n\nimport Control.Monad\n\ndata Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show\n\nmylex :: String -> [String]\nmylex xs = case head (lex xs) of\n    ([] , []) -> []\n    (x , y) -> x : mylex y\n\nparse_factor :: [String] -> (Tree Int , [String])\nparse_factor (\"(\":xs) = case parse_expr xs of\n    (t , \")\" : rest) -> (t , rest)\n    (_ , _) -> error \"'(' is not closed.\"\nparse_factor (x:xs) = (Leaf $ read x , xs) -- number ?\nparse_factor [] = error \"The empty string is not an expression.\"\n\nparse_term :: [String] -> (Tree Int , [String])\nparse_term xs = case parse_factor xs of\n    (t , rest) -> parse_term' t rest\n\nparse_term' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_term' t (\"*\":xs) = let rest' = parse_factor xs in parse_term' (Branch '*' t (fst rest')) (snd rest')\nparse_term' t (\"/\":xs) = let rest' = parse_factor xs in parse_term' (Branch '/' t (fst rest')) (snd rest')\nparse_term' t xs = (t , xs)\n\nparse_expr :: [String] -> (Tree Int , [String])\nparse_expr xs = case parse_term xs of\n    (t , rest) -> parse_expr' t rest\n\nparse_expr' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_expr' t (\"+\":xs) = let rest' = parse_term xs in parse_expr' (Branch '+' t (fst rest')) (snd rest')\nparse_expr' t (\"-\":xs) = let rest' = parse_term xs in parse_expr' (Branch '-' t (fst rest')) (snd rest')\nparse_expr' t xs = (t , xs)\n\nparse :: [String] -> Tree Int\nparse xs = case parse_expr xs of\n    (t , [\"=\"]) -> t\n    (_ , []) -> error $ \"The end of expression must be '='\"\n    (_ , ys) -> error $ \"failed to parse. \" ++ show ys\n\ncalc :: Tree Int -> Int\ncalc (Leaf x) = x\ncalc (Branch '+' x y) = calc x + calc y\ncalc (Branch '-' x y) = calc x - calc y\ncalc (Branch '*' x y) = calc x * calc y\ncalc (Branch '/' x y) = calc x `div` calc y\ncalc (Branch op _ _) = error $ \"unknown operator '\" ++ [op] ++ \"'.\"\n\nsolve :: String -> IO ()\nsolve s = -- print t >> \n    print (calc t)\n    where t = parse $ mylex s\n\nmain :: IO ()\nmain = readLn\n    >>= (\\ n -> replicateM n getLine)\n    >>= mapM_ solve"
  },
  {
    "language": "Haskell",
    "code": "import Data.Char\nimport Control.Monad\nimport Debug.Trace\n\nfindChar :: Char -> String -> String\nfindChar c (x:xs) = if c==x then [x] else x:findChar c xs\n\nfindChar2 :: Char -> String -> (String,String)\nfindChar2 c str = (init resstr, drop len str)\n    where resstr = findChar c str\n          len = length resstr\n\nfindCharRev :: Char -> String -> String\nfindCharRev c str = reverse $ drop len (c:rstr)\n    where rstr = reverse str\n          len = length $ findChar c rstr\n\nisDigitS :: String -> Bool\nisDigitS (x:xs) = if x=='-' then isDigitS xs else and $ map isDigit (x:xs)\n\nevalDigit :: String -> Int\nevalDigit (x:xs) = if x=='-' then (-1)*(evalDigit xs) else read (x:xs) :: Int\n\nevalOp :: (Int->Int->Int)->Char->String->Int\nevalOp op opc expr = op (evalExpr expr1) (evalExpr expr2)\n    where (expr1, expr2) = findChar2 opc expr\n\nevalPrnt :: String -> Int\nevalPrnt expr = evalExpr $ expr1++(show $ evalExpr ('(':expr2))\n    where (expr1, expr2) = findChar2 '(' expr\n\nevalExpr :: String -> Int\nevalExpr (x:xs)\n    | x=='('          = evalExpr $ init $ findCharRev ')' xs\n    | isDigitS (x:xs) = evalDigit (x:xs)\n    | otherwise       = \n        if      elem '(' (x:xs) then evalPrnt (x:xs)\n        else if elem '+' (x:xs) then evalOp (+) '+' (x:xs)\n        else if elem '-' (x:xs) then evalOp (-) '-' (x:xs)\n        else if elem '*' (x:xs) then evalOp (*) '*' (x:xs)\n        else if elem '/' (x:xs) then evalOp div '/' (x:xs)\n        else error \"Error\"\n\nsolve :: String -> Int\nsolve expr = evalExpr $ takeWhile (\\c->c/='=') expr\n\nmain = do\n    n <- readLn\n    l_expr <- replicateM n getLine\n    mapM_ print $ map (solve)  l_expr\n \n    "
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative((<$>))\nimport Control.Monad\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\ngetInt     = readInt <$> getLine\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\n-- solver ss = floor.calc.fst $ expr ss id\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `div` calc b\n-- calc (Node a '/' b) = calc a / calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1*4*3/2)-1=\",\"1-(6/1000000000*1000000000)\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\n\ndata Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show\n\nmylex :: String -> [String]\nmylex xs = case head (lex xs) of\n    ([] , []) -> []\n    (x , y) -> x : mylex y\n\nparse_factor :: [String] -> (Tree Int , [String])\nparse_factor (\"(\":xs) = case parse_expr xs of\n    (t , \")\" : rest) -> (t , rest)\n    (_ , _) -> error \"'(' is not closed.\"\nparse_factor (x:xs) = (Leaf $ read x , xs) -- number ?\nparse_factor [] = error \"The empty string is not an expression.\"\n\nparse_term :: [String] -> (Tree Int , [String])\nparse_term xs = case parse_factor xs of\n    (t , rest) -> parse_term' t rest\n\nparse_term' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_term' t (\"*\":xs) = let rest' = parse_factor xs in parse_term' (Branch '*' t (fst rest')) (snd rest')\nparse_term' t (\"/\":xs) = let rest' = parse_factor xs in parse_term' (Branch '/' t (fst rest')) (snd rest')\nparse_term' t xs = (t , xs) -- ????????\\??????\n\nparse_expr :: [String] -> (Tree Int , [String])\nparse_expr xs = case parse_term xs of\n    (t , rest) -> parse_expr' t rest\n\nparse_expr' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_expr' t (\"+\":xs) = let rest' = parse_term xs in parse_expr' (Branch '+' t (fst rest')) (snd rest')\nparse_expr' t (\"-\":xs) = let rest' = parse_term xs in parse_expr' (Branch '-' t (fst rest')) (snd rest')\nparse_expr' t xs = (t , xs) -- ????????\\??????\n\nparse :: [String] -> Tree Int\nparse xs = case parse_expr xs of\n    (t,[\"=\"]) -> t\n    (_,ys) -> error $ \"failed to parse. \" ++ show ys\n\ncalc :: Tree Int -> Int\ncalc (Leaf x) = x\ncalc (Branch '+' x y) = calc x + calc y\ncalc (Branch '-' x y) = calc x - calc y\ncalc (Branch '*' x y) = calc x * calc y\ncalc (Branch '/' x y) = calc x `div` calc y\ncalc (Branch op _ _) = error $ \"unknown operator '\" ++ [op] ++ \"'.\"\n\nsolve :: String -> IO ()\nsolve s = if null s then return () else (print . calc . parse . mylex) s\n-- solve s = print t >> print (calc t)\n--    where t = parse $ mylex s\n\nmain :: IO ()\nmain = readLn\n    >>= (\\ n -> replicateM n getLine)\n    >>= mapM_ solve"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Float | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = floor.calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\n-- calc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '/' b) = calc a / calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\",\"1-(6/1000000000*1000000000)\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "data Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show\n\nmylex :: String -> [String]\nmylex xs = case head (lex xs) of\n    ([] , []) -> []\n    (x , y) -> x : mylex y\n\nparse_factor :: [String] -> (Tree Int , [String])\nparse_factor (\"(\":xs) = case parse_expr xs of\n    (t , \")\" : rest) -> (t , rest)\n    (_ , _) -> error \"'(' is not closed.\"\nparse_factor (x:xs) = (Leaf $ read x , xs) -- number ?\nparse_factor [] = error \"The empty string is not an expression.\"\n\nparse_term :: [String] -> (Tree Int , [String])\nparse_term xs = case parse_factor xs of\n    (t , rest) -> parse_term' t rest\n\nparse_term' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_term' t (\"*\":xs) = let rest' = parse_factor xs in parse_term' (Branch '*' t (fst rest')) (snd rest')\nparse_term' t (\"/\":xs) = let rest' = parse_factor xs in parse_term' (Branch '/' t (fst rest')) (snd rest')\nparse_term' t xs = (t , xs) -- ????????\\??????\n\nparse_expr :: [String] -> (Tree Int , [String])\nparse_expr xs = case parse_term xs of\n    (t , rest) -> parse_expr' t rest\n\nparse_expr' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_expr' t (\"+\":xs) = let rest' = parse_term xs in parse_expr' (Branch '+' t (fst rest')) (snd rest')\nparse_expr' t (\"-\":xs) = let rest' = parse_term xs in parse_expr' (Branch '-' t (fst rest')) (snd rest')\nparse_expr' t xs = (t , xs) -- ????????\\??????\n\nparse :: [String] -> Tree Int\nparse xs = case parse_expr xs of\n    (t,[\"=\"]) -> t\n    (_,ys) -> error $ \"failed to parse. \" ++ show ys\n\ncalc :: Tree Int -> Int\ncalc (Leaf x) = x\ncalc (Branch '+' x y) = calc x + calc y\ncalc (Branch '-' x y) = calc x - calc y\ncalc (Branch '*' x y) = calc x * calc y\ncalc (Branch '/' x y) = calc x `div` calc y\ncalc (Branch op _ _) = error $ \"unknown operator '\" ++ [op] ++ \"'.\"\n\nsolve :: String -> IO ()\nsolve = print . calc . parse . mylex\n-- solve s = print t >> print (calc t)\n--    where t = parse $ mylex s\n\nmain :: IO ()\nmain = getLine\n    >> getContents\n    >>= mapM_ solve . lines"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>), (*>), (<*))\nimport Control.Monad\nimport Data.List\nimport Text.Parsec\nimport Text.Parsec.String\n\nmain :: IO ()\nmain = do\n  n <- getl toInt\n  map solve <$> replicateM n getLine >>= mapM_ print\n\nsolve :: String -> Int\nsolve cs = either (const 0) id $ parse (kagen <* char '=') \"\" cs\n\ntoInt :: String -> Int\ntoInt = read\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine\n\nnum :: Parser Int\nnum = read <$> many1 digit\n\njoujo :: Parser Int\njoujo = do\n  x <- numpar\n  fs <- many (muldiv <$> (char '*' <|> char '/') <*> numpar)\n  return $ foldl (flip ($)) x fs\n\nmuldiv :: Char -> Int -> Int -> Int\nmuldiv op x\n  | op == '*' = (* x)\n  | otherwise = (`div` x)\n\nkagen :: Parser Int\nkagen = do\n  x <- joujo\n  fs <- many (addsub <$> (char '+' <|> char '-') <*> joujo)\n  return $ foldl (flip ($)) x fs\n\naddsub :: Char -> Int -> Int -> Int\naddsub op x\n  | op == '+' = (+ x)\n  | otherwise = subtract x\n                \nnumpar :: Parser Int\nnumpar = num <|> (char '(' *> kagen <* char ')')"
  },
  {
    "language": "Haskell",
    "code": "gets.to_i.times{puts eval(gets.chomp[0...-1])}"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nmain = do\n    n <- readLn\n    formulas <- fmap init $ replicateM n getLine\n    mapM_ print $ map calcForm formulas\n\ndata Tree a =  Leaf a | Node a (Tree a) (Tree a) deriving Show\nisLeaf :: Tree a -> Bool\nisLeaf x = case x of\n             Leaf _ -> True\n             otherwise -> False\n\ncalcForm :: String -> Int\ncalcForm str = calcTree.divCalcTree $ Leaf str\n\ncalcTree :: Tree String -> Int\ncalcTree (Leaf a)            = read a\ncalcTree (Node c left right) = calc c (calcTree left) (calcTree right)\n\ncalc c l r\n    | c == \"/\" = l `div` r\n    | c == \"*\" = l * r\n    | c == \"-\" = l - r\n    | c == \"+\" = l + r\n\ndivCalcTree :: Tree String -> Tree String\ndivCalcTree (Leaf str)\n  | check '(' str = calcInParenthesis str\n  | check '+' str = sepBy '+' str\n  | check '-' str = sepBy '-' str\n  | check '*' str = sepBy '*' str\n  | check '/' str = sepBy '/' str\n  | otherwise     = Leaf str\n\nsepBy :: Char -> String -> Tree String\nsepBy c str = Node [c] (divCalcTree left) (divCalcTree right)\n    where\n        left = Leaf $ takeWhile (/= c) str\n        right = Leaf $ tail.dropWhile (/= c) $ str\n\ncalcInParenthesis str = divCalcTree (Leaf calcedStr)\n    where calcedStr = takeWhile (/= '(') str ++ (show.calcForm $ inParen) ++ (tail.dropWhile (/= ')') $ str)\n          inParen   = takeWhile (/= ')').tail.dropWhile (/= '(') $ str\n\ncheck :: Char -> String -> Bool\ncheck c str = c `elem` str"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\n\ndata Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show\n\nmylex :: String -> [String]\nmylex xs = case head (lex xs) of\n    ([] , []) -> []\n    (x , y) -> x : mylex y\n\nparse_factor :: [String] -> (Tree Int , [String])\nparse_factor (\"(\":xs) = case parse_expr xs of\n    (t , \")\" : rest) -> (t , rest)\n    (_ , _) -> error \"'(' is not closed.\"\nparse_factor (x:xs) = (Leaf $ read x , xs) -- number ?\nparse_factor [] = error \"The empty string is not an expression.\"\n\nparse_term :: [String] -> (Tree Int , [String])\nparse_term xs = case parse_factor xs of\n    (t , rest) -> parse_term' t rest\n\nparse_term' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_term' t (\"*\":xs) = let rest' = parse_factor xs in parse_term' (Branch '*' t (fst rest')) (snd rest')\nparse_term' t (\"/\":xs) = let rest' = parse_factor xs in parse_term' (Branch '/' t (fst rest')) (snd rest')\nparse_term' t xs = (t , xs) -- ????????\\??????\n\nparse_expr :: [String] -> (Tree Int , [String])\nparse_expr xs = case parse_term xs of\n    (t , rest) -> parse_expr' t rest\n\nparse_expr' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_expr' t (\"+\":xs) = let rest' = parse_term xs in parse_expr' (Branch '+' t (fst rest')) (snd rest')\nparse_expr' t (\"-\":xs) = let rest' = parse_term xs in parse_expr' (Branch '-' t (fst rest')) (snd rest')\nparse_expr' t xs = (t , xs) -- ????????\\??????\n\nparse :: [String] -> Tree Int\nparse xs = case parse_expr xs of\n    (t,[\"=\"]) -> t\n    (_,ys) -> error $ \"failed to parse. \" ++ show ys\n\ncalc :: Tree Int -> Int\ncalc (Leaf x) = x\ncalc (Branch '+' x y) = calc x + calc y\ncalc (Branch '-' x y) = calc x - calc y\ncalc (Branch '*' x y) = calc x * calc y\ncalc (Branch '/' x y) = calc x `div` calc y\ncalc (Branch op _ _) = error $ \"unknown operator '\" ++ [op] ++ \"'.\"\n\nsolve :: String -> IO ()\nsolve = print . calc . parse . mylex\n-- solve s = print t >> print (calc t)\n--    where t = parse $ mylex s\n\nmain :: IO ()\nmain = readLn\n    >>= (\\ n -> replicateM n getLine)\n    >>= mapM_ solve"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative((<$>))\nimport Control.Monad\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\ngetInt     = readInt <$> getLine\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\n-- solver ss = floor.calc.fst $ expr ss id\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `quot` calc b\n-- calc (Node a '/' b) = calc a / calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1*4*3/2)-1=\",\"1-(6/1000000000*1000000000)\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Data.Char\nimport Control.Monad\n\nexpression :: String->(String,Int)\nexpression expr = expression' $ term expr\n\nexpression' :: (String,Int)->(String,Int)\nexpression' ([], n) = ([], n)\nexpression' (x:xs, n)\n    | x=='+'    = expression' (expr', n+n')\n    | x=='-'    = expression' (expr', n-n')\n    | otherwise = (x:xs, n)\n        where (expr', n') = term xs\n\nterm :: String->(String,Int)\nterm expr = term' $ factor expr\n\nterm' :: (String,Int)->(String,Int)\nterm' ([], n) = ([], n)\nterm' (x:xs, n)\n    | x=='*'     = term' (expr', n*n')\n    | x=='/'     = term' (expr', n`div`n')\n    | otherwise  = (x:xs, n)\n        where (expr', n') = factor xs\n\nfactor :: String->(String, Int)\nfactor (x:xs)\n    | x=='('    = (tail $ expr1, n1) --ignore ')'\n    | otherwise = (expr2, n2)\n        where (expr1, n1) = expression xs --ignore '('\n              (expr2, n2) = number (x:xs, 0)\n\nnumber :: (String, Int)->(String, Int)\nnumber ([], n)   = ([], n)\nnumber (x:xs, n) = if isDigit x then number (xs, n*10+(digitToInt x)) else (x:xs, n)\n\nsolve :: String->IO ()\nsolve expr = do\n    print (snd $ expression $ takeWhile (/='=') expr)\n\nmain :: IO ()\nmain = do\n    n <- readLn\n    lexpr <- replicateM n getLine\n    mapM_ solve lexpr"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nmain = do\n    n <- readLn\n    formulas <- fmap init $ replicateM n getLine\n    mapM_ print $ map calcForm formulas\n\ndata Tree a =  Leaf a | Node a (Tree a) (Tree a) deriving Show\nisLeaf :: Tree a -> Bool\nisLeaf x = case x of\n             Leaf _ -> True\n             otherwise -> False\n\ncalcForm :: String -> Int\ncalcForm str = calcTree.divCalcTree $ str\n\ncalcTree :: Tree String -> Int\ncalcTree (Leaf a)            = read a\ncalcTree (Node c left right) = calc c (calcTree left) (calcTree right)\n\ncalc c l r\n    | c == \"/\" = l `div` r\n    | c == \"*\" = l * r\n    | c == \"-\" = l - r\n    | c == \"+\" = l + r\n\ndivCalcTree :: String -> Tree String\ndivCalcTree str\n  | check '(' str = divCalcTree $ calcInParenthesis str\n  | check '+' str = sepBy '+' str\n  | check '-' str = sepBy '-' str\n  | check '*' str = sepBy '*' str\n  | check '/' str = sepBy '/' str\n  | otherwise     = Leaf str\n\nsepBy :: Char -> String -> Tree String\nsepBy c str = Node [c] (divCalcTree left) (divCalcTree right)\n    where\n        left = takeWhile (/= c) str\n        right = tail.dropWhile (/= c) $ str\n\ncalcInParenthesis :: String -> String\ncalcInParenthesis str = if '(' `elem` str then calcInParenthesis calcedStr\n                                          else str\n                                              where\n                                                  calcedStr = before ++ (show.calcForm $ mid) ++ after\n                                                  ([before,after],mid) = cutParen str\n\ncutParen :: String -> ([String], String)\ncutParen str = ([before,after],init mid)\n    where\n        (before, next) = span (/= '(') str\n        (mid,after)    = betweenParen next\n\nbetweenParen :: String -> (String, String)\nbetweenParen str = between  [] 1 (tail str)\n--    where\nbetween list n str\n  | n == 0          = (reverse list, str)\n  | head str == '(' = between ((head str):list) (n+1) (tail str)\n  | head str == ')' = between ((head str):list) (n-1) (tail str)\n  | otherwise       = between ((head str):list) n (tail str)\n\n\ncheck :: Char -> String -> Bool\ncheck c str = c `elem` str"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\n\nimport Text.Parsec (parse, many1, digit, char)\nimport Text.Parsec.String\n\n-- import Test.HUnit\n\nmain :: IO ()\n-- main = runTestTT (TestList tests) >> return ()\nmain = do\n  n <- readLn\n  map solve <$> replicateM n (init <$> getLine) >>= mapM_ print\n\nsolve :: String -> Int\nsolve = either (const 0) id . parse expr \"\"\n\nnum :: Parser Int\nnum = read <$> many1 digit\n\nfact :: Parser Int\nfact = do\n  sgn <- negate <$ char '-' <|> id <$ char '+' <|> return id\n  sgn <$> (num <|> char '(' *> expr <* char ')')\n\nterm :: Parser Int\nterm = do\n  f1 <- fact\n  ops <- many $ do\n    op <- flip (*) <$ char '*' <|> flip quot <$ char '/'\n    op <$> fact\n  return $ foldl' (flip ($)) f1 ops\n\nexpr :: Parser Int\nexpr = do\n  t1 <- term\n  ops <- many $ do\n    op <- flip (+) <$ char '+' <|> flip (-) <$ char '-'\n    op <$> term\n  return $ foldl' (flip ($)) t1 ops\n  \n-- tests :: [Test]\n-- tests = map f [\n--   (\"num1\", parse num \"\" \"00234\", Right 234),\n--   (\"term1\", parse term \"\" \"23\", Right 23),\n--   (\"term2\", parse term \"\" \"2*3\", Right 6),\n--   (\"term3\", parse term \"\" \"7/3\", Right 2),\n--   (\"term4\", parse term \"\" \"23*43/124\", Right 7),\n--   (\"term5\", parse term \"\" \"352345/89/38\", Right 104),\n--   (\"expr1\", parse expr \"\" \"345\", Right 345),\n--   (\"expr2\", parse expr \"\" \"4*3*5/12\", Right 5),\n--   (\"expr3\", parse expr \"\" \"2+3-1\", Right 4),\n--   (\"expr4\", parse expr \"\" \"12-3+5\", Right 14),\n--   (\"expr5\", parse expr \"\" \"2*3*3-12/3*2+5*8/2\", Right 30),\n--   (\"fact1\", parse fact \"\" \"(3+5*2)\", Right 13),\n--   (\"term6\", parse term \"\" \"(3+5*2)*(8-25/5)\", Right 39),\n--   (\"expr6\", parse expr \"\" \"4-2*3\", Right (-2)),\n--   (\"expr7\", parse expr \"\" \"4*(8+4+3)\", Right 60),\n--   (\"expr8\", parse expr \"\" \"-3*-5+-60/5\", Right 3),\n--   (\"fact2\", parse fact \"\" \"34\", Right 34),\n--   (\"fact3\", parse fact \"\" \"+45\", Right 45),\n--   (\"fact4\", parse fact \"\" \"-567\", Right (-567)),\n--   (\"fact5\", parse expr \"\" \"(-99)/4\", Right (-24)),\n--   (\"fact6\", parse expr \"\" \"-5++8*(23+4-2*3)-(-(35-2)*3)/4\", Right 187)\n--   ]\n--   where \n--     f (ms, rv, ev) = ms ~: rv ~?= ev\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Float | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = floor.calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\n-- calc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '/' b) = calc a / calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\",\"1-(6/1000000000*1000000000)\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\ndata Token = TNum Int | TAdd | TSub | TMul | TDiv | TOpen | TClose | TEnd deriving (Show, Eq)\n\ntokenize :: String -> [Token]\ntokenize [] = []\ntokenize s@(c:cs) = case c of\n    '=' -> [TEnd]\n    '(' -> TOpen : tokenize cs\n    ')' -> TClose : tokenize cs\n    '+' -> TAdd : tokenize cs\n    '-' -> TSub : tokenize cs\n    '*' -> TMul : tokenize cs\n    '/' -> TDiv : tokenize cs\n    _ -> let (n, r) = readNum s in TNum n : tokenize r\n  where\n    readNum :: String -> (Int, String)\n    readNum s = readNum' 0 s\n    readNum' x s@(c:cs)\n      | isDigit c = readNum' (10*x+digitToInt c) cs\n      | otherwise = (x, s)\n\ncalc :: [Token] -> Int\ncalc ts = fst $ calc' ts\ncalc' ts@(TNum _:_) = f 0 (+) 1 (*) ts\ncalc' ts = f 0 (+) 0 (*) ts\nf :: Int -> (Int -> Int -> Int) -> Int -> (Int -> Int -> Int) -> [Token] -> (Int, [Token])\nf n nop m mop (TEnd:ts) = (nop n m, ts)\nf n nop m mop (TClose:ts) = (nop n m, ts)\nf n nop m mop (TOpen:ts) = let (x, r) = calc' ts in f n nop (mop m x) mop r\nf n nop m mop (TAdd:ts) = f (nop n m) (+) 1 (*) ts\nf n nop m mop (TSub:ts) = f (nop n m) (-) 1 (*) ts\nf n nop m mop (TMul:ts) = f n nop m (*) ts\nf n nop m mop (TDiv:ts) = f n nop m div ts\nf n nop m mop (TNum x:ts) = f n nop (mop m x) mop ts \n\n\nmain = getInt >>= flip replicateM getLine >>= mapM_ (print . calc . tokenize)\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Char\nimport Data.List\nimport Debug.Trace\nimport Control.Monad\n\nfindPrnth n depth (x:xs)\n    | x==\")\"    = if depth==0 then n else findPrnth (n+1) (depth-1) xs\n    | x==\"(\"    = findPrnth (n+1) (depth+1) xs\n    | otherwise = findPrnth (n+1) depth xs\n\ncrrspPrnth expr = (take i expr, drop (i+1) expr)\n    where i = findPrnth 0 0 expr\n\nisDigitS :: String -> Bool\nisDigitS expr = and $ map isDigit expr\n\ndata Op = Plus | Minus | Mult |Divide deriving (Eq, Ord, Show)\ndata Tree =  Empty | Leaf Int | Parentheses Tree | Node Op Tree Tree deriving (Eq, Show)\n\nparseExpr :: [String] -> Tree -> Tree\nparseExpr [] tree = tree\nparseExpr (x:xs) tree\n    | isDigitS x = parseExpr xs $ number x tree\n    | tree==Empty && x==\"-\" = parseExpr xs $ Node Minus (Leaf 0) Empty\n    | x==\"+\"                = parseExpr xs $ plus tree Plus\n    | x==\"-\"                = parseExpr xs $ plus tree Minus\n    | x==\"*\"                = parseExpr xs $ mult tree Mult\n    | x==\"/\"                = parseExpr xs $ mult tree Divide\n    | x==\"(\"                = parseExpr e2 $ parentheses e1 tree\n    | otherwise             = tree\n        where (e1, e2) = crrspPrnth xs\n\nparentheses :: [String] -> Tree -> Tree\nparentheses expr Empty = Parentheses $ parseExpr expr Empty\nparentheses expr (Node op t1 t2)\n    | t2 == Empty = Node op t1 $ Parentheses $ parseExpr expr Empty\n    | otherwise   = Node op t1 $ parentheses expr t2\n\nnumber :: String -> Tree -> Tree\nnumber x Empty = Leaf $ (read x :: Int)\nnumber x (Node o t1 t2)\n    | t2 == Empty = Node o t1 (Leaf $ (read x :: Int))\n    | otherwise   = Node o t1 $ number x t2\n\nplus :: Tree -> Op -> Tree\nplus tree o = Node o tree Empty\n\nmult :: Tree -> Op -> Tree\nmult (Leaf t2) op = Node op (Leaf t2) Empty\nmult (Parentheses t2) op = Node op (Parentheses t2) Empty\nmult (Node op1 t1 t2) op2 \n    | op1 == Plus || op1 == Minus  = Node op1 t1 $ mult t2 op2\n    | op1 == Mult || op1 == Divide = Node op2 (Node op1 t1 t2) Empty\n\ntokens :: String -> [String]\ntokens \"\" = []\ntokens (x:xs) \n    | elem x ['+','-','*','/','(',')'] = [x]:(tokens xs)\n    | otherwise                        = dig:(tokens $ drop len (x:xs))\n        where dig = takeWhile isDigit (x:xs)\n              len = length dig\n\nevalExpr :: Tree -> Int\nevalExpr (Leaf t) = t\nevalExpr (Parentheses t) = evalExpr t\nevalExpr (Node o t1 t2) \n    | o == Plus   = v1 + v2\n    | o == Minus  = v1 - v2\n    | o == Mult   = v1 * v2\n    | o == Divide = v1 `div` v2\n        where v1 = evalExpr t1\n              v2 = evalExpr t2\n\nsolve expr = do\n    let expr' = takeWhile (\\c->c/='=') expr\n    let tkn = tokens expr'\n    let tree = parseExpr tkn Empty\n    let val = evalExpr tree\n    print val\n\nmain :: IO ()\nmain = do\n    n <- readLn\n    lexpr <- replicateM n getLine\n    mapM_ solve lexpr"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\ndata Token = TNum Int | TAdd | TSub | TMul | TDiv | TOpen | TClose | TEnd deriving (Show, Eq)\n\ntokenize :: String -> [Token]\ntokenize [] = []\ntokenize s@(c:cs) = case c of\n    '=' -> [TEnd]\n    '(' -> TOpen : tokenize cs\n    ')' -> TClose : tokenize cs\n    '+' -> TAdd : tokenize cs\n    '-' -> TSub : tokenize cs\n    '*' -> TMul : tokenize cs\n    '/' -> TDiv : tokenize cs\n    _ -> let (n, r) = readNum s in TNum n : tokenize r\n  where\n    readNum :: String -> (Int, String)\n    readNum s = readNum' 0 s\n    readNum' x s@(c:cs)\n      | isDigit c = readNum' (10*x+digitToInt c) cs\n      | otherwise = (x, s)\n\ncalc :: [Token] -> Int\ncalc ts = fst $ calc' ts\ncalc' ts@(TNum _:_) = f 0 (+) 1 (*) ts\ncalc' ts = f 0 (+) 0 (*) ts\nf :: Int -> (Int -> Int -> Int) -> Int -> (Int -> Int -> Int) -> [Token] -> (Int, [Token])\nf n nop m mop (TEnd:ts) = (nop n m, ts)\nf n nop m mop (TClose:ts) = (nop n m, ts)\nf n nop m mop (TOpen:ts) = let (x, r) = calc' ts in f n nop (mop m x) mop r\nf n nop m mop (TAdd:ts) = f (nop n m) (+) 1 (*) ts\nf n nop m mop (TSub:ts) = f (nop n m) (-) 1 (*) ts\nf n nop m mop (TMul:ts) = f n nop m (*) ts\nf n nop m mop (TDiv:ts) = f n nop m quot ts\nf n nop m mop (TNum x:ts) = f n nop (mop m x) mop ts \n\n\nmain = getInt >>= flip replicateM getLine >>= mapM_ (print . calc . tokenize)\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nmain = do\n    n <- readLn\n    formulas <- fmap init $ replicateM n getLine\n    mapM_ print $ map calcForm formulas\n\ndata Tree a =  Leaf a | Node a (Tree a) (Tree a) deriving Show\nisLeaf :: Tree a -> Bool\nisLeaf x = case x of\n             Leaf _ -> True\n             otherwise -> False\n\ncalcForm :: String -> Int\ncalcForm str = calcTree.divCalcTree $ str\n\ncalcTree :: Tree String -> Int\ncalcTree (Leaf a)            = read a\ncalcTree (Node c left right) = calc c (calcTree left) (calcTree right)\n\ncalc c l r\n    | c == \"/\" = l `div` r\n    | c == \"*\" = l * r\n    | c == \"-\" = l - r\n    | c == \"+\" = l + r\n\ndivCalcTree :: String -> Tree String\ndivCalcTree str\n  | check '(' str = divCalcTree $ calcInParenthesis str\n  | check '+' str = sepBy '+' str\n  | check '-' str = sepBy '-' str\n  | check '*' str = sepBy '*' str\n  | check '/' str = sepBy '/' str\n  | otherwise     = Leaf str\n\nsepBy :: Char -> String -> Tree String\nsepBy c str = Node [c] (divCalcTree left) (divCalcTree right)\n    where\n        left = takeWhile (/= c) str\n        right = tail.dropWhile (/= c) $ str\n\ncalcInParenthesis :: String -> String\ncalcInParenthesis str = if '(' `elem` str then calcInParenthesis calcedStr\n                                          else str\n                                              where\n                                                  calcedStr = before ++ (show.calcForm $ mid) ++ after\n                                                  ([before,after],mid) = cutParen str\n\ncutParen :: String -> ([String], String)\ncutParen str = ([before,after],init mid)\n    where\n        (before, next) = span (/= '(') str\n        (mid,after)    = betweenParen next\n\nbetweenParen :: String -> (String, String)\nbetweenParen str = between  [] 1 (tail str)\n    where\n        between list n (x:xs)\n          | n == 0 = (reverse list, (x:xs))\n          | x == '(' = between (x:list) (n+1) xs\n          | x == ')' = between (x:list) (n-1) xs\n          | otherwise = between (x:list) n xs\n\n\ncheck :: Char -> String -> Bool\ncheck c str = c `elem` str"
  },
  {
    "language": "Haskell",
    "code": "data Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show\n\nmylex :: String -> [String]\nmylex xs = case head (lex xs) of\n    ([] , []) -> []\n    (x , y) -> x : mylex y\n\nparse_factor :: [String] -> (Tree Int , [String])\nparse_factor (\"(\":xs) = case parse_expr xs of\n    (t , \")\" : rest) -> (t , rest)\n    (_ , _) -> error \"'(' is not closed.\"\nparse_factor (x:xs) = (Leaf $ read x , xs) -- number ?\nparse_factor [] = error \"The empty string is not an expression.\"\n\nparse_term :: [String] -> (Tree Int , [String])\nparse_term xs = case parse_factor xs of\n    (t , rest) -> parse_term' t rest\n\nparse_term' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_term' t (\"*\":xs) = let rest' = parse_factor xs in parse_term' (Branch '*' t (fst rest')) (snd rest')\nparse_term' t (\"/\":xs) = let rest' = parse_factor xs in parse_term' (Branch '/' t (fst rest')) (snd rest')\nparse_term' t xs = (t , xs) -- ????????\\??????\n\nparse_expr :: [String] -> (Tree Int , [String])\nparse_expr xs = case parse_term xs of\n    (t , rest) -> parse_expr' t rest\n\nparse_expr' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_expr' t (\"+\":xs) = let rest' = parse_term xs in parse_expr' (Branch '+' t (fst rest')) (snd rest')\nparse_expr' t (\"-\":xs) = let rest' = parse_term xs in parse_expr' (Branch '-' t (fst rest')) (snd rest')\nparse_expr' t xs = (t , xs) -- ????????\\??????\n\nparse :: [String] -> Tree Int\nparse xs = case parse_expr xs of\n    (t,[\"=\"]) -> t\n    (_,ys) -> error $ \"failed to parse. \" ++ show ys\n\ncalc :: Tree Int -> Int\ncalc (Leaf x) = x\ncalc (Branch '+' x y) = calc x + calc y\ncalc (Branch '-' x y) = calc x - calc y\ncalc (Branch '*' x y) = calc x * calc y\ncalc (Branch '/' x y) = calc x `div` calc y\ncalc (Branch op _ _) = error $ \"unknown operator '\" ++ [op] ++ \"'.\"\n\nsolve :: String -> IO ()\nsolve s = if null s then return () else (print . calc . parse . mylex) s\n-- solve s = print t >> print (calc t)\n--    where t = parse $ mylex s\n\nmain :: IO ()\nmain = getLine\n    >> getContents\n    >>= mapM_ solve . lines"
  },
  {
    "language": "Haskell",
    "code": "data Token = LP | N Int | SO (Int -> Int -> Int) | PO (Int -> Int -> Int) | RP\ndata Branch = LeftBranch | RightBranch\ntype Guide = (Token, Branch, Tree)\ndata Tree = Node Token Tree Tree [Guide] | Leaf Token [Guide]\ninstance Eq Token where\n  LP == LP = True\n  (N _) == (N _) = True\n  (SO _) == (SO _) = True\n  (PO _) == (PO _) = True\n  RP == RP = True\n  _ == _ = False\ninstance Ord Token where\n  LP `compare` LP = EQ\n  LP `compare` _ = GT\n  _ `compare` LP = LT\n  (SO _) `compare` (SO _) = EQ\n  (SO _) `compare` _ = GT\n  _ `compare` (SO _) = LT\n  (PO _) `compare` (PO _) = EQ\n  (PO _) `compare` _ = GT\n  _ `compare` (PO _) = LT\n  (N _) `compare` (N _) = EQ\n  (N _) `compare` _ = GT\n  _ `compare` (N _) = LT\n  RP `compare` RP = EQ\ninstance Show Token where\n  show LP = \"(\"\n  show RP = \")\"\n  show (N n) = (show n)\n  show (SO _) = \"SO\"\n  show (PO _) = \"PO\"\ninstance Show Tree where\n  show (Leaf t g) = replicate (length g) '|' ++ (show t ++ \"\\n\")\n  show n@(Node t _ _ g) = replicate (length g) '|' ++ (show t ++ ('\\n':(show (moveLeft n) ++ show (moveRight n))))\nmoveUp :: Tree -> Tree\nmoveUp n@(Node _ _ _ ((token, branch, other):gr)) = case branch of\n  LeftBranch -> Node token n other gr\n  RightBranch -> Node token other n gr\nmoveUp l@(Leaf _ ((token, branch, other):gr)) = case branch of\n  LeftBranch -> Node token l other gr\n  RightBranch -> Node token other l gr\nmoveUp t = t\nmoveTop :: Tree -> Tree\nmoveTop = moveUpWhile (const True)\nmoveUpWhile :: (Token -> Bool) -> Tree -> Tree\nmoveUpWhile _ n@(Node _ _ _ []) = n\nmoveUpWhile _ l@(Leaf _ []) = l\nmoveUpWhile f n@(Node t _ _ _)\n  |f t = moveUpWhile f (moveUp n)\n  |otherwise = n\nmoveUpWhile f l@(Leaf t _)\n  |f t = moveUpWhile f (moveUp l)\n  |otherwise = l\nfindLast :: (Token -> Bool) -> Tree -> Tree\nfindLast f n@(Node _ _ _ ((t, _, _):_))\n  |f t = findLast f (moveUp n)\n  |otherwise = n\nfindLast f l@(Leaf _ ((t, _, _):_))\n  |f t = findLast f (moveUp l)\n  |otherwise = l\nfindLast _ n = n\nmoveDown :: Branch -> Tree -> Tree\nmoveDown LeftBranch (Node t (Node token left right _) r g) = Node token left right ((t, LeftBranch, r):g)\nmoveDown RightBranch (Node t l (Node token left right _) g) = Node token left right ((t, RightBranch, l):g)\nmoveDown LeftBranch (Node t (Leaf token _) r g) = Leaf token ((t, LeftBranch, r):g)\nmoveDown RightBranch (Node t l (Leaf token _) g) = Leaf token ((t, RightBranch, l):g)\nmoveDown _ _ = error \"error: Can't move down\"\nmoveLeft :: Tree -> Tree\nmoveLeft n@(Node {}) = moveDown LeftBranch n\nmoveLeft _ = error \"error: Can't move Left\"\nmoveRight :: Tree -> Tree\nmoveRight n@(Node {}) = moveDown RightBranch n\nmoveRight _ = error \"error: Can't move Right\"\nmoveUpForPO :: Tree -> Tree\nmoveUpForPO = findLast (==(PO (+)))\nmoveUpForSO :: Tree -> Tree\nmoveUpForSO = findLast (<=(SO (+)))\ngetoutPare :: Tree -> Tree\ngetoutPare = moveUpWhile (/=LP)\ninsertNode :: Tree -> Token -> Tree\ninsertNode o@(Node _ _ _ g) t = Leaf RP ((t, RightBranch, o):g)\ninsertNode l@(Leaf _ g) t = Leaf RP ((t, RightBranch, l):g)\nguide :: Tree -> [Guide]\nguide (Leaf _ g) = g\nguide (Node _ _ _ g) = g\nmakeTree :: Tree -> [String] -> Tree\nmakeTree g (\"(\":sr) = makeTree (moveLeft top) sr\n  where\n    top = Node LP (Leaf RP []) (Leaf RP []) (guide g)\nmakeTree g (\")\":\")\":sr) = makeTree (getoutPare g) (\")\":sr)\nmakeTree g (num:\")\":\")\":sr) = makeTree gp (\")\":sr)\n  where\n    gp = getoutPare (Leaf (N (read num :: Int)) (guide g))\nmakeTree g (num:\")\":o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO (div))) sr\n  otherwise -> error \"error: line 89\"\n  where\n    right = getoutPare (Leaf (N (read num :: Int)) (guide g))\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree g (\")\":o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO (div))) sr\n  otherwise -> error \"error: line 99\"\n  where\n    right = getoutPare g\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree g [num, \")\"] = moveTop (Leaf (N (read num :: Int)) (guide g))\nmakeTree g (num:o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO (div))) sr\n  otherwise -> error \"error: line 111\"\n  where\n    right = Leaf (N (read num :: Int)) (guide g)\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree g [\")\"] = moveTop g\nmakeTree g [num] = moveTop (Leaf (N (read num :: Int)) (guide g))\nmakeTree _ _ = error \"error: line 118\"\nsplitAtOperator :: String -> [String]\nsplitAtOperator \"=\" = [[]]\nsplitAtOperator (o:sr)\n  |o == '+' || o == '-' || o == '*' || o == '/' = []:[o]:rest\n  |o == '(' = [o]:rest\n  |o == ')' = []:(o:(head rest)):(tail rest)\n  |otherwise = (o:(head rest)):(tail rest)\n  where\n    rest = splitAtOperator sr\nexpToTree :: String -> Tree\nexpToTree = (makeTree (Leaf RP [])) . splitAtOperator\nculTree :: Tree -> Int\nculTree (Leaf (N n) _) = n\nculTree (Node (SO f) l r _) = f (culTree l) (culTree r)\nculTree (Node (PO f) l r _) = f (culTree l) (culTree r)\nculTree (Node LP l _ _) = culTree l\nculTree _ = error \"error: Can't culcurate expression Tree\"\nsolve :: String -> Int\nsolve = culTree . expToTree\nmain :: IO ()\nmain = do\n  _ <- getLine\n  line <- fmap lines getContents\n  mapM_ (print . solve) line"
  },
  {
    "language": "Haskell",
    "code": "-- ?????????\n-- http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109\n\nimport Control.Monad\n\ndata Tree a = Leaf a | Branch Char (Tree a) (Tree a) deriving Show\n\nmylex :: String -> [String]\nmylex xs = case head (lex xs) of\n    ([] , []) -> []\n    (x , y) -> x : mylex y\n\nparse_factor :: [String] -> (Tree Int , [String])\nparse_factor (\"(\":xs) = case parse_expr xs of\n    (t , \")\" : rest) -> (t , rest)\n    (_ , _) -> error \"'(' is not closed.\"\nparse_factor (\"-\":x:xs) = (Leaf $ negate $ read x , xs) -- number ?\nparse_factor (x:xs) = (Leaf $ read x , xs) -- number ?\nparse_factor [] = error \"The empty string is not an expression.\"\n\nparse_term :: [String] -> (Tree Int , [String])\nparse_term xs = case parse_factor xs of\n    (t , rest) -> parse_term' t rest\n\nparse_term' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_term' t (\"*\":xs) = let rest' = parse_factor xs in parse_term' (Branch '*' t (fst rest')) (snd rest')\nparse_term' t (\"/\":xs) = let rest' = parse_factor xs in parse_term' (Branch '/' t (fst rest')) (snd rest')\nparse_term' t xs = (t , xs)\n\nparse_expr :: [String] -> (Tree Int , [String])\nparse_expr xs = case parse_term xs of\n    (t , rest) -> parse_expr' t rest\n\nparse_expr' :: Tree Int -> [String] -> (Tree Int , [String])\nparse_expr' t (\"+\":xs) = let rest' = parse_term xs in parse_expr' (Branch '+' t (fst rest')) (snd rest')\nparse_expr' t (\"-\":xs) = let rest' = parse_term xs in parse_expr' (Branch '-' t (fst rest')) (snd rest')\nparse_expr' t xs = (t , xs)\n\nparse :: [String] -> Tree Int\nparse xs = case parse_expr xs of\n    (t , [\"=\"]) -> t\n    (_ , []) -> error $ \"The end of expression must be '='\"\n    (_ , ys) -> error $ \"failed to parse. \" ++ show ys\n\ncalc :: Tree Int -> Int\ncalc (Leaf x) = x\ncalc (Branch '+' x y) = calc x + calc y\ncalc (Branch '-' x y) = calc x - calc y\ncalc (Branch '*' x y) = calc x * calc y\ncalc (Branch '/' x y) = calc x `quot` calc y\ncalc (Branch op _ _) = error $ \"unknown operator '\" ++ [op] ++ \"'.\"\n\nsolve :: String -> IO ()\nsolve s = -- print t >> \n    print (calc t)\n    where t = parse $ mylex s\n\nmain :: IO ()\nmain = readLn\n    >>= (\\ n -> replicateM n getLine)\n    >>= mapM_ solve"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\ndata Token = TNum Int | TAdd | TSub | TMul | TDiv | TOpen | TClose | TEnd deriving (Show, Eq)\n\ntokenize :: String -> [Token]\ntokenize [] = []\ntokenize s@(c:cs) = case c of\n    '=' -> [TEnd]\n    '(' -> TOpen : tokenize cs\n    ')' -> TClose : tokenize cs\n    '+' -> TAdd : tokenize cs\n    '-' -> TSub : tokenize cs\n    '*' -> TMul : tokenize cs\n    '/' -> TDiv : tokenize cs\n    _ -> let (n, r) = readNum s in TNum n : tokenize r\n  where\n    readNum :: String -> (Int, String)\n    readNum s = readNum' 0 s\n    readNum' x s@(c:cs)\n      | isDigit c = readNum' (10*x+digitToInt c) cs\n      | otherwise = (x, s)\n\ncalc :: [Token] -> Int\ncalc ts = fst $ f 0 (+) 1 (*) ts\nf :: Int -> (Int -> Int -> Int) -> Int -> (Int -> Int -> Int) -> [Token] -> (Int, [Token])\nf n nop m mop (TEnd:ts) = (nop n m, ts)\nf n nop m mop (TClose:ts) = (nop n m, ts)\nf n nop m mop (TOpen:ts) = let (x, r) = f 0 (+) 1 (*) ts in f n nop (mop m x) mop r\nf n nop m mop (TAdd:ts) = f (nop n m) (+) 1 (*) ts\nf n nop m mop (TSub:ts) = f (nop n m) (-) 1 (*) ts\nf n nop m mop (TMul:ts) = f n nop m (*) ts\nf n nop m mop (TMul:ts) = f n nop m div ts\nf n nop m mop (TNum x:ts) = f n nop (mop m x) mop ts \n\n\nmain = getInt >>= flip replicateM getLine >>= mapM_ (print . calc . tokenize)\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nmain = do\n    n <- readLn\n    formulas <- replicateM n $ fmap init getLine\n    print formulas\n    mapM_ print $ map calcForm formulas\n\ndata Tree a =  Leaf a | Node a (Tree a) (Tree a) deriving Show\nisLeaf :: Tree a -> Bool\nisLeaf x = case x of\n             Leaf _ -> True\n             otherwise -> False\n\ncalcForm :: String -> Int\ncalcForm str = calcTree.divCalcTree $ str\n\ncalcTree :: Tree String -> Int\ncalcTree (Leaf a)            = read a\ncalcTree (Node c left right) = calc c (calcTree left) (calcTree right)\n\ncalc c l r\n    | c == \"/\" = l `div` r\n    | c == \"*\" = l * r\n    | c == \"-\" = l - r\n    | c == \"+\" = l + r\n\ndivCalcTree :: String -> Tree String\ndivCalcTree str\n  | check '(' str = divCalcTree $ calcInParenthesis str\n  | check '+' str = sepBy '+' str\n  | check '-' str = sepBy '-' str\n  | check '*' str = sepBy '*' str\n  | check '/' str = sepBy '/' str\n  | otherwise     = Leaf str\n\nsepBy :: Char -> String -> Tree String\nsepBy c str = Node [c] (divCalcTree left) (divCalcTree right)\n    where\n        left = takeWhile (/= c) str\n        right = tail.dropWhile (/= c) $ str\n\ncalcInParenthesis :: String -> String\ncalcInParenthesis str = if '(' `elem` str then calcInParenthesis calcedStr\n                                          else str\n                                              where\n                                                  calcedStr = before ++ (show.calcForm $ mid) ++ after\n                                                  ([before,after],mid) = cutParen str\n\ncutParen :: String -> ([String], String)\ncutParen str = ([before,after],init mid)\n    where\n        (before, next) = span (/= '(') str\n        (mid,after)    = betweenParen next\n\nbetweenParen :: String -> (String, String)\nbetweenParen str = between  [] 1 (tail str)\n--    where\nbetween list n str\n  | n == 0          = (reverse list, str)\n  | head str == '(' = between ((head str):list) (n+1) (tail str)\n  | head str == ')' = between ((head str):list) (n-1) (tail str)\n  | otherwise       = between ((head str):list) n (tail str)\n\n\ncheck :: Char -> String -> Bool\ncheck c str = c `elem` str"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nmain = do\n    n <- readLn\n    formulas <- replicateM n $ fmap init getLine\n    mapM_ print $ map calcForm formulas\n\ndata Tree a =  Leaf a | Node a (Tree a) (Tree a) deriving Show\nisLeaf :: Tree a -> Bool\nisLeaf x = case x of\n             Leaf _ -> True\n             otherwise -> False\n\ncalcForm :: String -> Int\ncalcForm str = calcTree.divCalcTree $ str\n\ncalcTree :: Tree String -> Int\ncalcTree (Leaf a)            = read a\ncalcTree (Node c left right) = calc c (calcTree left) (calcTree right)\n\ncalc c l r\n    | c == \"/\" = l `div` r\n    | c == \"*\" = l * r\n    | c == \"-\" = l - r\n    | c == \"+\" = l + r\n\ndivCalcTree :: String -> Tree String\ndivCalcTree str\n  | check '(' str = divCalcTree $ calcInParenthesis str\n  | check '+' str = sepBy '+' str\n  | check '-' str = sepBy '-' str\n  | check '*' str = sepBy '*' str\n  | check '/' str = sepBy '/' str\n  | otherwise     = Leaf str\n\nsepBy :: Char -> String -> Tree String\nsepBy c str = Node [c] (divCalcTree left) (divCalcTree right)\n    where\n        left = takeWhile (/= c) str\n        right = tail.dropWhile (/= c) $ str\n\ncalcInParenthesis :: String -> String\ncalcInParenthesis str = if '(' `elem` str then calcInParenthesis calcedStr\n                                          else str\n                                              where\n                                                  calcedStr = before ++ (show.calcForm $ mid) ++ after\n                                                  ([before,after],mid) = cutParen str\n\ncutParen :: String -> ([String], String)\ncutParen str = ([before,after],init mid)\n    where\n        (before, next) = span (/= '(') str\n        (mid,after)    = betweenParen next\n\nbetweenParen :: String -> (String, String)\nbetweenParen str = between  [] 1 (tail str)\n--    where\nbetween list n str\n  | n == 0          = (reverse list, str)\n  | head str == '(' = between ((head str):list) (n+1) (tail str)\n  | head str == ')' = between ((head str):list) (n-1) (tail str)\n  | otherwise       = between ((head str):list) n (tail str)\n\n\ncheck :: Char -> String -> Bool\ncheck c str = c `elem` str"
  },
  {
    "language": "Haskell",
    "code": "data Token = LP | N Int | SO (Int -> Int -> Int) | PO (Int -> Int -> Int) | RP\ndata Branch = LeftBranch | RightBranch\ntype Guide = (Token, Branch, Tree)\ndata Tree = Node Token Tree Tree [Guide] | Leaf Token [Guide]\ninstance Eq Token where\n  LP == LP = True\n  (N _) == (N _) = True\n  (SO _) == (SO _) = True\n  (PO _) == (PO _) = True\n  RP == RP = True\n  _ == _ = False\ninstance Ord Token where\n  LP `compare` LP = EQ\n  LP `compare` _ = GT\n  _ `compare` LP = LT\n  (SO _) `compare` (SO _) = EQ\n  (SO _) `compare` _ = GT\n  _ `compare` (SO _) = LT\n  (PO _) `compare` (PO _) = EQ\n  (PO _) `compare` _ = GT\n  _ `compare` (PO _) = LT\n  (N _) `compare` (N _) = EQ\n  (N _) `compare` _ = GT\n  _ `compare` (N _) = LT\n  RP `compare` RP = EQ\ninstance Show Token where\n  show LP = \"(\"\n  show RP = \")\"\n  show (N n) = (show n)\n  show (SO _) = \"SO\"\n  show (PO _) = \"PO\"\ninstance Show Tree where\n  show (Leaf t g) = replicate (length g) '|' ++ (show t ++ \"\\n\")\n  show n@(Node t _ _ g) = replicate (length g) '|' ++ (show t ++ ('\\n':(show (moveLeft n) ++ show (moveRight n))))\nmoveUp :: Tree -> Tree\nmoveUp n@(Node _ _ _ ((token, branch, other):gr)) = case branch of\n  LeftBranch -> Node token n other gr\n  RightBranch -> Node token other n gr\nmoveUp l@(Leaf _ ((token, branch, other):gr)) = case branch of\n  LeftBranch -> Node token l other gr\n  RightBranch -> Node token other l gr\nmoveUp t = t\nmoveTop :: Tree -> Tree\nmoveTop = moveUpWhile (const True)\nmoveUpWhile :: (Token -> Bool) -> Tree -> Tree\nmoveUpWhile _ n@(Node _ _ _ []) = n\nmoveUpWhile _ l@(Leaf _ []) = l\nmoveUpWhile f n@(Node t _ _ _)\n  |f t = moveUpWhile f (moveUp n)\n  |otherwise = n\nmoveUpWhile f l@(Leaf t _)\n  |f t = moveUpWhile f (moveUp l)\n  |otherwise = l\nfindLast :: (Token -> Bool) -> Tree -> Tree\nfindLast f n@(Node _ _ _ ((t, _, _):_))\n  |f t = findLast f (moveUp n)\n  |otherwise = n\nfindLast f l@(Leaf _ ((t, _, _):_))\n  |f t = findLast f (moveUp l)\n  |otherwise = l\nfindLast _ n = n\nmoveDown :: Branch -> Tree -> Tree\nmoveDown LeftBranch (Node t (Node token left right _) r g) = Node token left right ((t, LeftBranch, r):g)\nmoveDown RightBranch (Node t l (Node token left right _) g) = Node token left right ((t, RightBranch, l):g)\nmoveDown LeftBranch (Node t (Leaf token _) r g) = Leaf token ((t, LeftBranch, r):g)\nmoveDown RightBranch (Node t l (Leaf token _) g) = Leaf token ((t, RightBranch, l):g)\nmoveDown _ _ = error \"error: Can't move down\"\nmoveLeft :: Tree -> Tree\nmoveLeft n@(Node {}) = moveDown LeftBranch n\nmoveLeft _ = error \"error: Can't move Left\"\nmoveRight :: Tree -> Tree\nmoveRight n@(Node {}) = moveDown RightBranch n\nmoveRight _ = error \"error: Can't move Right\"\nmoveUpForPO :: Tree -> Tree\nmoveUpForPO = findLast (==(PO (+)))\nmoveUpForSO :: Tree -> Tree\nmoveUpForSO = findLast (<=(SO (+)))\ngetoutPare :: Tree -> Tree\ngetoutPare = moveUpWhile (/=LP)\ninsertNode :: Tree -> Token -> Tree\ninsertNode o@(Node _ _ _ g) t = Leaf RP ((t, RightBranch, o):g)\ninsertNode l@(Leaf _ g) t = Leaf RP ((t, RightBranch, l):g)\nguide :: Tree -> [Guide]\nguide (Leaf _ g) = g\nguide (Node _ _ _ g) = g\nmakeTree :: Tree -> [String] -> Tree\nmakeTree t (\"(\":sr) = makeTree (Leaf RP ((LP, LeftBranch, (Leaf RP [])):(guide t))) sr\nmakeTree t [\")\", \")\"] = moveTop t\nmakeTree t [num, \")\"] = moveTop (Leaf (N (read num :: Int)) (guide t))\nmakeTree t [\")\"] = moveTop t\nmakeTree t [num] = moveTop (Leaf (N (read num :: Int)) (guide t))\nmakeTree t (\")\":\")\":sr) = makeTree ((getoutPare . moveUp) t) (\")\":sr)\nmakeTree t (num:\")\":\")\":sr) = makeTree (getoutPare right) (\")\":sr)\n  where\n    right = Leaf (N (read num :: Int)) (guide t)\nmakeTree t (\")\":o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO (div))) sr\n  where\n    right = (getoutPare . moveUp) t\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree t (num:\")\":o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO div)) sr\n  where\n    right = getoutPare (Leaf (N (read num :: Int)) (guide t))\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree t (num:o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO div)) sr\n  where\n    right = Leaf (N (read num :: Int)) (guide t)\n    so = moveUpForSO right\n    po = moveUpForPO right\nsplitAtOperator :: String -> [String]\nsplitAtOperator \"=\" = [[]]\nsplitAtOperator (o:sr)\n  |o == '+' || o == '-' || o == '*' || o == '/' = []:[o]:rest\n  |o == '(' = [o]:rest\n  |o == ')' = []:(o:(head rest)):(tail rest)\n  |otherwise = (o:(head rest)):(tail rest)\n  where\n    rest = splitAtOperator sr\nexpToTree :: String -> Tree\nexpToTree = (makeTree (Leaf RP [])) . splitAtOperator\nculTree :: Tree -> Int\nculTree (Leaf (N n) _) = n\nculTree (Node (SO f) l r _) = f (culTree l) (culTree r)\nculTree (Node (PO f) l r _) = f (culTree l) (culTree r)\nculTree (Node LP l _ _) = culTree l\nculTree _ = error \"error: Can't culcurate expression Tree\"\nsolve :: String -> Int\nsolve = culTree . expToTree\nmain :: IO ()\nmain = do\n  _ <- getLine\n  line <- fmap lines getContents\n  mapM_ (print . solve) line"
  },
  {
    "language": "Haskell",
    "code": "import Data.Char\nimport Control.Monad\n\nmydiv :: Int->Int->Int\nmydiv x y \n    | x<0 && y>0 = (((-1)*x)`div`y)*(-1)\n    | x>0 && y<0 = (x`div`((-1)*y))*(-1)\n    | otherwise  = x`div`y\n\nexpression :: String->(String,Int)\nexpression expr = expression' $ term expr\n\nexpression' :: (String,Int)->(String,Int)\nexpression' ([], n) = ([], n)\nexpression' (x:xs, n)\n    | x=='+'    = expression' (expr', n+n')\n    | x=='-'    = expression' (expr', n-n')\n    | otherwise = (x:xs, n)\n        where (expr', n') = term xs\n\nterm :: String->(String,Int)\nterm expr = term' $ factor expr\n\nterm' :: (String,Int)->(String,Int)\nterm' ([], n) = ([], n)\nterm' (x:xs, n)\n    | x=='*'     = term' (expr', n*n')\n    | x=='/'     = term' (expr', n`mydiv`n')\n    | otherwise  = (x:xs, n)\n        where (expr', n') = factor xs\n\nfactor :: String->(String, Int)\nfactor (x:xs)\n    | x=='('    = (tail $ expr1, n1) --ignore ')'\n    | otherwise = (expr2, n2)\n        where (expr1, n1) = expression xs --ignore '('\n              (expr2, n2) = number (x:xs, 0)\n\nnumber :: (String, Int)->(String, Int)\nnumber ([], n)   = ([], n)\nnumber (x:xs, n) = if isDigit x then number (xs, n*10+(digitToInt x)) else (x:xs, n)\n\nsolve :: String->IO ()\nsolve expr = do\n    print (snd $ expression $ takeWhile (/='=') expr)\n\nmain :: IO ()\nmain = do\n    n <- readLn\n    lexpr <- replicateM n getLine\n    mapM_ solve lexpr"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  n  <- getInt\n  es <- replicateM n getLine\n  -- let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative((<$>))\nimport Control.Monad\nimport qualified Data.Map as M\n-- import qualified Data.Char as C\n-- import qualified Data.List as L\n-- import qualified Data.IntSet as I\n-- import Debug.Trace\n--------------------------------------------\nreadInt    = read :: String -> Int\nreadFloat  = read :: String -> Float\ngetInt     = readInt <$> getLine\ngetIntList = map readInt . words <$> getLine\nint2bin 0 =  []\nint2bin n =  n `mod` 2 : int2bin (n `div` 2)\n----------------------------------------------\n\n-- ????????°?????? ver.\n-- expr   = term   | expr +- term\n-- term   = factor | term */ factor\n-- factor = number | (expr)\n\n-- ????????°?????? ver.\n-- expr   = term   | term (+- expr)\n-- term   = factor | factor (*/ term)\n-- factor = number | (expr)\n\ntype Op = Char\ndata Tree = Leaf Int | Node Tree Op Tree deriving Show\ntype Keisan = String -> (Tree -> Tree) -> (Tree,String)\n\nexpr :: Keisan\nexpr ss tr =\n  let (t,state) = term ss id in\n  if state == \"\" then (tr t,state)\n  else if head state == '+' then expr (tail state) (Node (tr t) '+')\n  else if head state == '-' then expr (tail state) (Node (tr t) '-')\n  else (tr t,state)\n\nterm :: Keisan\nterm ss tr =\n  let (f,state) = factor ss id in\n  if state == \"\" then (tr f,state)\n  else if head state == '*' then term (tail state) (Node (tr f) '*')\n  else if head state == '/' then term (tail state) (Node (tr f) '/')\n  else (tr f,state)\n\nfactor :: Keisan\nfactor ss tr =\n  if head ss == '(' then let (e,state) = expr (tail ss) id in (tr e,tail state)\n  else let (e,state) = getNumber ss in ((tr . Leaf . read) e,state)\n    where\n      getNumber = takeWhile2 (\\x -> x `elem` ['0'..'9'])\n\ntakeWhile2 :: (a -> Bool) -> [a] -> ([a],[a])\ntakeWhile2 cond l = aux [] l\n  where\n    aux acc [] = (reverse acc, [])\n    aux acc (x:xs)\n      | cond x = aux (x:acc) xs\n      | otherwise = (reverse acc, x:xs)\n\nsolver ss = calc.fst $ expr ss id\n-- solver ss = fst $ expr ss id\ncalc (Leaf a) = a\ncalc (Node a '+' b) = calc a + calc b\ncalc (Node a '-' b) = calc a - calc b\ncalc (Node a '/' b) = calc a `div` calc b\ncalc (Node a '*' b) = calc a * calc b\n\nmain :: IO ()\nmain = do\n  -- n  <- getInt\n  -- es <- replicateM n getLine\n  let es = [\"0+3*2*2+1=\",\"4-2*3=\",\"4*(8+4+3)=\",\"1-(1-1)-1=\"]\n  mapM_ (print.solver.(takeWhile ('=' /=))) es"
  },
  {
    "language": "Haskell",
    "code": "data Token = LP | N Int | SO (Int -> Int -> Int) | PO (Int -> Int -> Int) | RP\ndata Branch = LeftBranch | RightBranch\ntype Guide = (Token, Branch, Tree)\ndata Tree = Node Token Tree Tree [Guide] | Leaf Token [Guide]\ninstance Eq Token where\n  LP == LP = True\n  (N _) == (N _) = True\n  (SO _) == (SO _) = True\n  (PO _) == (PO _) = True\n  RP == RP = True\n  _ == _ = False\ninstance Ord Token where\n  LP `compare` LP = EQ\n  LP `compare` _ = GT\n  _ `compare` LP = LT\n  (SO _) `compare` (SO _) = EQ\n  (SO _) `compare` _ = GT\n  _ `compare` (SO _) = LT\n  (PO _) `compare` (PO _) = EQ\n  (PO _) `compare` _ = GT\n  _ `compare` (PO _) = LT\n  (N _) `compare` (N _) = EQ\n  (N _) `compare` _ = GT\n  _ `compare` (N _) = LT\n  RP `compare` RP = EQ\ninstance Show Token where\n  show LP = \"(\"\n  show RP = \")\"\n  show (N n) = (show n)\n  show (SO _) = \"SO\"\n  show (PO _) = \"PO\"\ninstance Show Tree where\n  show (Leaf t g) = replicate (length g) '|' ++ (show t ++ \"\\n\")\n  show n@(Node t _ _ g) = replicate (length g) '|' ++ (show t ++ ('\\n':(show (moveLeft n) ++ show (moveRight n))))\nmoveUp :: Tree -> Tree\nmoveUp n@(Node _ _ _ ((token, branch, other):gr)) = case branch of\n  LeftBranch -> Node token n other gr\n  RightBranch -> Node token other n gr\nmoveUp l@(Leaf _ ((token, branch, other):gr)) = case branch of\n  LeftBranch -> Node token l other gr\n  RightBranch -> Node token other l gr\nmoveUp t = t\nmoveTop :: Tree -> Tree\nmoveTop = moveUpWhile (const True)\nmoveUpWhile :: (Token -> Bool) -> Tree -> Tree\nmoveUpWhile _ n@(Node _ _ _ []) = n\nmoveUpWhile _ l@(Leaf _ []) = l\nmoveUpWhile f n@(Node t _ _ _)\n  |f t = moveUpWhile f (moveUp n)\n  |otherwise = n\nmoveUpWhile f l@(Leaf t _)\n  |f t = moveUpWhile f (moveUp l)\n  |otherwise = l\nfindLast :: (Token -> Bool) -> Tree -> Tree\nfindLast f n@(Node _ _ _ ((t, _, _):_))\n  |f t = findLast f (moveUp n)\n  |otherwise = n\nfindLast f l@(Leaf _ ((t, _, _):_))\n  |f t = findLast f (moveUp l)\n  |otherwise = l\nfindLast _ n = n\nmoveDown :: Branch -> Tree -> Tree\nmoveDown LeftBranch (Node t (Node token left right _) r g) = Node token left right ((t, LeftBranch, r):g)\nmoveDown RightBranch (Node t l (Node token left right _) g) = Node token left right ((t, RightBranch, l):g)\nmoveDown LeftBranch (Node t (Leaf token _) r g) = Leaf token ((t, LeftBranch, r):g)\nmoveDown RightBranch (Node t l (Leaf token _) g) = Leaf token ((t, RightBranch, l):g)\nmoveDown _ _ = error \"error: Can't move down\"\nmoveLeft :: Tree -> Tree\nmoveLeft n@(Node {}) = moveDown LeftBranch n\nmoveLeft _ = error \"error: Can't move Left\"\nmoveRight :: Tree -> Tree\nmoveRight n@(Node {}) = moveDown RightBranch n\nmoveRight _ = error \"error: Can't move Right\"\nmoveUpForPO :: Tree -> Tree\nmoveUpForPO = findLast (==(PO (+)))\nmoveUpForSO :: Tree -> Tree\nmoveUpForSO = findLast (<=(SO (+)))\ngetoutPare :: Tree -> Tree\ngetoutPare = moveUpWhile (/=LP)\ninsertNode :: Tree -> Token -> Tree\ninsertNode o@(Node _ _ _ g) t = Leaf RP ((t, RightBranch, o):g)\ninsertNode l@(Leaf _ g) t = Leaf RP ((t, RightBranch, l):g)\nguide :: Tree -> [Guide]\nguide (Leaf _ g) = g\nguide (Node _ _ _ g) = g\nmakeTree :: Tree -> [String] -> Tree\nmakeTree t (\"(\":sr) = makeTree (Leaf RP ((LP, LeftBranch, (Leaf RP [])):(guide t))) sr\nmakeTree t [\")\", \")\"] = moveTop t\nmakeTree t [num, \")\"] = moveTop (Leaf (N (read num :: Int)) (guide t))\nmakeTree t [\")\"] = moveTop t\nmakeTree t [num] = moveTop (Leaf (N (read num :: Int)) (guide t))\nmakeTree t (\")\":\")\":sr) = makeTree ((getoutPare . moveUp) t) (\")\":sr)\nmakeTree t (num:\")\":\")\":sr) = makeTree (getoutPare right) (\")\":sr)\n  where\n    right = Leaf (N (read num :: Int)) (guide t)\nmakeTree t (\")\":o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO (div))) sr\n  where\n    right = (getoutPare . moveUp) t\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree t (num:\")\":o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO div)) sr\n  where\n    right = getoutPare (Leaf (N (read num :: Int)) (guide t))\n    so = moveUpForSO right\n    po = moveUpForPO right\nmakeTree t (num:o:sr) = case o of\n  \"+\" -> makeTree (insertNode so (SO (+))) sr\n  \"-\" -> makeTree (insertNode so (SO (-))) sr\n  \"*\" -> makeTree (insertNode po (PO (*))) sr\n  \"/\" -> makeTree (insertNode po (PO div)) sr\n  where\n    right = Leaf (N (read num :: Int)) (guide t)\n    so = moveUpForSO right\n    po = moveUpForPO right\nsplitAtOperator :: String -> [String]\nsplitAtOperator \"=\" = [[]]\nsplitAtOperator (o:sr)\n  |o == '+' || o == '-' || o == '*' || o == '/' = []:[o]:rest\n  |o == '(' = [o]:rest\n  |o == ')' = []:(o:(head rest)):(tail rest)\n  |otherwise = (o:(head rest)):(tail rest)\n  where\n    rest = splitAtOperator sr\nexpToTree :: String -> Tree\nexpToTree = (makeTree (Leaf RP [])) . splitAtOperator\nculTree :: Tree -> Int\nculTree (Leaf (N n) _) = n\nculTree (Node (SO f) l r _) = f (culTree l) (culTree r)\nculTree (Node (PO f) l r _) = f (culTree l) (culTree r)\nculTree (Node LP l _ _) = culTree l\nculTree _ = error \"error: Can't culcurate expression Tree\"\nsolve :: String -> Int\nsolve = culTree . expToTree\ntimesDo :: Int -> IO ()\ntimesDo 0 = return ()\ntimesDo n = do\n  line <- getLine\n  print $ solve line\n  timesDo (n - 1)\nmain :: IO ()\nmain = do\n  n <- fmap (\\m -> read m :: Int) getLine\n  timesDo n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nmain = do\n    n <- readLn\n    formulas <- fmap init $ replicateM n getLine\n    mapM_ print $ map calcForm formulas\n\ndata Tree a =  Leaf a | Node a (Tree a) (Tree a) deriving Show\nisLeaf :: Tree a -> Bool\nisLeaf x = case x of\n             Leaf _ -> True\n             otherwise -> False\n\ncalcForm :: String -> Int\ncalcForm str = calcTree.divCalcTree $ Leaf str\n\ncalcTree :: Tree String -> Int\ncalcTree (Leaf a)            = read a\ncalcTree (Node c left right) = calc c (calcTree left) (calcTree right)\n\ncalc c l r\n    | c == \"/\" = l `div` r\n    | c == \"*\" = l * r\n    | c == \"-\" = l - r\n    | c == \"+\" = l + r\n\ndivCalcTree :: Tree String -> Tree String\ndivCalcTree (Leaf str)\n  | check '(' str = calcInParenthesis str\n  | check '+' str = sepBy '+' str\n  | check '-' str = sepBy '-' str\n  | check '*' str = sepBy '*' str\n  | check '/' str = sepBy '/' str\n  | otherwise     = Leaf str\n\nsepBy :: Char -> String -> Tree String\nsepBy c str = Node [c] (divCalcTree left) (divCalcTree right)\n    where\n        left = Leaf $ takeWhile (/= c) str\n        right = Leaf $ tail.dropWhile (/= c) $ str\n\ncalcInParenthesis str = divCalcTree (Leaf calcedStr)\n    where calcedStr = takeWhile (/= '(') str ++ (show.calcForm $ inParen) ++ (tail.dropWhile (/= ')') $ str)\n          inParen   = takeWhile (/= ')').tail.dropWhile (/= '(') $ str\n\ncheck :: Char -> String -> Bool\ncheck c str = c `elem` str"
  },
  {
    "language": "Haskell",
    "code": "data Token = N Int | SO (Int -> Int -> Int) | PO (Int -> Int -> Int) | LP | RP\ndata Tree = Node Token Tree Tree [Guide] | Leaf Token [Guide]\ndata Branch = LeftBranch | RightBranch deriving (Eq)\ntype Guide = (Token, Branch, Tree)\n\ninstance Eq Token where\n  (N _) == (N _) = True\n  (SO _) == (SO _) = True\n  (PO _) == (PO _) = True\n  LP == LP = True\n  RP == RP = True\n  _ == _ = False\n\ninstance Ord Token where\n  LP `compare` LP = EQ\n  LP `compare` _ = GT\n  _ `compare` LP = LT\n  (N _) `compare` (N _) = EQ\n  (N _) `compare` _ = GT\n  _ `compare` (N _) = LT\n  (SO _) `compare` (SO _) = EQ\n  (SO _) `compare` _ = GT\n  _ `compare` (SO _) = LT\n  (PO _) `compare` (PO _) = EQ\n  (PO _) `compare` _ = GT\n  _ `compare` (PO _) = LT\n  RP `compare` RP = EQ\n\ninstance Show Token where\n  show (N n) = show n\n  show (SO _) = \"SO\"\n  show (PO _) = \"PO\"\n  show LP = \"----(\"\n  show RP = \")----\"\n\ninstance Show Tree where\n  show (Leaf t g) = replicate (length g) '|' ++ (show t) ++ \"\\n\"\n  show n@(Node t l r g) = replicate (length g) '|' ++ ((show t) ++ ('\\n':(show (moveDown n LeftBranch) ++ (show (moveDown n RightBranch)))))\n\nsetGuide :: Tree -> [Guide] -> Tree\nsetGuide (Node t l r _) g = Node t l r g\nsetGuide (Leaf t _) g = Leaf t g\n\nmoveDown :: Tree -> Branch -> Tree\nmoveDown (Node t l r g) LeftBranch = setGuide l ((t, LeftBranch, r):g)\nmoveDown (Node t l r g) RightBranch = setGuide r ((t, RightBranch, l):g)\nmoveDown _ _ = error \"error: Try move down from Leaf -> moveDown\"\n\nmoveUp :: Tree -> Tree\nmoveUp t@(Node _ _ _ ((u, branch, o):g))\n  |branch == LeftBranch = Node u (setGuide t []) o g\n  |branch == RightBranch = Node u o (setGuide t []) g\nmoveUp t@(Leaf _ ((u, branch, o):g))\n  |branch == LeftBranch = Node u (setGuide t []) o g\n  |branch == RightBranch = Node u o (setGuide t []) g\nmoveUp t@(Node _ _ _ []) = t\nmoveUp l = l\n\nmoveTop :: Tree -> Tree\nmoveTop t@(Node _ _ _ []) = t\nmoveTop l@(Leaf _ []) = l\nmoveTop t@(Node _ _ _ ((v, branch, o):gr)) = case branch of\n  LeftBranch -> moveTop (Node v t o gr)\n  RightBranch -> moveTop (Node v o t gr)\nmoveTop l@(Leaf _ ((v, branch, o):gr)) = case branch of\n  LeftBranch -> moveTop (Node v l o gr)\n  RightBranch -> moveTop (Node v o l gr)\n\nmoveUpUntil :: (Token -> Bool) -> Tree -> Tree\nmoveUpUntil _ n@(Node _ _ _ []) = n\nmoveUpUntil _ l@(Leaf _ []) = l\nmoveUpUntil f n@(Node _ _ _ ((t, _, _):_))\n  |f t = moveUpUntil f (moveUp n)\n  |otherwise = n\nmoveUpUntil f l@(Leaf _ ((t, _, _):_))\n  |f t = moveUpUntil f (moveUp l)\n  |otherwise = l\n\nfindUpFirstNode :: (Token -> Bool) -> Tree -> Tree\nfindUpFirstNode _ n@(Node _ _ _ []) = n\nfindUpFirstNode _ l@(Leaf _ []) =l\nfindUpFirstNode f n@(Node t _ _ _)\n  |f t = n\n  |otherwise = findUpFirstNode f (moveUp n)\nfindUpFirstNode f l@(Leaf t _)\n  |f t = l\n  |otherwise = findUpFirstNode f (moveUp l)\n\ngetOutPare :: Tree -> Tree\ngetOutPare = moveUp . findUpFirstNode (/= LP)\n\nmakeTree :: [Guide] -> [String] -> Tree\nmakeTree g [num] = moveTop $ Leaf (N (read num :: Int)) g\nmakeTree g (\"(\":sr) = makeTree ((LP, LeftBranch, (Leaf RP [])):g) sr\nmakeTree g [num, \")\"]= moveTop $ Leaf (N (read num :: Int)) g\nmakeTree g (num:\")\":o:sr) = case o of\n  \"+\" -> makeTree ((SO (+), RightBranch, top):(getGuide top)) sr\n  \"-\" -> makeTree ((SO (-), RightBranch, top):(getGuide top)) sr\n  \"*\" -> makeTree ((PO (*), RightBranch, ptop):(getGuide ptop)) sr\n  \"/\" -> makeTree ((PO (div), RightBranch, ptop):(getGuide ptop)) sr\n  where\n    right = getOutPare (Leaf (N (read num :: Int)) g)\n    top = moveUpUntil (/=LP) right\n    ptop = moveUpUntil (<= (PO (*))) right\nmakeTree g (num:o:sr) = case o of\n  \"+\" -> makeTree ((SO (+), RightBranch, top):(getGuide top)) sr\n  \"-\" -> makeTree ((SO (-), RightBranch, top):(getGuide top)) sr\n  \"*\" -> makeTree ((PO (*), RightBranch, ptop):(getGuide ptop)) sr\n  \"/\" -> makeTree ((PO (div), RightBranch, ptop):(getGuide ptop)) sr\n  where\n    right = Leaf (N (read num :: Int)) g\n    top = moveUpUntil (/=LP) right\n    ptop = moveUpUntil (<= (PO (*))) right\n\ngetGuide :: Tree -> [Guide]\ngetGuide (Node _ _ _ g) = g\ngetGuide (Leaf _ g) = g\n\nsplitAtOperator :: String -> [String]\nsplitAtOperator \"=\" = [\"\"]\nsplitAtOperator \")=\" = [\"\", \")\"]\nsplitAtOperator (s:sr)\n  |s == '+' || s == '-' || s == '*' || s == '/' = []:[s]:(splitAtOperator sr)\n  |s == '(' = \"(\":(splitAtOperator sr)\n  | s == ')' = []:(')':(head (splitAtOperator sr))):(tail (splitAtOperator sr))\n  |otherwise = (s:head (splitAtOperator sr)):(tail (splitAtOperator sr))\n\nexpressToTree :: String -> Tree\nexpressToTree = (makeTree []) . splitAtOperator\n\nculcurateTree :: Tree -> Int\nculcurateTree (Leaf t _) = case t of\n  (N n) -> n\n  _ -> error \"error: Invalid Tree -> with unexpected Leaf\"\nculcurateTree n@(Node LP left _ _) = culcurateTree (moveDown n LeftBranch)\nculcurateTree n@(Node (SO f) left right _) = f (culcurateTree (moveDown n LeftBranch)) (culcurateTree (moveDown n RightBranch))\nculcurateTree n@(Node (PO f) left right _) = f (culcurateTree (moveDown n LeftBranch)) (culcurateTree (moveDown n RightBranch))\nculcurateTree _ = error \"error: Invalid Tree\"\n\nsolve :: String -> Int\nsolve = culcurateTree . expressToTree\n\nmain :: IO ()\nmain = do\n  n <- getLine\n  expressions <- fmap lines getContents\n  mapM_ (print . solve) expressions"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\ndata Token = TNum Int | TAdd | TSub | TMul | TDiv | TOpen | TClose | TEnd deriving (Show, Eq)\n\ntokenize :: String -> [Token]\ntokenize [] = []\ntokenize s@(c:cs) = case c of\n    '=' -> [TEnd]\n    '(' -> TOpen : tokenize cs\n    ')' -> TClose : tokenize cs\n    '+' -> TAdd : tokenize cs\n    '-' -> TSub : tokenize cs\n    '*' -> TMul : tokenize cs\n    '/' -> TDiv : tokenize cs\n    _ -> let (n, r) = readNum s in TNum n : tokenize r\n  where\n    readNum :: String -> (Int, String)\n    readNum s = readNum' 0 s\n    readNum' x s@(c:cs)\n      | isDigit c = readNum' (10*x+digitToInt c) cs\n      | otherwise = (x, s)\n\ncalc :: [Token] -> Int\ncalc ts = fst $ f 0 (+) 1 (*) ts\nf :: Int -> (Int -> Int -> Int) -> Int -> (Int -> Int -> Int) -> [Token] -> (Int, [Token])\nf n nop m mop (TEnd:ts) = (nop n m, ts)\nf n nop m mop (TClose:ts) = (nop n m, ts)\nf n nop m mop (TOpen:ts) = let (x, r) = f 0 (+) 1 (*) ts in f n nop (mop m x) mop r\nf n nop m mop (TAdd:ts) = f (nop n m) (+) 1 (*) ts\nf n nop m mop (TSub:ts) = f (nop n m) (-) 1 (*) ts\nf n nop m mop (TMul:ts) = f n nop m (*) ts\nf n nop m mop (TDiv:ts) = f n nop m div ts\nf n nop m mop (TNum x:ts) = f n nop (mop m x) mop ts \n\n\nmain = getInt >>= flip replicateM getLine >>= mapM_ (print . calc . tokenize)\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<string.h>\n#include<stdlib.h>\n\nint expression(char *);\nint term(char *);\nint factor(char *);\nint number(char *);\n\nint main(void){\n  int N,i,ans;\n  char s[100000];\n  char *begin;\n  scanf(\"%d\",&N);\n  scanf(\"%c\",&s[0]);\n  \n  for(i=0;i<N;i++){\n    scanf(\"%[^\\n]%*c\",s);\n    \n    begin=s;\n    ans=expression(begin);\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\nint expression(char *begin){\n  int ret=term(begin);\n  \n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint  term(char *begin){\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(char *begin){\n  \n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n    return ret;\n  }\n  if(*begin=='-'){\n    begin++;\n    return -factor(begin);\n  }\n  return number(begin);\n}\n\nint number(char *begin){\n  int ret=0;\n  \n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint r,b,q[100];\nchar s[101];\nvoid f(int e){\n  int i,c=0,j;\n  for(i=e;i<r;i++){//printf(\"%c \",s[i]);\n    if(s[i]=='*'){\n      q[i+1]=q[i]*q[i+1];\n      c++;\n    }\n    else if(s[i]=='/'){\n      q[i+1]=q[i]/q[i+1];\n      c++;\n    }\n    else {\n      //if(s[i]=='=')return;\n      s[i-c]=s[i];\n      q[i-c]=q[i];\n    }\n  }if(s[0]=='=')return ;\n  r-=c;//printf(\"\\n\\nq:\");\n  //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\ns:\");\n  //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n  //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");  \n  for(i=e;i<r;i++){\n    if(s[i]=='+')q[i+1]=q[i]+q[i+1];\n    if(s[i]=='-')q[i+1]=q[i]-q[i+1];\n  }\n  q[e]=q[r-1];\n  b+=r-e;\n  r=e+1;\n  return;\n}\nint main(){\n  int m,n=0,i,c=-1,kr=0,k[100],j;\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",s);\n    for(i=r=b=kr=0;s[i];i++){\n      if('0'<=s[i]&&s[i]<='9'){\n\tn*=10;\n\tn+=s[i]-'0';\n\tc++;\n      }\n      else {\n\tb++;\n\tif(s[i]=='(')k[kr++]=r;\n\telse{\n\t  if(c+1)q[r++]=n;\n\t  n=0;\n\t  b+=c;\n\t  c=-1;\n\t  if(s[i]==')')f(k[--kr]);\n       \t  else s[i-b]=s[i];\n\t}\n      }//printf(\"q:\");\n      //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\nk:\");\n      //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n      //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");\n    }\n    f(0);//printf(\"\\nq:\");\n    //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\nk:\");\n    //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n    //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");\n    printf(\"%d\\n\",q[0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "char E[200];\nint p;\n//A=M[+-]M[+-]M\n//M=T[*/]T[*/]T\n//T=(A)|%d\nPM(){\n\tint r;\n\tr=PT();\n\tfor(;;){\n\t\tif(E[p]=='*'){\n\t\t\tp++;\n\t\t\tr*=PT();\n\t\t}else if(E[p]=='/'){\n\t\t\tp++;\n\t\t\tr/=PT();\n\t\t}else\n\t\t\treturn r;\n\t}\n}\nPA(){\n\tint r;\n\tr=PM();\n\tfor(;;){\n\t\tif(E[p]=='+'){\n\t\t\tp++;\n\t\t\tr+=PM();\n\t\t}else if(E[p]=='-'){\n\t\t\tp++;\n\t\t\tr-=PM();\n\t\t}else\n\t\t\treturn r;\n\t}\n}\nPT(){\n\tint r,l;\n\tif(E[p]=='('){\n\t\tp++;\n\t\tr=PA();\n\t\tp++;\n\t}else{\n\t\tsscanf(E+p,\"%d%n\",&r,&l);\n\t\tp+=l;\n\t}\n\treturn r;\n}\nmain(){\n\tscanf(\"%*d\\n\");\n\tfor(;~scanf(\"%[^=]=\\n\",E);){\n\t\tp=0;\n\t\tprintf(\"%d\\n\",PA());\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        res = addsub(idx + 1);\n    }\n    else if (formula[idx] == '-'){\n        res = -number(idx + 1);\n    }\n    else {\n        while (isdigit(formula[idx])){\n            res = res * 10 + formula[idx] - '0';\n            ++idx;\n        }\n    }\n    //printf(\"   %d\\n\", res);\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    ++idx;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (!isdigit(formula[idx])){\n            break;\n        }\n        ++idx;\n    }\n    //printf(\"  %d\\n\", res);\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int first = 1;\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n        }\n        else if (formula[idx] == '-' && !brackets && !first){\n            res -= muldiv(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n        first = 0;\n    }\n    //printf(\" %d\\n\", res);\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define CALC {if(sign==0) term=term*x; else term=term/x;}\n\nint num;\nchar str[101];\n\nint smartCalc(){\n  int sum=0, term=1, sign=0, x=0;\n  while(1){\n    switch(str[num]){\n    case '*':\n      CALC;\n      sign=0;\n      x=0;\n      break;\n    case '/':\n      CALC;\n      sign=1;\n      x=0;\n      break;\n    case '+':\n      CALC;\n      sum += term;\n      term=1;\n      sign = 0;\n      x =0;\n      break;\n    case '-':\n      CALC;\n      sum += term;\n      term = -1;\n      sign = 0;\n      x=0;\n      break;\n    case '(':\n      num += 1;\n      x = smartCalc();\n      break;\n    case ')':\n      break;\n    case '=':\n      CALC;\n      sum += term;\n      return sum;\n      break;\n    default:\n      x = x*10 + str[num] - '0';\n    }\n    num += 1;\n  }\n}\nint main(){\n  int n, i;\n  scanf(\"%d\", &n);\n  for(i=0; i<n; i++){\n    scanf(\"%s\", str);\n    num=0;\n    printf(\"%d\\n\", smartCalc());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint p=0;\ndouble f(double a,int b,double c){\n  if(b==2)return a+c;\n  if(b==3)return a-c;\n  if(b==4)return a*c;\n  return a/c;\n}\nint kobun(){\n  int i,r=0,o[3],or[]={0,0,1,1,2,2};\n  int n[3],a;\n  char c[]={\")=+-*/\"};\n  while(1){\n    for(a=0;'0'<=s[p]&&s[p]<='9';p++)a=a*10+s[p]-'0';\n    if(s[p]=='('){\n      p++;\n      a=kobun();\n    }\n    for(i=0;s[p]-c[i];i++);\n    for(;r&&o[r-1]/2>=or[i];r--)a=f(n[r-1],o[r-1],a);\n    n[r]=a;\n    o[r++]=or[i];\n    p++;\n    if(or[i]==0)return n[0];\n  }\n  return 0;\n}\nint main(){\n  int n;\n  for(scanf(\"%d\",&n);n--;p=0){\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",kobun());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0109: Smart Calculator\n// 2017.8.5\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX 200\n#define INF   1000000010\n#define LEFT (INF+1)\n#define RIGHT (INF+2)\n#define PLUS (INF+3)\n#define MINUS (INF+4)\n#define MUL (INF+5)\n#define DIV (INF+6)\n\nchar *gets(char *);\nchar buf[200], *p;\nint S[MAX + 3], top;\nint Q[MAX + 3], end;\n\nint getInt(void)\n{\n\tint n = 0;\n//\twhile (isspace(*p)) p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nint token(char c)\n{\n\tif (c == '+') return PLUS;\n\tif (c == '-') return MINUS;\n\tif (c == '*') return MUL;\n\treturn DIV;\n}\n\nint rank(int op)\n{\n\tif (op == PLUS || op == MINUS) return 2;\n\tif (op == MUL || op == DIV) return 3;\n\treturn 1;\n}\n\nint main()\n{\n\tint i, f, k, d1, d2;\n\tint cno, cmax;\n\n\tgets(p = buf); cmax = getInt();\n\tfor (cno = 0; cno < cmax; cno++) {\n\t\tgets(p = buf), f = 1, top = 0, end = 0;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (!*p || *p == '=') {\n\t\t\t\twhile (top) Q[end++] = S[--top];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '-' && f && isdigit(*(p + 1))) {\n\t\t\t\tp++;\n\t\t\t\tQ[end++] = -getInt();\n\t\t\t\tf = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = 0;\n\t\t\tif (isdigit(*p)) Q[end++] = getInt();\n\t\t\telse if (*p == ')') {\n\t\t\t\twhile (S[top - 1] != LEFT) Q[end++] = S[--top];\n\t\t\t\ttop--, p++;\n\t\t\t}\n\t\t\telse if (*p == '(') S[top++] = LEFT, p++, f = 1;\n\t\t\telse {\n\t\t\t\tk = token(*p++);\n\t\t\t\twhile (top) {\n\t\t\t\t\tif (rank(k) <= rank(S[top - 1])) Q[end++] = S[--top];\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tS[top++] = k;\n\t\t\t}\n\t\t}\n#if 0\n\t\tfor (i = 0; i < end; i++) printf(\"%d \", Q[i]);\n\t\tprintf(\"\\n\");\n#endif\n\t\tfor (top = i = 0; i < end; i++) {\n\t\t\tif ((k = Q[i]) > INF) {\n\t\t\t\td1 = S[--top], d2 = S[--top];\n\t\t\t\tif (k == PLUS) d2 += d1;\n\t\t\t\telse if (k == MINUS) d2 -= d1;\n\t\t\t\telse if (k == MUL) d2 *= d1;\n\t\t\t\telse d2 /= d1;\n\t\t\t\tS[top++] = d2;\n\t\t\t} else S[top++] = k;\n\t\t}\n\t\tprintf(\"%d\\n\", S[--top]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint N,idx;\nchar S[105];\n \nint fact();\nint expr();\nint term();\nint number();\n \nint expr()\n{\n    int res=term();\n    for(;S[idx]=='+'||S[idx]=='-';)\n    {\n        char op=S[idx++];\n        int tmp=term();\n        if(op=='+')res+=tmp;\n        else res-=tmp;\n    }\n    return res;\n}\n \nint term()\n{\n    int res=fact();\n    for(;S[idx]=='*'||S[idx]=='/';)\n    {\n        char op=S[idx++];\n        int tmp=fact();\n        if(op=='*')res*=tmp;\n        else res/=tmp;\n    }\n    return res;\n}\n \nint fact()\n{\n    int res;\n    if(S[idx]=='(')\n    {\n        idx++;\n        res=expr();\n        idx++;\n    }\n    else\n        res=number();\n    return res;\n}\n \nint number()\n{\n    int res=0;\n    for(;'0'<=S[idx]&&S[idx]<='9';idx++)\n    {\n        res=res*10+S[idx]-'0';\n    }\n    return res;\n}\n \n \nint main()\n{\n    scanf(\"%d\\n\",&N);\n    for(;N--;)\n    {\n        idx=0;\n        gets(S);\n        printf(\"%d\\n\",expr());\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include  <stdio.h>\nint expr();\nint term();\nint fact();\nint number();\n\nint n,idx;\n\nchar s[105];\nint expr(void){\n    int res=term();\n        for(;s[idx] == '+' || s[idx]=='-';){\n        char ope=s[idx++];\n        char temp=term();\n        ope=='+'?(res+=temp):(res-=temp);\n    }\n    return res;\n}\nint term(void){\n    int res=fact();\n    for(;s[idx]=='*' || s[idx]=='/';){\n        char ope=s[idx++];\n        int temp=fact();\n        ope=='*'?(res*=temp):(res/=temp);\n    }\n    return res;\n}\nint fact(void){\n    int res;\n    if(s[idx]=='('){\n        idx++;\n        res=expr();\n        idx++;\n    }\n    else\n        res=number();\n    return res;\n}\nint number(void){\n    int res=0;\n    for(;'0' <= s[idx] && s[idx] <= '9';idx++){\n        res=res*10+s[idx]-'0';\n    }\n    return res;\n}\nint main(void){\n    int i;\n    scanf(\"%d\\n\",&n);\n    for(i=0;i<n;i++){\n        idx=0;\n        fgets(s,105,stdin);\n        printf(\"%d\\n\",expr());\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "char*p,s[999];t();f();e(x){for(x=t(0);*p&&*p<46;)x+=*p++%5?t(0):-t(0);return x;}t(x){for(x=f(0);*p%5==2;x*=f(0))++p;return x;}f(x){return*p<41?++p,x=e(0),++p,x:*p<46?*p++%5?f(0):-f(0):strtol(p,&p,0);}main(i){for(;~scanf(\"%s\",p=s);)--i&&printf(\"%d\\n\",e(0));}"
  },
  {
    "language": "C",
    "code": "#include  <stdio.h>\nint expr();\nint term();\nint fact();\nint number();\n\nint n,idx;\n\nchar s[105];\nint expr(void){\n    int res=term();\n        for(;s[idx] == '+' || s[idx]=='-';){\n        char ope=s[idx++];\n        int  temp=term();\n        ope=='+'?(res+=temp):(res-=temp);\n    }\n    return res;\n}\nint term(void){\n    int res=fact();\n    for(;s[idx]=='*' || s[idx]=='/';){\n        char ope=s[idx++];\n        int temp=fact();\n        ope=='*'?(res*=temp):(res/=temp);\n    }\n    return res;\n}\nint fact(void){\n    int res;\n    if(s[idx]=='('){\n        idx++;\n        res=expr();\n        idx++;\n    }\n    else\n        res=number();\n    return res;\n}\nint number(void){\n    int res=0;\n    for(;'0' <= s[idx] && s[idx] <= '9';idx++){\n        res=res*10+s[idx]-'0';\n    }\n    return res;\n}\nint main(void){\n    int i;\n    scanf(\"%d\\n\",&n);\n    for(i=0;i<n;i++){\n        idx=0;\n        fgets(s,105,stdin);\n        printf(\"%d\\n\",expr());\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0109: Smart Calculator\n// 2017.8.5\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX 200\n#define INF   1000000010\n#define LEFT (INF+1)\n#define RIGHT (INF+2)\n#define PLUS (INF+3)\n#define MINUS (INF+4)\n#define MUL (INF+5)\n#define DIV (INF+6)\n\nchar *gets(char *);\nchar buf[200], *p;\nint S[MAX + 3], top;\nint Q[MAX + 3], end;\n\nint getInt(void)\n{\n\tint n = 0;\n//\twhile (isspace(*p)) p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nint token(char c)\n{\n\tif (c == '+') return PLUS;\n\tif (c == '-') return MINUS;\n\tif (c == '*') return MUL;\n\treturn DIV;\n}\n\nint main()\n{\n\tint i, f, k, d1, d2;\n\tint cno, cmax;\n\n\tgets(p = buf); cmax = getInt();\n\tfor (cno = 0; cno < cmax; cno++) {\n\t\tgets(p = buf), f = 1, top = 0, end = 0;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (!*p || *p == '=') {\n\t\t\t\twhile (top) Q[end++] = S[--top];\n\t\t\t\tbreak;\n\t\t\t}\n#if 0\n\t\t\tif (*p == '-' && f && isdigit(*(p + 1))) {\n\t\t\t\tp++;\n\t\t\t\tQ[end++] = -getInt();\n\t\t\t\tf = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = 0;\n#endif\n\t\t\tif (isdigit(*p)) Q[end++] = getInt();\n\t\t\telse if (*p == ')') {\n\t\t\t\twhile (S[top - 1] != LEFT) Q[end++] = S[--top];\n\t\t\t\ttop--, p++;\n\t\t\t}\n\t\t\telse if (*p == '(') S[top++] = LEFT, p++, f = 1;\n\t\t\telse {\n\t\t\t\tk = token(*p++);\n\t\t\t\twhile (top) {\n\t\t\t\t\tif (k < S[top - 1]) Q[end++] = S[--top];\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tS[top++] = k;\n\t\t\t}\n\t\t}\n#if 0\n\t\tfor (i = 0; i < end; i++) printf(\"%d \", Q[i]);\n\t\tprintf(\"\\n\");\n#endif\n\t\tfor (top = i = 0; i < end; i++) {\n\t\t\tif ((k = Q[i]) > INF) {\n\t\t\t\td1 = S[--top], d2 = S[--top];\n\t\t\t\tif (k == PLUS) d2 += d1;\n\t\t\t\telse if (k == MINUS) d2 -= d1;\n\t\t\t\telse if (k == MUL) d2 *= d1;\n\t\t\t\telse d2 /= d1;\n\t\t\t\tS[top++] = d2;\n\t\t\t} else S[top++] = k;\n\t\t}\n\t\tif (top != 1) while (1);\n\t\tprintf(\"%d\\n\", S[--top]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint N,idx;\nchar S[105];\n\nint fact();\nint expr();\nint term();\nint number();\n\nint expr()\n{\n\tint res=term();\n\tfor(;S[idx]=='+'||S[idx]=='-';)\n\t{\n\t\tchar op=S[idx++];\n\t\tint tmp=term();\n\t\tif(op=='+')res+=tmp;\n\t\telse res-=tmp;\n\t}\n\treturn res;\n}\n\nint term()\n{\n\tint res=fact();\n\tfor(;S[idx]=='*'||S[idx]=='/';)\n\t{\n\t\tchar op=S[idx++];\n\t\tint tmp=fact();\n\t\tif(op=='*')res*=tmp;\n\t\telse res/=tmp;\n\t}\n\treturn res;\n}\n\nint fact()\n{\n\tint res;\n\tif(S[idx]=='(')\n\t{\n\t\tidx++;\n\t\tres=expr();\n\t\tidx++;\n\t}\n\telse\n\t\tres=number();\n\treturn res;\n}\n\nint number()\n{\n\tint res=0;\n\tfor(;'0'<=S[idx]&&S[idx]<='9';idx++)\n\t{\n\t\tres=res*10+S[idx]-'0';\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tscanf(\"%d\\n\",&N);\n\tfor(;N--;)\n\t{\n\t\tidx=0;\n\t\tgets(S);\n\t\tprintf(\"%d\\n\",expr());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,s[999];t();f();e(x){for(x=t(0);*p&&*p<46;)x+=*p++%5?t(0):-t(0);return x;}t(x){for(x=f(0);*p%5==2;x*=f(0))++p;return x;}f(x){return*p<41?++p,x=e(0),++p,x:strtol(p,&p,0);}main(i){for(;~scanf(\"%s\",p=s);)--i&&printf(\"%d\\n\",e(0));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define CALC {if(sign==0) term=term*x; else term=term/x;}\n\nint num;\nchar str[101];\n\nint smartCalc(){\n  int sum=0, term=1, sign=0, x=0;\n  while(1){\n    switch(str[num]){\n    case '*':\n      CALC;\n      sign=0;\n      x=0;\n      break;\n    case '/':\n      CALC;\n      sign=1;\n      x=0;\n      break;\n    case '+':\n      CALC;\n      sum += term;\n      term=1;\n      sign = 0;\n      x =0;\n      break;\n    case '-':\n      CALC;\n      sum += term;\n      term = -1;\n      sign = 0;\n      x=0;\n      break;\n    case '(':\n      num += 1;\n      x = smartCalc();\n      break;\n    case ')':\n      break;\n    case '=':\n      CALC;\n      sum += term;\n      return sum;\n      break;\n    default:\n      x = x*10 + str[num] - '0';\n    }\n    num += 1;\n  }\n}\nint main(){\n  int n, i;\n  scanf(\"%d\", &n);\n  for(i=0; i<n; i++){\n    scanf(\"%s\", str);\n    num=0;\n    printf(\"%d\\n\", smartCalc());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\n  int n,i,j,k,q,m,bfc,stc;\n  char raw[256],st[256],bf[256];\n\n\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++){\n\n    for(j=0;j<256;j++){\n      bf[j]='\\0';\n      st[j]='\\0';\n    }\n    bfc=0;\n    stc=0;\n\n    scanf(\"%s\",raw);\n    k=0;\n    while(raw[k]!='='){\n      // printf(\"raw[k]=%c\\n\",raw[k]);\n\n      if(isdigit(raw[k])!=0){\n\tbf[bfc]=raw[k];\n\tk++;\n\tbfc++;\n\t//printf(\"digit\\nbf %s\\nst %s\\n\",bf,st);\n\t//printf(\"--------------------\\n\");\n      }\n      /*if(st[stc-1]==')'&&st[stc-3]=='('){\n\tst[stc-1]='\\0';\n\tst[stc-3]='\\0';\n\tstc=stc-3;\n\tprintf(\"!\\n\");\n\t}*/\n      else if(stc==0||raw[k]=='('){\n\tst[stc]=raw[k];\n\tstc++;\n\tk++;\n\t//printf(\"blank\\nbf %s\\nst %s\\n\",bf,st);\n      }\n      else if(raw[k]==')'){\n\tst[stc]=raw[k];\n\twhile(st[stc-1]!='('){\n\t  stc--;\n\t  bf[bfc]=st[stc];\n\t  bfc++;\n\t}\n\tstc--;\n\tk++;\n\t//printf(\")\\nbf %s\\nst %s\\n\",bf,st);\n      }\n      else if(raw[k]=='+'||raw[k]=='-'){\n\tif(st[stc-1]=='+'||st[stc-1]=='-'||st[stc-1]=='('){\n\t  st[stc]=raw[k];\n\t  stc++;\n\t  k++;\n\t  //printf(\"+=1\\nbf %s\\nst %s\\n\",bf,st);\n\t}\n\telse{\n\t  while(st[stc-1]!='('){\n\t    if(stc==0)break;\n\t    else{\n\t  stc--;\n\t  bf[bfc]=st[stc];\n\t  bfc++;\n\t  }\n\t  }\n\t  st[stc]=raw[k];\n\t  k++;\n\t  stc++;\n\t  //printf(\"+-2\\nbf %s\\nst %s\\n\",bf,st);\n\t}\n      }\n      else if(raw[k]=='*'||raw[k]=='/'){\n\tif(st[stc-1]=='*'||st[stc-1]=='/'){\n\t  stc--;\n\t  bf[bfc]=st[stc];\n\t  bfc++;\n\t  st[stc]=raw[k];\n\t  stc++;\n\t  k++;\n\t  //printf(\"*/1\\nbf %s\\nst %s\\n\",bf,st);\n\t}\n\telse{\n\t  st[stc]=raw[k];\n\t  stc++;\n\t  k++;\n\t  //printf(\"*/2\\nbf %s\\nst %s\\n\",bf,st);\n\t}\n      }\n      //printf(\"--------------------\\n\");\n    }\n\n\n    while(stc>0){\n      stc--;\n      bf[bfc]=st[stc];\n      bfc++;\n    }\n    //printf(\"new raw is %s\\n\",bf);\n  \n\n\n q=0;\n    for(m=0;m<255;m++){\n      if(isdigit(bf[m])!=0){\n\tst[q]=bf[m]-'0';\n\tq++;\n      }\n     else if(bf[m]=='+'){\n\tst[q-2]=st[q-2]+st[q-1];\n\tq--;\n      }\n     else if(bf[m]=='-'){\n\tst[q-2]=st[q-2]-st[q-1];\n\tq--;\n      }\n     else if(bf[m]=='*'){\n\tst[q-2]=st[q-2]*st[q-1];\n\tq--;\n      }\n     else if(bf[m]=='/'){\n\tst[q-2]=st[q-2]/st[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st[0]);\n    //printf(\"%s\\n\",bf);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,E[200];M(r){for(r=T();*p==42|*p==47;)*p++-42?(r/=T()):(r*=T());return r;}A(r){for(r=M();*p==43|*p==45;)*p++-43?(r-=M()):(r+=M());return r;}T(r,l){*p-40?sscanf(p,\"%d%n\",&r,&l):(++p,r=A(l=1));p+=l;return r;}main(){for(;~scanf(\"%*d\\n%[^=]=\\n\"+!!p*4,E);)printf(\"%d\\n\",A(p=E));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint p=0;\nint g(double a,int b,double c){\n  if(b==2)return a+c;\n  if(b==3)return a-c;\n  if(b==4)return a*c;\n  return a/c;\n}\ndouble f(){\n  int i,r=0,o[3];\n  double n[3],a;\n  char c[]={\")=+-*/\"};\n  while(1){\n    for(a=0;'0'<=s[p]&&s[p]<='9';p++)a=a*10+s[p]-'0';\n    if(s[p]=='('){\n      p++;\n      a=f();\n    }\n    for(i=0;s[p]-c[i];i++);\n    for(;r&&o[r-1]/2>=i/2;r--)a=g(n[r-1],o[r-1],a);\n    n[r]=a;\n    o[r++]=i;\n    p++;\n    if(i/2==0)return n[0];\n  }\n  return 0;\n}\n  \nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  while(n--){\n    p=0;\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",(int)f(s));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n \nint calc1();\nint calc2();\nint calc3();\n \nint p;\nstring eq;\n \nint calc1() {\n  int a = calc2();\n  while (eq[p]=='+' || eq[p]=='-') {\n    if (eq[p]=='+') {\n      p++;\n      a += calc2();\n    } else if (eq[p]=='-') {\n      p++;\n      a -= calc2();\n    }\n  }\n  return a;\n}\n \nint calc2() {\n  int a = calc3();\n  while (eq[p]=='*' || eq[p]=='/') {\n    if (eq[p]=='*') {\n      p++;\n      a *= calc3();\n    } else if (eq[p]=='/') {\n      p++;\n      a /= calc3();\n    }\n  }\n  return a;\n}\n \nint calc3() {\n  int a;\n  if (eq[p]=='(') {\n    p++;\n    a = calc1();\n    p++;\n  } else {\n    a = 0;\n    while (eq[p]>='0'&&eq[p]<='9') {\n      a *= 10;\n      a += eq[p++] - '0';\n    }\n  }\n  return a;\n}\n \nint main() {\n  int n, r;\n \n  cin >> n;\n  for (int i=0; i<n; i++) {\n    cin >> eq;\n    p = 0;\n    r = calc1();\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 1 Problem 0109\n\n#include <stdio.h>\n#include <string.h>\n\nint expression(char **form);\nint term(char **form);\nint factor(char **form);\n\nint main(void)\n{\n\tchar formula[101];\n\tint n;\n\tint i;\n\tchar *p;\n\tint result;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\"%s\", formula);\n\n\t\tp = formula;\n\t\tresult = expression(&p);\n\t\tprintf(\"%d\\n\", result);\n\t}\n\t\n\treturn (0);\n}\n\nint expression(char **form)\n{\n\tint result;\n\n\tresult = term(form);\n\t\n\twhile (1){\n\t\tif (**form == '+'){\n\t\t\t(*form)++;\n\t\t\tresult += term(form);\n\t\t}\n\t\telse if (**form == '-'){\n\t\t\t(*form)++;\n\t\t\tresult -= term(form);\n\t\t}\n\t\telse if (**form == '='){\n\t\t\t(*form)++;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (result);\n}\n\nint term(char **form)\n{\n\tint result;\n\t\n\n\tresult = factor(form);\n\t\n\twhile (1){\n\t\tif (**form == '*'){\n\t\t\t(*form)++;\n\t\t\tresult *= factor(form);\n\t\t}\n\t\telse if (**form == '/'){\n\t\t\t(*form)++;\n\t\t\tresult /= factor(form);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (result);\n}\n\nint factor(char **form)\n{\n\tint result;\n\t\n\tif (**form == '('){\n\t\t(*form)++;\n\t\tresult = expression(form);\n\t\t(*form)++;\t\t// skip ')'\n\t}\n\telse {\n\t\tresult = 0;\n\t\twhile ('0' <= **form && **form <= '9'){\n\t\t\tresult = result * 10 + **form - '0';\n\t\t\t(*form)++;\n\t\t}\n\t}\n\t\n\treturn (result);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n/** テヲツ閉ーテ・ツシツ湘」ツつ、テ」ツδ?」ツδャテ」ツδシテ」ツつソ */\nstatic const char *p;\n\nstatic int expression ( );\n\nstatic int\nfactor (\n  void\n  )\n{\n  int res = 0;\n\n  if ( *p == '(' )\n  {\n    ++p;\n    res = expression ( );\n    ++p;\n  }\n  else while ( isdigit ( *p ) )\n  {\n    res = res * 10 + ( *( p++ ) - '0' );\n  }\n\n  return ( res );\n}\n\nstatic int\nterm (\n  void\n  )\n{\n  int res = factor ( );\n\n  for ( ; ; )\n  {\n    switch ( *p )\n    {\n      case '*':\n        ++p;\n        res *= factor ( );\n        break ;\n      case '/':\n        ++p;\n        res /= factor ( );\n        break ;\n      default:\n        return ( res );\n    }\n  }\n}\n\nstatic int\nexpression (\n  void\n  )\n{\n  int res = term ( );\n\n  for ( ; ; )\n  {\n    switch ( *p )\n    {\n      case '+':\n        ++p;\n        res += term ( );\n        break ;\n      case '-':\n        ++p;\n        res -= term ( );\n        break ;\n      default:\n        return ( res );\n    }\n  }\n}\n\n/** テヲツ閉ーテ・ツシツ銃xpr テ」ツつ津ィツィツ暗ァツョツ療」ツ?凖」ツつ凝ッツシツ?*/\nstatic int\ncalculate (\n  const char *expr\n  )\n{\n  p = expr;\n\n  return\n  expression ( );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  /** ティツィツ暗ァツョツ療・ツッツセティツアツ。テ」ツ?ョテヲツ閉ーテ・ツシツ?*/\n  char expr[ 128 ];\n  /** テ・ツ?・テ・ツ環崚」ツ?ョテ・ツ?凝ヲツ閉ー */\n  int n;\n\n  scanf ( \"%d\", &n );\n  while ( n-- )\n  {\n    scanf ( \" %s\", expr );\n\n    printf ( \"%d\\n\", calculate ( expr ) );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEN 100\n\nint expr();\nint term();\nint fact();\nint number();\n\nconst char *p;\n\nint expr() {\n\tint result = term();\n\twhile(*p == '+' || *p == '-') {\n\t\tconst char operator = *p;\n\t\t++p;\n\t\tswitch(operator) {\n\t\tcase '+': result += term(); break;\n\t\tcase '-': result -= term(); break;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\treturn result;\n}\n\nint term() {\n\tint result = fact();\n\twhile(*p == '*' || *p == '/') {\n\t\tconst char operator = *p;\n\t\t++p;\n\t\tswitch(operator) {\n\t\tcase '*': result *= fact(); break;\n\t\tcase '/': result /= fact(); break;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\treturn result;\n\n}\n\nint fact() {\n\tif(*p == '-') {\n\t\t++p;\n\t\treturn -fact();\n\t}\n\telse if(*p == '(') {\n\t\t++p;\n\t\tconst int result = expr();\n\t\tassert(*p == ')');\n\t\t++p;\n\t\treturn result;\n\t}\n\telse if(isdigit(*p)) {\n\t\treturn number();\n\t}\n\telse {\n\t\tassert(false);\n\t}\n}\n\nint number() {\n\tint result = 0;\n\twhile(isdigit(*p)) {\n\t\tresult = result * 10 + (*p - '0');\n\t\t++p;\n\t}\n\treturn result;\n}\n\nint main() {\n\tchar input[MAX_LEN + 1];\n\tint i;\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor(i = 0; i < n; ++i) {\n\t\tscanf(\"%s\", input);\n\t\tp = input;\n\t\tconst int ans = expr();\n\t\tassert(*p == '=');\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128],c;\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<128;j++){\n      b[j]='\\0';\n      st[j]='\\0';\n    }\n\n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n    \n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n     else if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128],c;\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<128;j++){\n      b[j]='!';\n      st[j]='!';\n    }\n    \n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n\n    q=0;\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n     else if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint expr(char **s);\n\nint number(char **s) {\n  int val = 0;\n  while ('0' <= **s && **s <= '9') {\n    val = val * 10 + **s - '0';\n    (*s)++;\n  }\n  return val;\n}\n\nint factor(char **s) {\n  if (**s == '(') {\n    (*s)++;\n    int val = expr(s);\n    (*s)++;\n    return val;\n  }\n  return number(s);\n}\n\nint term(char **s) {\n  int val = factor(s);\n  while (1) {\n    if (**s == '*') {\n      (*s)++;\n      val *= factor(s);\n    } else if (**s == '/') {\n      (*s)++;\n      val /= factor(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint expr(char **s) {\n  int val = term(s);\n  while (1) {\n    if (**s == '+') {\n      (*s)++;\n      val += term(s);\n    } else if (**s == '-') {\n      (*s)++;\n      val -= term(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define TERMING { if(sign==0) term=term*x; else term=term/x; }\n\nint n,pp;\nchar exp[150];\n\nint culc(){\n\tint x=0,term=1,sum=0,sign=0;\n\twhile(1){\n\t\tswitch(exp[pp]){\n\t\t\tcase '*':\n\t\t\t\tTERMING\n\t\t\t\tsign=0;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tTERMING\n\t\t\t\tsign=1;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tTERMING\n\t\t\t\tsum+=term;\n\t\t\t\tterm=1;\n\t\t\t\tsign=0;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tTERMING\n\t\t\t\tsum+=term;\n\t\t\t\tterm=-1;\n\t\t\t\tsign=0;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tpp++;\n\t\t\t\tx=culc();\n\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\tcase'=':\n\t\t\t\tTERMING\n\t\t\t\tsum+=term;\n\t\t\t\treturn sum;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tx=x*10+exp[pp]-'0';\n\t\t\tbreak;\n\t\t}\n\t\tpp++;\n\t}\n}\n\nint main(){\n\tfor(scanf(\"%d\",&n);n>0;n--){\n\t\tscanf(\"%s\",exp);\n\t\tpp=0;\n\t\tprintf(\"%d\\n\",culc());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128],c;\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<128;j++){\n      b[j]='\\0';\n      st[j]='\\0';\n    }\n\n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n    /*\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n      if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n      if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n      if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n      if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    */\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar stk[50], psh[50];\nint v[50],pri[256], sp, pp;\n\nint calc(char *p) {\n  int i;\n  char *exp = p;\n  for (i = 0; i < 256; i++)\n    pri[i] = 3;\n  pri['+'] = pri['-'] = 1;\n  pri['*'] = pri['/'] = 2;\n  pri['('] = 4;\n  pri[')'] = 0;\n  stk[0] = 0;\n  pri[0] = -1;\n  sp = pp = 0;\n  while (*p != '\\0') {\n    while (pri[*p] <= pri[stk[sp]] && stk[sp] != '(')\n      psh[++pp] = stk[sp--];\n    if (*p != ')')\n      stk[++sp] = *p;\n    else\n      sp--;\n    p++;\n  }\n  for (i = sp; i > 0; i--)\n    psh[++pp] = stk[i];\n  sp = 0;\n  for (i = 1; i <= pp; i++) {\n    if ('0' <= psh[i] && psh[i] <= '9')\n      v[++sp] = psh[i] - '0';\n    else {\n      switch (psh[i]) {\n      case '+':\n        v[sp - 1] = v[sp - 1] + v[sp];\n        break;\n      case '-':\n        v[sp - 1] = v[sp - 1] - v[sp];\n        break;\n      case '*':\n        v[sp - 1] = v[sp - 1] * v[sp];\n        break;\n      case '/':\n        v[sp - 1] = v[sp - 1] / v[sp];\n        break;\n      }\n      sp--;\n    }\n  }\n  printf(\"%d\\n\",v[1]);\n}\n\nint main() {\n  int i, j, n;\n  char p[50][100];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++)\n    scanf(\"%s\", p[i]);\n  for (i = 0; i < n; i++)\n    for (j = 0; j < 100; j++)\n      if (p[i][j] == '=')\n        p[i][j] = '\\0';\n  for (i = 0; i < n; i++)\n    calc(p[i]);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint expr();\nint term();\nint fact();\nint number();\n\nchar s[200] = {};\nint idx = 0;\n\nint main(){\n\n  int dSetNum = 0;\n  int i = 0;\n\n  scanf(\"%d\", &dSetNum);\n  int answer[dSetNum + 1];\n  int answerNum = 0;\n\n  for(i = 0; i < dSetNum; i++){\n    idx = 0;\n    scanf(\"%s\", &s);\n    printf(\"%d\\n\", expr());\n    // answer[answerNum] = expr();\n  }\n\n  for(i = 0; i < answerNum; i++){\n    printf(\"%d\\n\", answer[i]);\n  }\n  return 0;\n}\n\nint expr(){\n  int res = term();\n  while(s[idx] == '+' || s[idx] == '-'){\n    char op = s[idx++];\n    int tmp = term();\n    if(op == '+')res += tmp;\n    else res -= tmp;\n  }\n\n  return res;\n}\n\nint term(){\n  int res = fact();\n   while(s[idx] == '*' || s[idx] == '/'){\n    char op = s[idx++];\n     int tmp = fact();\n     if(op == '*') res *= tmp;\n     else res /= tmp;\n   }\n   return res;\n}\n\nint fact(){\n  int res;\n  if(s[idx] == '('){\n    idx++; res = expr();\n    //assert( s[idx] == ')' );\n    idx++;\n  }\n  else{\n    res = number();\n  }\n  return res;\n}\n\nint number(){\n  int res = 0;\n  while('0' <= s[idx] && s[idx] <= '9'){\n    res = res * 10 + s[idx] - '0';\n    idx++;\n  }\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint p=0;\ndouble f(double a,int b,double c){\n  if(b==2)return a+c;\n  if(b==3)return a-c;\n  if(b==4)return a*c;\n  return a/c;\n}\nint kobun(){\n  int i,r=0,o[3],or[]={0,0,1,1,2,2};\n  int n[3],a;\n  char c[]={\")=+-*/\"};\n  while(1){\n    for(a=0;'0'<=s[p]&&s[p]<='9';p++)a=a*10+s[p]-'0';\n    if(s[p]=='('){\n      p++;\n      a=kobun();\n    }\n    for(i=0;s[p]-c[i];i++);\n    for(;r&&or[o[r-1]]>=or[i];r--)a=f(n[r-1],o[r-1],a);\n    n[r]=a;\n    o[r++]=i;\n    p++;\n    if(or[i]==0)return n[0];\n  }\n  return 0;\n}\nint main(){\n  int n;\n  for(scanf(\"%d\",&n);n--;p=0){\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",kobun());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint r,b,q[100];\nchar s[101];\nvoid f(int e){\n  int i,c=0,j;\n  for(i=e;i<r;i++){//printf(\"%c \",s[i]);\n    if(s[i]=='*'){\n      q[i+1]=q[i]*q[i+1];\n      c++;\n    }\n    else if(s[i]=='/'){\n      q[i+1]=q[i]/q[i+1];\n      c++;\n    }\n    else {\n      //if(s[i]=='=')return;\n      s[i-c]=s[i];\n      q[i-c]=q[i];\n    }\n  }if(s[0]=='=')return ;\n  r-=c;//printf(\"\\n\\nq:\");\n  //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\ns:\");\n  //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n  //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");  \n  for(i=e;i<r;i++){\n    if(s[i]=='+')q[i+1]=q[i]+q[i+1];\n    if(s[i]=='-')q[i+1]=q[i]-q[i+1];\n  }\n  q[e]=q[r-1];\n  b+=r-e;\n  r=e+1;\n  return;\n}\nint main(){\n  int m,n=0,i,c=-1,kr=0,k[100],j;\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",s);\n    for(i=r=b=kr=0;s[i];i++){\n      if('0'<=s[i]&&s[i]<='9'){\n\tn*=10;\n\tn+=s[i]-'0';\n\tc++;\n      }\n      else {\n\tb++;\n\tif(s[i]=='(')k[kr++]=r;\n\telse{\n\t  q[r++]=n;\n\t  n=0;\n\t  b+=c;\n\t  c=-1;\n\t  if(s[i]==')')f(k[--kr]);\n\t  else s[i-b]=s[i];\n\t}\n      }//printf(\"q:\");\n      //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\nk:\");\n      //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n      //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");\n    }\n    f(0);//printf(\"\\nq:\");\n    //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\nk:\");\n    //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n    //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");\n    printf(\"%d\\n\",q[0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0109: Smart Calculator\n// 2017.8.5\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX 200\n#define INF   1000000010\n#define LEFT (INF+1)\n#define RIGHT (INF+2)\n#define PLUS (INF+3)\n#define MINUS (INF+4)\n#define MUL (INF+5)\n#define DIV (INF+6)\n\nchar *gets(char *);\nchar buf[200], *p;\nint S[MAX + 3], top;\nint Q[MAX + 3], end;\n\nint getInt(void)\n{\n\tint n = 0;\n//\twhile (isspace(*p)) p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nint token(char c)\n{\n\tif (c == '+') return PLUS;\n\tif (c == '-') return MINUS;\n\tif (c == '*') return MUL;\n\treturn DIV;\n}\n\nint main()\n{\n\tint i, f, k, d1, d2;\n\tint cno, cmax;\n\n\tgets(p = buf); cmax = getInt();\n\tfor (cno = 0; cno < cmax; cno++) {\n\t\tgets(p = buf), f = 1, top = 0, end = 0;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (!*p || *p == '=') {\n\t\t\t\twhile (top) Q[end++] = S[--top];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '-' && f && isdigit(*(p + 1))) {\n\t\t\t\tp++;\n\t\t\t\tQ[end++] = -getInt();\n\t\t\t\tf = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = 0;\n\t\t\tif (isdigit(*p)) Q[end++] = getInt();\n\t\t\telse if (*p == ')') {\n\t\t\t\twhile (S[top - 1] != LEFT) Q[end++] = S[--top];\n\t\t\t\ttop--, p++;\n\t\t\t}\n\t\t\telse if (*p == '(') S[top++] = LEFT, p++, f = 1;\n\t\t\telse {\n\t\t\t\tk = token(*p++);\n\t\t\t\twhile (top) {\n\t\t\t\t\tif (k < S[top - 1]) Q[end++] = S[--top];\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tS[top++] = k;\n\t\t\t}\n\t\t}\n#if 0\n\t\tfor (i = 0; i < end; i++) printf(\"%d \", Q[i]);\n\t\tprintf(\"\\n\");\n#endif\n\t\tfor (top = i = 0; i < end; i++) {\n\t\t\tif ((k = Q[i]) > INF) {\n\t\t\t\td1 = S[--top], d2 = S[--top];\n\t\t\t\tif (k == PLUS) d2 += d1;\n\t\t\t\telse if (k == MINUS) d2 -= d1;\n\t\t\t\telse if (k == MUL) d2 *= d1;\n\t\t\t\telse d2 /= d1;\n\t\t\t\tS[top++] = d2;\n\t\t\t} else S[top++] = k;\n\t\t}\n\t\tif (top != 1) while (1);\n\t\tprintf(\"%d\\n\", S[--top]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,s[999];t();f();e(x){for(x=t(0);*p&&*p<46;)x+=*p++%5?t(0):-t(0);return x;}t(x){for(x=f(0);*p%5==2;x*=f(0))++p;return x;}f(x){return*p<41?++p,x=e(0),++p,x:*p<44?f(0):*p<46?-f(0)strtol(p,&p,0);}main(i){for(;~scanf(\"%s\",p=s);)--i&&printf(\"%d\\n\",e(0));}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<string>\nusing namespace std;\nint i;\nstring str;\nint Expression();\nint Term();\nint Factor();\nint No(int);\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> str;\n    i = 0;\n    cout << Expression() << endl;\n  }\n}\nint Expression(){\n  int res = Term();\n  while(1){\n    switch(str[i]){\n    case '+':\n      i++;\n      res += Term();\n      break;\n    case '-':\n      i++;\n      res -= Term();\n      break;\n    default:\n      return res;\n    }\n  }\n}\nint Term(){\n  int res = Factor();\n  while(true){\n    switch(str[i]){\n    case '(':\n      i++;\n      res += Factor();\n      break;\n    case '*':\n      i++;\n      res *= Factor();\n      break;\n    case '/':\n      i++;\n      res /= Factor();\n      break;\n    default:\n      return res;\n    }\n  }\n}\nint Factor(){\n  int res = 0;\n  switch(str[i]){\n  case '(':\n    i++;\n    res = Expression();\n    i++;\n    return res;\n  default:\n    return No(i);\n  }\n}\nint No(int old){\n  while(isdigit(str[i])) i++;\n  return atoi((str.substr(old,i)).c_str());\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define STRMAX 101\n\nint parseerror( char c );\nint expression();\nint term();\nint number();\nint factor();\n\nchar str[STRMAX] = {}, *tp;\n\nint parseerror( char c )\n{\n\tprintf( \"[ERROR] Parser cant parse %c\\n\", c );\n\treturn -1;\n}\n\n\n// B;MB'1i;;$N<0$r%Q!<%9$7$FCM$rJV$9\nint expression()\n{\n\tint ret = term();\n\n\tfor ( ; ; ) {\n\t\tif ( *tp == '+' ) {\n\t\t\ttp++;\n\t\t\tret += term();\n\t\t} else if ( *tp == '-' ) {\n\t\t\ttp++;\n\t\t\tret -= term();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n// B>h;;=|;;$N<0$r%Q!<%9$7$FCM$rJV$9\nint term()\n{\n\tint ret = factor();\n\tfor ( ; ; ) {\n\t\tif ( *tp == '*' ) {\n\t\t\ttp++;\n\t\t\tret *= factor();\n\t\t} else if ( *tp == '/' ) {\n\t\t\ttp++;\n\t\t\tret /= factor();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n// B?t;z$NNs$r%Q!<%9$7$FCM$rJV$9\nint number()\n{\n\tint ret = 0;\n\twhile ( isdigit( *tp ) ) {\n\t\tret *= 10;\n\t\tret += *tp - '0';\n\t\ttp++;\n\t}\n\treturn ret;\n}\n\n// B3g8LIU$-J8;zNs$r%Q!<%9$9$k\nint factor()\n{\n\tint ret;\n\tif ( *tp == '(' ) {\n\t\ttp++;\n\t\tret = expression();\n\t\ttp++; // )B$rHt$P$9\n\t} else {\n\t\tret = number();\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tint answer = 0;\n\n\tscanf( \"%d\\n\", &n );\n\twhile ( n > 0 ) {\n\t\tfgets( str, 100, stdin );\n\t\ttp = str;\n\t\tanswer = expression();\t\n\t\tprintf( \"%d\\n\", answer );\t\n\t\tn--;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define N 128\n#define ADD -1\n#define SUB -2\n#define MUL -3\n#define DIV -4\n#define ESC -5\n#define LPR -6\n#define RPR -7\n\nstatic\nint * e;\n\nstatic\nint eval_1st ( void ),\n    eval_2nd ( void ),\n    eval_3rd ( void );\n\nstatic\nint eval_1st (\n  void\n  )\n{\n  if ( *e == LPR )\n  {\n    int res;\n\n    ++e;\n    res = eval_3rd ( );\n    ++e;\n    return ( res );\n  }\n  else\n  {\n    return ( *( e++ ) );\n  }\n}\n\nstatic\nint eval_2nd (\n  void\n  )\n{\n  int left = eval_1st ( );\n\n  while ( *e == MUL || *e == DIV )\n  {\n    ++e;\n    if ( e[ -1 ] == MUL ) left *= eval_1st ( );\n    else                  left /= eval_1st ( );\n  }\n\n  return ( left );\n}\n\nstatic\nint eval_3rd (\n  void\n  )\n{\n  int left = eval_2nd ( );\n\n  while ( *e == ADD || *e == SUB )\n  {\n    ++e;\n    if ( e[ -1 ] == ADD ) left += eval_2nd ( );\n    else                  left -= eval_2nd ( );\n  }\n\n  return ( left );\n}\n\nstatic\nint eval (\n  void\n  )\n{\n  return ( eval_3rd ( ) );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int n;\n\n  scanf ( \"%d \", &n );\n  while ( n-- )\n  {\n    int   expr[ N ] = { 0 };\n    int * p = expr;\n\n    for ( ; ; )\n    {\n      int ch = ' ';\n\n      while ( isspace ( ch ) )  ch = getchar ( );\n\n      switch ( ch )\n      {\n        case '+':   ++p; *( p++ ) = ADD; break;\n        case '-':   ++p; *( p++ ) = SUB; break;\n        case '*':   ++p; *( p++ ) = MUL; break;\n        case '/':   ++p; *( p++ ) = DIV; break;\n        case '=':   ++p; *( p++ ) = ESC; goto BREAKK;\n        case '(':        *( p++ ) = LPR; break;\n        case ')':   ++p; *( p++ ) = RPR; break;\n        default:\n          *p = *p * 10 + ( ch - '0' );\n          break;\n      }\n    }\nBREAKK:\n    e = expr;\n    printf ( \"%d\\n\", eval ( ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "char*p;l;M(r){for(r=T();*p==42|*p==47;)*p++-42?r/=T():(r*=T());return r;}A(r){for(r=M();*p==43|*p==45;)r+=*p++-43?-M():M();return r;}T(r){*p==40?r=A(++p),l=1:sscanf(p,\"%d%n\",&r,&l);p+=l;return r;}main(_,E){for(;~scanf(\"%*d\\n%[^=]=\\n\"+!!p*4,E);)printf(\"%d\\n\",A(p=E));}"
  },
  {
    "language": "C",
    "code": "char*p,E[200];M(){int r;r=T();for(;;){if(*p=='*'){p++;r*=T();}else if(*p=='/'){p++;r/=T();}elsereturn r;}}A(){int r;r=M();for(;;){if(*p=='+'){p++;r+=M();}else if(*p=='-'){p++;r-=M();}elsereturn r;}}T(){int r,l;if(*p=='('){p++;r=A();p++;}else{sscanf(p,\"%d%n\",&r,&l);p+=l;}return r;}main(){scanf(\"%*d\\n\");for(;~scanf(\"%[^=]=\\n\",E);){p=E;printf(\"%d\\n\",A());}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf(), fgets()\n#include <stdlib.h>         // strtol(), exit()\n#include <stdbool.h>\n\ntypedef struct token_tbl\n{\n\tchar kind;\n\tint value;\n} token_t;\n\nstruct token_stream_tbl\n{\n\tbool full;\n\ttoken_t buffer;\n} ts;\n\ntoken_t token;\nconst char *s;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nvoid\nts_get()\n{\n\tchar *nextp = NULL;\n\n\tif (ts.full)\n\t{\n\t\tts.full = false;\n\t\ttoken = ts.buffer;\n\t\treturn;\n\t}\n\n\tswitch (*s)\n\t{\n\tcase '(':\n\tcase ')':\n\tcase '+':\n\tcase '-':\n\tcase '*':\n\tcase '/':\n\tcase '=':\n\tcase '\\n':\n\tcase '\\0':\n\t\ttoken.kind = *s;\n\t\ts++;\n\t\treturn;\n\n\tdefault:\n\t\ttoken.kind = '9';\n\t\ttoken.value = strtol(s, &nextp, 10);\n\t\ts = nextp;\n\t\treturn;\n\t}\n}\n\nvoid\nts_unget()\n{\n\tts.full = true;\n\tts.buffer = token;\n}\n\nint expression();\n\nint\nprimary()\n{\n\tts_get();\n\tswitch(token.kind)\n\t{\n\tcase '(':\n\t  {\n\t\tint d = expression();\n\t\tts_get();\n\t\tif(token.kind != ')')\n\t\t{\n\t\t\tfprintf(stderr, \"'(' expected\\n\");\n\t\t\tcleanup(1);\n\t\t}\n\n\t\treturn (d);\n\t  }\n\n\tcase '-':\n\t\treturn (-primary());\n\n\tcase '9':\n\t\treturn (token.value);\n\n\tdefault:\n\t\tfprintf(stderr, \"primary expected\\n\");\n\t\tcleanup(1);\n\t\treturn 0;\n\t}\n}\n\nint\nterm()\n{\n\tint left = primary();\n\twhile(true)\n\t{\n\t\tts_get();\n\t\tswitch(token.kind)\n\t\t{\n\t\tcase '*':\n\t\t\tleft *= primary();\n\t\t\tbreak;\n\n\t\tcase '/':\n\t\t  {\n\t\t\tint d = primary();\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"divide by zero\\n\");\n\t\t\t\tcleanup(1);\n\t\t\t}\n\n\t\t\tleft /= d;\n\t\t\tbreak;\n\t\t  }\n\n\t\tdefault:\n\t\t\tts_unget();\n\t\t\treturn(left);\n\t\t}\n\t}\n}\n\nint\nexpression()\n{\n\tint left = term();\n\twhile(true)\n\t{\n\t\tts_get();\n\t\tswitch(token.kind)\n\t\t{\n\t\tcase '+':\n\t\t\tleft += term();\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tleft -= term();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tts_unget();\n\t\t\treturn(left);\n\t\t}\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\tchar line[101];\n\tint n;\n\n\tscanf(\"%d\\n\", &n);\n\twhile (n--)\n\t{\n\t\tfgets(line, sizeof(line), stdin);\n\t\tts.full = false;\n\t\ts = line;\n\t\tprintf(\"%d\\n\", expression());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint p=0;\ndouble f(double a,int b,double c){\n  if(b==2)return a+c;\n  if(b==3)return a-c;\n  if(b==4)return a*c;\n  return a/c;\n}\nint kobun(){\n  int i,r=0,o[3];\n  int n[3],a;\n  char c[]={\")=+-*/\"};\n  while(1){\n    for(a=0;'0'<=s[p]&&s[p]<='9';p++)a=a*10+s[p]-'0';\n    if(s[p]=='('){\n      p++;\n      a=kobun();\n    }\n    for(i=0;s[p]-c[i];i++);\n    for(;r&&o[r-1]/2>=i/2;r--)a=f(n[r-1],o[r-1],a);\n    n[r]=a;\n    o[r++]=i;\n    p++;\n    if(i/2==0)return n[0];\n  }\n  return 0;\n}\nint main(){\n  int n;\n  for(scanf(\"%d\",&n);n--;p=0){\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",kobun());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <strings.h>\n#include <stdio.h>\n#include <ctype.h>\n\nchar str[101];\nint tindex=0;\nint map[255];\nint token;\n\nint addminus();\n\nvoid getToken(void) {\n    int r = 0;\n    if (isdigit(str[tindex])) {\n\twhile (isdigit(str[tindex])) {\n\t    r = r*10+(str[tindex++]-'0');\n\t}\n\ttoken = r;\n    } else {\n\ttoken = map[(int)str[tindex++]];\n    }\n}\n\nint terminal() {\n    int result = 0;\n    if (token == -5) {\n\tgetToken();\n\tresult = addminus();\n\tgetToken();\n    } else if (token >= 0) {\n\tresult = token;\n\tgetToken();\n    }\n    return result;\n}\n\nint multidiv() {\n    int result = terminal();\n    while (token == -3 || token == -4) {\n\tif (token == -3) {\n\t    getToken();\n\t    result *= terminal();\n\t} else {\n\t    getToken();\n\t    result /= terminal();\n\t}\n    }\n    return result;\n}\n \nint addminus() {\n    int result = multidiv();\n    while (token == -1 || token == -2) {\n\tif (token == -1) {\n\t    getToken();\n\t    result += multidiv();\n\t} else {\n\t    getToken();\n\t    result -= multidiv();\n\t}\n    }\n    return result;\n}\n \nint main(void) {\n    int i, n, total;\n\n    map['+'] = -1;\n    map['-'] = -2;\n    map['*'] = -3;\n    map['/'] = -4;\n    map['('] = -5;\n    map[')'] = -6;\n    map['='] = -7;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n\tscanf(\"%s\", str);\n\tgetToken();\n\ttotal=addminus();\n\tprintf(\"%d\\n\", total);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct T{int typ,num;}T;\nint N;\nchar S[105];\n\nint calc(T *st,int len)\n{\n\tint i,np=0,op=0,CST[100];\n\tT NST[100],OST[100];\n\tfor(i=0;i<len;i++)\n\t{\n\t\tif(st[i].typ==1)\n\t\t{\n\t\t\tswitch(st[i].num)\n\t\t\t{\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\t\tif(OST[op-1].num=='*'||OST[op-1].num=='/')\n\t\t\t\t{\n\t\t\t\t\tNST[np++]=OST[op-1];\n\t\t\t\t\top--;\n\t\t\t\t}\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\tOST[op++]=st[i];break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNST[np++]=st[i];\n\t\t}\n\t}\n\tfor(i=op-1;i>=0;i--)\n\t{\n\t\tNST[np++]=OST[i];\n\t}\n\n\tfor(i=np=0;i<len;i++)\n\t{\n\t\tif(NST[i].typ)\n\t\t{\n\t\t\tswitch(NST[i].num)\n\t\t\t{\n\t\t\tcase '+':CST[np-2]=CST[np-2]+CST[np-1];np--;break;\n\t\t\tcase '-':CST[np-2]=CST[np-2]-CST[np-1];np--;break;\n\t\t\tcase '*':CST[np-2]=CST[np-2]*CST[np-1];np--;break;\n\t\t\tcase '/':CST[np-2]=CST[np-2]/CST[np-1];np--;break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tCST[np++]=NST[i].num;\n\t}\n\treturn CST[0];\n}\n\n\nint dfs(int s,int e)\n{\n\tint i,j,c,t,p=0;\n\tchar d[100],t2;\n\tT st[100];\n\tfor(i=s;i<=e;)\n\t{\n\t\tif(S[i]=='(')\n\t\t{\n\t\t\tfor(j=i+1,c=1;c!=0;j++)\n\t\t\t{\n\t\t\t\tif(S[j]=='(')c++;\n\t\t\t\telse if(S[j]==')')c--;\n\t\t\t}\n\t\t\tt=dfs(i+1,j-2);\n\t\t\tst[p].typ=0;\n\t\t\tst[p].num=t;\n\t\t\tp++;\n\t\t\ti=j;\n\t\t}\n\t\telse if('0'<=S[i]&&S[i]<='9')\n\t\t{\n\t\t\tsscanf(S+i,\"%d\",&t);\n\t\t\tst[p].typ=0;\n\t\t\tst[p].num=t;\n\t\t\tp++;\n\t\t\ti+=sprintf(d,\"%d\",t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsscanf(S+i,\"%c\",&t2);\n\t\t\tst[p].typ=1;\n\t\t\tst[p].num=t2;\n\t\t\tp++;\n\t\t\ti++;\n\t\t}\n\t}\n\tt=calc(st,p);\n\treturn t;\n}\n\nint main()\n{\n\tscanf(\"%d\\n\",&N);\n\tfor(;N--;)\n\t{\n\t\tgets(S);\n\t\tprintf(\"%d\\n\",dfs(0,strlen(S)-2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[100100];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        res = addsub(idx + 1);\n    }\n    else if (formula[idx] == '-'){\n        res = -number(idx + 1);\n    }\n    else {\n        while (isdigit(formula[idx])){\n            res = res * 10 + formula[idx] - '0';\n            ++idx;\n        }\n    }\n    //printf(\"   %d\\n\", res);\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    ++idx;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (!isdigit(formula[idx]) && !brackets){\n            break;\n        }\n        ++idx;\n    }\n    //printf(\"  %d\\n\", res);\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int first = 1;\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n        }\n        else if (formula[idx] == '-' && !brackets && !first){\n            res -= muldiv(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            if (!brackets){\n                break;\n            }\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n        first = 0;\n    }\n    //printf(\" %d\\n\", res);\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,s[999];t();f();e(x){for(x=t(0);*p&&*p<46;)x+=*p++%5?t(0):-t(0);return x;}t(x){for(x=f(0);*p%5==2;x*=f(0))++p;return x;}f(x){return*p<41?++p,x=e(0),++p,x:*p<46?*p++%5?f(0):-f(0):strtol(p,&p,10);}main(i){for(;~scanf(\"%s\",p=s);)--i&&printf(\"%d\\n\",e(0));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint p=0;\nint g(int a,int b,int c){\n  if(b==2)return a+c;\n  if(b==3)return a-c;\n  if(b==4)return a*c;\n  return a/c;\n}\nint f(){\n  int i,r=0,o[3];\n  int n[3],a;\n  char c[]={\")=+-*/\"};\n  while(1){\n    for(a=0;'0'<=s[p]&&s[p]<='9';p++)a=a*10+s[p]-'0';\n    if(s[p]=='('){\n      p++;\n      a=f();\n    }\n    for(i=0;s[p]-c[i];i++);\n    for(;r&&o[r-1]/2>=i/2;r--)a=g(n[r-1],o[r-1],a);\n    n[r]=a;\n    o[r++]=i;\n    p++;\n    if(i/2==0)return n[0];\n  }\n  return 0;\n}\n  \nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  while(n--){\n    p=0;\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",f(s));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128],c;\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<128;j++){\n      b[j]='\\0';\n      st[j]='\\0';\n    }\n\n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n    q=0;\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n     else if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "char*p,s[999];t();f();e(x){for(x=t(0);*p&&*p<46;)x+=*p++%5?t(0):-t(0);return x;}t(x){for(x=f(0);*p%5==2;x*=f(0))++p;return x;}f(x){return*p<41?++p,x=e(0),++p,x:*p<46?++p,*p%5?f(0):-f(0):strtol(p,&p,0);}main(i){for(;~scanf(\"%s\",p=s);)--i&&printf(\"%d\\n\",e(0));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar formula[101];\nint p;\n\nint additive() {\n  int result = multitive();\n  while (formula[p] == '+' || formula[p] == '-')\n    if (formula[p++] == '+')\n      result += multitive();\n    else\n      result -= multitive();\n  return result;\n}\n\nint multitive() {\n  int result = term();\n  while (formula[p] == '*' || formula[p] == '/')\n    if (formula[p++] == '*')\n      result *= term();\n    else\n      result /= term();\n  return result;\n}\n\nint term() {\n  int result = 0;\n  if (formula[p] == '(') {\n    p++;\n    result = additive();\n    p++;\n  } else while ('0' <= formula[p] && formula[p] <= '9')\n    result = result * 10 + formula[p++] - '0';\n  return result;\n}\n\nint main() {\n  int i, n;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%s\", formula);\n    p = 0;\n    printf(\"%d\\n\", additive());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define CALC {if(sign==0) term=term*x; else term=term/x;}\n\nint num;\nchar str[101];\n\nint smartCalc(){\n  int sum=0, term=1, sign=0, x=0;\n  while(1){\n    switch(str[num]){\n    case '*':\n      CALC;\n      sign=0;\n      x=0;\n      break;\n    case '/':\n      CALC;\n      sign=1;\n      x=0;\n      break;\n    case '+':\n      CALC;\n      sum += term;\n      term=1;\n      sign = 0;\n      x =0;\n      break;\n    case '-':\n      CALC;\n      sum += term;\n      term = -1;\n      sign = 0;\n      x=0;\n      break;\n    case '(':\n      num += 1;\n      x = smartCalc();\n      break;\n    case ')':\n    case '=':\n      CALC;\n      sum += term;\n      return sum;\n      break;\n    default:\n      x = x*10 + str[num] - '0';\n    }\n    num += 1;\n  }\n}\nint main(){\n  int n, i;\n  scanf(\"%d\", &n);\n  for(i=0; i<n; i++){\n    scanf(\"%s\", str);\n    num=0;\n    printf(\"%d\\n\", smartCalc());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint p=0;\ndouble f(double a,int b,double c){\n  if(b==2)return a+c;\n  if(b==3)return a-c;\n  if(b==4)return a*c;\n  return a/c;\n}\nint kobun(){\n  int i,r=0,o[3],or[]={0,0,1,1,2,2};\n  int n[3],a;\n  char c[]={\")=+-*/\"};\n  while(1){\n    for(a=0;'0'<=s[p]&&s[p]<='9';p++)a=a*10+s[p]-'0';\n    if(s[p]=='('){\n      p++;\n      a=kobun();\n    }\n    for(i=0;s[p]-c[i];i++);\n    for(;r&&o[r-1]>=or[i];r--)a=f(n[r-1],o[r-1],a);\n    n[r]=a;\n    o[r++]=or[i];\n    p++;\n    if(or[i]==0)return n[0];\n  }\n  return 0;\n}\nint main(){\n  int n;\n  for(scanf(\"%d\",&n);n--;p=0){\n    scanf(\"%s\",s);\n    printf(\"%d\\n\",kobun());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<string.h>\n#include<stdlib.h>\n\nint expression(char *);\nint term(char *);\nint factor(char *);\nint number(char *);\n\nint main(void){\nint N,i;\nchar s[100000];\nchar *begin;\n scanf(\"%d\",&N);\n scanf(\"%c\",&s[0]);\n\n for(i=0;i<N;i++){\n   scanf(\"%[^\\n]%*c\",s);\n//printf(\"%s\",s);\n    begin=s;\n    int ans=expression(begin);\nprintf(\"%d\\n\",ans);\n }\nreturn 0;\n}\n\nint expression(char *begin){\n  int ret=term(begin);\n  \n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint  term(char *begin){\n int ret=factor(begin); printf(\"%d\\n\",ret);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(char *begin){\n\n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n  return ret;\n  }\n  else return number(begin);\n}\n\nint number(char *begin){\n  int ret=0;\n\n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=atoi(*begin);\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\ntypedef const char *state;\n\nint expr(state *p);\nint term(state *p);\nint factor(state *p);\nint number(state *p);\n\nint expr(state *p) {\n  int val = term(p);\n  while (1) {\n    if (**p == '+') {\n      (*p)++;\n      val += term(p);\n    } else if (**p == '-') {\n      (*p)++;\n      val -= term(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(state *p) {\n  int val = factor(p);\n  while (1) {\n    if (**p == '*') {\n      (*p)++;\n      val *= factor(p);\n    } else if (**p == '/') {\n      (*p)++;\n      val /= factor(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(state *p) {\n  if (**p == '(') {\n    (*p)++;\n    int val = expr(p);\n    (*p)++;\n    return val;\n  }\n  return number(p);\n}\n\nint number(state *p) {\n  int val = 0;\n  while ('0' <= **p && **p <= '9') {\n    val *= 10;\n    val += **p - '0';\n    (*p)++;\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  char s[101];\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%s\", s);\n    state p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum command_type {\n\tVALUE = 0x2,\n\tOP_ADD = 0x4,\n\tOP_SUB = 0x5,\n\tOP_MUL = 0x8,\n\tOP_DIV = 0x9\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tint value;\n\tstruct command_t *next;\n};\ntypedef struct command_t Command;\n\nvoid expression(void);\n\nchar g_tokens[100][100];\nchar *g_symbol;\nint g_index;\nCommand *g_commands = NULL;\n\nvoid command_append(CommandType type, int value) {\n\tCommand *tmp, *new;\n\n\tnew = malloc(sizeof(Command));\n\tnew->type = type;\n\tnew->value = value;\n\tnew->next = NULL;\n\tif (g_commands == NULL) {\n\t\tg_commands = new;\n\t} else {\n\t\tfor (tmp = g_commands; tmp->next != NULL; tmp = tmp->next);\n\t\ttmp->next = new;\n\t}\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_index++];\n}\n\nvoid factor(void) {\n\tint value;\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tvalue = atoi(g_symbol);\n\t\tcommand_append(VALUE, value);\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tCommand *cmd, *tmp;\n\n\tg_index = 0;\n\tfor (cmd = g_commands; cmd != NULL;) {\n\t\ttmp = cmd;\n\t\tcmd = cmd->next;\n\t\tfree(tmp);\n\t}\n\tg_commands = NULL;\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n}\n\n\nvoid tokenize(char *in) {\n\tint digit, n, i;\n\n\tdigit = n = i = 0;\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t\tdigit = 1;\n\t\t} else {\n\t\t\tif (digit) {\n\t\t\t\tn++;\n\t\t\t\tdigit = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint run(void) {\n\tint stack[100];\n\tint top = -1, buf;\n\tCommand *cmd;\n\n\tfor (cmd = g_commands; cmd != NULL; cmd = cmd->next) {\n\t\tif (cmd->type == VALUE) {\n\t\t\tstack[++top] = cmd->value;\n\t\t} else if (cmd->type == OP_ADD) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] += buf;\n\t\t} else if (cmd->type == OP_SUB) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] -= buf;\n\t\t} else if (cmd->type == OP_MUL) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] *= buf;\n\t\t} else if (cmd->type == OP_DIV) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] /= buf;\n\t\t}\n\t}\n\treturn stack[top];\n}\n\nint main(void) {\n\tint n, i;\n\tchar in[128];\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tg_tokens[i][0] = '\\0';\n\t\t}\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%d\\n\", run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum command_type {\n\tVALUE = 0x2,\n\tOP_ADD = 0x4,\n\tOP_SUB = 0x5,\n\tOP_MUL = 0x8,\n\tOP_DIV = 0x9,\n\tEND = 0xffff\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tint value;\n};\ntypedef struct command_t Command;\n\nvoid expression(void);\n\nchar g_tokens[128][128];\nchar *g_symbol;\nint g_index;\nCommand g_commands[128];\nint g_cmd_idx = 0;\n\nvoid command_append(CommandType type, int value) {\n\tCommand *new;\n\n\tnew = &g_commands[g_cmd_idx];\n\tnew->type = type;\n\tnew->value = value;\n\tg_cmd_idx++;\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_index++];\n}\n\nvoid factor(void) {\n\tint value;\n\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tvalue = atoi(g_symbol);\n\t\tcommand_append(VALUE, value);\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tg_index = 0;\n\tg_cmd_idx = 0;\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n\tcommand_append(END, 0);\n}\n\n\nvoid tokenize(char *in) {\n\tint digit, n, i;\n\n#if 0\n\tfor (i = 0; i < 128; i++) {\n\t\tg_tokens[i][0] = '\\0';\n\t}\n#endif\n\n\tdigit = n = i = 0;\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t\tdigit = 1;\n\t\t} else {\n\t\t\tif (digit) {\n\t\t\t\tn++;\n\t\t\t\tdigit = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n\tg_tokens[n][0] = '\\0';\n}\n\nlong long\nint run(void) {\n\tlong long\n\tint stack[128];\n\tint top = -1, buf;\n\tCommand *cmd;\n\tint i;\n\n\tfor (i = 0; g_commands[i].type != END; i++) {\n\t\tcmd = &g_commands[i];\n\t\t//for (cmd = g_commands; cmd != NULL; cmd = cmd->next) {\n\t\tif (cmd->type == VALUE) {\n\t\t\tstack[++top] = cmd->value;\n\t\t} else if (cmd->type == OP_ADD) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] += buf;\n\t\t} else if (cmd->type == OP_SUB) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] -= buf;\n\t\t} else if (cmd->type == OP_MUL) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] *= buf;\n\t\t} else if (cmd->type == OP_DIV) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] /= buf;\n\t\t}\n\t}\n\treturn stack[top];\n}\n\nint main(void) {\n\t//int n, i;\n\tint n;\n\tchar in[128];\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%lld\\n\", run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstatic char s[1024];\nstatic int sp;\n\nint term(void);\nint factor(void);\nint expr(void);\nint nextInt2();\nint nextInt();\n\nint main(void)\n{int i, n;\nscanf(\"%d\",&n);\nfor (i = 0; i < n; i++) {\nsp = 0;\n  scanf(\" %s\",s);\n\n  printf(\"%d\\n\",expr());\n}\n  return 0;\n\n}\n\nint nextInt(void)\n{\n    int tmp;\n    tmp = s[sp] - '0';\n    sp++;\n    return tmp;\n}\n\nint nextInt2(void)\n{\n    if (s[sp] == '-') {\n        sp++;\n        return nextInt() * -1;\n    } else {\n        return nextInt();\n    }\n}\n\nint term(void)\n{\n  if(s[sp]=='('){\n    int res;\n    sp++; \n    res = expr();\n    sp++;\n    return res;\n  }\n  return nextInt2();\n}\n\nint factor(void)\n{\n  int res = term();\n  while(1) {\n    if(s[sp]=='*'){\n      sp++; res *= term();\n    } else if(s[sp]=='/'){\n      sp++; res /= term();\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nint expr(void)\n{\n  int res = factor();\n  while(1){\n    if(s[sp]=='+') {\n      sp++; res += factor();\n    } else if(s[sp]=='-') {\n      sp++; res -= factor();\n    } else {\n      break;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum command_type {\n\tVALUE = 0x2,\n\tOP_ADD = 0x4,\n\tOP_SUB = 0x5,\n\tOP_MUL = 0x8,\n\tOP_DIV = 0x9,\n\tEND = 0xffff\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tint value;\n};\ntypedef struct command_t Command;\n\nvoid expression(void);\n\nchar g_tokens[128][30];\nchar *g_symbol;\nint g_index;\nCommand g_commands[128];\nint g_cmd_idx = 0;\n\nvoid command_append(CommandType type, int value) {\n\tCommand *new;\n\n\tnew = &g_commands[g_cmd_idx];\n\tnew->type = type;\n\tnew->value = value;\n\tg_cmd_idx++;\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_index++];\n}\n\nvoid factor(void) {\n\tint value;\n\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tvalue = atoi(g_symbol);\n\t\tcommand_append(VALUE, value);\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tg_index = 0;\n\tg_cmd_idx = 0;\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n\tcommand_append(END, 0);\n}\n\n\nvoid tokenize(char *in) {\n\tint digit, n, i;\n\n#if 0\n\tfor (i = 0; i < 128; i++) {\n\t\tg_tokens[i][0] = '\\0';\n\t}\n#endif\n\n\tdigit = n = i = 0;\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t\tdigit = 1;\n\t\t} else {\n\t\t\tif (digit) {\n\t\t\t\tn++;\n\t\t\t\tdigit = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n\tg_tokens[n][0] = '\\0';\n}\n\nint run(void) {\n\tint stack[128];\n\tint top = -1, buf;\n\tCommandType type;\n\tCommand *cmd;\n\tint i;\n\n\tfor (i = 0; g_commands[i].type != END; i++) {\n\t\ttype = g_commands[i].type;\n\t\tcmd = &g_commands[i];\n\t\tif (type == VALUE) {\n\t\t\t//if (cmd->type == VALUE) {\n\t\t\tstack[++top] = cmd->value;\n\t\t} else if (type == OP_ADD) {\n\t\t\t//} else if (cmd->type == OP_ADD) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] += buf;\n\t\t} else if (type == OP_SUB) {\n\t\t\t//} else if (cmd->type == OP_SUB) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] -= buf;\n\t\t} else if (type == OP_MUL) {\n\t\t\t//} else if (cmd->type == OP_MUL) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] *= buf;\n\t\t} else if (type == OP_DIV) {\n\t\t\t//} else if (cmd->type == OP_DIV) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] = (int)((double)stack[top] / (double)buf);\n\t\t\t//stack[top] /= buf;\n\t\t}\n\t}\n\treturn stack[top];\n}\n\nint main(void) {\n\t//int n, i;\n\tint n;\n\tchar in[128];\n\n\tfgets(in, 127, stdin);\n\tn = atoi(in);\n\n\twhile (n--) {\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%d\\n\", run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<string>\nusing namespace std;\nint i;\nstring str;\nint Expression();\nint Term();\nint Factor();\nint No(int);\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cin >> str;\n    i = 0;\n    cout << Expression() << endl;\n  }\n}\nint Expression(){\n  int res = Term();\n  while(1){\n    switch(str[i]){\n    case '+':\n      i++;\n      res += Term();\n      break;\n    case '-':\n      i++;\n      res -= Term();\n      break;\n    default:\n      return res;\n    }\n  }\n}\nint Term(){\n  int res = Factor();\n  while(true){\n    switch(str[i]){\n    case '(':\n      i++;\n      res += Factor();\n      break;\n    case '*':\n      i++;\n      res *= Factor();\n      break;\n    case '/':\n      i++;\n      res /= Factor();\n      break;\n    default:\n      return res;\n    }\n  }\n}\nint Factor(){\n  int res = 0;\n  switch(str[i]){\n  case '(':\n    i++;\n    res = Expression();\n    i++;\n    return res;\n  default:\n    return No(i);\n  }\n}\nint No(int old){\n  while(isdigit(str[i])) i++;\n  return atoi((str.substr(old,i)).c_str());\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum command_type {\n\tVALUE = 0x2,\n\tOP_ADD = 0x4,\n\tOP_SUB = 0x5,\n\tOP_MUL = 0x8,\n\tOP_DIV = 0x9,\n\tEND = 0xffff\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tint value;\n};\ntypedef struct command_t Command;\n\nvoid expression(void);\n\nchar g_tokens[128][128];\nchar *g_symbol;\nint g_index;\nCommand g_commands[128];\nint g_cmd_idx = 0;\n\nvoid command_append(CommandType type, int value) {\n\tCommand *new;\n\n\tnew = &g_commands[g_cmd_idx];\n\tnew->type = type;\n\tnew->value = value;\n\tg_cmd_idx++;\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_index++];\n}\n\nvoid factor(void) {\n\tint value;\n\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tvalue = atoi(g_symbol);\n\t\tcommand_append(VALUE, value);\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tg_index = 0;\n\tg_cmd_idx = 0;\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n\tcommand_append(END, 0);\n}\n\n\nvoid tokenize(char *in) {\n\tint digit, n, i;\n\n\tdigit = n = i = 0;\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t\tdigit = 1;\n\t\t} else {\n\t\t\tif (digit) {\n\t\t\t\tn++;\n\t\t\t\tdigit = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint run(void) {\n\tint stack[128];\n\tint top = -1, buf;\n\tCommand *cmd;\n\tint i;\n\n\tfor (i = 0; g_commands[i].type != END; i++) {\n\t\tcmd = &g_commands[i];\n\t\t//for (cmd = g_commands; cmd != NULL; cmd = cmd->next) {\n\t\tif (cmd->type == VALUE) {\n\t\t\tstack[++top] = cmd->value;\n\t\t} else if (cmd->type == OP_ADD) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] += buf;\n\t\t} else if (cmd->type == OP_SUB) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] -= buf;\n\t\t} else if (cmd->type == OP_MUL) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] *= buf;\n\t\t} else if (cmd->type == OP_DIV) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] /= buf;\n\t\t}\n\t}\n\treturn stack[top];\n}\n\nint main(void) {\n\tint n, i;\n\tchar in[128];\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tg_tokens[i][0] = '\\0';\n\t\t}\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%d\\n\", run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#define MAX 100\n\n\nint calculate(char str[]){/*0～9のみ*/\n\tint i,x,y;\n\tint top=0;\n\tint stack[MAX];\n\n\tfor(i=0;i<strlen(str);i++){\n\t\tif(isdigit(str[i]))stack[top++]=str[i]-'0';\n\t\telse if(str[i]=='=')return stack[top-1];\n\t\telse {\n\t\t\tx=stack[top-1];top--;\n\t\t\ty=stack[top-1];top--;\n\t\t\tswitch(str[i]){\n\t\t\t\tcase '+':stack[top++]=y+x;break;\n\t\t\t\tcase '-':stack[top++]=y-x;break;\n\t\t\t\tcase '*':stack[top++]=y*x;break;\n\t\t\t\tcase '/':stack[top++]=y/x;break;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint op_cmp(char a,char b){\n\tint A,B;\n\tif(a=='+' || a=='-')A=1;\n\telse if(a=='(')A=-1;\n\telse A=2;\n\t\n\tif(b=='+' || b=='-')B=1;\n\telse B=2;\n\n\treturn B-A;\n}\n\nvoid convert(char in[],char out[]){\n\tint i,idx=0;\n\tint top=0;\n\tchar stack[MAX];\n\tfor(i=0;i<strlen(in);i++){\n\t\n\t\tif(isdigit(in[i]))out[idx++]=in[i];\n\t\t\n\t\telse if(in[i]=='('){\n\t\t\tstack[top++]=in[i];\n\t\t}\n\t\t\n\t\telse if(in[i]==')'){\n\t\t\twhile(stack[top-1]!='('){\n\t\t\t\tout[idx++]=stack[top-1];\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\ttop--;\n\t\t}\n\t\t\n\t\telse if(in[i]=='='){\n\t\t\twhile(top>0){\n\t\t\t\tout[idx++]=stack[top-1];\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tout[idx++]=in[i];\n\t\t}\n\t\telse {\n\t\t\twhile( top>0 && op_cmp(stack[top-1],in[i])<=0 ){\n\t\t\t\tout[idx++]=stack[top-1];\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tstack[top++]=in[i];\n\t\t}\n\t\n\t}\n\t\n\t\n\tout[idx]='\\0';\n\treturn;\n}\n\n\nint main(){\n\tchar str_in[MAX];\n\tchar str_post[MAX];\n\tint ans,n;\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i=0;i<n;i++){\n\t\n\t\tscanf(\"%s\",str_in);\n\t\n\t\tconvert(str_in,str_post);\n\t\n\t\tans=calculate(str_post);\n\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "char*p,E[200];l;M(r){for(r=T();;){if(*p==42){p++;r*=T();}else if(*p==47){p++;r/=T();}else return r;}}A(r){for(r=M();;){if(*p==43){p++;r+=M();}else if(*p==45){p++;r-=M();}else return r;}}T(r){if(*p==40){p++;r=A();p++;}else{sscanf(p,\"%d%n\",&r,&l);p+=l;}return r;}main(){scanf(\"%*d\\n\");for(;~scanf(\"%[^=]=\\n\",E);)printf(\"%d\\n\",A(p=E));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstatic char s[1024];\nstatic int sp;\n\nint term(void);\nint factor(void);\nint expr(void);\nint nextInt2();\nint nextInt();\n\nint main(void)\n{\n\n  while(scanf(\" %s\",s) != EOF) {\nsp  = 0;\n  printf(\"%d\\n\",expr());\n}\n  return 0;\n\n}\n\nint nextInt(void)\n{\n    int tmp;\n    tmp = s[sp] - '0';\n    sp++;\n    return tmp;\n}\n\nint nextInt2(void)\n{\n    if (s[sp] == '-') {\n        sp++;\n        return nextInt() * -1;\n    } else {\n        return nextInt();\n    }\n}\n\nint term(void)\n{\n  if(s[sp]=='('){\n    int res;\n    sp++; \n    res = expr();\n    sp++;\n    return res;\n  }\n  return nextInt2();\n}\n\nint factor(void)\n{\n  int res = term();\n  while(1) {\n    if(s[sp]=='*'){\n      sp++; res *= term();\n    } else if(s[sp]=='/'){\n      sp++; res /= term();\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nint expr(void)\n{\n  int res = factor();\n  while(1){\n    if(s[sp]=='+') {\n      sp++; res += factor();\n    } else if(s[sp]=='-') {\n      sp++; res -= factor();\n    } else {\n      break;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n#define MAX 100\n\n\nint calculate(char str[]){/*0～9のみ*/\n\tint i,x,y;\n\tint top=0;\n\tint stack[MAX];\n\n\tfor(i=0;i<strlen(str);i++){\n\t\tif(isdigit(str[i]))stack[top++]=str[i]-'0';\n\t\telse if(str[i]=='=')return stack[top-1];\n\t\telse {\n\t\t\tx=stack[top-1];top--;\n\t\t\ty=stack[top-1];top--;\n\t\t\tswitch(str[i]){\n\t\t\t\tcase '+':stack[top++]=y+x;break;\n\t\t\t\tcase '-':stack[top++]=y-x;break;\n\t\t\t\tcase '*':stack[top++]=y*x;break;\n\t\t\t\tcase '/':stack[top++]=y/x;break;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint op_cmp(char a,char b){\n\tint A,B;\n\tif(a=='+' || a=='-')A=1;\n\telse if(a=='(')A=-1;\n\telse A=2;\n\t\n\tif(b=='+' || b=='-')B=1;\n\telse B=2;\n\n\treturn B-A;\n}\n\nvoid convert(char in[],char out[]){\n\tint i,idx=0;\n\tint top=0;\n\tchar stack[MAX];\n\tfor(i=0;i<strlen(in);i++){\n\t\n\t\tif(isdigit(in[i]))out[idx++]=in[i];\n\t\t\n\t\telse if(in[i]=='('){\n\t\t\tstack[top++]=in[i];\n\t\t}\n\t\t\n\t\telse if(in[i]==')'){\n\t\t\twhile(stack[top-1]!='('){\n\t\t\t\tout[idx++]=stack[top-1];\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\ttop--;\n\t\t}\n\t\t\n\t\telse if(in[i]=='='){\n\t\t\twhile(top>0){\n\t\t\t\tout[idx++]=stack[top-1];\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tout[idx++]=in[i];\n\t\t}\n\t\telse {\n\t\t\twhile( top>0 && op_cmp(stack[top-1],in[i])<=0 ){\n\t\t\t\tout[idx++]=stack[top-1];\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tstack[top++]=in[i];\n\t\t}\n\t\n\t}\n\t\n\t\n\tout[idx]='\\0';\n\treturn;\n}\n\n\nint main(){\n\tchar str_in[MAX];\n\tchar str_post[MAX];\n\tint ans,n;\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i=0;i<n;i++){\n\t\n\t\tscanf(\"%s\",str_in);\n\t\n\t\tconvert(str_in,str_post);\n\t\n\t\tans=calculate(str_post);\n\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n#define CALC {if(sign==0) term=term*x; else term=term/x;}\n\nint num;\nchar str[101];\n\nint smartCalc(){\n  int sum=0, term=1, sign=0, x=0;\n  while(1){\n    switch(str[num]){\n    case '*':\n      CALC;\n      sign=0;\n      x=0;\n      break;\n    case '/':\n      CALC;\n      sign=1;\n      x=0;\n      break;\n    case '+':\n      CALC;\n      sum += term;\n      term=1;\n      sign = 0;\n      x =0;\n      break;\n    case '-':\n      CALC;\n      sum += term;\n      term = -1;\n      sign = 0;\n      x=0;\n      break;\n    case '(':\n      num += 1;\n      x = smartCalc();\n      break;\n    case ')':\n      break;\n    case '=':\n      CALC;\n      sum += term;\n      return sum;\n      break;\n    default:\n      x = x*10 + str[num] - '0';\n    }\n    num += 1;\n  }\n}\nint main(){\n  int n, i;\n  scanf(\"%d\", &n);\n  for(i=0; i<n; i++){\n    scanf(\"%s\", str);\n    num=0;\n    printf(\"%d\\n\", smartCalc());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define def_func(name) int name(int f, int l)\n#define gen_func(name, next, aop1, op1, aop2, op2) \\\ndef_func(name){ \\\n    int i; \\\n    for (i = l; i >= f; i--){ \\\n        if (expr[i] == ')') i = find_open(f, i - 1) - 1; \\\n        if (expr[i] == aop1) return (name(f, i - 1) op1 next(i + 1, l)); \\\n        if (expr[i] == aop1) return (name(f, i - 1) op1 next(i + 1, l)); \\\n    } \\\n    return (next(f, l)); \\\n} \\\n\nchar expr[128];\n\ndef_func(eval);\ndef_func(term);\ndef_func(factor);\ndef_func(find_open);\n \nint main(void)\n{\n    int n, i;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\" %s\", expr);\n        printf(\"%d\\n\", eval(0, strlen(expr) - 2));\n    }\n    return (0);\n}\n\ngen_func(eval, term, '+', +, '-', -)\ngen_func(term, factor, '*', *, '/', /)\ndef_func(factor)\n{\n    if (expr[f] == '(') return (eval(f + 1, l - 1));\n    return (atoi(expr + f));\n}\n\ndef_func(find_open)\n{\n    int i;\n    int close = 0;\n    for (i = l; i >= f; i--){\n        if (expr[i] == ')') close++;\n        if (expr[i] == '('){\n            if (close == 0) break;\n            close--;\n        }\n    }\n    return (i);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint r,b,q[100];\nchar s[101];\nvoid f(int e){\n  int i,c=0,j;\n  for(i=e;i<r;i++){//printf(\"%c \",s[i]);\n    if(s[i]=='*'){\n      q[i+1]=q[i]*q[i+1];\n      c++;\n    }\n    else if(s[i]=='/'){\n      q[i+1]=q[i]/q[i+1];\n      c++;\n    }\n    else {\n      //if(s[i]=='=')return;\n      s[i-c]=s[i];\n      q[i-c]=q[i];\n    }\n  }if(s[0]=='=')return ;\n  r-=c;//printf(\"\\n\\nq:\");\n  //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\ns:\");\n  //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n  //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");  \n  for(i=e;i<r;i++){\n    if(s[i]=='+')q[i+1]=q[i]+q[i+1];\n    if(s[i]=='-')q[i+1]=q[i]-q[i+1];\n  }\n  q[e]=q[r-1];\n  b+=r-e;\n  r=e+1;\n  return;\n}\nint main(){\n  int m,n=0,i,c=-1,kr=0,k[100],j;\n  scanf(\"%d\",&m);\n  while(m--){\n    scanf(\"%s\",s);\n    for(i=r=b=0;s[i];i++){\n      if('0'<=s[i]&&s[i]<='9'){\n\tn*=10;\n\tn+=s[i]-'0';\n\tc++;\n      }\n      else {\n\tb++;\n\tif(s[i]=='(')k[kr++]=r;\n\telse{\n\t  q[r++]=n;\n\t  n=0;\n\t  b+=c;\n\t  c=-1;\n\t  if(s[i]==')')f(k[--kr]);\n\t  else s[i-b]=s[i];\n\t}\n      }//printf(\"q:\");\n      //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\nk:\");\n      //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n      //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");\n    }\n    f(0);//printf(\"\\nq:\");\n    //for(j=0;j<r ;j++)printf(\"%d \",q[j]);printf(\"\\nk:\");\n    //for(j=0;j<kr;j++)printf(\"%d \",k[j]);printf(\"\\ns:\");\n    //for(j=0;s[j];j++)printf(\"%c \",s[j]);printf(\"\\n\");\n    printf(\"%d\\n\",q[0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<ctype.h>\n#include<string.h>\n#include<stdlib.h>\n\nint expression(char *);\nint term(char *);\nint factor(char *);\nint number(char *);\n\nint main(void){\n  int N,i,ans;\n  char s[100000];\n  char *begin;\n  scanf(\"%d\",&N);\n  scanf(\"%c\",&s[0]);\n  \n  for(i=0;i<N;i++){\n    scanf(\"%[^\\n]%*c\",s);\n    \n    begin=s;\n    ans=expression(begin);\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\nint expression(char *begin){\n  int ret=term(begin);\n  \n  while(1){\n    if(*begin=='+'){\n      begin++;\n      ret+=term(begin);\n    }\n    else if(*begin=='-'){\n      begin++;\n      ret-=term(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint  term(char *begin){\n  int ret=factor(begin);\n  while(1){\n    if(*begin=='*'){\n      begin++;\n      ret*=factor(begin);\n    }\n    else if(*begin=='/'){\n      begin++;\n      ret/=factor(begin);\n    }\n    else break;\n  }\n  return ret;\n}\n\nint factor(char *begin){\n  \n  if(*begin=='('){\n    begin++;\n    int ret=expression(begin);\n    begin++;\n    return ret;\n  }\n  if(*begin=='-'){\n    begin++;\n    return -factor(begin);\n  }\n  return number(begin);\n}\n\nint number(char *begin){\n  int ret=0;\n  \n  while(isdigit(*begin)){\n    ret*=10;\n    ret+=*begin-'0';\n    begin++;\n  }\n  return ret;\n}"
  },
  {
    "language": "C",
    "code": "char*p,E[200];M(r){for(r=T();*p==42|*p==47;)*p-42?(p++,r/=T()):(p++,r*=T());return r;}A(r){for(r=M();*p==43|*p==45;)*p-43?(p++,r-=M()):(p++,r+=M());return r;}T(r,l){*p-40?sscanf(p,\"%d%n\",&r,&l):(++p,r=A(l=1));p+=l;return r;}main(){for(;~scanf(\"%*d\\n%[^=]=\\n\"+!!p*4,E);)printf(\"%d\\n\",A(p=E));}"
  },
  {
    "language": "C",
    "code": "char*p;M(r){for(r=T();*p%5==2;)r=*p&1?r/T():r*T();return r;}A(r){for(r=M();abs(*p-=44)<2;)r-=*p*M();return++p,r;}T(){return*++p-40?strtol(p,&p,10):A(p);}main(f){for(;~scanf(\"%as\",&p);f=0)f||printf(\"%d\\n\",A(--p));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128];\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<128;j++){\n      b[j]='\\0';\n      st[j]='\\0';\n    }\n\n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n\n\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n      if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n      if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n      if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n      if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n    printf(\"%d\\n\",st2[0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define N 128\n#define ADD -1\n#define SUB -2\n#define MUL -3\n#define DIV -4\n#define ESC -5\n#define LPR -6\n#define RPR -7\n\nstatic\nint * e;\n\nstatic\nint eval_1st ( void ),\n    eval_2nd ( void ),\n    eval_3rd ( void );\n\nstatic\nint eval_1st (\n  void\n  )\n{\n  if ( *e == LPR )\n  {\n    int res;\n\n    ++e;\n    res = eval_3rd ( );\n    ++e;\n    return ( res );\n  }\n  else\n  {\n    return ( *( e++ ) );\n  }\n}\n\nstatic\nint eval_2nd (\n  void\n  )\n{\n  int left = eval_1st ( );\n\n  switch ( *e )\n  {\n    case MUL: ++e;  return ( left * eval_2nd ( ) );\n    case DIV: ++e;  return ( left / eval_2nd ( ) );\n    default:        return ( left );\n  }\n}\n\nstatic\nint eval_3rd (\n  void\n  )\n{\n  int left = eval_2nd ( );\n\n  switch ( *e )\n  {\n    case ADD: ++e;  return ( left + eval_3rd ( ) );\n    case SUB: ++e;  return ( left - eval_3rd ( ) );\n    default:        return ( left );\n  }\n}\n\nstatic\nint eval (\n  void\n  )\n{\n  return ( eval_3rd ( ) );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int n;\n\n  scanf ( \"%d \", &n );\n  while ( n-- )\n  {\n    int   expr[ N ] = { 0 };\n    int * p = expr;\n\n    for ( ; ; )\n    {\n      int ch = ' ';\n\n      while ( isspace ( ch ) )  ch = getchar ( );\n\n      switch ( ch )\n      {\n        case '+':   ++p; *( p++ ) = ADD; break;\n        case '-':   ++p; *( p++ ) = SUB; break;\n        case '*':   ++p; *( p++ ) = MUL; break;\n        case '/':   ++p; *( p++ ) = DIV; break;\n        case '=':   ++p; *( p++ ) = ESC; goto BREAKK;\n        case '(':        *( p++ ) = LPR; break;\n        case ')':   ++p; *( p++ ) = RPR; break;\n        default:\n          *p = *p * 10 + ( ch - '0' );\n          break;\n      }\n    }\nBREAKK:\n    e = expr;\n    printf ( \"%d\\n\", eval ( ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define N 128\n#define ADD -1\n#define SUB -2\n#define MUL -3\n#define DIV -4\n#define ESC -5\n#define LPR -6\n#define RPR -7\n\nstatic\nint * e;\n\nstatic\nint eval_1st ( void ),\n    eval_2nd ( void ),\n    eval_3rd ( void );\n\nstatic\nint eval_1st (\n  void\n  )\n{\n  if ( *e == LPR )\n  {\n    int res;\n\n    ++e;\n    res = eval_3rd ( );\n    ++e;\n    return ( res );\n  }\n  else\n  {\n    return ( *( e++ ) );\n  }\n}\n\nstatic\nint eval_2nd (\n  void\n  )\n{\n  int left = eval_1st ( );\n\n  while ( *e == MUL || *e == DIV )\n  {\n    ++e;\n    if ( e[ -1 ] == MUL ) left *= eval_2nd ( );\n    else                  left /= eval_2nd ( );\n  }\n\n  return ( left );\n}\n\nstatic\nint eval_3rd (\n  void\n  )\n{\n  int left = eval_2nd ( );\n\n  while ( *e == ADD || *e == SUB )\n  {\n    ++e;\n    if ( e[ -1 ] == ADD ) left += eval_2nd ( );\n    else                  left -= eval_2nd ( );\n  }\n\n  return ( left );\n}\n\nstatic\nint eval (\n  void\n  )\n{\n  return ( eval_3rd ( ) );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int n;\n\n  scanf ( \"%d \", &n );\n  while ( n-- )\n  {\n    int   expr[ N ] = { 0 };\n    int * p = expr;\n\n    for ( ; ; )\n    {\n      int ch = ' ';\n\n      while ( isspace ( ch ) )  ch = getchar ( );\n\n      switch ( ch )\n      {\n        case '+':   ++p; *( p++ ) = ADD; break;\n        case '-':   ++p; *( p++ ) = SUB; break;\n        case '*':   ++p; *( p++ ) = MUL; break;\n        case '/':   ++p; *( p++ ) = DIV; break;\n        case '=':   ++p; *( p++ ) = ESC; goto BREAKK;\n        case '(':        *( p++ ) = LPR; break;\n        case ')':   ++p; *( p++ ) = RPR; break;\n        default:\n          *p = *p * 10 + ( ch - '0' );\n          break;\n      }\n    }\nBREAKK:\n    e = expr;\n    printf ( \"%d\\n\", eval ( ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint expr(const char **p);\nint term(const char **p);\nint factor(const char **p);\nint number(const char **p);\n\nint expr(const char **p) {\n  int val = term(p);\n  while (1) {\n    if (**p == '+') {\n      (*p)++;\n      val += term(p);\n    } else if (**p == '-') {\n      (*p)++;\n      val -= term(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(const char **p) {\n  int val = factor(p);\n  while (1) {\n    if (**p == '*') {\n      (*p)++;\n      val *= factor(p);\n    } else if (**p == '/') {\n      (*p)++;\n      val /= factor(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(const char **p) {\n  if (**p == '(') {\n    (*p)++;\n    int val = expr(p);\n    (*p)++;\n    return val;\n  }\n  return number(p);\n}\n\nint number(const char **p) {\n  int val = 0;\n  while ('0' <= **p && **p <= '9') {\n    val = val * 10 + **p - '0';\n    (*p)++;\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  char s[101];\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%s\", s);\n    const char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n \nint calc1();\nint calc2();\nint calc3();\n \nint p;\nstring eq;\n \nint calc1() {\n  int a = calc2();\n  while (eq[p]=='+' || eq[p]=='-') {\n    if (eq[p]=='+') {\n      p++;\n      a += calc2();\n    } else if (eq[p]=='-') {\n      p++;\n      a -= calc2();\n    }\n  }\n  return a;\n}\n \nint calc2() {\n  int a = calc3();\n  while (eq[p]=='*' || eq[p]=='/') {\n    if (eq[p]=='*') {\n      p++;\n      a *= calc3();\n    } else if (eq[p]=='/') {\n      p++;\n      a /= calc3();\n    }\n  }\n  return a;\n}\n \nint calc3() {\n  int a;\n  if (eq[p]=='(') {\n    p++;\n    a = calc1();\n    p++;\n  } else {\n    a = 0;\n    while (eq[p]>='0'&&eq[p]<='9') {\n      a *= 10;\n      a += eq[p++] - '0';\n    }\n  }\n  return a;\n}\n \nint main() {\n  int n, r;\n \n  cin >> n;\n  for (int i=0; i<n; i++) {\n    cin >> eq;\n    p = 0;\n    r = calc1();\n    cout << r << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0109: Smart Calculator\n// 2017.8.5\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX 500\n#define INF   1000000010\n#define LEFT (INF+1)\n#define RIGHT (INF+2)\n#define PLUS (INF+3)\n#define MINUS (INF+4)\n#define MUL (INF+5)\n#define DIV (INF+6)\n\nchar *gets(char *);\nchar buf[200], *p;\nint S[MAX + 3], top;\nint Q[MAX + 3], end;\n\nint getInt(void)\n{\n\tint n = 0;\n//\twhile (isspace(*p)) p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nint token(char c)\n{\n\tif (c == '+') return PLUS;\n\tif (c == '-') return MINUS;\n\tif (c == '*') return MUL;\n\treturn DIV;\n}\n\nint main()\n{\n\tint i, f, k, d1, d2;\n\tint cno, cmax;\n\n\tgets(p = buf); cmax = getInt();\n\tfor (cno = 0; cno < cmax; cno++) {\n\t\tgets(p = buf), f = 1, top = 0, end = 0;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (!*p || *p == '=') {\n\t\t\t\twhile (top) Q[end++] = S[--top];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '-' && f && isdigit(*(p + 1))) {\n\t\t\t\tp++;\n\t\t\t\tQ[end++] = -getInt();\n\t\t\t\tf = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = 0;\n\t\t\tif (isdigit(*p)) Q[end++] = getInt();\n\t\t\telse if (*p == ')') {\n\t\t\t\twhile (S[top - 1] != LEFT) Q[end++] = S[--top];\n\t\t\t\ttop--, p++;\n\t\t\t}\n\t\t\telse if (*p == '(') S[top++] = LEFT, p++, f = 1;\n\t\t\telse {\n\t\t\t\tk = token(*p++);\n\t\t\t\twhile (top) {\n\t\t\t\t\tif (k < S[top - 1]) Q[end++] = S[--top];\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tS[top++] = k;\n\t\t\t}\n\t\t}\n#if 0\n\t\tfor (i = 0; i < end; i++) printf(\"%d \", Q[i]);\n\t\tprintf(\"\\n\");\n#endif\n\t\tfor (top = i = 0; i < end; i++) {\n\t\t\tif ((k = Q[i]) > INF) {\n\t\t\t\td1 = S[--top], d2 = S[--top];\n\t\t\t\tif (k == PLUS) d2 += d1;\n\t\t\t\telse if (k == MINUS) d2 -= d1;\n\t\t\t\telse if (k == MUL) d2 *= d1;\n\t\t\t\telse d2 /= d1;\n\t\t\t\tS[top++] = d2;\n\t\t\t} else S[top++] = k;\n\t\t}\n\t\tprintf(\"%d\\n\", S[--top]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128],c;\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    l=0;//優先順位\n    m=0;\n    p=0;//スタックの数\n    q=0;\n    // b[0]='\\0';\n    // st[0]='\\0';\n    for(j=0;j<128;j++){\n      b[j]='\\0';\n      st[j]='\\0';\n    }\n\n    for(j=0;j<strlen(a);j++){\n\n      //printf(\"b : %s\\n\",b);\n      //printf(\"st : %s\\n\",st);\n      //printf(\"--------------------\\n\");\n    \n      //定数はそのまま出力\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n\t//printf(\"digi\\n\");\n      }\n      //全てを処理したらスタックの中身を出力\n      else if(a[j]=='='){\n\t//printf(\"eq\\n\");\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      //演算子が来て、スタックが空なのでぶち込む。(も問答無用でぶち込む\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n\t//printf(\"blank\\n\");\n      }\n      //)が来たら(からの分の演算子を出力\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\t//printf(\"close\\n\");\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      //優先度の低い演算子について\n      else if(a[j]=='+' || a[j]=='-'){\n\t//既にスタックにつまれている演算子の優先順位が同じか低いとき\n\t//\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t  //printf(\"+-1\\n\");\n\t}\n\t//既にスタックにつまれている演算子の方が優先度が高いとき\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t  //printf(\"+-2\\n\");\n\t}\n      }\n\n\n      \n      //優先度の高い演算子について\n      else if((a[j]=='*') || (a[j]=='/')){\n\t//既にスタックにつまれている演算子の優先順位が同じ*/か低いときは\n\t//スタックにある優先順位の高い+-演算子を全て出してから新しいのを積む\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n\t//printf(\"*/1\\n\");\n      }\n      //既にスタックにつまれている演算子の方が優先度が高いときはそのまま積む\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n\t//printf(\"*/2\\n\");\n      }\n    }\n\n    //printf(\"%s\\n\",b);\n\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\t//printf(\"--%d--\\n\",st2[q]);\n\tq++;\n      }\n      if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n      if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n      if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n      if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n    printf(\"%d\\n\",st2[0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "l=[eval(raw_input()[:-1]) for i in range(int(input()))]\nfor i in l:\n    print i\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        return addsub(idx + 1);\n    }\n    while (isdigit(formula[idx])){\n        res = res * 10 + formula[idx] - '0';\n        ++idx;\n    }\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    while (1){\n        if (formula[idx] == '*'){\n            res *= number(idx + 1);\n        }\n        else if (formula[idx] == '/'){\n            res /= number(idx + 1);\n        }\n        else if (!isdigit(formula[idx])){\n            break;\n        }\n        ++idx;\n    }\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n        }\n        else if (formula[idx] == '-' && !brackets){\n            res -= muldiv(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n    }\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint expr(char **);\n\nint number(char **s) {\n  int val = 0;\n  while ('0' <= **s && **s <= '9') {\n    val = val * 10 + **s - '0';\n    (*s)++;\n  }\n  return val;\n}\n\nint factor(char **s) {\n  if (**s == '(') {\n    (*s)++;\n    int val = expr(s);\n    (*s)++;\n    return val;\n  }\n  return number(s);\n}\n\nint term(char **s) {\n  int val = factor(s);\n  while (1) {\n    if (**s == '*') {\n      (*s)++;\n      val *= factor(s);\n    } else if (**s == '/') {\n      (*s)++;\n      val /= factor(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint expr(char **s) {\n  int val = term(s);\n  while (1) {\n    if (**s == '+') {\n      (*s)++;\n      val += term(s);\n    } else if (**s == '-') {\n      (*s)++;\n      val -= term(s);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define SIZE    (100)\n\nenum _tt {TERM_N, TERM_OP_PM, TERM_OP_MD, TERM_LB, TERM_RB, TERM_END};\n\ntypedef struct _term_t {\n  enum _tt type;\n  int d;\n} term_t;\n\nstatic term_t expr[SIZE];\nstatic term_t rpn[SIZE];\n\nvoid print_term(term_t *terms, int tn) {\n  int i;\n\n  for (i = 0; i < tn; i++)\n    printf(\" (%d, %d)\", terms[i].type, terms[i].d);\n  putchar('\\n');\n}\n\nterm_t *term_push(term_t *expr, int *enp, enum _tt type, int d) {\n  term_t *t = &expr[(*enp)++];\n  t->type = type;\n  t->d = d;\n  return t;\n}\n\nint lex_analyze(char *str, term_t *expr) {\n  int d, come_sign, en, sign;\n  char *pt;\n  term_t *t;\n\n  en = 0;\n  come_sign = 1;\n  sign = 1;\n  d = 0;\n\n  for (pt = str; *pt; pt++) {\n#ifdef DEBUG\n    printf(\"%c\\n\", *pt);\n#endif /* DEBUG */\n\n    switch (*pt) {\n    case '+':\n      if (! come_sign) {\n        term_push(expr, &en, TERM_OP_PM, *pt);\n        come_sign = 1;\n      }\n      break;\n\n    case '-':\n      if (come_sign)\n        sign *= -1;\n      else {\n        term_push(expr, &en, TERM_OP_PM, *pt);\n        come_sign = 1;\n        sign = 1;\n      }\n      break;\n\n    case '*':\n    case '/':\n      term_push(expr, &en, TERM_OP_MD, *pt);\n      come_sign = 1;\n      sign = 1;\n      break;\n\n    case '(':\n      term_push(expr, &en, TERM_LB, *pt);\n      come_sign = 1;\n      sign = 1;\n      break;\n\n    case ')':\n      term_push(expr, &en, TERM_RB, *pt);\n      come_sign = 1;\n      sign = 1;\n      break;\n\n    case '=':\n      term_push(expr, &en, TERM_END, *pt);\n      *(pt + 1) = '\\0';\n      break;\n\n    default:\n      d = d * 10 + (*pt - '0');\n      if (! isdigit(*(pt + 1))) {\n        term_push(expr, &en, TERM_N, d * sign);\n        d = 0;\n        come_sign = 0;\n        sign = 1;\n      }\n    }\n  }\n\n  return en;\n}\n\nint to_rpn(term_t *expr, int en, term_t *rpn) {\n  int i, rn, sp;\n  term_t *t, *st;\n  static term_t stack[SIZE];\n\n  rn = sp = 0;\n\n  for (i = 0; i < en; i++) {\n    t = &expr[i];\n\n    switch (t->type) {\n    case TERM_N:\n      term_push(rpn, &rn, t->type, t->d);\n      break;\n\n    case TERM_OP_PM:\n      while (sp > 0 &&\n             ((st = &stack[sp - 1])->type == TERM_OP_PM ||\n              st->type == TERM_OP_MD)) {\n        --sp;\n        term_push(rpn, &rn, st->type, st->d);\n      }\n      term_push(stack, &sp, t->type, t->d);\n      break;\n\n    case TERM_OP_MD:\n      while (sp > 0 && stack[sp - 1].type == TERM_OP_MD) {\n        --sp;\n        term_push(rpn, &rn, st->type, st->d);\n      }\n      term_push(stack, &sp, t->type, t->d);\n      break;\n\n    case TERM_LB:\n      term_push(stack, &sp, t->type, t->d);\n      break;\n\n    case TERM_RB:\n      while (stack[sp - 1].type != TERM_LB) {\n        st = &stack[--sp];\n        term_push(rpn, &rn, st->type, st->d);\n      }\n      --sp;\n      break;\n\n    case TERM_END:\n      while (sp > 0) {\n        st = &stack[--sp];\n        term_push(rpn, &rn, st->type, st->d);\n      }\n    }\n  }\n\n  return rn;\n}\n\nint calc_rpn(term_t *rpn, int rn) {\n  int i, n1, n2, sp;\n  term_t *t;\n  static int d_stack[SIZE];\n\n  sp = 0;\n\n  for (i = 0; i < rn; i++) {\n    t = &rpn[i];\n\n    if (t->type == TERM_N)\n      d_stack[sp++] = t->d;\n    else {\n      n2 = d_stack[--sp];\n      n1 = d_stack[--sp];\n      switch (t->d) {\n      case '+':\n        d_stack[sp++] = n1 + n2;\n        break;\n      case '-':\n        d_stack[sp++] = n1 - n2;\n        break;\n      case '*':\n        d_stack[sp++] = n1 * n2;\n        break;\n      case '/':\n        d_stack[sp++] = n1 / n2;\n        break;\n      }\n    }\n  }\n\n  return d_stack[0];\n}\n\n/* main */\n\nint main() {\n  int i, en, n, num, rn;\n  char str[SIZE + 2];\n\n  scanf(\"%d\\n\", &n);\n\n  for (i = 0; i < n; i++) {\n    fgets(str, SIZE + 1, stdin);\n\n    en = lex_analyze(str, expr);\n    rn = to_rpn(expr, en, rpn);\n\n#ifdef DEBUG\n    print_term(expr, en);\n    print_term(rpn, rn);\n#endif /* DEBUG */\n\n    num = calc_rpn(rpn, rn);\n    printf(\"%d\\n\", num);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <strings.h>\n#include <stdio.h>\n#include <ctype.h>\n\nchar str[101];\nint tindex=0;\nint map[255];\nint token;\n\nint addminus();\n\nvoid getToken(void) {\n    int r = 0;\n    if (isdigit(str[tindex])) {\n\twhile (isdigit(str[tindex])) {\n\t    r = r*10+(str[tindex++]-'0');\n\t}\n\ttoken = r;\n    } else {\n\ttoken = map[(int)str[tindex++]];\n    }\n}\n\nint terminal() {\n    int result = 0;\n    if (token == -5) {\n\tgetToken();\n\tresult = addminus();\n\tgetToken();\n    } else if (token >= 0) {\n\tresult = token;\n\tgetToken();\n    }\n    return result;\n}\n\nint multidiv() {\n    int result = terminal();\n    while (token == -3 || token == -4) {\n\tif (token == -3) {\n\t    getToken();\n\t    result *= terminal();\n\t} else {\n\t    getToken();\n\t    result /= terminal();\n\t}\n    }\n    return result;\n}\n \nint addminus() {\n    int result = multidiv();\n    while (token == -1 || token == -2) {\n\tif (token == -1) {\n\t    getToken();\n\t    result += multidiv();\n\t} else {\n\t    getToken();\n\t    result -= multidiv();\n\t}\n    }\n    return result;\n}\n \nint main(void) {\n    int i, n, total;\n\n    map['+'] = -1;\n    map['-'] = -2;\n    map['*'] = -3;\n    map['/'] = -4;\n    map['('] = -5;\n    map[')'] = -6;\n    map['='] = -7;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n\ttindex=0;\n\tscanf(\"%s\", str);\n\tgetToken();\n\ttotal=addminus();\n\tprintf(\"%d\\n\", total);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n \ntypedef std::stringstream sst;\n \nint ToInt(std::string str){\n    int i;\n    sst ss;\n    ss<<str;\n    ss>>i;\n    return i;\n}\nstd::string ToStr(int i){\n    std::string str;\n    sst ss;\n    ss<<i;\n    ss>>str;\n    return str;\n}\n \nstd::string SubStr(std::string str,int x,int y){\n    return str.substr(x,y-x+1);\n}\nint Third(std::string str){\n    int fres,Ans;\n    while( ( fres=str.find_first_of(\"+-\",1) ) != std::string::npos ){\n        int aRes;\n         \n        if( (aRes=str.find_first_of(\"+-\",fres+2)) == std::string::npos )\n            aRes=str.size()-1;\n        else --aRes;\n         \n        if( str[fres] =='+' ){\n            Ans=ToInt(SubStr(str,0,fres-1))+ToInt(SubStr(str,fres+1,aRes));\n            str.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n        }else{\n            Ans=ToInt(SubStr(str,0,fres-1))-ToInt(SubStr(str,fres+1,aRes));\n            str.replace(0,SubStr(str,0,aRes).size(),ToStr(Ans).c_str());\n        }\n    }\n    return ToInt(str);\n}\n \nint Second(std::string str){\n    int fres,Ans;\n    while( ( fres=str.find_first_of(\"*/\") ) != std::string::npos ){\n        int bRes,aRes;\n        if( (bRes=str.find_last_of(\"+-\",fres)) == std::string::npos  || bRes==0 )\n            bRes=0;\n        else ++bRes;\n         \n        if( (aRes=str.find_first_of(\"+-*/\",fres+2)) == std::string::npos )\n            aRes=str.size()-1;\n        else --aRes;\n         \n        if( str[fres] =='*' ){\n            Ans=ToInt(SubStr(str,bRes,fres-1))*ToInt(SubStr(str,fres+1,aRes));\n            str.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n        }else{\n            Ans=ToInt(SubStr(str,bRes,fres-1))/ToInt(SubStr(str,fres+1,aRes));\n            str.replace(bRes,SubStr(str,bRes,aRes).size(),ToStr(Ans).c_str());\n        }\n    }\n    Ans=Third(str);\n    return Ans;\n}\n \nint First(std::string str){\n    int fres;\n    while( (fres = str.find(\")\") ) != std::string::npos ){\n        int rfres=str.rfind(\"(\",fres);\n        std::string Next=SubStr(str,rfres+1,fres-1);\n        int cRes=Second(Next);\n        str.replace(rfres,Next.size()+2,ToStr(cRes).c_str());\n    }\n    int lRes = Second(str);\n     \n    return lRes;\n}\n \nint main(){\n    int n;\n  std::string str;\n    std::cin>>n;\n    while( n-- ){\n        std::cin>>str;\n      std::cout<<First(str)<<std::endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "char s[101],*p;\ne(r){\n\tfor(r=t();*p==43?r+=t(p++),1:*p==45?r-=t(p++),1:0;);\n\treturn r;\n}\nt(r){\n\tfor(r=f();*p==42?r*=f(p++),1:*p==47?r/=f(p++),1:0;);\n\treturn r;\n}\nf(r){\n\treturn *p==40?r=e(p++),p++,r:n(p);\n}\nn(r){\n\tfor(r=0;47<*p&*p<58;)r=r*10+*p++-48;\n\treturn r;\n}\nmain(i){\n\tfor(;gets(p=s);)--i&&!printf(\"%d\\n\",e());\n}"
  },
  {
    "language": "C",
    "code": "char*p,E[200];M(r){for(r=T();;){if(*p==42){p++;r*=T();}else if(*p==47){p++;r/=T();}else return r;}}A(r){for(r=M();;){if(*p==43){p++;r+=M();}else if(*p==45){p++;r-=M();}else return r;}}T(r,l){if(*p==40){p++;r=A();p++;}else{sscanf(p,\"%d%n\",&r,&l);p+=l;}return r;}main(){scanf(\"%*d\\n\");for(;~scanf(\"%[^=]=\\n\",E);)printf(\"%d\\n\",A(p=E));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[110];\nint i;\nint f(){\n  char o[]={\"#)=+-*/\"};\n  int  p[]={-1,0,0,1,1,2,2};\n  int j=0,k,n=0,r=0,sn[]={0};\n  char so[]={\"#\"};\n  while(p[j]){//printf(\"a\\n\");\n    if('0'<=s[i]&&s[i]<='9')n=n*10+s[i]-'0';\n    else{\n      if(s[i]=='('){\n\ti++;\n\tn=f();\n      }//printf(\"n:%d\\n\",n);\n      for(j=0;o[j]-s[i];j++);\n      while(1){\n\tfor(k=0;o[k]-so[r];k++);\n\tif(p[k]<p[j])break;\n\tif(k==3)n=sn[r--]+n;\n\tif(k==4)n=sn[r--]-n;\n\tif(k==5)n=sn[r--]*n;\n\tif(k==6)n=sn[r--]/n;\n\t//for(k=0;k<r+1;k++)printf(\"*%d %c %d\\n\",sn[k],so[k],n);printf(\"\\n\");\n     }\n      sn[++r]=n;\n      so[  r]=s[i];\n      n=0;\n    }\n    //for(k=0;k<r+1;k++)printf(\"%d %c\\n\",sn[k],so[k]);printf(\"\\n\");\n    i++;\n  }\n  return sn[1];\n}\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%s\",s);\n    i=0;\n    printf(\"%d\\n\",f());\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[255];\n  char a[255],st[255],b[255];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<255;j++){\n      b[j]='!';\n      st[j]='!';\n    }\n    \n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n\n    q=0;\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n     else if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint eval(char *ex, int first, int last);\nint term(char *ex, int first, int last);\nint factor(char *ex, int first, int last);\nint literal(char *ex, int first, int last);\nint find_open(char *ex, int first, int last);\n\nint main(void)\n{\n\tchar expr[128];\n\tint n, i;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\" %s\", expr);\n\t\tprintf(\"%d\\n\", eval(expr, 0, strlen(expr) - 2));\n\t}\n\n\treturn (0);\n}\n\nint eval(char *ex, int first, int last)\n{\n\tint i;\n\n\tfor (i = last; i >= first; i--){\n\t\tif (ex[i] == ')'){\n\t\t\ti = find_open(ex, first, i - 1) - 1;\n\t\t}\n\t\tif (ex[i] == '+') return (eval(ex, first, i - 1) + term(ex, i + 1, last));\n\t\tif (ex[i] == '-') return (eval(ex, first, i - 1) - term(ex, i + 1, last));\n\t}\n\treturn (term(ex, first, last));\n}\n\nint term(char *ex, int first, int last)\n{\n\tint i;\n\n\tfor (i = last; i >= first; i--){\n\t\tif (ex[i] == ')'){\n\t\t\ti = find_open(ex, first, i - 1) - 1;\n\t\t}\n\t\tif (ex[i] == '*') return (term(ex, first, i - 1) * factor(ex, i + 1, last));\n\t\tif (ex[i] == '/') return (term(ex, first, i - 1) / factor(ex, i + 1, last));\n\t}\n\treturn (factor(ex, first, last));\n}\n\nint factor(char *ex, int first, int last)\n{\n\tif (ex[first] == '('){\n\t\treturn (eval(ex, first + 1, last - 1));\n\t}\n\treturn (atoi(ex + first));\n}\n\nint find_open(char *ex, int first, int last)\n{\n\tint close;\n\tint i;\n\n\tclose = 0;\n\tfor (i = last; i >= first; i--){\n\t\tif (ex[i] == ')') close++;\n\t\tif (ex[i] == '('){\n\t\t\tif (close == 0){\n\t\t\t\treturn (i);\n\t\t\t}\n\t\t\tclose--;\n\t\t}\n\t}\n\treturn (-1);\n}"
  },
  {
    "language": "C",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 100\n\nconst char *p;\n\nint expr();\nint term();\nint fact();\nint number();\n\nint expr() {\n\tint res = term();\n\twhile(*p == '+' || *p == '-') {\n\t\tconst char operator = *p;\n\t\t++p;\n\t\tswitch(operator) {\n\t\tcase '+': res += term(); break;\n\t\tcase '-': res -= term(); break;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\treturn res;\n}\n\nint term() {\n\tint res = fact();\n\twhile(*p == '*' || *p == '/') {\n\t\tconst char operator = *p;\n\t\t++p;\n\t\tswitch(operator) {\n\t\tcase '*': res *= fact(); break;\n\t\tcase '/': res /= fact(); break;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\treturn res;\n}\n\nint fact() {\n\tif(*p == '-') {\n\t\t++p;\n\t\treturn -fact();\n\t}\n\telse if(*p == '(') {\n\t\t++p;\n\t\tconst int res = expr();\n\t\tassert(*p == ')');\n\t\t++p;\n\t\treturn res;\n\t}\n\telse if(isdigit(*p)) {\n\t\treturn number();\n\t}\n\telse {\n\t\tassert(false);\n\t}\n}\n\nint number() {\n\tint res = 0;\n\twhile(isdigit(*p)) {\n\t\tres = res * 10 + (*p - '0');\n\t\t++p;\n\t}\n\treturn res;\n}\n\nint main() {\n\tchar input[MAX_LEN + 1];\n\tint i;\n\tint n;\n\tscanf(\"%d\\n\", &n);\n\n\tfor(i = 0; i < n; ++i) {\n\t\tfgets(input, MAX_LEN + 1, stdin);\n\t\tp = input;\n\t\tconst int ans = expr();\n\t\tassert(*p == '=');\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define TERMING { if(sign==0) term=term*x; else term=term/x; }\n\nint n,pp;\nchar exp[150];\n\nint culc(){\n\tint x=0,term=1,sum=0,sign=0;\n\twhile(1){\n\t\tswitch(exp[pp]){\n\t\t\tcase '*':\n\t\t\t\tTERMING\n\t\t\t\tsign=0;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tTERMING\n\t\t\t\tsign=1;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tTERMING\n\t\t\t\tsum+=term;\n\t\t\t\tterm=1;\n\t\t\t\tsign=0;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tTERMING\n\t\t\t\tsum+=term;\n\t\t\t\tterm=-1;\n\t\t\t\tsign=0;\n\t\t\t\tx=0;\n\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tpp++;\n\t\t\t\tx=culc();\n\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\tcase'=':\n\t\t\t\tTERMING\n\t\t\t\tsum+=term;\n\t\t\t\treturn sum;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tx=x*10+exp[pp]-'0';\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"x=%d term=%d sum=%d\\n\",x,term,sum);\n\t\tpp++;\n\t}\n}\n\nint main(){\n\tfor(scanf(\"%d\",&n);n>0;n--){\n\t\tscanf(\"%s\",exp);\n\t\tpp=0;\n\t\tprintf(\"%d\\n\",culc());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0109\nTitle\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nchar siki[101];\nchar bin_op1[]=\"+-\";\nchar bin_op2[]=\"*/\";\n//\nchar * find_bin_op(char * s,int len)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op1,s[i]); //priority low\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  p=strchr(bin_op2,s[i]); //priority high\n\t  if(p && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nint calc_expr1(int a1,int a2 ,char operator)\n{\n  //printf(\"s:%d %d %c\",a1,a2,operator);\n\n  switch(operator){\n  case '+':\n    return(a1+a2);\n  case '-':\n    return(a1-a2);\n  case '*':\n    return(a1*a2);\n  case '/':\n    return(a1/a2);\n  default:\n    break;\n    }\n}\nint isnumber(char *s,int len)\n{\n  int i;\n  for(i=0;i<len;i++)\n    if(s[i] < '0' || s[i] > '9')\n      return(0);\n  return(-1);\n}\nint calc_expr(char *s,int len)\n{\n  char *r;\n  int i;\n#ifdef DEBUG\n  printf(\"exp:\");\n  for(i=0;i<len;i++)\n    printf(\"%c\",s[i]);\n  printf(\"\\n\");\n#endif\n  if(isnumber(s,len))\n    {\n       return(atoi(s));\n    }\n    \n  r=find_bin_op(s,len);\n \n  if(r)\n    {\n      return(calc_expr1(calc_expr(s,r-s),calc_expr(r+1,len-(r-s+1)),r[0]));\n    }\n  //if(s[0]=='c')\n  //   return(calc_cpl(calc_expr(s+1,len-1)));\n  if(s[0]=='(' && s[len-1]==')')\n    return(calc_expr(s+1,len-2));\n\n}\n\nmain()\n{\n  int ret;\n  int n,i;\n  \n  scanf(\"%d \",&n);\n  for(i=0;i<n;i++)\n    {\n      fgets(siki,sizeof(siki),stdin);\n      if(!isprint(siki[strlen(siki)-1]))\n\tsiki[strlen(siki)-1]='\\0';\n      if(siki[strlen(siki)-1]='=')\n\tsiki[strlen(siki)-1]='\\0';\n       \n      ret=calc_expr(siki,strlen(siki));\n      printf(\"%d\\n\",ret);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint expr(const char **);\nint term(const char **);\nint factor(const char **);\nint number(const char **);\n\nint expr(const char **p) {\n  int val = term(p);\n  while (1) {\n    if (**p == '+') {\n      (*p)++;\n      val += term(p);\n    } else if (**p == '-') {\n      (*p)++;\n      val -= term(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint term(const char **p) {\n  int val = factor(p);\n  while (1) {\n    if (**p == '*') {\n      (*p)++;\n      val *= factor(p);\n    } else if (**p == '/') {\n      (*p)++;\n      val /= factor(p);\n    } else {\n      break;\n    }\n  }\n  return val;\n}\n\nint factor(const char **p) {\n  if (**p == '(') {\n    (*p)++;\n    int val = expr(p);\n    (*p)++;\n    return val;\n  }\n  return number(p);\n}\n\nint number(const char **p) {\n  int val = 0;\n  while ('0' <= **p && **p <= '9') {\n    val = val * 10 + **p - '0';\n    (*p)++;\n  }\n  return val;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  char s[101];\n  while (n--) {\n    scanf(\"%s\", s);\n    const char *p = s;\n    printf(\"%d\\n\", expr(&p));\n  }\n}"
  },
  {
    "language": "C",
    "code": "char*p,E[200];l;M(r){for(r=T();*p==42|*p==47;)*p++-42?(r/=T()):(r*=T());return r;}A(r){for(r=M();*p==43|*p==45;)*p++-43?(r-=M()):(r+=M());return r;}T(r){*p-40?sscanf(p,\"%d%n\",&r,&l):(r=A(++p),l=1);p+=l;return r;}main(){for(;~scanf(\"%*d\\n%[^=]=\\n\"+!!p*4,E);)printf(\"%d\\n\",A(p=E));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define N 128\n#define ADD -1\n#define SUB -2\n#define MUL -3\n#define DIV -4\n#define ESC -5\n#define LPR -6\n#define RPR -7\n\nstatic\nint * e;\n\nstatic\nint eval_1st ( void ),\n    eval_2nd ( void ),\n    eval_3rd ( void );\n\nstatic\nint eval_1st (\n  void\n  )\n{\n  if ( *e == LPR )\n  {\n    int res;\n\n    ++e;\n    res = eval_3rd ( );\n    ++e;\n    return ( res );\n  }\n  else\n  {\n    return ( *( e++ ) );\n  }\n}\n\nstatic\nint eval_2nd (\n  void\n  )\n{\n  int left = eval_1st ( );\n\n  while ( *e == MUL || *e == DIV )\n  {\n    ++e;\n    if ( e[ -1 ] == MUL ) left *= eval_1st ( );\n    else                  left /= eval_1st ( );\n  }\n\n  return ( left );\n}\n\nstatic\nint eval_3rd (\n  void\n  )\n{\n  int left = eval_2nd ( );\n\n  while ( *e == ADD || *e == SUB )\n  {\n    ++e;\n    if ( e[ -1 ] == ADD ) left += eval_2nd ( );\n    else                  left -= eval_2nd ( );\n  }\n\n  return ( left );\n}\n\nstatic\nint eval (\n  void\n  )\n{\n  return ( eval_3rd ( ) );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int n;\n\n  scanf ( \"%d \", &n );\n  while ( n-- )\n  {\n    int   expr[ N ] = { 0 };\n    int * p = expr;\n\n    for ( ; ; )\n    {\n      int ch = ' ';\n\n      while ( isspace ( ch ) )  ch = getchar ( );\n\n      switch ( ch )\n      {\n        case '+':   ++p; *( p++ ) = ADD; break;\n        case '-':   ++p; *( p++ ) = SUB; break;\n        case '*':   ++p; *( p++ ) = MUL; break;\n        case '/':   ++p; *( p++ ) = DIV; break;\n        case '=':   ++p; *( p++ ) = ESC; goto BREAKK;\n        case '(':        *( p++ ) = LPR; break;\n        case ')':   ++p; *( p   ) = RPR; break;\n        default:\n          *p = *p * 10 + ( ch - '0' );\n          break;\n      }\n    }\nBREAKK:\n    e = expr;\n    printf ( \"%d\\n\", eval ( ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include  <stdio.h>\n//<expr>   ::= <term> [ ('+'|'-') <term> ]*\n//<term>   ::= <factor> [ ('*'|'/') <factor> ]*\n//<factor> ::= <number> | '(' <expr> ')'\n//<number> :== 1?????\\????????°???\nint expr();\nint term();\nint fact();\nint number();\n\nint n,idx;\n\nchar s[101];\nint expr(void){\n    int res=term();\n        for(;s[idx] == '+' || s[idx]=='-';){\n        char ope=s[idx++];\n        char temp=term();\n        ope=='+'?(res+=temp):(res-=temp);\n    }\n    return res;\n}\nint term(void){\n    int res=fact();\n    for(;s[idx]=='*' || s[idx]=='/';){\n        char ope=s[idx++];\n        int temp=fact();\n        ope=='*'?(res*=temp):(res/=temp);\n    }\n    return res;\n}\nint fact(void){\n    int res;\n    if(s[idx]=='('){\n        idx++;\n        res=expr();\n        idx++;\n    }\n    else\n        res=number();\n    return res;\n}\nint number(void){\n    int res=0;\n    for(;'0' <= s[idx] && s[idx] <= '9';idx++){\n        res=res*10+s[idx]-'0';\n    }\n    return res;\n}\nint main(void){\n    int i;\n    scanf(\"%d\\n\",&n);\n    for(i=0;i<n;i++){\n        idx=0;\n        fgets(s,101,stdin);\n        printf(\"%d\\n\",expr());\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<string.h>\n#include<math.h>\n#include<time.h>\nconst char symbollist[] = \"+-*/()$;\" ;//??????????????????\nchar SymbolJudge(char c, const char* str)//?????????????????¢??°\n{\n  for(size_t i = 0; str[i] != '\\0'; ++i )\n  {\n    if( c == str[i])\n    {\n      return str[i] ;\n    }\n  }\n  return 0 ;\n}\n\nint Judge(char *str)//()????????????????????????????????¢??°\n{\n  int pa_n = 0;\n  for(size_t i = 0; str[i] != '\\0'; ++i )\n  {\n    if(str[i] == '('){\n      ++pa_n ;\n    }\n  }\n  return pa_n ;\n}\n\nint Str(const char* str,const char* tar,const char* bul){//?????????????????¢??°\n  char *temp ;\n  size_t slen = strlen(str) ;\n  size_t tlen = strlen(tar) ;\n  size_t blen = strlen(bul) ;\n  if((temp = strstr(str,tar)) == NULL){\n    return 0 ;\n  }\n  memmove(temp + blen,temp + tlen,slen - (temp + tlen - str) + 1 ) ;\n  memcpy(temp, bul , blen) ;\n  return 1 ;\n}\nconst int N = 200;\ndouble EasyCalc(char *string){//()??????????¨????????????¢??°\n  char formula[100] = {}, operators[N], temp[N], c ;\n  size_t i, j = 0, nu_n = 0, op_n = 0 ;\n  int tmp = 0  ;\n  double num[N] ;\n  strcpy(formula,string ) ;\n  while(Str(formula,\" \",\"\")) ;\n  strcat(formula,\";\") ;\n  for(i = 0,j = 0; formula[i] != '\\0'; ++ i){\n    if(SymbolJudge(formula[i], symbollist) == '-'){\n      if(i == 0 || SymbolJudge(formula[i-1], symbollist) != 0){\n        temp[j] = formula[i] ;\n        ++j ;\n        operators[op_n] = '+';\n      }\n      else{\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else if((c =SymbolJudge(formula[i], symbollist)) != 0){\n      if(c != '('){\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else{\n      temp[j] = formula[i] ;\n      ++j ;\n    }\n  }\n  tmp = 0 ;\n  while(1){\n    if((c=SymbolJudge(operators[tmp], symbollist) ) == ';'){\n      break ;\n    }\n    switch(c){\n      case '*':\n        num[tmp] *= num[tmp + 1];\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '/':\n        num[tmp] /= num[tmp + 1];\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        ++tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == 0){\n        num[j] = num[j + 1] ;\n        num[j + 1] = 0 ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  tmp = 0 ;\n  while(1){\n    if((c=SymbolJudge(operators[0],symbollist)) == ';'){\n      break ;\n    }\n    switch(c){\n      case '+':\n        num[tmp] += num[tmp + 1] ;\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '-':\n        num[tmp] -= num[tmp + 1] ;\n        num[tmp + 1] = 0 ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        ++ tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == 0){\n        num[j] = num[j + 1] ;\n        num[j + 1] = 0 ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  return num[0] ;\n}\ndouble Calculation(char *string)//???????????£??????????¨??????????\n{\n//   char* string = const_cast<char*>(str.c_str());\n  bool flag = false ;\n  char formula[N], formula1[N] = {}, operators[N], temp[N], c, buf[N] ;\n  int flag_p = 0, pa_n = 0 ;\n  size_t i, j = 0, nu_n = 0, op_n = 0, tmp = 0 ;\n  double num[N] , ans;\n  strcpy(formula,string ) ;\n  while(1){//()??????????¨????????????¨???\n    flag_p = Judge(formula) ;//()??????????????????????????????\n    if(flag_p == 0 ){\n      break ;\n    }\n    for(i = 0,j = 0,pa_n =0; formula[i] != '\\0' ; ++ i){\n      c = SymbolJudge(formula[i],symbollist) ;\n      if(c == '('){\n        ++pa_n ;\n        if(flag_p == pa_n){\n          formula[i] = '$' ;\n          flag = true ;\n        }\n        j = 0;\n        memset(formula1,'\\0',N) ;\n      }\n      if(flag_p == pa_n){\n        if(c == ')'){\n          formula[i] = ' ' ;\n          while(Str(formula1,\" \",\"\")) ;\n          while(Str(formula1,\"\\n\",\"\")) ;\n          ans = EasyCalc(formula1) ;\n          break ;\n        }\n        else{\n          if(flag){\n            flag = !flag ;\n          }\n          else{\n            formula1[j] = formula[i] ;\n            formula[i] = ' ' ;\n            ++ j ;\n          }\n        }\n      }\n    }\n    while(Str(formula,\" \",\"\")) ;\n    for(i = 0,j = 0; formula[i] != '\\0' ; ++ i){\n      c = SymbolJudge(formula[i],symbollist) ;\n      if(c == '$'){\n        sprintf(buf,\"%lf\",ans) ;\n        Str(formula,\"$\", buf) ;\n        break ;\n      }\n    }\n  }\n\n  strcat(formula,\";\") ;//????°?????????????????????§???????????¨???????????????????????????????¨?\n\n  Str(formula,\")\",\"\") ;\n  for(i = 0,j = 0; formula[i] != '\\0'; ++ i){\n    if(SymbolJudge(formula[i], symbollist) == '-'){\n      if(formula[i+1] != '\\0' && SymbolJudge(formula[i+1], symbollist) == '-'){\n        num[nu_n] = -1 ;\n        ++nu_n ;\n        operators[op_n] = '*' ;\n        ++op_n ;\n      }\n      else if(i == 0 || SymbolJudge(formula[i-1], symbollist) != 0){//????????°??????????????????\n        temp[j] = formula[i] ;\n        ++j ;\n        operators[op_n] = '+';\n      }\n      else{//???????????°?????¨???????????????????????????\n        operators[op_n] = formula[i] ;//????????????????´?\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else if((c =SymbolJudge(formula[i], symbollist)) != 0){//????????????????????°??§???????????§??????\n      if(c != '('){\n        operators[op_n] = formula[i] ;\n        ++op_n ;\n        j = 0 ;\n        num[nu_n] = atof(temp) ;\n        ++ nu_n ;\n        memset(temp,'\\0', N);\n      }\n    }\n    else{//???????????§??????????????°??§??????\n      temp[j] = formula[i] ;\n      ++j ;\n    }\n  }\n  while(1){//*/??????????????????\n//         printf(\"%lf\\n\",num[nu_n-1]) ;\n    if((c=SymbolJudge(operators[tmp], symbollist) ) == ';'){//???????????????????????????\n      break ;\n    }\n    switch(c){//????´?????????????????????????????????£?????????????????????\n      case '*':\n        num[tmp] *= num[tmp + 1];\n        num[tmp + 1] = INFINITY ;//????????¨?????\\?????????????????¨??????\n        operators[tmp] = '\\0' ;//????????¨?????\\???\n        break ;\n      case '/':\n        num[tmp] /= num[tmp + 1];\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default://+-???????????§????¨?????????????\n        ++tmp ;\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){//????????¨?????\\????????????????????????????????°????????????\n      if(num[j] == INFINITY){\n        num[j] = num[j + 1] ;\n        num[j + 1] = INFINITY ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){//????§????\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  tmp = 0 ;\n  while(1){//+-?????????\n    if((c=SymbolJudge(operators[0],symbollist)) == ';'){\n      break ;\n    }\n    switch(c){//*/??¨?????????????????§??????\n      case '+':\n        num[tmp] += num[tmp + 1] ;\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      case '-':\n        num[tmp] -= num[tmp + 1] ;\n        num[tmp + 1] = INFINITY ;\n        operators[tmp] = '\\0' ;\n        break ;\n      default:\n        break ;\n    }\n    for(j = 0; j < nu_n - 1; ++ j){\n      if(num[j] == INFINITY){\n        num[j] = num[j + 1] ;\n        num[j + 1] = INFINITY ;\n      }\n    }\n    for(j = 0; j < op_n - 1; ++ j){\n      if(operators[j] == '\\0'){\n        operators[j] = operators[j+1] ;\n        operators[j + 1] = '\\0' ;\n      }\n    }\n  }\n  return num[0] ;//??°????????????????????????????????????????´??????????\n}\n\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  char str[N];\n  for(int i = 0; i < n; ++i){\n    scanf(\"%s\",str);\n    int ans = Calculation(str);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define def_func(name) int name(int f, int l)\n#define gen_func(name, next, aop1, op1, aop2, op2) \\\ndef_func(name){ \\\n    int i; \\\n    for (i = l; i >= f; i--){ \\\n        if (expr[i] == ')') i = find_open(f, i - 1) - 1; \\\n        if (expr[i] == aop1) return (name(f, i - 1) op1 next(i + 1, l)); \\\n        if (expr[i] == aop2) return (name(f, i - 1) op2 next(i + 1, l)); \\\n    } \\\n    return (next(f, l)); \\\n} \\\n\nchar expr[128];\n\ndef_func(eval);\ndef_func(term);\ndef_func(factor);\ndef_func(find_open);\n \nint main(void)\n{\n    int n, i;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\" %s\", expr);\n        printf(\"%d\\n\", eval(0, strlen(expr) - 2));\n    }\n    return (0);\n}\n\ngen_func(eval, term, '+', +, '-', -)\ngen_func(term, factor, '*', *, '/', /)\ndef_func(factor)\n{\n    if (expr[f] == '(') return (eval(f + 1, l - 1));\n    return (atoi(expr + f));\n}\n\ndef_func(find_open)\n{\n    int i;\n    int close = 0;\n    for (i = l; i >= f; i--){\n        if (expr[i] == ')') close++;\n        if (expr[i] == '('){\n            if (close == 0) break;\n            close--;\n        }\n    }\n    return (i);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n  char str[1000];\nint kigo[100];\nint hantei(char);\nmain(){\n  int l,i,j,a[100],kigo[100],k=0,i1,j1,k1;\n  int cnt=0,flg=0,bai=1,ans=0,ans2=0,v;\n  for(i=0;i<100;i++)a[i]=0;\n  printf(\"Smart Calculatorにようこそ!!\\n\");\n  printf(\"式 \");\n  scanf(\"%s\",str);\n  l=strlen(str);\n\n\n  for(i1=0;i1<=l;i1++){\n    if(str[i1]=='('){\n      for(j1=i1+1;str[j1]!=')';j1++);\n\n      for(i=i1;i<=j1;i++){\n\tbai*=10;\n\tif(!(str[i]>='0'&&str[i]<='9')){\n\t  bai/=10;\n\t  if(cnt==0)bai/=10;\n\t  for(j=k;j<=i;j++,bai/=10){\n\t    a[cnt]+=bai*(str[j]-'0');\n\t  }\n\t  kigo[cnt]=hantei(str[i]);\n\t  if(kigo[cnt]==0)goto keisan1;\n\t  cnt++,i++;\n\t  bai=1,k=i;\n\t}\n      }\n\n\n    keisan1:\n     \n      for(i=0;i<=cnt;i++){\n\tif(kigo[i]==3){\n\t  a[i+1]*=a[i];\n\t  a[i]=0;\n\t  kigo[i]=1;\n\t}else if (kigo[i]==4){\n\t  a[i+1]=a[i]/a[i+1];\n\t  a[i]=0;\n\t  kigo[i]=1;\n\t}\n\t}\n      ans+=a[0];\n      v=kigo[0];\n          for(i=1;i<=cnt;i++){\n\t  if(a[i]!=0){\n\t    if(v==1){\n\t      ans+=a[i];\n\t    }else if(v==2){\n\t      ans-=a[i];\n\t    }\n\t    v=kigo[i];\n\t  }\n\t  }\n\t  for(k1=1,ans2=1;ans/k1!=0;k1*=10,ans2++);\n\t  k1/=10;\n\t  flg=k1;\n\t  for(i=i1;k1>=10;k1/=10,i++){\n\t    str[i]=(ans/10)+48;\n\t  }\n\t  str[i]=(ans%flg)+48;\n\t  i++;\n\t  j=i;\n\t  for(;str[i]!=')';i++);\n\t  i++;\n\t  for(;i<l;i++,j++)str[j]=str[i];\n\t  for(;j<l;j++)str[j]='\\0';\n\t  l=strlen(str);\n    }\n  }\n  \n  cnt=0,ans=0,bai=1,k=0,flg=0;\n  for(i=0;i<100;i++)kigo[i]=0,a[i]=0;\n  for(i=0;i<=l;i++){\n    bai*=10;\n    if(!(str[i]>='0'&&str[i]<='9')){\n      bai/=10;\n      if(cnt==0)bai/=10;\n      for(j=k;j<=i;j++,bai/=10){\n\ta[cnt]+=bai*(str[j]-'0');\n      }\n      kigo[cnt]=hantei(str[i]);\n      if(kigo[cnt]==0)goto keisan;\n      cnt++,i++;\n      bai=1,k=i;\n    }\n  }\n keisan:\n  for(i=0;i<=cnt;i++){\n    if(kigo[i]==3){\n      a[i+1]*=a[i];\n      a[i]=0;\n      kigo[i]=1;\n  }else if (kigo[i]==4){\n    a[i+1]=a[i]/a[i+1];\n    a[i]=0;\n    kigo[i]=1;\n  }\n  }\n  ans+=a[0];\n  v=kigo[0];\n   for(i=1;i<=cnt;i++){\n     if(a[i]!=0){\n    if(v==1){\n      ans+=a[i];\n    }else if(v==2){\n      ans-=a[i];\n    }\n     v=kigo[i];\n     }\n   }\n \n   //      for(i=0;i<cnt;i++){\n   //        printf(\"%d %d\\n\",a[i],kigo[i]);\n   // }\n   printf(\"%d\\n\",ans);\n  \nreturn 0;\n\n  }\n\nint hantei(char s){\n  switch(s){\n  case'+':return 1;\n  case'-':return 2;\n  case'*':return 3;\n  case'/':return 4;\n  default:return 1;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum command_type {\n\tVALUE = 0x2,\n\tOP_ADD = 0x4,\n\tOP_SUB = 0x5,\n\tOP_MUL = 0x8,\n\tOP_DIV = 0x9\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tint value;\n\tstruct command_t *next;\n};\ntypedef struct command_t Command;\n\nvoid expression(void);\n\nchar g_tokens[128][128];\nchar *g_symbol;\nint g_index;\nCommand *g_commands = NULL;\n\nvoid command_append(CommandType type, int value) {\n\tCommand *tmp, *new;\n\n\tnew = malloc(sizeof(Command));\n\tnew->type = type;\n\tnew->value = value;\n\tnew->next = NULL;\n\tif (g_commands == NULL) {\n\t\tg_commands = new;\n\t} else {\n\t\tfor (tmp = g_commands; tmp->next != NULL; tmp = tmp->next);\n\t\ttmp->next = new;\n\t}\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_index++];\n}\n\nvoid factor(void) {\n\tint value;\n\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tvalue = atoi(g_symbol);\n\t\tcommand_append(VALUE, value);\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tCommand *cmd, *tmp;\n\n\tg_index = 0;\n\tfor (cmd = g_commands; cmd != NULL;) {\n\t\ttmp = cmd;\n\t\tcmd = cmd->next;\n\t\tfree(tmp);\n\t}\n\tg_commands = NULL;\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n}\n\n\nvoid tokenize(char *in) {\n\tint digit, n, i;\n\n\tdigit = n = i = 0;\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t\tdigit = 1;\n\t\t} else {\n\t\t\tif (digit) {\n\t\t\t\tn++;\n\t\t\t\tdigit = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nint run(void) {\n\tint stack[128];\n\tint top = -1, buf;\n\tCommand *cmd;\n\n\tfor (cmd = g_commands; cmd != NULL; cmd = cmd->next) {\n\t\tif (cmd->type == VALUE) {\n\t\t\tstack[++top] = cmd->value;\n\t\t} else if (cmd->type == OP_ADD) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] += buf;\n\t\t} else if (cmd->type == OP_SUB) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] -= buf;\n\t\t} else if (cmd->type == OP_MUL) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] *= buf;\n\t\t} else if (cmd->type == OP_DIV) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] /= buf;\n\t\t}\n\t}\n\treturn stack[top];\n}\n\nint main(void) {\n\tint n, i;\n\tchar in[128];\n\n\tscanf(\"%d \", &n);\n\n\twhile (n--) {\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tg_tokens[i][0] = '\\0';\n\t\t}\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%d\\n\", run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128],c;\n  char a[128],st[128],b[128];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<128;j++){\n      b[j]='\\0';\n      st[j]='\\0';\n    }\n    /*\n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n    */\n    q=0;\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n     else if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        res = addsub(idx + 1);\n    }\n    else {\n        while (isdigit(formula[idx])){\n            res = res * 10 + formula[idx] - '0';\n            ++idx;\n        }\n    }\n    //printf(\"   %d\\n\", res);\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n            //printf(\"  %d\\n\", res);\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n            //printf(\"  %d\\n\", res);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (!isdigit(formula[idx]) && !brackets){\n            break;\n        }\n        ++idx;\n    }\n    //printf(\"  %d\\n\", res);\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n            //printf(\"  %d\\n\", res);\n        }\n        else if (formula[idx] == '-' && !brackets){\n            res -= muldiv(idx + 1);\n            //printf(\"  %d\\n\", res);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            if (!brackets){\n                break;\n            }\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n    }\n    //printf(\" %d\\n\", res);\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": " #include <stdio.h>\n\nint main(void){\n\tint i,n,result,a,b,val[100],sym[100],v,s,x,y,p,q,g,h;\n\tscanf(\"%d\",&n);\n\tfor(i=0; i<n; i++){\n\t\tresult=0;\n\t\tb=0;\n\t\tv=0;\n\t\ts=1;\n\t\tsym[0]='(';\n\t\ta=getchar();\n\t\twhile(a!='='){\n\t\t\tif(a>='0' && a<='9'){\n\t\t\t\tb=(b*10+a-'0');\n\t\t\t}else{\n\t\t\t\tswitch(a){\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\tcase ')':\n\t\t\t\t\tsym[s]=a;\n\t\t\t\t\tval[v]=b;\n\t\t\t\t\ts++;\n\t\t\t\t\tv++;\n\t\t\t\t\tb=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '(':\n\t\t\t\t\tsym[s]='(';\n\t\t\t\t\ts++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta=getchar();\n\t\t}\n\t\tif(b!=0){\n\t\t\tval[v]=b;\n\t\t\tv++;\n\t\t}\n\t\tsym[s]=')';\n\t\ts++;\n\t\tp=1;\n\t\tfor(q=0; q<s; q++){\n\t\t\tif(sym[q]==')'){\n\t\t\t\tg=q;\n\t\t\t\th=p;\n\t\t\t\twhile(sym[g]!='('){\n\t\t\t\t\tg--;\n\t\t\t\t\tif(sym[g]!='?'){\n\t\t\t\t\t\th--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ty=(h+1);\n\t\t\t\tfor(x=g; x<q; x++){\n\t\t\t\t\tswitch(sym[x]){\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tval[y]*=(-1);\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tval[y]*=val[y-1];\n\t\t\t\t\t\tval[y-1]=0;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tval[y]=val[y-1]/val[y];\n\t\t\t\t\t\tval[y-1]=0;\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsym[x]='!';\n\t\t\t\t}\n\t\t\t\tresult=0;\n\t\t\t\tfor(x=h; x<=p; x++){\n\t\t\t\t\tresult+=val[x];\n\t\t\t\t\tval[x]=0;\n\t\t\t\t}\n\t\t\t\tval[h]=result;\n\t\t\t\tsym[g]='?';\n\t\t\t\tsym[q]='?';\n\t\t\t}else if(sym[q]!='(' && sym[q]!='?'){\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nenum {/*type*/\n\tTYPE_NUMBER,\n\tTYPE_ENZANSI,\n\tTYPE_HENSUU,\n\tTYPE_FUNCTION\n};\nenum {/*enzansi*/\n\tENZ_PLUS,\n\tENZ_MINUS,\n\tENZ_MUL,\n\tENZ_DIV,\n\t/*ENZ_POW,*/\n\tENZ_INV\n};\n\ntypedef struct {\n\tint type;\n\tint suuzi;\n\tint enzansi;\n\tint hikisuunum;\n}VALUE;\n\ntypedef struct _values {\n\tVALUE value;\n\tstruct _values* next;\n} VALUECHAIN;\n\ntypedef struct _vcadmin {\n\tVALUECHAIN* first;\n\tVALUECHAIN* last;\n} VCADMIN;\n\nenum {/*status*/\n\tSTAT_NUMBER,\n\tSTAT_ENZANSI,\n\tSTAT_HENSUU,\n\tSTAT_FUNCTION,\n\tSTAT_KAKKO\n};\n\nenum {/*G[R[h*/\n\tERROR_INVALIDNUM=1,\n\tERROR_NULLPOINTER,\n\tERROR_INVALIDNUMBER,\n\tERROR_INVALIDSIKI,\n\tERROR_KAKKOERROR,\n\tERROR_NOSIKIBETUSI,\n\tERROR_DIV0,\n\tERROR_FUNCTIONERROR,\n\tERROR_NOSTACK,\n\tERROR_OVERSTACK,\n\tERROR_UNDEFINEDTYPE,\n\tERROR_UNDEFINEDENZANSI,\n\tERROR_UNDEFINEDHENSUU,\n\tERROR_UNDEFINEDFUNCTION\n};\n\ntypedef struct _numchain {\n\tint num;\n\tstruct _numchain* next;\n} NUMCHAIN;\n\ninline void* malloc2(unsigned int size) {\n\treturn malloc(size);\n}\n\ninline int free2(void* ptr) {\n\tfree(ptr);\n\treturn 0;\n}\n\ninline int str2int(int* result,char* str,int length) {\n\tint error=0;\n\tint i;\n\tint _result=0;\n\tfor(i=0;i<length;i++) {\n\t\tif(str[i]>='0' && str[i]<='9') {\n\t\t\t_result=_result*10+(str[i]-'0');\n\t\t} else {\n\t\t\terror=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(error==0)*result=_result;\n\treturn error;\n}\n\ninline int tuyosa(int enzansi) {\n\tswitch(enzansi) {\n\t\tcase ENZ_PLUS:\n\t\t\tcase ENZ_MINUS:\n\t\t\treturn 1;break;\n\t\tcase ENZ_MUL:\n\t\tcase ENZ_DIV:\n\t\t\treturn 2;break;\n\t\t/*case ENZ_POW:\n\t\t\treturn 3;break;*/\n\t\tdefault:\n\t\t\treturn 0;break;\n\t}\n\treturn 0;\n}\n\ninline int code2enz(char code) {\n\tswitch(code) {\n\t\tcase '+':\n\t\t\treturn ENZ_PLUS;break;\n\t\tcase '-':\n\t\t\treturn ENZ_MINUS;break;\n\t\tcase '*':\n\t\t\treturn ENZ_MUL;break;\n\t\tcase '/':\n\t\t\treturn ENZ_DIV;break;\n\t\t/*case '^':\n\t\t\treturn ENZ_POW;break;*/\n\t\tdefault:\n\t\t\treturn -1;break;\n\t}\n\treturn -1;\n}\n\nvoid freestack(VALUECHAIN* stacklast) {\n\tVALUECHAIN* cur;\n\tVALUECHAIN* next;\n\tcur=stacklast;\n\twhile(cur!=NULL) {\n\t\tnext=cur->next;\n\t\tfree2(cur);\n\t\tcur=next;\n\t}\n}\n\nint henkan(VCADMIN* result,char* input,int length) {\n\tVALUECHAIN* stacklast=NULL;\n\tVALUECHAIN* now;\n\tint i;\n\tint first=0;\n\tint error=0;\n\tint status=-1;\n\tint curenzansi;\n\tint minus=0;\n\tif(length==0) {\n\t\treturn ERROR_INVALIDSIKI;\n\t}\n\tif(input[0]=='-') {\n\t\tminus=1;\n\t\ti=1;\n\t} else if(input[0]=='+')i=1; else i=0;\n\tfor(;i<length;i++) {\n\t\tif((input[i]>='0' && input[i]<='9') || input[i]=='.') {/**/\n\t\t\tif(status!=-1 && status!=STAT_ENZANSI && status!=STAT_NUMBER) {\n\t\t\t\tfreestack(stacklast);\n\t\t\t\treturn ERROR_INVALIDSIKI;\n\t\t\t}\n\t\t\tif(status==-1 || status!=STAT_NUMBER) {\n\t\t\t\tfirst=i;\n\t\t\t}\n\t\t\tstatus=STAT_NUMBER;\n\t\t} else {\n\t\t\t/*ð®ÉÇÁ*/\n\t\t\tif(status==STAT_NUMBER) {\n\t\t\t\tnow=malloc2(sizeof(VALUECHAIN));\n\t\t\t\tnow->value.type=TYPE_NUMBER;\n\t\t\t\tnow->next=NULL;\n\t\t\t\tif(str2int(&(now->value.suuzi),&input[first],i-first)) {\n\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\treturn ERROR_INVALIDNUMBER;\n\t\t\t\t}\n\t\t\t\tif(result->first==NULL) {\n\t\t\t\t\tresult->first=now;\n\t\t\t\t} else {\n\t\t\t\t\tresult->last->next=now;\n\t\t\t\t}\n\t\t\t\tresult->last=now;\n\t\t\t\tif(minus) {\n\t\t\t\t\tnow=malloc2(sizeof(VALUECHAIN));\n\t\t\t\t\tnow->value.type=TYPE_ENZANSI;\n\t\t\t\t\tnow->next=NULL;\n\t\t\t\t\tnow->value.enzansi=ENZ_INV;\n\t\t\t\t\tif(result->first==NULL) {\n\t\t\t\t\t\tresult->first=now;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult->last->next=now;\n\t\t\t\t\t}\n\t\t\t\t\tresult->last=now;\n\t\t\t\t\tminus=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(input[i]=='+' || input[i]=='-' ||\n\t\t\t\t\tinput[i]=='*' || input[i]=='/'/* ||\n\t\t\t\t\tinput[i]=='^'*/) {/*Zq*/\n\t\t\t\tif(status==-1 || status==TYPE_ENZANSI) {\n\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\treturn ERROR_INVALIDSIKI;\n\t\t\t\t}\n\t\t\t\tcurenzansi=code2enz(input[i]);\n\t\t\t\tif(stacklast!=NULL) {\n\t\t\t\t\twhile(stacklast!=NULL &&\n\t\t\t\t\t\t\ttuyosa(stacklast->value.enzansi)\n\t\t\t\t\t\t\t>=tuyosa(curenzansi)) {\n\t\t\t\t\t\t/*Zqð®ÉÇÁ*/\n\t\t\t\t\t\tif(result->first==NULL) {\n\t\t\t\t\t\t\tresult->first=stacklast;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult->last->next=stacklast;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult->last=stacklast;\n\t\t\t\t\t\tstacklast=stacklast->next;\n\t\t\t\t\t\tresult->last->next=NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*ZqðX^bNÉÇÁ*/\n\t\t\t\tnow=malloc2(sizeof(VALUECHAIN));\n\t\t\t\tnow->value.type=TYPE_ENZANSI;\n\t\t\t\tnow->value.enzansi=curenzansi;\n\t\t\t\tnow->next=stacklast;\n\t\t\t\tstacklast=now;\n\t\t\t\t/*óÔðÏX*/\n\t\t\t\tstatus=STAT_ENZANSI;\n\t\t\t} else {\n\t\t\t\tif(status!=-1 && status!=STAT_ENZANSI) {\n\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\treturn ERROR_INVALIDSIKI;\n\t\t\t\t}\n\t\t\t\tif(input[i]=='(') {/*Ê*/\n\t\t\t\t\tint kakko;\n\t\t\t\t\tint rs;\n\t\t\t\t\tkakko=1;\n\t\t\t\t\tfirst=i+1;\n\t\t\t\t\tfor(i++;i<length;i++) {\n\t\t\t\t\t\tif(input[i]=='(')kakko++;\n\t\t\t\t\t\tif(input[i]==')')kakko--;\n\t\t\t\t\t\tif(kakko<=0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(kakko>0) {\n\t\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\t\treturn ERROR_KAKKOERROR;\n\t\t\t\t\t}\n\t\t\t\t\trs=henkan(result,&input[first],i-first);\n\t\t\t\t\tif(rs) {\n\t\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\t\treturn rs;\n\t\t\t\t\t}\n\t\t\t\t\tif(minus) {\n\t\t\t\t\t\tnow=malloc2(sizeof(VALUECHAIN));\n\t\t\t\t\t\tnow->value.type=TYPE_ENZANSI;\n\t\t\t\t\t\tnow->next=NULL;\n\t\t\t\t\t\tnow->value.enzansi=ENZ_INV;\n\t\t\t\t\t\tif(result->first==NULL) {\n\t\t\t\t\t\t\tresult->first=now;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult->last->next=now;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult->last=now;\n\t\t\t\t\t\tminus=0;\n\t\t\t\t\t}\n\t\t\t\t\t/*óÔðÏX*/\n\t\t\t\t\tstatus=STAT_KAKKO;\n\t\t\t\t} else if(input[i]==')') {/*G[*/\n\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\treturn ERROR_KAKKOERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(status==STAT_ENZANSI) {\n\t\tfreestack(stacklast);\n\t\treturn ERROR_INVALIDSIKI;\n\t}\n\t/*ð®ÉÇÁ*/\n\tif(status==STAT_NUMBER) {\n\t\tnow=malloc2(sizeof(VALUECHAIN));\n\t\tnow->value.type=TYPE_NUMBER;\n\t\tnow->next=NULL;\n\t\tif(str2int(&(now->value.suuzi),&input[first],i-first)) {\n\t\t\tfreestack(stacklast);\n\t\t\treturn ERROR_INVALIDNUMBER;\n\t\t}\n\t\tif(result->first==NULL) {\n\t\t\tresult->first=now;\n\t\t} else {\n\t\t\tresult->last->next=now;\n\t\t}\n\t\tresult->last=now;\n\t}\n\tif(minus) {\n\t\tnow=malloc2(sizeof(VALUECHAIN));\n\t\tnow->value.type=TYPE_ENZANSI;\n\t\tnow->next=NULL;\n\t\tnow->value.enzansi=ENZ_INV;\n\t\tif(result->first==NULL) {\n\t\t\tresult->first=now;\n\t\t} else {\n\t\t\tresult->last->next=now;\n\t\t}\n\t\tresult->last=now;\n\t\tminus=0;\n\t}\n\t/*Zqð®ÉÇÁ*/\n\twhile(stacklast!=NULL) {\n\t\tif(result->first==NULL) {\n\t\t\tresult->first=stacklast;\n\t\t} else {\n\t\t\tresult->last->next=stacklast;\n\t\t}\n\t\tresult->last=stacklast;\n\t\tstacklast=stacklast->next;\n\t\tresult->last->next=NULL;\n\t}\n\tfreestack(stacklast);\n\treturn 0;\n}\n\nint strcalc(int* result,char* input) {\n\tVCADMIN siki;\n\tVALUECHAIN* stacklast=NULL;\n\tVALUECHAIN* stacktemp;\n\tVALUECHAIN* stackprev;\n\tVALUECHAIN* now;\n\tint henkanresult;\n\tsiki.first=NULL;\n\tsiki.last=NULL;\n\thenkanresult=henkan(&siki,input,strlen(input));\n\tif(henkanresult!=0) {\n\t\tVALUECHAIN* cur;\n\t\tVALUECHAIN* next;\n\t\t/*Jú*/\n\t\tcur=siki.first;\n\t\twhile(cur!=NULL) {\n\t\t\tnext=cur->next;\n\t\t\tfree2(cur);\n\t\t\tcur=next;\n\t\t}\n\t\treturn henkanresult;\n\t}\n\t/*vZ*/\n\tnow=siki.first;\n\twhile(now!=NULL) {\n\t\tswitch(now->value.type) {\n\t\t\tcase TYPE_NUMBER:\n\t\t\t\tstacktemp=malloc2(sizeof(VALUECHAIN));\n\t\t\t\tstacktemp->value.type=TYPE_NUMBER;\n\t\t\t\tstacktemp->value.suuzi=now->value.suuzi;\n\t\t\t\tstacktemp->next=stacklast;\n\t\t\t\tstacklast=stacktemp;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_ENZANSI:\n\t\t\t\tif(stacklast==NULL) {\n\t\t\t\t\tfreestack(siki.first);\n\t\t\t\t\treturn ERROR_NOSTACK;\n\t\t\t\t}\n\t\t\t\tstackprev=stacklast->next;\n\t\t\t\tif(now->value.enzansi!=ENZ_INV && stackprev==NULL) {\n\t\t\t\t\tfreestack(siki.first);\n\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\treturn ERROR_NOSTACK;\n\t\t\t\t}\n\t\t\t\tswitch(now->value.enzansi) {\n\t\t\t\t\tcase ENZ_PLUS:\n\t\t\t\t\t\tstackprev->value.suuzi+=stacklast->value.suuzi;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ENZ_MINUS:\n\t\t\t\t\t\tstackprev->value.suuzi-=stacklast->value.suuzi;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ENZ_MUL:\n\t\t\t\t\t\tstackprev->value.suuzi*=stacklast->value.suuzi;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ENZ_DIV:\n\t\t\t\t\t\tif(stacklast->value.suuzi==0) {\n\t\t\t\t\t\t\tfreestack(siki.first);\n\t\t\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\t\t\treturn ERROR_DIV0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackprev->value.suuzi/=stacklast->value.suuzi;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ENZ_INV:\n\t\t\t\t\t\tstacklast->value.suuzi=-(stacklast->value.suuzi);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfreestack(siki.first);\n\t\t\t\t\t\tfreestack(stacklast);\n\t\t\t\t\t\treturn ERROR_UNDEFINEDENZANSI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now->value.enzansi!=ENZ_INV) {\n\t\t\t\t\tfree2(stacklast);\n\t\t\t\t\tstacklast=stackprev;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfreestack(siki.first);\n\t\t\t\tfreestack(stacklast);\n\t\t\t\treturn ERROR_UNDEFINEDTYPE;\n\t\t\t\tbreak;\n\t\t}\n\t\tnow=now->next;\n\t}\n\tif(stacklast==NULL) {\n\t\tfreestack(siki.first);\n\t\treturn ERROR_NOSTACK;\n\t}\n\tif(stacklast->next!=NULL) {\n\t\tfreestack(siki.first);\n\t\tfreestack(stacklast);\n\t\treturn ERROR_OVERSTACK;\n\t}\n\t*result=stacklast->value.suuzi;\n\t/*Jú*/\n\tfreestack(siki.first);\n\tfreestack(stacklast);\n\treturn 0;\n}\n\nint main(void) {\n\tint kazu,now;\n\tint result;\n\tchar siki[101];\n\tscanf(\"%d\",&kazu);\n\twhile(getchar()!='\\n');\n\tfor(now=0;now<kazu;now++) {\n\t\tfgets(siki,sizeof(siki),stdin);\n\t\t*strchr(siki,'=')=0;\n\t\tif(strcalc(&result,siki))return 1;\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main(){\n\n  int n,i,j,k,l,m,p,q,st2[128];\n  char a[254],st[254],b[254];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",a);\n    k=0;\n    m=0;\n    p=0;\n    q=0;\n    for(j=0;j<254;j++){\n      b[j]='!';\n      st[j]='!';\n    }\n    \n    for(j=0;j<strlen(a);j++){\n      if(isdigit(a[j]) != 0){\n\tb[k]=a[j];\n\tk++;\n      }\n      else if(a[j]=='='){\n\twhile(p>0){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n      }\n      else if(p==0 || a[j]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(a[j]==')'){\n\tst[p]=a[j];\n\twhile(st[p-1]!='('){\n\t  p--;\n\t  b[k]=st[p];\n\t  k++;\n\t}\n\tp--;\n      }\n      else if(a[j]=='+' || a[j]=='-'){\n\tif(st[p-1]!='*' || st[p-1]!='/'){\n\t  st[p]=a[j];\n\t  p++;\n\t}\n\telse if(st[p-1]=='*' || st[p-1]=='/' || st[p-1]=='('){\n\t  p--;\t \n\t  b[k]=st[p];\n\t  k++;\n\t  p++;\n\t  st[p]=a[j];\n\t}\n      }\n      else if((a[j]=='*') || (a[j]=='/')){\n\tif(st[p-1]=='*' || st[p-1]=='/'){\n\t  p--;\n\t  b[k]=st[p];\n      \t  k++;\n\t}\n\tst[p]=a[j];\n\tp++;\n      }\n      else if(st[p-1]=='+' || st[p-1]=='-' || st[p-1]=='('){\n\tst[p]=a[j];\n\tp++;\n      }\n    }\n\n    q=0;\n    for(m=0;m<128;m++){\n      if(isdigit(b[m])!=0){\n\tst2[q]=b[m]-'0';\n\tq++;\n      }\n     else if(b[m]=='+'){\n\tst2[q-2]=st2[q-2]+st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='-'){\n\tst2[q-2]=st2[q-2]-st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='*'){\n\tst2[q-2]=st2[q-2]*st2[q-1];\n\tq--;\n      }\n     else if(b[m]=='/'){\n\tst2[q-2]=st2[q-2]/st2[q-1];\n\tq--;\n      }\n    }\n\n    printf(\"%d\\n\",st2[0]);\n  }  \n    \n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint shiki();\nint shiki2();\nint num();\n\nchar input[101];\nint pos = 0;\n\nint num(){\n  int n = 0;\n\n  if(input[pos] == '('){\n    pos++;\n    n = shiki();\n    \n    if(input[pos] == ')'){\n      pos++;\n      return n;\n    }\n  }else{\n    while('0' <= input[pos] && input[pos] <= '9'){\n      n = n*10 + (input[pos] - '0');\n      pos++;\n    }\n  }\n  return n;\n}\n\nint shiki2(){\n  int first,second;\n  \n  first = num();\n  for(;;){\n    if(input[pos] == '*'){\n      pos++;\n      second = num();\n      first *= second; \n    }else if(input[pos] == '/'){\n      pos++;\n      second = num();\n      first /= second;\n    }else{\n      return first;\n    }\n  }\n}\n\nint shiki(){\n  int first,second;\n  \n  first = shiki2();\n  \n  for(;;){\n    if(input[pos] == '+'){\n      pos++;\n      second = shiki2();\n      first += second; \n    }else if(input[pos] == '-'){\n      pos++;\n      second = shiki2();\n      first -= second;\n    }else{\n      return first;\n    }\n  }\n}\n\nvoid clear(){\n  memset(input,0,sizeof(input));\n  pos = 0;\n}\n\nint main(int argc,char* argv[]){\n  int n,i,j;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0; i < n; i++){\n    clear();\n    scanf(\"%s\",input);\n\n    printf(\"%d\\n\",shiki());\n    \n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        return addsub(idx + 1);\n    }\n    else if (formula[idx] == '-'){\n        return -number(idx + 1);\n    }\n    while (isdigit(formula[idx])){\n        res = res * 10 + formula[idx] - '0';\n        ++idx;\n    }\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (!isdigit(formula[idx])){\n            break;\n        }\n        ++idx;\n    }\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int first = 1;\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n        }\n        else if (formula[idx] == '-' && !brackets && !first){\n            res -= muldiv(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n        first = 0;\n    }\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring s;\n\nint single(int& pos);\n\nint figure(int& pos);\n\nint solve(int& pos);\n\nint main(){\n\tint T;\n\tcin>>T;\n\tfor(int i = 0; i < T; i++){\n\t\tcin>>s;\n\t\tint pos = 0;\n\t\tcout<<solve(pos)<<endl;\n\t}\n\t\n\treturn 0;\n}\n\nint single(int& pos){//??°??????????????????????????¢??°\n\tif(s[pos]!='('){\n\t\tint res = 0;\n\t\twhile('0'<=s[pos] && s[pos]<='9'){\n\t\t\tres *= 10;\n\t\t\tres += s[pos]-48;\n\t\t\tpos++;\n\t\t}\n\t\treturn res;\n\t}else{\n\t\treturn solve(++pos);\n\t}\n}\n\nint figure(int& pos){//????????????????????????????????¢??°\n\tint res = single(pos);\n\twhile(1){\n\t\tif(s[pos]=='*'){\n\t\t\tres *= single(++pos);\n\t\t}else if(s[pos]=='/'){\n\t\t\tres /= single(++pos);\n\t\t}else {\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nint solve(int& pos){//?????¨???????¨????????????¢??°(????????????????¨?????????????????????¨?????????)\n\tint res = figure(pos);\n\twhile(s[pos]!='=' && s[pos]!=')'){\n\t\tif(s[pos]=='+') res += figure(++pos);\n\t\telse if(s[pos]=='-') res -= figure(++pos);\n\t}\n\tpos++;\n\treturn res;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        res = addsub(idx + 1);\n    }\n    else if (formula[idx] == '-'){\n        res = -number(idx + 1);\n    }\n    else {\n        while (isdigit(formula[idx])){\n            res = res * 10 + formula[idx] - '0';\n            ++idx;\n        }\n    }\n    //printf(\"   %d\\n\", res);\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    ++idx;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (!isdigit(formula[idx]) && !brackets){\n            break;\n        }\n        ++idx;\n    }\n    //printf(\"  %d\\n\", res);\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int first = 1;\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n        }\n        else if (formula[idx] == '-' && !brackets && !first){\n            res -= muldiv(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            if (!brackets){\n                break;\n            }\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n        first = 0;\n    }\n    //printf(\" %d\\n\", res);\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p;l;M(r){for(r=T();*p%5==2;)*p&1?r/=T():(r*=T());return r;}A(r){for(r=M();abs(*p-=44)<2;)r-=*p*M();return++p,r;}T(){return*++p-40?strtol(p,&p,10):A(p);}main(f,E){for(;~scanf(\"%s\",E);f=0)f||printf(\"%d\\n\",A(p=E-1));}"
  },
  {
    "language": "C",
    "code": "//??????B?????????????????????????????????????????§???by Mikami\n#include <stdio.h>\n#include <stdlib.h>\n#define MAX_LEN (1024)\n\n#define CONSTANT     (0) \n#define BOP_ADD      (1) \n#define BOP_SUBTRACT (2)\n#define BOP_MULTIPLY (3) \n#define BOP_DIVIDE   (4)\n#define UOP_MINUS    (5)\n#define UOP_PLUS     (6)\n\nvoid throwError(char *msg){\n\tfprintf(stderr,\"Error: %s\\n\",msg);\n\texit(1);\n}\ntypedef struct _NODE_{\n\tint type;\n\tint value;\n\tstruct _NODE_ *l,*r;\n} NODE;\n\n\nchar expr[MAX_LEN];\nint pos;\n\nNODE* S();\nNODE* E();\nNODE* T();\nNODE* F();\n\nNODE* S(){\n\tpos=0;\n\tNODE* res = E();\n\tif(expr[pos] != '\\0') throwError(\"syntax error\");\n\treturn res;\n}\n\n\nNODE* E(){\n\tNODE *res = T();\n\twhile( expr[pos] == '+' || expr[pos] == '-' ){\n\t\tNODE *tmp = (NODE*) malloc(sizeof(NODE));\n\t\tif( expr[pos] == '+'){\n\t\t\tpos++;\n\t\t\ttmp->type = BOP_ADD; \n\t\t\ttmp->l = res;\n\t\t\ttmp->r = T();\n\t\t}else{\n\t\t\tpos++;\n\t\t\ttmp->type = BOP_SUBTRACT; \n\t\t\ttmp->l = res;\n\t\t\ttmp->r = T();\n\t\t}\n\t\tres = tmp;\n\t}\n\treturn res;\n}\n\n\nNODE* T(){\n\tNODE *res = F();\n\twhile( expr[pos] == '*' || expr[pos] == '/' ){\n\t\tNODE *tmp = (NODE*) malloc(sizeof(NODE));\n\t\tif( expr[pos] == '*'){\n\t\t\tpos++;\n\t\t\ttmp->type = BOP_MULTIPLY; \n\t\t\ttmp->l = res;\n\t\t\ttmp->r = F();\n\t\t}else{\n\t\t\tpos++;\n\t\t\ttmp->type = BOP_DIVIDE; \n\t\t\ttmp->l = res;\n\t\t\ttmp->r = F();\n\t\t}\n\t\tres = tmp;\n\t}\n\treturn res;\n}\n\nNODE* F(){\n\tif( expr[pos] == '(' ){\n\t\tpos++;\n\t\tNODE *res = E();\n\t\tif( expr[pos] != ')' ) throwError(\"syntax error\");\n\t\tpos++;\n\t\treturn res;\n\t}else if( expr[pos] == '-' ){\n\t\tpos++;\n\t\tNODE *tmp = (NODE*) malloc(sizeof(NODE));\n\t\ttmp->type = UOP_MINUS;\n\t\ttmp->l = F();\n\t\ttmp->r = NULL;\n\t\treturn tmp;\n\t}else if( expr[pos] == '+' ){\n\t\tpos++;\n\t\tNODE *tmp = (NODE*) malloc(sizeof(NODE));\n\t\ttmp->type = UOP_PLUS;\n\t\ttmp->l = F();\n\t\ttmp->r = NULL;\n\t\treturn tmp;\t\n\t}else{ // number\n\t\tif( !(expr[pos] >= '0' && expr[pos] <= '9') ) throwError(\"syntax error\");\n\t\tNODE *tmp = (NODE*) malloc(sizeof(NODE));\n\t\ttmp->type = CONSTANT;\n\t\ttmp->l = tmp->r = NULL;\n\t\ttmp->value = 0;\n\t\twhile( expr[pos] >= '0' && expr[pos] <= '9' )\n\t\t\ttmp->value = tmp->value * 10 + expr[pos++] - '0';\n\t\treturn tmp;\n\t}\n}\n\nint calc(NODE *root){\n\tint tmp;\n\tswitch(root->type){\n\t\tcase BOP_ADD:\n\t\t\treturn calc(root->l)+calc(root->r);\n\t\tcase BOP_SUBTRACT:\n\t\t\treturn calc(root->l)-calc(root->r);\n\t\tcase BOP_MULTIPLY:\n\t\t\treturn calc(root->l)*calc(root->r);\n\t\tcase BOP_DIVIDE:\n\t\t\ttmp = calc(root->r);\n\t\t\tif(tmp==0) throwError(\"Division by zero\");\n\t\t\treturn calc(root->l)/tmp;\n\t\tcase UOP_PLUS:\n\t\t\treturn +calc(root->l);\n\t\tcase UOP_MINUS:\n\t\t\treturn -calc(root->l);\n\t\tcase CONSTANT:\n\t\t\treturn root->value;\n\t};\n\tthrowError(\"unknown\");\n\treturn -1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tscanf(\"%s\",expr);\n\t\texpr[strlen(expr)-1] = '\\0';\n\t\tNODE *root = S();\n\t\tprintf(\"%d\\n\",calc(root));\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstatic char s[1024];\nstatic int sp;\n\nint term(void);\nint factor(void);\nint expr(void);\nint nextInt2();\nint nextInt();\n\nint main(void)\n{\n    int i, n;\n    scanf(\"%d\",&n);\n    for (i = 0; i < n; i++) {\n        sp = 0;\n\n    scanf(\"%s\",s);\n\n    printf(\"%d\\n\",expr());\n\n    }\n    return 0;\n\n}\n\nint nextInt(void)\n{\n    int tmp;\n    tmp = s[sp] - '0';\n    sp++;\n    while (s[sp] == '0' ||\n            s[sp] == '1' ||\n            s[sp] == '2' ||\n            s[sp] == '3' ||\n            s[sp] == '4' ||\n            s[sp] == '5' ||\n            s[sp] == '6' ||\n            s[sp] == '7' ||\n            s[sp] == '8' ||\n            s[sp] == '9') {\n        tmp *= 10;\n        tmp += s[sp] - '0';\n        sp++;\n    }\n    return tmp;\n}\n\nint nextInt2(void)\n{\n    if (s[sp] == '-') {\n        sp++;\n        return nextInt() * -1;\n    } else {\n        return nextInt();\n    }\n}\n\nint term(void)\n{\n    if(s[sp]=='('){\n        int res;\n        sp++; \n        res = expr();\n        sp++;\n        return res;\n    }\n    return nextInt2();\n}\n\nint factor(void)\n{\n    int res = term();\n    while(1) {\n        if(s[sp]=='*'){\n            sp++; res *= term();\n        } else if(s[sp]=='/'){\n            sp++; res /= term();\n        } else {\n            break;\n        }\n    }\n    return res;\n}\n\nint expr(void)\n{\n    int res = factor();\n    while(1){\n        if(s[sp]=='+') {\n            sp++; res += factor();\n        } else if(s[sp]=='-') {\n            sp++; res -= factor();\n        } else {\n            break;\n        }\n    }\n    return res;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        res = addsub(idx + 1);\n    }\n    else {\n        while (isdigit(formula[idx])){\n            res = res * 10 + formula[idx] - '0';\n            ++idx;\n        }\n    }\n#ifdef DEBUG\n    printf(\"   %d\\n\", res);\n#endif\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            if (!brackets){\n                break;\n            }\n            --brackets;\n        }\n        else if (!isdigit(formula[idx]) && !brackets){\n            break;\n        }\n        ++idx;\n    }\n#ifdef DEBUG\n    printf(\"  %d\\n\", res);\n#endif\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '-' && !brackets){\n            res -= muldiv(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            if (!brackets){\n                break;\n            }\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n    }\n#ifdef DEBUG\n    printf(\" %d\\n\", res);\n#endif\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "i = 0\n\ndef number(begin):\n\tglobal i\n\t\n\tif begin[i] == \"(\":\n\t\ti += 1\n\t\tres = expression(begin)\n\t\ti += 1 \n\t\treturn res\n\t\n\tres = 0\n\t\n\twhile begin[i].isdigit():\n\t\tres *= 10\n\t\tres += int(begin[i])\n\t\ti+=1\n\t\n\treturn res\n\t\ndef term(begin):# your code goes here\n\n\tglobal i\n\tres = number(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"*\":\n\t\t\ti += 1\n\t\t\tres *= number(begin)\n\t\telif begin[i] == \"/\":\n\t\t\ti += 1\n\t\t\tres /= number(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\ndef expression(begin):\n\t\n\tglobal i\n\tres = term(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"+\":\n\t\t\ti += 1\n\t\t\tres += term(begin)\n\t\t\t\n\t\telif begin[i] == \"-\":\n\t\t\ti += 1\n\t\t\tres -= term(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\n\ndef main():\n\tex = raw_input() +\"=\"\n\tans = expression(ex)\n\t\n\tprint ans\n\t\nmain()"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0109: Smart Calculator\n// 2017.8.5\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX 100\n#define INF   1000000010\n#define LEFT (INF+1)\n#define RIGHT (INF+2)\n#define PLUS (INF+3)\n#define MINUS (INF+4)\n#define MUL (INF+5)\n#define DIV (INF+6)\n\nchar *gets(char *);\nchar buf[150], *p;\nint S[MAX + 3], top;\nint Q[MAX + 3], end;\n\nint getInt(void)\n{\n\tint n = 0;\n//\twhile (isspace(*p)) p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\nint token(char c)\n{\n\tif (c == '+') return PLUS;\n\tif (c == '-') return MINUS;\n\tif (c == '*') return MUL;\n\treturn DIV;\n}\n\nint main()\n{\n\tint i, f, k, d1, d2;\n\tint cno, cmax;\n\n\tgets(p = buf); cmax = getInt();\n\tfor (cno = 0; cno < cmax; cno++) {\n\t\tgets(p = buf), f = 1, top = 0, end = 0;\n\t\twhile (1) {\n\t\t\twhile (isspace(*p)) p++;\n\t\t\tif (!*p || *p == '=') {\n\t\t\t\twhile (top) Q[end++] = S[--top];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*p == '-' && f && isdigit(*(p + 1))) {\n\t\t\t\tp++;\n\t\t\t\tQ[end++] = -getInt();\n\t\t\t\tf = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = 0;\n\t\t\tif (isdigit(*p)) Q[end++] = getInt();\n\t\t\telse if (*p == ')') {\n\t\t\t\twhile (S[top - 1] != LEFT) Q[end++] = S[--top];\n\t\t\t\ttop--, p++;\n\t\t\t}\n\t\t\telse if (*p == '(') S[top++] = LEFT, p++, f = 1;\n\t\t\telse {\n\t\t\t\tk = token(*p++);\n\t\t\t\twhile (top) {\n\t\t\t\t\tif (k < S[top - 1]) Q[end++] = S[--top];\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tS[top++] = k;\n\t\t\t}\n\t\t}\n#if 0\n\t\tfor (i = 0; i < end; i++) printf(\"%d \", Q[i]);\n\t\tprintf(\"\\n\");\n#endif\n\t\tfor (top = i = 0; i < end; i++) {\n\t\t\tif ((k = Q[i]) > INF) {\n\t\t\t\td1 = S[--top], d2 = S[--top];\n\t\t\t\tif (k == PLUS) d2 += d1;\n\t\t\t\telse if (k == MINUS) d2 -= d1;\n\t\t\t\telse if (k == MUL) d2 *= d1;\n\t\t\t\telse d2 /= d1;\n\t\t\t\tS[top++] = d2;\n\t\t\t} else S[top++] = k;\n\t\t}\n\t\tprintf(\"%d\\n\", S[--top]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        return addsub(idx + 1);\n    }\n    else if (formula[idx] == '-'){\n        return -number(idx + 1);\n    }\n    while (isdigit(formula[idx])){\n        res = res * 10 + formula[idx] - '0';\n        ++idx;\n    }\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    while (1){\n        if (formula[idx] == '*'){\n            res *= number(idx + 1);\n        }\n        else if (formula[idx] == '/'){\n            res /= number(idx + 1);\n        }\n        else if (!isdigit(formula[idx])){\n            break;\n        }\n        ++idx;\n    }\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int first = 1;\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n        }\n        else if (formula[idx] == '-' && !brackets && !first){\n            res -= muldiv(idx + 1);\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n        first = 0;\n    }\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p,E[200];M(){int r;r=T();for(;;){if(*p=='*'){p++;r*=T();}else if(*p=='/'){p++;r/=T();}else return r;}}A(){int r;r=M();for(;;){if(*p=='+'){p++;r+=M();}else if(*p=='-'){p++;r-=M();}else return r;}}T(){int r,l;if(*p=='('){p++;r=A();p++;}else{sscanf(p,\"%d%n\",&r,&l);p+=l;}return r;}main(){scanf(\"%*d\\n\");for(;~scanf(\"%[^=]=\\n\",E);){p=E;printf(\"%d\\n\",A());}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\nint idx;\nchar formula[1024];\n\nint addsub(int idx);\n\nint number(int idx)\n{\n    int res = 0;\n    if (formula[idx] == '('){\n        res = addsub(idx + 1);\n    }\n    else {\n        while (isdigit(formula[idx])){\n            res = res * 10 + formula[idx] - '0';\n            ++idx;\n        }\n    }\n#ifdef DEBUG\n    printf(\"   %d\\n\", res);\n#endif\n    return res;\n}\n\nint muldiv(int idx)\n{\n    int res = number(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '*' && !brackets){\n            res *= number(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '/' && !brackets){\n            res /= number(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            --brackets;\n        }\n        else if (!isdigit(formula[idx]) && !brackets){\n            break;\n        }\n        ++idx;\n    }\n#ifdef DEBUG\n    printf(\"  %d\\n\", res);\n#endif\n    return res;\n}\n\nint addsub(int idx)\n{\n    int res = muldiv(idx);\n    int brackets = 0;\n    while (1){\n        if (formula[idx] == '+' && !brackets){\n            res += muldiv(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '-' && !brackets){\n            res -= muldiv(idx + 1);\n#ifdef DEBUG\n            printf(\"  %d\\n\", res);\n#endif\n        }\n        else if (formula[idx] == '('){\n            ++brackets;\n        }\n        else if (formula[idx] == ')'){\n            if (!brackets){\n                break;\n            }\n            --brackets;\n        }\n        else if (formula[idx] == '='){\n            break;\n        }\n        ++idx;\n    }\n#ifdef DEBUG\n    printf(\" %d\\n\", res);\n#endif\n    return res;\n}\n\nint main(void)\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    while (n--){\n        scanf(\"%s\", formula);\n        printf(\"%d\\n\", addsub(0));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint N;\nchar S[105];\n\nint calc(char *st,int len)\n{\n\tint i,np=0,op=0,CST[100];\n\tchar OST[100],NST[100];\n\tfor(i=0;i<len;i++)\n\t{\n\t\tswitch(st[i])\n\t\t{\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tif(OST[op-1]=='*'||OST[op-1]=='/')\n\t\t\t{\n\t\t\t\tNST[np++]=OST[op-1];\n\t\t\t\top--;\n\t\t\t}\n\t\tcase '*':\n\t\tcase '/':\n\t\t\tOST[op++]=st[i];break;\n\t\tdefault:\n\t\t\tNST[np++]=st[i];\n\t\t}\n\t}\n\tfor(i=op-1;i>=0;i--)\n\t{\n\t\tNST[np++]=OST[i];\n\t}\n\n\tfor(i=np=0;i<len;i++)\n\t{\n\t\tswitch(NST[i])\n\t\t{\n\t\tcase '+':CST[np-2]=CST[np-2]+CST[np-1];np--;break;\n\t\tcase '-':CST[np-2]=CST[np-2]-CST[np-1];np--;break;\n\t\tcase '*':CST[np-2]=CST[np-2]*CST[np-1];np--;break;\n\t\tcase '/':CST[np-2]=CST[np-2]/CST[np-1];np--;break;\n\t\tdefault: CST[np++]=NST[i];\n\t\t}\n\t}\n\treturn CST[0];\n}\n\n\nint dfs(int s,int e)\n{\n\tint i,j,c,t,p=0;\n\tchar st[100],d[100];\n\tfor(i=s;i<=e;)\n\t{\n\t\tif(S[i]=='(')\n\t\t{\n\t\t\tfor(j=i+1,c=1;c!=0;j++)\n\t\t\t{\n\t\t\t\tif(S[j]=='(')c++;\n\t\t\t\telse if(S[j]==')')c--;\n\t\t\t}\n\t\t\tt=dfs(i+1,j-2);\n\t\t\tst[p++]=t;\n\t\t\ti=j+1;\n\t\t}\n\t\telse if('0'<=S[i]&&S[i]<='9')\n\t\t{\n\t\t\tsscanf(S+i,\"%d\",&t);\n\t\t\tst[p++]=t;\n\t\t\ti+=sprintf(d,\"%d\",t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsscanf(S+i,\"%c\",&st[p++]);\n\t\t\ti++;\n\t\t}\n\t}\n\tt=calc(st,p);\n\treturn t;\n}\n\nint main()\n{\n\tscanf(\"%d\\n\",&N);\n\tfor(;N--;)\n\t{\n\t\tgets(S);\n\t\tprintf(\"%d\\n\",dfs(0,strlen(S)-2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstatic char s[1024];\nstatic int sp;\n\nint term(void);\nint factor(void);\nint expr(void);\nint nextInt2();\nint nextInt();\n\nint main(void)\n{\n\n  scanf(\" %s\",s);\n  scanf(\"%d\",&sp);\n\n  printf(\"%d\\n\",expr());\n\n  return 0;\n\n}\n\nint nextInt(void)\n{\n    int tmp;\n    tmp = s[sp] - '0';\n    sp++;\n    return tmp;\n}\n\nint nextInt2(void)\n{\n    if (s[sp] == '-') {\n        sp++;\n        return nextInt() * -1;\n    } else {\n        return nextInt();\n    }\n}\n\nint term(void)\n{\n  if(s[sp]=='('){\n    int res;\n    sp++; \n    res = expr();\n    sp++;\n    return res;\n  }\n  return nextInt2();\n}\n\nint factor(void)\n{\n  int res = term();\n  while(1) {\n    if(s[sp]=='*'){\n      sp++; res *= term();\n    } else if(s[sp]=='/'){\n      sp++; res /= term();\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nint expr(void)\n{\n  int res = factor();\n  while(1){\n    if(s[sp]=='+') {\n      sp++; res += factor();\n    } else if(s[sp]=='-') {\n      sp++; res -= factor();\n    } else {\n      break;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cctype>\nusing namespace std;\nint expr(string& s,int& i);\nint term(string& s,int& i);\nint factor(string& s,int& i);\nint number(string& s,int& i);\n\n\nint expr(string& s,int& i){\n  int val = term(s,i);\n  while(s[i]=='+' || s[i]=='-'){\n    char op = s[i];\n    i++;\n    int val2 = term(s,i);\n    if(op=='+')val += val2;\n    else val -= val2;\n  }\n  return val;\n}\n\nint term(string& s,int& i){\n  int val = factor(s,i);\n  while(s[i]=='*' || s[i]=='/'){\n    char op = s[i];\n    i++;\n    int val2 = factor(s,i);\n    if(op=='*')val *= val2;\n    else val /= val2;\n  }\n  return val;\n}\n\nint factor(string& s,int& i){\n  if(isdigit(s[i]))return number(s,i);\n\n\n  i++;\n  int ret = expr(s,i);\n  i++;\n  return ret;\n}\n\nint number(string& s,int& i){\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n=n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(void)\n{\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++){\n    string str;\n    cin >> str;\n    int j=0;\n    cout << expr(str,j) << endl;\n  }\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int value;\n    int pos;\n} result;\n\nresult equation(char *s, int pos);\nresult factor(char *s, int pos);\nresult term(char *s, int pos);\n\nresult equation(char *s, int pos)\n{\n    result temp, next;\n    temp = factor(s, pos);\n    while (s[temp.pos] == '+' || s[temp.pos] == '-'){\n        next = factor(s, temp.pos + 1);\n        if (s[temp.pos] == '+'){\n            temp.value += next.value;\n        }\n        else {\n            temp.value -= next.value;\n        }\n        temp.pos = next.pos;\n    }\n    \n    return (temp);\n}\n\nresult factor(char *s, int pos)\n{\n    result temp, next;\n    temp = term(s, pos);\n    while (s[temp.pos] == '*' || s[temp.pos] == '/'){\n        next = term(s, temp.pos + 1);\n        if (s[temp.pos] == '*'){\n            temp.value *= next.value;\n        }\n        else {\n            temp.value /= next.value;\n        }\n        temp.pos = next.pos;\n    }\n    \n    return (temp);\n}\n\nresult term(char *s, int pos)\n{\n    int i;\n    int value;\n    result temp;\n    \n    if (s[pos] == '('){\n        temp = equation(s, pos + 1);\n        temp.pos += 1;\n        return (temp);\n    }\n    else {\n        value = 0;\n        while ('0' <= s[pos] && s[pos] <= '9'){\n            value = value * 10 + (s[pos++] - '0');\n        }\n        temp.value = value;\n        temp.pos = pos;\n        return (temp);\n    }\n}\n\nint main(void)\n{\n    result res;\n    char expr[256];\n    int i, n;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++){\n        res.pos = 0;\n        scanf(\"%s\", expr);\n        res = equation(expr, 0);\n        printf(\"%d\\n\", res.value);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef long long int Integer;\n\nenum command_type {\n\tVALUE = 0x2,\n\tOP_ADD = 0x4,\n\tOP_SUB = 0x5,\n\tOP_MUL = 0x8,\n\tOP_DIV = 0x9,\n\tEND = 0xffff\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tInteger value;\n};\ntypedef struct command_t Command;\n\nvoid expression(void);\n\nchar g_tokens[128][30];\nchar *g_symbol;\nint g_index;\nCommand g_commands[128];\nint g_cmd_idx = 0;\n\nvoid command_append(CommandType type, Integer value) {\n\tCommand *new;\n\n\tnew = &g_commands[g_cmd_idx];\n\tnew->type = type;\n\t//new->value = symbol ? atoll(symbol) : 0LL;\n\tnew->value = value;\n\tg_cmd_idx++;\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_index++];\n}\n\nvoid factor(void) {\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tcommand_append(VALUE, atoll(g_symbol));\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tg_index = 0;\n\tg_cmd_idx = 0;\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n\tcommand_append(END, 0);\n}\n\n\nvoid tokenize(char *in) {\n\tint digit, n, i;\n\n\tdigit = n = i = 0;\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t\tdigit = 1;\n\t\t} else {\n\t\t\tif (digit) {\n\t\t\t\tn++;\n\t\t\t\tdigit = 0;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n\tg_tokens[n][0] = '\\0';\n}\n\nInteger run(void) {\n\tInteger stack[128], buf;\n\tint top = -1, i;\n\tCommandType type;\n\tCommand *cmd;\n\n\tfor (i = 0; g_commands[i].type != END; i++) {\n\t\ttype = g_commands[i].type;\n\t\tcmd = &g_commands[i];\n\t\tif (type == VALUE) {\n\t\t\t//if (cmd->type == VALUE) {\n\t\t\tstack[++top] = cmd->value;\n\t\t} else if (type == OP_ADD) {\n\t\t\t//} else if (cmd->type == OP_ADD) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] += buf;\n\t\t} else if (type == OP_SUB) {\n\t\t\t//} else if (cmd->type == OP_SUB) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] -= buf;\n\t\t} else if (type == OP_MUL) {\n\t\t\t//} else if (cmd->type == OP_MUL) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] *= buf;\n\t\t} else if (type == OP_DIV) {\n\t\t\t//} else if (cmd->type == OP_DIV) {\n\t\t\tbuf = stack[top--];\n\t\t\tstack[top] = (int)((double)stack[top] / (double)buf);\n\t\t\t//stack[top] /= buf;\n\t\t}\n\t}\n\treturn stack[top];\n}\n\nint main(void) {\n\tint n;\n\tchar in[128];\n\n\tfgets(in, 127, stdin);\n\tn = atoi(in);\n\n\twhile (n--) {\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%lld\\n\", run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 100\n\nconst char *p;\n\nint expr();\nint term();\nint fact();\nint number();\n\nint expr() {\n\tint res = term();\n\twhile(*p == '+' || *p == '-') {\n\t\tconst char operator = *p;\n\t\t++p;\n\t\tswitch(operator) {\n\t\tcase '+': res += term(); break;\n\t\tcase '-': res -= term(); break;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\treturn res;\n}\n\nint term() {\n\tint res = fact();\n\twhile(*p == '*' || *p == '/') {\n\t\tconst char operator = *p;\n\t\t++p;\n\t\tswitch(operator) {\n\t\tcase '*': res *= fact(); break;\n\t\tcase '/': res /= fact(); break;\n\t\tdefault: assert(false);\n\t\t}\n\t}\n\treturn res;\n}\n\nint fact() {\n\tif(*p == '-') {\n\t\t++p;\n\t\treturn -fact();\n\t}\n\telse if(*p == '(') {\n\t\t++p;\n\t\tconst int res = expr();\n\t\tassert(*p == ')');\n\t\t++p;\n\t\treturn res;\n\t}\n\telse if(isdigit(*p)) {\n\t\treturn number();\n\t}\n\telse {\n\t\tassert(false);\n\t}\n}\n\nint number() {\n\tint res = 0;\n\twhile(isdigit(*p)) {\n\t\tres = res * 10 + (*p - '0');\n\t\t++p;\n\t}\n\treturn res;\n}\n\nint main() {\n\tchar input[MAX_LEN + 1];\n\n\tint n;\n\tscanf(\"%d\\n\", &n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tfgets(input, MAX_LEN + 1, stdin);\n\t\tp = input;\n\t\tconst int ans = expr();\n\t\tassert(*p == '=');\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NUM_TOKENS 128\n#define TOKEN_LENGTH 16\n\ntypedef int Integer;\n\nenum command_type {\n\tVALUE,\n\tOP_ADD,\n\tOP_SUB,\n\tOP_MUL,\n\tOP_DIV,\n\tEND\n};\ntypedef enum command_type CommandType;\n\nstruct command_t {\n\tCommandType type;\n\tInteger value;\n};\ntypedef struct command_t Command;\n\n\nchar g_tokens[NUM_TOKENS][TOKEN_LENGTH];\nint g_tok_index;\nchar *g_symbol;\nCommand g_commands[NUM_TOKENS];\nCommand *g_cmd_iter;\n\n\nvoid expression(void);\n\nvoid command_append(CommandType type, Integer value) {\n\tg_cmd_iter->type = type;\n\tg_cmd_iter->value = value;\n\tg_cmd_iter++;\n}\n\nvoid next_symbol(void) {\n\tg_symbol = g_tokens[g_tok_index++];\n}\n\nvoid factor(void) {\n\tif ('0' <= g_symbol[0] && g_symbol[0] <= '9') {\n\t\tcommand_append(VALUE, atoi(g_symbol));\n\t\tnext_symbol();\n\t} else if (g_symbol[0] == '(') {\n\t\tnext_symbol();\n\t\texpression();\n\t\tif (g_symbol[0] != ')') {\n\t\t\tfprintf(stderr, \"SyntaxError: close %s\\n\", g_symbol);\n\t\t\texit(1);\n\t\t}\n\t\tnext_symbol();\n\t} else {\n\t\tfprintf(stderr, \"SyntaxError: %s\\n\", g_symbol);\n\t\texit(1);\n\t}\n}\n\nvoid term(void) {\n\tchar op_sign;\n\n\tfactor();\n\twhile (g_symbol[0] == '*' || g_symbol[0] == '/') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tfactor();\n\t\tcommand_append(op_sign == '*' ? OP_MUL : OP_DIV, 0);\n\t}\n}\n\nvoid expression(void) {\n\tchar op_sign;\n\n\tif (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t} else {\n\t\tterm();\n\t}\n\twhile (g_symbol[0] == '+' || g_symbol[0] == '-') {\n\t\top_sign = g_symbol[0];\n\t\tnext_symbol();\n\t\tterm();\n\t\tcommand_append(op_sign == '+' ? OP_ADD : OP_SUB, 0);\n\t}\n}\n\nvoid parse(void) {\n\tg_tok_index = 0;\n\tg_cmd_iter = &g_commands[0];\n\n\tnext_symbol();\n\twhile (g_symbol[0] != '=') {\n\t\texpression();\n\t}\n\tcommand_append(END, 0);\n}\n\n\nvoid tokenize(char *in) {\n\tint n, i;\n\n\tfor (n = 0; n < NUM_TOKENS; n++) {\n\t\tfor (i = 0; i < TOKEN_LENGTH; i++) {\n\t\t\tg_tokens[n][i] = '\\0';\n\t\t}\n\t}\n\tn = i = 0;\n\n\tfor (; *in; in++) {\n\t\tif ('0' <= *in && *in <= '9') {\n\t\t\tg_tokens[n][i++] = *in;\n\t\t} else {\n\t\t\tif (i) {\n\t\t\t\tn++;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tg_tokens[n++][0] = *in;\n\t\t\tif (*in == '=')\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nInteger run(Command *cmd_iter) {\n\tInteger stack[128];\n\tint top = -1;\n\tCommandType type;\n\n\tfor (; cmd_iter->type != END; cmd_iter++) {\n\t\ttype = cmd_iter->type;\n\t\tif (type == VALUE) {\n\t\t\tstack[++top] = cmd_iter->value;\n\t\t} else {\n\t\t\ttop--;\n\t\t\tif (type == OP_ADD) {\n\t\t\t\tstack[top] += stack[top+1];\n\t\t\t} else if (type == OP_SUB) {\n\t\t\t\tstack[top] -= stack[top+1];\n\t\t\t} else if (type == OP_MUL) {\n\t\t\t\tstack[top] *= stack[top+1];\n\t\t\t} else if (type == OP_DIV) {\n\t\t\t\tstack[top] /= stack[top+1];\n\t\t\t}\n\t\t}\n\t}\n\treturn stack[top];\n}\n\n\nint main(void) {\n\tint n;\n\tchar in[128];\n\n\tfgets(in, 127, stdin);\n\tn = atoi(in);\n\n\twhile (n--) {\n\t\tfgets(in, 127, stdin);\n\t\ttokenize(in);\n\t\tparse();\n\t\tprintf(\"%d\\n\", run(g_commands));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Smart Calculator\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\t//skip first line\n\t\tbr.readLine();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tDeque<String> queue = new ArrayDeque<>();\n\t\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\t\tchar _c = 0;\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tif (stack.peek() == '*' || stack.peek() == '/') {\n\t\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '/':\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\t\twhile (stack.peek() != '(') {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ('0' <= _c && _c <= '9') {\n\t\t\t\t\t\t\tString s = queue.pollLast();\n\t\t\t\t\t\t\tqueue.offer(s + c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(c));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_c = c;\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tDeque<Integer> ans = new ArrayDeque<>();\n\t\t\tfor (String s : queue) {\n\t\t\t\tif (\"+-*/\".indexOf(s) != -1) {\n\t\t\t\t\tint a, b;\n\t\t\t\t\tb = ans.pop();\n\t\t\t\t\ta = ans.pop();\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\t\tans.push(a + b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\tans.push(a - b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\tans.push(a * b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tans.push(a / b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tans.push(parseInt(s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.peek());\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tString s;\n\n\tvoid run(){\n\t\tfor(int n=sc.nextInt(); n>0; n--){\n\t\t\ts=sc.next();\n\t\t\tprintln(equation(0).val+\"\");\n\t\t}\n\t}\n\n\tR equation(int p){\n\t\tR r=factor(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='+'||c=='-'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='+')\n\t\t\t\t\tr.val+=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val-=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR factor(int p){\n\t\tR r=term(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='*'||c=='/'){\n\t\t\t\tR q=term(r.p+1);\n\t\t\t\tif(c=='*')\n\t\t\t\t\tr.val*=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val/=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR term(int p){\n\t\tif(s.charAt(p)=='('){\n\t\t\tR r=equation(p+1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t}else{\n\t\t\tboolean minus=false;\n\t\t\tif(s.charAt(p)=='-'){\n\t\t\t\tp++;\n\t\t\t\tminus=true;\n\t\t\t}\n\t\t\tlong val=0;\n\t\t\tfor(; Character.isDigit(s.charAt(p)); p++){\n\t\t\t\tval=val*10+(s.charAt(p)-'0');\n\t\t\t}\n\t\t\tif(minus){\n\t\t\t\tval=-val;\n\t\t\t}\n\t\t\treturn new R(p, val);\n\t\t}\n\t}\n\n\tclass R{\n\t\tint p;\n\t\tlong val;\n\n\t\tR(int p, long val){\n\t\t\tthis.p=p;\n\t\t\tthis.val=val;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s = \"\";\n\tint pos = 0;\n\t\n\tint exp(){\n\t\tint p = term();\n\t\twhile(true){\n\t\t\tif(pos==s.length()) break;\n\t\t\tint q = s.codePointAt(pos);\n\t\t\tpos++;\n\t\t\tif(q==43) p+=term();\n\t\t\telse if(q==45) p-=term();\n\t\t\telse break;\n\t\t}\n\t\treturn p;\n\t}\n\t\n\tint term(){\n\t\tint p = fact();\n\t\twhile(true){\n\t\t\tif(pos==s.length()) break;\n\t\t\tint q = s.codePointAt(pos);\n\t\t\tpos++;\n\t\t\tif(q==42) p*=fact();\n\t\t\telse if(q==47) p/=fact();\n\t\t\telse break;\n\t\t}\n\t\tpos--;\n\t\treturn p;\n\t}\n\t\n\tint fact(){\n\t\tint q = s.codePointAt(pos);\n\t\tpos++;\n\t\tif(q==40) return exp();\n\t\tif(q==43) return fact();\n\t\tif(q==45) return -fact();\n\n\t\tpos--;\n\t\tint ini = pos;\n\t\twhile(s.codePointAt(pos)>=48 && s.codePointAt(pos)<=57){\n\t\t\tpos++;\n\t\t\tif(pos==s.length()) break;\n\t\t}\n\t\tint p = Integer.valueOf(s.substring(ini,pos));\n\t\treturn p;\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while(n-- > 0){\n            String exp = sc.next();\n            Parser parser = new Parser(exp);\n            System.out.println(parser.expression());\n        }\n    }\n    public static void main(String[] args){\n        new Main().run();\n    }\n}\n\nclass Parser{\n    char[] exp;\n    int begin;\n    Parser(String str){\n        this.exp = (str+\"#\").toCharArray();\n    }\n    //四則演算の式をパースして、その評価結果を返す\n    int expression(){\n        int ret = term();\n        \n        while(true){\n            if(exp[begin] == '+'){\n                begin++;\n                ret += term();\n            }\n            else if(exp[begin] == '-'){\n                begin++;\n                ret -= term();\n            }\n            else{\n                break;\n            }\n        }\n        return ret;\n    }\n    //乗算除算の式をパースして、その評価結果を返す\n    int term(){\n        int ret = factor();\n        while(true){\n            if(exp[begin] == '*'){\n                begin++;\n                ret *= factor();\n            }\n            else if(exp[begin] == '/'){\n                begin++;\n                ret /= factor();\n            }\n            else{\n                break;\n            }\n        }\n        return ret;\n    }\n    //数字の列をパースして、その数を返す\n    int number(){\n        int ret = 0;\n        while(Character.isDigit(exp[begin])){\n            ret *= 10;\n            ret += exp[begin] - '0';\n            begin++;\n        }\n        return ret;\n    }\n    //括弧か数かをパースして、その評価結果を返す\n    int factor(){\n        if(exp[begin] == '('){\n            begin++;//'('を飛ばす\n            int ret = expression();\n            begin++;//')'を飛ばす\n            return ret;\n        }\n        else{\n            return number();\n        }\n    }\n}\n//https://gist.github.com/draftcode/1357281"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (5+(6/2/2+50*3/2/3*6/4)/9*2-(6/2/2+50*3/2/3*6)+36)*2+1=\n\nclass Main{\n\tstatic Pattern addsub = Pattern.compile(\"^(.*?)(-?\\\\d+)([+Z])(\\\\d+)(.*)$\");\n\tstatic Pattern muldiv = Pattern.compile(\"^(.*?)(-?\\\\d+)([*/])(\\\\d+)(.*)$\");\n\n\tstatic String process(String s){\n\tSystem.out.println(\"---\"+s);\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\tSystem.out.println(\"+++\"+s);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next().replaceAll(\"-\",\"Z\");\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (5+(6/2/2+50*3/2/3*6/4)/9*2-(6/2/2+50*3/2/3*6)+36)*2+1=\n\nclass Main{\n\tstatic Pattern addsub = Pattern.compile(\"^(.*?)(-?\\\\d+)([+Z])(\\\\d+)(.*)$\");\n\tstatic Pattern muldiv = Pattern.compile(\"^(.*?)(-?\\\\d+)([*/])(\\\\d+)(.*)$\");\n\n\tstatic String process(String s){\n\t//System.out.println(\"---\"+s);\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\t//System.out.println(\"+++\"+s);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next().replaceAll(\"-\",\"Z\");\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tprivate int p;\n\tprivate String line;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint lines = Integer.parseInt(sc.nextLine());\n\n\t\tfor (int i = 0; i < lines; i++) {\n\t\t\tline = sc.nextLine();\n\t\t\t\n\t\t\tp = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\n\tprivate int expression() {\n\t\tdouble value = term();\n\t\t\n\t\treturn (int)sub_expression(value);\n\t}\n\t\n\tprivate int sub_expression(double value) {\n\t\tif (line.charAt(p) == '+') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value + term();\n\t\t\tvalue = sub_expression(value);\n\t\t} else if (line.charAt(p) == '-') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value - term();\n\t\t\tvalue = sub_expression(value);\n\t\t}\n\t\t\n\t\treturn (int)value;\n\t}\n\t\n\tprivate int term() {\n\t\tdouble value = factor();\n\t\t\n\t\treturn (int)sub_term(value);\n\t}\n\t\t\n\tprivate int sub_term(double value) {\n\t\tif (line.charAt(p) == '*') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value * factor();\n\t\t\tvalue = sub_term(value);\n\t\t} else if (line.charAt(p) == '/') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value / factor();\n\t\t\tvalue = sub_term(value);\n\t\t}\n\t\t\n\t\treturn (int)value;\n\t}\n\t\n\tprivate int factor() {\n\t\tdouble value = 0;\n\t\t\n\t\tswitch (line.charAt(p)) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tString number = \"\";\n\t\t\twhile (Character.isDigit(line.charAt(p)) == true) {\n\t\t\t\tnumber = number + line.charAt(p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tvalue = Integer.parseInt(number);\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = expression();\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\treturn (int)value;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.*;\nimport java.util.*;\n\nclass Now {\n\tprivate static Now singleton = null;\n\tprivate static int id;\n\tprivate static String exp;\n\n\tprivate Now() {\n\t\tid = 0;\n\t}\n\n\tprivate Now(String exp) {\n\t\tthis.exp = exp;\n\t\tid = 0;\n\t}\n\n\tpublic static synchronized void initialize(String exp) {\n\t\tsingleton = new Now(exp);\n\t}\n\n\tpublic static synchronized Now getInstance() {\n\t\tif(singleton == null){\n\t\t\tsingleton = new Now();\n\t\t}\n\t\treturn singleton;\n\t}\n\n\tpublic static int getId() {\n\t\treturn id;\n\t}\n\n\tpublic static String getExp() {\n\t\treturn exp;\n\t}\n\n\tpublic static int plusId() {\n\t\tid++;\n\t\treturn id;\n\t}\n}\n\n\ninterface Parser {\n\tpublic int parse();\n}\n\nclass Expression implements Parser{\n\n\tpublic int parse(){\n\t\tint res = new Term().parse();\n\n\t\twhile(true){\n\t\t\tchar now = Now.getExp().charAt(Now.getId());\n\t\t\t\n\t\t\tif(now == '+') {\n\t\t\t\tNow.plusId();\n\t\t\t\tres += new Term().parse();\n\t\t\t}\n\t\t\telse if(now == '-') {\n\t\t\t\tNow.plusId();\n\t\t\t\tres -= new Term().parse();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\nclass Term implements Parser {\n\n\tpublic int parse(){\n\t\tint res = new Factor().parse();\n\t\twhile(true) {\n\t\t\tchar now = Now.getExp().charAt(Now.getId());\n\n\t\t\tif(now == '*') {\n\t\t\t\tNow.plusId();\n\t\t\t\tres *= new Factor().parse();\n\t\t\t}\n\t\t\telse if(now == '/') {\n\t\t\t\tNow.plusId();\n\t\t\t\tres /= new Factor().parse();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\nclass Factor implements Parser {\n\n\tpublic int parse() {\n\t\tint res=0;\n\t\tchar now = Now.getExp().charAt(Now.getId());\n\n\t\tif(now == '(') {\n\t\t\tNow.plusId();\n\t\t\tres = new Expression().parse();\n\t\t\tNow.plusId();\n\t\t}\n\t\telse {\n\t\t\treturn new Number().parse();\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\nclass Number implements Parser {\n\n\tpublic int parse() {\n\t\tint res = 0;\n\t\tString exp = Now.getExp();\n\n\t\twhile(true) {\n\t\t\tchar now = exp.charAt(Now.getId());\n\t\t\tif(!Character.isDigit(now))break;\n\n\t\t\tres *= 10;\n\t\t\tres += Character.digit(now,10);\n\t\t\t\n\t\t\tNow.plusId();\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\npublic class Main {\n\n\tpublic void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tString exp;\n\t\texp = sc.nextLine();\n\n\t\tfor(int i=0;i<n;i++) {\n\t\t\texp = sc.nextLine();\n\t\t\tNow.initialize(exp);\n\t\t\tSystem.out.println(new Expression().parse());\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain problem_0109 = new Main();\n\t\tproblem_0109.solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class SmartCalculator {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (pos < str.length()) {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (pos < str.length()) {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn expression();\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.function.IntBinaryOperator;\n\npublic class Calc {\n\n    static int lastIndexOf(String e, char ch) {\n        int nest = 0;\n        for(int i = e.length()-1; i > 0 ; i--) {\n            char c = e.charAt(i);\n            if(c == ‘(’) {\n                nest++;\n            }\n            if(c == ‘)’) {\n                nest--;\n            }\n            if(ch == c && nest == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    static int parse(String e) {\n        if(e.startsWith(“(”)) {\n            return parse(e.substring(1, e.length()-1));\n        }\n        int loc = lastIndexOf(e, ‘-’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) - parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘+’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) + parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘/’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) / parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘*’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) * parse(e.substring(loc+1));\n        }\n        return Integer.parseInt(e);\n    }\n    \n    public static void main(String[] args) {\n        try(Scanner sc = new Scanner(System.in)) {\n            int n = sc.nextInt();\n            for(int i = 0; i < n; i++) {\n                String e = sc.next().replace(“=”, “”);\n                System.out.println(parse(e));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[101];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()-1));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tenum ope {\n\n\t\tadd, sub, mul, div;\n\n\t}\n\n\n\n\tLinkedList<String> tokenize(String str) {\n\n\t\tString token = \"\";\n\n\t\tLinkedList<String> ret = new LinkedList<String>();\n\n\t\tString sp = \"+-*/()=\";\n\n\t\tfor (char c : str.toCharArray()) {\n\n\t\t\tif (Character.isDigit(c)) {\n\n\t\t\t\ttoken += c;\n\n\t\t\t} else {\n\n\t\t\t\tif (sp.indexOf(c) != -1) {\n\n\t\t\t\t\tif (token.length() != 0)\n\n\t\t\t\t\t\tret.addLast(token);\n\n\t\t\t\t\tret.addLast(Character.toString(c));\n\n\t\t\t\t\ttoken = \"\";\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tclass evTree {\n\n\t\tope o;\n\n\t\tString s;\n\n\t\tevTree left = null;\n\n\t\tevTree right = null;\n\n\t\tint val = 0;\n\n\n\n\t\tint getVal() {\n\n\t\t\tif (left == null && right == null) {\n\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tif (o == ope.add) {\n\n\t\t\t\t// System.out.println(left.s +\" add \"+ right.s);\n\n\t\t\t\treturn left.getVal() + right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.sub) {\n\n\t\t\t\t// System.out.println(left.s +\" sub \"+ right.s);\n\n\t\t\t\treturn left.getVal() - right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.mul) {\n\n\t\t\t\t// System.out.println(left.s +\" mul \"+ right.s);\n\n\t\t\t\treturn left.getVal() * right.getVal();\n\n\t\t\t}\n\n\t\t\t// if (o == ope.div) {\n\n\t\t\t// System.out.println(left.s +\" div \"+ right.s);\n\n\t\t\treturn left.getVal() / right.getVal();\n\n\t\t\t// }\n\n\t\t}\n\n\n\n\t\tboolean evTrimable(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\"))\n\n\t\t\t\treturn true;\n\n\t\t\treturn t.getFirst().equals(\"(\") && t.getLast().equals(\")\");\n\n\t\t}\n\n\n\n\t\tvoid evTrim(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\")) {\n\n\t\t\t\tt.removeLast();\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tt.removeFirst();\n\n\t\t\tt.removeLast();\n\n\t\t\treturn;\n\n\t\t}\n\n\n\n\t\tString tts(LinkedList<String> t) {\n\n\t\t\tString ret = \"\";\n\n\t\t\tfor (String s : t) {\n\n\t\t\t\tret += s;\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t}\n\n\n\n\t\tevTree(LinkedList<String> t) {\n\n\t\t\ts = tts(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tfor (; evTrimable(t);)\n\n\t\t\t\tevTrim(t);\n\n\t\t\tint[] p = new int[t.size()];\n\n\t\t\tint depth = 1;\n\n\t\t\tint min = 100;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tString token = t.get(i);\n\n\t\t\t\tif (Character.isDigit(token.toCharArray()[0]))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\tdepth += 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\tdepth -= 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"+\") || token.equals(\"-\")) {\n\n\t\t\t\t\tp[i] = depth;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"*\") || token.equals(\"/\")) {\n\n\t\t\t\t\tp[i] = depth + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint z = 0;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tif (p[i] == 0)\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p[i] < min) {\n\n\t\t\t\t\tmin = p[i];\n\n\t\t\t\t\tz = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tString token = t.get(z);\n\n\t\t\tif (token.equals(\"+\")) {\n\n\t\t\t\tthis.o = ope.add;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"-\")) {\n\n\t\t\t\tthis.o = ope.sub;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"*\")) {\n\n\t\t\t\tthis.o = ope.mul;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"/\")) {\n\n\t\t\t\tthis.o = ope.div;\n\n\t\t\t}\n\n\t\t\tLinkedList<String> tl = new LinkedList<String>(t.subList(0, z));\n\n\t\t\tthis.left = new evTree(tl);\n\n\t\t\tLinkedList<String> tr = new LinkedList<String>(t.subList(z + 1,\n\n\t\t\t\t\tt.size()));\n\n\t\t\tthis.right = new evTree(tr);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tint n = Integer.valueOf(sc.nextLine());\n\n\t\tfor (; n-- > 0;) {\n\n\t\t\tLinkedList<String> token = tokenize(sc.nextLine());\n\n\t\t\tfor (String t : token) {\n\n\t\t\t\tSystem.out.println(t);\n\n\t\t\t}\n\n\t\t\tSystem.out.println(new evTree(token).getVal());\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint dataset = sc.nextInt();\n\twhile(dataset-->0){\n\t    in = sc.next().toCharArray();\n\t    p = 0;\n\t    System.out.println(expr());\n\t}\n    }\n\n    int expr(){\n\tint a = term();\n\twhile(in[p]=='+' || in[p]=='-'){\n\t    int enzan = 0;\n\t    if(in[p]=='-') enzan = 1;\n\t    p++;\n\t    int b = term();\n\t    if(enzan==0) a += b;\n\t    else a -= b;\n\t} \n\treturn a;\n    }\n\n    int term(){\n\tint a = factor();\n\twhile(in[p]=='*' || in[p]=='/'){\n\t    int enzan = 0;\n\t    if(in[p]=='/') enzan = 1;\n\t    p++;\n\t    int b = factor();\n\t    if(enzan==0) a *= b;\n\t    else a /= b;\n\t} \n\treturn a;\n    }\n\n    int factor(){\n\tif(in[p]=='('){\n\t    p++;\n\t    int res = expr();\n\t    p++;\n\t    return res;\n\t}\n\treturn digit();\n    }\n\n    int digit(){\n\tint res = 0;\n\twhile(p<in.length-1 && Character.isDigit(in[p])){\n\t    res = res * 10 + (in[p]-'0');\n\t    p++;\n\t}\n\treturn res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char a) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\t\t//()内は無視\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif(a==c && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\n\t\n\tstatic int parse(String str) {\t\t\n\t\tSystem.out.println(str);\n\t\tint a = str.length();\n\t\tint n = 0;\n\t\tint g = 0;\n\t\tif(str.startsWith(\"(\") && str.endsWith(\")\")) {\t\t\t\t//(で始まり)で終わる\n\t\t\tif(!str.substring(1, a-1).contains(\"(\"))\t\t\t\t//間に()がなければsubstr\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\tfor(int i=0;i<str.length()-1;i++) {\n\t\t\t\tif(str.charAt(i)=='(') {\n\t\t\t\t\tn++;\n\t\t\t\t\tg++;\n\t\t\t\t}\n\t\t\t\tif(str.charAt(i)==')') n--;\n\t\t\t\tif(g!=0 && n==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==str.length()-2 && n-1==0) {\n\t\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ind = lastInd(str,'-');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) - parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'+');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) + parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'/');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) / parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'*');\n\t\tif(ind!=-1){\n\t\t\treturn parse(str.substring(0, ind)) * parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\tprivate\tstatic\tTermTbl\t\t\ttt = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\ttt = new TermTbl();\n\t\ttt.put('+', 1);\n\t\ttt.put('-', 1);\n\t\ttt.put('*', 2);\n\t\ttt.put('/', 2);\n\t}\n \n    /**\n     * @param args\n     */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tnum = parseNum();\n\n\t\twhile (num-- > 0) {\n\t\t\tFormula\tformula = parseFormula();\n\t\t\tSystem.out.println(calc(formula));\n\t\t}\n\t}\n\n\tprivate static int calc(Formula formula) {\n\t\tFormula\tstk = new Formula();\n\t\tString\tobj = null;\n\t\tString\ttrm = null;\n\t\tint\t\tsize = formula.size();\n\n\t\t// 数式を逆ポーランド記法に変換\n\t\tfor (int l = 0; l < size; l++) {\n\t\t\tobj = formula.get(l);\n\n\t\t\tif (obj.equals(\"+\") || obj.equals(\"-\") || obj.equals(\"*\") || obj.equals(\"/\")) {\n\t\t\t\t\ttrm = obj;\n\t\t\t}\n\t\t\telse if (obj.equals(\"(\")) {\n\t\t\t\tFormula\tins = new Formula();\n\t\t\t\tint\t\tper = 1;\n\t\t\t\tfor(int i = l; i < size && per > 0;) {\n\t\t\t\t\tformula.remove(i);\n\t\t\t\t\tsize--;\n\t\t\t\t\tString\ttmp = formula.get(i);\n\n\t\t\t\t\tif (tmp.equals(\")\") && per == 1) {\n\t\t\t\t\t\tins.push(\"=\");\n\t\t\t\t\t\tformula.remove(i);\n\t\t\t\t\t\tformula.insertElementAt(String.valueOf(calc(ins)), l--);\n\t\t\t\t\t\tper = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (tmp.equals(\"(\")) {\n\t\t\t\t\t\t\tper++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (tmp.equals(\")\")) {\n\t\t\t\t\t\t\tper--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tins.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!obj.equals(\"=\")) {\n\t\t\t\tif (trm == null) {\n\t\t\t\t\tstk.push(obj);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = stk.size() - 1; i >= 0; i--) {\n\t\t\t\t\t\tString\ttmp = stk.get(i);\n\t\t\t\t\t\tif (tmp.equals(\"+\") || tmp.equals(\"-\") || tmp.equals(\"*\") || tmp.equals(\"/\")) {\n\t\t\t\t\t\t\tif (tt.get(trm.charAt(0)) <= tt.get(tmp.charAt(0))) {\n\t\t\t\t\t\t\t\tstk.insertElementAt(obj, i+1);\n\t\t\t\t\t\t\t\tstk.insertElementAt(trm, i+2);\n\t\t\t\t\t\t\t\ttrm = null;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstk.insertElementAt(obj, i+1);\n\t\t\t\t\t\t\tstk.insertElementAt(trm, i+2);\n\t\t\t\t\t\t\ttrm = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 数式を計算\n\t\tsize = stk.size();\n\t\tfor (int l = 0; l < size; l++) {\n\t\t\tString\ttmp = stk.get(l);\n\t\t\tint\t\ta   = 0;\n\t\t\tint\t\tb   = 0;\n\t\t\tint\t\tc   = 0;\n\t\t\tif (tmp.equals(\"+\") || tmp.equals(\"-\") || tmp.equals(\"*\") || tmp.equals(\"/\")) {\n\t\t\t\ta = Integer.parseInt(stk.get(l-2));\n\t\t\t\tstk.remove(l-2);\n\t\t\t\tb = Integer.parseInt(stk.get(l-2));\n\t\t\t\tstk.remove(l-2);\n\n\t\t\t\tif (tmp.equals(\"+\")) {\n\t\t\t\t\tc = a + b;\n\t\t\t\t}\n\t\t\t\telse if (tmp.equals(\"-\")) {\n\t\t\t\t\tc = a - b;\n\t\t\t\t}\n\t\t\t\telse if (tmp.equals(\"*\")) {\n\t\t\t\t\tc = a * b;\n\t\t\t\t}\n\t\t\t\telse if (tmp.equals(\"/\")) {\n\t\t\t\t\tc = a / b;\n\t\t\t\t}\n\n\t\t\t\tstk.remove(l-2);\n\t\t\t\tstk.insertElementAt(String.valueOf(c), l-2);\n\t\t\t\tl    -= 3;\n\t\t\t\tsize -= 2;\n\t\t\t}\n\t\t}\n\n\t\treturn Integer.parseInt(stk.get(0));\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum = 0;\n\t\tString\tstr = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(str);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tprivate static Formula parseFormula() {\n\t\tFormula\tformula = null;\n\t\tString\tstr     = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tint\t\tsize = str.length();\n\t\t\tInteger\tnum  = 0;\n\n\t\t\tformula = new Formula();\n\t\t\tfor\t(int l = 0; l < size; l++) {\n\t\t\t\tCharacter\tchr = str.charAt(l);\n\t\t\t\tif (Character.isDigit(chr)) {\n\t\t\t\t\tif (l > 0) {\n\t\t\t\t\t\tif (Character.isDigit(str.charAt(l-1))) {\n\t\t\t\t\t\t\tnum *= 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnum += (int)(chr - '0');\n\t\t\t\t} else {\n\t\t\t\t\tif (l > 0) {\n\t\t\t\t\t\tif (Character.isDigit(str.charAt(l-1))) {\n\t\t\t\t\t\t\tformula.push(String.valueOf(num));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tformula.push(String.valueOf(chr));\n\t\t\t\t\tnum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn formula;\n\t}\n\n\tprivate static String parseStdin() {\n        String  stdin = null;\n        \n        try {\n        \tString  tmp = br.readLine();\n        \tif (tmp != null) {\n            \tif (!tmp.isEmpty()) {\n            \t\tstdin = tmp;\n            \t}\n        \t}\n        }\n        catch (IOException e) {}\n \n        return stdin;\n\t}\n}\n\nclass TermTbl extends HashMap<Character, Integer> {\n}\n\nclass Formula extends Stack<String> {\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\n\tstatic int nowp = 0;\n\tstatic int INF = 2 << 29;\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString in = sc.next();\n\t\t\tnowp = 0;\n\t\t\tint a = expression(in);\n\t\t\tout.println(a);\n\t\t}\n\t\tout.flush();\n\t\t\n\t}\n\t\n\tstatic int expression(String a) {\n\t\tint ret = term(a);\n\t\t\n\t\tfor(;;) {\n\t\t\tif(a.charAt(nowp) == '+') {\n\t\t\t\tnowp++;\n\t\t\t\tret += term(a);\n\t\t\t}\n\t\t\telse if(a.charAt(nowp) == '-') {\n\t\t\t\tnowp++;\n\t\t\t\tret -= term(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int term(String a) {\n\t\tint ret = factor(a);\n\t\t\n\t\tfor(;;) {\n\t\t\tif(a.charAt(nowp) == '*') {\n\t\t\t\tnowp++;\n\t\t\t\tret *= factor(a);\n\t\t\t}\n\t\t\telse if(a.charAt(nowp) == '/') {\n\t\t\t\tnowp++;\n\t\t\t\tret /= factor(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int number(String a) { \n\t\tint ret = 0;\n\t\twhile(isdigit(a.charAt(nowp))) {\n\t\t\tret *= 10;\n\t\t\tret += a.charAt(nowp) - '0';\n\t\t\tnowp++;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tstatic int factor(String a) {\n\t\tif(a.charAt(nowp) == '(') {\n\t\t\tnowp++;\n\t\t\tint ret = expression(a);\n\t\t\tnowp++;\n\t\t\treturn ret;\n\t\t}\n\t\treturn number(a);\n\t\t\n\t}\n\t\n\tstatic boolean isdigit(char a) {\n\t\tif(a == '0' || a == '1' || a == '2' || a == '3' || a == '4' || a == '5' || a == '6' || a == '7' || a == '8' || a == '9') return true;\n\t\treturn false;\n\t}\n\t\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\n\t\tint size = Integer.parseInt(line);\n\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint a = SC(line);\n\t\t\tans.add(a);\n\t\t}\n\n\t\tfor(int i=0; i<ans.size(); i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\n\tpublic int SC(String line){\n\t\tList<String> eq = new ArrayList<String>();\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tString str = line.substring(count, count+1);\n\t\t\tif(str.equals(\"=\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq.add(str);\n\t\t\tcount++;\n\t\t}\n\n\t\tcount = 0;\n\t\twhile(count < eq.size()-1){\n\t\t\tif(isNumber(eq.get(count)) && isNumber(eq.get(count+1))){\n\t\t\t\tString dst = eq.get(count) + eq.get(count+1);\n\t\t\t\teq.add(count+2, dst);\n\t\t\t\teq.remove(count);\n\t\t\t\teq.remove(count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\n\t\twhile(eq.size() != 1){\n\t\t\t//ツ環古環づ個計ツ算\n\t\t\tint bra_count = 0;\n\t\t\tint n = eq.indexOf(\"(\");\n\t\t\tif(n != -1){\n\t\t\t\tfor(int i=n+1; i<eq.size(); i++){\n\t\t\t\t\tif(eq.get(i).equals(\")\") && bra_count == 0){\n\t\t\t\t\t\tString part = getPartString(eq, n, i);\n\t\t\t\t\t\tpart = Integer.toString(SC(part+\"=\"));\n\t\t\t\t\t\teq = RangeReplace(eq, part, n, i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\"(\")){\n\t\t\t\t\t\tbra_count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\")\")){\n\t\t\t\t\t\tbra_count--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ掛ツつッツ算ツ環づィツ算\n\t\t\tn = eq.indexOf(\"*\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) * Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = eq.indexOf(\"/\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) / Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ堕ォツつオツ算ツ暗クツつォツ算\n\t\t\tn = eq.indexOf(\"+\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) + Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = eq.indexOf(\"-\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) - Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn Integer.parseInt(eq.get(0));\n\t}\n\n\tpublic String getPartString(List<String> eq, int s, int e){\n\t\tString part = \"\";\n\n\t\tfor(int i=s+1; i<e; i++){\n\t\t\tpart += eq.get(i);\n\t\t}\n\n\t\treturn part;\n\t}\n\n\tpublic List<String> RangeReplace(List<String> eq, String part, int s, int e){\n\t\teq.add(e+1, part);\n\n\t\tfor(int i=s; i<=e; i++){\n\t\t\teq.remove(s);\n\t\t}\n\n\t\treturn eq;\n\t}\n\n\tpublic boolean isNumber(String s){\n\t\ttry{\n\t\t\tint n = Integer.parseInt(s);\n\t\t}catch(NumberFormatException err){\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<Integer> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<Integer>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tint n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = Integer.parseInt(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a+b);\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a-b);\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a*b);\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int getResult(){\n\t\tcalculate();\n\t\treturn stack.pop();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\tprivate boolean[] minusFlag;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tminusFlag = new boolean[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\tminusFlag[current] = true;\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if(tmp == '-'){\n\t\t\t\t\tif(!minusFlag[current]){\n\t\t\t\t\t\trpn += tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t\t}\n\t\t\t\t}else if(tmp == '+'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t\tminusFlag[current] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint t = sc.nextInt();\n\twhile(t-->0){\n\t    String line = sc.next();\n\n\t    int ans = calc(line.substring(0,line.length()-1));\n\t    System.out.println(ans);\n\t}\n    }\n\n    int calc(String line){\n\n\tString newLine = \"\";\n\tfor(int i=0; i<line.length(); i++){\n\t    if(line.charAt(i)=='('){\n\t\tint idx = i;\n\t\tint left = 1;\n\t\tint right = 0;\n\t\twhile(right!=left){\n\t\t    if(line.charAt(idx)==')') right++;\n\t\t    else idx++;\n\t\t}\n\t\tnewLine += calc(line.substring(i+1,idx));\n\t\ti = idx;\n\t    }else newLine += line.charAt(i);\n\t}\n\n\tArrayList<Integer> list = new ArrayList<Integer>();\n\tArrayList<Character> list2 = new ArrayList<Character>();\n\tString tmp = \"\";\n\tfor(int i=0; i<newLine.length(); i++){\n\t    char c = newLine.charAt(i);\n\t    if(c=='*' || c=='/' || c=='+' || c=='-'){\n\t\tlist.add(Integer.parseInt(tmp));\n\t\ttmp = \"\";\n\t\tlist2.add(c);\n\t    }else{\n\t\ttmp += c;\n\t    }\n\t}\n\tlist.add(Integer.parseInt(tmp));\n\n\t//System.out.println(list.size()+\" \"+list2.size());\n\n\tfor(int i=0; i<list2.size(); i++){\n\t    char c = list2.get(i);\n\t    if(c=='*' || c=='/'){\n\t\tint n1 = list.get(i);\n\t\tint n2 = list.get(i+1);\n\t\tif(c=='*'){\n\t\t    list.set(i, n1*n2);\n\t\t}else{\n\t\t    list.set(i, n1/n2);\n\t\t}\n\t\tlist.remove(i+1);\n\t\tlist2.remove(i);\n\t\ti--;\n\t    }\n\t}\n\n\tint ans = list.get(0);\n\tfor(int i=0; i<list2.size(); i++){\n\t    char c = list2.get(i);\n\t    if(c=='+'){\n\t\tans += list.get(i+1);\n\t    }else{\n\t\tans -= list.get(i+1);\n\t    }\n\t}\n\n\treturn ans;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\tchar[] a = str.toCharArray();\n\t\t\ts = new char[150];\n\t\t\tfor(int i = 0; i < a.length;i++){\n\t\t\t\ts[i]=a[i];\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\n\t}\n\tstatic int expression(){\n\t\tint res =term();\n\t\twhile(s[idx]=='+'||s[idx]=='-'){\n\t\t\tif(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres+=expression();\n\t\t\t}\n\t\t\telse if(s[idx]=='-'){\n\t\t\t\tidx++;\n\t\t\t\tres-=expression();\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\twhile(s[idx]=='*'||s[idx]=='/'){\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres*=fact();\n\t\t\t}\n\t\t\telse if(s[idx]=='/'){\n\t\t\t\tidx++;\n\t\t\t\tres/=fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\tres = s[idx++]-'0';\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.function.IntBinaryOperator;\n\npublic class Main {\n\n\tstatic int lastIndexOf(String e, char ch, char ch2) {\n\t\tint nest = 0;\n\t\tfor(int i = e.length()-1; i > 0 ; i--) {\n\t\t\tchar c = e.charAt(i);\n\t\t\tif(c == '(') {\n\t\t\t\tnest++;\n\t\t\t}\n\t\t\tif(c == ')') {\n\t\t\t\tnest--;\n\t\t\t}\n\t\t\tif((ch == c || c == ch2) && nest == 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tstatic int parse(String e) {\n\t\tint loc = lastIndexOf(e, '-', '+');\n\t\tif(loc != -1) {\n\t\t\tif(e.charAt(loc) == '+') {\n\t\t\t\treturn parse(e.substring(0, loc)) + parse(e.substring(loc+1));\t\t\t\t\n\t\t\t}\n\t\t\treturn parse(e.substring(0, loc)) - parse(e.substring(loc+1));\n\t\t}\n\t\tloc = lastIndexOf(e, '/', '*');\n\t\tif(loc != -1) {\n\t\t\tif(e.charAt(loc) == '*') {\n\t\t\t\treturn parse(e.substring(0, loc)) * parse(e.substring(loc+1));\t\t\t\t\n\t\t\t}\n\t\t\treturn parse(e.substring(0, loc)) / parse(e.substring(loc+1));\n\t\t}\n\t\tif(e.startsWith(\"(\") && e.endsWith(\")\")) {\n\t\t\treturn parse(e.substring(1, e.length()-1));\n\t\t}\n\t\treturn Integer.parseInt(e);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tString e = sc.next().replace(\"=\", \"\");\n\t\t\t\tSystem.out.println(parse(e));\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Smart Calculator\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\t//skip first line\n\t\tbr.readLine();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tDeque<String> queue = new ArrayDeque<>();\n\t\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\t\tchar _c = 0;\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tif (stack.peek() == '*' || stack.peek() == '/') {\n\t\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase '-':\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\t\twhile (stack.peek() != '(') {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ('0' <= _c && _c <= '9') {\n\t\t\t\t\t\t\tString s = queue.pollLast();\n\t\t\t\t\t\t\tqueue.offer(s + c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(c));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_c = c;\n\t\t\t}\n\n\t\t\tSystem.out.println(String.join(\" \", queue));\n\n\t\t\t//solve\n\t\t\tDeque<Integer> ans = new ArrayDeque<>();\n\t\t\tfor (String s : queue) {\n\t\t\t\tif (\"+-*/\".indexOf(s) != -1) {\n\t\t\t\t\tint a, b;\n\t\t\t\t\tb = ans.pop();\n\t\t\t\t\ta = ans.pop();\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\t\tans.push(a + b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\tans.push(a - b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\tans.push(a * b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tans.push(a / b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tans.push(parseInt(s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.peek());\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<Integer> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<Integer>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tint n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\ttry{\n\t\t\t\tn = Integer.parseInt(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a+b);\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a-b);\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a*b);\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int getResult(){\n\t\tcalculate();\n\t\treturn stack.pop();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if((tmp == '+') || (tmp == '-')){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tString s;\n\n\tvoid run(){\n\t\tfor(int n=sc.nextInt(); n>0; n--){\n\t\t\ts=sc.next();\n\t\t\tprintln(equation(0).val+\"\");\n\t\t}\n\t}\n\n\tR equation(int p){\n\t\tR r=factor(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='+'||c=='-'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='+')\n\t\t\t\t\tr.val+=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val-=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR factor(int p){\n\t\tR r=term(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='*'||c=='/'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='*')\n\t\t\t\t\tr.val*=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val/=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR term(int p){\n\t\tif(s.charAt(p)=='('){\n\t\t\tR r=equation(p+1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t}else{\n\t\t\tboolean minus=false;\n\t\t\tif(s.charAt(p)=='-'){\n\t\t\t\tp++;\n\t\t\t\tminus=true;\n\t\t\t}\n\t\t\tlong val=0;\n\t\t\tfor(; Character.isDigit(s.charAt(p)); p++){\n\t\t\t\tval=val*10+(s.charAt(p)-'0');\n\t\t\t}\n\t\t\tif(minus){\n\t\t\t\tval=-val;\n\t\t\t}\n\t\t\treturn new R(p, val);\n\t\t}\n\t}\n\n\tclass R{\n\t\tint p;\n\t\tlong val;\n\n\t\tR(int p, long val){\n\t\t\tthis.p=p;\n\t\t\tthis.val=val;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char a) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\t\t//()内は無視\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif(a==c && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\n\t\n\tstatic int parse(String str) {\n\t\tint a = str.length();\n\t\tint n = 0;\n\t\tint g = 0;\n\t\tif(str.startsWith(\"(\") && str.endsWith(\")\")) {\t\t\t\t//(で始まり)で終わる\n\t\t\tif(!str.substring(1, a-1).contains(\"(\"))\t\t\t\t//間に()がなければsubstr\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\tfor(int i=0;i<str.length()-1;i++) {\n\t\t\t\tif(str.charAt(i)=='(') {\n\t\t\t\t\tn++;\n\t\t\t\t\tg++;\n\t\t\t\t}\n\t\t\t\tif(str.charAt(i)==')') n--;\n\t\t\t\tif(g!=0 && n==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==str.length()-2 && n-1==0) {\n\t\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ind = lastInd(str,'+');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) + parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'-');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) - parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'/');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) / parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'*');\n\t\tif(ind!=-1){\n\t\t\treturn parse(str.substring(0, ind)) * parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\nclass Main{\n\tpublic static void main(String[]z)throws Exception{\n\t\tScriptEngineManager factory = new ScriptEngineManager();\n\t\tScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[101];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tString input_str = br.readLine();\n\t\t\t\tchar[] line = new char[101];\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (5-(6/2/2+50*3/2/3*6/4)/9*2-(6/2/2+50*3/2/3*6)-36)*2-1=\n\nclass Main{\n\tstatic Pattern addsub = Pattern.compile(\"^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$\");\n\tstatic Pattern muldiv = Pattern.compile(\"^(.*?)(-?\\\\d+)([*/])(-?\\\\d+)(.*)$\");\n\n\tstatic String process(String s){\n\t//System.out.println(\"---\"+s);\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\t//System.out.println(\"+++\"+s);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next().replaceAll(\"-\",\"Z\");\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main{\n\n\tpublic static void main(String args[]){\n\t\tnew Main().mainrun();\n\t}\n\n\tprivate Scanner scan;\n\tprivate String[] str;\n\n\tprivate int cursor = 0;\n\n\tprivate void mainrun() {\n\t\tscan = new Scanner(System.in);\n\n\t\tint n = Integer.parseInt(scan.nextLine());\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcursor = 0;\n\t\t\tstr = scan.nextLine().split(\"\");\n\t\t\tSystem.out.println(looprun());\n\t\t}\n\n\t\tscan.close();\n\t}\n\n\tprivate Long looprun() {\n\t\tDeque<String> element = new LinkedList<String>();\n\n\t\tDeque<String> c = new LinkedList<String>();\n\n\t\tboolean numflag = false;\n\n\t\tfor(int i = cursor;i < str.length;i++) {\n\t\t\tif(str[i].equals(\" \")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(str[i].equals(\"(\")) {\n\t\t\t\tcursor = i + 1;\n\t\t\t\telement.add(Long.toString(looprun()));\n\t\t\t\ti = cursor;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(str[i].equals(\")\")) {\n\t\t\t\tcursor = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(str[i]) {\n\t\t\tcase \"+\":\n\t\t\tcase \"-\":\n\t\t\tcase \"*\":\n\t\t\tcase \"/\":\n\t\t\t\tif(!c.isEmpty()) {\n\t\t\t\t\tif(rank(c.getFirst()) >= rank(str[i])) {\n\t\t\t\t\t\twhile(!c.isEmpty()) {\n\t\t\t\t\t\t\tif(rank(c.getFirst()) >= rank(str[i])) {\n\t\t\t\t\t\t\t\telement.add(c.remove());\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tc.push(str[i]);\n\t\t\t\tnumflag = false;\n\t\t\t\tbreak;\n\t\t\tcase \"=\":\n\t\t\t\tbreak;\n\t\t\tdefault: /*数値 0-9 */\n\t\t\t\tif(numflag) {\n\t\t\t\t\tString a = element.removeLast();\n\t\t\t\t\telement.add(a + str[i]);\n\t\t\t\t}else {\n\t\t\t\t\telement.add(str[i]);\n\t\t\t\t\tnumflag = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile(!c.isEmpty()) {\n\t\t\telement.add(c.pop());\n\t\t}\n\n\t\treturn cal(element);\n\t}\n\n\tprivate int rank(String s) {\n\t\tif(s.equals(\"*\") || s.equals(\"/\")) {\n\t\t\treturn 2;\n\t\t}else { /* s.equals(\"+\") || s.equals(\"-\") */\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tprivate Long cal(Deque<String> l) {\n\t\tStack<String> c = new Stack<>();\n\n\t\tfor(String s : l){\n\t\t\tswitch(s) {\n\t\t\tcase \"+\":\n\t\t\tcase \"-\":\n\t\t\tcase \"*\":\n\t\t\tcase \"/\":\n\t\t\t\tlong b = Long.parseLong(c.pop());\n\t\t\t\tlong a = Long.parseLong(c.pop());\n\t\t\t\tif(s.equals(\"+\")) {c.push(Long.toString(a + b));}\n\t\t\t\tif(s.equals(\"-\")) {c.push(Long.toString(a - b));}\n\t\t\t\tif(s.equals(\"*\")) {c.push(Long.toString(a * b));}\n\t\t\t\tif(s.equals(\"/\")) {c.push(Long.toString(a / b));}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tc.push(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn Long.parseLong(c.pop());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// ((6/2/2+50*3/2/3*6/4)+(6/2/2+50*3/2/3*6))*2+1=\n\nclass Main{\n\tstatic Pattern parens = Pattern.compile(\"(.*?)\\\\((.+)\\\\)(.*)\");\n\tstatic Pattern addsub = Pattern.compile(\"(.*?)(\\\\d+)([+-])(\\\\d+)(.*)\");\n\tstatic Pattern muldiv = Pattern.compile(\"(.*?)(\\\\d+)([*/])(\\\\d+)(.*)\");\n\tstatic Pattern div = Pattern.compile(\"(.*?)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\tstatic String process(String s){\n\t//System.out.println(\"---\"+s);\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\t//System.out.println(\"+++\"+s);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport javax.script.*;\n\nclass Main{\n\tpublic static void main(String[]z){try{\n\t\tScanner x=new Scanner(System.in);\n\t\tScriptEngine y = new ScriptEngineManager().getEngineByName(\"JavaScript\");\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\ty.eval(\"println(\"+s.substring(0,s.length()-1)+\");\");\n\t\t}\n\t}catch(Exception e){}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Smart Calculator\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\t//skip first line\n\t\tbr.readLine();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tDeque<String> queue = new ArrayDeque<>();\n\t\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\t\tchar _c = 0;\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twhile (!stack.isEmpty() && (stack.peek() == '*' || stack.peek() == '/')) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '/':\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\t\twhile (stack.peek() != '(') {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ('0' <= _c && _c <= '9') {\n\t\t\t\t\t\t\tString s = queue.pollLast();\n\t\t\t\t\t\t\tqueue.offer(s + c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(c));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_c = c;\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tDeque<Integer> ans = new ArrayDeque<>();\n\t\t\tfor (String s : queue) {\n\t\t\t\tif (\"+-*/\".indexOf(s) != -1) {\n\t\t\t\t\tint a, b;\n\t\t\t\t\tb = ans.pop();\n\t\t\t\t\ta = ans.pop();\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\t\tans.push(a + b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\tans.push(a - b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\tans.push(a * b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tans.push(a / b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tans.push(parseInt(s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.peek());\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[101];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// 2*(6/2/2+50*3/2/3*6)+1=\n\nclass Main{\n\tstatic Pattern parens = Pattern.compile(\"(.*?)\\\\((.+)\\\\)(.*)\");\n\tstatic Pattern addsub = Pattern.compile(\"(.*?)(\\\\d+)([+-])(\\\\d+)(.*)\");\n\tstatic Pattern muldiv = Pattern.compile(\"(.*?)(\\\\d+)([*/])(\\\\d+)(.*)\");\n\tstatic Pattern div = Pattern.compile(\"(.*?)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\tstatic String process(String s){\n\t\tMatcher m=parens.matcher(s);\n\t\tif(m.find()){\n\t\t\ts=m.group(1)+process(m.group(2))+m.group(3);\n\t\t}\n\n\t\tm=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tString s;\n\n\tvoid run(){\n\t\tfor(int n=sc.nextInt(); n>0; n--){\n\t\t\ts=sc.next();\n\t\t\tprintln(equation(0).val+\"\");\n\t\t}\n\t}\n\n\tR equation(int p){\n\t\tR r=factor(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='+'||c=='-'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='+')\n\t\t\t\t\tr.val+=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val-=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR factor(int p){\n\t\tR r=term(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='*'||c=='/'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='*')\n\t\t\t\t\tr.val*=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val/=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR term(int p){\n\t\tif(s.charAt(p)=='('){\n\t\t\tR r=equation(p+1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t}else{\n\t\t\tint val=0;\n\t\t\tfor(; Character.isDigit(s.charAt(p)); p++){\n\t\t\t\tval=val*10+(s.charAt(p)-'0');\n\t\t\t}\n\t\t\treturn new R(p, val);\n\t\t}\n\t}\n\n\tclass R{\n\t\tint p, val;\n\n\t\tR(int p, int val){\n\t\t\tthis.p=p;\n\t\t\tthis.val=val;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n\tstatic String s;\n\tstatic int now;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts = sc.next();\n\t\t\tnow = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == '+') {\n\t\t\t\tnow++;\n\t\t\t\tret += term();\n\t\t\t} else if (s.charAt(now) == '-') {\n\t\t\t\tnow++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (true) {\n\t\t\tif (s.charAt(now) == '*') {\n\t\t\t\tnow++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (s.charAt(now) == '/') {\n\t\t\t\tnow++;\n\t\t\t\tret /= factor();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic int factor() {\n\t\tif (s.charAt(now) == '(') {\n\t\t\tnow++;\n\t\t\tint ret = expression();\n\t\t\tnow++;\n\t\t\treturn ret;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(s.charAt(now))) {\n\t\t\tret *= 10;\n\t\t\tret += s.charAt(now) - '0';\n\t\t\tnow++;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    String dummy = scanner.nextLine();\n    while (scanner.hasNext()) {\n      String line = scanner.nextLine();\n      Deque<String> ou = new ArrayDeque<String>();\n      Deque<String> op = new ArrayDeque<String>();\n      for (int ii = 0; ii < line.length(); ii++) {\n        Character pp = line.charAt(ii);\n        String p = pp.toString();\n        if (p.equals(\"=\")) {\n          while (!op.isEmpty()) {\n            ou.addLast(op.removeLast());\n          }\n          break;\n        } else if (p.equals(\"+\") || p.equals(\"-\")) {\n          while (!op.isEmpty()) {\n            if (op.getLast().equals(\"(\")) {\n              break;\n            }\n            ou.addLast(op.removeLast());\n          }\n          op.addLast(p);\n        } else if (p.equals(\"*\") || p.equals(\"/\") || p.equals(\"(\")) {\n          op.addLast(p);\n        } else if (p.equals(\")\")) {\n          for (;;) {\n            if (op.isEmpty()) {\n              break;\n            }\n            String work = op.removeLast();\n            if (work.equals(\"(\")) {\n              break;\n            }\n            ou.addLast(work);\n          }\n        } else {\n          ou.addLast(p);\n        }\n//System.out.println(ou.toString());\n//System.out.println(op.toString());\n      }\n//System.out.println(ou.toString());\n//System.out.println(op.toString());\n      Deque<Integer> num = new ArrayDeque<Integer>();\n      while (!ou.isEmpty()) {\n        String p = ou.removeFirst();\n        if (p.equals(\"+\")) {\n          num.addLast(num.removeLast() + num.removeLast());\n        } else if (p.equals(\"-\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b - a);\n        } else if (p.equals(\"*\")) {\n          num.addLast(num.removeLast() * num.removeLast());\n        } else if (p.equals(\"/\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b / a);\n        } else {\n          num.addLast(Integer.parseInt(p));\n        }\n      }\n      out += num.removeLast() + \"\\n\";\n    }\n    System.out.print(out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.lang.Character.Subset;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0109();\n\t}\n\n\tclass AOJ0109{\n\t\tchar[] line;\n\t\tint pos;\n\n\t\tint exp(){\n\t\t\tint r = term();\n\t\t\twhile(true){\n\t\t\t\tchar c = line[pos++];\n\t\t\t\tif(c=='+')r+=term();\n\t\t\t\telse if(c=='-')r-=term();\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\n\t\tint term(){\n\t\t\tint r = fact();\n\t\t\twhile(true){\n\t\t\t\tchar c = line[pos++];\n\t\t\t\tif(c=='*') r*=fact();\n\t\t\t\telse if(c=='/')r/=fact();\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tpos--;\n\t\t\treturn r;\n\t\t}\n\n\t\tint fact(){\n\t\t\tchar c = line[pos++];\n\t\t\tif(c=='(')return exp();\n\t\t\tif(c=='-')return -fact();\n\t\t\tif(c=='+')return fact();\n\t\t\tint x = c-'0';\n\t\t\twhile(true){\n\t\t\t\tc = line[pos++];\n\t\t\t\tif(Character.isDigit(c)){\n\t\t\t\t\tx *= 10;\n\t\t\t\t\tx += c-'0';\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tpos--;\n\t\t\treturn x;\n\t\t}\n\t\tvoid doIt(){\n\t\t\tString a = in.next();\n\t\t\tline = a.toCharArray();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\n\t\tpublic AOJ0109() {\n\t\t\tint n = in.nextInt();\n\t\t\twhile(n--!=0)doIt();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew A().doIt();\n\t}\n\tclass A{\n\t\tString str;\n\t\tint pos;\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tstr = sc.next();\n\t\t\t\tpos = 0;\n\t\t\t\tSystem.out.println(exp());\n\t\t\t}\n\t\t}\n\t\tint exp() {\n\t\t\tint res = term();\n\t\t\twhile(true){\n\t\t\t\tchar op = str.charAt(pos);\n\t\t\t\tif(op != '+' && op != '-')break;\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tif(op == '+')res = old + res;\n\t\t\t\telse res = old - res;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tint term(){\n\t\t\tint res = fact();\n\t\t\twhile(true){\n\t\t\t\tchar op = str.charAt(pos);\n\t\t\t\tif(op != '*' && op != '/')break;\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tif(op == '*')res = old * res;\n\t\t\t\telse res = old / res;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tint fact(){\n\t\t\tif(Character.isDigit(str.charAt(pos))){\n\t            int t = str.charAt(pos) - '0';\n\t            pos++;\n\t            while(Character.isDigit(str.charAt(pos))){\n\t                t = t * 10 + (str.charAt(pos) - '0');\n\t                pos++; \n\t            }\n\t            return t; \n\t        }\n\t        else if(str.charAt(pos) == '('){\n\t            pos++;\n\t            int res = exp();\n\t            pos++;\n\t            return res;\n\t        }\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class SmartCalculator {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\n\t\tint size = Integer.parseInt(line);\n\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint a = SC(line);\n\t\t\tans.add(a);\n\t\t}\n\n\t\tfor(int i=0; i<ans.size(); i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\n\tpublic int SC(String line){\n\t\tList<String> eq = new ArrayList<String>();\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tString str = line.substring(count, count+1);\n\t\t\tif(str.equals(\"=\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq.add(str);\n\t\t\tcount++;\n\t\t}\n\n\t\tcount = 0;\n\t\twhile(count < eq.size()-1){\n\t\t\tif(isNumber(eq.get(count)) && isNumber(eq.get(count+1))){\n\t\t\t\tString dst = eq.get(count) + eq.get(count+1);\n\t\t\t\teq.add(count+2, dst);\n\t\t\t\teq.remove(count);\n\t\t\t\teq.remove(count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\n\t\twhile(eq.size() != 1){\n\t\t\t//ツ環古環づ個計ツ算\n\t\t\tint m;\n\t\t\tint bra_count = 0;\n\t\t\tint n = eq.indexOf(\"(\");\n\t\t\tif(n != -1){\n\t\t\t\tfor(int i=n+1; i<eq.size(); i++){\n\t\t\t\t\tif(eq.get(i).equals(\")\") && bra_count == 0){\n\t\t\t\t\t\teq = RangeReplace(eq, n, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\"(\")){\n\t\t\t\t\t\tbra_count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\")\")){\n\t\t\t\t\t\tbra_count--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ掛ツつッツ算ツ環づィツ算\n\t\t\tn = eq.indexOf(\"*\");\n\t\t\tm = eq.indexOf(\"/\");\n\n\t\t\tif(n != -1 && (m == -1 || n < m)){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) * Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(m != -1 && (n == -1 || m < n)){\n\t\t\t\tint a = Integer.parseInt(eq.get(m-1)) / Integer.parseInt(eq.get(m+1));\n\t\t\t\teq.add(m+2, Integer.toString(a));\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ堕ォツつオツ算ツ暗クツつォツ算\n\t\t\tn = eq.indexOf(\"+\");\n\t\t\tm = eq.indexOf(\"-\");\n\n\t\t\tif(n != -1 && (m == -1 || n < m)){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) + Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(m != -1 && (n == -1 || m < n)){\n\t\t\t\tint a = Integer.parseInt(eq.get(m-1)) - Integer.parseInt(eq.get(m+1));\n\t\t\t\teq.add(m+2, Integer.toString(a));\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\teq.remove(m-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn Integer.parseInt(eq.get(0));\n\t}\n\n\tpublic List<String> RangeReplace(List<String> eq, int s, int e){\n\t\tString part = \"\";\n\n\t\tfor(int i=s+1; i<e; i++){\n\t\t\tpart += eq.get(i);\n\t\t}\n\n\t\tpart = Integer.toString(SC(part+\"=\"));\n\n\t\teq.add(e+1, part);\n\n\t\tfor(int i=s; i<=e; i++){\n\t\t\teq.remove(s);\n\t\t}\n\n\t\treturn eq;\n\t}\n\n\tpublic boolean isNumber(String s){\n\t\ttry{\n\t\t\tint n = Integer.parseInt(s);\n\t\t}catch(NumberFormatException err){\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic char a[];\n\tstatic int id;\n\tstatic int n;\n\n\tpublic static int exp() {\n\t\tint left = term();\n\t\twhile (true) {\n\t\t\tint c = a[id++];\n\t\t\tif (c == '+') {\n\t\t\t\tint right = term();\n\t\t\t\tleft += right;\n\t\t\t} else if (c == '-') {\n\t\t\t\tint right = term();\n\t\t\t\tleft -= right;\n\t\t\t} else {\n\t\t\t\tid--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\tpublic static int term() {\n\t\tint left = fact();\n\t\twhile (true) {\n\t\t\tint c = a[id++];\n\t\t\tif (c == '*') {\n\t\t\t\tint right = fact();\n\t\t\t\tleft *= right;\n\t\t\t} else if (c == '/') {\n\t\t\t\tint right = fact();\n\t\t\t\tleft /= right;\n\t\t\t} else {\n\t\t\t\tid--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\tpublic static int fact() {\n\t\tint c = a[id++];\n\t\tif (c == '+') {\n\t\t\treturn exp();\n\t\t} else if (c == '-') {\n\t\t\treturn -exp();\n\t\t} else if (c == '(') {\n\t\t\tint left = exp();\n\t\t\tid++;\n\t\t\treturn left;\n\t\t} else {\n\t\t\tint x = c - '0';\n\t\t\twhile (true) {\n\t\t\t\tif (Character.isDigit(a[id])) {\n\t\t\t\t\tx *= 10;\n\t\t\t\t\tx += a[id++] - '0';\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = x;\n\t\t}\n\t\treturn c;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();\n\t\twhile (m-- != 0) {\n\t\t\ta = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tn = a.length;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\tint t = in.nextInt();\n\t\twhile(t-->0){\n\t\t\ts = in.next().toCharArray();\n\t\t\tcur = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\t\n\tpublic static int cur;\n\tpublic static int exp(){\n\t\tint val = add();\n\t\twhile(s[cur] == '+' || s[cur] == '-'){\n\t\t\tif(s[cur++] == '+'){\n\t\t\t\tval += add();\n\t\t\t}else val -= add();\n\t\t}\n\t\treturn val;\n\t}\n\t\n\tpublic static int add(){\n\t\tint val = mult();\n\t\twhile(s[cur] == '*' || s[cur] == '/'){\n\t\t\tif(s[cur++] == '*'){\n\t\t\t\tval *= mult();\n\t\t\t}else val /= mult();\n\t\t}\n\t\treturn val;\n\t}\n\t\n\tpublic static int mult(){\n\t\tif(s[cur] == '('){\n\t\t\tcur++;\n\t\t\tint val = exp();\n\t\t\tcur++;\n\t\t\treturn val;\n\t\t}else{\n\t\t\treturn num();\n\t\t}\n\t}\n\t\n\tpublic static int num(){\n\t\tint d = 0;\n\t\tint sign = 1;\n\t\tif(s[cur] == '-'){\n\t\t\tsign = -1;\n\t\t\tcur++;\n\t\t}\n\t\twhile(cur < s.length && Character.isDigit(s[cur])){\n\t\t\td *= 10;\n\t\t\td += s[cur++]-'0';\n\t\t}\n\t\treturn d*sign;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\t\n\tString formulaStr = \"\"; //式を保存する文字列\n\tint index = 0; //式の文字列のインデックス\n\t\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.smartCalculator();\n\t\treturn;\n\t}\n\t\n\t//四則演算を計算する\n\tprivate void smartCalculator() {\n\t\t\n\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); //標準入力\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tString inputNumStr = bufferedReader.readLine();\n\t\t\tint inputNum = Integer.parseInt(inputNumStr); //与えられる式の数\n\t\t\t\n\t\t\t//式の計算\n\t\t\tfor (int i = 0; i < inputNum; i++) {\n\t\t\t\tformulaStr = bufferedReader.readLine();\n\t\t\t\tindex = 0;\n\t\t\t\tSystem.out.println(this.calculationFormula());\n\t\t\t}\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t}\n\t\n\t//式の計算を行う\n\tprivate Long calculationFormula() {\n\t\t\n\t\tlong answer = 0;\n\t\t\n\t\tanswer = this.calculationAddSub();\n\t\t\n\t\treturn answer;\n\t}\n\t\n\t//足し算、引き算の処理\n\tprivate Long calculationAddSub() {\n\t\t\n\t\tlong answer = this.calculationMulDiv();\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tswitch (formulaStr.charAt(index)) {\n\t\t\t\tcase '+':\n\t\t\t\t\tindex++;\n\t\t\t\t\tanswer += this.calculationMulDiv();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tindex++;\n\t\t\t\t\tanswer -= this.calculationMulDiv();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn answer;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\t//掛け算、割り算の処理\n\tprivate Long calculationMulDiv() {\n\t\t\n\t\tlong answer = this.calculationTerm();\n\t\t\n\t\twhile (true) {\n\t\t\t\n\t\t\tswitch (formulaStr.charAt(index)) {\n\t\t\t\tcase '*':\n\t\t\t\t\tindex++;\n\t\t\t\t\tanswer *= this.calculationTerm();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tindex++;\n\t\t\t\t\tanswer /= this.calculationTerm();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn answer;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\t//括弧と数字の処理\n\tprivate Long calculationTerm() {\n\t\t\n\t\tlong answer = 0;\n\t\t\n\t\t//括弧があった場合、優先して処理する\n\t\tif (formulaStr.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tanswer = this.calculationAddSub();\n\t\t\tindex++;\n\t\t\treturn answer;\n\t\t}\n\t\t\n\t\t//数字の場合の処理\n\t\tif (Character.isDigit(formulaStr.charAt(index))) {\n\t\t\treturn this.calculationValue();\n\t\t}\n\t\t\n\t\treturn (long) 0;\n\t}\n\t\n\t//文字列から非演算子の数字のみを切り出す\n\tprivate Long calculationValue() {\n\t\t\n\t\tString tmpStr = formulaStr.substring(index); //処理が終わる前の式を切り出す\n\t\tString[] tmpStrs = tmpStr.split(\"[+-/\\\\*=)]\");\n\t\t\n\t\tindex += tmpStrs[0].length(); //インデックスの更新\n\t\t\n\t\treturn Long.parseLong(tmpStrs[0]);\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\tchar[] a = str.toCharArray();\n\t\t\ts = new char[150];\n\t\t\tfor(int i = 0; i < a.length;i++){\n\t\t\t\ts[i]=a[i];\n\t\t\t}\n\n\t\t\tSystem.out.println(expression());\n\t\t}\n\n\t}\n\tstatic int expression(){\n\t\tint res =term();\n\t\twhile(s[idx]=='+'||s[idx]=='-'){\n\t\t\tif(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres+=term();\n\t\t\t}\n\t\t\telse if(s[idx]=='-'){\n\t\t\t\tidx++;\n\t\t\t\tres-=term();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\twhile(s[idx]=='*'||s[idx]=='/'){\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres*=fact();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tidx++;\n\t\t\t\tres/=fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\twhile(true){\n\t\t\t\tres += s[idx]-'0';\n\t\t\t\tidx++;\n\t\t\t\tif(!Character.isDigit(s[idx])){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres*=10;\n\t\t\t}\n\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\ts = new char[101];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i]=str.charAt(i);\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\t\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = kagen();\n\t\treturn res;\n\t}\n\tstatic int kagen(){\n\t\tint res = joujo();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\treturn res +term();\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\treturn res -term();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int joujo(){\n\t\tint res =  value();\n\t\t\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\treturn res *value();\n\t\t}\n\t\telse if(s[idx]=='/'){\n\t\t\tidx++;\n\t\t\treturn res /value();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int value(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=term();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\tres = s[idx++]-'0';\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n \nclass Main {\n     \n    private static String context;\n    private static int pos;\n     \n    public Main() {\n        this.context = \"\";\n        this.pos = 0;\n    }\n     \n    public static void setContext(String exp) {\n        context = exp;\n    }\n \n    private static double fact() { \n        if( context.charAt(pos) == '(' ) {\n            ++pos;\n            double p = expression();\n            ++pos;\n            return p;\n        } else {\n            int sp = pos;\n            while( pos < context.length() && ( ( '0' <= context.charAt(pos) && context.charAt(pos) <= '9' ) || context.charAt(pos) == '.' ) ) {\n                ++pos;\n            }\n            String q = context.substring(sp, pos);\n            return Double.parseDouble(q);\n        }\n    }\n     \n    private static double term() {\n        double p = fact();\n        while( pos < context.length() ) {\n            char c = context.charAt(pos);\n            if( c =='*' ) {\n                ++pos;\n                p *= fact();\n            } else if( c == '/' ) {\n                ++pos;\n                //p /= (int)fact();\n\t\tp = (int)(p / (int)fact());\n            } else {\n                break;\n            }\n        }\n        return p;\n    }\n     \n    private static double expression() {\n        double p = term();\n        while( pos < context.length() ) {\n            char c = context.charAt(pos);\n            if( c == '+' ) {\n                ++pos;\n                p += term();\n            } else if( c == '-' ) {\n                ++pos;\n                p -= term();\n            } else {\n                break;\n            }\n        }\n        return p;\n    }\n     \n    public static double eval(String exp) {\n        context = removeSpace(exp);\n        pos = 0;\n        return expression();\n    }\n     \n    private static String removeSpace(String s) {\n        String t = \"\";\n        for(int i=0;i<s.length();++i) {\n            char c = s.charAt(i);\n            if( c == ' ') {\n                continue;\n            } \n            t += c;\n        }\n        return t;\n    }\n     \n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        for(int i=0;i<n;++i) {\n            String s = br.readLine();\n            s = s.substring(0,(int)s.length()-1);\n            System.out.println((int)eval(s));\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (5+(6/2/2+50*3/2/3*6/4)+(6/2/2+50*3/2/3*6))*2+1=\n\nclass Main{\n\tstatic Pattern addsub = Pattern.compile(\"(.*?)(\\\\d+)([+-])(\\\\d+)(.*)\");\n\tstatic Pattern muldiv = Pattern.compile(\"(.*?)(\\\\d+)([*/])(\\\\d+)(.*)\");\n\n\tstatic String process(String s){\n\t//System.out.println(\"---\"+s);\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\t//System.out.println(\"+++\"+s);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int calculate(String str){\n\t\tStringBuilder ans = new StringBuilder(str);\n\t\twhile( true ){\n\t\t\tStringBuilder temp = new StringBuilder();\n\t\t\tint key = 0;\n\t\t\tint before = -1;\n\t\t\tint after = ans.length();\n\t\t\tfor(int i = 0; i < ans.length(); i++){\n\t\t\t\tif( !Character.isDigit(ans.charAt(i)) ){\n\t\t\t\t\tif( ans.charAt(i) == '*' || ans.charAt(i) == '/' ){\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if( key == 0 ){\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tSystem.out.println(\"before = \" + before + \", key = \" + key + \", after = \" + after);\n\t\t\tif( key == 0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = key-1; i > 0; i--){\n\t\t\t\tif( !Character.isDigit(ans.charAt(i)) ){\n\t\t\t\t\tbefore = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = key+1; i < ans.length(); i++){\n\t\t\t\tif( !Character.isDigit(ans.charAt(i)) ){\n\t\t\t\t\tafter = i;\n\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp.append(ans.toString().substring(0, before+1));\n\t\t\tint x = Integer.parseInt(ans.toString().substring(before+1, key));\n\t\t\tint y = Integer.parseInt(ans.toString().substring(key+1, after));\n\t\t\tswitch( ans.charAt(key) ){\n\t\t\t\tcase '*' : temp.append(x*y); break;\n\t\t\t\tcase '/' : temp.append(x/y); break;\n\t\t\t\tcase '+' : temp.append(x+y); break;\n\t\t\t\tcase '-' : temp.append(x-y); break;\n\t\t\t}\n\t\t\ttemp.append(ans.toString().substring(after));\n\t\t\tans = new StringBuilder(temp);\n\t\t}\n\t\treturn Integer.parseInt(ans.toString());\n\t\t\n\t}\n\t\t\t\t\t\n\tpublic int step(String str){\n\t\tStringBuilder ans = new StringBuilder(str);\n\t\tans.deleteCharAt(ans.length()-1);\n\t\twhile( true ){\n\t\t\tStringBuilder temp = new StringBuilder();\n\t\t\tint n = ans.indexOf(\")\");\n\t\t\tint m = ans.lastIndexOf(\"(\", n);\n\t\t\tif( n < 0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp.append(ans.toString().substring(0, m));\n\t\t\ttemp.append(calculate(ans.toString().substring(m+1, n)));\n\t\t\ttemp.append(ans.toString().substring(n+1, ans.length()));\n\t\t\tans = new StringBuilder(temp);\n\t\t//\tSystem.out.println(ans);\n\t\t}\n\t\treturn calculate(ans.toString());\n\t}\n\tpublic void solve() throws IOException{\n\t\tint n = nextInt();\n\t\twhile( n-- > 0 ){\n\t\t\tString str = nextToken();\n\t\t\tSystem.out.println(step(str));\t\t\n\t\t}\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\t\t\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.function.IntBinaryOperator;\n\npublic class Main{\n\n    static int lastIndexOf(String e, char ch) {\n        int nest = 0;\n        for(int i = e.length()-1; i > 0 ; i--) {\n            char c = e.charAt(i);\n            if(c == ‘(’) {\n                nest++;\n            }\n            if(c == ‘)’) {\n                nest--;\n            }\n            if(ch == c && nest == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    static int parse(String e) {\n        if(e.startsWith(“(”) && e.endsWith(“)”)) {\n            return parse(e.substring(1, e.length()-1));\n        }\n        int loc = lastIndexOf(e, ‘-’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) - parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘+’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) + parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘/’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) / parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘*’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) * parse(e.substring(loc+1));\n        }\n        return Integer.parseInt(e);\n    }\n    \n    public static void main(String[] args) {\n        try(Scanner sc = new Scanner(System.in)) {\n            int n = sc.nextInt();\n            for(int i = 0; i < n; i++) {\n                String e = str.substring(0,str.length()-1);\n                System.out.println(parse(e));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        while(n-->0){\n            in = sc.next().toCharArray();\n            p = 0;     \n            System.out.println(expr());            \n        }\n    }\n\n    int expr(){\n        int a = term();\n        while(p<in.length && (in[p]=='+' || in[p]=='-')){\n            boolean boo = in[p]=='+';\n            p++;\n            int b = term();\n            if(boo) a += b;\n            else a -= b;\n        }\n        return a;\n    }\n\n    int term(){\n        int a = factor();\n        while(p<in.length && (in[p]=='*' || in[p]=='/')){\n            boolean boo = in[p]=='*';\n            p++;\n            int b = factor();\n            if(boo) a *= b;\n            else a /= b;\n        }\n        return a;\n    }\n\n    int factor(){\n        if(p<in.length && in[p]=='('){\n            p++;\n            int res = expr();\n            p++;\n            return res;\n        }\n        else return digit();\n    }\n\n    int digit(){\n        int res = 0;\n        while(p<in.length && Character.isDigit(in[p])){\n            res = res*10 + (in[p]-'0');\n            p++;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    HashMap<String, Integer> op = new HashMap<String, Integer>(){{\n        put(\"*\", 1); put(\"/\", 1);\n        put(\"+\", 2); put(\"-\", 2);\n        put(\"(\", 3); put(\")\", 3);\n    }};\n\n    void solve(){\n        int n = in.nextInt(); in.nextLine();\n        for(int i = 0; i < n; i++){\n            ArrayDeque<String> q = toRevPolish(in.nextLine());\n            System.out.println(calc(q));\n        }\n    }\n\n    ArrayDeque<String> toRevPolish(String str){\n        ArrayDeque<String> p = new ArrayDeque<>(), s = new ArrayDeque<>();\n        str = str.substring(0, str.length() - 1);\n\n        while(str.length() > 0){\n            int idx = nextIndex(str);\n            String t = str.substring(0, idx);\n            if(t.equals(\"(\")){\n                s.push(t);\n            }else if(t.equals(\")\")){\n                while(!s.peek().equals(\"(\")){\n                    p.push(s.pop());\n                }\n                s.pop();\n            }else{\n                while(s.size() > 0 && getRank(t) > getRank(s.peek())){\n                    p.push(s.pop());\n                }\n                s.push(t);\n            }\n            str = str.substring(idx);\n        }\n\n        while(p.size() > 0){\n            s.push(p.pop());\n        }\n\n        return s;\n    }\n\n    int calc(ArrayDeque<String> q){\n        Deque<Integer> t = new ArrayDeque<>();\n\n        while(q.size() > 0){\n            String s = q.pop();\n            if(isOperator(s)){\n                int a = t.pop(), b = t.pop();\n                switch(s){\n                    case \"+\": t.push(b + a); break;\n                    case \"-\": t.push(b - a); break;\n                    case \"*\": t.push(b * a); break;\n                    case \"/\": t.push(b / a); break;\n                }\n            }else{\n                t.push(Integer.parseInt(s));\n            }\n           \n        }\n\n        return t.pop();\n    }\n\n    int nextIndex(String str){\n        int idx = 0;\n        while(idx < str.length() && !isOperator(str.charAt(idx))) idx++;\n        if(idx == 0) idx = 1;\n        return idx;\n    }\n\n    boolean isOperator(char ch){\n        return \"*/+-()\".indexOf(ch) > -1;\n    }\n\n    boolean isOperator(String s){\n        return s.length() == 1 && isOperator(s.charAt(0));\n    }\n\n    int getRank(String str){\n        return isOperator(str) ? op.get(str) : 0;\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\n\nclass EvalScript {\n    public static void main(String[] args) throws Exception {\n        ScriptEngineManager factory = new ScriptEngineManager();\n        ScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n       \n        engine.eval(\"println('Hello JavaScript from Java.')\");\n       \n        engine.eval(\"var str1 = 'JavaScript String'\");\n        engine.eval(\"println(str1);\");\n        engine.eval(\"var str2 = new java.lang.String('Java String');\");\n        engine.eval(\"println(str2);\");\n       \n        engine.eval(\"var array = ['JavaScript', 'Array'];\");\n        engine.eval(\"println(array);\");\n        engine.eval(\"var list = new java.util.ArrayList();\");\n        engine.eval(\"list.add('Java');\");\n        engine.eval(\"list.add('ArrayList');\");\n        engine.eval(\"println(list);\");\n       \n        engine.eval(\"var obj = {'JavaScript':'Object'};\");\n        engine.eval(\"println(obj);\");\n        engine.eval(\"var map = new java.util.HashMap();\");\n        engine.eval(\"map.put('Java', 'HashMap');\");\n        engine.eval(\"println(map);\");\n       \n        Runtime r = Runtime.getRuntime();\n        engine.put(\"r\", r);\n        engine.eval(\"print('Max:   ' + r.maxMemory() + ' Bytes\\\\n');\");\n        engine.eval(\"print('Total: ' + r.totalMemory() + ' Bytes\\\\n');\");\n        engine.eval(\"print('Free:  ' + r.freeMemory() + ' Bytes\\\\n');\");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    HashMap<String, Integer> op = new HashMap<String, Integer>(){{\n        put(\"*\", 1); put(\"/\", 1);\n        put(\"+\", 2); put(\"-\", 2);\n        put(\"(\", 3); put(\")\", 3);\n    }};\n\n    void solve(){\n        int n = in.nextInt(); in.nextLine();\n        for(int i = 0; i < n; i++){\n            ArrayDeque<String> q = toRevPolish(in.nextLine());\n            System.out.println(calc(q));\n        }\n    }\n\n    ArrayDeque<String> toRevPolish(String str){\n        ArrayDeque<String> p = new ArrayDeque<>(), s = new ArrayDeque<>();\n        str = str.replace(\"=\", \"\");\n\n        while(str.length() > 0){\n            int idx = nextIndex(str);\n            String t = str.substring(0, idx);\n            if(t.equals(\"(\")){\n                s.push(t);\n            }else if(t.equals(\")\")){\n                while(!s.peek().equals(\"(\")){\n                    p.push(s.pop());\n                }\n                s.pop();\n            }else{\n                while(s.size() > 0 && getRank(t) > getRank(s.peek())){\n                    p.push(s.pop());\n                }\n                s.push(t);\n            }\n            str = str.substring(idx);\n        }\n\n        while(p.size() > 0){\n            s.push(p.pop());\n        }\n\n        return s;\n    }\n\n    int calc(ArrayDeque<String> q){\n        Deque<Integer> t = new ArrayDeque<>();\n\n        while(q.size() > 0){\n            String s = q.pop();\n            if(isOperator(s)){\n                int a = t.pop(), b = t.pop();\n                switch(s){\n                    case \"+\": t.push(b + a); break;\n                    case \"-\": t.push(b - a); break;\n                    case \"*\": t.push(b * a); break;\n                    case \"/\": t.push(b / a); break;\n                }\n            }else{\n                t.push(Integer.parseInt(s));\n            }\n           \n        }\n\n        return t.pop();\n    }\n\n    int nextIndex(String str){\n        int idx = 0;\n        while(idx < str.length() && !isOperator(str.charAt(idx))) idx++;\n        if(idx == 0) idx = 1;\n        return idx;\n    }\n\n    boolean isOperator(char ch){\n        return \"*/+-()\".indexOf(ch) > -1;\n    }\n\n    boolean isOperator(String s){\n        return s.length() == 1 && isOperator(s.charAt(0));\n    }\n\n    int getRank(String str){\n        return isOperator(str) ? op.get(str) : 0;\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int calculate(String str){\n\t\tStringBuilder ans = new StringBuilder(str);\n\t\twhile( true ){\n\t\t\tStringBuilder temp = new StringBuilder();\n\t\t\tint key = 0;\n\t\t\tint before = -1;\n\t\t\tint after = ans.length();\n\t\t\tfor(int i = 0; i < ans.length(); i++){\n\t\t\t\tif( !Character.isDigit(ans.charAt(i)) ){\n\t\t\t\t\tif( ans.charAt(i) == '*' || ans.charAt(i) == '/' ){\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if( key == 0 ){\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tSystem.out.println(\"before = \" + before + \", key = \" + key + \", after = \" + after);\n\t\t\tif( key == 0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = key-1; i > 0; i--){\n\t\t\t\tif( !Character.isDigit(ans.charAt(i)) ){\n\t\t\t\t\tbefore = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = key+1; i < ans.length(); i++){\n\t\t\t\tif( !Character.isDigit(ans.charAt(i)) ){\n\t\t\t\t\tafter = i;\n\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp.append(ans.toString().substring(0, before+1));\n\t\t\tint x = Integer.parseInt(ans.toString().substring(before+1, key));\n\t\t\tint y = Integer.parseInt(ans.toString().substring(key+1, after));\n\t\t\tswitch( ans.charAt(key) ){\n\t\t\t\tcase '*' : temp.append(x*y); break;\n\t\t\t\tcase '/' : temp.append(x/y); break;\n\t\t\t\tcase '+' : temp.append(x+y); break;\n\t\t\t\tcase '-' : temp.append(x-y); break;\n\t\t\t}\n\t\t\ttemp.append(ans.toString().substring(after));\n\t\t\tans = new StringBuilder(temp);\n\t\t}\n\t\treturn Integer.parseInt(ans.toString());\n\t\t\n\t}\n\t\t\t\t\t\n\tpublic int step(String str){\n\t\tStringBuilder ans = new StringBuilder(str);\n\t\twhile( true ){\n\t\t\tStringBuilder temp = new StringBuilder();\n\t\t\tint n = ans.indexOf(\")\");\n\t\t\tint m = ans.lastIndexOf(\"(\", n);\n\t\t\tif( n < 0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp.append(ans.toString().substring(0, m));\n\t\t\ttemp.append(calculate(ans.toString().substring(m+1, n)));\n\t\t\ttemp.append(ans.toString().substring(n+1, ans.length()));\n\t\t\tans = new StringBuilder(temp);\n\t\t//\tSystem.out.println(ans);\n\t\t}\n\t\treturn calculate(ans.toString());\n\t}\n\tpublic void solve() throws IOException{\n\t\tScanner stdIn = null;\n\t\ttry{\n\t\t\tstdIn = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\twhile( stdIn.hasNext() ){\n\t\t\t\tString str = stdIn.next();\n\t\t\t\tSystem.out.println(step(str));\n\t\t\t}\n\t\t} finally {\n\t\t\tif( stdIn != null ){\n\t\t\t\tstdIn.close();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().solve();\t\t\n\t}\n\t\n/*\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}*/\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tstatic int id;\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tid = 0;\n\t\t\tString[] list = split(sc.nextLine());\n\t\t\tSystem.out.println(calc(list));\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic int calc(String[] list){\n\t\tint value = Integer.parseInt(list[id]);\n\t\twhile(id < list.length-1){\n\t\t\tid++;\n\t\t\tif(list[id].equals(\"*\")){\n\t\t\t\tif(list[id+1].equals(\"(\")){\n\t\t\t\t\tid += 2;\n\t\t\t\t\tvalue *= calc(list);\n\t\t\t\t}else{\n\t\t\t\t\tvalue *= Integer.parseInt(list[++id]);\n\t\t\t\t}\n\t\t\t}else if(list[id].equals(\"/\")){\n\t\t\t\tif(list[id+1].equals(\"(\")){\n\t\t\t\t\tid += 2;\n\t\t\t\t\tvalue /= calc(list);\n\t\t\t\t}else{\n\t\t\t\t\tvalue /= Integer.parseInt(list[++id]);\n\t\t\t\t}\n\t\t\t}else if(list[id].equals(\"+\")){\n\t\t\t\tid++;\n\t\t\t\tif(list[id].equals(\"(\")){\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t\tvalue += calc(list);\n\t\t\t}else if(list[id].equals(\"-\")){\n\t\t\t\tid++;\n\t\t\t\tif(list[id].equals(\"(\")){\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t\tvalue -= calc(list);\n\t\t\t}else if(list[id].equals(\")\")){\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\tstatic String[] split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tString tmp = \"\";\n\t\tint length = s.length();\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(!isInt(s.charAt(i))){\n\t\t\t\tif(!tmp.equals(\"\")){\n\t\t\t\t\tlist.add(tmp);\n\t\t\t\t}\n\t\t\t\tlist.add(String.valueOf(s.charAt(i)));\n\t\t\t\ttmp = \"\";\n\t\t\t}else{\n\t\t\t\ttmp += s.charAt(i);\n\t\t\t}\n\t\t}\n\t\tString[] array = null;\n\t\treturn (String[])list.toArray(new String[list.size()]);\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        \n        int t = sc.nextInt();\n        while(t-->0){\n            String line = sc.next();\n            \n            int ans = calc(line.substring(0,line.length()-1));\n            System.out.println(ans);\n        }\n    }\n    \n    int calc(String line){\n        \n        String newLine = \"\";\n        for(int i=0; i<line.length(); i++){\n            if(line.charAt(i)=='('){\n                int idx = i;\n                int left = 1;\n                int right = 0;\n                while(right!=left){\n                    idx++;\n                    if(line.charAt(idx)==')'){\n                        right++;\n                    }else if(line.charAt(idx)=='('){\n                        left++;\n                    }\n                }\n                newLine += calc(line.substring(i+1,idx));\n                i = idx;\n            }else newLine += line.charAt(i);\n        }\n        \n        ArrayList<Integer> list = new ArrayList<Integer>();\n        ArrayList<Character> list2 = new ArrayList<Character>();\n        String tmp = \"\";\n        for(int i=0; i<newLine.length(); i++){\n            char c = newLine.charAt(i);\n            if(c=='*' || c=='/' || c=='+' || c=='-'){\n                list.add(Integer.parseInt(tmp));\n                tmp = \"\";\n                list2.add(c);\n            }else{\n                tmp += c;\n            }\n        }\n        list.add(Integer.parseInt(tmp));\n        \n        for(int i=0; i<list2.size(); i++){\n            char c = list2.get(i);\n            if(c=='*' || c=='/'){\n                int n1 = list.get(i);\n                int n2 = list.get(i+1);\n                if(c=='*'){\n                    list.set(i, n1*n2);\n                }else{\n                    list.set(i, n1/n2);\n                }\n                list.remove(i+1);\n                list2.remove(i);\n                i--;\n            }\n        }\n        \n        int ans = list.get(0);\n        for(int i=0; i<list2.size(); i++){\n            char c = list2.get(i);\n            if(c=='+'){\n                ans += list.get(i+1);\n            }else{\n                ans -= list.get(i+1);\n            }\n        }\n        \n        return ans;\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    Scanner in = new Scanner(System.in);\n\n    HashMap<String, Integer> op = new HashMap<String, Integer>(){{\n        put(\"*\", 1); put(\"/\", 1); put(\"%\", 1);\n        put(\"+\", 2); put(\"-\", 2);\n        put(\"(\", 3); put(\")\", 3);\n    }};\n\n    void solve(){\n        int n = in.nextInt(); in.nextLine();\n        for(int i = 0; i < n; i++){\n            ArrayDeque<String> q = toRevPolish(in.nextLine());\n            System.out.println(calc(q));\n            // while(q.size() > 0){\n            //     System.out.println(q.pop());\n            // }\n        }\n    }\n\n    ArrayDeque<String> toRevPolish(String str){\n        ArrayDeque<String> p = new ArrayDeque<>(), s = new ArrayDeque<>();\n        str = str.substring(0, str.length() - 1);\n\n        while(str.length() > 0){\n            int idx = nextIndex(str);\n            String t = str.substring(0, idx);\n            if(t.equals(\"(\")){\n                s.push(t);\n            }else if(t.equals(\")\")){\n                while(!s.peek().equals(\"(\")){\n                    p.push(s.pop());\n                }\n                s.pop();\n            }else{\n                while(s.size() > 0 && getRank(t) > getRank(s.peek())){\n                    p.push(s.pop());\n                }\n                s.push(t);\n            }\n            str = str.substring(idx);\n        }\n\n        while(p.size() > 0){\n            s.push(p.pop());\n        }\n\n        return s;\n    }\n\n    int calc(ArrayDeque<String> q){\n        Deque<Integer> t = new ArrayDeque<>();\n\n        while(q.size() > 0){\n            String s = q.pop();\n            if(isOperator(s)){\n                int a = t.pop(), b = t.pop();\n                switch(s){\n                    case \"+\": t.push(b + a); break;\n                    case \"-\": t.push(b - a); break;\n                    case \"*\": t.push(b * a); break;\n                    case \"/\": t.push(b / a); break;\n                    case \"%\": t.push(b % a); break;\n                }\n            }else{\n                t.push(Integer.parseInt(s));\n            }\n           \n        }\n\n        return t.pop();\n    }\n\n    int nextIndex(String str){\n        int idx = 0;\n        while(idx < str.length() && !isOperator(str.charAt(idx))) idx++;\n        if(idx == 0) idx = 1;\n        return idx;\n    }\n\n    boolean isOperator(char ch){\n        return \"*/%+-()\".indexOf(ch) > -1;\n    }\n\n    boolean isOperator(String s){\n        return s.length() == 1 && isOperator(s.charAt(0));\n    }\n\n    int getRank(String str){\n        return isOperator(str) ? op.get(str) : 0;\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();    \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tString s = sc.nextLine();\n\t\t\ts = s.substring(0, s.length()-1);\n\t\t\tSystem.out.println(calc(s));\n\t\t}\n\n\t}\n\tstatic String calc(String s){\n\t\tArrayList<String> list = split(\"(\"+s+\")\");\n\t\tint index1 = index1(list);\n\t\twhile(index1 != -1){\n\t\t\tint index2 = index2(list, index1);\n\t\t\tint indexOfm = indexOf(\"*\", list, index2, index1);\n\t\t\tint indexOfd = indexOf(\"/\", list, index2, index1);\n\t\t\tint indexOf = -1;\n\t\t\tif(indexOfm == -1){\n\t\t\t\tindexOf = indexOfd;\n\t\t\t}else if(indexOfd == -1){\n\t\t\t\tindexOf = indexOfm;\n\t\t\t}else{\n\t\t\t\tindexOf = (indexOfm < indexOfd) ? indexOfm : indexOfd;\n\t\t\t}\n\t\t\twhile(indexOf != -1){\n\t\t\t\tlong a,b,c;\n\t\t\t\ta = Long.parseLong((String)list.get(indexOf-1));\n\t\t\t\tb = Long.parseLong((String)list.get(indexOf+1));\n\t\t\t\tif(indexOfd == indexOf){\n\t\t\t\t\tc = a/b;\n\t\t\t\t}else{\n\t\t\t\t\tc = a*b;\n\t\t\t\t}\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOfm = indexOf(\"*\", list, index2, index1);\n\t\t\t\tindexOfd = indexOf(\"/\", list, index2, index1);\n\t\t\t\tif(indexOfm == -1){\n\t\t\t\t\tindexOf = indexOfd;\n\t\t\t\t}else if(indexOfd == -1){\n\t\t\t\t\tindexOf = indexOfm;\n\t\t\t\t}else{\n\t\t\t\t\tindexOf = (indexOfm < indexOfd) ? indexOfm : indexOfd;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tlong a,b,c;\n\t\t\t\ta = Long.parseLong((String)list.get(indexOf-1));\n\t\t\t\tb = Long.parseLong((String)list.get(indexOf+1));\n\t\t\t\tc = a+b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tlong a,b,c;\n\t\t\t\ta = Long.parseLong((String)list.get(indexOf-1));\n\t\t\t\tb = Long.parseLong((String)list.get(indexOf+1));\n\t\t\t\tc = a-b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\t}\n\t\t\tlist.remove(index1);\n\t\t\tlist.remove(index2);\n\t\t\tindex1 = index1(list);\n\t\t}\n\t\treturn (String)list.get(0);\n\t}\n\t//)ÌCfbNX\n\tstatic int index1(ArrayList<String> list){\n\t\tfor(int i = 0 ; i < list.size() ; i++){\n\t\t\tif(((String)list.get(i)).equals(\")\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//)ÌèOÌ(ÌCfbNX\n\tstatic int index2(ArrayList<String> list, int index1){\n\t\tfor(int i = index1-1; i >= 0 ; i--){\n\t\t\tif(((String)list.get(i)).equals(\"(\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//*,/,+,-ÌCfbNX\n\tstatic int indexOf(String s, ArrayList<String> list, int index2, int index1){\n\t\tfor(int i = index2+1; i < index1; i++){\n\t\t\tif(((String)list.get(i)).equals(s)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic ArrayList<String> split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile(s.length() > 0){\n\t\t\tif(isInt(s.charAt(0))){\n\t\t\t\tint i = 0;\n\t\t\t\tString _s = \"\";\n\t\t\t\twhile(isInt(s.charAt(i))){\n\t\t\t\t\t_s += String.valueOf(s.charAt(i));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlist.add(_s);\n\t\t\t\tif(i == s.length()){\n\t\t\t\t\ts = \"\";\n\t\t\t\t}else{\n\t\t\t\t\ts = s.substring(i, s.length());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlist.add(String.valueOf(s.charAt(0)));\n\t\t\t\ts = s.substring(1, s.length());\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint dataset = sc.nextInt();\n\twhile(dataset-->0){\n\t    in = sc.next().toCharArray();\n\t    System.out.println(expr(0, in.length-1));\n\t}\n    }\n\n    int expr(int l, int r){\n\tint depth = 0;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='(') depth++;\n\t    else if(in[i]==')') depth--;\n\n\t    if(depth!=0) continue;\n\t    if(in[i]=='+'){\n\t\tint nn = expr(l, i) + expr(i+1, r);\n\t\treturn nn;\n\t    }else if(in[i]=='-'){\n\t\tint nn = expr(l, i) - expr(i+1, r);\n\t\treturn nn;\n\t    }\n\t}\n\n\tint res = 0;\n\tint enzan = 2; // 0:+ , 1:- , 2:nothing\n\tint left = -1, right = -1;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='('){\n\t\tdepth++;\n\t\tif(left==-1){\n\t\t    left = i;\n\t\t    right = i;\n\t\t}\n\t    }else if(in[i]==')'){\n\t\tdepth--;\n\t\tif(depth==0){\n\t\t    if(enzan==0){\n\t\t\tres *= expr(left+1, i);\n\t\t    }\n\t\t    if(enzan==1) res /= expr(left+1, i);\n\t\t    if(enzan==2) res = expr(left+1, i);\n\t\t    left = right = -1;\n\t\t}\n\t    }else if(depth==0 && Character.isDigit(in[i])){\n\t\tif(enzan==0) res *= digit(i);\n\t\tif(enzan==1) res /= digit(i);\n\t\tif(enzan==2) res = digit(i);\n\t\twhile(i+1<in.length-1 && Character.isDigit(in[i+1])){\n\t\t    i++;\n\t\t}\n\t    }else if(depth==0 && in[i]=='*' || in[i]=='/'){\n\t\tif(in[i]=='*') enzan = 0;\n\t\telse enzan = 1;\n\t    }\n\t}\n\n\treturn res;\n    }\n\n    int digit(int p){\n\tint res = 0, l = p;\n\twhile(p<in.length-1 && Character.isDigit(in[p])) p++;\n\tfor(int i=l; i<p; i++)\n\t    res += (in[i]-'0') * (int)Math.pow(10, p-i-1);\n\treturn res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Smart Calculator\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\t//skip first line\n\t\tbr.readLine();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tDeque<String> queue = new ArrayDeque<>();\n\t\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\t\tchar _c = 0;\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tif (!stack.isEmpty()) {\n\t\t\t\t\t\t\twhile (stack.peek() == '*' || stack.peek() == '/') {\n\t\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '/':\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\t\twhile (stack.peek() != '(') {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ('0' <= _c && _c <= '9') {\n\t\t\t\t\t\t\tString s = queue.pollLast();\n\t\t\t\t\t\t\tqueue.offer(s + c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(c));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_c = c;\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tDeque<Integer> ans = new ArrayDeque<>();\n\t\t\tfor (String s : queue) {\n\t\t\t\tif (\"+-*/\".indexOf(s) != -1) {\n\t\t\t\t\tint a, b;\n\t\t\t\t\tb = ans.pop();\n\t\t\t\t\ta = ans.pop();\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\t\tans.push(a + b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\tans.push(a - b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\tans.push(a * b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tans.push(a / b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tans.push(parseInt(s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.peek());\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n//\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=fact();\n\t\t\telse if(c=='/')r/=fact();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn -fact();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn fact();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    String dummy = scanner.nextLine();\n    while (scanner.hasNext()) {\n      String line = scanner.nextLine();\n      Deque<String> ou = new ArrayDeque<String>();\n      Deque<String> op = new ArrayDeque<String>();\n      for (int ii = 0; ii < line.length(); ii++) {\n        Character pp = line.charAt(ii);\n        String p = pp.toString();\n        if (p.equals(\"=\")) {\n          while (!op.isEmpty()) {\n            ou.addLast(op.removeLast());\n          }\n          break;\n        } else if (p.equals(\"+\") || p.equals(\"-\")) {\n          while (!op.isEmpty()) {\n            if (op.getLast().equals(\"(\")) {\n              break;\n            }\n            ou.addLast(op.removeLast());\n          }\n          op.addLast(p);\n        } else if (p.equals(\"*\") || p.equals(\"/\") || p.equals(\"(\")) {\n          op.addLast(p);\n        } else if (p.equals(\")\")) {\n          for (;;) {\n            if (op.isEmpty()) {\n              break;\n            }\n            String work = op.removeLast();\n            if (work.equals(\"(\")) {\n              break;\n            }\n            ou.addLast(work);\n          }\n        } else {\n          ou.addLast(p);\n        }\n//System.out.println(ou.toString());\n//System.out.println(op.toString());\n      }\n//System.out.println(ou.toString());\n//System.out.println(op.toString());\n      Deque<Integer> num = new ArrayDeque<Integer>();\n      while (!ou.isEmpty()) {\n        String p = ou.removeFirst();\n        if (p.equals(\"+\")) {\n          num.addLast(num.removeLast() + num.removeLast());\n        } else if (p.equals(\"-\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b - a);\n        } else if (p.equals(\"*\")) {\n          num.addLast(num.removeLast() * num.removeLast());\n        } else if (p.equals(\"/\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b / a);\n        } else {\n          num.addLast(Integer.parseInt(p));\n        }\n      }\n      out += num.removeLast() + \"\\n\";\n    }\n    System.out.print(out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Map<String, Integer> opPriority = new HashMap<String, Integer>(){\n\t\t{\n\t\t\tput(\"+\", 2);\n\t\t\tput(\"-\", 2);\n\t\t\tput(\"*\", 3);\n\t\t\tput(\"/\", 3);\n\t\t}\n\t};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString s = sc.next();\n\t\t\tList<String> list = make(s);\n\t\t\tDeque<Integer> stackNum = new ArrayDeque<Integer>();\n\t\t\tDeque<String> stackOp = new ArrayDeque<String>();\n\t\t\tfor(String t : list) {\n\t\t\t\tif(t.equals(\"=\")) break;\n\t\t\t\tif(t.matches(\"\\\\d+\")) {\n\t\t\t\t\tstackNum.addFirst(Integer.parseInt(t));\n\t\t\t\t}else if(opPriority.containsKey(t)){\n\t\t\t\t\twhile(stackOp.size() > 0) {\n\t\t\t\t\t\tString op = stackOp.removeFirst();\n\t\t\t\t\t\tif(opPriority.containsKey(op)) {\n\t\t\t\t\t\t\tif(opPriority.get(t) <= opPriority.get(op)) {\n\t\t\t\t\t\t\t\tint v2 = stackNum.removeFirst();\n\t\t\t\t\t\t\t\tint v1 = stackNum.removeFirst();\n\t\t\t\t\t\t\t\tstackNum.addFirst(calc(op, v1, v2));\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tstackOp.addFirst(op);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tstackOp.addFirst(op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstackOp.addFirst(t);\n\t\t\t\t}else if(t.equals(\"(\")){\n\t\t\t\t\tstackOp.addFirst(t);\n\t\t\t\t}else if(t.equals(\")\")){\n\t\t\t\t\twhile(stackOp.size() > 0){\n\t\t\t\t\t\tString op = stackOp.removeFirst();\n\t\t\t\t\t\tif(op.equals(\"(\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tint v2 = stackNum.removeFirst();\n\t\t\t\t\t\t\tint v1 = stackNum.removeFirst();\n\t\t\t\t\t\t\tstackNum.addFirst(calc(op, v1, v2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(stackOp.size() > 0) {\n\t\t\t\tString op = stackOp.removeFirst();\n\t\t\t\tif(opPriority.containsKey(op)) {\n\t\t\t\t\tint v2 = stackNum.removeFirst();\n\t\t\t\t\tint v1 = stackNum.removeFirst();\n\t\t\t\t\tstackNum.addFirst(calc(op, v1, v2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(stackNum.removeFirst());\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic int calc(String op, int v1, int v2) {\n\t\tif(op.equals(\"+\")) {\n\t\t\treturn v1 + v2;\n\t\t}else if(op.equals(\"-\")) {\n\t\t\treturn v1 - v2;\n\t\t}else if(op.equals(\"*\")) {\n\t\t\treturn v1 * v2;\n\t\t}else if(op.equals(\"/\")){\n\t\t\treturn v1 / v2;\n\t\t}else {\n\t\t\treturn 0;\n\t\t}\n\t}\n \tstatic List<String> make(String s){\n\t\tList<String> list = new ArrayList<String>();\n\t\tint l = s.length();\n\t\tint idx = 0;\n\t\twhile(idx < l) {\n\t\t\tchar c = s.charAt(idx);\n\t\t\tif(c == '=') {\n\t\t\t\tlist.add(\"=\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')') {\n\t\t\t\tlist.add(String.valueOf(c));\n\t\t\t\tidx++;\n\t\t\t}else {\n\t\t\t\tint begin = idx;\n\t\t\t\tchar t = s.charAt(idx);\n\t\t\t\twhile(t >= '0' && t <= '9') {\n\t\t\t\t\tidx++;\n\t\t\t\t\tt = s.charAt(idx);\n\t\t\t\t}\n\t\t\t\tlist.add(s.substring(begin, idx));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\t\n\tprivate char[] e;\n\tprivate int p;\n\n\tpublic int number() {\n\t\tint res = 0;\n\t\tif (e[p] == '(') {\n\t\t\t++p;\n\t\t\tres = expression();\n\t\t\t++p;\n\t\t} else {\n\t\t\tfor (; Character.isDigit(e[p]); ++p) {\n\t\t\t\tres = res * 10 + (e[p] - '0');\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic int factor() {\n\t\tint res = number();\n\t\tfor (;;) {\n\t\t\tif (e[p] == '*') {\n\t\t\t\t++p;\n\t\t\t\tres *= number();\n\t\t\t} else if (e[p] == '/') {\n\t\t\t\t++p;\n\t\t\t\tres /= number();\n\t\t\t} else break ;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic int expression() {\n\t\tint res = factor();\n\t\tfor (;;) {\n\t\t\tif (e[p] == '+') {\n\t\t\t\t++p;\n\t\t\t\tres += factor();\n\t\t\t} else if (e[p] == '-') {\n\t\t\t\t++p;\n\t\t\t\tres -= factor();\n\t\t\t} else break ;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run(java.util.Scanner sc, java.io.PrintStream out) {\n\t\tfinal int n = sc.nextInt();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\te = sc.next().toCharArray();\n\t\t\tp = 0;\n\t\t\tout.println(expression());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry (java.util.Scanner sc = new java.util.Scanner(System.in)) {\n\t\t\t(new Main()).run(sc, System.out);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=term();\n\t\t\telse if(c=='/')r/=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn s[id]=='('?-exp():-term();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn s[id]=='('?exp():-term();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tString input_str = br.readLine();\n\t\t\t\tchar[] line = new char[101];\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t    for(int i = left; i <= right; ){\n\t        if(line[i] == '(')depth++;\n\t        else if(line[i] == ')')depth--;\n\n\t        if(depth != 0){\n\t            i++;\n\t        }else if(line[i] != '+' && line[i] != '-'){\n\t            i++;\n\t        }else{\n\t            if(line[i] == '+'){\n\t                Q.add(i);\n\t                i++;\n\t            }else{ //line[i] == '-'\n\t                if((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t                    Q.add(i);\n\t                }\n\t                while(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t            }\n\t        }\n\t    }\n\n\t    if(Q.isEmpty()){ //深さ0の+-がない\n\t        return calc_T(line,left,right);\n\t    }\n\n\t    int tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t    if(tmp == BIG_NUM)return BIG_NUM;\n\n\t    while(!Q.isEmpty()){\n\t        int loc = Q.peek();\n\t        Q.poll();\n\n\t        if(Q.isEmpty()){\n\t            tmp_right = calc_T(line,loc+1,right);\n\t        }else{\n\t            tmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t        }\n\n\t        if(tmp_right == BIG_NUM){\n\t            return BIG_NUM;\n\t        }\n\n\t        if(line[loc] == '+'){\n\t            tmp += tmp_right;\n\t        }else{\n\t            tmp -= tmp_right;\n\t        }\n\t    }\n\n\t    return tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tstatic int LastIndexOf(String e,char c,char c2) {\n\t\tfor(int i=e.length()-1; i>0; i--) {\n\t\t\tint nest = 0;\n\t\t\tif(e.charAt(i) == ')') {\n\t\t\t\tnest++;\n\t\t\t}if(e.charAt(i) == '(') {\n\t\t\t\tnest--;\n\t\t\t}\n\t\t\tif((c == e.charAt(i) || c2 == e.charAt(i)) && nest == 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tstatic int calc(String e) {\n\t\tint pos = LastIndexOf(e,'+','-');\n\t\tif(pos != -1) {\n\t\t\tif(e.charAt(pos) == '+') {\n\t\t\t\treturn calc(e.substring(0,pos))+calc(e.substring(pos+1));\n\t\t\t}else if(e.charAt(pos) == '-'){\n\t\t\t\treturn calc(e.substring(0,pos))-calc(e.substring(pos+1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpos = LastIndexOf(e,'*','/');\n\t\tif(pos != -1) {\n\t\t\tif(e.charAt(pos) == '*') {\n\t\t\t\treturn calc(e.substring(0,pos))*calc(e.substring(pos+1));\n\t\t\t}else if(e.charAt(pos) == '/'){\n\t\t\t\treturn calc(e.substring(0,pos))/calc(e.substring(pos+1));\n\t\t\t}\n\t\t}\n\n\t\tif(e.startsWith(\"(\")){\n\t\t\t\treturn calc(e.substring(1,e.length()-1));\n\t\t}else{\n\t\t\treturn Integer.parseInt(e);\t\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\t\n\t\t\tSystem.out.println(calc(\"1+(2+3)\"));\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n\t\t\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    String dummy = scanner.nextLine();\n    while (scanner.hasNext()) {\n      String line = scanner.nextLine();\n      Deque<String> ou = new ArrayDeque<String>();\n      Deque<String> op = new ArrayDeque<String>();\n      for (int ii = 0; ii < line.length(); ii++) {\n        Character pp = line.charAt(ii);\n        String p = pp.toString();\n        if (p.equals(\"=\")) {\n          while (!op.isEmpty()) {\n            ou.addLast(op.removeLast());\n          }\n          break;\n        } else if (p.equals(\"+\") || p.equals(\"-\")) {\n          while (!op.isEmpty()) {\n            if (op.getLast().equals(\"(\")) {\n              break;\n            }\n            ou.addLast(op.removeLast());\n          }\n          op.addLast(p);\n        } else if (p.equals(\"*\") || p.equals(\"/\") || p.equals(\"(\")) {\n          op.addLast(p);\n        } else if (p.equals(\")\")) {\n          for (;;) {\n            if (op.isEmpty()) {\n              break;\n            }\n            String work = op.removeLast();\n            if (work.equals(\"(\")) {\n              break;\n            }\n            ou.addLast(work);\n          }\n        } else {\n          ou.addLast(p);\n        }\n//System.out.println(ou.toString());\n//System.out.println(op.toString());\n      }\n//System.out.println(ou.toString());\n//System.out.println(op.toString());\n      Deque<Integer> num = new ArrayDeque<Integer>();\n      while (!ou.isEmpty()) {\n        String p = ou.removeFirst();\n        if (p.equals(\"+\")) {\n          num.addLast(num.removeLast() + num.removeLast());\n        } else if (p.equals(\"-\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b - a);\n        } else if (p.equals(\"*\")) {\n          num.addLast(num.removeLast() * num.removeLast());\n        } else if (p.equals(\"/\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b / a);\n        } else {\n          num.addLast(Integer.parseInt(p));\n        }\n      }\n      out += num.removeLast() + \"\\n\";\n    }\n    System.out.print(out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tenum ope {\n\n\t\tadd, sub, mul, div;\n\n\t}\n\n\n\n\tLinkedList<String> tokenize(String str) {\n\n\t\tString token = \"\";\n\n\t\tLinkedList<String> ret = new LinkedList<String>();\n\n\t\tString sp = \"+-*/()=\";\n\n\t\tfor (char c : str.toCharArray()) {\n\n\t\t\tif (Character.isDigit(c)) {\n\n\t\t\t\ttoken += c;\n\n\t\t\t} else {\n\n\t\t\t\tif (sp.indexOf(c) != -1) {\n\n\t\t\t\t\tif (token.length() != 0)\n\n\t\t\t\t\t\tret.addLast(token);\n\n\t\t\t\t\tret.addLast(Character.toString(c));\n\n\t\t\t\t\ttoken = \"\";\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tclass evTree {\n\n\t\tope o;\n\n\t\tString s;\n\n\t\tevTree left = null;\n\n\t\tevTree right = null;\n\n\t\tint val = 0;\n\n\n\n\t\tint getVal() {\n\n\t\t\tif (left == null && right == null) {\n\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tif (o == ope.add) {\n\n\t\t\t\t// System.out.println(left.s + \" add \" + right.s);\n\n\t\t\t\treturn left.getVal() + right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.sub) {\n\n\t\t\t\t// System.out.println(left.s + \" sub \" + right.s);\n\n\t\t\t\treturn left.getVal() - right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.mul) {\n\n\t\t\t\t// System.out.println(left.s + \" mul \" + right.s);\n\n\t\t\t\treturn left.getVal() * right.getVal();\n\n\t\t\t}\n\n\t\t\t// if (o == ope.div) {\n\n\t\t\t// System.out.println(left.s + \" div \" + right.s);\n\n\t\t\treturn left.getVal() / right.getVal();\n\n\t\t\t// }\n\n\t\t}\n\n\n\n\t\tboolean evTrimable(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\"))\n\n\t\t\t\treturn true;\n\n\t\t\tif (t.getFirst().equals(\"(\") && t.getLast().equals(\")\")) {\n\n\t\t\t\tint depth = 0;\n\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (String token : t) {\n\n\t\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\t\tdepth++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\t\tdepth--;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (depth == 0) {\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn count == 1;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\n\n\t\tvoid evTrim(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\")) {\n\n\t\t\t\tt.removeLast();\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tt.removeFirst();\n\n\t\t\tt.removeLast();\n\n\t\t\treturn;\n\n\t\t}\n\n\n\n\t\tString tts(LinkedList<String> t) {\n\n\t\t\tString ret = \"\";\n\n\t\t\tfor (String s : t) {\n\n\t\t\t\tret += s;\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t}\n\n\n\n\t\tevTree(LinkedList<String> t) {\n\n\t\t\ts = tts(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tfor (; evTrimable(t);)\n\n\t\t\t\tevTrim(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tint[] p = new int[t.size()];\n\n\t\t\tint depth = 1;\n\n\t\t\tint min = 100;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tString token = t.get(i);\n\n\t\t\t\tif (Character.isDigit(token.toCharArray()[0]))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\tdepth += 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\tdepth -= 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"+\") || token.equals(\"-\")) {\n\n\t\t\t\t\tp[i] = depth;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"*\") || token.equals(\"/\")) {\n\n\t\t\t\t\tp[i] = depth + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint z = 0;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tif (p[i] == 0)\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p[i] < min) {\n\n\t\t\t\t\tmin = p[i];\n\n\t\t\t\t\tz = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tString token = t.get(z);\n\n\t\t\tif (token.equals(\"+\")) {\n\n\t\t\t\tthis.o = ope.add;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"-\")) {\n\n\t\t\t\tthis.o = ope.sub;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"*\")) {\n\n\t\t\t\tthis.o = ope.mul;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"/\")) {\n\n\t\t\t\tthis.o = ope.div;\n\n\t\t\t}\n\n\t\t\tLinkedList<String> tl = new LinkedList<String>(t.subList(0, z));\n\n\t\t\tthis.left = new evTree(tl);\n\n\t\t\tLinkedList<String> tr = new LinkedList<String>(t.subList(z + 1,\n\n\t\t\t\t\tt.size()));\n\n\t\t\tthis.right = new evTree(tr);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tint n = Integer.valueOf(sc.nextLine());\n\n\t\tfor (; n-- > 0;) {\n\n\t\t\tLinkedList<String> token = tokenize(sc.nextLine());\n\n\t\t\t/*\n\n\t\t\t * for (String t : token) { System.out.println(t); }\n\n\t\t\t */\n\n\t\t\tSystem.out.println(new evTree(token).getVal());\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tl = sc.next(); p = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\t\n\tString l; int p;\n\tchar next() {\n\t\treturn l.charAt(p++);\n\t}\n\t\n\tString exp() {\n\t\tBigDecimal v1 = new BigDecimal(term());\n\t\tchar c = next();\n\t\tfor( ;c != '=' && c != ')'; c = next() ) { \n\t\t\tBigDecimal v2 = new BigDecimal(term());\n\t\t\tif( c == '+' ) v1 = v1.add(v2);\n\t\t\telse v1 = v1.subtract(v2);\n\t\t}\n\t\tp--; \n\t\treturn v1.toString();\n\t}\n\t\n\tString term() {\n\t\tBigDecimal v1 = new BigDecimal(val());\n\t\tchar c = next();\n\t\tfor( ;c != '=' && c != '+' && c != '-' && c != ')';c=next() ) {\n\t\t\tBigDecimal v2 = new BigDecimal(val());\n\t\t\tif( c == '*' ) v1 = v1.multiply(v2);\n\t\t\telse v1 = v1.divideToIntegralValue(v2);\n\t\t}\n\t\tp--; \n\t\treturn v1.toString();\n\t}\n\t\n\tString val() {\n\t\tchar c = next();\n\t\tif( c == '(' ) {BigDecimal v = new BigDecimal(exp()); p++; return v.toString();}\n\t\tString v = \"\" + c;\n\t\tfor(c = next();'0'<=c && c<='9';c=next()) v += c;\n\t\tp--;\n\t\treturn v;\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<BigInteger> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<BigInteger>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tBigInteger n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = new BigInteger(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a.add(b));\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a.subtract(b));\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a.multiply(b));\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a.divide(b));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getResult(){\n\t\tcalculate();\n\t\treturn stack.pop().toString();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\tprivate boolean[] minusFlag;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tminusFlag = new boolean[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\tminusFlag[current] = true;\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tminusFlag[current] = false;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if(tmp == '-'){\n\t\t\t\t\tif(!minusFlag[current]){\n\t\t\t\t\t\trpn += tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t\t}\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t}else if(tmp == '+'){\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\tstatic int cur;\n\tstatic String S;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint k = sc.nextInt();\n\t\tfor (int l=0; l<k; l++){\n\t\t\tS = sc.next();\n\t\t\tcur = 0;\n\t\t\tint a = parse();\n\t\t\tassert (cur == S.length());\n\t\t\tSystem.out.println(a);\n\t\t}\n\t}\n\tstatic int parse() {\n\t\treturn expression();\n\t}\n\tstatic int digit(){\n\t\tassert(Character.isDigit(S.charAt(cur)));\n\t\tint n = S.charAt(cur) -'0';\n\t\tcur++;\n\t\treturn n;\n\t}\n\tstatic int number() {\n\t\tint n = digit();\n\t\twhile ((cur < S.length()) && Character.isDigit(S.charAt(cur)))\n\t\t\tn = n*10 + digit();\n\t\treturn n;\n\t}\n\tstatic int expression(){\n\t\tint sum = term();\n\t\twhile (S.charAt(cur) != '='){\n\t\t\tif (S.charAt(cur) == '+'){\n\t\t\t\tcur++;\n\t\t\t\tsum+=term();\n\t\t\t}\n\t\t\telse if (S.charAt(cur)=='-'){\n\t\t\t\tcur++;\n\t\t\t\tsum-=term();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn sum;\n\t}\n\tstatic int factor(){\n\t\tif (S.charAt(cur)!='(') return number();\n\t\tcur++;\n\t\tint n = expression();\n\t\tassert(S.charAt(cur)==')');\n\t\tcur++;\n\t\treturn n;\n\t}\n\tstatic int term(){\n\t\tint a = factor();\n\t\twhile (true) {\n\t\t\tif (S.charAt(cur) == '*'){\n\t\t\t\tcur++;\n\t\t\t\ta*=factor();\n\t\t\t}\n\t\t\telse if (S.charAt(cur) == '/'){\n\t\t\t\tcur++;\n\t\t\t\ta/=factor();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\n\t\tint size = Integer.parseInt(line);\n\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint a = SC(line);\n\t\t\tans.add(a);\n\t\t}\n\n\t\tfor(int i=0; i<ans.size(); i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\n\tpublic int SC(String line){\n\t\tList<String> eq = new ArrayList<String>();\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tString str = line.substring(count, count+1);\n\t\t\tif(str.equals(\"=\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq.add(str);\n\t\t\tcount++;\n\t\t}\n\n\t\tcount = 0;\n\t\twhile(count < eq.size()-1){\n\t\t\tif(isNumber(eq.get(count)) && isNumber(eq.get(count+1))){\n\t\t\t\tString dst = eq.get(count) + eq.get(count+1);\n\t\t\t\teq.add(count+2, dst);\n\t\t\t\teq.remove(count);\n\t\t\t\teq.remove(count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\n\t\twhile(eq.size() != 1){\n\t\t\t//for(int i=0; i<eq.size(); i++){\n\t\t\t//\tSystem.out.print(eq.get(i));\n\t\t\t//}\n\t\t\t//System.out.println();\n\n\t\t\t//ツ環古環づ個計ツ算\n\t\t\tint bra_count = 0;\n\t\t\tint n = eq.indexOf(\"(\");\n\t\t\tif(n != -1){\n\t\t\t\tfor(int i=n+1; i<eq.size(); i++){\n\t\t\t\t\tif(eq.get(i).equals(\")\") && bra_count == 0){\n\t\t\t\t\t\teq = RangeReplace(eq, n, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\"(\")){\n\t\t\t\t\t\tbra_count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\")\")){\n\t\t\t\t\t\tbra_count--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ掛ツつッツ算ツ環づィツ算\n\t\t\tn = eq.indexOf(\"*\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) * Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = eq.indexOf(\"/\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) / Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ堕ォツつオツ算ツ暗クツつォツ算\n\t\t\tn = eq.indexOf(\"+\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) + Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = eq.indexOf(\"-\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) - Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn Integer.parseInt(eq.get(0));\n\t}\n\n\tpublic List<String> RangeReplace(List<String> eq, int s, int e){\n\t\tString part = \"\";\n\n\t\tfor(int i=s+1; i<e; i++){\n\t\t\tpart += eq.get(i);\n\t\t}\n\n\t\tpart = Integer.toString(SC(part+\"=\"));\n\n\t\teq.add(e+1, part);\n\n\t\tfor(int i=s; i<=e; i++){\n\t\t\teq.remove(s);\n\t\t}\n\n\t\treturn eq;\n\t}\n\n\tpublic boolean isNumber(String s){\n\t\ttry{\n\t\t\tint n = Integer.parseInt(s);\n\t\t}catch(NumberFormatException err){\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//Volume1-0109\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\t//declare\n\tprivate static final int                   NUM   = 1,\n\t\t\t                                   OPE1  = 2,\n\t\t\t                                   OPE2  = 3,\n\t\t\t                                   SPRN  = 4,\n\t\t\t                                   EPRN  = 5,\n\t\t\t                                   EQ    = 6;\n\tprivate static final String                regex = \"([0-9]+|\\\\+|-|\\\\*|/|\\\\(|\\\\)|=)(.*)\";\n\tprivate static       ArrayList<String>     t     = new ArrayList<String>(),\n\t\t\t                                   rpn   = new ArrayList<String>();\n\tprivate static       ArrayDeque<String>    stack = new ArrayDeque<String>();\n\tprivate static       ArrayDeque<Integer>   ans   = new ArrayDeque<Integer>();\n\n\n\tpublic static void main(String[] args){\n\n\t\tMatcher m;\n \t\tString  s;\n \t\tint     n;\n\n\t\t//initialize\n\t\tPattern token = Pattern.compile(regex);\n\n\t\t//input\n        Scanner sc = new Scanner(System.in);\n        n = Integer.parseInt(sc.nextLine());\n        while(n-- > 0){\n        \tt.clear();\n        \trpn.clear();\n        \tstack.clear();\n        \ts = sc.nextLine();\n        \twhile(s.length() != 0){\n        \t\tm = token.matcher(s);\n        \t\tif(m.find()){\n        \t\t\tt.add(m.group(1));\n        \t\t\ts = m.group(2);\n        \t\t}\n        \t}\n\n        \t//calculate\n        \tchg_notation();\n        \tcalc();\n\n        \t//output\n        \tSystem.out.println(ans.pop());\n        }\n\t}\n\n\tprivate static void calc(){\n\n\t\tint kind,a,b;\n\t\tfor(String tkn:rpn){\n\t\t\tkind = isKind(tkn);\n\t\t\tif(kind == NUM){\n\t\t\t\tans.push(Integer.parseInt(tkn));\n\t\t\t}else if(tkn.equals(\"+\")){\n\t\t\t\tans.push(ans.pop()+ans.pop());\n\t\t\t}else if(tkn.equals(\"-\")){\n\t\t\t\tb = ans.pop();\n\t\t\t\ta = ans.pop();\n\t\t\t\tans.push(a-b);\n\t\t\t}else if(tkn.equals(\"*\")){\n\t\t\t\tans.push(ans.pop()*ans.pop());\n\t\t\t}else if(tkn.equals(\"/\")){\n\t\t\t\tb = ans.pop();\n\t\t\t\ta = ans.pop();\n\t\t\t\tans.push(a/b);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void chg_notation(){\n    \tout:for(String tkn:t){\n    \t\tswitch(isKind(tkn)) {\n    \t\t\tcase NUM  : {rpn.add(tkn);break;}\n    \t\t\tcase OPE1 : {}\n    \t\t\tcase OPE2 : {\n    \t\t\tString top = stack.peek();\n    \t\t\t\tif(top != null && isKind(top) == OPE2){\n    \t\t\t\t\trpn.add(stack.pop());\n    \t\t\t\t}\n    \t\t\t\tstack.push(tkn);\n    \t\t\t\tbreak;\n    \t\t\t}\n        \t    case SPRN :{\n    \t\t\t\tstack.push(tkn);\n    \t\t\t\tbreak;\n        \t    }\n        \t    case EPRN :{\n        \t    \tString e;\n        \t    \twhile(true){\n        \t    \t\te = stack.pop();\n        \t    \t\tif(isKind(e) != SPRN){\n        \t    \t\t\trpn.add(e);\n        \t    \t\t} else {\n        \t    \t\t\tbreak;\n        \t    \t\t}\n        \t    \t}\n        \t    \tbreak;\n        \t    }\n        \t    case EQ : {\n        \t    \tfor(String e:stack){\n        \t    \t\trpn.add(e);\n        \t    \t}\n        \t    \tbreak out;\n        \t    }\n        \t}\n    \t}\n\t}\n\n\tprivate static int isKind(String s){\n\t\tint ret = -1;\n\t\tif     (s.matches(\"[0-9]+\")) {ret = 1;}\n\t\telse if(s.matches(\"(\\\\+|-)\")){ret = 2;}\n\t\telse if(s.matches(\"(\\\\*|/)\")){ret = 3;}\n\t\telse if(s.matches(\"\\\\(\"))    {ret = 4;}\n\t\telse if(s.matches(\"\\\\)\"))    {ret = 5;}\n\t\telse if(s.matches(\"=\"))      {ret = 6;}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<BigInteger> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<BigInteger>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tBigInteger n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = new BigInteger(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a.add(b));\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a.subtract(b));\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a.multiply(b));\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a.divide(b));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getResult(){\n\t\tcalculate();\n\t\treturn stack.pop().toString();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\tprivate boolean[] minusFlag;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tminusFlag = new boolean[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\tminusFlag[current] = true;\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tminusFlag[current] = false;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if(tmp == '-'){\n\t\t\t\t\tif(!minusFlag[current]){\n\t\t\t\t\t\trpn += tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t\t}\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t}else if(tmp == '+'){\n\t\t\t\t\tminusFlag[current] = true;\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// 61706535\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\t\n\tpublic static class Parser {\n\t\tprivate final String str;\n\t\tprivate long ans;\n\t\tprivate int idx = 0;\n\t\tprivate final char[] ex012 = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n\t\tprivate class InvalidExpressionException extends Exception {\n\t\t\tInvalidExpressionException(int idx) {\n\t\t\t\tsuper(\"around input[\" + idx + \"] : \" + \"Invalid expression\");\n\t\t\t}\n\t\t}\n\t\tParser(String str) {\n\t\t\tthis.str = str + \"$\";\n\t\t\ttry {\n\t\t\t\tthis.ans = expr();\n\t\t\t\tif(this.str.charAt(idx) != '$') {\n\t\t\t\t\tthrow new InvalidExpressionException(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(ArithmeticException e) {\n\t\t\t\tSystem.out.println(\"around input[\" + idx + \"] : \" + e.getMessage());\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t\tcatch(InvalidExpressionException e) {\n\t\t\t\tSystem.out.println(e.getMessage());\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t}\n\t\t}\n\t\tlong answer() {\n\t\t\treturn this.ans;\n\t\t}\n\t\tlong expr() throws InvalidExpressionException {\n\t\t\tlong ret = term();\n\t\t\twhile(true) {\n\t\t\t\tchar c = str.charAt(idx);\n\t\t\t\tif(c == '$') {\n\t\t\t\t\treturn ret;\n\t\t\t\t} else if(c == '+') {\n\t\t\t\t\tcheck('+');\n\t\t\t\t\tret = Math.addExact(ret, term());\n\t\t\t\t} else if(c == '-') {\n\t\t\t\t\tcheck('-');\n\t\t\t\t\tret = Math.subtractExact(ret, term());\n\t\t\t\t} else {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong term() throws InvalidExpressionException {\n\t\t\tlong ret = fact();\n\t\t\twhile(true) {\n\t\t\t\tchar c = str.charAt(idx);\n\t\t\t\tif(c == '*') {\n\t\t\t\t\tcheck('*');\n\t\t\t\t\tret = Math.multiplyExact(ret, fact());\n\t\t\t\t} else if(c == '/') {\n\t\t\t\t\tcheck('/');\n\t\t\t\t\tret /= fact();\n\t\t\t\t} else {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong fact() throws InvalidExpressionException {\n\t\t\tchar c = str.charAt(idx);\n\t\t\tif(c == '(') {\n\t\t\t\tcheck('(');\n\t\t\t\tlong ret = expr();\n\t\t\t\tcheck(')');\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\treturn numb();\n\t\t\t}\n\t\t}\n\t\tlong numb() throws InvalidExpressionException {\n\t\t\tlong ret = 0;\n\t\t\tboolean flag = false;\n\t\t\twhile(true) {\n\t\t\t\tchar c = str.charAt(idx);\n\t\t\t\tif('0' <= c && c <= '9') {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tret = Math.multiplyExact(ret, 10);\n\t\t\t\t\t// ret *= 10;\n\t\t\t\t\tret = Math.addExact(ret, Character.getNumericValue(c));\n\t\t\t\t\t// ret += Character.getNumericValue(c);\n\t\t\t\t\tcheck(ex012);\n\t\t\t\t} else {\n\t\t\t\t\tif(!flag) {\n\t\t\t\t\t\tthrow new InvalidExpressionException(idx);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid check(char expected) throws InvalidExpressionException  {\n\t\t\tchar[] ex = {expected};\n\t\t\tcheck(ex);\n\t\t}\n\t\tvoid check(char[] expected) throws InvalidExpressionException {\n\t\t\tchar got = str.charAt(idx);\n\t\t\tfor(char c : expected){\n\t\t\t\tif(got == c) {\n\t\t\t\t\tidx++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new InvalidExpressionException(idx);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\twhile(n > 0) {\n\t\t\tn--;\n\t\t\tString str = scan.next();\n\t\t\tstr = str.substring(0, str.length() - 1);\n\t\t\ttry {\n\t\t\t\tParser parse = new Parser(str);\n\t\t\t\tSystem.out.println(parse.answer());\n\t\t\t}\n\t\t\tcatch(IllegalStateException e) {}\n\t\t\tfinally {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\twhile(n-- > 0){\n\t\t\tp = sc.next().toCharArray();\n\t\t\tParsed ans = expr(0);\n\t\t\tSystem.out.println(ans.val);\n\t\t}\n\t}\n\n\tstatic char[] p;\n\n\tstatic Parsed expr(int idx){\n\t\tParsed r = term(idx);\n\t\twhile(p[r.idx] == '+' || p[r.idx] == '-'){\n\t\t\tchar op = p[r.idx];\n\t\t\tint tmp = r.val;\n\t\t\tr = term(r.idx + 1);\n\t\t\tif(op == '+') r.val = tmp + r.val;\n\t\t\telse r.val = tmp - r.val;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic Parsed term(int idx){\n\t\tParsed r = fact(idx);\n\t\twhile(p[r.idx] == '*' || p[r.idx] == '/'){\n\t\t\tchar op = p[r.idx];\n\t\t\tint tmp = r.val;\n\t\t\tr = fact(r.idx + 1);\n\t\t\tif(op == '*') r.val = tmp * r.val;\n\t\t\telse r.val = tmp / r.val;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic Parsed fact(int idx){\n\t\tif(Character.isDigit(p[idx])){\n\t\t\tint t = p[idx++] - '0';\n\t\t\twhile(Character.isDigit(p[idx]))t = t*10 + p[idx++] - '0';\n\t\t\treturn new Parsed(t,idx);\n\t\t}\n\t\telse if(p[idx] == '('){\n\t\t\tParsed r = expr(idx + 1);\n\t\t\tif(p[r.idx] != ')') return null;\n\t\t\treturn new Parsed(r.val, r.idx + 1);\n\t\t}\n\t\telse return null;\n\t}\n}\n\nclass Parsed{\n\tint val;\n\tint idx;\n\tParsed(int val,int idx){\n\t\tthis.val = val;\n\t\tthis.idx = idx;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint index = 0;\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\twhile (N-- > 0) {\n\t\t\tindex = 0;\n\t\t\tString input = sc.next();\n\t\t\tSystem.out.println(expression(new StringBuilder(input)));\n\t\t}\n\t}\n\n\tint number(StringBuilder sb) {\n\t\tint res = 0;\n\t\twhile (index < sb.length() && Character.isDigit(sb.charAt(index))) {\n\t\t\tres *= 10;\n\t\t\tres += sb.charAt(index) - '0';\n\t\t\tindex++;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint term(StringBuilder sb) {\n\t\tint res = number(sb);\n\t\tfor (; index < sb.length();) {\n\t\t\tif (sb.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tres *= factor(sb);\n\t\t\t} else if (sb.charAt(index) == '/') {\n\t\t\t\tindex++;\n\t\t\t\tres /= factor(sb);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint factor(StringBuilder sb) {\n\t\tint res = 0;\n\t\tif (sb.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tres = expression(sb);\n\t\t\tindex++;\n\t\t} else {\n\t\t\tres = number(sb);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint expression(StringBuilder sb) {\n\t\tint res = term(sb);\n\t\tfor (; index < sb.length();) {\n\t\t\tif (sb.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tres += term(sb);\n\t\t\t} else if (sb.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tres -= term(sb);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\twhile(line[i] == '-')i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tString s;\n\n\tvoid run(){\n\t\tfor(int n=sc.nextInt(); n>0; n--){\n\t\t\ts=sc.next();\n\t\t\tprintln(equation(0).val+\"\");\n\t\t}\n\t}\n\n\tR equation(int p){\n\t\tR r=factor(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='+'||c=='-'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='+')\n\t\t\t\t\tr.val+=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val-=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR factor(int p){\n\t\tR r=term(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='*'||c=='/'){\n\t\t\t\tR q=term(r.p+1);\n\t\t\t\tif(c=='*')\n\t\t\t\t\tr.val*=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val/=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR term(int p){\n\t\tif(s.charAt(p)=='('){\n\t\t\tR r=equation(p+1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t}else{\n\t\t\tlong val=0;\n\t\t\tfor(; Character.isDigit(s.charAt(p)); p++){\n\t\t\t\tval=val*10+(s.charAt(p)-'0');\n\t\t\t}\n\t\t\treturn new R(p, val);\n\t\t}\n\t}\n\n\tclass R{\n\t\tint p;\n\t\tlong val;\n\n\t\tR(int p, long val){\n\t\t\tthis.p=p;\n\t\t\tthis.val=val;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tString s = sc.nextLine();\n\t\t\ts = s.substring(0, s.length()-1);\n\t\t\tSystem.out.println(calc(s));\n\t\t}\n\n\t}\n\tstatic String calc(String s){\n\t\tArrayList<String> list = split(\"(\"+s+\")\");\n\t\tint index1 = index1(list);\n\t\twhile(index1 != -1){\n\t\t\tint index2 = index2(list, index1);\n\t\t\tint indexOfm = indexOf(\"*\", list, index2, index1);\n\t\t\tint indexOfd = indexOf(\"/\", list, index2, index1);\n\t\t\tint indexOf = -1;\n\t\t\tif(indexOfm == -1){\n\t\t\t\tindexOf = indexOfd;\n\t\t\t}else if(indexOfd == -1){\n\t\t\t\tindexOf = indexOfm;\n\t\t\t}else{\n\t\t\t\tindexOf = (indexOfm < indexOfd) ? indexOfm : indexOfd;\n\t\t\t}\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tif(indexOfd == indexOf){\n\t\t\t\t\tc = a/b;\n\t\t\t\t}else{\n\t\t\t\t\tc = a*b;\n\t\t\t\t}\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOfm = indexOf(\"*\", list, index2, index1);\n\t\t\t\tindexOfd = indexOf(\"/\", list, index2, index1);\n\t\t\t\tif(indexOfm == -1){\n\t\t\t\t\tindexOf = indexOfd;\n\t\t\t\t}else if(indexOfd == -1){\n\t\t\t\t\tindexOf = indexOfm;\n\t\t\t\t}else{\n\t\t\t\t\tindexOf = (indexOfm < indexOfd) ? indexOfm : indexOfd;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a+b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a-b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\t}\n\t\t\tlist.remove(index1);\n\t\t\tlist.remove(index2);\n\t\t\tindex1 = index1(list);\n\t\t}\n\t\treturn (String)list.get(0);\n\t}\n\t//)ÌCfbNX\n\tstatic int index1(ArrayList<String> list){\n\t\tfor(int i = 0 ; i < list.size() ; i++){\n\t\t\tif(((String)list.get(i)).equals(\")\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//)ÌèOÌ(ÌCfbNX\n\tstatic int index2(ArrayList<String> list, int index1){\n\t\tfor(int i = index1-1; i >= 0 ; i--){\n\t\t\tif(((String)list.get(i)).equals(\"(\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//*,/,+,-ÌCfbNX\n\tstatic int indexOf(String s, ArrayList<String> list, int index2, int index1){\n\t\tfor(int i = index2+1; i < index1; i++){\n\t\t\tif(((String)list.get(i)).equals(s)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic ArrayList<String> split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile(s.length() > 0){\n\t\t\tif(isInt(s.charAt(0))){\n\t\t\t\tint i = 0;\n\t\t\t\tString _s = \"\";\n\t\t\t\twhile(isInt(s.charAt(i))){\n\t\t\t\t\t_s += String.valueOf(s.charAt(i));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlist.add(_s);\n\t\t\t\tif(i == s.length()){\n\t\t\t\t\ts = \"\";\n\t\t\t\t}else{\n\t\t\t\t\ts = s.substring(i, s.length());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlist.add(String.valueOf(s.charAt(0)));\n\t\t\t\ts = s.substring(1, s.length());\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.lang.Character.Subset;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0109();\n\t}\n\n\tclass AOJ0109{\n\t\tchar[] line;\n\t\tint pos=0;\n\t\tprivate int expr(){\n\t\t\tint ret = term();\n\t\t\twhile(true){\n\t\t\t\tif(pos>=line.length)break;\n\t\t\t\tchar op = line[pos];\n\t\t\t\tif( (op=='+') || (op=='-')){\n\t\t\t\t\tint old = ret;\n\t\t\t\t\t++pos;\n\t\t\t\t\tret = term();\n\t\t\t\t\tif(op=='+')ret=old+ret;\n\t\t\t\t\tif(op=='-')ret=old-ret;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate int term(){\n\t\t\tint ret = fact();\n\t\t\twhile(true){\n\t\t\t\tif(pos>=line.length)return ret;\n\t\t\t\tchar op = line[pos];\t\t\t\n\t\t\t\tif( (op=='*') || (op=='/') ){\n\t\t\t\t\tint old = ret;\n\t\t\t\t\t++pos;\n\t\t\t\t\tret = fact();\n\t\t\t\t\tif(op=='*')ret = old*ret;\n\t\t\t\t\tif(op=='/')ret = old/ret;\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate int fact(){\n\t\t\tif(Character.isDigit(line[pos])){\n\t\t\t\tint ret=line[pos]-'0';\n\t\t\t\t++pos;\n\t\t\t\tif(pos>=line.length)return ret;\n\t\t\t\twhile(Character.isDigit(line[pos])){\n\t\t\t\t\tret=ret*10+(line[pos]-'0');\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}else if(line[pos]=='('){\n\t\t\t\t++pos;\n\t\t\t\tint ret=expr();\n\t\t\t\t++pos; // \")\"\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid doIt(){\n\t\t\tString[] a = in.next().split(\"=\");\n\t\t\tline = a[0].toCharArray();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expr());\n\t\t}\n\n\t\tpublic AOJ0109() {\n\t\t\tint n = in.nextInt();\n\t\t\tfor(int i=0;i<n;i++)doIt();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (5-(6/2/2+50*3/2/3*6/4)/9*2-(6/2/2+50*3/2/3*6)-36)*2-1=\n\nclass Main{\n\tstatic Pattern addsub = Pattern.compile(\"^(.*?)(-?\\\\d+)([+Z])(\\\\d+)(.*)$\");\n\tstatic Pattern muldiv = Pattern.compile(\"^(.*?)(-?\\\\d+)([*/])(\\\\d+)(.*)$\");\n\n\tstatic String process(String s){\n\t//System.out.println(\"---\"+s);\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\t//System.out.println(\"+++\"+s);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next().replaceAll(\"-\",\"Z\");\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[101];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\ts = new char[101];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i]=str.charAt(i);\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\t\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = kagen();\n\t\treturn res;\n\t}\n\tstatic int kagen(){\n\t\tint res = joujo();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\treturn res +term();\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\treturn res -term();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int joujo(){\n\t\tint res =  value();\n\t\t\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\treturn res *term();\n\t\t}\n\t\telse if(s[idx]=='/'){\n\t\t\tidx++;\n\t\t\treturn res /term();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int value(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=term();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\tres = s[idx++]-'0';\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\npublic class Main {\n\tstatic char[] s;\n\tstatic int id ;\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\ts = sc.next().toCharArray();\n\t\t\t\tid = 0;\n\t\t\t\tSystem.out.println(exp());\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic int exp() {\n\t\tint res = term();\n\t\twhile(s[id] == '+' || s[id] == '-') {\n\t\t\tif(s[id] == '+') {\n\t\t\t\tid++;\n\t\t\t\tres += term();\n\t\t\t}else {\n\t\t\t\tid++;\n\t\t\t\tres -= term();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int term() {\n\t\tint res = fact();\n\t\twhile(s[id] == '*' || s[id] == '/') {\n\t\t\tif(s[id] == '*') {\n\t\t\t\tid++;\n\t\t\t\tres *= fact();\n\t\t\t}else{\n\t\t\t\tid++;\n\t\t\t\tres /= fact();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tstatic int fact() {\n\t\tint res = 0;\n\t\tif(s[id] == '(') {\n\t\t\tid++;\n\t\t\tres = exp();\n\t\t\tid++;\n\t\t}else if(s[id] == '+') {\n\t\t\tid++;\n\t\t\tres = fact();\n\t\t}else if(s[id] == '-') {\n\t\t\tid++;\n\t\t\tres = -fact(); \n\t\t}else {\n\t\t\tres = num();\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int num() {\n\t\tint res = 0;\n\t\tif(Character.isDigit(s[id])) {\n\t\t\twhile('0' <= s[id] && s[id] <= '9') {\n\t\t\t\tres *= 10;\n\t\t\t\tres += s[id] - '0';\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        while(n-->0){\n            in = sc.next().toCharArray();\n            p = 0;     \n            System.out.println(expr());            \n        }\n    }\n\n    int expr(){\n        int a = term();\n        while(in[p]=='+' || in[p]=='-'){\n            boolean boo = in[p]=='+';\n            p++;\n            int b = term();\n            if(boo) a += b;\n            else a -= b;\n        }\n        return a;\n    }\n\n    int term(){\n        int a = factor();\n        while(in[p]=='*' || in[p]=='/'){\n            boolean boo = in[p]=='*';\n            p++;\n            int b = term();\n            if(boo) a *= b;\n            else a /= b;\n        }\n        return a;\n    }\n\n    int factor(){\n        if(in[p]=='('){\n            p++;\n            int res = expr();\n            p++;\n            return res;\n        }\n        else return digit();\n    }\n\n    int digit(){\n        int res = 0;\n        while(Character.isDigit(in[p])){\n            res = res*10 + (in[p]-'0');\n            p++;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[101];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()-1));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()-1));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\n\npublic class EvalScript {\n    public static void main(String[] args) throws Exception {\n        ScriptEngineManager factory = new ScriptEngineManager();\n        ScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n       \n        engine.eval(\"println('Hello JavaScript from Java.')\");\n       \n        engine.eval(\"var str1 = 'JavaScript String'\");\n        engine.eval(\"println(str1);\");\n        engine.eval(\"var str2 = new java.lang.String('Java String');\");\n        engine.eval(\"println(str2);\");\n       \n        engine.eval(\"var array = ['JavaScript', 'Array'];\");\n        engine.eval(\"println(array);\");\n        engine.eval(\"var list = new java.util.ArrayList();\");\n        engine.eval(\"list.add('Java');\");\n        engine.eval(\"list.add('ArrayList');\");\n        engine.eval(\"println(list);\");\n       \n        engine.eval(\"var obj = {'JavaScript':'Object'};\");\n        engine.eval(\"println(obj);\");\n        engine.eval(\"var map = new java.util.HashMap();\");\n        engine.eval(\"map.put('Java', 'HashMap');\");\n        engine.eval(\"println(map);\");\n       \n        Runtime r = Runtime.getRuntime();\n        engine.put(\"r\", r);\n        engine.eval(\"print('Max:   ' + r.maxMemory() + ' Bytes\\\\n');\");\n        engine.eval(\"print('Total: ' + r.totalMemory() + ' Bytes\\\\n');\");\n        engine.eval(\"print('Free:  ' + r.freeMemory() + ' Bytes\\\\n');\");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (1+(6/2/2+50*3/2/3*6))*2+1=\n\nclass Main{\n\tstatic Pattern parens = Pattern.compile(\"(.*?)\\\\((.+)\\\\)(.*)\");\n\tstatic Pattern addsub = Pattern.compile(\"(.*?)(\\\\d+)([+-])(\\\\d+)(.*)\");\n\tstatic Pattern muldiv = Pattern.compile(\"(.*?)(\\\\d+)([*/])(\\\\d+)(.*)\");\n\tstatic Pattern div = Pattern.compile(\"(.*?)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\tstatic String process(String s){\n\t\tMatcher m=parens.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+process(m.group(2))+m.group(3);\n\t\t\tm=parens.matcher(s);\n\t\t}\n\n\t\tm=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\ts = new char[101];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i]=str.charAt(i);\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\twhile(s[idx]=='+'||s[idx]=='-'){\n\t\t\tif(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres += term();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tidx++;\n\t\t\t\tres -= term();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\twhile(s[idx]=='*' || s[idx]=='/'){\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres *= fact();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tidx++;\n\t\t\t\tres /= fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\tres = s[idx++]-'0';\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int kagen(){\n\t\tint res = joujo();\n\t\tif(s[idx]=='+'){\n\t\t\tidx++;\n\t\t\treturn res +term();\n\t\t}\n\t\telse if(s[idx]=='-'){\n\t\t\tidx++;\n\t\t\treturn res -term();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int joujo(){\n\t\tint res =  value();\n\t\t\n\t\tif(s[idx]=='*'){\n\t\t\tidx++;\n\t\t\tres *=value();\n\t\t\treturn res*term();\n\t\t}\n\t\telse if(s[idx]=='/'){\n\t\t\tidx++;\n\t\t\treturn res /value();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int value(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres=term();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\tres = s[idx++]-'0';\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\nclass Main{\n\tpublic static void main(String[]z)throws Exception{\n        ScriptEngineManager factory = new ScriptEngineManager();\n        ScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n       \n        engine.eval(\"println('Hello JavaScript from Java.')\");\n       \n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Smart Calculator\nimport java.util.*;\n\npublic class Main {\n\tstatic int pos;\n\tstatic String formura;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tformura = scanner.next();\n\t\t\tpos = 0;\n\t\t\tint result = expression();\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic int expression() {\n\t\tint result = 0;\n\t\tint a = term();\n\t\tresult += a;\n\t\twhile (pos < formura.length()\n\t\t\t\t&& (formura.charAt(pos) == '+' || formura.charAt(pos) == '-')) {\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = term();\n\t\t\tif (op == '+')\n\t\t\t\tresult += b;\n\t\t\telse\n\t\t\t\tresult -= b;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = 0;\n\t\tint a = factor();\n\t\tresult += a;\n\t\twhile (pos < formura.length()\n\t\t\t\t&& (formura.charAt(pos) == '*' || formura.charAt(pos) == '/')) {\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = factor();\n\t\t\tif (op == '*')\n\t\t\t\tresult *= b;\n\t\t\telse\n\t\t\t\tresult /= b;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int factor() {\n\t\tint result = 0;\n\t\tif (formura.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tresult = expression();\n\t\t\tpos++;\n\t\t} else {\n\t\t\twhile (pos < formura.length()\n\t\t\t\t\t&& Character.isDigit(formura.charAt(pos))) {\n\t\t\t\tresult *= 10;\n\t\t\t\tresult += Character.getNumericValue(formura.charAt(pos));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char a) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\t\t//()内は無視\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif(a==c && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\n\t\n\tstatic int parse(String str) {\n\t\tint a = str.length();\n\t\tint n = 0;\n\t\tint g = 0;\n\t\tif(str.startsWith(\"(\") && str.endsWith(\")\")) {\t\t\t\t//(で始まり)で終わる\n\t\t\tif(!str.substring(1, a-1).contains(\"(\"))\t\t\t\t//間に()がなければsubstr\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\tfor(int i=0;i<str.length()-1;i++) {\n\t\t\t\tif(str.charAt(i)=='(') {\n\t\t\t\t\tn++;\n\t\t\t\t\tg++;\n\t\t\t\t}\n\t\t\t\tif(str.charAt(i)==')') n--;\n\t\t\t\tif(g!=0 && n==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==str.length()-2 && n-1==0) {\n\t\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ind = lastInd(str,'+');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) + parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'-');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) - parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'/');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) / parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'*');\n\t\tif(ind!=-1){\n\t\t\treturn parse(str.substring(0, ind)) * parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nclass Main{\n\tstatic Pattern parens = Pattern.compile(\"(.*?)\\\\((.+)\\\\)(.*)\");\n\tstatic Pattern add = Pattern.compile(\"(.*?)(\\\\d+)\\\\+(\\\\d+)(.*)\");\n\tstatic Pattern sub = Pattern.compile(\"(.*?)(\\\\d+)\\\\-(\\\\d+)(.*)\");\n\tstatic Pattern mul = Pattern.compile(\"(.*?)(\\\\d+)\\\\*(\\\\d+)(.*)\");\n\tstatic Pattern div = Pattern.compile(\"(.*?)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\tstatic String process(String s){\n\t\tMatcher m=parens.matcher(s);\n\t\tif(m.find()){\n\t\t\ts=m.group(1)+process(m.group(2))+m.group(3);\n\t\t}\n\t\tm=mul.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=mul.matcher(s);\n\t\t}\n\t\tm=div.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=div.matcher(s);\n\t\t}\n\t\tm=add.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=add.matcher(s);\n\t\t}\n\t\tm=sub.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=sub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tstatic int id;\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tid = 0;\n\t\t\tString[] list = split(sc.nextLine());\n\t\t\tSystem.out.println(calc(list));\n\t\t}\n\t}\n\tstatic int calc(String[] list){\n\t\tint value = Integer.parseInt(list[id]);\n\t\twhile(id < list.length-1){\n\t\t\tid++;\n\t\t\tif(list[id].equals(\"*\")){\n\t\t\t\tif(list[id+1].equals(\"(\")){\n\t\t\t\t\tid += 2;\n\t\t\t\t\tvalue *= calc(list);\n\t\t\t\t}else{\n\t\t\t\t\tvalue *= Integer.parseInt(list[++id]);\n\t\t\t\t}\n\t\t\t}else if(list[id].equals(\"/\")){\n\t\t\t\tif(list[id+1].equals(\"(\")){\n\t\t\t\t\tid += 2;\n\t\t\t\t\tvalue /= calc(list);\n\t\t\t\t}else{\n\t\t\t\t\tvalue /= Integer.parseInt(list[++id]);\n\t\t\t\t}\n\t\t\t}else if(list[id].equals(\"+\")){\n\t\t\t\tid++;\n\t\t\t\tif(list[id].equals(\"(\")){\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t\tvalue += calc(list);\n\t\t\t}else if(list[id].equals(\"-\")){\n\t\t\t\tid++;\n\t\t\t\tif(list[id].equals(\"(\")){\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t\tvalue -= calc(list);\n\t\t\t}else if(list[id].equals(\")\")){\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\tstatic String[] split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tString tmp = \"\";\n\t\tint length = s.length();\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(!isInt(s.charAt(i))){\n\t\t\t\tif(!tmp.equals(\"\")){\n\t\t\t\t\tlist.add(tmp);\n\t\t\t\t}\n\t\t\t\tlist.add(String.valueOf(s.charAt(i)));\n\t\t\t\ttmp = \"\";\n\t\t\t}else{\n\t\t\t\ttmp += s.charAt(i);\n\t\t\t}\n\t\t}\n\t\tString[] array = null;\n\t\treturn (String[])list.toArray(new String[list.size()]);\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<BigInteger> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<BigInteger>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tBigInteger n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = new BigInteger(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a.add(b));\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a.subtract(b));\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a.multiply(b));\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a.divide(b));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic String getResult(){\n\t\tcalculate();\n\t\treturn stack.pop().toString();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\tprivate boolean[] minusFlag;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tminusFlag = new boolean[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\tminusFlag[current] = true;\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if(tmp == '-'){\n\t\t\t\t\tif(!minusFlag[current]){\n\t\t\t\t\t\trpn += tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t\t}\n\t\t\t\t}else if(tmp == '+'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t\tminusFlag[current] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport javax.script.*;\n\nclass Main{\n\tpublic static void main(String[]z){try{\n\t\tScanner x=new Scanner(System.in);\n\t\tScriptEngine y = new ScriptEngineManager().getEngineByName(\"JavaScript\");\n\t\tPattern p = Pattern.compile(\"(.*?)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tMatcher m=p.matcher(s);\n\t\t\twhile(m.find()){\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\t\tm=p.matcher(s);\n\t\t\t}\n\t\t\ty.eval(\"println(\"+s.substring(0,s.length()-1)+\");\");\n\t\t}\n\t}catch(Exception e){}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tprivate int p;\n\tprivate String line;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint lines = Integer.parseInt(sc.nextLine());\n\n\t\tfor (int i = 0; i < lines; i++) {\n\t\t\tline = sc.nextLine();\n\t\t\t\n\t\t\tp = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\n\tprivate int expression() {\n\t\tdouble value = term();\n\t\t\n\t\treturn (int)sub_expression(value);\n\t}\n\t\n\tprivate int sub_expression(double value) {\n\t\tif (line.charAt(p) == '+') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value + term();\n\t\t\tvalue = sub_expression(value);\n\t\t} else if (line.charAt(p) == '-') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value - term();\n\t\t\tvalue = sub_expression(value);\n\t\t}\n\t\t\n\t\treturn (int)value;\n\t}\n\t\n\tprivate int term() {\n\t\tdouble value = factor();\n\t\t\n\t\treturn (int)sub_term(value);\n\t}\n\t\t\n\tprivate int sub_term(double value) {\n\t\tif (line.charAt(p) == '*') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value * factor();\n\t\t\tvalue = sub_term(value);\n\t\t} else if (line.charAt(p) == '/') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value / factor();\n\t\t\tvalue = sub_term(value);\n\t\t}\n\t\t\n\t\treturn (int)value;\n\t}\n\t\n\tprivate int factor() {\n\t\tdouble value = 0;\n\t\t\n\t\tswitch (line.charAt(p)) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tvalue = Integer.parseInt(\"\" + line.charAt(p));\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = expression();\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\treturn (int)value;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tString s = sc.nextLine();\n\t\t\ts = s.substring(0, s.length()-1);\n\t\t\tSystem.out.println(calc(s));\n\t\t}\n\t\t\n\t}\n\tstatic String calc(String s){\n\t\tArrayList<String> list = split(\"(\"+s+\")\");\n\t\tint index1 = index1(list);\n\t\twhile(index1 != -1){\n\t\t\tint index2 = index2(list, index1);\n\t\t\tint indexOf = indexOf(\"*\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a*b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"*\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"/\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a/b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"/\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a+b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a-b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\t}\n\t\t\tlist.remove(index1);\n\t\t\tlist.remove(index2);\n\t\t\tindex1 = index1(list);\n\t\t}\n\t\treturn (String)list.get(0);\n\t}\n\t//)ÌCfbNX\n\tstatic int index1(ArrayList<String> list){\n\t\tfor(int i = 0 ; i < list.size() ; i++){\n\t\t\tif(((String)list.get(i)).equals(\")\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//)ÌèOÌ(ÌCfbNX\n\tstatic int index2(ArrayList<String> list, int index1){\n\t\tfor(int i = index1-1; i >= 0 ; i--){\n\t\t\tif(((String)list.get(i)).equals(\"(\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//*,/,+,-ÌCfbNX\n\tstatic int indexOf(String s, ArrayList<String> list, int index2, int index1){\n\t\tfor(int i = index2+1; i < index1; i++){\n\t\t\tif(((String)list.get(i)).equals(s)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic ArrayList<String> split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile(s.length() > 0){\n\t\t\tif(isInt(s.charAt(0))){\n\t\t\t\tint i = 0;\n\t\t\t\tString _s = \"\";\n\t\t\t\twhile(isInt(s.charAt(i))){\n\t\t\t\t\t_s += String.valueOf(s.charAt(i));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlist.add(_s);\n\t\t\t\tif(i == s.length()){\n\t\t\t\t\ts = \"\";\n\t\t\t\t}else{\n\t\t\t\t\ts = s.substring(i, s.length());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlist.add(String.valueOf(s.charAt(0)));\n\t\t\t\ts = s.substring(1, s.length());\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int mark;\n\tstatic boolean cont(int st,int en,String str,String f,int flag) {\n\t\tchar g = f.charAt(0);\n\t\tif(flag==1) {\n\t\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\t\tif(st <= i && i <= en)continue;\t\t//()内を無視\n\t\t\t\tif(str.charAt(i)==g) {\n\t\t\t\t\tmark = i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tif(str.contains(f)) {\n\t\t\t\tmark = str.lastIndexOf(f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int parse(String str) {\n\t\tSystem.out.println(str);\n\t\tint a = 0;\n\t\tint sum = 0;\n\t\tint s = 0;\n\t\tint st = str.length()-1;\n\t\tint en = 0;\n\t\tint flag = 0;\n\t\tmark = 0;\n\t\t\n\t\t\n\t\tif(str.contains(\")\")) {\n\t\t\tflag = 1;\t\t\t\t\t\t//(())を想定して+-で考える\n\t\t\tif(str.charAt(0)=='(' && str.charAt(str.length()-1)==')') {\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t}\n\t\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\t\tif(str.charAt(i)==')') {\n\t\t\t\t\ts++;\n\t\t\t\t\ten = Math.max(en, i);\n\t\t\t\t}\n\t\t\t\telse if(str.charAt(i)=='(') {\n\t\t\t\t\ts--;\n\t\t\t\t\tst = Math.min(st, i);\n\t\t\t\t}\n\t\t\t\tif(s==0) {\n\t\t\t\t\tst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cont(st,en,str,\"-\",flag)) {\n\t\t\ta = mark;\n\t\t\tsum = parse(str.substring(0, a)) - parse(str.substring(a+1));\n\t\t}\n\t\t\t\n\t\telse if(cont(st,en,str,\"+\",flag)) {\n\t\t\ta = mark;\n\t\t\tsum = parse(str.substring(0, a)) + parse(str.substring(a+1));\n\t\t}\n\t\t\t\n\t\telse if(cont(st,en,str,\"/\",flag)) {\n\t\t\ta = mark;\n\t\t\tsum = parse(str.substring(0, a)) / parse(str.substring(a+1));\n\t\t}\n\t\t\t\n\t\telse if(cont(st,en,str,\"*\",flag)){\n\t\t\ta = mark;\n\t\t\tsum = parse(str.substring(0, a)) * parse(str.substring(a+1));\t\t\t}\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char ch1,char ch2) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\t\t//()内は無視\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif((ch1==c||ch2==c) && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\n\t\n\tstatic int parse(String str) {\n\t\tint a = str.length();\n\t\tint n = 0;\n\t\tint g = 0;\n\t\tif(str.startsWith(\"(\") && str.endsWith(\")\")) {\t\t\t\t//(で始まり)で終わる\n\t\t\tif(!str.substring(1, a-1).contains(\"(\"))\t\t\t\t//間に()がなければsubstr\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\tfor(int i=0;i<str.length()-1;i++) {\n\t\t\t\tif(str.charAt(i)=='(') {\n\t\t\t\t\tn++;\n\t\t\t\t\tg++;\n\t\t\t\t}\n\t\t\t\tif(str.charAt(i)==')') n--;\n\t\t\t\tif(g!=0 && n==0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i==str.length()-2 && n-1==0) {\n\t\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ind = lastInd(str,'+','-');\n\t\tif(ind!=-1) {\n\t\t\tif(str.charAt(ind)=='+')\n\t\t\t\treturn parse(str.substring(0, ind)) + parse(str.substring(ind+1));\n\t\t\treturn parse(str.substring(0, ind))  - parse(str.substring(ind+1));\n\t\t}\n\t\t\t\t\n\t\tind = lastInd(str,'*','/');\t\t\t\t\t\n\t\tif(ind!=-1){\n\t\t\tif(str.charAt(ind)=='*')\n\t\t\t\treturn parse(str.substring(0, ind)) * parse(str.substring(ind+1));\n\t\t\treturn parse(str.substring(0, ind)) / parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\treturn Integer.parseInt(str);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tenum ope {\n\n\t\tadd, sub, mul, div;\n\n\t}\n\n\n\n\tLinkedList<String> tokenize(String str) {\n\n\t\tString token = \"\";\n\n\t\tLinkedList<String> ret = new LinkedList<String>();\n\n\t\tString sp = \"+-*/()=\";\n\n\t\tfor (char c : str.toCharArray()) {\n\n\t\t\tif (Character.isDigit(c)) {\n\n\t\t\t\ttoken += c;\n\n\t\t\t} else {\n\n\t\t\t\tif (sp.indexOf(c) != -1) {\n\n\t\t\t\t\tif (token.length() != 0)\n\n\t\t\t\t\t\tret.addLast(token);\n\n\t\t\t\t\tret.addLast(Character.toString(c));\n\n\t\t\t\t\ttoken = \"\";\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tclass evTree {\n\n\t\tope o;\n\n\t\tString s;\n\n\t\tevTree left = null;\n\n\t\tevTree right = null;\n\n\t\tint val = 0;\n\n\n\n\t\tint getVal() {\n\n\t\t\tif (left == null && right == null) {\n\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tif (o == ope.add) {\n\n\t\t\t//\t System.out.println(left.s + \" add \" + right.s);\n\n\t\t\t\treturn left.getVal() + right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.sub) {\n\n\t\t\t//\t System.out.println(left.s + \" sub \" + right.s);\n\n\t\t\t\treturn left.getVal() - right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.mul) {\n\n\t\t\t//\t System.out.println(left.s + \" mul \" + right.s);\n\n\t\t\t\treturn left.getVal() * right.getVal();\n\n\t\t\t}\n\n\t\t\t// if (o == ope.div) {\n\n\t\t\t// System.out.println(left.s + \" div \" + right.s);\n\n\t\t\treturn left.getVal() / right.getVal();\n\n\t\t\t// }\n\n\t\t}\n\n\n\n\t\tboolean evTrimable(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\"))\n\n\t\t\t\treturn true;\n\n\t\t\tif (t.getFirst().equals(\"(\") && t.getLast().equals(\")\")) {\n\n\t\t\t\tint depth = 0;\n\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (String token : t) {\n\n\t\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\t\tdepth++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\t\tdepth--;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (depth == 0) {\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn count == 1;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\n\n\t\tvoid evTrim(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\")) {\n\n\t\t\t\tt.removeLast();\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tt.removeFirst();\n\n\t\t\tt.removeLast();\n\n\t\t\treturn;\n\n\t\t}\n\n\n\n\t\tString tts(LinkedList<String> t) {\n\n\t\t\tString ret = \"\";\n\n\t\t\tfor (String s : t) {\n\n\t\t\t\tret += s;\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t}\n\n\n\n\t\tevTree(LinkedList<String> t) {\n\n\t\t\ts = tts(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tfor (; evTrimable(t);)\n\n\t\t\t\tevTrim(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tint[] p = new int[t.size()];\n\n\t\t\tint depth = 1;\n\n\t\t\tint min = 100;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tString token = t.get(i);\n\n\t\t\t\tif (Character.isDigit(token.toCharArray()[0]))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\tdepth += 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\tdepth -= 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"+\") || token.equals(\"-\")) {\n\n\t\t\t\t\tp[i] = depth;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"*\") || token.equals(\"/\")) {\n\n\t\t\t\t\tp[i] = depth + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint z = 0;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tif (p[i] == 0)\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p[i] <= min) {\n\n\t\t\t\t\tmin = p[i];\n\n\t\t\t\t\tz = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tString token = t.get(z);\n\n\t\t\tif (token.equals(\"+\")) {\n\n\t\t\t\tthis.o = ope.add;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"-\")) {\n\n\t\t\t\tthis.o = ope.sub;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"*\")) {\n\n\t\t\t\tthis.o = ope.mul;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"/\")) {\n\n\t\t\t\tthis.o = ope.div;\n\n\t\t\t}\n\n\t\t\tLinkedList<String> tl = new LinkedList<String>(t.subList(0, z));\n\n\t\t\tthis.left = new evTree(tl);\n\n\t\t\tLinkedList<String> tr = new LinkedList<String>(t.subList(z + 1,\n\n\t\t\t\t\tt.size()));\n\n\t\t\tthis.right = new evTree(tr);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tint n = Integer.valueOf(sc.nextLine());\n\n\t\tfor (; n-- > 0;) {\n\n\t\t\tLinkedList<String> token = tokenize(sc.nextLine());\n\n\t\t\t/*\n\n\t\t\t * for (String t : token) { System.out.println(t); }\n\n\t\t\t */\n\n\t\t\tSystem.out.println(new evTree(token).getVal());\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.function.IntBinaryOperator;\n\npublic class Main {\n\n    static int lastIndexOf(String e, char ch) {\n        int nest = 0;\n        for(int i = e.length()-1; i > 0 ; i--) {\n            char c = e.charAt(i);\n            if(c == ‘(’) {\n                nest++;\n            }\n            if(c == ‘)’) {\n                nest--;\n            }\n            if(ch == c && nest == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    static int parse(String e) {\n        if(e.startsWith(“(”) && e.endsWith(“)”)) {\n            return parse(e.substring(1, e.length()-1));\n        }\n        int loc = lastIndexOf(e, ‘-’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) - parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘+’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) + parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘/’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) / parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘*’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) * parse(e.substring(loc+1));\n        }\n        return Integer.parseInt(e);\n    }\n    \n    public static void main(String[] args) {\n        try(Scanner sc = new Scanner(System.in)) {\n            int n = sc.nextInt();\n            for(int i = 0; i < n; i++) {\n                String e = sc.next().replace(“=”, “”);\n                System.out.println(parse(e));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tpublic int calculate(String str){\n        StringBuilder ans = new StringBuilder(str);\n\t    while( true ){            \n\t\t\tStringBuilder temp = new StringBuilder();\n           \tint key = 0; \n           \tint before = -1;\n           \tint after = ans.length();\n       \t\tfor(int i = 0; i < ans.length(); i++){\n               \tif( ans.charAt(i) == '*' || ans.charAt(i) == '/' ){\n                   \tkey = i;\n                   \tbreak;\n               \t} else if( key == 0 && ans.charAt(i) == '+' || ans.charAt(i) == '-' ){ \n                   \tkey = i;\n                }             \n           \t}\n        \t//  System.out.println(\"before = \" + before + \", key = \" + key + \", after = \" + after);\n           \tif( key == 0 ){\n           \t\tbreak;\n           \t}\n           \tfor(int i = key-1; i > 0; i--){\n               \tif( ans.charAt(i) == '+' || ans.charAt(i) == '-' ){\n                   \tbefore = i;\n                   \tbreak;\n               \t}\n           \t}\n           \tfor(int i = key+1; i < ans.length(); i++){\n               \tif( ans.charAt(i) == '+' || ans.charAt(i) == '-' || ans.charAt(i) == '*' || ans.charAt(i) == '/' ){\n                   \tafter = i;\n                   \tbreak;\n                }\n           \t}\n           \ttemp.append(ans.toString().substring(0, before+1));\n           \tint x = (int)Double.parseDouble(ans.toString().substring(before+1, key));\n           \tint y = (int)Double.parseDouble(ans.toString().substring(key+1, after));\n          \tswitch( ans.charAt(key) ){\n          \t \tcase '*' : temp.append(x*y); break;\n               \tcase '/' : temp.append(x/y); break;\n               \tcase '+' : temp.append(x+y); break;\n               \tcase '-' : temp.append(x-y); break;\n           \t}\n            temp.append(ans.toString().substring(after));\n            ans = new StringBuilder(temp);\n       \t}\n       \treturn Integer.parseInt(ans.toString());\n   }\n   public int step(String str){\n        StringBuilder ans = new StringBuilder(str);\n        ans.deleteCharAt(ans.length()-1);\n        while( true ){\n            StringBuilder temp = new StringBuilder();\n            int n = ans.indexOf(\")\");\n            int m = ans.lastIndexOf(\"(\", n);\n            if( n < 0 ){\n                break;\n            }\n            temp.append(ans.toString().substring(0, m));\n            temp.append(calculate(ans.toString().substring(m+1, n)));\n            temp.append(ans.toString().substring(n+1, ans.length()));\n            ans = new StringBuilder(temp);\n        //  System.out.println(ans);\n        }\n        return calculate(ans.toString());\n    }\n    public void solve() throws IOException{\n        int n = nextInt();\n        while( n-- > 0 ){\n            String str = nextToken();\n            System.out.println(step(str));\n        }\n    }\n    public static void main (String args[]) throws IOException{\n        new Main().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer; \n    public void run() throws IOException{\n        try{\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    public int nextInt() throws IOException{\n        return Integer.parseInt(nextToken());\n    }\n    public String nextToken() throws IOException{\n        while( tokenizer == null || !tokenizer.hasMoreTokens() ){\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tenum ope {\n\n\t\tadd, sub, mul, div;\n\n\t}\n\n\n\n\tLinkedList<String> tokenize(String str) {\n\n\t\tString token = \"\";\n\n\t\tLinkedList<String> ret = new LinkedList<String>();\n\n\t\tString sp = \"+-*/()=\";\n\n\t\tfor (char c : str.toCharArray()) {\n\n\t\t\tif (Character.isDigit(c)) {\n\n\t\t\t\ttoken += c;\n\n\t\t\t} else {\n\n\t\t\t\tif (sp.indexOf(c) != -1) {\n\n\t\t\t\t\tif (token.length() != 0)\n\n\t\t\t\t\t\tret.addLast(token);\n\n\t\t\t\t\tret.addLast(Character.toString(c));\n\n\t\t\t\t\ttoken = \"\";\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tclass evTree {\n\n\t\tope o;\n\n\t\tString s;\n\n\t\tevTree left = null;\n\n\t\tevTree right = null;\n\n\t\tint val = 0;\n\n\n\n\t\tint getVal() {\n\n\t\t\tif (left == null && right == null) {\n\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tif (o == ope.add) {\n\n\t\t\t\t// System.out.println(left.s + \" add \" + right.s);\n\n\t\t\t\treturn left.getVal() + right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.sub) {\n\n\t\t\t\t// System.out.println(left.s + \" sub \" + right.s);\n\n\t\t\t\treturn left.getVal() - right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.mul) {\n\n\t\t\t\t// System.out.println(left.s + \" mul \" + right.s);\n\n\t\t\t\treturn left.getVal() * right.getVal();\n\n\t\t\t}\n\n\t\t\t// if (o == ope.div) {\n\n\t\t\t// System.out.println(left.s + \" div \" + right.s);\n\n\t\t\treturn left.getVal() / right.getVal();\n\n\t\t\t// }\n\n\t\t}\n\n\n\n\t\tboolean evTrimable(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\"))\n\n\t\t\t\treturn true;\n\n\t\t\tif (t.getFirst().equals(\"(\") && t.getLast().equals(\")\")) {\n\n\t\t\t\tint depth = 0;\n\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (String token : t) {\n\n\t\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\t\tdepth++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\t\tdepth--;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (depth == 0) {\n\n\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn count == 1;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\n\n\t\tvoid evTrim(LinkedList<String> t) {\n\n\t\t\tif (t.getLast().equals(\"=\")) {\n\n\t\t\t\tt.removeLast();\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tt.removeFirst();\n\n\t\t\tt.removeLast();\n\n\t\t\treturn;\n\n\t\t}\n\n\n\n\t\tString tts(LinkedList<String> t) {\n\n\t\t\tString ret = \"\";\n\n\t\t\tfor (String s : t) {\n\n\t\t\t\tret += s;\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t}\n\n\n\n\t\tevTree(LinkedList<String> t) {\n\n\t\t\ts = tts(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tfor (; evTrimable(t);)\n\n\t\t\t\tevTrim(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tint[] p = new int[t.size()];\n\n\t\t\tint depth = 1;\n\n\t\t\tint min = 100;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tString token = t.get(i);\n\n\t\t\t\tif (Character.isDigit(token.toCharArray()[0]))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\tdepth += 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\tdepth -= 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"+\") || token.equals(\"-\")) {\n\n\t\t\t\t\tp[i] = depth;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"*\") || token.equals(\"/\")) {\n\n\t\t\t\t\tp[i] = depth + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint z = 0;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tif (p[i] == 0)\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p[i] < min) {\n\n\t\t\t\t\tmin = p[i];\n\n\t\t\t\t\tz = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tString token = t.get(z);\n\n\t\t\tif (token.equals(\"+\")) {\n\n\t\t\t\tthis.o = ope.add;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"-\")) {\n\n\t\t\t\tthis.o = ope.sub;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"*\")) {\n\n\t\t\t\tthis.o = ope.mul;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"/\")) {\n\n\t\t\t\tthis.o = ope.div;\n\n\t\t\t}\n\n\t\t\tLinkedList<String> tl = new LinkedList<String>(t.subList(0, z));\n\n\t\t\tthis.left = new evTree(tl);\n\n\t\t\tLinkedList<String> tr = new LinkedList<String>(t.subList(z + 1,\n\n\t\t\t\t\tt.size()));\n\n\t\t\tthis.right = new evTree(tr);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tint n = Integer.valueOf(sc.nextLine());\n\n\t\tfor (; n-- > 0;) {\n\n\t\t\tLinkedList<String> token = tokenize(sc.nextLine());\n\n\t\t\tfor (String t : token) {\n\n\t\t\t\tSystem.out.println(t);\n\n\t\t\t}\n\n\t\t\tSystem.out.println(new evTree(token).getVal());\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n   Scanner in = new Scanner(System.in);\n\n   HashMap<String, Integer> op = new HashMap<String, Integer>(){{\n       put(\"*\", 1); put(\"/\", 1);\n       put(\"+\", 2); put(\"-\", 2);\n       put(\"(\", 3); put(\")\", 3);\n   }};\n\n   void solve(){\n       int n = in.nextInt(); in.nextLine();\n       for(int i = 0; i < n; i++){\n           ArrayDeque<String> q = toRevPolish(in.nextLine());\n           System.out.println(calc(q));\n       }\n   }\n\n   ArrayDeque<String> toRevPolish(String str){\n       ArrayDeque<String> p = new ArrayDeque<>(), s = new ArrayDeque<>();\n       str = str.replace(\"=\", \"\");\n\n       boolean bfIsOp = true;\n       while(str.length() > 0){\n           int idx = nextIndex(str, bfIsOp);\n           String t = str.substring(0, idx);\n           bfIsOp = isOperator(t);\n           if(t.equals(\"(\")){\n               s.push(t);\n           }else if(t.equals(\")\")){\n               while(!s.peek().equals(\"(\")){\n                   p.push(s.pop());\n               }\n               s.pop();\n           }else{\n               while(s.size() > 0 && getRank(t) > getRank(s.peek())){\n                   p.push(s.pop());\n               }\n               s.push(t);\n           }\n           str = str.substring(idx);\n       }\n\n       while(p.size() > 0){\n           s.push(p.pop());\n       }\n\n       return s;\n   }\n\n   int calc(ArrayDeque<String> q){\n       Deque<Integer> t = new ArrayDeque<>();\n\n       while(q.size() > 0){\n           String s = q.pop();\n           if(isOperator(s)){\n               int a = t.pop(), b = t.pop();\n               switch(s){\n                   case \"+\": t.push(b + a); break;\n                   case \"-\": t.push(b - a); break;\n                   case \"*\": t.push(b * a); break;\n                   case \"/\": t.push(b / a); break;\n               }\n           }else{\n               t.push(Integer.parseInt(s));\n           }\n           \n       }\n\n       return t.pop();\n   }\n\n   int nextIndex(String str, boolean bfIsOp){\n       int idx = 0;\n       if(bfIsOp && str.charAt(0) == '-') idx++;\n       while(idx < str.length() && !isOperator(str.charAt(idx))) idx++;\n       if(idx == 0) idx = 1;\n       return idx;\n   }\n\n   boolean isOperator(char ch){\n       return \"*/+-()\".indexOf(ch) > -1;\n   }\n\n   boolean isOperator(String s){\n       return s.length() == 1 && isOperator(s.charAt(0));\n   }\n\n   int getRank(String str){\n       return isOperator(str) ? op.get(str) : 0;\n   }\n    \n   public static void main(String[] args){\n       new Main().solve();    \n   }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Smart Calculator\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\t//skip first line\n\t\tbr.readLine();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tDeque<String> queue = new ArrayDeque<>();\n\t\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\t\tchar _c = 0;\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tif (!stack.isEmpty() && (stack.peek() == '*' || stack.peek() == '/')) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '/':\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\t\twhile (stack.peek() != '(') {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ('0' <= _c && _c <= '9') {\n\t\t\t\t\t\t\tString s = queue.pollLast();\n\t\t\t\t\t\t\tqueue.offer(s + c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(c));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_c = c;\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tDeque<Integer> out = new ArrayDeque<>();\n\t\t\tfor (String s : queue) {\n\t\t\t\tswitch (s) {\n\t\t\t\t\tcase \"+\":\n\t\t\t\t\tcase \"-\":\n\t\t\t\t\tcase \"*\":\n\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\tint a, b;\n\t\t\t\t\t\tb = out.pop();\n\t\t\t\t\t\ta = out.pop();\n\t\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\t\t\tout.push(a + b);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\t\tout.push(a - b);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\t\tout.push(a * b);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\t\tout.push(a / b);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tout.push(parseInt(s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(out.peek());\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint index = 0;\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\twhile (N-- > 0) {\n\t\t\tindex = 0;\n\t\t\tString input = sc.next();\n\t\t\tSystem.out.println(expression(input.substring(0,\n\t\t\t\t\tinput.length() - 1)));\n\t\t}\n\t}\n\n\tint expression(String sb) {\n\t\tint res = term(sb);\n\t\tfor (; index < sb.length();) {\n\t\t\tif (sb.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tres += term(sb);\n\t\t\t} else if (sb.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tres -= term(sb);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint term(String sb) {\n\t\tint res = factor(sb);\n\t\tfor (; index < sb.length();) {\n\t\t\tif (sb.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tres *= factor(sb);\n\t\t\t} else if (sb.charAt(index) == '/') {\n\t\t\t\tindex++;\n\t\t\t\tres /= factor(sb);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint factor(String sb) {\n\t\tint res = 0;\n\t\tif (index < sb.length() && sb.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tres = expression(sb);\n\t\t\tindex++;\n\t\t} else {\n\t\t\tres = number(sb);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint number(String sb) {\n\t\tint res = 0;\n\t\twhile (index < sb.length() && Character.isDigit(sb.charAt(index))) {\n\t\t\tres *= 10;\n\t\t\tres += sb.charAt(index) - '0';\n\t\t\tindex++;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic String s;\n\tstatic int cur;\n\t\n\tstatic boolean isdigit(char c) {\n\t\tif(c=='0' || c=='1' ||c=='2' ||c=='3' ||c=='4' ||c=='5' ||c=='6' ||c=='7' ||c=='8' ||c=='9') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic int digit() {\n\t\tassert(isdigit(s.charAt(cur)));\n\t\tint n=s.charAt(cur)-'0';\n\t\tcur++;\n\t\treturn n;\n\t}\n\t\n\tstatic int number() {\n\t\tint n=digit();\n\t\twhile(cur<s.length() && isdigit(s.charAt(cur))) {\n\t\t\tn=n*10+digit();\n\t\t}\n\t\treturn n;\n\t}\n\t\n\tstatic int term() {\n\t\tint a=factor();\n\t\twhile(cur<s.length() && (s.charAt(cur)=='*' || s.charAt(cur)=='/')) {\n\t\t\tchar op=s.charAt(cur++);\n\t\t\tint b=factor();\n\t\t\tif(op=='*') {\n\t\t\t\ta*=b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta/=b;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tstatic int expression() {\n\t\tint a=term();\n\t\twhile(cur<s.length() && (s.charAt(cur)=='+' || s.charAt(cur)=='-')) {\n\t\t\tchar op=s.charAt(cur++);\n\t\t\tint b=term();\n\t\t\tif(op=='+') {\n\t\t\t\ta+=b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta-=b;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tstatic int factor() {\n\t\tif(s.charAt(cur)!='(') {\n\t\t\treturn number();\n\t\t}\n\t\tcur++;\n\t\tint n=expression();\n\t\tassert(s.charAt(cur)==')');\n\t\tcur++;\n\t\treturn n;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint n=sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tcur=0;\n\t\t\t\ts=sc.next();\n\t\t\t\ts=s.substring(0, s.length()-1);\n\t\t\t\tSystem.out.println(expression());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<Integer> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<Integer>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tint n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = Integer.parseInt(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a+b);\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a-b);\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a*b);\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int getResult(){\n\t\tcalculate();\n\t\treturn stack.pop();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\tprivate boolean[] minusFlag;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tminusFlag = new boolean[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\tminusFlag[current] = false;\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if(tmp == '-'){\n\t\t\t\t\tif(!minusFlag[current]){\n\t\t\t\t\t\trpn += tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t\t}\n\t\t\t\t}else if(tmp == '+'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t\tminusFlag[current] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint dataset = sc.nextInt();\n\twhile(dataset-->0){\n\t    in = sc.next().toCharArray();\n\t    p = 0;\n\t    System.out.println(expr(0, in.length-1));\n\t}\n    }\n\n    int expr(int l, int r){\n\tint depth = 0;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='(') depth++;\n\t    else if(in[i]==')') depth--;\n\n\t    if(depth!=0) continue;\n\t    if(in[i]=='+'){\n\t\tint nn = expr(l, i) + expr(i+1, r);\n\t\t//System.out.println(in[l]+\" \"+in[i-1]+\" \"+nn+\" \"+in[i+1]+\" \"+in[r-1]);\n\t\treturn nn;\n\t    }else if(in[i]=='-'){\n\t\tint nn = expr(l, i) - expr(i+1, r);\n\t\t//System.out.println(in[l]+\" \"+in[i-1]+\" \"+nn+\" \"+in[i+1]+\" \"+in[r-1]);\n\t\treturn nn;\n\t    }\n\t}\n\n\tint res = 0;\n\tint enzan = 2; // 0:+ , 1:- , 2:nothing\n\tint left = -1, right = -1;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='('){\n\t\tdepth++;\n\t\tif(left==-1){\n\t\t    left = i;\n\t\t    right = i;\n\t\t}\n\t    }else if(in[i]==')'){\n\t\tdepth--;\n\t\tif(depth==0){\n\t\t    if(enzan==0){\n\t\t\t//System.out.println(\"res \"+res);\n\t\t\tres *= expr(left+1, i);\n\t\t\t//System.out.println(\"res \"+res);\n\t\t    }\n\t\t    if(enzan==1) res /= expr(left+1, i);\n\t\t    if(enzan==2) res = expr(left+1, i);\n\t\t    left = right = -1;\n\t\t}\n\t    }else if(depth==0 && Character.isDigit(in[i])){\n\t\tif(enzan==0) res *= digit(i);\n\t\tif(enzan==1) res /= digit(i);\n\t\tif(enzan==2) res = digit(i);\n\t\twhile(i+1<in.length && Character.isDigit(in[i+1])){\n\t\t    i++;\n\t\t}\n\t    }else if(depth==0 && in[i]=='*' || in[i]=='/'){\n\t\tif(in[i]=='*') enzan = 0;\n\t\telse enzan = 1;\n\t    }\n\t}\n\n\t//System.out.println(l+\" \"+r+\" res \"+res);\n\treturn res;\n    }\n\n    int digit(int p){\n\tint res = 0;\n\tint l = p;\n\twhile(p<in.length && Character.isDigit(in[p])){\n\t    p++;\n\t}\n\tfor(int i=l; i<p; i++){\n\t    res += (in[i]-'0') * (int)Math.pow(10, p-i-1);\n\t}\n\treturn res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint dataset = sc.nextInt();\n\twhile(dataset-->0){\n\t    in = sc.next().toCharArray();\n\t    p = 0;\n\t    System.out.println(expr());\n\t}\n    }\n\n    int expr(){\n\tint a = term();\n\twhile(in[p]=='+' || in[p]=='-'){\n\t    int enzan = 0;\n\t    if(in[p]=='-') enzan = 1;\n\t    p++;\n\t    int b = term();\n\t    if(enzan==0) a += b;\n\t    else a -= b;\n\t} \n\treturn a;\n    }\n\n    int term(){\n\tint a = factor();\n\twhile(in[p]=='*' || in[p]=='/'){\n\t    int enzan = 0;\n\t    if(in[p]=='/') enzan = 1;\n\t    p++;\n\t    int b = term();\n\t    if(enzan==0) a *= b;\n\t    else a /= b;\n\t} \n\treturn a;\n    }\n\n    int factor(){\n\tif(in[p]=='('){\n\t    p++;\n\t    int res = expr();\n\t    p++;\n\t    return res;\n\t}\n\treturn digit();\n    }\n\n    int digit(){\n\tint res = 0;\n\twhile(p<in.length-1 && Character.isDigit(in[p])){\n\t    res = res * 10 + (in[p]-'0');\n\t    p++;\n\t}\n\treturn res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\tchar[] a = str.toCharArray();\n\t\t\ts = new char[150];\n\t\t\tfor(int i = 0; i < a.length;i++){\n\t\t\t\ts[i]=a[i];\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\n\t}\n\tstatic int expression(){\n\t\tint res =term();\n\t\twhile(s[idx]=='+'||s[idx]=='-'){\n\t\t\tif(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres+=expression();\n\t\t\t}\n\t\t\telse if(s[idx]=='-'){\n\t\t\t\tidx++;\n\t\t\t\tres-=expression();\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\twhile(s[idx]=='*'||s[idx]=='/'){\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres*=fact();\n\t\t\t}\n\t\t\telse if(s[idx]=='/'){\n\t\t\t\tidx++;\n\t\t\t\tres/=fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\twhile(true){\n\t\t\t\tres += s[idx]-'0';\n\t\t\t\tidx++;\n\t\t\t\tif(!Character.isDigit(s[idx])){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres*=10;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tif(expr.indexOf(\"-\",m)>m+1){\n\t\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\tstatic int cur;\n\tstatic String S;\n\tprivate static Scanner sc;\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tint k = sc.nextInt();\n\t\tfor (int l=0; l<k; l++){\n\t\t\tS = sc.next();\n\t\t\tcur = 0;\n\t\t\tint a = parse();\n\t\t\tSystem.out.println(a);\n\t\t}\n\t}\n\tstatic int parse() {\n\t\treturn expression();\n\t}\n\tstatic int digit(){\n\t\tassert(Character.isDigit(S.charAt(cur)));\n\t\tint n = S.charAt(cur) -'0';\n\t\tcur++;\n\t\treturn n;\n\t}\n\tstatic int number() {\n\t\tint n = digit();\n\t\twhile ((cur < S.length()) && Character.isDigit(S.charAt(cur)))\n\t\t\tn = n*10 + digit();\n\t\treturn n;\n\t}\n\tstatic int expression(){\n\t\tint sum = term();\n\t\twhile (S.charAt(cur) != '='){\n\t\t\tif (S.charAt(cur) == '+'){\n\t\t\t\tcur++;\n\t\t\t\tsum+=term();\n\t\t\t}\n\t\t\telse if (S.charAt(cur)=='-'){\n\t\t\t\tcur++;\n\t\t\t\tsum-=term();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn sum;\n\t}\n\tstatic int factor(){\n\t\tif (S.charAt(cur)!='(') return number();\n\t\tcur++;\n\t\tint n = expression();\n\t\tassert(S.charAt(cur)==')');\n\t\tcur++;\n\t\treturn n;\n\t}\n\tstatic int term(){\n\t\tint a = factor();\n\t\twhile (true) {\n\t\t\tif (S.charAt(cur) == '*'){\n\t\t\t\tcur++;\n\t\t\t\ta*=factor();\n\t\t\t}\n\t\t\telse if (S.charAt(cur) == '/'){\n\t\t\t\tcur++;\n\t\t\t\ta/=factor();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package aoj1;\n\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\nnew Main().run();\n\t}\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tfor(; T-->0; ) {\n\t\t\tParser parser = new Parser( sc.next() );\n\t\t\tSystem.out.println(parser.expr());\n\t\t}\n\t}\n\t\n\tclass Parser {\n\t\tchar s[];\n\t\tint p;\n\t\tParser(String s) {\n\t\t\tthis.s = s.toCharArray();\n\t\t\tthis.p = 0;\n\t\t}\n\t\t\n\t\tint expr(){\n\t\t\tint r = term();\n\t\t\tfor(;;) {\n\t\t\t\tif( s[p] == '+') {\n\t\t\t\t\tp++;\n\t\t\t\t\tint t = term();\n\t\t\t\t\tr += t;\n\t\t\t\t}\n\t\t\t\telse if( s[p] == '-') {\n\t\t\t\t\tp++;\n\t\t\t\t\tint t = term();\n\t\t\t\t\tr -= t;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tint term() {\n\t\t\tint r = num();\n\t\t\tfor(;;) {\n\t\t\t\tif( s[p] == '*') {\n\t\t\t\t\tp++;\n\t\t\t\t\tint t = num();\n\t\t\t\t\tr *= t;\n\t\t\t\t}\n\t\t\t\telse if( s[p] == '/') {\n\t\t\t\t\tp++;\n\t\t\t\t\tint t = num();\n\t\t\t\t\tr /= t;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tint num() {\n\t\t\tif( s[p] == '(') {\n\t\t\t\tp++;\n\t\t\t\tint r = expr();\n\t\t\t\tp++;\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint r = 0;\n\t\t\t\twhile( Character.isDigit(s[p]) ) {\n\t\t\t\t\tr = r * 10 + s[p] - '0';\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tchar[] c;\n\tint id;\n\n\tint expression() {\n\t\tint res = term();\n\t\twhile (c[id] == '+' || c[id] == '-') {\n\t\t\tif (c[id] == '+') {\n\t\t\t\tid++;\n\t\t\t\tres += term();\n\t\t\t} else {\n\t\t\t\tid++;\n\t\t\t\tres -= term();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint term() {\n\t\tint res = fact();\n\t\twhile (c[id] == '*' || c[id] == '/') {\n\t\t\tif (c[id] == '*') {\n\t\t\t\tid++;\n\t\t\t\tres *= fact();\n\t\t\t} else {\n\t\t\t\tid++;\n\t\t\t\tres /= fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint fact() {\n\t\tint res = 0;\n\t\tif (c[id] == '(') {\n\t\t\tid++;\n\t\t\tres = expression();\n\t\t\tid++;\n\t\t} else if (c[id] == '+') {\n\t\t\tid++;\n\t\t\tres = fact();\n\t\t} else if (c[id] == '-') {\n\t\t\tid++;\n\t\t\tres = -fact();\n\t\t} else {\n\t\t\tres = number();\n\t\t}\n\t\treturn res;\n\t}\n\n\tint number() {\n\t\tint res = 0;\n\t\twhile ('0' <= c[id] && c[id] <= '9') {\n\t\t\tres *= 10;\n\t\t\tres += c[id] - '0';\n\t\t\tid++;\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfor (int T = sc.nextInt() - 1; 0 <= T; T--) {\n\t\t\tc = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\tif(tmp_right == 0){\n\t\t\t\t\ttmp_right = 1;\n\t\t\t\t\tSystem.out.println(\"BUG!\\n\");\n\t\t\t\t}\n\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -calc_F(left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\n\tstatic int INF = 2 << 29;\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\n\t\tfor(int  i = 0; i < n; i++) {\n\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\tString ret = rp(in);\n\t\t\tfor(int j = 0; j < ret.length(); j++) {\n\t\t\t\tif(ret.charAt(j) == '+') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b + a);\n\t\t\t\t}\n\t\t\t\telse if(ret.charAt(j) == '-') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b - a);\n\t\t\t\t}\n\t\t\t\telse if(ret.charAt(j) == '*') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b * a);\n\t\t\t\t}\n\t\t\t\telse if(ret.charAt(j) == '/') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b / a);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstackX.push(ret.charAt(j) - '0');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tout.println(stackX.pop());\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic ArrayDeque<Integer> stackX = new ArrayDeque<Integer>();\n\t\n\tstatic String rp(char[] a) {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tfor(int i = 0; i < a.length-1; i++) {\n\t\t\tchar token = a[i];\n\t\t\tif(token == '0' || token == '1' || token == '2' || token == '3' || token == '4' || token == '5' ||\n\t\t\t\t\ttoken == '6' || token == '7' || token == '8' || token == '9') {\n\t\t\t\t\tbuf.append(token);\n\t\t\t}\n\t\t\telse if(token == ')') {\n\t\t\t\twhile(true) {\n\t\t\t\t\tchar p = stack.pop();\n\t\t\t\t\tif(p == '(') break;\n\t\t\t\t\tbuf.append(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(token == '(') {\n\t\t\t\tstack.push(token);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile(true) {\n\t\t\t\t\tif(stack.isEmpty()) {\n\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(PC(stack.peek()) > PC(token)) {\n\t\t\t\t\t\tbuf.append(stack.pop());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t}\n\t\t\n\t\twhile(!stack.isEmpty()) {\n\t\t\tbuf.append(stack.pop());\n\t\t}\n\t\t\n\t\treturn buf.toString();\n\t\t\n\t}\n\t\n\tstatic int PC(char a) {\n\t\tif(a == '+' || a == '-') return 1;\n\t\tif(a == '*') return 2;\n\t\tif(a == '/') return 2;\n\t\telse return 0;\n\t}\n\t\n\tstatic ArrayDeque<Character> stack = new ArrayDeque<Character>();\n\n\t\n}\n\t\t\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=term();\n\t\t\telse if(c=='/')r/=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=fact();\n\t\t\telse if(c=='/')r/=fact();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn -fact();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn fact();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=term();\n\t\t\telse if(c=='/')r/=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn s[id]=='('?-exp():-term();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn s[id]=='('?exp():term();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n  static char[] p;\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n\n    while(n-- > 0){\n      p = sc.next().toCharArray();\n      System.out.println(expr(0).val);\n    }\n  }\n\n  static class Parsed{\n    int val;\n    int idx;\n    Parsed(int val, int idx){\n      this.val = val;\n      this.idx = idx;\n    }\n  }\n\n  static Parsed expr(int idx){\n    Parsed r = term(idx);\n    while(p[r.idx]=='+' || p[r.idx]=='-'){\n      char op = p[r.idx];\n      int tmp = r.val;\n      r = term(r.idx+1);\n      if(op == '+') r.val = tmp + r.val;\n      else r.val = tmp - r.val;\n    }\n    return r;\n  }\n\n  static Parsed term(int idx){\n    Parsed r = fact(idx);\n    while(p[r.idx]=='*' || p[r.idx]=='/'){\n      char op = p[r.idx];\n      int tmp = r.val;\n      r = fact(r.idx+1);\n      if(op == '*') r.val = tmp * r.val;\n      else r.val = tmp / r.val;\n    }\n    return r;\n  }\n\n  static Parsed fact(int idx){\n    if(Character.isDigit(p[idx])){\n      int t = p[idx++] - '0';\n      while(Character.isDigit(p[idx]))t = t*10 + p[idx++]-'0';\n      return new Parsed(t, idx);\n    }\n    else if(p[idx]=='('){\n      Parsed r = expr(idx+1);\n      if(p[r.idx]!=')') return null; // invalid input\n      return new Parsed(r.val, r.idx+1);\n    }\n    else return null; // invalid input\n  }\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tpublic int calculate(String str){\n        StringBuilder ans = new StringBuilder(str);\n\t    while( true ){            \n\t\t\tStringBuilder temp = new StringBuilder();\n           \tint key = 0; \n           \tint before = -1;\n           \tint after = ans.length();\n       \t\tfor(int i = 1; i < ans.length(); i++){\n               \tif( ans.charAt(i) == '*' || ans.charAt(i) == '/' ){\n                   \tkey = i;\n                   \tbreak;\n               \t} else if( key == 0 && (ans.charAt(i) == '+' || ans.charAt(i) == '-') ){ \n                   \tkey = i;\n                }             \n           \t}\n      //  \tSystem.out.println(\"before = \" + before + \", key = \" + key + \", after = \" + after);\n           \tif( key == 0 ){\n           \t\tbreak;\n           \t}\n           \tfor(int i = key-1; i > 0; i--){\n               \tif( ans.charAt(i) == '+' || ans.charAt(i) == '-' ){\n                   \tbefore = i;\n                   \tbreak;\n               \t}\n           \t}\n           \tfor(int i = key+2; i < ans.length(); i++){\n               \tif( ans.charAt(i) == '+' || ans.charAt(i) == '-' || ans.charAt(i) == '*' || ans.charAt(i) == '/' ){\n                   \tafter = i;\n                   \tbreak;\n                }\n           \t}\n           \ttemp.append(ans.toString().substring(0, before+1));\n           \tint x = (int)Double.parseDouble(ans.toString().substring(before+1, key));\n           \tint y = (int)Double.parseDouble(ans.toString().substring(key+1, after));\n          \tswitch( ans.charAt(key) ){\n          \t \tcase '*' : temp.append(x*y); break;\n               \tcase '/' : temp.append(x/y); break;\n               \tcase '+' : temp.append(x+y); break;\n               \tcase '-' : temp.append(x-y); break;\n           \t}\n            temp.append(ans.toString().substring(after));\n            ans = new StringBuilder(temp);\n\t//\t\tSystem.out.println(ans);\n       \t}\n       \treturn Integer.parseInt(ans.toString());\n   }\n   public int step(String str){\n        StringBuilder ans = new StringBuilder(str);\n        ans.deleteCharAt(ans.length()-1);\n        while( true ){\n            StringBuilder temp = new StringBuilder();\n            int n = ans.indexOf(\")\");\n            int m = ans.lastIndexOf(\"(\", n);\n            if( n < 0 ){\n                break;\n            }\n            temp.append(ans.toString().substring(0, m));\n            temp.append(calculate(ans.toString().substring(m+1, n)));\n            temp.append(ans.toString().substring(n+1, ans.length()));\n            ans = new StringBuilder(temp);\n       //   System.out.println(ans);\n        }\n        return calculate(ans.toString());\n    }\n    public void solve() throws IOException{\n        int n = nextInt();\n        while( n-- > 0 ){\n            String str = nextToken();\n            System.out.println(step(str));\n        }\n    }\n    public static void main (String args[]) throws IOException{\n        new Main().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer; \n    public void run() throws IOException{\n        try{\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    public int nextInt() throws IOException{\n        return Integer.parseInt(nextToken());\n    }\n    public String nextToken() throws IOException{\n        while( tokenizer == null || !tokenizer.hasMoreTokens() ){\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n} "
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(int st,String str,String f) {\n\t\tchar a = f.charAt(0);\n\t\tfor(int i=st;i>=0;i--) {\n\t\t\tif(str.charAt(i)==a)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tstatic int parse(String str) {\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint sum = 0;\n\t\tint s = 0;\n\t\tint st = str.length()-1;\n\t\tint en = 0;\n\t\t\n\t\t\n\t\tSystem.out.println(str);\n\t\tif(str.contains(\")\")) {\t\n\t\t\tif(str.charAt(0)=='(' && str.charAt(str.length()-1)==')') {\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t}\n\t\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\t\tif(str.charAt(i)==')') {\n\t\t\t\t\ts++;\n\t\t\t\t\ten = Math.max(en, i);\n\t\t\t\t}\n\t\t\t\telse if(str.charAt(i)=='(') {\n\t\t\t\t\ts--;\n\t\t\t\t\tst = Math.min(st, i);\n\t\t\t\t}\n\t\t\t\tif(s==0) {\n\t\t\t\t\tst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(str.contains(\"-\") && lastInd(st,str,\"-\")!=-1) {\n\t\t\ta = lastInd(st,str,\"-\");\n\t\t\tsum = parse(str.substring(0, a)) - parse(str.substring(a+1));\n\t\t}\n\t\t\t\n\t\telse if(str.contains(\"+\") && lastInd(st,str,\"+\")!=-1) {\n\t\t\ta = lastInd(st,str,\"+\");\n\t\t\tsum = parse(str.substring(0, a)) + parse(str.substring(a+1));\n\t\t}\n\t\t\t\n\t\telse if(str.contains(\"/\") && lastInd(st,str,\"/\")!=-1) {\n\t\t\ta = lastInd(st,str,\"/\");\n\t\t\tsum = parse(str.substring(0, a)) / parse(str.substring(a+1));\n\t\t}\n\t\t\t\n\t\telse if(str.contains(\"*\") && lastInd(st,str,\"*\")!=-1){\n\t\t\ta = lastInd(st,str,\"*\");\n\t\t\tsum = parse(str.substring(0, a)) * parse(str.substring(a+1));\t\t\t}\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\n    public static void main( final String[] args ) throws IOException {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int n = Integer.parseInt( stdin.nextLine() );\n\tfor ( int i = 0; i < n; i++ ) {\n\t    final String input = stdin.nextLine();\n\t    final StreamTokenizer tokenizer = new StreamTokenizer( new StringReader( input.substring( 0, input.length() - 1 ) ) );\n\t    tokenizer.parseNumbers();\n\t    tokenizer.ordinaryChar( '+' );\n\t    tokenizer.ordinaryChar( '-' );\n\t    tokenizer.ordinaryChar( '/' );\n\t    tokenizer.ordinaryChar( '*' );\n\t    tokenizer.ordinaryChar( ')' );\n\t    tokenizer.ordinaryChar( '(' );\n\t    tokenizer.nextToken();\n\t    System.out.println( pm( tokenizer ) );\n\t}\n    }\n\n    static int pm( StreamTokenizer tokenizer ) throws IOException {\n\tint ans = md( tokenizer );\n\n\twhile ( tokenizer.ttype != StreamTokenizer.TT_EOF &&\n\t\t( tokenizer.ttype == '+' || tokenizer.ttype == '-' ) ) {\n\t    \n\t    boolean add = ( tokenizer.ttype == '+' );\n\t    tokenizer.nextToken();\n\t    final int val = md( tokenizer );\n\t    if ( add ) {\n\t\tans += val;\n\t    } else {\n\t\tans -= val;\n\t    }\n\t}\n\treturn ans;\n    }\n\n    static int md( StreamTokenizer tokenizer ) throws IOException {\n\tint ans = term( tokenizer );\n\twhile ( tokenizer.ttype != StreamTokenizer.TT_EOF &&\n\t\t( tokenizer.ttype == '*' || tokenizer.ttype == '/' ) ){\n\t    \n\t    boolean mul = ( tokenizer.ttype == '*' );\n\t    tokenizer.nextToken();\n\t    final int val = term( tokenizer );\n\t    if ( mul ) {\n\t\tans *= val;\n\t    } else {\n\t\tans /= val;\n\t    }\n\t}\n\treturn ans;\n    }\n\n    static int term( StreamTokenizer tokenizer ) throws IOException {\n\tif ( tokenizer.ttype == StreamTokenizer.TT_NUMBER ) {\n\t    final int val = ( int )tokenizer.nval;\n\t    tokenizer.nextToken();\n\t    return val;\n\t} else { \n\t    tokenizer.nextToken(); //(\n\t    final int val = pm( tokenizer );\n\t    tokenizer.nextToken(); //)\n\t    return val;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint t = sc.nextInt();\n\twhile(t-->0){\n\t    String line = sc.next();\n\n\t    int ans = calc(line.substring(0,line.length()-1));\n\t    System.out.println(ans);\n\t}\n    }\n\n    int calc(String line){\n\n\tString newLine = \"\";\n\tfor(int i=0; i<line.length(); i++){\n\t    if(line.charAt(i)=='('){\n\t\tint idx = i;\n\t\twhile(line.charAt(idx)!=')') idx++;\n\t\tnewLine += calc(line.substring(i+1,idx));\n\t\ti = idx;\n\t    }else newLine += line.charAt(i);\n\t}\n\n\tArrayList<Integer> list = new ArrayList<Integer>();\n\tArrayList<Character> list2 = new ArrayList<Character>();\n\tString tmp = \"\";\n\tfor(int i=0; i<newLine.length(); i++){\n\t    char c = newLine.charAt(i);\n\t    if(c=='*' || c=='/' || c=='+' || c=='-'){\n\t\tlist.add(Integer.parseInt(tmp));\n\t\ttmp = \"\";\n\t\tlist2.add(c);\n\t    }else{\n\t\ttmp += c;\n\t    }\n\t}\n\tlist.add(Integer.parseInt(tmp));\n\n\t//System.out.println(list.size()+\" \"+list2.size());\n\n\tfor(int i=0; i<list2.size(); i++){\n\t    char c = list2.get(i);\n\t    if(c=='*' || c=='/'){\n\t\tint n1 = list.get(i);\n\t\tint n2 = list.get(i+1);\n\t\tif(c=='*'){\n\t\t    list.set(i, n1*n2);\n\t\t}else{\n\t\t    list.set(i, n1/n2);\n\t\t}\n\t\tlist.remove(i+1);\n\t\tlist2.remove(i);\n\t\ti--;\n\t    }\n\t}\n\n\tint ans = list.get(0);\n\tfor(int i=0; i<list2.size(); i++){\n\t    char c = list2.get(i);\n\t    if(c=='+'){\n\t\tans += list.get(i+1);\n\t    }else{\n\t\tans -= list.get(i+1);\n\t    }\n\t}\n\n\treturn ans;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (;n>0;n--) {\n\t\t\tp = 0;\n\t\t\tline = sc.next();\n\t\t\tSystem.out.println(formula());\n\t\t}\n\t}\n\t\n\tint p; String line;\n\tchar next() {\n\t\treturn line.charAt(p++);\n\t}\n\t\n\tint formula() {\n\t\treturn exp();\n\t}\n\t\n\tint exp() {\n\t\tint a = term();\n\t\tchar op = next();\n\t\twhile (op == '+' || op == '-') {\n\t\t\tint b = term();\n\t\t\tif (op == '+') a += b;\n\t\t\telse a -= b;\n\t\t\top = next();\n\t\t}\n\t\tp--;\n\t\treturn a;\n\t}\n\t\n\tint term() {\n\t\tint a = num();\n\t\tchar op = next();\n\t\twhile(op == '*' || op == '/') {\n\t\t\tint b = num();\n\t\t\tif (op == '*') a *= b;\n\t\t\telse a /= b;\n\t\t\top = next();\n\t\t}\n\t\tp--;\n\t\treturn a;\n\t}\n\t\n\tint num() {\n\t\tchar c = next();\n\t\tif (c == '(') {\n\t\t\tint num = exp(); p++; return num;\n\t\t}\n\t\tString num = \"\";\n\t\twhile('0' <= c && c <= '9') {\n\t\t\tnum += c; c = next();\n\t\t}\n\t\tp--;\n\t\treturn Integer.parseInt(num);\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()-1));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\t\n\tint check(String expr){\n\t\tint count=0;\n\t\tint n=-1;\n\t\twhile(n<expr.length()){\n\t\t\tn=expr.indexOf(\"(\",n+1);\n\t\t\tif(n!=-1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn=-1;\n\t\twhile(n<expr.length()){\n\t\t\tn=expr.indexOf(\")\",n+1);\n\t\t\tif(n!=-1){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tString[] param=expr.split(\"\\\\Q+\\\\E\");\n\t\tint m;\n\t\tArrayList<String> sp=new ArrayList<String>();\n\t\tfor(m=0;m<param.length;m++){\n\t\t\tString[] str=param[m].split(\"-\");\n\t\t\tfor(int n=0;n<str.length;n++){\n\t\t\t\tsp.add(str[n]);\n\t\t\t\tsp.add(\"-\");\n\t\t\t}\n\t\t\tsp.remove(sp.size()-1);\n\t\t\tsp.add(\"+\");\n\t\t}\n\t\tsp.remove(sp.size()-1);\n\t\t\n\t\tm=0;\n\t\twhile(m<sp.size()){\n\t\t\tint n=check(sp.get(m));\n\t\t\tif(n==0){\n\t\t\t\tnum.add(sp.get(m));\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString str=sp.get(m);\n\t\t\t\tdo{\n\t\t\t\t\tm++;\n\t\t\t\t\tstr+=sp.get(m);\n\t\t\t\t} while(check(str)!=0);\n\t\t\t\tnum.add(str);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tString[] param=expr.split(\"\\\\Q*\\\\E\");\n\t\tint m;\n\t\tArrayList<String> sp=new ArrayList<String>();\n\t\tfor(m=0;m<param.length;m++){\n\t\t\tString[] str=param[m].split(\"/\");\n\t\t\tfor(int n=0;n<str.length;n++){\n\t\t\t\tsp.add(str[n]);\n\t\t\t\tsp.add(\"/\");\n\t\t\t}\n\t\t\tsp.remove(sp.size()-1);\n\t\t\tsp.add(\"*\");\n\t\t}\n\t\tsp.remove(sp.size()-1);\n\t\t\n\t\tm=0;\n\t\twhile(m<sp.size()){\n\t\t\tint n=check(sp.get(m));\n\t\t\tif(n==0){\n\t\t\t\tnum.add(sp.get(m));\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString str=sp.get(m);\n\t\t\t\tdo{\n\t\t\t\t\tm++;\n\t\t\t\t\tstr+=sp.get(m);\n\t\t\t\t} while(check(str)!=0);\n\t\t\t\tnum.add(str);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\tString[] param=expr.split(\"\\\\Q(\\\\E\");\n\t\t\t\tint m;\n\t\t\t\tArrayList<String> sp=new ArrayList<String>();\n\t\t\t\tfor(m=0;m<param.length;m++){\n\t\t\t\t\tString[] str=param[m].split(\"\\\\Q)\\\\E\");\n\t\t\t\t\tif(str.length>1){\n\t\t\t\t\t\tfor(int n=0;n<str.length;n++){\n\t\t\t\t\t\t\tsp.add(str[n]);\n\t\t\t\t\t\t\tsp.add(\")\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!str[0].equals(\"\")){\n\t\t\t\t\t\t\tsp.add(str[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsp.add(\"(\");\n\t\t\t\t}\n\t\t\t\tsp.remove(sp.size()-1);\n\t\t\t\tif(!sp.get(sp.size()-1).equals(\")\")){\n\t\t\t\t\tsp.add(\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tm=0;\n\t\t\t\twhile(m<sp.size()){\n\t\t\t\t\tint n=check(sp.get(m));\n\t\t\t\t\tif(n==0){\n\t\t\t\t\t\treturn doCalc3(sp.get(m).substring(1,sp.get(m).length()-1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tString str=sp.get(m);\n\t\t\t\t\t\tdo{\n\t\t\t\t\t\t\tm++;\n\t\t\t\t\t\t\tstr+=sp.get(m);\n\t\t\t\t\t\t} while(check(str)!=0);\n\t\t\t\t\t\treturn doCalc3(str.substring(1,str.length()-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse if(expr.charAt(0)!=')'){\n\t\t\ttry {\n\t\t\t\treturn new Integer(expr);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\treturn null;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//Volume1-0109\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\t//declare\n\tprivate static final int                   NUM   = 1,\n\t\t\t                                   OPE1  = 2,\n\t\t\t                                   OPE2  = 3,\n\t\t\t                                   SPRN  = 4,\n\t\t\t                                   EPRN  = 5,\n\t\t\t                                   EQ    = 6;\n\tprivate static final String                regex = \"([0-9]+|\\\\+|-|\\\\*|/|\\\\(|\\\\)|=)(.*)\";\n\tprivate static       ArrayList<String>     t     = new ArrayList<String>(),\n\t\t\t                                   rpn   = new ArrayList<String>();\n\tprivate static       ArrayDeque<String>    stack = new ArrayDeque<String>();\n\tprivate static       ArrayDeque<Integer>   ans   = new ArrayDeque<Integer>();\n\n\n\tpublic static void main(String[] args){\n\n\t\tMatcher m;\n \t\tString  s;\n \t\tint     n;\n\n\t\t//initialize\n\t\tPattern token = Pattern.compile(regex);\n\n\t\t//input\n        Scanner sc = new Scanner(System.in);\n        n = Integer.parseInt(sc.nextLine());\n        while(n-- > 0){\n        \tt.clear();\n        \trpn.clear();\n        \tstack.clear();\n        \ts = sc.nextLine();\n        \twhile(s.length() != 0){\n        \t\tm = token.matcher(s);\n        \t\tif(m.find()){\n        \t\t\tt.add(m.group(1));\n        \t\t\ts = m.group(2);\n        \t\t}\n        \t}\n\n        \t//calculate\n        \tchg_notation();\n        \tcalc();\n\n        \t//output\n        \tSystem.out.println(ans.pop());\n        }\n\t}\n\n\tprivate static void calc(){\n\n\t\tint kind,a,b;\n\t\tfor(String tkn:rpn){\n\t\t\tkind = isKind(tkn);\n\t\t\tif(kind == NUM){\n\t\t\t\tans.push(Integer.parseInt(tkn));\n\t\t\t}else if(tkn.equals(\"+\")){\n\t\t\t\tans.push(ans.pop()+ans.pop());\n\t\t\t}else if(tkn.equals(\"-\")){\n\t\t\t\tb = ans.pop();\n\t\t\t\ta = ans.pop();\n\t\t\t\tans.push(a-b);\n\t\t\t}else if(tkn.equals(\"*\")){\n\t\t\t\tans.push(ans.pop()*ans.pop());\n\t\t\t}else if(tkn.equals(\"/\")){\n\t\t\t\tb = ans.pop();\n\t\t\t\ta = ans.pop();\n\t\t\t\tans.push(a/b);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void chg_notation(){\n    \tout:for(String tkn:t){\n    \t\tswitch(isKind(tkn)) {\n    \t\t\tcase NUM  : {rpn.add(tkn);break;}\n    \t\t\tcase OPE1 : {}\n    \t\t\tcase OPE2 : {\n    \t\t\tString top = stack.peek();\n    \t\t\t\tif(top != null && isKind(top) == OPE2){\n    \t\t\t\t\trpn.add(stack.pop());\n    \t\t\t\t}\n    \t\t\t\tstack.push(tkn);\n    \t\t\t\tbreak;\n    \t\t\t}\n        \t    case SPRN :{\n    \t\t\t\tstack.push(tkn);\n    \t\t\t\tbreak;\n        \t    }\n        \t    case EPRN :{\n        \t    \tString e;\n        \t    \twhile(true){\n        \t    \t\te = stack.pop();\n        \t    \t\tif(isKind(e) != SPRN){\n        \t    \t\t\trpn.add(e);\n        \t    \t\t} else {\n        \t    \t\t\tbreak;\n        \t    \t\t}\n        \t    \t}\n        \t    \tbreak;\n        \t    }\n        \t    case EQ : {\n        \t    \tfor(String e:stack){\n        \t    \t\trpn.add(e);\n        \t    \t}\n        \t    \tbreak out;\n        \t    }\n        \t}\n    \t}\n\t}\n\n\tprivate static int isKind(String s){\n\t\tint ret = -1;\n\t\tif     (s.matches(\"[0-9]+\")) {ret = 1;}\n\t\telse if(s.matches(\"(\\\\+|-)\")){ret = 2;}\n\t\telse if(s.matches(\"(\\\\*|/)\")){ret = 3;}\n\t\telse if(s.matches(\"\\\\(\"))    {ret = 4;}\n\t\telse if(s.matches(\"\\\\)\"))    {ret = 5;}\n\t\telse if(s.matches(\"=\"))      {ret = 6;}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (str.charAt(pos) != '=') {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= factor();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tint temp = expression();\n\t\t\tpos++;\n\t\t\treturn temp;\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport javax.script.*;\n\nclass Main{\n\tpublic static void main(String[]z){try{\n\t\tScanner x=new Scanner(System.in);\n\t\tScriptEngine y = new ScriptEngineManager().getEngineByName(\"JavaScript\");\n\t\tPattern p = Pattern.compile(\"(.*)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tMatcher m=p.matcher(s);\n\t\t\twhile(m.find()){\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\t\tm=p.matcher(s);\n\t\t\t}\n\t\t\ty.eval(\"println(\"+s.substring(0,s.length()-1)+\");\");\n\t\t}\n\t}catch(Exception e){}}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\n\tstatic int INF = 2 << 29;\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\n\t\tfor(int  i = 0; i < n; i++) {\n\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\tString ret = rp(in);\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < ret.length(); j++) {\n\t\t\t\tif(ret.charAt(j) == '+') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b + a);\n\t\t\t\t}\n\t\t\t\telse if(ret.charAt(j) == '-') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b - a);\n\t\t\t\t}\n\t\t\t\telse if(ret.charAt(j) == '*') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b * a);\n\t\t\t\t}\n\t\t\t\telse if(ret.charAt(j) == '/') {\n\t\t\t\t\tint a = stackX.pop();\n\t\t\t\t\tint b = stackX.pop();\n\t\t\t\t\tstackX.push(b / a);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstackX.push(ret.charAt(j) - '0');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tout.println(stackX.pop());\n\t\t\t\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tstatic ArrayDeque<Integer> stackX = new ArrayDeque<Integer>();\n\t\n\tstatic String rp(char[] a) {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tfor(int i = 0; i < a.length-1; i++) {\n\t\t\tchar token = a[i];\n\t\t\tif(token == '0' || token == '1' || token == '2' || token == '3' || token == '4' || token == '5' ||\n\t\t\t\t\ttoken == '6' || token == '7' || token == '8' || token == '9') {\n\t\t\t\t\tbuf.append(token);\n\t\t\t}\n\t\t\telse if(token == ')') {\n\t\t\t\twhile(true) {\n\t\t\t\t\tchar p = stack.pop();\n\t\t\t\t\tif(p == '(') break;\n\t\t\t\t\tbuf.append(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(token == '(') {\n\t\t\t\tstack.push(token);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile(true) {\n\t\t\t\t\tif(stack.isEmpty()) {\n\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(PC(stack.peek()) > PC(token)) {\n\t\t\t\t\t\tbuf.append(stack.pop());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tstack.push(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t}\n\t\t\n\t\twhile(!stack.isEmpty()) {\n\t\t\tbuf.append(stack.pop());\n\t\t}\n\t\t\n\t\treturn buf.toString();\n\t\t\n\t}\n\t\n\tstatic int PC(char a) {\n\t\tif(a == '+' || a == '-') return 1;\n\t\tif(a == '*') return 2;\n\t\tif(a == '/') return 3;\n\t\tif(a == '(') return 0;\n\t\telse return 0;\n\t}\n\t\n\tstatic ArrayDeque<Character> stack = new ArrayDeque<Character>();\n\n\t\n}\n\t\t\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \t if (!hasNext()) throw new NoSuchElementException();\n         int n = 0;\n         boolean minus = false;\n         int b = readByte();\n         if (b == '-') {\n             minus = true;\n             b = readByte();\n         }\n         if (b < '0' || '9' < b) {\n             throw new NumberFormatException();\n         }\n         while(true){\n             if ('0' <= b && b <= '9') {\n                 n *= 10;\n                 n += b - '0';\n             }else if(b == -1 || !isPrintableChar(b)){\n                 return minus ? -n : n;\n             }else{\n                 throw new NumberFormatException();\n             }\n             b = readByte();\n         }\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\npublic class Main {\n\n\tstatic int n;\n\tstatic String line;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic void read() {\n\t\tline = sc.nextLine();\n\t}\n\t\n\tstatic int solve() {\n\t\treturn new MyParser().parse(line.substring(0, line.length() - 1));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt(); sc.nextLine();\n\t\twhile(n-- > 0) {\n\t\t\tread();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n}\n\nclass MyParsed {\n\tint val;\n\tString str;\n\t\n\tMyParsed(int val, String str) {\n\t\tthis.val = val; this.str = str;\n\t}\n}\n\nclass MyParser {\n\t\n\tpublic int parse(String str) {\n\t\tMyParsed mp = expr(str);\n\t\treturn mp.val;\n\t}\n\t\n\tprivate MyParsed expr(String str) {\n\t\tMyParsed mp = term(str);\n\t\twhile(mp.str.length() > 0 && (mp.str.charAt(0) == '+' || mp.str.charAt(0) == '-')) {\n\t\t\tchar op = mp.str.charAt(0);\n\t\t\tint tmp = mp.val;\n\t\t\tmp = term(mp.str.substring(1));\t\t\t\t\n\t\t\tif(op == '+') {\n\t\t\t\tmp.val = tmp + mp.val;\n\t\t\t} else {\n\t\t\t\tmp.val = tmp - mp.val;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\treturn mp;\n\t}\n\t\n\tprivate MyParsed term(String str) {\n\t\tMyParsed mp = fact(str);\n\t\twhile(mp.str.length() > 0 && (mp.str.charAt(0) == '*' || mp.str.charAt(0) == '/')) {\n\t\t\tchar op = mp.str.charAt(0);\n\t\t\tint tmp = mp.val;\n\t\t\tmp = fact(mp.str.substring(1));\n\t\t\tif(op == '*') {\n\t\t\t\tmp.val = tmp * mp.val;\n\t\t\t} else {\n\t\t\t\tmp.val = tmp / mp.val;\n\t\t\t}\n\t\t}\n\t\treturn mp;\n\t}\n\t\n\tprivate MyParsed fact(String str) {\n\t\tif(Character.isDigit(str.charAt(0))) {\n\t\t\tint pos = 0; String num = \"\";\n\t\t\twhile(pos < str.length() && Character.isDigit(str.charAt(pos))) {\n\t\t\t\tnum += str.charAt(pos++);\t\t\t\n\t\t\t}\n\t\t\treturn new MyParsed(Integer.parseInt(num), str.substring(pos));\n\t\t} else {\n\t\t\tMyParsed mp = expr(str.substring(1));\n\t\t\tmp.str = mp.str.substring(1);\n\t\t\treturn mp;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// 6/2/2+50*3/2*6\n\nclass Main{\n\tstatic Pattern parens = Pattern.compile(\"(.*?)\\\\((.+)\\\\)(.*)\");\n\tstatic Pattern add = Pattern.compile(\"(.*?)(\\\\d+)\\\\+(\\\\d+)(.*)\");\n\tstatic Pattern sub = Pattern.compile(\"(.*?)(\\\\d+)\\\\-(\\\\d+)(.*)\");\n\tstatic Pattern mul = Pattern.compile(\"(.*?)(\\\\d+)\\\\*(\\\\d+)(.*)\");\n\tstatic Pattern muldiv = Pattern.compile(\"(.*?)(\\\\d+)\\\\*(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\tstatic Pattern div = Pattern.compile(\"(.*?)(\\\\d+)\\\\/(\\\\d+)(.*)\");\n\n\tstatic String process(String s){\n\t\tMatcher m=parens.matcher(s);\n\t\tif(m.find()){\n\t\t\ts=m.group(1)+process(m.group(2))+m.group(3);\n\t\t}\n\t\tm=mul.matcher(s);\n\t\twhile(m.find()){\n\t\t\tMatcher M=muldiv.matcher(s);\n\t\t\tif(M.find()){\n\t\t\t\ts=M.group(1)+(Integer.parseInt(M.group(2))*Integer.parseInt(M.group(3))/Integer.parseInt(M.group(4)))+M.group(5);\n\t\t\t}else{\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\t}\n\t\t\tm=mul.matcher(s);\n\t\t}\n\t\tm=div.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=div.matcher(s);\n\t\t}\n\t\tm=sub.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=sub.matcher(s);\n\t\t}\n\t\tm=add.matcher(s);\n\t\twhile(m.find()){\n\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(3)))+m.group(4);\n\t\t\tm=add.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next();\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\npublic class Main {\n\tstatic char[] s;\n\tstatic int id ;\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\ts = sc.next().toCharArray();\n\t\t\t\tid = 0;\n\t\t\t\tSystem.out.println(exp());\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic int exp() {\n\t\tint res = term();\n\t\twhile(s[id] == '+' || s[id] == '-') {\n\t\t\tif(s[id] == '+') {\n\t\t\t\tid++;\n\t\t\t\tres += term();\n\t\t\t}else {\n\t\t\t\tid++;\n\t\t\t\tres -= term();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int term() {\n\t\tint res = fact();\n\t\twhile(s[id] == '*' || s[id] == '/') {\n\t\t\tif(s[id] == '*') {\n\t\t\t\tid++;\n\t\t\t\tres *= fact();\n\t\t\t}else{\n\t\t\t\tid++;\n\t\t\t\tres /= fact();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tstatic int fact() {\n\t\tint res = 0;\n\t\tif(s[id] == '(') {\n\t\t\tid++;\n\t\t\tres = exp();\n\t\t\tid++;\n\t\t}else if(s[id] == '+') {\n\t\t\tid++;\n\t\t\tres = fact();\n\t\t}else if(s[id] == '-') {\n\t\t\tid++;\n\t\t\tres = -fact(); \n\t\t}else {\n\t\t\tres = num();\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int num() {\n\t\tint res = 0;\n\t\tif(Character.isDigit(s[id])) {\n\t\t\twhile('0' <= s[id] && s[id] <= '9') {\n\t\t\t\tres *= 10;\n\t\t\t\tres += s[id] - '0';\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint dataset = sc.nextInt();\n\twhile(dataset-->0){\n\t    in = sc.next().toCharArray();\n\t    p = 0;\n\t    System.out.println(expr(0, in.length-1));\n\t}\n    }\n\n    int expr(int l, int r){\n\tint depth = 0;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='(') depth++;\n\t    else if(in[i]==')') depth--;\n\n\t    if(depth!=0) continue;\n\t    if(in[i]=='+'){\n\t\tint nn = expr(l, i) + expr(i+1, r);\n\t\t//System.out.println(in[l]+\" \"+in[i-1]+\" \"+nn+\" \"+in[i+1]+\" \"+in[r-1]);\n\t\treturn nn;\n\t    }else if(in[i]=='-'){\n\t\tint nn = expr(l, i) - expr(i+1, r);\n\t\t//System.out.println(in[l]+\" \"+in[i-1]+\" \"+nn+\" \"+in[i+1]+\" \"+in[r-1]);\n\t\treturn nn;\n\t    }\n\t}\n\n\tint res = 0;\n\tint enzan = 2; // 0:+ , 1:- , 2:nothing\n\tint left = -1, right = -1;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='('){\n\t\tdepth++;\n\t\tif(left==-1){\n\t\t    left = i;\n\t\t    right = i;\n\t\t}\n\t    }else if(in[i]==')'){\n\t\tdepth--;\n\t\tif(depth==0){\n\t\t    if(enzan==0){\n\t\t\t//System.out.println(\"res \"+res);\n\t\t\tres *= expr(left+1, i);\n\t\t\t//System.out.println(\"res \"+res);\n\t\t    }\n\t\t    if(enzan==1) res /= expr(left+1, i);\n\t\t    if(enzan==2) res = expr(left+1, i);\n\t\t    left = right = -1;\n\t\t}\n\t    }else if(depth==0 && Character.isDigit(in[i])){\n\t\tif(enzan==0) res *= digit(i);\n\t\tif(enzan==1) res /= digit(i);\n\t\tif(enzan==2) res = digit(i);\n\t\twhile(i+1<in.length && Character.isDigit(in[i+1])){\n\t\t    i++;\n\t\t}\n\t    }else if(depth==0 && in[i]=='*' || in[i]=='/'){\n\t\tif(in[i]=='*') enzan = 0;\n\t\telse enzan = 1;\n\t    }\n\t}\n\n\t//System.out.println(l+\" \"+r+\" res \"+res);\n\treturn res;\n    }\n\n    int digit(int p){\n\tint res = 0;\n\tint l = p;\n\twhile(p<in.length && Character.isDigit(in[p])){\n\t    p++;\n\t}\n\tfor(int i=l; i<p; i++){\n\t    res += (in[i]-'0') * (int)Math.pow(10, p-i-1);\n\t}\n\treturn res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tl = sc.next(); p = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\t\n\tString l; int p;\n\tchar next() {\n\t\treturn l.charAt(p++);\n\t}\n\t\n\tlong exp() {\n\t\tlong v1 = term();\n\t\tchar c = next();\n\t\tif( c == '=' || c == ')' ) { p--; return v1; }\n\t\tlong v2 = exp();\n\t\tif( c == '+' ) return v1 + v2;\n\t\telse return v1 - v2;\n\t}\n\t\n\tlong term() {\n\t\tlong v1 = val();\n\t\tchar c = next();\n\t\tif( c == '=' || c == '+' || c == '-' || c == ')' ) {p--; return v1;}\n\t\tlong v2 = term();\n\t\tif( c == '*' ) return v1 * v2;\n\t\telse return v1 / v2;\n\t}\n\t\n\tlong val() {\n\t\tchar c = next();\n\t\tif( c == '(' ) {long v = exp(); p++; return v;}\n\t\tString v = \"\" + c;\n\t\tfor(c = next();'0'<=c && c<='9';c=next()) v += c;\n\t\tp--;\n\t\treturn Long.parseLong(v);\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=fact();\n\t\t\telse if(c=='/')r/=fact();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn -fact();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn fact();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint t = sc.nextInt();\n\twhile(t-->0){\n\t    String line = sc.next();\n\n\t    int ans = calc(line.substring(0,line.length()-1));\n\t    System.out.println(ans);\n\t}\n    }\n\n    int calc(String line){\n\n\tString newLine = \"\";\n\tfor(int i=0; i<line.length(); i++){\n\t    if(line.charAt(i)=='('){\n\t\tint idx = i;\n\t\tint left = 1;\n\t\tint right = 0;\n\t\twhile(right!=left){\n\t\t    idx++;\n\t\t    if(line.charAt(idx)==')'){\n\t\t\tright++;\n\t\t    }else if(line.charAt(idx)=='('){\n\t\t\tleft++;\n\t\t    }\n\t\t}\n\t\tnewLine += calc(line.substring(i+1,idx));\n\t\ti = idx;\n\t    }else newLine += line.charAt(i);\n\t}\n\n\tArrayList<Integer> list = new ArrayList<Integer>();\n\tArrayList<Character> list2 = new ArrayList<Character>();\n\tString tmp = \"\";\n\tfor(int i=0; i<newLine.length(); i++){\n\t    char c = newLine.charAt(i);\n\t    if(c=='*' || c=='/' || c=='+' || c=='-'){\n\t\tlist.add(Integer.parseInt(tmp));\n\t\ttmp = \"\";\n\t\tlist2.add(c);\n\t    }else{\n\t\ttmp += c;\n\t    }\n\t}\n\tlist.add(Integer.parseInt(tmp));\n\n\t//System.out.println(list.size()+\" \"+list2.size());\n\n\tfor(int i=0; i<list2.size(); i++){\n\t    char c = list2.get(i);\n\t    if(c=='*' || c=='/'){\n\t\tint n1 = list.get(i);\n\t\tint n2 = list.get(i+1);\n\t\tif(c=='*'){\n\t\t    list.set(i, n1*n2);\n\t\t}else{\n\t\t    list.set(i, n1/n2);\n\t\t}\n\t\tlist.remove(i+1);\n\t\tlist2.remove(i);\n\t\ti--;\n\t    }\n\t}\n\n\tint ans = list.get(0);\n\tfor(int i=0; i<list2.size(); i++){\n\t    char c = list2.get(i);\n\t    if(c=='+'){\n\t\tans += list.get(i+1);\n\t    }else{\n\t\tans -= list.get(i+1);\n\t    }\n\t}\n\n\treturn ans;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && (line[i-1] == '0' || line[i-1] == '1' || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tl = sc.next(); p = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\t\n\tString l; int p;\n\tchar next() {\n\t\treturn l.charAt(p++);\n\t}\n\t\n\tString exp() {\n\t\tBigDecimal v1 = new BigDecimal(term());\n\t\tchar c = next();\n\t\tif( c == '=' || c == ')' ) { p--; return v1.toString(); }\n\t\tBigDecimal v2 = new BigDecimal(exp());\n\t\tif( c == '+' ) return v1.add(v2).toString();\n\t\telse return v1.subtract(v2).toString();\n\t}\n\t\n\tString term() {\n\t\tBigDecimal v1 = new BigDecimal(val());\n\t\tchar c = next();\n\t\tif( c == '=' || c == '+' || c == '-' || c == ')' ) {p--; return v1.toString();}\n\t\tBigDecimal v2 = new BigDecimal(term());\n\t\tif( c == '*' ) return v1.multiply(v2).toString();\n\t\telse return v1.divideToIntegralValue(v2).toString();\n\t}\n\t\n\tString val() {\n\t\tchar c = next();\n\t\tif( c == '(' ) {BigDecimal v = new BigDecimal(exp()); p++; return v.toString();}\n\t\tString v = \"\" + c;\n\t\tfor(c = next();'0'<=c && c<='9';c=next()) v += c;\n\t\tp--;\n\t\treturn v;\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tenum ope {\n\n\t\tadd, sub, mul, div;\n\n\t}\n\n\n\n\tLinkedList<String> tokenize(String str) {\n\n\t\tString token = \"\";\n\n\t\tLinkedList<String> ret = new LinkedList<String>();\n\n\t\tString sp = \"+-*/()=\";\n\n\t\tfor (char c : str.toCharArray()) {\n\n\t\t\tif (Character.isDigit(c)) {\n\n\t\t\t\ttoken += c;\n\n\t\t\t} else {\n\n\t\t\t\tif (sp.indexOf(c) != -1) {\n\n\t\t\t\t\tret.addLast(token);\n\n\t\t\t\t\tret.addLast(Character.toString(c));\n\n\t\t\t\t\ttoken = \"\";\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tclass evTree {\n\n\t\tope o;\n\n\t\tString s;\n\n\t\tevTree left = null;\n\n\t\tevTree right = null;\n\n\t\tint val = 0;\n\n\t\tint getVal() {\n\n\t\t\tif(left == null && right == null){\n\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tif (o == ope.add) {\n\n//\t\t\t\tSystem.out.println(left.s +\" add \"+ right.s);\n\n\t\t\t\treturn left.getVal() + right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.sub) {\n\n//\t\t\t\tSystem.out.println(left.s +\" sub \"+ right.s);\n\n\t\t\t\treturn left.getVal() - right.getVal();\n\n\t\t\t}\n\n\t\t\tif (o == ope.mul) {\n\n//\t\t\t\tSystem.out.println(left.s +\" mul \"+ right.s);\n\n\t\t\t\treturn left.getVal() * right.getVal();\n\n\t\t\t}\n\n\t\t\t//if (o == ope.div) {\n\n//\t\t\tSystem.out.println(left.s +\" div \"+ right.s);\n\n\t\t\t\treturn left.getVal() / right.getVal();\n\n\t\t\t//}\n\n\t\t}\n\n\n\n\t\tboolean evTrimable(LinkedList<String> t) {\n\n\t\t\tif(t.getLast().equals(\"=\")) return true;\n\n\t\t\treturn t.getFirst().equals(\"(\") && t.getLast().equals(\")\");\n\n\t\t}\n\n\n\n\t\tvoid evTrim(LinkedList<String> t) {\n\n\t\t\tif(t.getLast().equals(\"=\")){\n\n\t\t\t\tt.removeLast();\n\n\t\t\t\treturn ;\n\n\t\t\t}\n\n\t\t\tt.removeFirst();\n\n\t\t\tt.removeLast();\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tString tts(LinkedList<String> t){\n\n\t\t\tString ret=\"\";\n\n\t\t\tfor(String s : t){\n\n\t\t\t\tret+=s;\n\n\t\t\t}\n\n\t\t\treturn ret;\n\n\t\t}\n\n\t\tevTree(LinkedList<String> t) {\n\n\t\t\ts = tts(t);\n\n\t\t\tif (t.size() == 1) {\n\n\t\t\t\tthis.val = Integer.valueOf(t.get(0));\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif (t.size() == 0) {\n\n\t\t\t\tthis.val = 0;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tfor (; evTrimable(t);)\n\n\t\t\t\tevTrim(t);\n\n\t\t\tint[] p = new int[t.size()];\n\n\t\t\tint depth = 1;\n\n\t\t\tint min = 100;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tString token = t.get(i);\n\n\t\t\t\tif(token.length()==0){\n\n\t\t\t\t\tt.remove(i);\n\n\t\t\t\t\ti--;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (Character.isDigit(token.toCharArray()[0]))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (token.equals(\"(\")) {\n\n\t\t\t\t\tdepth += 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\")\")) {\n\n\t\t\t\t\tdepth -= 2;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"+\") || token.equals(\"-\")) {\n\n\t\t\t\t\tp[i] = depth;\n\n\t\t\t\t}\n\n\t\t\t\tif (token.equals(\"*\") || token.equals(\"/\")) {\n\n\t\t\t\t\tp[i] = depth + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint z = 0;\n\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\n\t\t\t\tif (p[i] == 0)\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p[i] < min) {\n\n\t\t\t\t\tmin = p[i];\n\n\t\t\t\t\tz = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tString token = t.get(z);\n\n\t\t\tif (token.equals(\"+\")) {\n\n\t\t\t\tthis.o = ope.add;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"-\")) {\n\n\t\t\t\tthis.o = ope.sub;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"*\")) {\n\n\t\t\t\tthis.o = ope.mul;\n\n\t\t\t}\n\n\t\t\tif (token.equals(\"/\")) {\n\n\t\t\t\tthis.o = ope.div;\n\n\t\t\t}\n\n\t\t\tLinkedList<String> tl = new LinkedList<String>(t.subList(0, z));\n\n\t\t\tthis.left = new evTree(tl);\n\n\t\t\tLinkedList<String> tr = new LinkedList<String>(t.subList(z+1, t.size()));\n\n\t\t\tthis.right = new evTree(tr);\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tint n = Integer.valueOf(sc.nextLine());\n\n\t\tfor (; n-- > 0;) {\n\n\t\t\tSystem.out.println(new evTree(tokenize(sc.nextLine())).getVal());\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScriptEngineManager factory = new ScriptEngineManager();\n\t\tScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\twhile(n-- != 0){\n\t\t\tString query = sc.nextLine();\n\t\t\ttry {\n\t\t\t\tengine.eval(\"println(\" + query.substring(0, query.length() - 1) + \");\");\n\t\t\t}catch(ScriptException e){\n\t\t\t\t// nothing to do\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic String str;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstr = sc.next();\n\t\t\tpos = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic int expression() {\n\t\tint ret = term();\n\t\twhile (pos < str.length()) {\n\t\t\tif (str.charAt(pos) == '+') {\n\t\t\t\tpos++;\n\t\t\t\tret += term();\n\t\t\t} else if (str.charAt(pos) == '-') {\n\t\t\t\tpos++;\n\t\t\t\tret -= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int term() {\n\t\tint ret = factor();\n\t\twhile (pos < str.length()) {\n\t\t\tif (str.charAt(pos) == '*') {\n\t\t\t\tpos++;\n\t\t\t\tret *= factor();\n\t\t\t} else if (str.charAt(pos) == '/') {\n\t\t\t\tpos++;\n\t\t\t\tret /= term();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int factor() {\n\t\tif (str.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\treturn expression();\n\t\t} else {\n\t\t\treturn number();\n\t\t}\n\t}\n\n\tstatic int number() {\n\t\tint ret = 0;\n\t\twhile (Character.isDigit(str.charAt(pos))) {\n\t\t\tret *= 10;\n\t\t\tret += str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException err){\n\t\t\terr.printStackTrace();\n\t\t}\n\t}\n\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> ans = new ArrayList<Integer>();\n\t\tString line = in.readLine();\n\n\t\tint size = Integer.parseInt(line);\n\n\t\tfor(int n=0; n<size; n++){\n\t\t\tline = in.readLine();\n\t\t\tint a = SC(line);\n\t\t\tans.add(a);\n\t\t}\n\n\t\tfor(int i=0; i<ans.size(); i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\n\tpublic int SC(String line){\n\t\tList<String> eq = new ArrayList<String>();\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tString str = line.substring(count, count+1);\n\t\t\tif(str.equals(\"=\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq.add(str);\n\t\t\tcount++;\n\t\t}\n\n\t\tcount = 0;\n\t\twhile(count < eq.size()-1){\n\t\t\tif(isNumber(eq.get(count)) && isNumber(eq.get(count+1))){\n\t\t\t\tString dst = eq.get(count) + eq.get(count+1);\n\t\t\t\teq.add(count+2, dst);\n\t\t\t\teq.remove(count);\n\t\t\t\teq.remove(count);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\n\t\twhile(eq.size() != 1){\n\t\t\tfor(int i=0; i<eq.size(); i++){\n\t\t\t\tSystem.out.print(eq.get(i));\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\t//ツ環古環づ個計ツ算\n\t\t\tint bra_count = 0;\n\t\t\tint n = eq.indexOf(\"(\");\n\t\t\tif(n != -1){\n\t\t\t\tfor(int i=n+1; i<eq.size(); i++){\n\t\t\t\t\tif(eq.get(i).equals(\")\") && bra_count == 0){\n\t\t\t\t\t\teq = RangeReplace(eq, n, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\"(\")){\n\t\t\t\t\t\tbra_count++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(eq.get(i).equals(\")\")){\n\t\t\t\t\t\tbra_count--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ掛ツつッツ算ツ環づィツ算\n\t\t\tn = eq.indexOf(\"*\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) * Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = eq.indexOf(\"/\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) / Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//ツ堕ォツつオツ算ツ暗クツつォツ算\n\t\t\tn = eq.indexOf(\"+\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) + Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = eq.indexOf(\"-\");\n\t\t\tif(n != -1){\n\t\t\t\tint a = Integer.parseInt(eq.get(n-1)) - Integer.parseInt(eq.get(n+1));\n\t\t\t\teq.add(n+2, Integer.toString(a));\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\teq.remove(n-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn Integer.parseInt(eq.get(0));\n\t}\n\n\tpublic List<String> RangeReplace(List<String> eq, int s, int e){\n\t\tString part = \"\";\n\n\t\tfor(int i=s+1; i<e; i++){\n\t\t\tpart += eq.get(i);\n\t\t}\n\n\t\tpart = Integer.toString(SC(part+\"=\"));\n\n\t\teq.add(e+1, part);\n\n\t\tfor(int i=s; i<=e; i++){\n\t\t\teq.remove(s);\n\t\t}\n\n\t\treturn eq;\n\t}\n\n\tpublic boolean isNumber(String s){\n\t\ttry{\n\t\t\tint n = Integer.parseInt(s);\n\t\t}catch(NumberFormatException err){\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//Volume1-0109\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n\n\t//declare\n\tprivate static final int                   NUM   = 1,\n\t\t\t                                   OPE1  = 2,\n\t\t\t                                   OPE2  = 3,\n\t\t\t                                   SPRN  = 4,\n\t\t\t                                   EPRN  = 5,\n\t\t\t                                   EQ    = 6;\n\tprivate static final String                regex = \"([0-9]+|\\\\+|-|\\\\*|/|\\\\(|\\\\)|=)(.*)\";\n\tprivate static       ArrayList<String>     t     = new ArrayList<String>(),\n\t\t\t                                   rpn   = new ArrayList<String>();\n\tprivate static       ArrayDeque<String>    stack = new ArrayDeque<String>();\n\tprivate static       ArrayDeque<Integer>   ans   = new ArrayDeque<Integer>();\n\n\n\tpublic static void main(String[] args){\n\n\t\tMatcher m;\n \t\tString  s;\n \t\tint     n;\n\n\t\t//initialize\n\t\tPattern token = Pattern.compile(regex);\n\n\t\t//input\n        Scanner sc = new Scanner(System.in);\n        n = Integer.parseInt(sc.nextLine());\n        while(n-- > 0){\n        \tt.clear();\n        \trpn.clear();\n        \tstack.clear();\n        \ts = sc.nextLine();\n        \twhile(s.length() != 0){\n        \t\tm = token.matcher(s);\n        \t\tif(m.find()){\n        \t\t\tt.add(m.group(1));\n        \t\t\ts = m.group(2);\n        \t\t}\n        \t}\n\n        \t//calculate\n        \tchg_notation();\n        \tcalc();\n\n        \t//output\n        \tSystem.out.println(ans.pop());\n        }\n\t}\n\n\tprivate static void calc(){\n\n\t\tint kind,a,b;\n\t\tfor(String tkn:rpn){\n\t\t\tkind = isKind(tkn);\n\t\t\tif(kind == NUM){\n\t\t\t\tans.push(Integer.parseInt(tkn));\n\t\t\t}else if(tkn.equals(\"+\")){\n\t\t\t\tans.push(ans.pop()+ans.pop());\n\t\t\t}else if(tkn.equals(\"-\")){\n\t\t\t\tb = ans.pop();\n\t\t\t\ta = ans.pop();\n\t\t\t\tans.push(a-b);\n\t\t\t}else if(tkn.equals(\"*\")){\n\t\t\t\tans.push(ans.pop()*ans.pop());\n\t\t\t}else if(tkn.equals(\"/\")){\n\t\t\t\tb = ans.pop();\n\t\t\t\ta = ans.pop();\n\t\t\t\tans.push(a/b);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void chg_notation(){\n    \tout:for(String tkn:t){\n    \t\tswitch(isKind(tkn)) {\n    \t\t\tcase NUM  : {rpn.add(tkn);break;}\n    \t\t\tcase OPE1 : {\n    \t\t\t\tString top = stack.peek();\n    \t\t\t\tif(top != null && isKind(top) == OPE2){\n    \t\t\t\t\trpn.add(stack.pop());\n    \t\t\t\t}\n    \t\t\t\tstack.push(tkn);\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tcase OPE2 :{}\n        \t    case SPRN :{\n    \t\t\t\tstack.push(tkn);\n    \t\t\t\tbreak;\n        \t    }\n        \t    case EPRN :{\n        \t    \tString e;\n        \t    \twhile(true){\n        \t    \t\te = stack.pop();\n        \t    \t\tif(isKind(e) != SPRN){\n        \t    \t\t\trpn.add(e);\n        \t    \t\t} else {\n        \t    \t\t\tbreak;\n        \t    \t\t}\n        \t    \t}\n        \t    \tbreak;\n        \t    }\n        \t    case EQ : {\n        \t    \tfor(String e:stack){\n        \t    \t\trpn.add(e);\n        \t    \t}\n        \t    \tbreak out;\n        \t    }\n        \t}\n    \t}\n\t}\n\n\tprivate static int isKind(String s){\n\t\tint ret = -1;\n\t\tif     (s.matches(\"[0-9]+\")) {ret = 1;}\n\t\telse if(s.matches(\"(\\\\+|-)\")){ret = 2;}\n\t\telse if(s.matches(\"(\\\\*|/)\")){ret = 3;}\n\t\telse if(s.matches(\"\\\\(\"))    {ret = 4;}\n\t\telse if(s.matches(\"\\\\)\"))    {ret = 5;}\n\t\telse if(s.matches(\"=\"))      {ret = 6;}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine);\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tif(expr.indexOf(\"-\",m)>m+1){\n\t\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\ttry{\n\t\t\tif(expr.length()>6 && expr.substring(0, 6).equals(\"radius\")){\n\t\t\t\treturn doCalc1(expr.substring(6))/180*Math.PI;\n\t\t\t}\n\t\t\telse if(expr.length()>3 && expr.substring(0, 3).equals(\"sin\")){\n\t\t\t\treturn Math.sin(doCalc1(expr.substring(3)));\n\t\t\t}\n\t\t\telse if(expr.length()>3 && expr.substring(0, 3).equals(\"cos\")){\n\t\t\t\treturn Math.cos(doCalc1(expr.substring(3)));\n\t\t\t}\n\t\t\telse if(expr.length()>3 && expr.substring(0, 3).equals(\"tan\")){\n\t\t\t\treturn Math.tan(doCalc1(expr.substring(3)));\n\t\t\t}\n\t\t\telse if(expr.substring(0, 1).equals(\"r\")){\n\t\t\t\treturn Math.sqrt(doCalc1(expr.substring(1)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn doCalc0(expr);\n\t\t\t}\n\t\t} catch (NullPointerException e){\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tInteger doCalc0(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n    int p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        while(n-->0){\n            in = sc.next().toCharArray();\n            p = 0;     \n            System.out.println(expr());            \n        }\n    }\n\n    int expr(){\n        int a = term();\n        while(in[p]=='+' || in[p]=='-'){\n            boolean boo = in[p]=='+';\n            p++;\n            int b = term();\n            if(boo) a += b;\n            else a -= b;\n        }\n        return a;\n    }\n\n    int term(){\n        int a = factor();\n        while(in[p]=='*' || in[p]=='/'){\n            boolean boo = in[p]=='*';\n            p++;\n            int b = factor();\n            if(boo) a *= b;\n            else a /= b;\n        }\n        return a;\n    }\n\n    int factor(){\n        if(in[p]=='('){\n            p++;\n            int res = expr();\n            p++;\n            return res;\n        }\n        else return digit();\n    }\n\n    int digit(){\n        int res = 0;\n        while(Character.isDigit(in[p])){\n            res = res*10 + (in[p]-'0');\n            p++;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    char[] in;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\tint dataset = sc.nextInt();\n\twhile(dataset-->0){\n\t    in = sc.next().toCharArray();\n\t    System.out.println(expr(0, in.length-1));\n\t}\n    }\n\n    int expr(int l, int r){\n\tint depth = 0;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='(') depth++;\n\t    else if(in[i]==')') depth--;\n\n\t    if(depth!=0) continue;\n\t    if(in[i]=='+'){\n\t\tint nn = expr(l, i) + expr(i+1, r);\n\t\treturn nn;\n\t    }else if(in[i]=='-'){\n\t\tint nn = expr(l, i) - expr(i+1, r);\n\t\treturn nn;\n\t    }\n\t}\n\n\tint res = 0;\n\tint enzan = 2; // 0:+ , 1:- , 2:nothing\n\tint left = -1, right = -1;\n\tfor(int i=l; i<r; i++){\n\t    if(in[i]=='('){\n\t\tdepth++;\n\t\tif(left==-1){\n\t\t    left = i;\n\t\t    right = i;\n\t\t}\n\t    }else if(in[i]==')'){\n\t\tdepth--;\n\t\tif(depth==0){\n\t\t    if(enzan==0){\n\t\t\tres *= expr(left+1, i);\n\t\t    }\n\t\t    if(enzan==1) res /= expr(left+1, i);\n\t\t    if(enzan==2) res = expr(left+1, i);\n\t\t    left = right = -1;\n\t\t}\n\t    }else if(depth==0 && Character.isDigit(in[i])){\n\t\tif(enzan==0) res *= digit(i);\n\t\tif(enzan==1) res /= digit(i);\n\t\tif(enzan==2) res = digit(i);\n\t\twhile(i+1<in.length && Character.isDigit(in[i+1])){\n\t\t    i++;\n\t\t}\n\t    }else if(depth==0 && in[i]=='*' || in[i]=='/'){\n\t\tif(in[i]=='*') enzan = 0;\n\t\telse enzan = 1;\n\t    }\n\t}\n\n\treturn res;\n    }\n\n    int digit(int p){\n\tint res = 0, l = p;\n\twhile(p<in.length && Character.isDigit(in[p])) p++;\n\tfor(int i=l; i<p; i++)\n\t    res += (in[i]-'0') * (int)Math.pow(10, p-i-1);\n\treturn res;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tString s = sc.nextLine();\n\t\t\ts = s.substring(0, s.length()-1);\n\t\t\tSystem.out.println(calc(s));\n\t\t}\n\t\t\n\t}\n\tstatic String calc(String s){\n\t\tArrayList<String> list = split(\"(\"+s+\")\");\n\t\tint index1 = index1(list);\n\t\twhile(index1 != -1){\n\t\t\tint index2 = index2(list, index1);\n\t\t\tint indexOf = indexOf(\"*\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a*b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"*\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"/\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a/b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"/\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a+b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a-b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\t}\n\t\t\tlist.remove(index1);\n\t\t\tlist.remove(index2);\n\t\t\tindex1 = index1(list);\n\t\t}\n\t\treturn (String)list.get(0);\n\t}\n\t//)ÌCfbNX\n\tstatic int index1(ArrayList<String> list){\n\t\tfor(int i = 0 ; i < list.size() ; i++){\n\t\t\tif(((String)list.get(i)).equals(\")\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//)ÌèOÌ(ÌCfbNX\n\tstatic int index2(ArrayList<String> list, int index1){\n\t\tfor(int i = index1-1; i >= 0 ; i--){\n\t\t\tif(((String)list.get(i)).equals(\"(\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//*,/,+,-ÌCfbNX\n\tstatic int indexOf(String s, ArrayList<String> list, int index2, int index1){\n\t\tfor(int i = index2+1; i < index1; i++){\n\t\t\tif(((String)list.get(i)).equals(s)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic ArrayList<String> split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile(s.length() > 0){\n\t\t\tif(isInt(s.charAt(0))){\n\t\t\t\tint i = 0;\n\t\t\t\tString _s = \"\";\n\t\t\t\twhile(isInt(s.charAt(i))){\n\t\t\t\t\t_s += String.valueOf(s.charAt(i));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlist.add(_s);\n\t\t\t\tif(i == s.length()){\n\t\t\t\t\ts = \"\";\n\t\t\t\t}else{\n\t\t\t\t\ts = s.substring(i, s.length());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlist.add(String.valueOf(s.charAt(0)));\n\t\t\t\ts = s.substring(1, s.length());\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\nclass Main{\n\tpublic static void main(String[]z){try{\n\t\tScriptEngineManager factory = new ScriptEngineManager();\n\t\tScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n\n\t\tengine.eval(\"println('Hello JavaScript from Java.');\");\n\n\n\t}catch(Exception e){}}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tl = sc.next(); p = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\t\n\tString l; int p;\n\tchar next() {\n\t\treturn l.charAt(p++);\n\t}\n\t\n\tString exp() {\n\t\tBigDecimal v1 = new BigDecimal(term());\n\t\tchar c = next();\n\t\tif( c == '=' || c == ')' ) { p--; return v1.toString(); }\n\t\tBigDecimal v2 = new BigDecimal(exp());\n\t\tif( c == '+' ) return v1.add(v2).toString();\n\t\telse return v1.subtract(v2).toString();\n\t}\n\t\n\tString term() {\n\t\tBigDecimal v1 = new BigDecimal(val());\n\t\tchar c = next();\n\t\tif( c == '=' || c == '+' || c == '-' || c == ')' ) {p--; return v1.toString();}\n\t\tBigDecimal v2 = new BigDecimal(term());\n\t\tif( c == '*' ) return v1.multiply(v2).toString();\n\t\telse return v1.divide(v2).toString();\n\t}\n\t\n\tString val() {\n\t\tchar c = next();\n\t\tif( c == '(' ) {BigDecimal v = new BigDecimal(exp()); p++; return v.toString();}\n\t\tString v = \"\" + c;\n\t\tfor(c = next();'0'<=c && c<='9';c=next()) v += c;\n\t\tp--;\n\t\treturn v;\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n  public static void main (String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String out = \"\";\n    String dummy = scanner.nextLine();\n    while (scanner.hasNext()) {\n      String line = scanner.nextLine();\n      Deque<String> ou = new ArrayDeque<String>();\n      Deque<String> op = new ArrayDeque<String>();\n      for (int ii = 0; ii < line.length(); ii++) {\n        Character pp = line.charAt(ii);\n        String p = pp.toString();\n        if (p.equals(\"=\")) {\n          while (!op.isEmpty()) {\n            ou.addLast(op.removeLast());\n          }\n          break;\n        } else if (p.equals(\"+\") || p.equals(\"-\")) {\n          while (!op.isEmpty()) {\n            ou.addLast(op.removeLast());\n          }\n          op.addLast(p);\n        } else if (p.equals(\"*\") || p.equals(\"/\")) {\n          op.addLast(p);\n        } else {\n          ou.addLast(p);\n        }\n      }\n//System.out.println(ou.toString());\n      Deque<Integer> num = new ArrayDeque<Integer>();\n      while (!ou.isEmpty()) {\n        String p = ou.removeFirst();\n        if (p.equals(\"+\")) {\n          num.addLast(num.removeLast() + num.removeLast());\n        } else if (p.equals(\"-\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b - a);\n        } else if (p.equals(\"*\")) {\n          num.addLast(num.removeLast() * num.removeLast());\n        } else if (p.equals(\"/\")) {\n          int a = num.removeLast();\n          int b = num.removeLast();\n          num.addLast(b / a);\n        } else {\n          num.addLast(Integer.parseInt(p));\n        }\n      }\n      out += num.removeLast() + \"\\n\";\n    }\n    System.out.print(out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()-1));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\t\n\tint check(String expr){\n\t\tint count=0;\n\t\tint n=-1;\n\t\twhile(n<expr.length()){\n\t\t\tn=expr.indexOf(\"(\",n+1);\n\t\t\tif(n!=-1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn=-1;\n\t\twhile(n<expr.length()){\n\t\t\tn=expr.indexOf(\")\",n+1);\n\t\t\tif(n!=-1){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tString[] param=expr.split(\"\\\\Q+\\\\E\");\n\t\tint m;\n\t\tArrayList<String> sp=new ArrayList<String>();\n\t\tfor(m=0;m<param.length;m++){\n\t\t\tString[] str=param[m].split(\"-\");\n\t\t\tfor(int n=0;n<str.length;n++){\n\t\t\t\tsp.add(str[n]);\n\t\t\t\tsp.add(\"-\");\n\t\t\t}\n\t\t\tsp.remove(sp.size()-1);\n\t\t\tsp.add(\"+\");\n\t\t}\n\t\tsp.remove(sp.size()-1);\n\t\t\n\t\tm=0;\n\t\twhile(m<sp.size()){\n\t\t\tint n=check(sp.get(m));\n\t\t\tif(n==0){\n\t\t\t\tnum.add(sp.get(m));\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString str=sp.get(m);\n\t\t\t\tdo{\n\t\t\t\t\tm++;\n\t\t\t\t\tstr+=sp.get(m);\n\t\t\t\t} while(check(str)!=0);\n\t\t\t\tnum.add(str);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tString[] param=expr.split(\"\\\\Q*\\\\E\");\n\t\tint m;\n\t\tArrayList<String> sp=new ArrayList<String>();\n\t\tfor(m=0;m<param.length;m++){\n\t\t\tString[] str=param[m].split(\"/\");\n\t\t\tfor(int n=0;n<str.length;n++){\n\t\t\t\tsp.add(str[n]);\n\t\t\t\tsp.add(\"/\");\n\t\t\t}\n\t\t\tsp.remove(sp.size()-1);\n\t\t\tsp.add(\"*\");\n\t\t}\n\t\tsp.remove(sp.size()-1);\n\t\t\n\t\tm=0;\n\t\twhile(m<sp.size()){\n\t\t\tint n=check(sp.get(m));\n\t\t\tif(n==0){\n\t\t\t\tnum.add(sp.get(m));\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString str=sp.get(m);\n\t\t\t\tdo{\n\t\t\t\t\tm++;\n\t\t\t\t\tstr+=sp.get(m);\n\t\t\t\t} while(check(str)!=0);\n\t\t\t\tnum.add(str);\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\tint n=check(expr);\n\t\t\t\tif(n==0){\n\t\t\t\t\treturn doCalc3(expr.substring(1,expr.length()-1));\n\t\t\t\t}\n\t\t\t\telse if(n>0){\n\t\t\t\t\tSystem.err.println(\"(が多いか)が足りません。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.err.println(\")が多いか(が足りません。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse if(expr.charAt(0)!=')'){\n\t\t\ttry {\n\t\t\t\treturn new Integer(expr);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\treturn null;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) throws ScriptException {\n\t\tScriptEngineManager factory = new ScriptEngineManager();\n\t\tScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\twhile(n-- != 0){\n\t\t\tString query = sc.nextLine();\n\t\t\tengine.eval(\"println(\" + query.substring(0, query.length() - 1) + \");\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    \n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        \n        int t = sc.nextInt();\n        while(t-->0){\n            String line = sc.next();\n            \n            int ans = calc(line.substring(0,line.length()-1));\n            System.out.println(ans);\n        }\n    }\n    \n    int calc(String line){\n        \n        String newLine = \"\";\n        for(int i=0; i<line.length(); i++){\n            if(line.charAt(i)=='('){\n                int idx = i;\n                int left = 1;\n                int right = 0;\n                while(right!=left){\n                    idx++;\n                    if(line.charAt(idx)==')'){\n                        right++;\n                    }else if(line.charAt(idx)=='('){\n                        left++;\n                    }\n                }\n                newLine += calc(line.substring(i+1,idx));\n                i = idx;\n            }else newLine += line.charAt(i);\n        }\n        \n        ArrayList<Integer> list = new ArrayList<Integer>();\n        ArrayList<Character> list2 = new ArrayList<Character>();\n        String tmp = \"\";\n        for(int i=0; i<newLine.length(); i++){\n            char c = newLine.charAt(i);\n            if(c=='*' || c=='/' || c=='+' || c=='-'){\n                list.add(Integer.parseInt(tmp));\n                tmp = \"\";\n                list2.add(c);\n            }else{\n                tmp += c;\n            }\n        }\n        list.add(Integer.parseInt(tmp));\n        \n        for(int i=0; i<list2.size(); i++){\n            char c = list2.get(i);\n            if(c=='*' || c=='/'){\n                int n1 = list.get(i);\n                int n2 = list.get(i+1);\n                if(c=='*'){\n                    list.set(i, n1*n2);\n                }else{\n                    list.set(i, n1/n2);\n                }\n                list.remove(i+1);\n                list2.remove(i);\n                i--;\n            }\n        }\n        \n        int ans = list.get(0);\n        for(int i=0; i<list2.size(); i++){\n            char c = list2.get(i);\n            if(c=='+'){\n                ans += list.get(i+1);\n            }else{\n                ans -= list.get(i+1);\n            }\n        }\n        \n        return ans;\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<Long> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<Long>();\n\t}\n\t\n\tprivate void calculate(){\n\t\tlong n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = Long.parseLong(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a+b);\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a-b);\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a*b);\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic long getResult(){\n\t\tcalculate();\n\t\treturn stack.pop();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\tprivate boolean[] minusFlag;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tminusFlag = new boolean[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\tminusFlag[current] = true;\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if(tmp == '-'){\n\t\t\t\t\tif(!minusFlag[current]){\n\t\t\t\t\t\trpn += tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t\t}\n\t\t\t\t}else if(tmp == '+'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t\tminusFlag[current] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic char[] s;\n\tstatic int id;\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=fact();\n\t\t\telse if(c=='/')r/=fact();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn -fact();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn fact();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\n}\nclass SC {\n\tprivate BufferedReader reader = null;\n\tprivate StringTokenizer tokenizer = null;\n\tpublic SC(InputStream in) {\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t}\n\tpublic String next() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\tpublic String nextLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=fact();\n\t\t\telse if(c=='/')r/=fact();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tif(c=='-'){\n\t\t\treturn s[id]=='('?-exp():-term();\n\t\t}\n\t\tif(c=='+'){\n\t\t\treturn s[id]=='('?exp():term();\n\t\t}\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\npublic class Main {\n\tString str;\n\tint ans, pos;\n\t//0352 start\n\t//0405 cording end\n\t//0406 WA\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tstr = sc.next();\n\t\t\tans = 0;\n\t\t\tpos = 0;\n\t\t\tint res = exp();\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\twhile(true){\n\t\t\tchar op = str.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+': \n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int term() {\n\t\tint res = fact();\n\t\twhile(true){\n\t\t\tchar op = str.charAt(pos);\n\t\t\tif((op == '*') || (op == '/')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tswitch(op){\n\t\t\t\tcase '*':\n\t\t\t\t\tres = old * res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tres = old / res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int fact() {\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tint t = str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt = t * 10 + (str.charAt(pos) - '0');\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\treturn t;\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint res = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Smart Calculator\nimport java.util.*;\n\npublic class Main {\n\tstatic int pos;\n\tstatic String formura;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tformura = scanner.next();\n\t\t\tpos = 0;\n\t\t\tint result = expression();\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic int expression() {\n\t\tint result = 0;\n\t\tint a = term();\n\t\tresult += a;\n\t\twhile (pos < formura.length()\n\t\t\t\t&& (formura.charAt(pos) == '+' || formura.charAt(pos) == '-')) {\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = term();\n\t\t\tif (op == '+')\n\t\t\t\tresult += b;\n\t\t\telse\n\t\t\t\tresult -= b;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = 0;\n\t\tint a = factor();\n\t\tresult += a;\n\t\twhile (pos < formura.length()\n\t\t\t\t&& (formura.charAt(pos) == '*' || formura.charAt(pos) == '/')) {\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = factor();\n\t\t\tif (op == '*')\n\t\t\t\tresult *= b;\n\t\t\telse\n\t\t\t\tresult /= b;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int factor() {\n\t\tint result = 0;\n\t\tif (formura.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tresult = expression();\n\t\t} else {\n\t\t\twhile (pos < formura.length()\n\t\t\t\t\t&& Character.isDigit(formura.charAt(pos))) {\n\t\t\t\tresult *= 10;\n\t\t\t\tresult += Character.getNumericValue(formura.charAt(pos));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char a) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\t\t//()内は無視\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif(a==c && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tstatic int parse(String str) {\t\t\n\t\t\n\t\tint a = str.length();\n\t\tif(str.startsWith(\"(\") && str.endsWith(\")\")) {\t\t\t\t//(で始まり)で終わる\n\t\t\tif(!str.substring(1, a-1).contains(\"(\"))\t\t\t\t//間に()がなければsubstr\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\tif( str.lastIndexOf(\"(\",a-2) < str.lastIndexOf(\")\", a-2))//()*()のようなものは×\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t}\n\t\t\n\t\tint ind = lastInd(str,'-');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) - parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'+');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) + parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'/');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) / parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'*');\n\t\tif(ind!=-1){\n\t\t\treturn parse(str.substring(0, ind)) * parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\t\n\tstatic int exp(){\n\t\tint r = term();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='+')r+=term();\n\t\t\telse if(c=='-')r-=term();\n\t\t\telse break;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tstatic int term(){\n\t\tint r = fact();\n\t\twhile(true){\n\t\t\tchar c = s[id++];\n\t\t\tif(c=='*') r*=term();\n\t\t\telse if(c=='/')r/=term();\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn r;\n\t}\n\t\n\tstatic int fact(){\n\t\tchar c = s[id++];\n\t\tif(c=='(')return exp();\n\t\tint x = c-'0';\n\t\twhile(true){\n\t\t\tc = s[id++];\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tx *= 10;\n\t\t\t\tx += c-'0';\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\ts = sc.next().toCharArray();\n\t\t\tid = 0;\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import javax.script.*;\nclass Main{\n\tpublic static void main(String[]z){\n        ScriptEngineManager factory = new ScriptEngineManager();\n        ScriptEngine engine = factory.getEngineByName(\"JavaScript\");\n       \n        engine.eval(\"println('Hello JavaScript from Java.')\");\n       \n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "def calc(array):\n\twhile not len(array) == 1:\n\t\tif '*' in array:\n\t\t\tx = array.index('*')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) * int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\t\tif '/' in array:\n\t\t\tx = array.index('/')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) / int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\t\tif '-' in array:\n\t\t\tx = array.index('-')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) - int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\t\tif '+' in array:\n\t\t\tx = array.index('+')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) + int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\treturn str(array[0])\n\nn = input()\nfor i in xrange(n):\n\tarray = list(raw_input())\n\t\n\twhile '(' in array:\n\t\tx1 = array.index('(') + 1\n\t\tx2 = array.index(')')\n\t\tjon = array[x1:x2]\n\t\tarray[x2] = calc(jon)\n\t\tdel array[x1 - 1:x2]\n\tprint calc(array[0:len(array) - 1])"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tl = sc.next(); p = 0;\n                        debug(l);\n\t\t\tSystem.out.println(exp());\n\t\t}\n\t}\n\t\n\tString l; int p;\n\tchar next() {\n\t\treturn l.charAt(p++);\n\t}\n\t\n\tString exp() {\n\t\tBigDecimal v1 = new BigDecimal(term());\n\t\tchar c = next();\n\t\tif( c == '=' || c == ')' ) { p--; return v1.toString(); }\n\t\tBigDecimal v2 = new BigDecimal(exp());\n\t\tif( c == '+' ) return v1.add(v2).toString();\n\t\telse return v1.subtract(v2).toString();\n\t}\n\t\n\tString term() {\n\t\tBigDecimal v1 = new BigDecimal(val());\n\t\tchar c = next();\n\t\tif( c == '=' || c == '+' || c == '-' || c == ')' ) {p--; return v1.toString();}\n\t\tBigDecimal v2 = new BigDecimal(term());\n\t\tif( c == '*' ) return v1.multiply(v2).toString();\n\t\telse return v1.divideToIntegralValue(v2).toString();\n\t}\n\t\n\tString val() {\n\t\tchar c = next();\n\t\tif( c == '(' ) {BigDecimal v = new BigDecimal(exp()); p++; return v.toString();}\n\t\tString v = \"\" + c;\n\t\tfor(c = next();'0'<=c && c<='9';c=next()) v += c;\n\t\tp--;\n\t\treturn v;\n\t}\n\t\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n    public static class Calculator {\n        private char[] input;\n        private int ptr;\n\n        public Calculator(char[] input) {\n            this.input = input;\n            this.ptr = 0;\n        }\n\n        private int expr() {\n            int value = term();\n            while (input[ptr] == '+' || input[ptr] == '-') {\n                if (input[ptr] == '+') {\n                    ptr++;\n                    value += term();\n                } else {\n                    ptr++;\n                    value -= term();\n                }\n            }\n            return value;\n        }\n\n        private int term() {\n            int value = factor();\n            while (input[ptr] == '*' || input[ptr] == '/') {\n                if (input[ptr] == '*') {\n                    ptr++;\n                    value *= factor();\n                } else {\n                    ptr++;\n                    value /= factor();\n                }\n            }\n            return value;\n        }\n\n        private int factor() {\n            int value;\n            if (input[ptr] == '(') {\n                ptr++;\n                value = expr();\n                assert input[ptr] == ')';\n                ptr++;\n            } else {\n                value = number();\n            }\n            return value;\n        }\n\n        private int number() {\n            StringBuilder number = new StringBuilder();\n            while (Character.isDigit(input[ptr])) {\n                number.append(input[ptr++]);\n            }\n            return Integer.valueOf(number.toString());\n        }\n\n        public int run() {\n            int value = expr();\n            assert input[ptr] == '=';\n            return value;\n        }\n    }\n\n    private static void solve() {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n\n        for (int i = 0; i < n; i++) {\n            char[] input = scanner.next().toCharArray();\n            System.out.println(new Calculator(input).run());\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\tprivate\tstatic\tTermTbl\t\t\ttt = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\ttt = new TermTbl();\n\t\ttt.put('+', 1);\n\t\ttt.put('-', 1);\n\t\ttt.put('*', 2);\n\t\ttt.put('/', 2);\n\t}\n \n    /**\n     * @param args\n     */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tnum = parseNum();\n\n\t\twhile (num-- > 0) {\n\t\t\tStack\tformula = parseFormula();\n\t\t\tSystem.out.println(calc(formula));\n\t\t}\n\t}\n\n\tprivate static int calc(Stack formula) {\n\t\tStack\tstk = new Stack();\n\t\tObject\tobj = null;\n\t\tObject\ttrm = null;\n\t\tint\t\tsize = formula.size();\n\t\tint\t\tres  = 0;\n\n\t\t// 数式を逆ポーランド記法に変換\n\t\tfor (int l = 0; l < size; l++) {\n\t\t\tobj = formula.get(l);\n\t\t\tif (obj instanceof Character) {\n\t\t\t\tswitch ((Character)obj) {\n\t\t\t\tcase\t'+':\n\t\t\t\tcase\t'-':\n\t\t\t\tcase\t'*':\n\t\t\t\tcase\t'/':\n\t\t\t\t\ttrm = obj;\n\t\t\t\t\tbreak;\n\t\t\t\tcase\t'=':\n\t\t\t\t\tbreak;\n\t\t\t\tcase\t'(':\n\t\t\t\t\t{\n\t\t\t\t\t\tStack\tins = new Stack();\n\t\t\t\t\t\tint\t\tper = 1;\n\t\t\t\t\t\tfor(int i = l; i < size && per > 0;) {\n\t\t\t\t\t\t\tformula.remove(i);\n\t\t\t\t\t\t\tsize--;\n\t\t\t\t\t\t\tObject\ttmp = formula.get(i);\n\t\t\t\t\t\t\tif (tmp instanceof Integer) {\n\t\t\t\t\t\t\t\tins.push(tmp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tswitch ((Character)tmp) {\n\t\t\t\t\t\t\t\tcase\t'(':\n\t\t\t\t\t\t\t\t\tper++;\n\t\t\t\t\t\t\t\t\tins.push(tmp);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase\t')':\n\t\t\t\t\t\t\t\t\tper--;\n\t\t\t\t\t\t\t\t\tif (per > 0) {\n\t\t\t\t\t\t\t\t\t\tins.push(tmp);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tins.push((Character)'=');\n\t\t\t\t\t\t\t\t\t\tformula.remove(i);\n\t\t\t\t\t\t\t\t\t\tformula.insertElementAt((Integer)calc(ins), l--);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tins.push(tmp);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (obj instanceof Integer) {\n\t\t\t\tif (trm == null) {\n\t\t\t\t\tstk.push(obj);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = stk.size() - 1; i >= 0; i--) {\n\t\t\t\t\t\tObject\ttmp = stk.get(i);\n\t\t\t\t\t\tif (tmp instanceof Character) {\n\t\t\t\t\t\t\tif (tt.get(trm) <= tt.get(tmp)) {\n\t\t\t\t\t\t\t\tstk.insertElementAt(obj, i+1);\n\t\t\t\t\t\t\t\tstk.insertElementAt(trm, i+2);\n\t\t\t\t\t\t\t\ttrm = null;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstk.insertElementAt(obj, i+1);\n\t\t\t\t\t\t\tstk.insertElementAt(trm, i+2);\n\t\t\t\t\t\t\ttrm = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 数式を計算\n\t\tsize = stk.size();\n\t\tfor (int l = 0; l < size; l++) {\n\t\t\tObject\ttmp = stk.get(l);\n\t\t\tInteger\ta   = null;\n\t\t\tInteger\tb   = null;\n\t\t\tObject\tc   = 0;\n\t\t\tif (tmp instanceof Character) {\n\t\t\t\ta = (Integer)stk.get(l-2);\n\t\t\t\tstk.remove(l-2);\n\t\t\t\tb = (Integer)stk.get(l-2);\n\t\t\t\tstk.remove(l-2);\n\n\t\t\t\tswitch ((Character)tmp) {\n\t\t\t\tcase\t'+':\n\t\t\t\t\tc = a + b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase\t'-':\n\t\t\t\t\tc = a - b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase\t'*':\n\t\t\t\t\tc = a * b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase\t'/':\n\t\t\t\t\tc = a / b;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstk.remove(l-2);\n\t\t\t\tstk.insertElementAt(c, l-2);\n\t\t\t\tl    -= 3;\n\t\t\t\tsize -= 2;\n\t\t\t}\n\t\t}\n\n\t\tif (stk.get(0) instanceof Integer) {\n\t\t\tres = (Integer)stk.get(0);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum = 0;\n\t\tString\tstr = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(str);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tprivate static Stack parseFormula() {\n\t\tStack\tformula = null;\n\t\tString\tstr     = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tint\t\tsize = str.length();\n\t\t\tInteger\tnum  = 0;\n\n\t\t\tformula = new Stack();\n\t\t\tfor\t(int l = 0; l < size; l++) {\n\t\t\t\tCharacter\tchr = str.charAt(l);\n\t\t\t\tif (Character.isDigit(chr)) {\n\t\t\t\t\tif (l > 0) {\n\t\t\t\t\t\tif (Character.isDigit(str.charAt(l-1))) {\n\t\t\t\t\t\t\tnum *= 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnum += (int)(chr - '0');\n\t\t\t\t} else {\n\t\t\t\t\tif (l > 0) {\n\t\t\t\t\t\tif (Character.isDigit(str.charAt(l-1))) {\n\t\t\t\t\t\t\tformula.push(num);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tformula.push(chr);\n\t\t\t\t\tnum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn formula;\n\t}\n\n\tprivate static String parseStdin() {\n        String  stdin = null;\n        \n        try {\n        \tString  tmp = br.readLine();\n        \tif (tmp != null) {\n            \tif (!tmp.isEmpty()) {\n            \t\tstdin = tmp;\n            \t}\n        \t}\n        }\n        catch (IOException e) {}\n \n        return stdin;\n\t}\n}\n\nclass TermTbl extends HashMap<Character, Integer> {\n}"
  },
  {
    "language": "Java",
    "code": "// Smart Calculator\nimport java.util.*;\n\npublic class Main {\n\tstatic int pos;\n\tstatic String formura;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tformura = scanner.next();\n\t\t\tpos = 0;\n\t\t\tint result = expression();\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic int expression() {\n\t\tint result = 0;\n\t\tint a = term();\n\t\tresult += a;\n\t\twhile (pos < formura.length()\n\t\t\t\t&& (formura.charAt(pos) == '+' || formura.charAt(pos) == '-')) {\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = term();\n\t\t\tif (op == '+')\n\t\t\t\tresult += b;\n\t\t\telse\n\t\t\t\tresult -= b;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int term() {\n\t\tint result = 0;\n\t\tint a = factor();\n\t\tresult += a;\n\t\twhile (pos < formura.length()\n\t\t\t\t&& (formura.charAt(pos) == '*' || formura.charAt(pos) == '/')) {\n\t\t\tchar op = formura.charAt(pos);\n\t\t\tpos++;\n\t\t\tint b = factor();\n\t\t\tif (op == '*')\n\t\t\t\tresult *= b;\n\t\t\telse\n\t\t\t\tresult /= b;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int factor() {\n\t\tint result = 0;\n\t\tif (formura.charAt(pos) == '(') {\n\t\t\tpos++;\n\t\t\tresult = expression();\n\t\t} else {\n\t\t\twhile (Character.isDigit(formura.charAt(pos))) {\n\t\t\t\tresult *= 10;\n\t\t\t\tresult += Character.getNumericValue(formura.charAt(pos));\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tprivate int p;\n\tprivate String line;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint lines = Integer.parseInt(sc.nextLine());\n\n\t\tfor (int i = 0; i < lines; i++) {\n\t\t\tline = sc.nextLine();\n\t\t\t\n\t\t\tp = 0;\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\n\tprivate int expression() {\n\t\tint value = term();\n\t\t\n\t\treturn sub_expression(value);\n\t}\n\t\n\tprivate int sub_expression(int value) {\n\t\tif (line.charAt(p) == '+') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value + term();\n\t\t\tvalue = sub_expression(value);\n\t\t} else if (line.charAt(p) == '-') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value - term();\n\t\t\tvalue = sub_expression(value);\n\t\t}\n\t\t\n\t\treturn value;\n\t}\n\t\n\tprivate int term() {\n\t\tint value = factor();\n\t\t\n\t\treturn sub_term(value);\n\t}\n\t\t\n\tprivate int sub_term(int value) {\n\t\tif (line.charAt(p) == '*') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value * factor();\n\t\t\tvalue = sub_term(value);\n\t\t} else if (line.charAt(p) == '/') {\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = value / factor();\n\t\t\tvalue = sub_term(value);\n\t\t}\n\t\t\n\t\treturn value;\n\t}\n\t\n\tprivate int factor() {\n\t\tint value = 0;\n\t\tswitch (line.charAt(p)) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tvalue = Integer.parseInt(\"\" + line.charAt(p));\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\t\n\t\t\tvalue = expression();\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\treturn value;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tRPN rpn;\n\t\tCalculator c;\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\trpn = new RPN(sc.nextLine());\n\t\t\tc = new Calculator(rpn.toRPN());\n\t\t\tSystem.out.println(c.getResult());\n\t\t}\n\t}\n}\n\nclass Calculator{\n\tprivate String[] formula;\n\tprivate Stack<Integer> stack;\n\t\n\tpublic Calculator(String formula){\n\t\tthis.formula = formula.split(\" \");\n\t\tstack = new Stack<Integer>();\n\t\tstack.push(0);\n\t}\n\t\n\tprivate void calculate(){\n\t\tint n,a,b;\n\t\tfor(int i=0;i<formula.length;i++){\n\t\t\tif(formula[i].equals(\"\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry{\n\t\t\t\tn = Integer.parseInt(formula[i]);\n\t\t\t\tstack.push(n);\n\t\t\t}catch(NumberFormatException e){\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tif(formula[i].equals(\"+\")){\n\t\t\t\t\tstack.push(a+b);\n\t\t\t\t}else if(formula[i].equals(\"-\")){\n\t\t\t\t\tstack.push(a-b);\n\t\t\t\t}else if(formula[i].equals(\"*\")){\n\t\t\t\t\tstack.push(a*b);\n\t\t\t\t}else if(formula[i].equals(\"/\")){\n\t\t\t\t\tstack.push(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int getResult(){\n\t\tcalculate();\n\t\treturn stack.pop();\n\t}\n}\n\nclass RPN{\n\tprivate Stack<Character> stack;\n\tprivate String rpn,formula,tmp;\n\tprivate int[] opeNum,top;\n\tprivate int current;\n\tprivate ArrayList<Integer> leftParenthesis;\n\t\n\tpublic RPN(String formula){\n\t\tthis.formula = formula;\n\t\trpn = \"\";\n\t\topeNum = new int[100];\n\t\tcurrent = 0;\n\t\ttop = new int[100];\n\t\tleftParenthesis = new ArrayList<Integer>();\n\t\tstack = new Stack<Character>();\n\t}\n\t\n\tpublic String toRPN(){\n\t\tchar tmp;\n\t\tfor(int i=0;i<formula.length();i++){\n\t\t\ttmp = formula.charAt(i);\n\t\t\tif(Character.isDigit(tmp)){\n\t\t\t\trpn += tmp;\n\t\t\t}else{\n\t\t\t\tif(tmp == ')'){\n\t\t\t\t\tfor(int j=0;j<opeNum[current]-1;j++){\n\t\t\t\t\t\trpn += \" \";\n\t\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t\topeNum[current] = 0;\n\t\t\t\t\ttop[current] = 0;\n\t\t\t\t\tcurrent --;\n\t\t\t\t}else if(tmp == '('){\n\t\t\t\t\tstack.push(tmp);\n\t\t\t\t\tcurrent ++;\n\t\t\t\t\topeNum[current]++;\n\t\t\t\t}else if(tmp == '/'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(3,tmp);\n\t\t\t\t}else if(tmp == '*'){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(2,tmp);\n\t\t\t\t}else if((tmp == '+') || (tmp == '-')){\n\t\t\t\t\trpn += \" \";\n\t\t\t\t\tsetOperator(1,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<opeNum[0];i++){\n\t\t\trpn += \" \";\n\t\t\trpn += stack.pop();\n\t\t}\n\t\t\n\t\treturn rpn;\n\t}\n\t\n\tprivate void setOperator(int n,char tmp){\n\t\tif((current == 0) && (top[current] >= n)){\n\t\t\tfor(int i=0;i<opeNum[current];i++){\n\t\t\t\trpn += stack.pop();\n\t\t\t\trpn += \" \";\n\t\t\t}\n\t\t\tstack.push(tmp);\n\t\t\ttop[current] = n;\n\t\t\topeNum[current] = 1;\n\t\t}else{\n\t\t\tif(top[current] >= n){\n\t\t\t\tfor(int i=0;i<opeNum[current]-1;i++){\n\t\t\t\t\trpn += stack.pop();\n\t\t\t\t\trpn += \" \";\n\t\t\t\t}\n\t\t\t\tstack.push(tmp);\n\t\t\t\ttop[current] = top[current] - top[current]%10 + n;\n\t\t\t\topeNum[current] = 2;\n\t\t\t}else{\n\t\t\t\tstack.push(tmp);\n\t\t\t\topeNum[current]++;\n\t\t\t\ttop[current] = n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\npublic class Main {\n\tString str;\n\tint ans, pos;\n\t//0352 start\n\t//0405 cording end\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tstr = sc.next();\n\t\t\tans = 0;\n\t\t\tpos = 0;\n\t\t\tint res = exp();\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate int exp() {\n\t\tint res = term();\n\t\twhile(true){\n\t\t\tchar op = str.charAt(pos);\n\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = term();\n\t\t\t\tswitch(op){\n\t\t\t\tcase '+': \n\t\t\t\t\tres = old + res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tres = old - res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int term() {\n\t\tint res = fact();\n\t\twhile(true){\n\t\t\tchar op = str.charAt(pos);\n\t\t\tif((op == '*') || (op == '/')){\n\t\t\t\tint old = res;\n\t\t\t\tpos++;\n\t\t\t\tres = fact();\n\t\t\t\tswitch(op){\n\t\t\t\tcase '*':\n\t\t\t\t\tres = old * res;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tres = old * res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate int fact() {\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tint t = str.charAt(pos) - '0';\n\t\t\tpos++;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt = t * 10 + (str.charAt(pos) - '0');\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\treturn t;\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tint res = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\tint index = 0;\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\twhile (N-- > 0) {\n\t\t\tindex = 0;\n\t\t\tString input = sc.next();\n\t\t\tSystem.out.println(expression(new StringBuilder(input.substring(0,\n\t\t\t\t\tinput.length() - 1))));\n\t\t}\n\t}\n\n\tint expression(StringBuilder sb) {\n\t\tint res = term(sb);\n\t\tfor (; index < sb.length();) {\n\t\t\tif (sb.charAt(index) == '+') {\n\t\t\t\tindex++;\n\t\t\t\tres += term(sb);\n\t\t\t} else if (sb.charAt(index) == '-') {\n\t\t\t\tindex++;\n\t\t\t\tres -= term(sb);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint term(StringBuilder sb) {\n\t\tint res = factor(sb);\n\t\tfor (; index < sb.length();) {\n\t\t\tif (sb.charAt(index) == '*') {\n\t\t\t\tindex++;\n\t\t\t\tres *= factor(sb);\n\t\t\t} else if (sb.charAt(index) == '/') {\n\t\t\t\tindex++;\n\t\t\t\tres /= factor(sb);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint factor(StringBuilder sb) {\n\t\tint res = 0;\n\t\tif (index < sb.length() && sb.charAt(index) == '(') {\n\t\t\tindex++;\n\t\t\tres = expression(sb);\n\t\t\tindex++;\n\t\t} else {\n\t\t\tres = number(sb);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint number(StringBuilder sb) {\n\t\tint res = 0;\n\t\twhile (index < sb.length() && Character.isDigit(sb.charAt(index))) {\n\t\t\tres *= 10;\n\t\t\tres += sb.charAt(index) - '0';\n\t\t\tindex++;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tstatic int id;\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tid = 0;\n\t\t\tString[] list = split(sc.nextLine());\n\t\t\tSystem.out.println(calc(list));\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic int calc(String[] list){\n\t\tint value = 0;\n\t\tif(list[id].equals(\"(\")){\n\t\t\tid++;\n\t\t\tvalue = calc(list);\n\t\t}else{\n\t\t\tvalue = Integer.parseInt(list[id]);\n\t\t}\n\t\twhile(id < list.length-1){\n\t\t\tid++;\n\t\t\tif(list[id].equals(\"*\")){\n\t\t\t\tif(list[id+1].equals(\"(\")){\n\t\t\t\t\tid += 2;\n\t\t\t\t\tvalue *= calc(list);\n\t\t\t\t}else{\n\t\t\t\t\tvalue *= Integer.parseInt(list[++id]);\n\t\t\t\t}\n\t\t\t}else if(list[id].equals(\"/\")){\n\t\t\t\tif(list[id+1].equals(\"(\")){\n\t\t\t\t\tid += 2;\n\t\t\t\t\tvalue /= calc(list);\n\t\t\t\t}else{\n\t\t\t\t\tvalue /= Integer.parseInt(list[++id]);\n\t\t\t\t}\n\t\t\t}else if(list[id].equals(\"+\")){\n\t\t\t\tid++;\n\t\t\t\tif(list[id].equals(\"(\")){\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t\tvalue += calc(list);\n\t\t\t}else if(list[id].equals(\"-\")){\n\t\t\t\tid++;\n\t\t\t\tif(list[id].equals(\"(\")){\n\t\t\t\t\tid++;\n\t\t\t\t}\n\t\t\t\tvalue -= calc(list);\n\t\t\t}else if(list[id].equals(\")\")){\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\tstatic String[] split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\tString tmp = \"\";\n\t\tint length = s.length();\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(!isInt(s.charAt(i))){\n\t\t\t\tif(!tmp.equals(\"\")){\n\t\t\t\t\tlist.add(tmp);\n\t\t\t\t}\n\t\t\t\tlist.add(String.valueOf(s.charAt(i)));\n\t\t\t\ttmp = \"\";\n\t\t\t}else{\n\t\t\t\ttmp += s.charAt(i);\n\t\t\t}\n\t\t}\n\t\tString[] array = null;\n\t\treturn (String[])list.toArray(new String[list.size()]);\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Smart Calculator\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\t//skip first line\n\t\tbr.readLine();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tDeque<String> queue = new ArrayDeque<>();\n\t\t\tDeque<Character> stack = new ArrayDeque<>();\n\n\t\t\tchar _c = 0;\n\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '+':\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tif (!stack.isEmpty()) {\n\t\t\t\t\t\t\twhile (stack.peek() == '*' || stack.peek() == '/')){\n\t\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\tcase '/':\n\t\t\t\t\tcase '(':\n\t\t\t\t\t\tstack.push(c);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\t\twhile (stack.peek() != '(') {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '=':\n\t\t\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(stack.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ('0' <= _c && _c <= '9') {\n\t\t\t\t\t\t\tString s = queue.pollLast();\n\t\t\t\t\t\t\tqueue.offer(s + c);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqueue.offer(String.valueOf(c));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_c = c;\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tDeque<Integer> ans = new ArrayDeque<>();\n\t\t\tfor (String s : queue) {\n\t\t\t\tif (\"+-*/\".indexOf(s) != -1) {\n\t\t\t\t\tint a, b;\n\t\t\t\t\tb = ans.pop();\n\t\t\t\t\ta = ans.pop();\n\t\t\t\t\tswitch (s) {\n\t\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\t\tans.push(a + b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\tans.push(a - b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\tans.push(a * b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tans.push(a / b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tans.push(parseInt(s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans.peek());\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[101];\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tString input_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(line,0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tif((i != left) && ((line[i-1] >= '0' && line[i-1] <= '9') || line[i-1] == ')')){ //-は、depthが0でもnegの場合あり\n\t\t\t\t\t\tQ.add(i);\n\t\t\t\t\t}\n\t\t\t\t\twhile(i <=right && line[i] == '-')i++; //negの-が続いている場合があるので、読み飛ばす\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_E(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(char line[],int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(line,left,right);\n\t\t}\n\n\t\tint tmp = calc_T(line,left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(line,loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(line,loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(char line[],int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(line,left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -1*calc_F(line,left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(line,left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(char line[],int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.function.IntBinaryOperator;\n\npublic class Calc {\n\n    static int lastIndexOf(String e, char ch) {\n        int nest = 0;\n        for(int i = e.length()-1; i > 0 ; i--) {\n            char c = e.charAt(i);\n            if(c == ‘(’) {\n                nest++;\n            }\n            if(c == ‘)’) {\n                nest--;\n            }\n            if(ch == c && nest == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    static int parse(String e) {\n        if(e.startsWith(“(”) && e.endsWith(“)”)) {\n            return parse(e.substring(1, e.length()-1));\n        }\n        int loc = lastIndexOf(e, ‘-’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) - parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘+’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) + parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘/’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) / parse(e.substring(loc+1));\n        }\n        loc = lastIndexOf(e, ‘*’);\n        if(loc != -1) {\n            return parse(e.substring(0, loc)) * parse(e.substring(loc+1));\n        }\n        return Integer.parseInt(e);\n    }\n    \n    public static void main(String[] args) {\n        try(Scanner sc = new Scanner(System.in)) {\n            int n = sc.nextInt();\n            for(int i = 0; i < n; i++) {\n                String e = sc.next().replace(“=”, “”);\n                System.out.println(parse(e));\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\ts = new char[101];\n\t\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\t\ts[i]=str.charAt(i);\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\t}\n\tstatic int expression(){\n\t\tint res = term();\n\t\twhile(s[idx]=='+'||s[idx]=='-'){\n\t\t\tif(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres += term();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tidx++;\n\t\t\t\tres -= term();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\twhile(s[idx]=='*' || s[idx]=='/'){\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres *= fact();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tidx++;\n\t\t\t\tres /= fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\t//res = s[idx++]-'0';\n\t\t\tres = value();\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int value(){\n\t\tint a[]=new int[100];\n\t\tint count=0, sum=0;\n\t\twhile(true){\n\t\t\tif(s[idx]>='0'&& s[idx]<='9'){\n\t\t\t\ta[count++]=s[idx++]-'0';\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < count;i++){\n\t\t\tsum += (int) (a[i]*Math.pow(10, count-i-1));\n\t\t}\n\t\treturn sum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package practice;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\n\tprivate static final int BIG_NUM  = 2000000000;\n\tprivate static final int MOD  = 1000000007;\n\tprivate static char[] line;\n\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tline = new char[120];\n\t\tString input_str;\n\t\tint length;\n\n\t\ttry {\n\t\t\tint num_eq = Integer.parseInt(br.readLine());\n\n\t\t\tfor(int loop = 0; loop < num_eq; loop++){\n\n\t\t\t\tinput_str = br.readLine();\n\n\t\t\t\tlength = 0;\n\t\t\t\tfor(int i = 0; input_str.charAt(i) != '='; i++){\n\t\t\t\t\tline[i] = input_str.charAt(i);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(calc_E(0,length-1));\n\t\t\t}\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic static int calc_E(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、プラスまたは-を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '+' && line[i] != '-'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(line[i] == '+'){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}else{ //line[i] == '-'\n\t\t\t\t\tQ.add(i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の+-がない\n\t\t\treturn calc_T(left,right);\n\t\t}\n\n\t\tint tmp = calc_E(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_T(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_T(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '+'){\n\t\t\t\ttmp += tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp -= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tpublic static int calc_T(int left,int right){\n\t\tint depth = 0;\n\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\n\t\t//深さ0の、*,/を探す\n\t\tfor(int i = left; i <= right; ){\n\t\t\tif(line[i] == '(')depth++;\n\t\t\telse if(line[i] == ')')depth--;\n\n\t\t\tif(depth != 0){\n\t\t\t\ti++;\n\t\t\t}else if(line[i] != '*' && line[i] != '/'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tQ.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tif(Q.isEmpty()){ //深さ0の*,/がない\n\t\t\treturn calc_F(left,right);\n\t\t}\n\n\t\tint tmp = calc_T(left,Q.peek()-1),tmp_right;\n\n\t\tif(tmp == BIG_NUM)return BIG_NUM;\n\n\t\twhile(!Q.isEmpty()){\n\t\t\tint loc = Q.peek();\n\t\t\tQ.poll();\n\n\t\t\tif(Q.isEmpty()){\n\t\t\t\ttmp_right = calc_F(loc+1,right);\n\t\t\t}else{\n\t\t\t\ttmp_right = calc_F(loc+1,Q.peek()-1);\n\t\t\t}\n\n\t\t\tif(tmp_right == BIG_NUM){\n\t\t\t\treturn BIG_NUM;\n\t\t\t}\n\n\t\t\tif(line[loc] == '*'){\n\t\t\t\ttmp *= tmp_right;\n\t\t\t}else{\n\t\t\t\ttmp /= tmp_right;\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\tpublic static int calc_F(int left,int right){\n\n\t\tif(line[left] >= '0' && line[left] <= '9'){\n\t\t\treturn calc_NUM(left,right);\n\n\t\t}else if(line[left] == '-'){\n\t\t\treturn -calc_F(left+1,right);\n\t\t}else if(line[left] == '('){\n\n\t\t\tint depth = 0;\n\t\t\tint close_pos = BIG_NUM;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(line[i] == '(')depth++;\n\t\t\t\telse if(line[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tclose_pos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(close_pos == BIG_NUM || close_pos != right)return BIG_NUM;\n\n\t\t\treturn calc_E(left+1,close_pos-1);\n\t\t}else{\n\t\t\treturn BIG_NUM;\n\t\t}\n\t}\n\tpublic static int calc_NUM(int left,int right){\n\n\t\tint ret = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tret = 10*ret+line[i]-'0';\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic int k(String e,char c1,char c2) {\n\t\tint nest = 0;\n\t\tfor(int i=e.length()-1;i>=0;i--) {\n\t\t\tif(e.charAt(i) == ')') {\n\t\t\t\tnest++;\n\t\t\t}\n\t\t\tif(e.charAt(i) == '(') {\n\t\t\t\tnest--;\n\t\t\t}\n\t\t\tif((e.charAt(i) == c1 ||e.charAt(i) == c2) && nest==0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tstatic int calc(String e) {\n\t\tint pos = k(e,'+','-');\n\t\tif(pos!=-1) {\n\t\t\tif(e.charAt(pos)=='+') {\n\t\t\t\treturn calc(e.substring(0,pos)) + calc(e.substring(pos+1));\n\t\t\t}else {\n\t\t\t\treturn calc(e.substring(0,pos)) - calc(e.substring(pos+1));\n\t\t\t}\n\t\t}\n\t\tpos = k(e,'*','/');\n\t\tif(pos!=-1) {\n\t\t\tif(e.charAt(pos)=='*') {\n\t\t\t\treturn calc(e.substring(0,pos)) * calc(e.substring(pos+1));\n\t\t\t}else {\n\t\t\t\treturn calc(e.substring(0,pos)) / calc(e.substring(pos+1));\n\t\t\t}\n\t\t}\n\t\tif(e.startsWith(\"(\")) {\n\t\t\treturn calc(e.substring(1,e.length()-1));\n\t\t}\n\t\treturn Integer.parseInt(e);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tString e = sc.next();\n\t\t\tSystem.out.println(calc(e.substring(0,e.length()-1)));\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\npublic class Main {\n\t//0352 start\n\t//0405 cording end\n\t//0406 WA\n\t//0408 AC 00:09sec 1445byte\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tString str = sc.next();\n\t\t\tParse p = new Parse(str);\n\t\t\tint res = p.exp();\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tclass Parse{\n\t\tString str;\n\t\tint pos;\n\t\tpublic Parse(String str){\n\t\t\tthis.str = str;\n\t\t\tpos = 0;\n\t\t}\n\t\t\n\t\tprivate int exp() {\n\t\t\tint res = term();\n\t\t\twhile(true){\n\t\t\t\tchar op = str.charAt(pos);\n\t\t\t\tif((op == '+') || (op == '-')){\n\t\t\t\t\tint old = res;\n\t\t\t\t\tpos++;\n\t\t\t\t\tres = term();\n\t\t\t\t\tswitch(op){\n\t\t\t\t\tcase '+': \n\t\t\t\t\t\tres = old + res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tres = old - res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate int term() {\n\t\t\tint res = fact();\n\t\t\twhile(true){\n\t\t\t\tchar op = str.charAt(pos);\n\t\t\t\tif((op == '*') || (op == '/')){\n\t\t\t\t\tint old = res;\n\t\t\t\t\tpos++;\n\t\t\t\t\tres = fact();\n\t\t\t\t\tswitch(op){\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tres = old * res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tres = old / res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate int fact() {\n\t\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\t\tint t = str.charAt(pos) - '0';\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\t\tt = t * 10 + (str.charAt(pos) - '0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\telse if(str.charAt(pos) == '('){\n\t\t\t\tpos++;\n\t\t\t\tint res = exp();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\n// (5-(6/2/2+50*3/2/3*6/4)/9*2-(6/2/2+50*3/2/3*6)-36)*2-1=\n\nclass Main{\n\tstatic Pattern addsub = Pattern.compile(\"^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$\");\n\tstatic Pattern muldiv = Pattern.compile(\"^(.*?)(-?\\\\d+)([*/])(-?\\\\d+)(.*)$\");\n\n\tstatic String process(String s){\n\t\t//analyze parens\n\t\tint bidx=s.indexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s.charAt(eidx)=='(')count++;\n\t\t\t\tif(s.charAt(eidx)==')')count--;\n\t\t\t}\n\t\t\ts=s.substring(0,bidx)+process(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n\t\t\tbidx=s.indexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatcher m=muldiv.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"*\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=muldiv.matcher(s);\n\t\t}\n\n\t\tm=addsub.matcher(s);\n\t\twhile(m.find()){\n\t\t\tif(m.group(3).equals(\"+\"))\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\telse\n\t\t\t\ts=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);\n\t\t\tm=addsub.matcher(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void main(String[]z){\n\t\tScanner x=new Scanner(System.in);\n\t\tint n=x.nextInt();for(;n>0;n--){\n\t\t\tString s=x.next().replaceAll(\"-\",\"Z\");\n\t\t\tSystem.out.println(process(s.substring(0,s.length()-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char a) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\t\t//()内は無視\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif(a==c && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\n\t\n\tstatic int parse(String str) {\t\t\n\t\t\n\t\tint a = str.length();\n\t\tif(str.startsWith(\"(\") && str.endsWith(\")\")) {\t\t\t\t//(で始まり)で終わる\n\t\t\tif(!str.substring(1, a-1).contains(\"(\"))\t\t\t\t//間に()がなければsubstr\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\tif( str.lastIndexOf(\"(\",a-2) < str.lastIndexOf(\")\", a-2))//()*()のようなものは×\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t}\n\t\t\n\t\tint ind = lastInd(str,'-');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) - parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'+');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) + parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'/');\n\t\tif(ind!=-1) {\n\t\t\treturn parse(str.substring(0, ind)) / parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\tind = lastInd(str,'*');\n\t\tif(ind!=-1){\n\t\t\treturn parse(str.substring(0, ind)) * parse(str.substring(ind+1));\n\t\t}\n\t\t\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "TERM_N  = 0\nTERM_OP_PM = 1\nTERM_OP_MD = 2\nTERM_OP_SIGN = 3\nTERM_LB = 4\nTERM_RB = 5\nTERM_END = 6\n\ndef lex_analyze(str)\n  expr = []\n\n  come_sign = true\n\n  for t in str.scan(/\\d+|[\\+\\-\\*\\/\\(\\)=]/)\n    case t\n      when '+', '-'\n      if come_sign\n        expr.push [TERM_OP_SIGN, t]\n      else\n        expr.push [TERM_OP_PM, t]\n        come_sign = true\n      end\n\n      when '*', '/'\n      expr.push [TERM_OP_MD, t]\n      come_sign = true\n\n      when '('\n      expr.push [TERM_LB, t]\n      come_sign = true\n\n      when ')'\n      expr.push [TERM_RB, t]\n      come_sign = true\n\n      when '='\n      expr.push [TERM_END, t]\n      come_sign = true\n\n      else\n      expr.push [TERM_N, t.to_i]\n      come_sign = false\n    end\n  end\n\n  return expr\nend\n\ndef to_rpn(expr)\n  rpn = []\n  stack = []\n\n  for t in expr\n    case t[0]\n      when TERM_N\n      rpn.push t\n      while ! stack.empty? && stack[-1][0] == TERM_OP_SIGN\n        rpn.push stack.pop\n      end\n\n      when TERM_OP_PM\n      while ! stack.empty? &&\n          ((st = stack[-1])[0] == TERM_OP_PM || st[0] == TERM_OP_MD)\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_MD\n      while ! stack.empty? && stack[-1][0] == TERM_OP_MD\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_SIGN\n      stack.push t\n\n      when TERM_LB\n      stack.push t\n\n      when TERM_RB\n      while stack[-1][0] != TERM_LB\n        rpn.push stack.pop\n      end\n      stack.pop\n      while ! stack.empty? && stack[-1][0] == TERM_OP_SIGN\n        rpn.push stack.pop\n      end\n\n      when TERM_END\n      while ! stack.empty?\n        rpn.push stack.pop\n      end\n    end\n  end\n\n  return rpn\nend\n\ndef calc_rpn(rpn)\n  stack = []\n\n  for t in rpn\n    if t[0] == TERM_N\n      stack.push t[1]\n    elsif t[0] == TERM_OP_SIGN\n      if t[1] == '-'\n        n1 = stack.pop\n        stack.push -n1\n      end\n    else\n      n2 = stack.pop\n      n1 = stack.pop\n      case t[1]\n        when \"+\"\n        stack.push(n1 + n2)\n        when \"-\"\n        stack.push(n1 - n2)\n        when \"*\"\n        stack.push(n1 * n2)\n        when \"/\"\n        stack.push(n1 / n2)\n      end\n    end\n  end\n\n  return stack[-1]\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  str = gets.chomp\n  #p str\n  expr = lex_analyze(str)\n  #p expr\n  rpn = to_rpn(expr)\n  #p rpn\n  num = calc_rpn(rpn)\n  puts num\nend"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[] ) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint line=Integer.parseInt(br.readLine());\n\t\tMain calc=new Main();\n\t\tfor(int n=0;n<line;n++){\n\t\t\tString str=br.readLine();\n\t\t\tInteger num=calc.doCalc(str.substring(0,str.length()));\n\t\t\tif(num!=null){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t}\n\t}\n\n\tInteger doCalc(String expr){\n\t\treturn doCalc3(expr);\n\t}\n\n\tInteger doCalc3(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"+\",m)!=-1 && (expr.indexOf(\"-\",m)==-1 || expr.indexOf(\"-\",m)>expr.indexOf(\"+\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\")));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"+\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"+\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"+\",m)));\n\t\t\t\t\tnum.add(\"+\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"+\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"-\",m)!=-1 && (expr.indexOf(\"+\",m)==-1 || expr.indexOf(\"+\",m)>expr.indexOf(\"-\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tif(expr.indexOf(\"-\",m)>m+1){\n\t\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\")));\n\t\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"-\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"-\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"-\",m)));\n\t\t\t\t\tnum.add(\"-\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"-\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc2(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry {\n\t\t\t\tif(num.get(m)==\"+\"){\n\t\t\t\t\tn+=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn-=doCalc2(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc2(String expr){\n\t\tArrayList<String> num=new ArrayList<String>();\n\t\tint m=0;\n\t\twhile(m<expr.length()){\n\t\t\tif(expr.indexOf(\"*\",m)!=-1 && (expr.indexOf(\"/\",m)==-1 || expr.indexOf(\"/\",m)>expr.indexOf(\"*\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\")));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"*\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"*\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"*\",m)));\n\t\t\t\t\tnum.add(\"*\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"*\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(expr.indexOf(\"/\",m)!=-1 && (expr.indexOf(\"*\",m)==-1 || expr.indexOf(\"*\",m)>expr.indexOf(\"/\",m))){\n\t\t\t\tif(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\"(\")==-1){\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\")));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t\telse if(expr.substring(0,expr.indexOf(\"/\",m)).indexOf(\")\")==-1){\n\t\t\t\t\tm=expr.indexOf(\"/\",m)+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum.add(expr.substring(0, expr.indexOf(\"/\",m)));\n\t\t\t\t\tnum.add(\"/\");\n\t\t\t\t\texpr=expr.substring(expr.indexOf(\"/\",m)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum.add(expr);\n\n\t\tInteger n=doCalc1(num.get(0));\n\t\tm=1;\n\t\twhile(m<num.size()){\n\t\t\ttry{\n\t\t\t\tif(num.get(m)==\"*\"){\n\t\t\t\t\tn*=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tn/=doCalc1(num.get(m+1));\n\t\t\t\t}\n\t\t\t\tm+=2;\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.err.println(num.get(m)+\"演算子の後には数字が来なくてはなりません。\");\n\t\t\t\treturn null;\n\t\t\t} catch (NullPointerException e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tInteger doCalc1(String expr){\n\t\ttry{\n\t\t\tif(expr.length()>6 && expr.substring(0, 6).equals(\"radius\")){\n\t\t\t\treturn doCalc1(expr.substring(6))/180*Math.PI;\n\t\t\t}\n\t\t\telse if(expr.length()>3 && expr.substring(0, 3).equals(\"sin\")){\n\t\t\t\treturn Math.sin(doCalc1(expr.substring(3)));\n\t\t\t}\n\t\t\telse if(expr.length()>3 && expr.substring(0, 3).equals(\"cos\")){\n\t\t\t\treturn Math.cos(doCalc1(expr.substring(3)));\n\t\t\t}\n\t\t\telse if(expr.length()>3 && expr.substring(0, 3).equals(\"tan\")){\n\t\t\t\treturn Math.tan(doCalc1(expr.substring(3)));\n\t\t\t}\n\t\t\telse if(expr.substring(0, 1).equals(\"r\")){\n\t\t\t\treturn Math.sqrt(doCalc1(expr.substring(1)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn doCalc0(expr);\n\t\t\t}\n\t\t} catch (NullPointerException e){\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tInteger doCalc0(String expr){\n\t\tif(expr.charAt(0)=='('){\n\t\t\tif(expr.indexOf(\")\")!=-1){\n\t\t\t\treturn doCalc3(expr.substring(1,expr.indexOf(\")\")));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\")が見つかりません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(expr.charAt(0)!=')'){\n\t\t\t\ttry {\n\t\t\t\t\treturn new Integer(expr);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tSystem.err.println(\"数字でないものが入力されています。:\"+expr);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.err.println(\"(がありません。:\"+expr);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tString s;\n\n\tvoid run(){\n\t\tfor(int n=sc.nextInt(); n>0; n--){\n\t\t\ts=sc.next();\n\t\t\tprintln(equation(0).val+\"\");\n\t\t}\n\t}\n\n\tR equation(int p){\n\t\tR r=factor(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='+'||c=='-'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='+')\n\t\t\t\t\tr.val+=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val-=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR factor(int p){\n\t\tR r=term(p);\n\t\tfor(;;){\n\t\t\tchar c=s.charAt(r.p);\n\t\t\tif(c=='*'||c=='/'){\n\t\t\t\tR q=factor(r.p+1);\n\t\t\t\tif(c=='*')\n\t\t\t\t\tr.val*=q.val;\n\t\t\t\telse\n\t\t\t\t\tr.val/=q.val;\n\t\t\t\tr.p=q.p;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tR term(int p){\n\t\tif(s.charAt(p)=='('){\n\t\t\tR r=equation(p+1);\n\t\t\tr.p++; // skip ')'\n\t\t\treturn r;\n\t\t}else{\n\t\t\tlong val=0;\n\t\t\tfor(; Character.isDigit(s.charAt(p)); p++){\n\t\t\t\tval=val*10+(s.charAt(p)-'0');\n\t\t\t}\n\t\t\treturn new R(p, val);\n\t\t}\n\t}\n\n\tclass R{\n\t\tint p;\n\t\tlong val;\n\n\t\tR(int p, long val){\n\t\t\tthis.p=p;\n\t\t\tthis.val=val;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n    static char[] expr;\n    static int now;\n\n    private static int expression(){\n\tint res=term();\n\twhile(true){\n\t    char c=expr[now++];\n\t    if(c=='+')res+=term();\n\t    else if(c=='-')res-=term();\n\t    else break;\n\t}\n\treturn res;\n    }\n\n    private static int term(){\n\tint res=fact();\n\twhile(true){\n\t    char c=expr[now++];\n\t    if(c=='*')res*=fact();\n\t    else if(c=='/')res/=fact();\n\t    else break;\n\t}\n\tnow--;\n\treturn res;\n    }\n    \n    static int fact(){\n\tchar c=expr[now++];\n\tif(c=='(')return expression();\n\tif(c=='-')return -fact();\n\tif(c=='+')return fact();\n\tint x=c-'0';\n\twhile(true){\n\t    c=expr[now++];\n\t    if(Character.isDigit(c)){\n\t\tx*=10;\n\t\tx+=c-'0';\n\t    }\n\t    else break;\n\t}\n\tnow--;\n\treturn x;\n    }\n\n    public static void main(String[] args){\n\tScanner sc=new Scanner(System.in);\n\tint t=sc.nextInt();\n\twhile(t--!=0){\n\t    expr=sc.next().toCharArray();\n\t    now=0;\n\t    System.out.println(expression());\n\t}\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Smart Calculator\npublic class Main {\n\n        static char[] s;\n        static int id;\n\n        static int exp(){\n                int r = term();\n                while(true){\n                        char c = s[id++];\n                        if(c=='+')r+=term();\n                        else if(c=='-')r-=term();\n                        else break;\n                }\n                return r;\n        }\n\n        static int term(){\n                int r = fact();\n                while(true){\n                        char c = s[id++];\n                        if(c=='*') r*=fact();\n                        else if(c=='/')r/=fact();\n                        else break;\n                }\n                id--;\n                return r;\n        }\n\n        static int fact(){\n                char c = s[id++];\n                if(c=='(')return exp();\n                if(c=='-'){\n                        return -fact();\n                }\n                if(c=='+'){\n                        return fact();\n                }\n                int x = c-'0';\n                while(true){\n                        c = s[id++];\n                        if(Character.isDigit(c)){\n                                x *= 10;\n                                x += c-'0';\n                        }\n                        else break;\n                }\n                id--;\n                return x;\n        }\n\n        public static void main(String[] args) {\n                Scanner sc = new Scanner(System.in);\n                int t = sc.nextInt();\n                while(t--!=0){\n                        s = sc.next().toCharArray();\n                        id = 0;\n                        System.out.println(exp());\n                }\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[] s;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tint N = cin.nextInt();\n\t\twhile(N--!=0){\n\t\t\tString str = cin.next();\n\t\t\tidx=0;\n\t\t\tchar[] a = str.toCharArray();\n\t\t\ts = new char[150];\n\t\t\tfor(int i = 0; i < a.length;i++){\n\t\t\t\ts[i]=a[i];\n\t\t\t}\n\t\t\tSystem.out.println(expression());\n\t\t}\n\n\t}\n\tstatic int expression(){\n\t\tint res =term();\n\t\twhile(s[idx]=='+'||s[idx]=='-'){\n\t\t\tif(s[idx]=='+'){\n\t\t\t\tidx++;\n\t\t\t\tres+=term();\n\t\t\t}\n\t\t\telse if(s[idx]=='-'){\n\t\t\t\tidx++;\n\t\t\t\tres-=term();\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int term(){\n\t\tint res = fact();\n\t\twhile(s[idx]=='*'||s[idx]=='/'){\n\t\t\tif(s[idx]=='*'){\n\t\t\t\tidx++;\n\t\t\t\tres*=fact();\n\t\t\t}\n\t\t\telse if(s[idx]=='/'){\n\t\t\t\tidx++;\n\t\t\t\tres/=fact();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic int fact(){\n\t\tint res=0;\n\t\tif(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tres = expression();\n\t\t\tidx++;\n\t\t}\n\t\telse{\n\t\t\twhile(true){\n\t\t\t\tres += s[idx]-'0';\n\t\t\t\tidx++;\n\t\t\t\tif(!Character.isDigit(s[idx])){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres*=10;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int lastInd(String str,char a) {\n\t\tint n = 0;\n\t\tfor(int i=str.length()-1;i>0;i--) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(c=='(')\n\t\t\t\tn++;\n\t\t\tif(c==')')\n\t\t\t\tn--;\n\t\t\tif(a==c && n==0)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tstatic int parse(String str) {\n\t\tint a = 0;\n\t\tint sum = 0;\n\t\tint s = 0;\n\t\tint st = str.length()-1;\n\t\tint en = 0;\n\t\tint flag = 0;\n\t\t\n\t\tif(str.contains(\")\")) {\n\t\t\tflag = 1;\t\t\t//(())を想定して+-で考える\n\t\t\tif(str.charAt(0)=='(' && str.charAt(str.length()-1)==')') {\n\t\t\t\treturn parse(str.substring(1, str.length()-1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(lastInd(str,'-')!=-1) {\n\t\t\tsum = parse(str.substring(0, lastInd(str,'-'))) - parse(str.substring(lastInd(str,'-')+1));\n\t\t}\n\t\t\t\n\t\telse if(lastInd(str,'+')!=-1) {\n\t\t\tsum = parse(str.substring(0, lastInd(str,'+'))) + parse(str.substring(lastInd(str,'+')+1));\n\t\t}\n\t\t\t\n\t\telse if(lastInd(str,'/')!=-1) {\n\t\t\tsum = parse(str.substring(0, lastInd(str,'/'))) / parse(str.substring(lastInd(str,'/')+1));\n\t\t}\n\t\t\t\n\t\telse if(lastInd(str,'*')!=-1){\n\t\t\tsum = parse(str.substring(0, lastInd(str,'*'))) * parse(str.substring(lastInd(str,'*')+1));\n\t\t}\n\t\telse\n\t\t\treturn Integer.parseInt(str);\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint a = sc.nextInt();\n\t\twhile(a--!=0) {\n\t\t\tString str = sc.next();\n\t\t\tSystem.out.println(parse(str.substring(0,str.length()-1)));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tString s = sc.nextLine();\n\t\t\ts = s.substring(0, s.length()-1);\n\t\t\tSystem.out.println(calc(s));\n\t\t}\n\t\t\n\t}\n\tstatic String calc(String s){\n\t\tArrayList<String> list = split(\"(\"+s+\")\");\n\t\tint index1 = index1(list);\n\t\twhile(index1 != -1){\n\t\t\tint index2 = index2(list, index1);\n\t\t\tint indexOf = indexOf(\"/\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a/b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"/\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"*\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a*b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"*\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a+b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"+\", list, index2, index1);\n\t\t\t}\n\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\twhile(indexOf != -1){\n\t\t\t\tint a,b,c;\n\t\t\t\ta = Integer.parseInt((String)list.get(indexOf-1));\n\t\t\t\tb = Integer.parseInt((String)list.get(indexOf+1));\n\t\t\t\tc = a-b;\n\t\t\t\tlist.remove(indexOf+1);\n\t\t\t\tlist.set(indexOf, String.valueOf(c));\n\t\t\t\tlist.remove(indexOf-1);\n\t\t\t\tindex1 -= 2;\n\t\t\t\tindexOf = indexOf(\"-\", list, index2, index1);\n\t\t\t}\n\t\t\tlist.remove(index1);\n\t\t\tlist.remove(index2);\n\t\t\tindex1 = index1(list);\n\t\t}\n\t\treturn (String)list.get(0);\n\t}\n\t//)ÌCfbNX\n\tstatic int index1(ArrayList<String> list){\n\t\tfor(int i = 0 ; i < list.size() ; i++){\n\t\t\tif(((String)list.get(i)).equals(\")\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//)ÌèOÌ(ÌCfbNX\n\tstatic int index2(ArrayList<String> list, int index1){\n\t\tfor(int i = index1-1; i >= 0 ; i--){\n\t\t\tif(((String)list.get(i)).equals(\"(\")){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//*,/,+,-ÌCfbNX\n\tstatic int indexOf(String s, ArrayList<String> list, int index2, int index1){\n\t\tfor(int i = index2+1; i < index1; i++){\n\t\t\tif(((String)list.get(i)).equals(s)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic ArrayList<String> split(String s){\n\t\tArrayList<String> list = new ArrayList<String>();\n\t\twhile(s.length() > 0){\n\t\t\tif(isInt(s.charAt(0))){\n\t\t\t\tint i = 0;\n\t\t\t\tString _s = \"\";\n\t\t\t\twhile(isInt(s.charAt(i))){\n\t\t\t\t\t_s += String.valueOf(s.charAt(i));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlist.add(_s);\n\t\t\t\tif(i == s.length()){\n\t\t\t\t\ts = \"\";\n\t\t\t\t}else{\n\t\t\t\t\ts = s.substring(i, s.length());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlist.add(String.valueOf(s.charAt(0)));\n\t\t\t\ts = s.substring(1, s.length());\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tstatic boolean isInt(char c){\n\t\tif('0' <= c && c <= '9'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class SmartCalculator\n{\n   private class EquationNode\n   {\n      public EquationNode left;\n      public EquationNode right;\n\n      public int value { get { return GetValue(this); } }\n      public Func<EquationNode, int> GetValue;\n\n      public static EquationNode Constant(int value)\n      {\n         return new EquationNode{ GetValue = x => value };\n      }\n      public static EquationNode ReferenceRight()\n      {\n         return new EquationNode{ GetValue = x => x.right.value };\n      }\n   }\n\n   public static int Calculate(string equation)\n   {\n      return MakeTree(equation).value;\n   }\n\n   private static EquationNode MakeTree(string equation)\n   {\n      var root = EquationNode.ReferenceRight();\n      root.right = EquationNode.ReferenceRight();\n      var node = root;\n\n      EquationNode valueNode = null;\n      for (int index = 0; index < equation.Length; index++)\n      {\n         char word = equation[index];\n         switch (word)\n         {\n            case '+':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value + x.right.value,\n               };\n               node = root;\n               break;\n            case '-':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value - x.right.value,\n               };\n               node = root;\n               break;\n            case '*':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value * x.right.value,\n               };\n               break;\n            case '/':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value / x.right.value,\n               };\n               break;\n            case '(':\n               {\n                  var end = equation.IndexOf(')', index);\n                  var innerEquation = equation.Substring(index + 1, end - index - 1);\n                  valueNode = SmartCalculator.MakeTree(innerEquation);\n                  index = end;\n                  break;\n               }\n            default:\n               // 数値\n               {\n                  var end = index;\n                  while (end < equation.Length && '0' <= equation[end] && equation[end] <= '9')\n                  {\n                     end++;\n                  }\n                  var innerEquation = equation.Substring(index, end - index);\n                  int value = int.Parse(innerEquation);\n                  valueNode = EquationNode.Constant(value);\n                  index = end - 1;\n                  break;\n               }\n         }\n      }\n\n      node.right.right = valueNode;\n\n      return root;\n   }\n}\n\nclass MainClass\n{\n   static void Main(string[] args)\n   {\n      var stringBuilder = new StringBuilder();\n\n      int n = int.Parse(Console.ReadLine());\n      for (; n > 0; n--)\n      {\n         var equation = Console.ReadLine().TrimEnd('=');\n         var result = SmartCalculator.Calculate(equation);\n\n         stringBuilder.AppendLine(result.ToString());\n      }\n\n      Console.Write(stringBuilder.ToString());\n   }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PaizaSample\n{\n\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n\n\n        for (int i = 0; i < n; i++)\n        {\n            List<string> list = new List<string>();\n            List<char> temp = new List<char>();\n            string input = Console.ReadLine();\n\n            bool numFlag = false;\n\n            for (int j = 0; j < input.Length; j++)\n            {\n                switch (input[j])\n                {\n                    case '+':\n                    case '-':\n                        \n                        if (temp.Count > 0 && (temp[temp.Count - 1] == '*' || temp[temp.Count - 1] == '/'))\n                        {\n                            list.Add(temp[temp.Count - 1].ToString());\n                        }\n                        else\n                        {\n                            temp.Add(input[j]);\n                        }\n                        numFlag = false;\n                        break;\n                    case '*':\n                    case '/':\n                        temp.Add(input[j]);\n                        numFlag = false;\n                        break;\n                    case '(':\n                        temp.Add('(');\n                        break;\n                    case ')':\n                        for (int k = temp.Count - 1; k >= 0; k--)\n                        {\n                            if (temp[k] == '(')\n                            {\n                                temp.RemoveAt(k);\n                                break;\n                            }\n                            else\n                            {\n                                list.Add(temp[k].ToString());\n                                temp.RemoveAt(k);\n                            }\n                        }\n                        numFlag = false;\n                        break;\n                    case '=':\n                        for (int k = temp.Count - 1; k >= 0; k--)\n                        {\n                            list.Add(temp[k].ToString());\n                            temp.RemoveAt(k);\n                        }\n                        break;\n                    default:\n                        if (numFlag)\n                        {\n                            list[list.Count - 1] += input[j];\n                        }\n                        else\n                        {\n                            list.Add(input[j].ToString());\n                        }\n                        numFlag = true;\n                        break;\n                }\n\n            }\n\n            //foreach (string s in list)\n            //{\n            //    Console.Write(s + \" \");\n            //}\n\n            //Console.WriteLine();\n\n            int cursol = 2;\n            while (true)\n            {\n                if (list.Count == 1)\n                {\n                    break;\n                }\n\n                switch (list[cursol])\n                {\n                    case \"+\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) + int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"-\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) - int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"*\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) * int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"/\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) / int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    default:\n                        cursol++;\n                        break;\n\n                }\n\n\n            }\n\n            Console.WriteLine(list[0]);\n\n        }\n\n\n        //Console.ReadKey();\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var t1 = new[] { \"+\", \"-\", \"*\", \"/\", \"(\", \")\", \"=\" };\n            var t2 = new[] { \" + \", \" - \", \" * \", \" / \", \"( \", \" )\", \" =\" };\n            for (int i = int.Parse(Console.ReadLine()); i > 0; --i) {\n                var f = Console.ReadLine();\n                for (int j = 0; j < t1.Length; ++j) {\n                    f = f.Replace(t1[j], t2[j]);\n                }\n                Console.WriteLine(e(f.Split()));\n            }\n        }\n        static int e(string[] t) {\n            int index = 0;\n            Func<int> r1 = null;\n            Func<int> r2 = () => t[index++] == \"(\" ? r1() : int.Parse(t[index - 1]);\n            return (r1 = () => {\n                int total = r2();\n                while (t[index] != \")\" && t[index] != \"=\") {\n                    switch (t[index++]) {\n                        case \"+\":\n                            total += r1();\n                            break;\n                        case \"-\":\n                            total -= r1();\n                            break;\n                        case \"*\":\n                            total *= r2();\n                            break;\n                        case \"/\":\n                            total /= r2();\n                            break;\n                    }\n                }\n                return total;\n            })();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\n            var theClass = assembly.GetType(\"N.C\");\n            return (int)theClass.GetMethod(\"Calculate\").Invoke(null, null);\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n\n                input = input.Replace(\"=\", \"\");\n\n                System.Data.DataTable dt = new System.Data.DataTable();\n                int result = (int)dt.Compute(input, \"\");\n\n                sb.AppendLine(result.ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0109\n{\n    public class Program\n        \n    {\n        public class Source\n        {\n            public string Str { get; }\n            public int Pos { get; set; }\n\n            public Source(string str) { Str = str; Pos = 0; }\n\n            public int Peek() { if (Pos < Str.Length) return Str[Pos]; else return -1; }\n            public void Next() { Pos++; }\n        }\n\n        public static void Main(string[] args)\n        {\n            int n = RInt();\n            for (int i = 0 ; i < n ; i++)\n            {\n                Console.WriteLine(new Parser(RSt()).Expr());\n            }\n        }\n\n        public class Parser : Source\n        {\n            public Parser(string str) : base(str) { }\n            \n            public int Expr()\n            {\n                int x = Term();\n                while (true)\n                {\n                    switch (Peek())\n                    {\n                        case '+': Next(); x += Term(); break;\n                        case '-': Next(); x -= Term(); break;\n                        default:   return x;\n                    }\n                }\n            }\n\n            public int Term()\n            {\n                int x = Factor();\n                while (true)\n                {\n                    switch (Peek())\n                    {\n                        case '*': Next(); x *= Factor(); break;\n                        case '/': Next(); x /= Factor(); break;\n                        default: return x;\n                    }\n                }\n            }\n\n            public int Factor()\n            {\n                if (Peek() == '(')\n                {\n                    Next();\n                    int ret = Expr();\n                    if (Peek() == ')') { Next(); }\n                    return ret;\n                }\n                return Number();\n            }\n            \n            public int Number()\n            {\n                StringBuilder sb = new StringBuilder();\n                int ch;\n                while ((ch = Peek()) >= 0 && char.IsDigit((char)ch))\n                {\n                    sb.Append((char)ch);\n                    Next();\n                }\n                return int.Parse(sb.ToString());\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.CSharp;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\n\nclass Program\n{\n    /// <summary>\n    /// \n    /// </summary>\n    /// <param name=\"args\"></param>\n    static void Main(string[] args)\n    {\n        int n = Int32.Parse(Console.ReadLine());\n        for (int i = 0; i < n; i++)\n        {\n            string ex = Console.ReadLine();\n            if (ex[ex.Length - 1] == '=') ex = ex.Substring(0, ex.Length - 1);\n            var script =\n    @\"\nusing System;\nclass Program\n{\n    public void Main()\n    {\n        Console.WriteLine(\" + ex + @\");\n    }\n}\n\";\n\n            var assemblyNames = new[]\n                {\n                    \"System.dll\",\n                };\n\n            CompilerResults results;\n            var param = new CompilerParameters(assemblyNames)\n            {\n                GenerateInMemory = true,\n                IncludeDebugInformation = false,\n            };\n\n            var codeProvider = new CSharpCodeProvider();\n            results = codeProvider.CompileAssemblyFromSource(param, script);\n            var type = results.CompiledAssembly.GetType(\"Program\");\n            var parameters = new object[0];\n            var instance = Activator.CreateInstance(type);\n            type.GetMethod(\"Main\")\n                .Invoke(instance, parameters);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\n            var theClass = assembly.GetType(\"N.C\");\n            return (int) theClass.GetMethod(\"Calculate\").Invoke(null, null);\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            // ReSharper disable once RedundantAssignment\n            var line = Console.ReadLine();\n            while ((line = Console.ReadLine()) != null)\n            {\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace _0109\n{\n\tclass Program\n\t{\n\t\tstatic string s;\n\t\tpublic static int pointer;\n\t\tstatic int number()\n\t\t{\n\t\t\tint ret = 0;\n\t\t\twhile (pointer < s.Length && '0' <= s[pointer] && s[pointer] <= '9')\n\t\t\t{\n\t\t\t\tret *= 10;\n\t\t\t\tret += s[pointer] - '0';\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tstatic int term()\n\t\t{\n\t\t\tint ret = factor();\n\t\t\twhile (pointer < s.Length)\n\t\t\t{\n\t\t\t\tif (s[pointer] == '*')\n\t\t\t\t{\n\t\t\t\t\tpointer++;\n\t\t\t\t\tret *= factor();\n\t\t\t\t}\n\t\t\t\telse if (s[pointer] == '/')\n\t\t\t\t{\n\t\t\t\t\tpointer++;\n\t\t\t\t\tret /= factor();\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tstatic int expression()\n\t\t{\n\t\t\tint ret = term();\n\t\t\twhile (pointer < s.Length)\n\t\t\t{\n\t\t\t\tif (s[pointer] == '+')\n\t\t\t\t{\n\t\t\t\t\tpointer++;\n\t\t\t\t\tret += term();\n\t\t\t\t}\n\t\t\t\telse if (s[pointer] == '-')\n\t\t\t\t{\n\t\t\t\t\tpointer++;\n\t\t\t\t\tret -= term();\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tstatic int factor()\n\t\t{\n\t\t\tif (s[pointer] == '(')\n\t\t\t{\n\t\t\t\tpointer++;\n\t\t\t\tint ret = expression();\n\t\t\t\tpointer++;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse return number();\n\t\t}\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint n = int.Parse(Console.ReadLine());\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\ts = Console.ReadLine();\n\t\t\t\tpointer = 0;\n\t\t\t\tConsole.WriteLine(expression());\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        public static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\nConsole.WriteLine(provider);\nConsole.WriteLine(source);\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\t\n\t\tvar d =int.Parse(Console.ReadLine());\n\t\tfor(int i=0;i<d;i++){\n\t\t\tString exp0 = Console.ReadLine();\n\t\t\tString exp=exp0.Substring(0,exp0.Length-1);\n\t\t\t\n\t\t\t//式を計算する\n\t\t\tSystem.Data.DataTable dt = new System.Data.DataTable();\n\t\t\tint result = (int)dt.Compute(exp, \"\");\n\n\t\t\t//結果を表示\t\n\t\t\tConsole.WriteLine(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        public static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        public static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\nConsole.WriteLine(assembly);\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n\n                Stack<int> leftB_Index = new Stack<int>();\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] == '(') leftB_Index.Push(j);\n                    else if (input[j] == ')')\n                    {\n                        int idx = leftB_Index.Pop();\n\n                        string subStr = input.Substring(idx + 1, j - idx - 1);\n\n                        input = input.Replace(subStr, Calc(subStr));\n                    }\n                }\n\n                string formula = \"\";\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] >= '0' && input[j] <= '9')\n                    {\n                        formula += input[j];\n                    }\n                    else if (input[j] == '+' || input[j] == '-' || input[j] == '*' || input[j] == '/')\n                    {\n                        formula += input[j];\n                    }\n                }\n                sb.AppendLine(Calc(formula));\n            }\n            Console.Write(sb);\n        }\n\n        static string Calc(string s)\n        {\n            List<string> f1 = new List<string>();\n            List<string> f2 = new List<string>();\n\n            string num = \"\";\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (s[i] >= '0' && s[i] <= '9')\n                {\n                    num += s[i];\n                }\n                else\n                {\n                    f1.Add(num);\n                    num = \"\";\n                    f1.Add(s[i].ToString());\n                }\n            }\n            f1.Add(num);\n\n            for (int i = 0; i < f1.Count; i++)\n            {\n                if (f1[i] == \"*\")\n                {\n                    int temp = int.Parse(f1[i - 1]) * int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else if (f1[i] == \"/\")\n                {\n                    int temp = int.Parse(f1[i - 1]) / int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else\n                {\n                    f2.Add(f1[i]);\n                }\n            }\n\n            int calc = int.Parse(f2[0]);\n\n            for (int i = 1; i < f2.Count; i += 2)\n            {\n                if (f2[i] == \"+\") calc += int.Parse(f2[i + 1]);\n                else if (f2[i] == \"-\") calc -= int.Parse(f2[i + 1]);\n            }\n\n            return calc.ToString();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        while (n-- > 0)\n        {\n            var s = Console.ReadLine().Trim();\n            var res = conv3(s);\n            var q = conv2(res);\n            var ans = getAns(q);\n            Console.WriteLine(ans);\n        }\n    }\n    static int getAns(Queue<string> q)\n    {\n        var st = new Stack<int>();\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            if (w == \"+\")\n            {\n                var t = st.Pop() + st.Pop();\n                st.Push(t);\n            }\n            else if (w == \"-\")\n            {\n                var t = -st.Pop() + st.Pop();\n                st.Push(t);\n            }\n            else if (w == \"*\")\n            {\n                var t = st.Pop() * st.Pop();\n                st.Push(t);\n            }\n            else if (w == \"/\")\n            {\n                var a1 = st.Pop();\n                var a2 = st.Pop();\n                var t = a2 / a1;\n                st.Push(t);\n            }\n            else st.Push(int.Parse(w));\n        }\n        return st.Pop();\n    }\n\n    static Queue<string> conv2(List<string> line)\n    {\n        var q = new Queue<string>();\n        var st = new Stack<string>();\n        foreach (var x in line)\n        {\n            if (x == \"(\") st.Push(x);\n            else if (x == \"+\" | x == \"-\")\n            {\n                if (st.Count() == 0) st.Push(x);\n                else\n                {\n                    if (st.Peek() == \"*\" | st.Peek() == \"/\")\n                    {\n                        q.Enqueue(st.Pop());\n                        if (st.Count() > 0 && (st.Peek() == \"+\" | st.Peek() == \"-\")) q.Enqueue(st.Pop());\n                        st.Push(x);\n                    }\n                    else if (st.Peek() == \"+\" | st.Peek() == \"-\")\n                    {\n                        q.Enqueue(st.Pop());\n                        st.Push(x);\n                    }\n                    else if (st.Peek() == \"(\") { st.Push(x); }\n                }\n            }\n            else if (x == \"*\" | x == \"/\")\n            {\n                if (st.Count() == 0) st.Push(x);\n                else\n                {\n                    if (st.Peek() == \"*\" | st.Peek() == \"/\")\n                    { q.Enqueue(st.Pop()); st.Push(x); }\n                    else if (st.Peek() == \"+\" | st.Peek() == \"-\")\n                    { st.Push(x); }\n                    else if (st.Peek() == \"(\") { st.Push(x); }\n                }\n            }\n            else if (x == \")\")\n            {\n                while (true)\n                {\n                    if (st.Peek() == \"(\") { st.Pop(); break; }\n                    else q.Enqueue(st.Pop());\n                }\n            }\n            else q.Enqueue(x);\n        }\n        while (st.Count() > 0)\n        {\n            q.Enqueue(st.Pop());\n        }\n        return q;\n    }\n    static List<string> conv3(string s)\n    {\n        var res = new List<string>();\n        var sL = s.Length;\n        var flag = false;\n        var nn = \"\";\n        for (int i = 0; i < sL; i++)\n        {\n            var w = s.Substring(i, 1);\n            if (w == \"*\" | w == \"/\" | w == \"+\" | w == \"-\" | w == \"(\" | w == \")\")\n            {\n                if (flag) { res.Add(nn); nn = \"\"; flag = false; }\n                res.Add(w);\n            }\n            else if (w == \"=\" && flag) res.Add(nn);\n            else { nn += w; flag = true; }\n        }\n        return res;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        public static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\nConsole.WriteLine(assembly);\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n\n                input = input.Replace(\"=\", \"\");\n\n                DataTable dt = new DataTable();\n                int result = (int)dt.Compute(input, \"\");\n\n                sb.AppendLine(result.ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n\n                Stack<int> leftB_Index = new Stack<int>();\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] == '(') leftB_Index.Push(j);\n                    else if (input[j] == ')')\n                    {\n                        int idx = leftB_Index.Pop();\n\n                        string subStr = input.Substring(idx + 1, j - idx - 1);\n\n                        input = input.Replace(subStr, Calc(subStr));\n                    }\n                }\n\n                string formula = \"\";\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] >= '0' && input[j] <= '9')\n                    {\n                        formula += input[j];\n                    }\n                    else if (input[j] == '+' || input[j] == '-' || input[j] == '*' || input[j] == '/')\n                    {\n                        formula += input[j];\n                    }\n                }\n                sb.AppendLine(Calc(formula));\n            }\n            Console.Write(sb);\n        }\n\n        static string Calc(string s)\n        {\n            List<string> f1 = new List<string>();\n            List<string> f2 = new List<string>();\n\n            string num = \"\";\n            bool flg = false;\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (s[i] >= '0' && s[i] <= '9')\n                {\n                    num += s[i];\n                }\n                else\n                {\n                    f1.Add(num);\n                    num = \"\";\n                    f1.Add(s[i].ToString());\n                }\n            }\n\n            if (num != \"\") f1.Add(num);\n\n            for (int i = 0; i < f1.Count; i++)\n            {\n                if (f1[i] == \"*\")\n                {\n                    int temp = int.Parse(f1[i - 1]) * int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else if (f1[i] == \"/\")\n                {\n                    int temp = int.Parse(f1[i - 1]) / int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else\n                {\n                    f2.Add(f1[i]);\n                }\n            }\n\n            int calc = int.Parse(f2[0]);\n\n            for (int i = 1; i < f2.Count; i += 2)\n            {\n                if (f2[i] == \"+\") calc += int.Parse(f2[i + 1]);\n                else if (f2[i] == \"-\") calc -= int.Parse(f2[i + 1]);\n            }\n\n            return calc.ToString();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class SmartCalculator\n{\n   private class EquationNode\n   {\n      public EquationNode left;\n      public EquationNode right;\n\n      public int value { get { return GetValue(this); } }\n      public Func<EquationNode, int> GetValue;\n\n      public static EquationNode Constant(int value)\n      {\n         return new EquationNode{ GetValue = x => value };\n      }\n      public static EquationNode ReferenceRight()\n      {\n         return new EquationNode{ GetValue = x => x.right.value };\n      }\n   }\n\n   public static int Calculate(string equation)\n   {\n      return MakeTree(equation).value;\n   }\n\n   private static EquationNode MakeTree(string equation)\n   {\n      var root = EquationNode.ReferenceRight();\n      root.right = EquationNode.ReferenceRight();\n      var node = root;\n\n      EquationNode valueNode = null;\n      for (int index = 0; index < equation.Length; index++)\n      {\n         char word = equation[index];\n         switch (word)\n         {\n            case '+':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value + x.right.value,\n               };\n               node = root;\n               break;\n            case '-':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value - x.right.value,\n               };\n               node = root;\n               break;\n            case '*':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value * x.right.value,\n               };\n               break;\n            case '/':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value / x.right.value,\n               };\n               break;\n            case '(':\n               {\n                  int nest = 1;\n                  int end;\n                  for (end = index + 1; nest > 0; end++)\n                  {\n                     switch (equation[end])\n                     {\n                        case '(':\n                           nest++;\n                           break;\n                        case ')':\n                           nest--;\n                           break;\n                     }\n                  }\n                  var innerEquation = equation.Substring(index + 1, (end - 1) - (index + 1));\n                  valueNode = SmartCalculator.MakeTree(innerEquation);\n                  index = end - 1;\n                  break;\n               }\n            default:\n               // 数値\n               {\n                  var end = index;\n                  while (end < equation.Length && '0' <= equation[end] && equation[end] <= '9')\n                  {\n                     end++;\n                  }\n                  var innerEquation = equation.Substring(index, end - index);\n                  int value = int.Parse(innerEquation);\n                  valueNode = EquationNode.Constant(value);\n                  index = end - 1;\n                  break;\n               }\n         }\n      }\n\n      node.right.right = valueNode;\n\n      return root;\n   }\n}\n\nclass MainClass\n{\n   static void Main(string[] args)\n   {\n      var stringBuilder = new StringBuilder();\n\n      int n = int.Parse(Console.ReadLine());\n      for (; n > 0; n--)\n      {\n         var equation = Console.ReadLine().TrimEnd('=');\n         var result = SmartCalculator.Calculate(equation);\n\n         stringBuilder.AppendLine(result.ToString());\n      }\n\n      Console.Write(stringBuilder.ToString());\n   }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text.RegularExpressions;\n\n// (5-(6/2/2+50*3/2/3*6/4)/9*2-(6/2/2+50*3/2/3*6)-36)*2-1=\n\nclass AOJ0109{\n\tstatic Regex addsub = new Regex(\"^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$\",RegexOptions.Compiled);\n\tstatic Regex muldiv = new Regex(\"^(.*?)(-?\\\\d+)([*/])(-?\\\\d+)(.*)$\",RegexOptions.Compiled);\n\n\tstatic String process(String s){\n\t\t//analyze parens\n\t\tint bidx=s.IndexOf(\"(\");\n\t\twhile(bidx!=-1){\n\t\t\tint count=1,eidx=bidx+1;\n\t\t\tfor(;count!=0;eidx++){\n\t\t\t\tif(s[eidx]=='(')count++;\n\t\t\t\tif(s[eidx]==')')count--;\n\t\t\t}\n\t\t\ts=s.Substring(0,bidx)+process(s.Substring(bidx+1,eidx-1-(bidx+1)))+s.Substring(eidx);\n\t\t\tbidx=s.IndexOf(\"(\");\n\t\t}\n\n\t\t//calc without parens\n\t\tMatchCollection m=muldiv.Matches(s);\n\t\twhile(m.Count>0){\n\t\t\tif(m[0].Groups[3].Value==\"*\")\n\t\t\t\ts=m[0].Groups[1].Value+(int.Parse(m[0].Groups[2].Value)*int.Parse(m[0].Groups[4].Value))+m[0].Groups[5].Value;\n\t\t\telse\n\t\t\t\ts=m[0].Groups[1].Value+(int.Parse(m[0].Groups[2].Value)/int.Parse(m[0].Groups[4].Value))+m[0].Groups[5].Value;\n\t\t\tm=muldiv.Matches(s);\n\t\t}\n\n\t\tm=addsub.Matches(s);\n\t\twhile(m.Count>0){\n\t\t\tif(m[0].Groups[3].Value==\"+\")\n\t\t\t\ts=m[0].Groups[1].Value+(int.Parse(m[0].Groups[2].Value)+int.Parse(m[0].Groups[4].Value))+m[0].Groups[5].Value;\n\t\t\telse\n\t\t\t\ts=m[0].Groups[1].Value+(int.Parse(m[0].Groups[2].Value)-int.Parse(m[0].Groups[4].Value))+m[0].Groups[5].Value;\n\t\t\tm=addsub.Matches(s);\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic static void Main(string[]z){\n\t\tint n=int.Parse(Console.ReadLine());\n\t\tfor(;n>0;n--){\n\t\t\tstring s=Console.ReadLine().Replace(\"-\",\"Z\");\n\t\t\tConsole.WriteLine(process(s.Substring(0,s.Length-1)));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class SmartCalculator\n{\n   private class EquationNode\n   {\n      public EquationNode left;\n      public EquationNode right;\n\n      public int value { get { return GetValue(this); } }\n      public Func<EquationNode, int> GetValue;\n\n      public static EquationNode Constant(int value)\n      {\n         return new EquationNode{ GetValue = x => value };\n      }\n   }\n\n   public static int Calculate(string equation)\n   {\n      var root = new EquationNode();\n      var node = root;\n      node.GetValue = x => x.right.value;\n\n      int value = 0;\n      for (int index = 0; index < equation.Length; index++)\n      {\n         char word = equation[index];\n         if ('0' < word && word < '9')\n         {\n            // 数値\n            value = 10 * value + word - '0';\n            continue;\n         }\n\n         // 演算子か括弧\n         switch (word)\n         {\n            case '+':\n               node.right = EquationNode.Constant(value);\n               root = new EquationNode{ left = root, };\n               node = root;\n               node.GetValue = x => x.left.value + x.right.value;\n               value = 0;\n               break;\n            case '-':\n               node.right = EquationNode.Constant(value);\n               root = new EquationNode{ left = root, };\n               node = root;\n               node.GetValue = x => x.left.value - x.right.value;\n               value = 0;\n               break;\n            case '*':\n               node.right = new EquationNode();\n               node = node.right;\n               node.GetValue = x => x.left.value * x.right.value;\n               node.left = EquationNode.Constant(value);\n               value = 0;\n               break;\n            case '/':\n               node.right = new EquationNode();\n               node = node.right;\n               node.GetValue = x => x.left.value / x.right.value;\n               node.left = EquationNode.Constant(value);\n               value = 0;\n               break;\n            case '(':\n               var end = equation.IndexOf(')', index);\n               var innerEquation = equation.Substring(index + 1, end - index - 1);\n               value = SmartCalculator.Calculate(innerEquation);\n               index = end;\n               break;\n         }\n\n      }\n\n      node.right = EquationNode.Constant(value);\n\n      return root.value;\n   }\n}\n\nclass MainClass\n{\n   static void Main(string[] args)\n   {\n      var stringBuilder = new StringBuilder();\n\n      int n = int.Parse(Console.ReadLine());\n      for (; n > 0; n--)\n      {\n         var equation = Console.ReadLine().TrimEnd('=');\n         var result = SmartCalculator.Calculate(equation);\n\n         stringBuilder.AppendLine(result.ToString());\n      }\n\n      Console.Write(stringBuilder.ToString());\n   }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace AOJ\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar n = int.Parse(Console.ReadLine());\n\t\t\twhile (n-- != 0)\n\t\t\t{\n\t\t\t\tf(Console.ReadLine());\n\t\t\t}\n\t\t}\n\n\t\tstatic void f(string s)\n\t\t{\n\t\t\tvar e = Regex.Replace(s, @\"[\\+\\-\\*\\/\\(\\)=]\", \" $0 \").Split(' ')\n\t\t\t\t.Where(a => a != \"\").ToArray();\n\t\t\tvar i = 0;\n\t\t\tConsole.WriteLine(expr(e, ref i));\n\t\t}\n\n\t\tstatic int factor(string[] e, ref int i)\n\t\t{\n\t\t\tif (e[i] != \"(\")\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\treturn int.Parse(e[i - 1]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\treturn expr(e, ref i);\n\t\t\t}\n\t\t}\n\n\t\tstatic int term(string[] e, ref int i)\n\t\t{\n\t\t\tvar r = factor(e, ref i);\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (e[i] == \"*\")\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tr *= factor(e, ref i);\n\t\t\t\t}\n\t\t\t\telse if (e[i] == \"/\")\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tr /= factor(e, ref i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic int expr(string[] e, ref int i)\n\t\t{\n\t\t\tvar r = term(e, ref i);\n\t\t\twhile (e[i] != \"=\" && e[i] != \")\")\n\t\t\t{\n\t\t\t\tif (e[i] == \"+\")\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tr += term(e, ref i);\n\t\t\t\t}\n\t\t\t\tif (e[i] == \"-\")\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tr -= term(e, ref i);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\treturn r;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        //private static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        //{\n        //    GenerateInMemory = true\n        //};\n\n        private static int Calculate(string expression)\n        {\n            //var provider = new CSharpCodeProvider();\n            //var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            //var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\n            //var theClass = assembly.GetType(\"N.C\");\n            //return (int) theClass.GetMethod(\"Calculate\").Invoke(null, null);\n            return 42;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            // ReSharper disable once RedundantAssignment\n            var line = Console.ReadLine();\n            while ((line = Console.ReadLine()) != null)\n            {\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n                string formula = input.Replace(\"=\", \"\");\n\n                Stack<int> leftIndex = new Stack<int>();\n\n                for (int j = 0; j < formula.Length; j++)\n                {\n                    if (formula[j] == '(')\n                    {\n                        leftIndex.Push(j);\n                    }\n                    else if (formula[j] == ')')\n                    {\n                        int idx = leftIndex.Pop();\n\n                        string subStrA = formula.Substring(idx, j - idx + 1);\n                        string subStrB = formula.Substring(idx + 1, j - idx - 1);\n\n                        Console.WriteLine(\"A: \" + subStrA);\n                        Console.WriteLine(\"B: \" + subStrB);\n\n                        formula = formula.Replace(subStrA, Calc(subStrB));\n                        j = idx;\n                    }\n                }\n                sb.AppendLine(Calc(formula));\n            }\n            Console.Write(sb);\n        }\n\n        static string Calc(string s)\n        {\n            List<string> f1 = new List<string>();\n            List<string> f2 = new List<string>();\n\n            string num = \"\";\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (s[i] >= '0' && s[i] <= '9')\n                {\n                    num += s[i];\n                }\n                else\n                {\n                    f1.Add(num);\n                    num = \"\";\n                    f1.Add(s[i].ToString());\n                }\n            }\n            f1.Add(num);\n\n            for (int i = 0; i < f1.Count; i++)\n            {\n                if (f1[i] == \"*\")\n                {\n                    int temp = int.Parse(f1[i - 1]) * int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else if (f1[i] == \"/\")\n                {\n                    int temp = int.Parse(f1[i - 1]) / int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else\n                {\n                    f2.Add(f1[i]);\n                }\n            }\n\n            int calc = int.Parse(f2[0]);\n\n            for (int i = 1; i < f2.Count; i += 2)\n            {\n                if (f2[i] == \"+\") calc += int.Parse(f2[i + 1]);\n                else if (f2[i] == \"-\") calc -= int.Parse(f2[i + 1]);\n            }\n\n            return calc.ToString();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class SmartCalculator\n{\n   private class EquationNode\n   {\n      public EquationNode left;\n      public EquationNode right;\n\n      public int value { get { return GetValue(this); } }\n      public Func<EquationNode, int> GetValue;\n\n      public static EquationNode Constant(int value)\n      {\n         return new EquationNode{ GetValue = x => value };\n      }\n      public static EquationNode ReferenceRight()\n      {\n         return new EquationNode{ GetValue = x => x.right.value };\n      }\n   }\n\n   public static int Calculate(string equation)\n   {\n      return MakeTree(equation).value;\n   }\n\n   private static EquationNode MakeTree(string equation)\n   {\n      var root = EquationNode.ReferenceRight();\n      root.right = EquationNode.ReferenceRight();\n      var node = root;\n\n      EquationNode valueNode = null;\n      for (int index = 0; index < equation.Length; index++)\n      {\n         char word = equation[index];\n         switch (word)\n         {\n            case '+':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value + x.right.value,\n               };\n               node = root;\n               break;\n            case '-':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value - x.right.value,\n               };\n               node = root;\n               break;\n            case '*':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value * x.right.value,\n               };\n               break;\n            case '/':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value / x.right.value,\n               };\n               break;\n            case '(':\n               {\n                  var end = equation.LastIndexOf(')');\n                  var innerEquation = equation.Substring(index + 1, end - (index + 1));\n                  valueNode = SmartCalculator.MakeTree(innerEquation);\n                  index = end;\n                  break;\n               }\n            default:\n               // 数値\n               {\n                  var end = index;\n                  while (end < equation.Length && '0' <= equation[end] && equation[end] <= '9')\n                  {\n                     end++;\n                  }\n                  var innerEquation = equation.Substring(index, end - index);\n                  int value = int.Parse(innerEquation);\n                  valueNode = EquationNode.Constant(value);\n                  index = end - 1;\n                  break;\n               }\n         }\n      }\n\n      node.right.right = valueNode;\n\n      return root;\n   }\n}\n\nclass MainClass\n{\n   static void Main(string[] args)\n   {\n      var stringBuilder = new StringBuilder();\n\n      int n = int.Parse(Console.ReadLine());\n      for (; n > 0; n--)\n      {\n         var equation = Console.ReadLine().TrimEnd('=');\n         var result = SmartCalculator.Calculate(equation);\n\n         stringBuilder.AppendLine(result.ToString());\n      }\n\n      Console.Write(stringBuilder.ToString());\n   }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PaizaSample\n{\n\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n\n\n        for (int i = 0; i < n; i++)\n        {\n            List<string> list = new List<string>();\n            List<char> temp = new List<char>();\n            string input = Console.ReadLine();\n\n            bool numFlag = false;\n\n            for (int j = 0; j < input.Length; j++)\n            {\n                switch (input[j])\n                {\n                    case '+':\n                    case '-':\n                        \n                        if (temp.Count > 0 && (temp[temp.Count - 1] == '*' || temp[temp.Count - 1] == '/'))\n                        {\n                            list.Add(temp[temp.Count - 1].ToString());\n                        }\n                        else\n                        {\n                            temp.Add(input[j]);\n                        }\n                        numFlag = false;\n                        break;\n                    case '*':\n                    case '/':\n                        temp.Add(input[j]);\n                        numFlag = false;\n                        break;\n                    case '(':\n                        temp.Add('(');\n                        break;\n                    case ')':\n                        for (int k = temp.Count - 1; k >= 0; k--)\n                        {\n                            if (temp[k] == '(')\n                            {\n                                temp.RemoveAt(k);\n                                break;\n                            }\n                            else\n                            {\n                                list.Add(temp[k].ToString());\n                                temp.RemoveAt(k);\n                            }\n                        }\n                        numFlag = false;\n                        break;\n                    case '=':\n                        for (int k = temp.Count - 1; k >= 0; k--)\n                        {\n                            list.Add(temp[k].ToString());\n                            temp.RemoveAt(k);\n                        }\n                        break;\n                    default:\n                        if (numFlag)\n                        {\n                            list[list.Count - 1] += input[j];\n                        }\n                        else\n                        {\n                            list.Add(input[j].ToString());\n                        }\n                        numFlag = true;\n                        break;\n                }\n\n            }\n\n            //foreach (string s in list)\n            //{\n            //    Console.Write(s + \" \");\n            //}\n\n            //Console.WriteLine();\n\n            int cursol = 2;\n            while (true)\n            {\n                if (list.Count == 1)\n                {\n                    break;\n                }\n\n                switch (list[cursol])\n                {\n                    case \"+\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) + int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"-\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) - int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"*\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) * int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"/\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) / int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    default:\n                        cursol++;\n                        break;\n\n                }\n\n\n            }\n\n            Console.WriteLine(list[0]);\n\n        }\n\n\n        //Console.ReadKey();\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n                string s1 = \"\";\n\n                Stack<int> leftB_Index = new Stack<int>();\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] == '(') leftB_Index.Push(j);\n                    else if (input[j] == ')')\n                    {\n                        int idx = leftB_Index.Pop();\n\n                        string subStr = input.Substring(idx + 1, j - idx - 1);\n\n                        s1 = input.Replace(subStr, Calc(subStr));\n                    }\n                    else\n                    {\n                        s1 += input[j];\n                    }\n                }\n\n                string s2 = \"\";\n\n                for (int j = 0; j < s1.Length; j++)\n                {\n                    if (s1[j] >= '0' && s1[j] <= '9')\n                    {\n                        s2 += s1[j];\n                    }\n                    else if (s1[j] == '+' || s1[j] == '-' || s1[j] == '*' || s1[j] == '/')\n                    {\n                        s2 += s1[j];\n                    }\n                }\n                sb.AppendLine(Calc(s2));\n            }\n            Console.Write(sb);\n        }\n\n        static string Calc(string s)\n        {\n            List<string> f1 = new List<string>();\n            List<string> f2 = new List<string>();\n\n            string num = \"\";\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (s[i] >= '0' && s[i] <= '9')\n                {\n                    num += s[i];\n                }\n                else\n                {\n                    f1.Add(num);\n                    num = \"\";\n                    f1.Add(s[i].ToString());\n                }\n            }\n            f1.Add(num);\n\n            for (int i = 0; i < f1.Count; i++)\n            {\n                if (f1[i] == \"*\")\n                {\n                    int temp = int.Parse(f1[i - 1]) * int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else if (f1[i] == \"/\")\n                {\n                    int temp = int.Parse(f1[i - 1]) / int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else\n                {\n                    f2.Add(f1[i]);\n                }\n            }\n\n            int calc = int.Parse(f2[0]);\n\n            for (int i = 1; i < f2.Count; i += 2)\n            {\n                if (f2[i] == \"+\") calc += int.Parse(f2[i + 1]);\n                else if (f2[i] == \"-\") calc -= int.Parse(f2[i + 1]);\n            }\n\n            return calc.ToString();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class SmartCalculator\n{\n   private class EquationNode\n   {\n      public EquationNode left;\n      public EquationNode right;\n\n      public int value { get { return GetValue(this); } }\n      public Func<EquationNode, int> GetValue;\n\n      public static EquationNode Constant(int value)\n      {\n         return new EquationNode{ GetValue = x => value };\n      }\n      public static EquationNode ReferenceRight()\n      {\n         return new EquationNode{ GetValue = x => x.right.value };\n      }\n   }\n\n   public static int Calculate(string equation)\n   {\n      return MakeTree(equation).value;\n   }\n\n   private static EquationNode MakeTree(string equation)\n   {\n      var root = EquationNode.ReferenceRight();\n      root.right = EquationNode.ReferenceRight();\n      var node = root;\n\n      EquationNode valueNode = null;\n      for (int index = 0; index < equation.Length; index++)\n      {\n         char word = equation[index];\n         switch (word)\n         {\n            case '+':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value + x.right.value,\n               };\n               node = root;\n               break;\n            case '-':\n               node.right.right = valueNode;\n               root = new EquationNode\n               {\n                  left = root,\n                  right = EquationNode.ReferenceRight(),\n                  GetValue = x => x.left.value - x.right.value,\n               };\n               node = root;\n               break;\n            case '*':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value * x.right.value,\n               };\n               break;\n            case '/':\n               node.right.right = valueNode;\n               node.right = new EquationNode\n               {\n                  left = node.right,\n                  GetValue = x => x.left.value / x.right.value,\n               };\n               break;\n            case '(':\n               {\n                  int nest = 1;\n                  int end;\n                  for (end = index + 1; nest > 0; end++)\n                  {\n                     switch (equation[end])\n                     {\n                        case '(':\n                           nest++;\n                           break;\n                        case ')':\n                           nest--;\n                           break;\n                     }\n                  }\n                  var innerEquation = equation.Substring(index + 1, (end - 1) - (index + 1));\n                  valueNode = MakeTree(innerEquation);\n                  index = end - 1;\n                  break;\n               }\n            default:\n               // 数値\n               {\n                  var end = index;\n                  while (end < equation.Length && '0' <= equation[end] && equation[end] <= '9')\n                  {\n                     end++;\n                  }\n                  var innerEquation = equation.Substring(index, end - index);\n                  int value = int.Parse(innerEquation);\n                  valueNode = EquationNode.Constant(value);\n                  index = end - 1;\n                  break;\n               }\n         }\n      }\n\n      node.right.right = valueNode;\n\n      return root;\n   }\n}\n\nclass MainClass\n{\n   static void Main(string[] args)\n   {\n      var stringBuilder = new StringBuilder();\n\n      int n = int.Parse(Console.ReadLine());\n      for (; n > 0; n--)\n      {\n         var equation = Console.ReadLine().TrimEnd('=');\n         var result = SmartCalculator.Calculate(equation);\n\n         stringBuilder.AppendLine(result.ToString());\n      }\n\n      Console.Write(stringBuilder.ToString());\n   }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static int Calculate(string expression)\n        {\n            var provider = new CSharpCodeProvider();\n            var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\n            var theClass = assembly.GetType(\"N.C\");\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n\n                Stack<int> leftB_Index = new Stack<int>();\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] == '(') leftB_Index.Push(j);\n                    else if (input[j] == ')')\n                    {\n                        int idx = leftB_Index.Pop();\n\n                        string subStr = input.Substring(idx + 1, j - idx - 1);\n\n                        input = input.Replace(subStr, Calc(subStr));\n                    }\n                }\n\n                string formula = \"\";\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    if (input[j] >= '0' && input[j] <= '9')\n                    {\n                        formula += input[j];\n                    }\n                    else if (input[j] == '+' || input[j] == '-' || input[j] == '*' || input[j] == '/')\n                    {\n                        formula += input[j];\n                    }\n                }\n                sb.AppendLine(Calc(formula));\n            }\n            Console.Write(sb);\n        }\n\n        static string Calc(string s)\n        {\n            List<string> f1 = new List<string>();\n            List<string> f2 = new List<string>();\n\n            string num = \"\";\n\n            for (int i = 0; i < s.Length; i++)\n            {\n                if (s[i] >= '0' && s[i] <= '9')\n                {\n                    num += s[i];\n                }\n                else\n                {\n                    f1.Add(num);\n                    num = \"\";\n                    f1.Add(s[i].ToString());\n                }\n            }\n\n            if (num != \"\") f1.Add(num);\n\n            for (int i = 0; i < f1.Count; i++)\n            {\n                if (f1[i] == \"*\")\n                {\n                    int temp = int.Parse(f1[i - 1]) * int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else if (f1[i] == \"/\")\n                {\n                    int temp = int.Parse(f1[i - 1]) / int.Parse(f1[i + 1]);\n                    f2[f2.Count - 1] = temp.ToString();\n                    i++;\n                }\n                else\n                {\n                    f2.Add(f1[i]);\n                }\n            }\n\n            int calc = int.Parse(f2[0]);\n\n            for (int i = 1; i < f2.Count; i += 2)\n            {\n                if (f2[i] == \"+\") calc += int.Parse(f2[i + 1]);\n                else if (f2[i] == \"-\") calc -= int.Parse(f2[i + 1]);\n            }\n\n            return calc.ToString();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing Microsoft.CSharp;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\n\nclass Program\n{\n    static void Main()\n    {\n        int n = Int32.Parse(Console.ReadLine());\n        for (int i = 0; i < n; i++)\n        {\n            string ex = Console.ReadLine();\n            var script =\n    @\"\nusing System;\nclass Program\n{\n    public void Main()\n    {\n        Console.WriteLine(\" + ex + @\");\n    }\n}\n\";\n\n            var assemblyNames = new[]\n                {\n                    \"System.dll\",\n                };\n\n            CompilerResults results;\n            var param = new CompilerParameters(assemblyNames)\n            {\n                GenerateInMemory = true,\n                IncludeDebugInformation = false,\n            };\n\n            var codeProvider = new CSharpCodeProvider();\n            results = codeProvider.CompileAssemblyFromSource(param, script);\n            var type = results.CompiledAssembly.GetType(\"Program\");\n            var parameters = new object[0];\n            var instance = Activator.CreateInstance(type);\n            type.GetMethod(\"Main\")\n                .Invoke(instance, parameters);\n        }\n        if (n != 0) Main();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n                string formula = input.Replace(\"=\", \"\");\n\n                Stack<int> leftIndex = new Stack<int>();\n\n                for (int j = 0; j < formula.Length; j++)\n                {\n                    if (formula[j] == '(')\n                    {\n                        leftIndex.Push(j);\n                    }\n                    else if (formula[j] == ')')\n                    {\n                        int idx = leftIndex.Pop();\n\n                        string subStrA = formula.Substring(idx, j - idx + 1);\n                        string subStrB = formula.Substring(idx + 1, j - idx - 1);\n\n                        formula = formula.Replace(subStrA, Calc(subStrB));\n                        j = idx;\n                    }\n                }\n                sb.AppendLine(Calc(formula));\n            }\n            Console.Write(sb);\n        }\n\n        static string Calc(string formula)\n        {\n            List<string> fl1 = new List<string>();\n\n            string num = \"\";\n\n            for (int i = 0; i < formula.Length; i++)\n            {\n                switch (formula[i])\n                {\n                    case '+':\n                        if (num != \"\")\n                        {\n                            fl1.Add(num);\n                            num = \"\";\n                        }\n                        break;\n                    case '-':\n                        if (num != \"\")\n                        {\n                            fl1.Add(num);\n                            num = \"\";\n                        }\n                        num += formula[i];\n                        break;\n                    case '*':\n                        fl1.Add(num);\n                        num = \"\";\n                        fl1.Add(formula[i].ToString());\n                        break;\n                    case '/':\n                        fl1.Add(num);\n                        num = \"\";\n                        fl1.Add(formula[i].ToString());\n                        break;\n                    default:\n                        num += formula[i];\n                        break;\n                }\n            }\n            if (num != \"\") fl1.Add(num);\n\n            List<int> fl2 = new List<int>();\n\n            for (int i = 0; i < fl1.Count; i++)\n            {\n                switch (fl1[i])\n                {\n                    case \"*\":\n                        fl2[fl2.Count - 1] *= int.Parse(fl1[i + 1]);\n                        i++;\n                        break;\n                    case \"/\":\n                        fl2[fl2.Count - 1] /= int.Parse(fl1[i + 1]);\n                        i++;\n                        break;\n                    default:\n                        fl2.Add(int.Parse(fl1[i]));\n                        break;\n                }\n            }\n            return fl2.Sum().ToString();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var t1 = new[] { \"+\", \"-\", \"*\", \"/\", \"(\", \")\", \"=\" };\n            var t2 = new[] { \" + \", \" - \", \" * \", \" / \", \"( \", \" )\", \" =\" };\n            for (int i = int.Parse(Console.ReadLine()); i > 0; --i) {\n                var f = Console.ReadLine();\n                for (int j = 0; j < t1.Length; ++j) {\n                    f = f.Replace(t1[j], t2[j]);\n                }\n                int r = 0;\n                Console.WriteLine(e(f.Split(), ref r));\n            }\n        }\n        static int e(string[] t, ref int i) {\n            int r = t[i++] == \"(\" ? e(t, ref i) : int.Parse(t[i - 1]);\n            while (t[i] != \")\" && t[i] != \"=\") {\n                switch (t[i++]) {\n                    case \"+\":\n                        r += e(t, ref i);\n                        break;\n                    case \"-\":\n                        r -= e(t, ref i);\n                        break;\n                    case \"/\":\n                        r /= t[i++] == \"(\" ? e(t, ref i) : int.Parse(t[i - 1]);\n                        break;\n                    case \"*\":\n                        r *= t[i++] == \"(\" ? e(t, ref i) : int.Parse(t[i - 1]);\n                        break;\n                }\n            }\n            return r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nnamespace ?¨???????\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int k = int.Parse(Console.ReadLine());\n            for (int i = 0; i < k; i++)\n            {\n                string q = Console.ReadLine().Replace(\"=\",\"\");\n                q = \"(\" + q + \")\";\n                Ans(ref q);\n                Console.WriteLine(q);\n            }\n        }\n        static string Ans(ref string q)\n        {\n            int s0 = 0, s1 = 0;\n            for (int i = 0; i < q.Length; i++)\n            {\n                string qc = q.Substring(i, 1);\n                if (qc.Equals(\"(\"))\n                    s0 = i;\n                else if (qc.Equals(\")\"))\n                {\n                    s1 = i;\n                    string u = q.Substring(s0, s1 - s0 + 1);\n                    q = q.Replace(u, ans(u.Substring(1, u.Length - 2)).ToString());\n                    Ans(ref q);\n                }\n            }\n            return q;\n        }\n        static double ans(string q)\n        {\n            string[] p = q.Split('+');\n            double a = 0;\n            for (int i = 0; i < p.Length; i++)\n            {\n                string pp = p[i];\n                if (pp.Contains('-'))\n                {\n                    string[] mm = pp.Split('-');\n                    double a0 = ans2(mm[0]);\n                    for (int j = 1; j < mm.Length; j++)\n                    {\n                        a0 -= ans2(mm[j]);\n                    }\n                    p[i] = a0.ToString();\n                }\n                a += ans2(p[i]);\n            }\n            return a;\n        }\n        static double ans2(string q)\n        {\n            string[] qq = q.Split('*');\n            double aa0 = 0;\n            for (int i = 0; i < qq.Length; i++)\n            {\n                string[] qp = qq[i].Split('/');\n                double a0 = double.Parse(qp[0]);\n                for (int j = 1; j < qp.Length; j++)\n                {\n                    a0 /= double.Parse(qp[j]);\n                }\n                if (i == 0)\n                {\n                    aa0 = a0;\n                }\n                else\n                {\n                    aa0 *= a0;\n                }\n            }\n            return aa0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static int Calculate(string expression)\n        {\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nnamespace myproject\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int k = int.Parse(Console.ReadLine());\n            for (int i = 0; i < k; i++)\n            {\n                string q = Console.ReadLine().Replace(\"=\",\"\");\n                q = \"(\" + q + \")\";\n                Ans(ref q);\n                Console.WriteLine(q);\n            }\n        }\n        static string Ans(ref string q)\n        {\n            int s0 = 0, s1 = 0;\n            for (int i = 0; i < q.Length; i++)\n            {\n                string qc = q.Substring(i, 1);\n                if (qc.Equals(\"(\"))\n                    s0 = i;\n                else if (qc.Equals(\")\"))\n                {\n                    s1 = i;\n                    string u = q.Substring(s0, s1 - s0 + 1);\n                    q = q.Replace(u, ans(u.Substring(1, u.Length - 2)).ToString());\n                    Ans(ref q);\n                }\n            }\n            return q;\n        }\n        static double ans(string q)\n        {\n            string[] p = q.Split('+');\n            double a = 0;\n            for (int i = 0; i < p.Length; i++)\n            {\n                string pp = p[i];\n                if (pp.Contains('-'))\n                {\n                    string[] mm = pp.Split('-');\n                    double a0 = ans2(mm[0]);\n                    for (int j = 1; j < mm.Length; j++)\n                    {\n                        a0 -= ans2(mm[j]);\n                    }\n                    p[i] = a0.ToString();\n                }\n                a += ans2(p[i]);\n            }\n            return a;\n        }\n        static double ans2(string q)\n        {\n            string[] qq = q.Split('*');\n            double aa0 = 0;\n            for (int i = 0; i < qq.Length; i++)\n            {\n                string[] qp = qq[i].Split('/');\n                double a0 = double.Parse(qp[0]);\n                for (int j = 1; j < qp.Length; j++)\n                {\n                    a0 /= double.Parse(qp[j]);\n                }\n                if (i == 0)\n                {\n                    aa0 = a0;\n                }\n                else\n                {\n                    aa0 *= a0;\n                }\n            }\n            return aa0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static int Calculate(string expression)\n        {\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            //var provider = new CSharpCodeProvider();\n            //var source = string.Format(\"namespace N{{public static class C{{public static int Calculate(){{return {0};}}}}}}\", expression);\n            //var assembly = provider.CompileAssemblyFromSource(CompilerParameters, source).CompiledAssembly;\n            //var theClass = assembly.GetType(\"N.C\");\n            //return (int) theClass.GetMethod(\"Calculate\").Invoke(null, null);\n            return 42;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            // ReSharper disable once RedundantAssignment\n            var line = Console.ReadLine();\n            while ((line = Console.ReadLine()) != null)\n            {\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        public static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Data;\n\nnamespace ConsoleApplication_C\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DataTable dt = new DataTable();\n            int n = int.Parse(Console.ReadLine());\n            for(int i = 0; i < n; i++)\n            {\n                string s = Console.ReadLine();\n                s = s.Remove(s.Length - 1);\n                Console.WriteLine(dt.Compute(s,null));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PaizaSample\n{\n\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n\n\n        for (int i = 0; i < n; i++)\n        {\n            List<string> list = new List<string>();\n            List<char> temp = new List<char>();\n            string input = Console.ReadLine();\n\n            bool numFlag = false;\n\n            for (int j = 0; j < input.Length; j++)\n            {\n                switch (input[j])\n                {\n                    case '+':\n                    case '-':\n                        \n                        if (temp.Count > 0 && (temp[temp.Count - 1] == '*' || temp[temp.Count - 1] == '/'))\n                        {\n                            list.Add(temp[temp.Count - 1].ToString());\n                        }\n                        else\n                        {\n                            temp.Add(input[j]);\n                        }\n                        numFlag = false;\n                        break;\n                    case '*':\n                    case '/':\n                        temp.Add(input[j]);\n                        numFlag = false;\n                        break;\n                    case '(':\n                        temp.Add('(');\n                        break;\n                    case ')':\n                        for (int k = temp.Count - 1; k > 0; k--)\n                        {\n                            if (temp[k] == '(')\n                            {\n                                temp.RemoveAt(k);\n                                break;\n                            }\n                            else\n                            {\n                                list.Add(temp[k].ToString());\n                                temp.RemoveAt(k);\n                            }\n                        }\n                        numFlag = false;\n                        break;\n                    case '=':\n                        for (int k = temp.Count - 1; k >= 0; k--)\n                        {\n                            list.Add(temp[k].ToString());\n                            temp.RemoveAt(k);\n                        }\n                        break;\n                    default:\n                        if (numFlag)\n                        {\n                            list[list.Count - 1] += input[j];\n                        }\n                        else\n                        {\n                            list.Add(input[j].ToString());\n                        }\n                        numFlag = true;\n                        break;\n                }\n\n            }\n\n            //foreach (string s in list)\n            //{\n            //    Console.Write(s + \" \");\n            //}\n\n            //Console.WriteLine();\n\n            int cursol = 2;\n            while (true)\n            {\n                if (list.Count == 1)\n                {\n                    break;\n                }\n\n                switch (list[cursol])\n                {\n                    case \"+\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) + int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"-\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) - int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"*\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) * int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    case \"/\":\n                        list[cursol - 2] = (int.Parse(list[cursol - 2]) / int.Parse(list[cursol - 1])).ToString();\n                        list.RemoveRange(cursol - 1, 2);\n                        cursol--;\n                        break;\n                    default:\n                        cursol++;\n                        break;\n\n                }\n\n\n            }\n\n            Console.WriteLine(list[0]);\n\n        }\n\n\n        //Console.ReadKey();\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.CodeDom.Compiler;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.CSharp;\n\nnamespace AOJ0109\n{\n    class Program\n    {\n        private static readonly CompilerParameters CompilerParameters = new CompilerParameters\n        {\n            GenerateInMemory = true\n        };\n\n        private static int Calculate(string expression)\n        {\n            return 0;\n        }\n\n        private static void Main()\n        {\n            ReadInputs()\n                .Select(Calculate)\n                .ForEach(Console.WriteLine);\n        }\n\n        private static IEnumerable<string> ReadInputs()\n        {\n            var count = int.Parse(Console.ReadLine());\n            for(var i = 0; i < count; i++)\n            {\n                var line = Console.ReadLine();\n                yield return line.Remove(line.Length - 1);\n            }\n        }\n    }\n\n    static class EnumerableExtensions\n    {\n        public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n        {\n            foreach (var item in source)\n            {\n                action(item);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing Microsoft.CSharp;\nusing System.CodeDom.Compiler;\nusing System.Reflection;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = Int32.Parse(Console.ReadLine());\n        for (int i = 0; i < n; i++)\n        {\n            string ex = Console.ReadLine();\n            if (ex[ex.Length - 1] == '=') ex = ex.Substring(0, ex.Length - 1);\n            var script =\n    @\"\nusing System;\nclass Program\n{\n    public void Main()\n    {\n        Console.WriteLine(\" + ex + @\");\n    }\n}\n\";\n\n            var assemblyNames = new[]\n                {\n                    \"System.dll\",\n                };\n\n            CompilerResults results;\n            var param = new CompilerParameters(assemblyNames)\n            {\n                GenerateInMemory = true,\n                IncludeDebugInformation = false,\n            };\n\n            var codeProvider = new CSharpCodeProvider();\n            results = codeProvider.CompileAssemblyFromSource(param, script);\n            var type = results.CompiledAssembly.GetType(\"Program\");\n            var parameters = new object[0];\n            var instance = Activator.CreateInstance(type);\n            type.GetMethod(\"Main\")\n                .Invoke(instance, parameters);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    input = input.split('\\n');\n    main();\n});\n\nfunction main() {\n    var\n    i,\n    n = +input[0],\n    lines = input.slice(1);\n    for(i = 0; i < n; i++) {\n        console.log(calc(lines[i]));\n    }\n}\n\nfunction calc(src) {\n    src = src.replace(/([-+*\\/()=])/g, ' $1 ').split(' ').filter(function(s) {\n        return s.trim() !== '';\n    });\n    return add(src);\n\n    function add(src) {\n        var\n        ret = mul(src);\n        while(src[0] in {'+': 1,'-': 1}) {\n            switch(src.shift()) {\n            case '+':\n                ret += mul(src);\n                break;\n            case '-':\n                ret -= mul(src);\n                break;\n            }\n        }\n        return ret;\n    }\n\n    function mul(src) {\n        var\n        ret = prim(src);\n        while(src[0] in {'*': 1,'/': 1}) {\n            switch(src.shift()) {\n            case '*':\n                ret *= prim(src);\n                break;\n            case '/':\n                ret = Math.floor(ret / prim(src));\n                break;\n            }\n        }\n        return ret;\n    }\n\n    function prim(src) {\n        var\n        ret, \n        head = src.shift();\n        switch(head) {\n        case '+':\n           return prim(src);\n        case '-':\n           return -prim(src);\n        case '(':\n           ret = add(src);\n           src.shift();\n           return ret;\n        default:\n           return parseInt(head, 10);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "(function (input) {\n    function expression() {\n        var num = term();\n\n        while(true) {\n            if ( code[cp] === \"+\" ) {\n                cp++;\n                num += term();\n            } else if ( code[cp] === \"-\" ) {\n                cp++;\n                num -= term();\n            } else {\n                break;\n            }\n        }\n        return num;\n    }\n    function term() {\n        var num = bracket();\n\n        while(true) {\n            if ( code[cp] === \"*\" ) {\n                cp++;\n                num = Math.floor(num * bracket());\n            } else if ( code[cp] === \"/\" ) {\n                cp++;\n                num = Math.floor(num / bracket());\n            } else {\n                break;\n            }\n        }\n\n        return num;\n    }\n\n    function bracket() {\n        var num;\n\n        if ( code[cp] == \"(\" ) {\n            cp++;   // (を読み飛ばす\n            num = expression();\n            cp++;   // )を読み飛ばす\n        } else {\n            return number();\n        }\n\n        return num;\n    }\n\n    function number() {\n        var num = 0;\n\n        while ( code[cp].match(/[0-9]/) ) {\n            num *= 10;\n            num += parseInt(code[cp]);\n            cp++;\n        }\n\n        return num;\n    }\n\n    var inputs = input.replace(/\\r/g, '').split(\"\\n\"),\n        cp,\n        n;\n\n    n = parseInt(inputs.shift());\n\n    while (n--) {\n        var code = inputs.shift().replace(/\\s/g, \"\");\n        cp = 0;\n\n        console.log(expression());\n    }\n})(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "var\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    input = input.split('\\n');\n    main();\n});\n\nfunction main() {\n    var\n    i,\n    n = +input[0],\n    lines = input.slice(1);\n    for(i = 0; i < n; i++) {\n        console.log(calc(lines[i]));\n    }\n}\n\nfunction calc(src) {\n    var\n    v, n,\n    op = {'+': 1,'-': 1,'*': 2,'/': 2},\n    ns = [],\n    os = [];\n    src = src.replace(/([-+*\\/=()])/g, ' $1 ').split(' ');\n    while((v = src.shift()) !== '=') {// console.log(v || ' ', ns, os);\n        if(!v) continue;\n\tn = parseInt(v, 10);\n        debugger;\n\tif(isNaN(n)) {\n            if(op[v] && os.length && op[v] < op[os[0]]) {\n                ns.push(oeval(os.shift(), ns.pop(), ns.pop()));\n            }\n\t    if(op[v] || v === '(') {\n\t        os.unshift(v);\n\t    }\n\t    if(v === ')') {\n                while((v = os.shift()) !== '(') {\n                    ns.push(oeval(v, ns.pop(), ns.pop()));\n\t        }\n\t    }\n        } else {\n\t    ns.push(n);\n\t}\n    }\n    while((v = os.shift()) !== undefined) {\n\tns.push(oeval(v, ns.pop(), ns.pop()));\n    }\n    return ns[0];\n\n    function oeval(op, b, a) {\n\tswitch(op) {\n\t    case '+':\n\t\treturn a + b;\n            case '-':\n\t\treturn a - b;\n            case '*':\n\t\treturn a * b;\n            case '/':\n\t\treturn Math.floor(a / b);\n\t}\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var Arr=(input.trim()).split(\"\\n\");\nvar L=Arr.shift()-0;\nfor(var i=0;i<L;i++){\n   var str=Arr[i];\n   str=str.slice(0,-1);\n   str=str.replace(/(\\d+)\\.\\d+/g,\"$1\");\n   var num=eval(str);\n   console.log(parseInt(num,10));\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar L=Arr.shift()-0;\nfor(var i=0;i<L;i++){\n   var str=Arr[i];\n   str=str.slice(0,-1);\n   console.log(eval(str));\n}"
  },
  {
    "language": "JavaScript",
    "code": "(function (input) {\n    function expression() {\n        var num = term();\n\n        while(true) {\n            if ( code[cp] === \"+\" ) {\n                cp++;\n                num += term();\n            } else if ( code[cp] === \"-\" ) {\n                cp++;\n                num -= term();\n            } else {\n                break;\n            }\n        }\n        return num;\n    }\n    function term() {\n        var num = bracket();\n\n        while(true) {\n            if ( code[cp] === \"*\" ) {\n                cp++;\n                num *= bracket();\n            } else if ( code[cp] === \"/\" ) {\n                cp++;\n                num /= bracket();\n            } else {\n                break;\n            }\n        }\n\n        return num;\n    }\n\n    function bracket() {\n        var num;\n\n        if ( code[cp] == \"(\" ) {\n            cp++;   // (を読み飛ばす\n            num = expression();\n            cp++;   // )を読み飛ばす\n        } else {\n            return number();\n        }\n\n        return num;\n    }\n\n    function number() {\n        var num = 0;\n\n        while ( code[cp].match(/[0-9]/) ) {\n            num *= 10;\n            num += parseInt(code[cp]);\n            cp++;\n        }\n\n        return num;\n    }\n\n    var inputs = input.replace(/\\r/g, '').split(\"\\n\"),\n        cp,\n        n;\n\n    n = parseInt(inputs.shift());\n\n    while (n--) {\n        var code = inputs.shift().replace(/\\s/g, \"\");\n        cp = 0;\n\n        console.log(expression());\n    }\n})(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\n\nprocess.stdin.on('end', function() {\n    main(input.split('\\n'));\n});\n\nfunction main(input) {\n    input.slice(1).forEach(function(expr) {\n        console.log(eval(expr.slice(0,-1)));\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\nvar util = require(\"util\"),\n    puts = console.log,\n    p = util.print,\n    cin = parseInput();\n\nfunction expression() {\n    var n = term();\n\n    while(true) {\n        if ( line[idx] == \"+\" ) {\n            idx++;\n            n += term();\n        } else if ( line[idx] == \"-\" ) {\n            idx++;\n            n -= term();\n        } else {\n            break;\n        }\n    }\n    return n;\n}\n\nfunction term() {\n    var n = factor();\n\n    while(true) {\n        if ( line[idx] == \"*\" ) {\n            idx++;\n            n *= factor();\n        } else if ( line[idx] == \"/\" ) {\n            idx++;\n            n = ~~(n / factor());\n        } else {\n            break;\n        }\n    }\n    return n;\n}\n\nfunction factor() {\n    while(true) {\n        if ( line[idx] == \"(\" ) {\n            idx++;\n            return expression();\n        } else if ( line[idx] == \")\" ) {\n            idx++;\n        } else {\n            break;\n        }\n    }\n    var n = number();\n    return n;\n}\n\nfunction number() {\n    var ret;\n\n    while(true) {\n        if ( /^\\d/.test(line[idx]) ) {\n            ret = ret ? ret * 10 + +line[idx] : +line[idx];\n            idx++;\n        }\n        else break;\n    }\n    return ret;\n}\n\nvar n = cin.nextInt(),\n    line, idx;\n\nwhile(n--) {\n    idx = 0;\n\n    line = cin.next();\n    line = line.slice(0, line.length - 1);\n\n    puts(expression());\n}\n\nfunction parseInput(useSplitSpace) {\n    var index = 0,\n        ret = [],\n        input = require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"),\n        inputs = input.replace(/\\r/g, '').split(\"\\n\");\n\n    useSplitSpace = useSplitSpace || true;\n\n    // 入力を改行/空白で区切り平坦な配列に変換\n    inputs.forEach(function(val) {\n        if ( useSplitSpace && val !== \"\" ) {\n            val.split(\" \").forEach(function(el) {\n                if ( el !== \"\" ) ret.push(el);\n            });\n        } else {\n            ret.push(val);\n        }\n    });\n\n    return {\n        hasNext: function(val) {\n            if ( typeof val === \"undefined\" ) {\n                return typeof ret[index] !== \"undefined\";\n            } else {\n                return ret[index] === val;\n            }\n        },\n        next: function() {\n            if ( typeof ret[index+1] === \"undefined\" ) throw new RangeError(\"Index out of bounds at '\" + index+1 + \"'\");\n            return ret[index++];\n        },\n        nextNumber: function () {\n            if ( !/^\\d+$/.test(this.top()) ) throw new TypeError(\"'\" + this.top() + \"' cannot convet to Number\");\n            return +this.next();\n        },\n        nextInt: function() {\n            return parseInt(this.nextNumber());\n        },\n        top: function() {\n            return ret[index];\n        },\n        rewind: function() {\n            index = 0;\n        }\n    };\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\nvar util = require(\"util\"),\n    puts = console.log,\n    p = util.print,\n    cin = parseInput();\n\nfunction expression() {\n    var n = term();\n\n    while(true) {\n        if ( line[idx] == \"+\" ) {\n            idx++;\n            n += term();\n        } else if ( line[idx] == \"-\" ) {\n            idx++;\n            n -= term();\n        } else {\n            break;\n        }\n    }\n    return n;\n}\n\nfunction term() {\n    var n = factor();\n\n    while(true) {\n        if ( line[idx] == \"*\" ) {\n            idx++;\n            n *= factor();\n        } else if ( line[idx] == \"/\" ) {\n            idx++;\n            n = ~~(n / factor());\n        } else {\n            break;\n        }\n    }\n    return n;\n}\n\nfunction factor() {\n    while(true) {\n        if ( line[idx] == \"(\" ) {\n            idx++;\n            return expression();\n        } else if ( line[idx] == \")\" ) {\n            idx++;\n        } else {\n            break;\n        }\n    }\n    var n = number();\n    return n;\n}\n\nfunction number() {\n    var ret, sign = 1;\n\n    if ( line[idx] == \"-\" ) {\n        idx++;\n        sign = -1;\n    }\n\n    while(true) {\n        if ( /^\\d/.test(line[idx]) ) {\n            ret = ret ? ret * 10 + +line[idx] : +line[idx];\n            idx++;\n        }\n        else break;\n    }\n    return ret * sign;\n}\n\nvar n = cin.nextInt(),\n    line, idx;\n\nwhile(n--) {\n    idx = 0;\n\n    line = cin.next();\n    line = line.slice(0, line.length - 1);\n\n    puts(expression());\n}\n\nfunction parseInput(useSplitSpace) {\n    var index = 0,\n        ret = [],\n        input = require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"),\n        inputs = input.replace(/\\r/g, '').split(\"\\n\");\n\n    useSplitSpace = useSplitSpace || true;\n\n    // 入力を改行/空白で区切り平坦な配列に変換\n    inputs.forEach(function(val) {\n        if ( useSplitSpace && val !== \"\" ) {\n            val.split(\" \").forEach(function(el) {\n                if ( el !== \"\" ) ret.push(el);\n            });\n        } else {\n            ret.push(val);\n        }\n    });\n\n    return {\n        hasNext: function(val) {\n            if ( typeof val === \"undefined\" ) {\n                return typeof ret[index] !== \"undefined\";\n            } else {\n                return ret[index] === val;\n            }\n        },\n        next: function() {\n            if ( typeof ret[index+1] === \"undefined\" ) throw new RangeError(\"Index out of bounds at '\" + index+1 + \"'\");\n            return ret[index++];\n        },\n        nextNumber: function () {\n            if ( !/^\\d+$/.test(this.top()) ) throw new TypeError(\"'\" + this.top() + \"' cannot convet to Number\");\n            return +this.next();\n        },\n        nextInt: function() {\n            return parseInt(this.nextNumber());\n        },\n        top: function() {\n            return ret[index];\n        },\n        rewind: function() {\n            index = 0;\n        }\n    };\n}"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    main(chunk.trim());\n});\n\nfunction main(chunk){\n    var lines = chunk.split(\"\\n\");\n    for(var i=1;i<lines.length;i++){\n        console.log(eval(lines[i].replace(\"=\",\"\")));\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\n\nprocess.stdin.on('end', function() {\n    main(input.split('\\n'));\n});\n\nfunction main(input) {\n    var n = +input[0];\n    for(var i = 0; i < n; ++i) console.log(eval(input[i+1].slice(0,-1))|0);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar L=Arr.shift()-0;\nfor(var i=0;i<L;i++){\n   var str=Arr[i];\n   str=str.slice(0,-1);\n   str=str.replace(/(\\d+)\\.\\d+/g,\"$1\");\n   var num=eval(str);\n   console.log(parseInt(num,10));\n}"
  },
  {
    "language": "JavaScript",
    "code": "// Generated by CoffeeScript 1.3.3\n(function() {\n  var a=[];\n  var stdin = process.openStdin();\n  stdin.setEncoding('utf8');\n\n  var proc = function(s) {\n    var bidx, count, eidx, m;\n    bidx = s.indexOf('(');\n    while (bidx !== -1) {\n      count = 1;\n      eidx = bidx + 1;\n      while (count > 0) {\n        if (s[eidx] === '(') {\n          count++;\n        }\n        if (s[eidx] === ')') {\n          count--;\n        }\n        eidx++;\n      }\n      s = s.substring(0, bidx) + proc(s.substring(bidx + 1, eidx - 1)) + s.substring(eidx);\n      bidx = s.indexOf('(');\n    }\n    while ((m = /^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$/.exec(s)) != null) {\n      if (m[3] === '*') {\n        s = m[1] + (parseInt(m[2]) * parseInt(m[4])) + m[5];\n      } else {\n        s = m[1] + (parseInt(m[2]) / parseInt(m[4]) ^ 0) + m[5];\n      }\n    }\n    while ((m = /^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$/.exec(s)) != null) {\n      if (m[3] === '+') {\n        s = m[1] + (parseInt(m[2]) + parseInt(m[4])) + m[5];\n      } else {\n        s = m[1] + (parseInt(m[2]) - parseInt(m[4])) + m[5];\n      }\n    }\n    return s;\n  };\n\n  stdin.on('data', function(input) {\n    var e, x;\n    x = (function() {\n      var _i, _len, _ref, _results;\n      _ref = input.split(\"\\n\");\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        e = _ref[_i];\n        _results.push(e);\n      }\n      return _results;\n    })();\n    if (x.length > 2 || !isNaN(x[1])) {\n      return a = x;\n    } else {\n      return a.push(x[0]);\n    }\n  });\n\n  stdin.on('end', function(z) {\n    var i, n, s, _i, _results;\n    n = parseInt(a[0]);\n    _results = [];\n    for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {\n      s = a[i].substring(0, a[i].indexOf('=')).replace(/-/g, 'Z');\n      _results.push(console.log(proc(s)));\n    }\n    return _results;\n  });\n\n}).call(this);"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\n\nprocess.stdin.on('end', function() {\n    main(input.split('\\n'));\n});\n\nfunction main(input) {\n    input.slice(1,-1).forEach(function(expr) {\n        console.log(eval(expr.slice(0,-1)));\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    main(chunk.trim());\n});\n \nfunction main(chunk){\n    var lines = chunk.split(\"\\n\");\n    for(var i=1;i<lines.length;i++){\n        console.log(eval(lines[i].replace(\"=\",\"\")));\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    main(chunk.trim());\n});\n \nfunction main(chunk){\n    var lines = chunk.split(\"\\n\");\n    for(var i in lines){\n        console.log(eval(lines[i].replace(\"=\",\"\")));\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "(function (input) {\n    function expression() {\n        var num = term();\n\n        while(true) {\n            if ( code[cp] === \"+\" ) {\n                cp++;\n                num += term();\n            } else if ( code[cp] === \"-\" ) {\n                cp++;\n                num -= term();\n            } else {\n                break;\n            }\n        }\n        return num;\n    }\n    function term() {\n        var num = bracket();\n\n        while(true) {\n            if ( code[cp] === \"*\" ) {\n                cp++;\n                num *= bracket();\n            } else if ( code[cp] === \"/\" ) {\n                cp++;\n                num /= bracket();\n            } else {\n                break;\n            }\n        }\n\n        return Math.floor(num);\n    }\n\n    function bracket() {\n        var num;\n\n        if ( code[cp] == \"(\" ) {\n            cp++;   // (を読み飛ばす\n            num = expression();\n            cp++;   // )を読み飛ばす\n        } else {\n            return number();\n        }\n\n        return num;\n    }\n\n    function number() {\n        var num = 0;\n\n        while ( code[cp].match(/[0-9]/) ) {\n            num *= 10;\n            num += parseInt(code[cp]);\n            cp++;\n        }\n\n        return num;\n    }\n\n    var inputs = input.replace(/\\r/g, '').split(\"\\n\"),\n        cp,\n        n;\n\n    n = parseInt(inputs.shift());\n\n    while (n--) {\n        var code = inputs.shift().replace(/\\s/g, \"\");\n        cp = 0;\n\n        console.log(expression());\n    }\n})(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "#!/usr/bin/node\n// Generated by CoffeeScript 1.3.3\n// manually optimized\n(function() {\n  var a=[];\n  var stdin = process.openStdin();\n  stdin.setEncoding('utf8');\n\n  var proc = function(s){\n    var bidx=s.indexOf('('),count,eidx,m;\n    while(bidx!=-1){\n      eidx=bidx+1;\n      for(count=1;count;eidx++){\n        if(s[eidx]=='(')count++;\n        if(s[eidx]==')')count--;\n      }\n      s=s.substring(0,bidx)+proc(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n      bidx=s.indexOf('(');\n    }\n    while(m = /^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$/.exec(s)){\n      if(m[3]=='*')s=m[1]+(parseInt(m[2])*parseInt(m[4]))+m[5];\n      else s=m[1]+(parseInt(m[2])/parseInt(m[4])^0)+m[5];\n    }\n    while(m = /^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$/.exec(s)){\n      if(m[3]=='+')s=m[1]+(parseInt(m[2])+parseInt(m[4]))+m[5];\n      else s=m[1]+(parseInt(m[2])-parseInt(m[4]))+m[5];\n    }\n    return s;\n  };\n\n  stdin.on('data', function(input) {\n    var i=0,len,ref,x=[];\n    ref=input.split(\"\\n\");\n    for(len=ref.length;i<len;i++)x.push(ref[i]);\n    if(x.length>2||!isNaN(x[1]))a=x;\n    else a.push(x[0]);\n  });\n\n  stdin.on('end', function(z) {\n    var i,n,s;\n    n = parseInt(a[0]);\n    for(i=1;i<=n;i++){\n      s=a[i].substring(0,a[i].indexOf('=')).replace(/-/g,'Z');\n      console.log(proc(s));\n    }\n  });\n}).call(this);"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\n\nprocess.stdin.on('end', function() {\n    main(input.split('\\n'));\n});\n\nfunction main(input) {\n    var n = +input[0];\n    for(var i = 0; i < n; ++i) console.log(this['e'+'val'](input[i+1].slice(0,-1)));\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar L=Arr.shift()-0;\nfor(var i=0;i<L;i++){\n   var str=Arr[i];\n   str=str.slice(0,-1);\n   var num=eval(str);\n   console.log(Math.floor(num));\n}"
  },
  {
    "language": "JavaScript",
    "code": "#!/usr/bin/node\n// Generated by CoffeeScript 1.3.3\n// manually optimized. Base for CodeIQ341.\n(function() {\n  var a=[];\n  var stdin = process.openStdin();\n  stdin.setEncoding('utf8');\n\n  var proc = function(s){\n    var bidx=s.indexOf('('),count,eidx,m;\n    while(bidx!=-1){\n      eidx=bidx+1;\n      for(count=1;count;eidx++){\n        if(s[eidx]=='(')count++;\n        if(s[eidx]==')')count--;\n      }\n      s=s.substring(0,bidx)+proc(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n      bidx=s.indexOf('(');\n    }\n    while(m = /^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$/.exec(s)){\n      if (m[3] == '*') {\n        s = m[1] + (parseInt(m[2]) * parseInt(m[4])) + m[5];\n      } else {\n        s = m[1] + (parseInt(m[2]) / parseInt(m[4]) ^ 0) + m[5];\n      }\n    }\n    while(m = /^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$/.exec(s)){\n      if (m[3] == '+') {\n        s = m[1] + (parseInt(m[2]) + parseInt(m[4])) + m[5];\n      } else {\n        s = m[1] + (parseInt(m[2]) - parseInt(m[4])) + m[5];\n      }\n    }\n    return s;\n  };\n\n  stdin.on('data', function(input) {\n    var i=0,len,ref,x=[];\n    ref=input.split(\"\\n\");\n    for(len=ref.length;i<len;i++)x.push(ref[i]);\n    if(x.length>2||!isNaN(x[1]))a=x;\n    else a.push(x[0]);\n  });\n\n  stdin.on('end', function(z) {\n    var i,n,s;\n    n = parseInt(a[0]);\n    for(i=1;i<=n;i++){\n      s=a[i].substring(0,a[i].indexOf('=')).replace(/-/g,'Z');\n      console.log(proc(s));\n    }\n  });\n\n}).call(this);"
  },
  {
    "language": "JavaScript",
    "code": "var inputs = [];\n  \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    inputs.push(chunk);\n});\nprocess.stdin.on('end', function() {\n    main();\n});\n \nfunction main(){\n  var n = inputs[0];\n  for(var i=1;i<=n;i++){\n    console.log(eval(inputs[i]));\n  }  \n};\n"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\nvar util = require(\"util\"),\n    puts = console.log,\n    p = util.print,\n    cin = parseInput();\n\nfunction expression() {\n    var n = term();\n\n    while(true) {\n        if ( line[idx] == \"+\" ) {\n            idx++;\n            n += term();\n        } else if ( line[idx] == \"-\" ) {\n            idx++;\n            n -= term();\n        } else {\n            break;\n        }\n    }\n    return n;\n}\n\nfunction term() {\n    var n = factor();\n\n    while(true) {\n        if ( line[idx] == \"*\" ) {\n            idx++;\n            n *= factor();\n        } else if ( line[idx] == \"/\" ) {\n            idx++;\n            n = ~~(n / factor());\n        } else {\n            break;\n        }\n    }\n    return n;\n}\n\nfunction factor() {\n    if ( line[idx] == \"(\" ) {\n        idx++;  // (\n        var ret = expression();\n        idx++;  // )\n        return ret;\n    } else {\n        return number();\n    }\n}\n\nfunction number() {\n    var ret = 0, sign = 1;\n\n    if ( line[idx] == \"-\" ) {\n        idx++;\n        sign = -1;\n    }\n\n    while( /^\\d/.test(line[idx]) ) {\n        ret = ret * 10 + +line[idx];\n        idx++;\n    }\n    return ret * sign;\n}\n\nvar n = cin.nextInt(),\n    line, idx;\n\nwhile(n--) {\n    idx = 0;\n\n    line = cin.next();\n    line = line.slice(0, line.length - 1);\n\n    puts(expression());\n}\n\nfunction parseInput(useSplitSpace) {\n    var index = 0,\n        ret = [],\n        input = require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"),\n        inputs = input.replace(/\\r/g, '').split(\"\\n\");\n\n    useSplitSpace = useSplitSpace || true;\n\n    // 入力を改行/空白で区切り平坦な配列に変換\n    inputs.forEach(function(val) {\n        if ( useSplitSpace && val !== \"\" ) {\n            val.split(\" \").forEach(function(el) {\n                if ( el !== \"\" ) ret.push(el);\n            });\n        } else {\n            ret.push(val);\n        }\n    });\n\n    return {\n        hasNext: function(val) {\n            if ( typeof val === \"undefined\" ) {\n                return typeof ret[index] !== \"undefined\";\n            } else {\n                return ret[index] === val;\n            }\n        },\n        next: function() {\n            if ( typeof ret[index+1] === \"undefined\" ) throw new RangeError(\"Index out of bounds at '\" + index+1 + \"'\");\n            return ret[index++];\n        },\n        nextNumber: function () {\n            if ( !/^\\d+$/.test(this.top()) ) throw new TypeError(\"'\" + this.top() + \"' cannot convet to Number\");\n            return +this.next();\n        },\n        nextInt: function() {\n            return parseInt(this.nextNumber());\n        },\n        top: function() {\n            return ret[index];\n        },\n        rewind: function() {\n            index = 0;\n        }\n    };\n}"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    main(chunk.trim());\n});\n\nfunction main(chunk){\n    for(var i in chunk){\n        console.log(eval(chunk[i].replace(\"=\",\"\")));\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\n\nprocess.stdin.on('end', function() {\n    main(input.split('\\n'));\n});\n\nfunction main(input) {\n    var n = +input[0];\n\n    for(var i = 0; i < n; ++i) console.log(eval(input[i+1].slice(0,-1)));\n}"
  },
  {
    "language": "JavaScript",
    "code": "#!/usr/bin/node\n// Generated by CoffeeScript 1.3.3\n// manually optimized. Base for CodeIQ341.\n(function() {\n  var a=[];\n  var stdin = process.openStdin();\n  stdin.setEncoding('utf8');\n\n  var proc = function(s){\n    var bidx=s.indexOf('('),count,eidx,m;\n    while(bidx!=-1){\n      eidx=bidx+1;\n      for(count=1;count;eidx++){\n        if(s[eidx]=='(')count++;\n        if(s[eidx]==')')count--;\n      }\n      s=s.substring(0,bidx)+proc(s.substring(bidx+1,eidx-1))+s.substring(eidx);\n      bidx=s.indexOf('(');\n    }\n    while(m = /^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$/.exec(s)){\n      if (m[3] == '*') {\n        s = m[1] + (parseInt(m[2]) * parseInt(m[4])) + m[5];\n      } else {\n        s = m[1] + (parseInt(m[2]) / parseInt(m[4]) ^ 0) + m[5];\n      }\n    }\n    while(m = /^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$/.exec(s)){\n      if (m[3] == '+') {\n        s = m[1] + (parseInt(m[2]) + parseInt(m[4])) + m[5];\n      } else {\n        s = m[1] + (parseInt(m[2]) - parseInt(m[4])) + m[5];\n      }\n    }\n    return s;\n  };\n\n  stdin.on('data', function(input) {\n    var i=0,len,ref,x=[];\n    ref=input.split(\"\\n\");\n    for(len=ref.length;i<len;i++)x.push(ref[i]);\n    if(x.length>2||!isNaN(x[1]))a=x;\n    else a.push(x[0]);\n  });\n\n  stdin.on('end', function(z) {\n    var i,n,s;\n    n = parseInt(a[0]);\n    for(i=1;i<=n;i++){\n      s=a[i].substring(0,a[i].indexOf('=')).replace(/-/g,'Z');\n      console.log(proc(s)));\n    }\n  });\n\n}).call(this);"
  },
  {
    "language": "JavaScript",
    "code": "var inputs = [];\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    inputs.push(chunk);\n});\nprocess.stdin.on('end', function() {\n    main();\n});\n\nfunction main(){\n  var n = inputs[0];\n  for(var i=1;i<=n;i++){\n    console.log(eval(inputs[i]);\n  }  \n};\n"
  },
  {
    "language": "JavaScript",
    "code": "var\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    input = input.split('\\n');\n    main();\n});\n\nfunction main() {\n    var\n    i,\n    n = +input[0],\n    lines = input.slice(1);\n    for(i = 0; i < n; i++) {\n        console.log(calc(lines[i]));\n    }\n}\n\nfunction calc(src) {\n    src = src.replace(/([-+*\\/()=])/g, ' $1 ').split(' ').filter(function(s) {\n        return s.trim() !== '';\n    });\n    return add(src);\n\n    function add(src) {\n        var\n        ret = mul(src);\n        while(src[0] in {'+': 1,'-': 1}) {\n            switch(src.shift()) {\n            case '+':\n                ret += mul(src);\n                break;\n            case '-':\n                ret -= mul(src);\n                break;\n            }\n        }\n        return ret;\n    }\n\n    function mul(src) {\n        var\n        val, sign,\n        ret = prim(src);\n        while(src[0] in {'*': 1,'/': 1}) {\n            switch(src.shift()) {\n            case '*':\n                ret *= prim(src);\n                break;\n            case '/':\n                val = prim(src);\n                sign = ret * val < 0 ? -1 : 1;\n                ret = sign * Math.floor(Math.abs(ret) / Math.abs(val));\n                break;\n            }\n        }\n        return ret;\n    }\n\n    function prim(src) {\n        var\n        ret, \n        head = src.shift();\n        switch(head) {\n        case '+':\n           return prim(src);\n        case '-':\n           return -prim(src);\n        case '(':\n           ret = add(src);\n           src.shift();\n           return ret;\n        default:\n           return parseInt(head, 10);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    input = input.split('\\n');\n    main();\n});\n\nfunction main() {\n    var\n    i,\n    n = +input[0],\n    lines = input.slice(1);\n    for(i = 0; i < n; i++) {\n        console.log(calc(lines[i]));\n    }\n}\n\nfunction calc(src) {\n    src = src.replace(/([-+*\\/()=])/g, ' $1 ').split(' ').filter(function(s) {\n        return s.trim() !== '';\n    });\n    return add();\n\n    function add() {\n        var\n        ret = mul(src);\n        while(src[0] in {'+': 1,'-': 1}) {\n            switch(src.shift()) {\n            case '+':\n                ret += mul(src);\n                break;\n            case '-':\n                ret -= mul(src);\n                break;\n            }\n        }\n        return ret;\n    }\n\n    function mul() {\n        var\n        ret = prim(src);\n        while(src[0] in {'*': 1,'/': 1}) {\n            switch(src.shift()) {\n            case '*':\n                ret *= prim(src);\n                break;\n            case '/':\n                ret = Math.floor(ret / prim(src));\n                break;\n            }\n        }\n        return ret;\n    }\n\n    function prim() {\n        var\n        ret, \n        head = src.shift();\n        switch(head) {\n        case '+':\n           return prim(src);\n        case '-':\n           return -prim(src);\n        case '(':\n           ret = add(src);\n           src.shift();\n           return ret;\n        default:\n           return parseInt(head, 10);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var i = require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\").replace(/\\r/g, '').split(\"\\n\"),n = +i.shift();while (n--) console.log(eval(i.shift().replace(/\\s|=/g, \"\")));"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\n\nprocess.stdin.on('end', function() {\n    main(input.split('\\n'));\n});\n\nfunction main(input) {\n    input.slice(1).forEach(function(expr) {\n        console.log(eval(expr.slice(0,-1)));\n    });\n    \n    return ;\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar L=Arr.shift()-0;\nfor(var i=0;i<L;i++){\n   var str=Arr[i];\n   str=str.slice(0,-1);\n   var num=eval(str);\n   console.log(parseInt(num,10));\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Fixnum\n\tdef /(o)\n\t\tself.fdiv(o).truncate\n\tend\nend\nputs gets.to_i.times.map{l=gets.chomp;eval l[0,l.index('=')]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval gets.gsub(\"=\",\"\")}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval gets.delete'='}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\ndef/n\nfdiv(n).to_i\nend\nend\ngets.to_i.times{p eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i;n.times{puts eval gets.strip[0..-2]}"
  },
  {
    "language": "Ruby",
    "code": "class Integer\n  def /(n)\n    x = Rational(self, n)\n    (x <=> 0) * (x.abs.floor)\n  end\nend\n\ngets.to_i.times{\n  s = gets\n  puts eval(s[0...s.index(?=)])\n}\n"
  },
  {
    "language": "Ruby",
    "code": "\n\nclass Numeric\n  def / (x)\n    y = self.fdiv(x)\n    if y < 0.0\n      y.ceil\n    else\n      y.floor\n    end\n    y\n  end\nend\n\n\nwhile n = gets do\n  n.to_i.times do\n    puts eval(gets.chomp.chop)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { p eval(gets.tr(\"=\",\"\")) }"
  },
  {
    "language": "Ruby",
    "code": "def parse tokens\n  case t = tokens.shift\n  when /\\d+/\n    parse_with_left_expr t, tokens\n  when '('\n    depth = 1\n    pos = tokens.index {|t|\n      if t == '('\n        depth += 1\n        false\n      elsif t == ')'\n        (depth -= 1).zero?\n      else\n        false\n      end\n    }\n    parse_with_left_expr(parse(tokens[0..pos - 1]), tokens[pos + 1..-1])\n  else\n    raise t.to_s\n  end\nend\n\ndef parse_with_left_expr left, tokens\n    return [left] if tokens.empty?\n    case op = tokens.shift\n    when '+', '-'\n      [left, parse(tokens), op]\n    when '*', '/'\n      case right = tokens.first\n      when /\\d+/\n        tokens.shift\n        parse_with_left_expr [left, right, op], tokens\n      when '('\n        [left, parse(tokens), op]\n      else\n        raise right.to_s\n      end\n    else\n      raise op.to_s\n    end\nend\n\ngets.to_i\n  .times\n  .lazy\n  .map{ gets.chomp }\n  .map {|s| s.scan(/([+\\-*\\/()]|\\d+)/).flatten }\n  .map(&method(:parse))\n  .map(&:flatten)\n  .map {|tokens|\n    tokens.reduce([]) {|s, t|\n      case t\n      when /\\d+/\n        s << t.to_i\n      else\n        r = s.pop\n        l = s.pop\n        s << l.send(t, r)\n        s\n      end\n    }.first\n  }\n  .each(&method(:puts))"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum;def/(o);r=self.fdiv(o);return r<0?r.ceil: r.floor;end;end;gets.to_i.times{puts eval gets.chop.chop}"
  },
  {
    "language": "Ruby",
    "code": "$<.each_line.to_a[1..-1].map{|s|puts eval(s.chomp[0..-2])}"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  intflg=false\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n      intflg=false\n    else\n      if intflg then st.push((st.pop.to_s+item).to_i)\n      else st.push(item.to_i) end\n      intflg=true\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push((1.0/calc.pop*calc.pop).floor)\n    else calc.push(n) end\n  end\n  puts calc\nend"
  },
  {
    "language": "Ruby",
    "code": "$<.each_line.to_a[1..-1].map{|s|p eval(s.chomp[0..-2])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { p eval gets[0..-3] }"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /(arg)\n    self.fdiv(arg).truncate\n  end\nend\n\nuntil (num = gets.to_i) == 0\n  num.times {puts eval gets.chomp.chop}\nend"
  },
  {
    "language": "Ruby",
    "code": "$stderr.puts $<.read"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chop.to_i\n\nn.times do\n  puts eval(gets.chop.gsub(/=$/, ''))\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def / (d)\n    r = 1.0 * self.fdiv(d)\n    if r < 0\n      return r.ceil\n    else\n      return r.floor\n    end\n  end\nend\n\ngets.to_i.times{puts eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|l|p eval(l[0..-3])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chop.chop)}"
  },
  {
    "language": "Ruby",
    "code": "puts gets.strip.to_i.times.map {\n  eval(gets.strip.gsub(/\\.\\d+/, \"\").sub(/=$/, \"\"))\n}.join(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef / (n)\n\t\td = 1.0*self.fdiv(n)\n\t\treturn n.ceil if d < 0\n\t\treturn n.floor if d >= 0\n\t\tend\n\tend\nend\n\ngets.to_i.times{ puts eval(gets.chomp.delete(\"=\")) }"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\ndef/o\nr=self.fdiv(o)\nr<0?r.ceil: r.floor\nend\nend\ngets\n$<.map{|x|p eval x[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{\n  s = gets\n  puts eval(s[0...s.index(?=)])\n}\n"
  },
  {
    "language": "Ruby",
    "code": "TERM_N  = 0\nTERM_OP_PM = 1\nTERM_OP_MD = 2\nTERM_LB = 3\nTERM_RB = 4\nTERM_END = 5\n\ndef lex_anlz(str)\n  expr = []\n\n  for t in str.scan(/\\d+|[\\+\\-\\*\\/\\(\\)=]/)\n    case t\n      when '+', '-'\n      expr.push [TERM_OP_PM, t]\n      when '*', '/'\n      expr.push [TERM_OP_MD, t]\n      when '('\n      expr.push [TERM_LB, t]\n      when ')'\n      expr.push [TERM_RB, t]\n      when '='\n      expr.push [TERM_END, t]\n      else\n      expr.push [TERM_N, t.to_i]\n    end\n  end\n\n  return expr\nend\n\ndef to_rpn(expr)\n  rpn = []\n  stack = []\n\n  for t in expr\n    case t[0]\n      when TERM_N\n      rpn.push t\n\n      when TERM_OP_PM\n      while ! stack.empty? &&\n          ((st = stack[-1])[0] == TERM_OP_PM || st[0] == TERM_OP_MD)\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_MD\n      while ! stack.empty? && stack[-1][0] == TERM_OP_MD\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_LB\n      stack.push t\n\n      when TERM_RB\n      while stack[-1][0] != TERM_LB\n        rpn.push stack.pop\n      end\n      stack.pop\n\n      when TERM_END\n      while ! stack.empty?\n        rpn.push stack.pop\n      end\n    end\n  end\n\n  return rpn\nend\n\ndef calc_rpn(rpn)\n  stack = []\n\n  for t in rpn\n    if t[0] == TERM_N\n      stack.push t[1]\n    else\n      n2 = stack.pop\n      n1 = stack.pop\n      case t[1]\n        when \"+\"\n        stack.push(n1 + n2)\n        when \"-\"\n        stack.push(n1 - n2)\n        when \"*\"\n        stack.push(n1 * n2)\n        when \"/\"\n        stack.push(n1 / n2)\n      end\n    end\n  end\n\n  return stack[-1]\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  str = gets.chomp\n  #p str\n  expr = lex_anlz(str)\n  #p expr\n  rpn = to_rpn(expr)\n  #p rpn\n  num = calc_rpn(rpn)\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "puts$<.map{|l|eval l.chop.chop}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /(x)\n    y = self.to_f.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n \n \nwhile n = gets.to_i\n\tn.times{\n    \tputs eval(gets.chomp.chop)\n\t}\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp[0...-1])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times {puts eval(gets[0..-2]).floor}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  puts eval(gets.chomp.chop.gsub(%r{/\\s*(-?\\d+?)}, '.fdiv(\\1).to_i'))\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{ puts eval(gets.chomp[0..-2].gsub(%r([-+*/=]), '.0\\&')).to_i }"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.each_line.map{|s|p eval(s.chomp[0..-2])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n\ts = gets.chomp.delete(\"=\")\n\tputs eval(s)\nend"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|s|p eval s.sub(/=/,'')}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { p eval gets.chomp.chop }"
  },
  {
    "language": "Ruby",
    "code": "\nclass Numeric\n  def / (x)\n    y = self.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n\n\nwhile n = gets do\n  n.to_i.times do\n    puts eval(gets.chomp.chop)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "TERM_N  = 0\nTERM_OP_PM = 1\nTERM_OP_MD = 2\nTERM_LB = 3\nTERM_RB = 4\nTERM_END = 5\n\ndef lex_analyze(str)\n  expr = []\n\n  come_sign = true\n  sign = 1\n\n  for t in str.scan(/\\d+|[\\+\\-\\*\\/\\(\\)=]/)\n    case t\n      when '+', '-'\n      if come_sign\n        sign = -sign if t == \"-\"\n      else\n        expr.push [TERM_OP_PM, t]\n        come_sign = true\n      end\n\n      when '*', '/'\n      expr.push [TERM_OP_MD, t]\n      come_sign = true\n\n      when '('\n      expr.push [TERM_LB, t]\n      come_sign = true\n\n      when ')'\n      expr.push [TERM_RB, t]\n      come_sign = true\n\n      when '='\n      expr.push [TERM_END, t]\n      come_sign = true\n\n      else\n      expr.push [TERM_N, t.to_i * sign]\n      come_sign = false\n      sign = 1\n    end\n  end\n\n  return expr\nend\n\ndef to_rpn(expr)\n  rpn = []\n  stack = []\n\n  for t in expr\n    case t[0]\n      when TERM_N\n      rpn.push t\n\n      when TERM_OP_PM\n      while ! stack.empty? &&\n          ((st = stack[-1])[0] == TERM_OP_PM || st[0] == TERM_OP_MD)\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_MD\n      while ! stack.empty? && stack[-1][0] == TERM_OP_MD\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_LB\n      stack.push t\n\n      when TERM_RB\n      while stack[-1][0] != TERM_LB\n        rpn.push stack.pop\n      end\n      stack.pop\n\n      when TERM_END\n      while ! stack.empty?\n        rpn.push stack.pop\n      end\n    end\n  end\n\n  return rpn\nend\n\ndef calc_rpn(rpn)\n  stack = []\n\n  for t in rpn\n    if t[0] == TERM_N\n      stack.push t[1]\n    else\n      n2 = stack.pop\n      n1 = stack.pop\n      case t[1]\n        when \"+\"\n        stack.push(n1 + n2)\n        when \"-\"\n        stack.push(n1 - n2)\n        when \"*\"\n        stack.push(n1 * n2)\n        when \"/\"\n        stack.push(n1 / n2)\n      end\n    end\n  end\n\n  return stack[-1]\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  str = gets.chomp\n  #p str\n  expr = lex_analyze(str)\n  #p expr\n  rpn = to_rpn(expr)\n  #p rpn\n  num = calc_rpn(rpn)\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{\np eval(p gets[0..-3].gsub(/\\/(\\(\\g<1>([-+*\\/]\\g<1>)*\\)|\\d+)/,'.fdiv(\\1).to_i'))\n}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  alias_method :div, :/\n  def /(a)\n    self.floor.div(a.floor)\n  end\nend\nputs gets.strip.to_i.times.map{eval(gets.strip.sub(/=$/, \"\"))}.join(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n    puts eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|s|p eval s}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\nalias / fdiv\nend\ngets.to_i.times{p eval(gets[0..-3]).to_i}"
  },
  {
    "language": "Ruby",
    "code": "class Hoge\n  def / (x)\n    y = self.to_f.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n \n \nwhile n = gets.to_i\n\tn.times{\n    \tputs eval(gets.chomp.chop)\n\t}\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp.chop.gsub(/(\\d+)/,'\\1.0')).to_i}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chop.to_i\nn.times do\n  puts eval(gets.chop.gsub(/=$/, ''))\nend"
  },
  {
    "language": "Ruby",
    "code": "\n# hiyakashiの指摘で修正\n# 自分ではresと打ったつもりがselfと打ってた\n# 前のソースでは割る数が負の時に動かない\n# なぜAcceptしたんだろ\n\nclass Fixnum\n\n\tdef /(o)\n\t\tres = self.fdiv(o)\n\t\tif (res < 0)\n\t\t\treturn res.ceil\n\t\telse\n\t\t\treturn res.floor\n\t\tend\n\tend\n\nend\n\ngets.to_i.times do\n\tputs eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef /(o)\n\t\tres = self.fdiv(o)\n\t\tif (res < 0)\n\t\t\treturn res.ceil\n\t\telse\n\t\t\treturn res.floor\n\t\tend\n\tend\nend\n\ngets.to_i.times do\n\tputs eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "p eval gets.chop"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def / (x)\n    y = self.to_f.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n \n \nwhile n = gets.to_i\n\tn.times{\n    \tputs eval(gets.chomp.chop)\n\t}\nend"
  },
  {
    "language": "Ruby",
    "code": "STDOUT.sync=true\nn= gets.chomp.to_i\n0.upto(n-1){|i|\n  s = gets.chomp\n  f=s.gsub(/(\\+)/,\" + \").gsub(/-/,\" - \").gsub(/\\*/,\" * \").gsub(/\\//,\" / \").gsub(/\\(/,\" ( \").gsub(/\\)/,\" ) \").gsub(/=/,\"\").split\n\n  g=f.map {|x|\n    if x=~ /[\\d\\.]+/ then\n      x.to_i\n    else\n     x\n    end\n  }\n#puts f.join;exit\n  puts eval(g.join)\n}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  # 3/-2 ??? -2 ??§????????? -1?????????????????????????????? fdiv.to_i ?????????\n  puts eval(gets.chomp.chop.gsub(%r{/(-\\d+?)}, '.fdiv(\\1).to_i'))\nend"
  },
  {
    "language": "Ruby",
    "code": "(gets.to_i).times do \n puts eval(gets.chomp.chop)\n end\n \n"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times {puts eval(gets[0..-3]).floor}"
  },
  {
    "language": "Ruby",
    "code": "\ndef main\n  t = gets.chomp.to_i\n  (1..t).each do |ca|\n    str = gets.chomp[0..-2]\n    puts eval(str)\n  end\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Fixnum\n\t#I want -3/2 to be -1, not -2\n\tdef /(o) self.fdiv(o).truncate end\nend\nputs$<.drop(1).map{|l|eval l.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nputs gets.to_i.times.map{l=gets.chomp;eval l[0,l,index('=')]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{ puts eval(gets.chomp[0..-2]).floor }"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /(o)\n    self.fdiv(o).to_i\n  end\nend\n\nn = gets.chop.to_i\n\nn.times do\n  puts eval(gets.chop.gsub(/=$/, ''))\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { puts eval(gets.chomp[0..-2]).floor }"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef / (n)\n\t\td = 1.0*self.fdiv(n)\n\t\treturn r.ceil if d < 0\n\t\treturn r.floor if d >= 0\n\t\tend\n\tend\nend\n\ngets.to_i.times{ puts eval(gets.chomp.delete(\"=\")) }"
  },
  {
    "language": "Ruby",
    "code": "p eval(gets.chop.chop)"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n    else\n      st.push(item.to_i)\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then\n      f,r=calc.pop,calc.pop\n      calc.push(r/f)\n    else calc.push(n) end\n    p calc\n  end\n  p calc[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nputs$<.drop(1).map{|l|eval l[0,l.index('=')||l.size]}#gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\n\nn.times.each do\n  expr = gets.chomp.delete(\"=\")\n  puts eval(expr)\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Numeric\n  def / (x)\n    y = self.quo(x)\n    if y < 0.0\n      y.ceil\n    else\n      y.floor\n    end\n    y\n  end\nend\n\n\ngets.to_i.times do\n  puts eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def / o\n    fdiv(o).to_i\n  end\nend\nps = {'+' => 1, '-' => 1, '*' => 2, '/' => 2}\ngets.to_i\n  .times\n  .lazy\n  .map{ gets.chomp }\n  .map {|s| s.scan(/([+\\-*\\/()]|\\d+)/).flatten }\n  .map {|tokens|\n    ops = []\n    tokens.each_with_object([]) {|t, rpn|\n      case t\n      when /\\d+/\n        rpn << t\n      when '('\n        ops << t\n      when ')'\n        op = nil\n        rpn << op until (op = ops.pop) == '('\n      else\n        p = ps[t]\n        rpn << ops.pop until p > (ps[ops.last] || 0)\n        ops << t\n      end\n    }.push(*ops.reverse)\n  }\n  .map {|rpn|\n    rpn.reduce([]) {|s, t|\n      case t\n      when /\\d+/\n        s << t.to_i\n      else\n        r = s.pop\n        l = s.pop\n        s << l.send(t, r)\n        s\n      end\n    }.first\n  }\n  .each(&method(:puts))"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do \n  line = gets.chomp.chop\n  puts eval line\nend"
  },
  {
    "language": "Ruby",
    "code": "while s = gets do\n  p eval s\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nputs$<.drop(1).map{|l|eval l[0...l.index('=')]}#gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "class Hoge\n  def / (x)\n    y = self.to_f.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n \n \nwhile n = gets.to_i\n\tn.times{\n    \tputs eval(gets.chomp.chop)\n\t}\nend"
  },
  {
    "language": "Ruby",
    "code": "$<.map{|i|puts eval i[0..-3]if i[-2]==\"=\"}"
  },
  {
    "language": "Ruby",
    "code": "STDOUT.sync=true\nn= gets.chomp.to_i\n0.upto(n-1){|i|\n  s = gets.chomp.gsub(/=$/, \"\")\n  puts eval(s)\n}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.lines.map{|s|p eval(s[0..-2])}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Fixnum\n  def / (d)\n    r = 1.0 * self.fdiv(d)\n    if r < 0\n      r.ceil\n    else\n      r.floor\n    end\n  end\nend\n\ngets.to_i.times { puts eval gets.chomp[0..-2]}"
  },
  {
    "language": "Ruby",
    "code": "def main\n  t = gets.chomp.to_i\n  (1..t).each do |ca|\n    str = gets.chomp.split(/=/)[0]\n    puts eval(str)\n  end\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  alias old_div /\n  def/(b)\n    if (self>0 and b<0) or (self<0 and b>0)  then\n      return self.fdiv(b).to_i\n    else\n      return self.old_div(b)\n    end\n  end\nend\n\nn= gets.chomp.to_i\n0.upto(n-1){|i|\n  s = gets.chomp.gsub(/=/,\"\")\n  puts eval(s)\n}"
  },
  {
    "language": "Ruby",
    "code": "class Hoge\n  def / (x)\n    y = self.to_f.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n \n \nwhile n = gets.to_i\n\tn.times{\n    \tputs eval(gets.chomp.chop)\n\t}\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{\n\tputs eval( gets.gsub(\"=\",'') )\n}"
  },
  {
    "language": "Ruby",
    "code": "$<.gets.to_i.times do\n  splited = $<.gets.chomp.scan(/([0-9\\.]+|\\+|\\-|\\*|\\/|\\(|\\)|=)/)\n  output = []\n  stack = []\n  a = nil\n  until (token = splited.shift) == [\"=\"]\n    token = token.first\n    case token\n    when \"(\" then stack << token\n    when \")\" then\n      output << a until (a = stack.pop) == \"(\"\n    when \"*\", \"/\"\n      loop do\n        a = stack.last\n        break unless %w(* /).include?(a)\n        output << stack.pop\n      end\n      stack << token\n    when \"+\", \"-\"\n      loop do\n        a = stack.last\n        break unless %w(+ - * /).include?(a)\n        output << stack.pop\n      end\n      stack << token\n    else\n      output << token.to_r\n    end\n  end\n  output << a while (a = stack.pop)\n  \n  stack = []\n  while (x = output.shift)\n    if %w(+ - * /).include?(x)\n      a, b = stack.pop, stack.pop\n      if x == \"/\" and ((a < 0) ^ (b < 0))\n        stack << -(b.abs / a.abs)\n      else\n        stack << eval(\"#{b.to_i} #{x} #{a.to_i}\").to_i\n      end\n    else\n      stack << x\n    end\n  end\n  puts stack.first.to_i\nend\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\n\nn.times.each do\n  expr = gets.chomp.delete(\"=\")\n\n  ans = eval expr\n  puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "puts gets.strip.to_i.times.map{eval(gets.strip.sub(/=$/, \"\"))}.join(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i;n.times{puts eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{p eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.gsub(\"=\",\"\")).to_i}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|s|p eval s.chop}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{p eval(gets.chop.chop)}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.lines.map{|s|p eval(s[0..-3])}"
  },
  {
    "language": "Ruby",
    "code": "n = STDIN.gets.to_i\nfor i in 0...(n)\n    line = STDIN.gets\n    puts eval(line[0, line.length-2]+\"\\n\")\nend"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n\nN.times do\n  puts eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{ puts eval(gets.chomp[0..-2].gsub(%r{([0-9]+)([-+*/=])}, '\\1.0\\2')).to_i }"
  },
  {
    "language": "Ruby",
    "code": "ps = {'+' => 1, '-' => 1, '*' => 2, '/' => 2}\ngets.to_i\n  .times\n  .lazy\n  .map{ gets.chomp }\n  .map {|s| s.scan(/([+\\-*\\/()]|\\d+)/).flatten }\n  .map {|tokens|\n    ops = []\n    tokens.each_with_object([]) {|t, rpn|\n      case t\n      when /\\d+/\n        rpn << t\n      when '('\n        ops << t\n      when ')'\n        op = nil\n        rpn << op until (op = ops.pop) == '('\n      else\n        p = ps[t]\n        rpn << ops.pop until p > (ps[ops.last] || 0)\n        ops << t\n      end\n    }.push(*ops.reverse)\n  }\n  .map {|rpn|\n    rpn.reduce([]) {|s, t|\n      case t\n      when /\\d+/\n        s << t.to_i\n      else\n        r = s.pop\n        l = s.pop\n        s << l.send(t, r)\n        s\n      end\n    }.first\n  }\n  .each(&method(:puts))"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp[0...-1])}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nputs$<.drop(1).map{|l|eval l.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "puts Array.new(gets.to_i){eval(gets.chomp[0...-1])}"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n    else\n      st.push(item.to_i)\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push(1.0/calc.pop*calc.pop)\n    else calc.push(n) end\n  end\n  p calc[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "\ngets.chomp.to_i.times{\n\ta = gets.chomp\n\tbreak if(a==\"\")\n\tbreak unless(a)\n\t\n\tputs eval(a.split(\"=\")[0])\n}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{p eval gets.delete'='}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|s|p eval s.chop.chop}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  p eval gets.tr(\"=\",\"\")\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /(n)\n    self.fdiv(n) < 0 ? r.ceil : r.floor\n  end\nend\ngets.to_i.times { p eval(gets[0..-3]) }"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  intflg=false\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n      intflg=false\n    else\n      if intflg then st.push((st.pop.to_s+item).to_i)\n      else st.push(item.to_i) end\n      intflg=true\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push((1.0/calc.pop*calc.pop).floor)\n    else calc.push(n) end\n  end\n  p calc[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "puts gets.strip.to_i.times.map do\n  eval(gets.strip.gsub(/\\.\\d+/, \"\").sub(/=$/, \"\"))\n}.join(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.lines.map{|s|p eval(s[0..-4])}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 0109-1.rb: Smart Calculator\n#\n\n$str = ''\n$pos = 0\n\ndef exp()\n  #puts \"exp():#{$pos}\"\n\n  ret = term();\n  while true\n    ch = $str[$pos]\n    $pos += 1\n\n    if ch == '+'\n      ret += term()\n    elsif ch == '-'\n      ret -= term()\n    else\n      break;\n    end\n  end\n\n  return ret\nend\n\ndef term()\n  #puts \"term():#{$pos}\"\n\n  ret = elm()\n  while true\n    ch = $str[$pos]\n    $pos += 1\n\n    case ch\n    when '*'\n      ret *= elm()\n    when '/'\n      ret /= elm()\n    else\n      break\n    end\n  end\n  $pos -= 1\n\n  return ret\nend\n\ndef elm()\n  #puts \"elm():#{$pos}\"\n\n  ch = $str[$pos]\n  $pos += 1\n\n  return exp() if ch == '('\n  return -elm() if ch == '-'\n  return elm() if ch == '+'\n\n  x = ch.ord - '0'.ord\n  while true\n    ch = $str[$pos]\n    $pos += 1\n\n    if /\\d/ =~ ch\n      x = 10 * x + (ch.ord - '0'.ord)\n    else\n      break\n    end\n  end\n  $pos -= 1\n\n  return x\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  $str = gets.chomp\n  $pos = 0\n  #p str\n  num = exp()\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "until (num = gets.to_i) == 0\n  num.times do\n    puts eval gets.chomp.chop\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{p eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n    def /n\n        fdiv(n).to_i\n    end\nend\ngets.to_i.times do\n    p eval gets.chomp.chop\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{\n  \nline = gets.chomp.chop\n line[0]=\"\" if  line[0] == \"+\"\n  puts eval(line)}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.each_line.map{|s|p eval(s[0..-2])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { p eval(gets[0..-3]) }"
  },
  {
    "language": "Ruby",
    "code": "def parse tokens\n  case t = tokens.shift\n  when /\\d+/\n    parse_with_left_expr t, tokens\n  when '('\n    pos = tokens.index(')')\n    parse_with_left_expr(parse(tokens[0..pos - 1]), tokens[pos + 1..-1])\n  else\n    raise t.to_s\n  end\nend\n\ndef parse_with_left_expr left, tokens\n    return [left] if tokens.empty?\n    case op = tokens.shift\n    when '+', '-'\n      [left, parse(tokens), op]\n    when '*', '/'\n      case right = tokens.first\n      when /\\d+/\n        tokens.shift\n        parse_with_left_expr [left, right, op], tokens\n      when '('\n        [left, parse(tokens), op]\n      else\n        raise right.to_s\n      end\n    else\n      raise op.to_s\n    end\nend\n\ngets.to_i\n  .times\n  .lazy\n  .map{ gets.chomp }\n  .map {|s| s.scan(/([+\\-*\\/()]|\\d+)/).flatten }\n  .map(&method(:parse))\n  .map(&:flatten)\n  .map {|tokens|\n    tokens.reduce([]) {|s, t|\n      case t\n      when /\\d+/\n        s << t.to_i\n      else\n        r = s.pop\n        l = s.pop\n        s << l.send(t, r)\n        s\n      end\n    }.first\n  }\n  .each(&method(:puts))"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n    else\n      st.push(item.to_i)\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push((1.0/calc.pop*calc.pop).floor)\n    else calc.push(n) end\n  end\n  p calc[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do \n  line = gets.chomp.chop\n  puts eval line\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n    alias :div :/\n    def /(x)\n        if self < 0\n            return -abs.div(x)\n        else\n            div(x)\n        end\n    end\nend\n\nn = gets.to_i\nn.times do\n    p eval(gets[0..-3])\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef /(o)\n\t\tr = self.fdiv(o)\n\t\treturn r < 0 ? r.ceil : r.floor\n\tend\nend\ngets.to_i.times{puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nn.times do\n    p eval(gets[0..-3])\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def / (d)\n    (1.0*self/d).ceil\n  end\nend\n\ngets.to_i.times{puts eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef / (n)\n\t\td = 1.0*self.fdiv(n)\n\t\tif d < 0\n\t\t\treturn d.ceil\n\t\telse\n\t\t\treturn d.floor\n\t\tend\n\tend\nend\n\ngets.to_i.times{ puts eval(gets.chomp.chop) }"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  puts eval(gets.chomp.chop.gsub(%r{/(\\d+)?}, '.fdiv(\\1).to_i'))\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{ puts eval(gets.chomp[0..-2]) }"
  },
  {
    "language": "Ruby",
    "code": "TERM_N  = 0\nTERM_OP_PM = 1\nTERM_OP_MD = 2\nTERM_OP_SIGN = 3\nTERM_LB = 4\nTERM_RB = 5\nTERM_END = 6\n\ndef lex_analyze(str)\n  expr = []\n\n  come_sign = true\n\n  for t in str.scan(/\\d+|[\\+\\-\\*\\/\\(\\)=]/)\n    case t\n      when '+', '-'\n      if come_sign\n        expr.push [TERM_OP_SIGN, t]\n      else\n        expr.push [TERM_OP_PM, t]\n        come_sign = true\n      end\n\n      when '*', '/'\n      expr.push [TERM_OP_MD, t]\n      come_sign = true\n\n      when '('\n      expr.push [TERM_LB, t]\n      come_sign = true\n\n      when ')'\n      expr.push [TERM_RB, t]\n      come_sign = false\n\n      when '='\n      expr.push [TERM_END, t]\n      come_sign = true\n\n      else\n      expr.push [TERM_N, t.to_i]\n      come_sign = false\n    end\n  end\n\n  return expr\nend\n\ndef to_rpn(expr)\n  rpn = []\n  stack = []\n\n  for t in expr\n    case t[0]\n      when TERM_N\n      rpn.push t\n      while ! stack.empty? && stack[-1][0] == TERM_OP_SIGN\n        rpn.push stack.pop\n      end\n\n      when TERM_OP_PM\n      while ! stack.empty? &&\n          ((st = stack[-1])[0] == TERM_OP_PM || st[0] == TERM_OP_MD)\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_MD\n      while ! stack.empty? && stack[-1][0] == TERM_OP_MD\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_SIGN\n      stack.push t\n\n      when TERM_LB\n      stack.push t\n\n      when TERM_RB\n      while stack[-1][0] != TERM_LB\n        rpn.push stack.pop\n      end\n      stack.pop\n      while ! stack.empty? && stack[-1][0] == TERM_OP_SIGN\n        rpn.push stack.pop\n      end\n\n      when TERM_END\n      while ! stack.empty?\n        rpn.push stack.pop\n      end\n    end\n  end\n\n  return rpn\nend\n\ndef calc_rpn(rpn)\n  stack = []\n\n  for t in rpn\n    if t[0] == TERM_N\n      stack.push t[1]\n    elsif t[0] == TERM_OP_SIGN\n      if t[1] == '-'\n        n1 = stack.pop\n        stack.push -n1\n      end\n    else\n      n2 = stack.pop\n      n1 = stack.pop\n      case t[1]\n        when \"+\"\n        stack.push(n1 + n2)\n        when \"-\"\n        stack.push(n1 - n2)\n        when \"*\"\n        stack.push(n1 * n2)\n        when \"/\"\n        stack.push(n1 / n2)\n      end\n    end\n  end\n\n  return stack[-1]\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  str = gets.chomp\n  #p str\n  expr = lex_analyze(str)\n  #p expr\n  rpn = to_rpn(expr)\n  #p rpn\n  num = calc_rpn(rpn)\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\ndef/o\nself.fdiv(o).to_i\nend\nend\ngets\n$<.map{|x|p eval x[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  alias old_div /\n  def /(b)\n    if((self<0) ^ (b<0))\n      return -(self.abs.old_div(b.abs))\n    else\n      return self.old_div(b)\n    end\n  end\nend\n\ngets.to_i.times{puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\t#-3/2 -> -1, not -2\n\tdef /(o) self.fdiv(o).truncate end\nend\nputs gets.to_i.times.map{eval gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { puts eval(\"1.0*\" + gets.chomp[0..-2]).to_i }"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  alias_method :div, :/\n  def /(a)\n    self.to_i.div(a.to_i)\n  end\nend\nputs gets.strip.to_i.times.map{eval(gets.strip.sub(/=$/, \"\"))}.join(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\ndef/o\nself.fdiv(o).to_i\nend\nend\ngets.to_i.times{p eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef / (n)\n\t\td = 1.0*self.fdiv(n)\n\t\treturn d.ceil if d < 0\n\t\treturn d.floor if d >= 0\n\t\tend\n\tend\nend\n\ngets.to_i.times{ puts eval(gets.chomp.delete(\"=\")) }"
  },
  {
    "language": "Ruby",
    "code": "gets; while s = gets; puts eval s[0..-3]; end"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /(num)\n    fdiv(num).to_i\n  end\nend\n\ngets.to_i.times do\n  puts eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "TERM_N  = 0\nTERM_OP_PM = 1\nTERM_OP_MD = 2\nTERM_LB = 3\nTERM_RB = 4\nTERM_END = 5\n\ndef lex_anlz(str)\n  expr = []\n\n  for t in str.scan(/\\d+|[\\+\\-\\*\\/\\(\\)=]/)\n    case t\n      when '+', '-'\n      expr.push [TERM_OP_PM, t]\n      when '*', '/'\n      expr.push [TERM_OP_MD, t]\n      when '('\n      expr.push [TERM_LB, t]\n      when ')'\n      expr.push [TERM_RB, t]\n      when '='\n      expr.push [TERM_END, t]\n      else\n      expr.push [TERM_N, t.to_i]\n    end\n  end\n\n  return expr\nend\n\ndef to_rpn(expr)\n  rpn = []\n  stack = []\n\n  for t in expr\n    case t[0]\n      when TERM_N\n      rpn.push t\n\n      when TERM_OP_PM, TERM_OP_MD\n      while ! stack.empty? && stack[-1][0] == t[0]\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_LB\n      stack.push t\n\n      when TERM_RB\n      while stack[-1][0] != TERM_LB\n        rpn.push stack.pop\n      end\n      stack.pop\n\n      when TERM_END\n      while ! stack.empty?\n        rpn.push stack.pop\n      end\n    end\n  end\n\n  return rpn\nend\n\ndef calc_rpn(rpn)\n  stack = []\n\n  for t in rpn\n    if t[0] == TERM_N\n      stack.push t[1]\n    else\n      n2 = stack.pop\n      n1 = stack.pop\n      case t[1]\n        when \"+\"\n        stack.push n1 + n2\n        when \"-\"\n        stack.push n1 - n2\n        when \"*\"\n        stack.push n1 * n2\n        when \"/\"\n        stack.push n1 / n2\n      end\n    end\n  end\n\n  return stack[-1]\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  str = gets.chomp\n  #p str\n  expr = lex_anlz(str)\n  #p expr\n  rpn = to_rpn(expr)\n  #p rpn\n  num = calc_rpn(rpn)\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  puts eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nn.times{|s|p eval gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "$str = ''\n$pos = 0\n\ndef exp()\n  #puts \"exp():#{$pos}\"\n\n  ret = term();\n  while true\n    ch = $str[$pos]\n    $pos += 1\n    if ch == '+'\n      ret += term()\n    elsif ch == '-'\n      ret -= term()\n    else\n      break;\n    end\n  end\n\n  return ret\nend\n\ndef term()\n  #puts \"term():#{$pos}\"\n\n  ret = elm()\n  while true\n    case $str[$pos]\n    when '*'\n      $pos += 1\n      ret *= elm()\n    when '/'\n      $pos += 1\n      ret /= elm()\n    else\n      break\n    end\n  end\n\n  return ret\nend\n\ndef elm()\n  #puts \"elm():#{$pos}\"\n\n  ch = $str[$pos]\n  $pos += 1\n\n  return exp() if ch == '('\n  return -elm() if ch == '-'\n  return elm() if ch == '+'\n\n  x = ch.ord - '0'.ord\n  while /\\d/ =~ $str[$pos]\n    x = 10 * x + ($str[$pos].ord - '0'.ord)\n    $pos += 1\n  end\n\n  return x\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  $str = gets.chomp\n  $pos = 0\n  #p str\n  num = exp()\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def/n\n    self.fdiv(n) < 0 ? r.ceil : r.floor\n  end\nend\ngets.to_i.times { p eval(gets[0..-3]) }"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /n\n    fdiv(n).to_i\n  end\nend\ngets.to_i.times { p eval(gets[0..-3]) }"
  },
  {
    "language": "Ruby",
    "code": "puts gets.to_i.times.map{eval gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Fixnum\n\n\tdef /(o)\n\t\tres = self.fdiv(o)\n\t\tif (self < 0)\n\t\t\treturn res.ceil\n\t\telse\n\t\t\treturn res.floor\n\t\tend\n\tend\n\nend\n\ngets.to_i.times do\n\tputs eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "\nclass Fixnum\n  def / (x)\n    y = self.to_f.fdiv(x)\n    if y < 0.0\n      y = y.ceil\n    else\n      y = y.floor\n    end\n    y\n  end\nend\n\n\nwhile n = gets do\n  n.to_i.times do\n    puts eval(gets.chomp.chop)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n    p eval gets.chomp.chop\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n    p eval(gets.chomp.chop)\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp.chop.gsub(/(\\d+)/,'\\1.1')).to_i}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{p eval gets.chop.chop}"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n    else\n      st.push(item.to_i)\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push(1.0/calc.pop*calc.pop)\n    else calc.push(n) end\n  end\n  p calc[0]\n\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.strip.to_i.times{puts eval(gets.strip.sub(/=$/, \"\"))}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|s|p eval s.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "gets;puts$<.map{|x|eval x.gsub /\\=/,''}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times { puts eval gets.chomp.delete(\"=\") }"
  },
  {
    "language": "Ruby",
    "code": "#負の切り捨てがよろしくない\n# -3/2 = -2 ? -1\nclass Fixnum\n\tdef /(o)\n\t\tr=1.0*self.fdiv(o)\n\t\treturn r<0 ? r.ceil : r.floor\n\tend\nend\ngets.to_i.times{puts(eval(gets.chop.chop))}\n"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n    p eval gets.chop.chop\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n    def /n\n        fdiv(n).to_i\n    end\nend\ngets.to_i.times do\n    p eval gets.chomp.chop\nend"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n    else\n      st.push(item.to_i)\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push((1.0/calc.pop*calc.pop).floor)\n    else calc.push(n) end\n  end\n  p calc[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "gets\n$<.each{|s|p eval s[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "puts Array.new(gets.to_i){eval(gets.chomp[0...-1])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times {puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "op=[\")\",\"/\",\"*\",\"+\",\"-\",\"(\",\"=\"]\ngets.to_i.times do\n  l1=gets.chomp.split(\"\")\n  st,ops=[],[]\n  intflg=false\n  l1.each do |item|\n    if op.include?(item) then\n      if item==\"(\" then\n        ops.push(item)\n      elsif item==\")\" then\n        while ops[-1]!=\"(\"\n          st.push(ops.pop)\n        end\n        ops.pop\n      else\n        while ops.size>0 and op.index(ops[-1])<op.index(item)\n          st.push(ops.pop)\n        end\n        ops.push(item)\n      end\n      intflg=false\n    else\n      if intflg then st.push((st.pop.to_s+item).to_i)\n      else st.push(item.to_i) end\n      intflg=true\n    end\n  end\n  st.reverse!\n  calc=[]\n  while st.size > 0\n    case n=st.pop\n    when \"+\" then calc.push(calc.pop+calc.pop)\n    when \"-\" then calc.push(-calc.pop+calc.pop)\n    when \"*\" then calc.push(calc.pop*calc.pop)\n    when \"/\" then calc.push((1.0/calc.pop*calc.pop).floor)\n    else calc.push(n) end\n  end\n  puts calc[0]\nend"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{gets.tr!?=,\"\"\n0 while$_.sub!(/\\/(\\(\\g<1>([-+*\\/]\\g<1>)*\\)|\\d+)/,'.fdiv(\\1).to_i')\np eval$_}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nputs gets.to_i.times.map{l=gets.chomp;eval l[0,l.index('=')]}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  alias old_div /\n  def /(b)\n    if((self<0) ^ (b<0))\n      return -(self.abs.old_div(b.abs))\n    else\n      return self.old_div(b)\n    end\n  end\nend\n\ngets.to_i.times{puts eval(gets.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "def priority_calculator(array)\n  result = array.shift.to_i\n  while array.size > 0\n    result = result.method(array.shift.to_sym).call(array.shift.to_i)\n  end\n  return result\nend\ndef subordinate_calculator(array)\n  result = array.shift.to_i\n  while array.size > 0\n    result = result.method(array.shift.to_sym).call(array.shift.to_i)\n  end\n  return result\nend\ndef sinple_calculator(string)\n  reg = /\\d+[\\*\\/]\\d+([\\*\\/]\\d+)*+/\n  while string.match(/[\\*\\/]/)\n    string.gsub!(reg){|matched|\n      priority_calculator(matched.scan(/\\d+|\\D/))\n    }\n  end\n  return subordinate_calculator(string.scan(/\\d+|\\D/))\nend\ndef smartcalculator(string)\n  reg = /\\([^()]+?\\)/\n  while string.match(/[()]/)\n    string.gsub!(reg){|matched|\n      sinple_calculator(matched[1...-1])\n    }\n  end\n  return sinple_calculator(string)\nend\ndef main(input = STDIN)\n  input.gets.to_i.times do\n    puts smartcalculator(input.gets.chomp[0...-1])\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  alias_method :div, :/\n  def /(a)\n    self.div(a).floor\n  end\nend\nputs gets.strip.to_i.times.map{eval(gets.strip.sub(/=$/, \"\"))}.join(\"\\n\")"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chop.chop.chop)}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  puts eval(gets.chomp.chop.gsub(%r{/\\s*(-?[\\d|\\.]+)}, '.fdiv(\\1).to_i'))\nend"
  },
  {
    "language": "Ruby",
    "code": "$stderr.puts $<.read"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def /n\n    fdiv(n) < 0 ? r.ceil : r.floor\n  end\nend\ngets.to_i.times { p eval(gets[0..-3]) }"
  },
  {
    "language": "Ruby",
    "code": "p eval(gets.chop)"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Fixnum\n\t#I want -3/2 to be -1, not -2\n\tdef /(o) self.fdiv(o).truncate end\nend\nputs gets.to_i.times.map{eval gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "gets;puts$<.map{|x|(eval x[0..-3].gsub /\\//,'/1.0/').to_i}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n  def/n\n    r = self.fdiv(n)\n    r < 0 ? r.ceil : r.floor\n  end\nend\ngets.to_i.times { p eval(gets[0..-3]) }"
  },
  {
    "language": "Ruby",
    "code": "(gets.to_i).times do \n puts eval(gets.chomp.chop.gsub(/(\\d+)/, '\\1.to_r')).to_i\n end\n \n"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval(gets.chomp.chomp.chop)}"
  },
  {
    "language": "Ruby",
    "code": "$_.to_i.times{p eval(gets[0..-3])}while gets"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{ puts eval(gets.chomp.delete(\"=\")) }"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nclass Fixnum\n\t#-3/2 -> -1, not -2\n\tdef /(o) self.fdiv(o).truncate end\nend\nputs gets.to_i.times.map{eval gets.chomp.chop}"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\tdef / (n)\n\t\td = 1.0*self.fdiv(n)\n\t\treturn d.ceil if d < 0\n\t\treturn d.floor if d >= 0\n\t\tend\n\tend\nend\n\ngets.to_i.times{ puts eval(gets.chomp.delete(\"=\")) }"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{puts eval gets[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times do\n  puts eval(gets.chomp.chop.gsub(%r{/\\s*(-?\\d+?)}, '.fdiv(\\1).to_i'))\nend"
  },
  {
    "language": "Ruby",
    "code": "TERM_N  = 0\nTERM_OP_PM = 1\nTERM_OP_MD = 2\nTERM_OP_SIGN = 3\nTERM_LB = 4\nTERM_RB = 5\nTERM_END = 6\n\ndef lex_analyze(str)\n  expr = []\n\n  come_sign = true\n\n  for t in str.scan(/\\d+|[\\+\\-\\*\\/\\(\\)=]/)\n    case t\n      when '+', '-'\n      if come_sign\n        expr.push [TERM_OP_SIGN, t]\n      else\n        expr.push [TERM_OP_PM, t]\n        come_sign = true\n      end\n\n      when '*', '/'\n      expr.push [TERM_OP_MD, t]\n      come_sign = true\n\n      when '('\n      expr.push [TERM_LB, t]\n      come_sign = true\n\n      when ')'\n      expr.push [TERM_RB, t]\n      come_sign = true\n\n      when '='\n      expr.push [TERM_END, t]\n      come_sign = true\n\n      else\n      expr.push [TERM_N, t.to_i]\n      come_sign = false\n    end\n  end\n\n  return expr\nend\n\ndef to_rpn(expr)\n  rpn = []\n  stack = []\n\n  for t in expr\n    case t[0]\n      when TERM_N\n      rpn.push t\n      while ! stack.empty? && stack[-1][0] == TERM_OP_SIGN\n        rpn.push stack.pop\n      end\n\n      when TERM_OP_PM\n      while ! stack.empty? &&\n          ((st = stack[-1])[0] == TERM_OP_PM || st[0] == TERM_OP_MD)\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_MD\n      while ! stack.empty? && stack[-1][0] == TERM_OP_MD\n        rpn.push stack.pop\n      end\n      stack.push t\n\n      when TERM_OP_SIGN\n      stack.push t\n\n      when TERM_LB\n      stack.push t\n\n      when TERM_RB\n      while stack[-1][0] != TERM_LB\n        rpn.push stack.pop\n      end\n      stack.pop\n      while ! stack.empty? && stack[-1][0] == TERM_OP_SIGN\n        rpn.push stack.pop\n      end\n\n      when TERM_END\n      while ! stack.empty?\n        rpn.push stack.pop\n      end\n    end\n  end\n\n  return rpn\nend\n\ndef calc_rpn(rpn)\n  stack = []\n\n  for t in rpn\n    if t[0] == TERM_N\n      stack.push t[1]\n    elsif t[0] == TERM_OP_SIGN\n      if t[1] == '-'\n        n1 = stack.pop\n        stack.push -n1\n      end\n    else\n      n2 = stack.pop\n      n1 = stack.pop\n      case t[1]\n        when \"+\"\n        stack.push(n1 + n2)\n        when \"-\"\n        stack.push(n1 - n2)\n        when \"*\"\n        stack.push(n1 * n2)\n        when \"/\"\n        stack.push(n1 / n2)\n      end\n    end\n  end\n\n  return stack[-1]\nend\n\n### main\n\nn = gets.chomp.to_i\n\nn.times.each do\n  str = gets.chomp\n  #p str\n  expr = lex_analyze(str)\n  #p expr\n  rpn = to_rpn(expr)\n  #p rpn\n  num = calc_rpn(rpn)\n  puts num\nend"
  },
  {
    "language": "Ruby",
    "code": "puts$<.drop(1).map{|l|eval l.chop.chop}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.map{|s|p eval s[0..-3]}"
  },
  {
    "language": "Ruby",
    "code": "gets;$<.each_line.map{|s|p eval(s[0..-3])}"
  },
  {
    "language": "Ruby",
    "code": "gets.to_i.times{p eval gets.chop.chop}"
  },
  {
    "language": "Ruby",
    "code": "def calculator\n\ts = gets.chomp.delete(\"=\")\n\tp eval(s)\nend\n\nn = gets.to_i\nn.times {calculator}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tstdin := bufio.NewScanner(os.Stdin)\n\tstdin.Scan()\n\tn, _ := strconv.Atoi(stdin.Text())\n\tfor i := 0; i < n; i++ {\n\t\tstdin.Scan()\n\t\texp := strings.TrimRight(stdin.Text(), \"=\")\n\t\tres, _ := types.Eval(token.NewFileSet(), nil, token.NoPos, exp)\n\t\tfmt.Println(res.Value)\n\t}\n}\n\n"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\nfunction process($s){\n\t$bidx=strpos($s,'(');\n\twhile($bidx!==FALSE){\n\t\t$count=1;\n\t\t$eidx=$bidx+1;\n\t\tfor(;$count;$eidx++){\n\t\t\tif($s{$eidx}=='(')$count++;\n\t\t\tif($s{$eidx}==')')$count--;\n\t\t}\n\t\t$s=substr($s,0,$bidx).process(substr($s,$bidx+1,$eidx-1-($bidx+1))).substr($s,$eidx);\n\t\t$bidx=strpos($s,'(');\n\t}\n\t$matches=null;\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='*')\n\t\t\t$s=$matches[1].($matches[2]*$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].intval($matches[2]/$matches[4]).$matches[5];\n\t}\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='+')\n\t\t\t$s=$matches[1].($matches[2]+$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].($matches[2]-$matches[4]).$matches[5];\n\t}\n\treturn $s;\n}\nfor($n=fgets(STDIN)^0;$n;$n--){\n//while($s=fgets(STDIN)){\n\t$s=str_replace('-','Z',rtrim(fgets(STDIN)));\n\techo process(substr($s,0,strlen($s)-1)).\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval('?>'.'<?php $r = $v; ?>');\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval('?>'.'<?php $r = '.$v.'; ?>');\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval(\"\\$r = \".$v.\";\");\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\nfunction process($s){\n\t$bidx=strpos($s,'(');\n\twhile($bidx!==FALSE){\n\t\t$count=1;\n\t\t$eidx=$bidx+1;\n\t\tfor(;$count;$eidx++){\n\t\t\tif($s{$eidx}=='(')$count++;\n\t\t\tif($s{$eidx}==')')$count--;\n\t\t}\n\t\t$s=substr($s,0,$bidx).process(substr($s,$bidx+1,$eidx-1-($bidx+1))).substr($s,$eidx);\n\t\t$bidx=strpos($s,'(');\n\t}\n\t$matches=null;\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='*')\n\t\t\t$s=$matches[1].($matches[2]*$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].intval($matches[2]/$matches[4]).$matches[5];\n\t}\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='+')\n\t\t\t$s=$matches[1].($matches[2]+$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].($matches[2]-$matches[4]).$matches[5];\n\t}\n\treturn $s;\n}\nfgets(STDIN);\nwhile($s=fgets(STDIN)){\n\t$s=str_replace('-','Z',rtrim($s));\n\techo process(substr($s,0,strlen($s)-1)).\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval(\"\\$r = \\$v;\");\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\n$n = intval($L[0]);\nfor ( $i = 0; $i < $n; ++ $i ) {\n    eval(\"\\$res=intval(\".substr( $L[$i+1], 0, -1 ).\");\");\n    echo \"$res\\n\";\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\n$LC = count($L);\nfor ( $i = 0; $i < $LC; ) {\n    $n = intval($L[$i++]);\n    if ( $n == 0 ) break;\n    for ( $j = 0; $j < $n && $i < $LC; ++ $j, ++ $i ) {\n        eval(\"\\$res=\".substr( $L[$i], 0, -1 ).\";\");\n        echo \"$res\\n\";\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\nfile_put_contents('/tmp/a', '<h1>Hello World</h1>');\n$s = file_get_contents('/tmp/a');\n//$s = preg_replace('/[^a-zA-Z0-9]/', '_', $s);\neval('$a['.$s.'];');\n?>\n\n<?php\n\t$fp = fopen('php://stdin', 'r');\n\t$line = $r = '';\n\twhile ( $line = fread( $fp, 1024 ) ) {\n\t\t$e = substr($line, 0, -1);\n\t\t$e = preg_replace('/=/', '', $e);\n\t\teval('$r='.$e.';');\n\t\techo $r;\n\t}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$N = trim(fgets(STDIN));\nfor($i = 0; $i < $N; $i++){\n        echo eval(\"return (\".(explode('=',trim(fgets(STDIN)))[0]).\");\").PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\n$LC = count($L);\nfor ( $i = 0; $i < $LC; ) {\n    $n = intval($L[$i++]);\n    if ( $n == 0 ) break;\n    for ( $j = 0; $j < $n; ++ $j, ++ $i ) {\n        eval(\"\\$res=\".substr( $L[$i], 0, -1 ).\";\");\n        echo \"$res\\n\";\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\n$LC = count($L);\nfor ( $i = 0; $i < $LC; ) {\n    $n = intval($L[$i++]);\n    for ( $j = 0; $j < $n; ++ $j, ++ $i ) {\n        eval(\"\\$res=\".substr( $L[$i], 0, -1 ).\";\");\n        echo \"$res\\n\";\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\n$LC = count($L);\nfor ( $i = 0; $i < $LC; ) {\n    echo \"i = $i\\n\";\n    $n = intval($L[$i++]);\n    if ( $n == 0 ) break;\n    for ( $j = 0; $j < $n; ++ $j, ++ $i ) {\n        eval(\"\\$res=\".substr( $L[$i], 0, -1 ).\";\");\n        echo \"$res\\n\";\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\n$LC = count($L);\nfor ( $i = 0; $i < $LC; ) {\n    $n = intval($L[$i++]);\n    if ( $n == 0 ) break;\n    for ( $j = 0; $j < $n && $i < $LC; ++ $j, ++ $i ) {\n        eval(\"\\$res=\".substr( $L[$i], 0, -1 ).\";\");\n        echo \"$res\\n\";\n    }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfscanf(STDIN, '%d', $n);\nfor ($i = 0; $i < $n; $i++) {\n    $code = sprintf('$m = %s;', substr(trim(fgets(STDIN)), 0, -1));\n    eval($code);\n    echo (int)$m, PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file_get_contents(\"/dev/stdin\");\nfile_put_contents(\"/tmp/a.txt\", $in);\nfile_put_contents(\"/tmp/a.sh\", \"\");\necho exec(\"sh /tmp/a.sh\").\"\\n\";\n?>\n\n<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval(\"\\$r = $v;\");\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\nfor ( $i = 0; $i < intval($L[0]); ++ $i ) {\n    eval(\"\\$res=\".substr( $L[$i+1], 0, -1 ).\";\");\n    echo \"$res\\n\";\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\t$fp = fopen('php://stdin', 'r');\n\t$line = $r = '';\n\tdo {\n\t\t$e = substr($line,0,-1);\n\t\teval('$r='.$e.';');\n\t\techo $r;\n\t} while ( $line = fread( $fp, 1024 ) );\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval(\"$r=1;\");\n\t//eval(\"$r = \".$v.\";\");\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\nfunction process($s){\n\t$bidx=strpos($s,'(');\n\twhile($bidx!==FALSE){\n\t\t$count=1;\n\t\t$eidx=$bidx+1;\n\t\tfor(;$count;$eidx++){\n\t\t\tif($s{$eidx}=='(')$count++;\n\t\t\tif($s{$eidx}==')')$count--;\n\t\t}\n\t\t$s=substr($s,0,$bidx)+process(substr($s,$bidx+1,$eidx-1-($bidx+1)))+substr($s,$eidx);\n\t\t$bidx=strpos($s,'(');\n\t}\n\t$matches=null;\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='*')\n\t\t\t$s=$matches[1].($matches[2]*$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].floor($matches[2]/$matches[4]).$matches[5];\n\t}\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='+')\n\t\t\t$s=$matches[1].($matches[2]+$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].($matches[2]-$matches[4]).$matches[5];\n\t}\n\treturn $s;\n}\nfgets(STDIN);\nwhile($s=fgets(STDIN)){\n\t$s=str_replace('-','Z',rtrim($s));\n\techo process(substr($s,0,strlen($s)-1)).\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$tokens = array();\n$cnt = 0;\n\n// 変数表\n$variables = array();\n\nmain();\n\nfunction main() {\n\tglobal $tokens, $cnt;\n\t$n = trim(fgets(STDIN));\n\tfor ($i = 0; $i < $n; $i++) {\n\t\ttry {\n\t\t\t$cnt = 0;\n\t\t\t//echo \"$ \";\n\t\t\t$input = trim(fgets(STDIN));\n\t\t\t$tokens = tokenize($input);\n\t\t\t// 代入文か、式か？\n\t\t\tif (is_assignment()) {\n\t\t\t\tassign();\n\t\t\t} else {\n\t\t\t\t$tree = expression();\n\t\t\t\techo $tree->evaluate() . \"\\n\";\n\t\t\t}\n\t\t} catch (SyntaxErrorException $e) {\n\t\t\techo $e->getMessage() . \"\\n\";\n\t\t\t$tokens = array();\n\t\t\t$cnt = 0;\n\t\t} catch (UndefinedVariableException $e) {\n\t\t\techo $e->getMessage() . \"\\n\";\n\t\t\t$tokens = array();\n\t\t\t$cnt = 0;\n\t\t}\n\t}\n}\n\nfunction tokenize($line) {\n\t$line = str_replace(' ', '', $line);\n\tpreg_match_all(\"@([0-9]+|\\+|\\-|\\*|/|\\(|\\))@\", $line, $tokens);\n\tif (!is_array($tokens)) {\n\t\treturn array();\n\t}\n\treturn $tokens[0];\n}\n\nfunction is_assignment() {\n\tglobal $tokens;\n\t// 代入にはトークンが少なくとも3つ必要\n\tif (count($tokens) < 3) {\n\t\treturn false;\n\t}\n\t$t0 = $tokens[0];\n\t$t1 = $tokens[1];\n\tif (is_string($t0) && $t1 === '=') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction assign() {\n\tglobal $variables, $tokens, $cnt;\n\t$var = $tokens[0];\n\t$cnt += 2; // '=' を読み飛ばす。\n\t$exp = expression();\n\t$variables[$var] = is_object($exp) ? $exp->evaluate() : null;\n\n}\n\nfunction expression() {\n\tglobal $tokens, $cnt;\n\tif (empty($tokens)) {\n\t\tdie(\"tokens are empty\\n\");\n\t}\n\n\t$node = term();\n\n\twhile (true) {\n\t\tif ($cnt >= count($tokens)) {\n\t\t\tbreak;\n\t\t}\n\t\t$next = $tokens[$cnt];\n\t\tif ($next === '+'|| $next === '-') {\n\t\t\t$cnt++;\n\t\t\t$node = new Node($next, $node, term());\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $node;\n}\n\nfunction term() {\n\tglobal $tokens, $cnt;\n\n\t$node = factor();\n\n\twhile (true) {\n\t\tif ($cnt >= count($tokens)) {\n\t\t\tbreak;\n\t\t}\n\t\t$next = $tokens[$cnt];\n\t\tif ($next === '*' || $next === '/') {\n\t\t\t$cnt++;\n\t\t\t$node = new Node($next, $node, factor());\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $node;\n}\n\nfunction factor() {\n\tglobal $variables, $tokens, $cnt;\n\n\t$next = $tokens[$cnt];\n\n\t// カッコがきたらその中にはexpressionがある。\n\tif ($next === '(') {\n\t\t$cnt++; // 左カッコを読み飛ばす\n\t\t$node = expression();\n\t\tif ($tokens[$cnt++] !== ')') { // 右括弧を読み飛ばす\n\t\t\tthrow new SyntaxErrorException(\"カッコが閉じていない\");\n\t\t}\n\t\treturn $node;\n\t}\n\t// カッコでなければ数か変数として評価\n\t// 数\n\telseif (is_numeric($next)) {\n\t\t$cnt++;\n\t\treturn new Node(intval($next));\n\t}\n\t// 変数\n\telseif (is_string($next)) {\n\t\tif (isset($variables[$next])) {\n\t\t\t$cnt++;\n\t\t\treturn new Node($variables[$next]);\n\t\t}\n\t\tthrow new UndefinedVariableException(\"Undefined variable: \" . $next);\n\t} else {\n\t\tthrow new SyntaxErrorException(\"Syntax error 2.\\n\");\n\t}\n}\n\nclass Node {\n\n\tpublic $value;\n\tpublic $left;\n\tpublic $right;\n\n\tpublic function __construct($value = null, $left = null, $right = null) {\n\t\t$this->value = $value;\n\t\t$this->left = $left;\n\t\t$this->right = $right;\n\t}\n\n\tpublic function evaluate() {\n\t\tif (is_numeric($this->value) || $this->value === null) {\n\t\t\treturn intval($this->value);\n\t\t}\n\n\t\tif ($this->left && $this->right) {\n\t\t\t$left = $this->left->evaluate();\n\t\t\t$right = $this->right->evaluate();\n\t\t\t$op = $this->value;\n\t\t\tswitch ($op) {\n\t\t\t\tcase '+':\n\t\t\t\t\treturn $left + $right;\n\t\t\t\tcase '-':\n\t\t\t\t\treturn $left - $right;\n\t\t\t\tcase '*':\n\t\t\t\t\treturn $left * $right;\n\t\t\t\tcase '/':\n\t\t\t\t\treturn $left / $right;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new SyntaxErrorException(\"不明な演算子：$op\");\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new SyntaxErrorException(\"evaluate: ツリー構造がおかしい\");\n\t}\n\n\n\tpublic function show($depth = 0) {\n\t\t$return = \"\";\n\n\t\t$left  = is_a($this->left,  \"Node\") ? \"\\n\" . $this->left->show($depth + 1)  : $this->left;\n\t\t$right = is_a($this->right, \"Node\") ? \"\\n\" . $this->right->show($depth + 1) : $this->right;\n\n\t\t$return .= $this->space($depth) . \"value = {$this->value}\\n\";\n\t\t$return .= $this->space($depth) . \"left  = {$left}\\n\";\n\t\t$return .= $this->space($depth) . \"right = {$right}\\n\";\n\n\n\t\treturn $return;\n\t}\n\n\tprivate function space($depth) {\n\t\t$space = \"\";\n\t\tfor ($i = 0; $i < $depth * 4; $i++) {\n\t\t\t$space .= \" \";\n\t\t}\n\t\treturn $space;\n\t}\n}\n\nclass SyntaxErrorException extends Exception {}\nclass UndefinedVariableException extends RuntimeException {}"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\nfunction process($s){\n\t$bidx=strpos($s,'(');\n\twhile($bidx!==FALSE){\n\t\t$count=1;\n\t\t$eidx=$bidx+1;\n\t\tfor(;$count;$eidx++){\n\t\t\tif($s{$eidx}=='(')$count++;\n\t\t\tif($s{$eidx}==')')$count--;\n\t\t}\n\t\t$s=substr($s,0,$bidx).process(substr($s,$bidx+1,$eidx-1-($bidx+1))).substr($s,$eidx);\n\t\t$bidx=strpos($s,'(');\n\t}\n\t$matches=null;\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='*')\n\t\t\t$s=$matches[1].($matches[2]*$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].intval($matches[2]/$matches[4]).$matches[5];\n\t}\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='+')\n\t\t\t$s=$matches[1].($matches[2]+$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].($matches[2]-$matches[4]).$matches[5];\n\t}\n\treturn $s;\n}\nfor($n=fgets(STDIN);$n--;){\n//while($s=fgets(STDIN)){\n\t$s=str_replace('-','Z',rtrim(fgets(STDIN)));\n\techo process(substr($s,0,strlen($s)-1)).\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "\n<?php\n\t$fp = fopen('php://stdin', 'r');\n\t$line = $r = '';\n\twhile ( $line = fread( $fp, 1024 ) ) {\n\t\t$e = substr($line, 0, -1);\n\t\t$e = preg_replace('/=/', '', $e);\n\t\teval('$r='.$e.';');\n\t\techo $r;\n\t}\n?>"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\nfunction process($s){\n\t$bidx=strpos($s,'(');\n\twhile($bidx!==FALSE){\n\t\t$count=1;\n\t\t$eidx=$bidx+1;\n\t\tfor(;$count;$eidx++){\n\t\t\tif($s{$eidx}=='(')$count++;\n\t\t\tif($s{$eidx}==')')$count--;\n\t\t}\n\t\t$s=substr($s,0,$bidx).process(substr($s,$bidx+1,$eidx-1-($bidx+1))).substr($s,$eidx);\n\t\t$bidx=strpos($s,'(');\n\t}\n\t$matches=null;\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='*')\n\t\t\t$s=$matches[1].($matches[2]*$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].floor($matches[2]/$matches[4]).$matches[5];\n\t}\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='+')\n\t\t\t$s=$matches[1].($matches[2]+$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].($matches[2]-$matches[4]).$matches[5];\n\t}\n\treturn $s;\n}\nfgets(STDIN);\nwhile($s=fgets(STDIN)){\n\t$s=str_replace('-','Z',rtrim($s));\n\techo process(substr($s,0,strlen($s)-1)).\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\t$fp = fopen('php://stdin', 'r');\n\t$line = $r = '';\n\twhile ( $line = fread( $fp, 1024 ) ) {\n\t\t$e = substr($line, 0, -1);\n\t\t$s = preg_replace('/=/', '', $s);\n\t\teval('$r='.$e.';');\n\t\techo $r;\n\t}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$L = explode( \"\\n\", trim(file_get_contents('/dev/stdin')) );\nfor ( $i = 0; $i < intval($L[0]); ++ $i ) {\n    eval(\"\\$res=\".substr( $L[$i+1], 0, -1 ).\";\");\n    echo \"$res\\n\";\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\t$fp = fopen('php://stdin', 'r');\n\tdo {\n\t\t$e = substr($line,0,-1);\n\t\teval('$r='.$e.';');\n\t\techo $r;\n\t} while ( $line = fread( $fp, 1024 ) );\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval('$r = '.$v.';');\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$in = file(\"/dev/stdin\");\nforeach ( $in as $v ) {\n\t$v = preg_replace( \"/=/\", \"\", $v );\n\teval(\"\\$r = $v;\");\n\techo $r.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$tokens = array();\n$cnt = 0;\n\n// 変数表\n$variables = array();\n\nmain();\n\nfunction main() {\n\tglobal $tokens, $cnt;\n\t$n = trim(fgets(STDIN));\n\tfor ($i = 0; $i < $n; $i++) {\n\t\ttry {\n\t\t\t$cnt = 0;\n\t\t\t//echo \"$ \";\n\t\t\t$input = trim(fgets(STDIN));\n\t\t\t$tokens = tokenize($input);\n\t\t\t// 代入文か、式か？\n\t\t\tif (is_assignment()) {\n\t\t\t\tassign();\n\t\t\t} else {\n\t\t\t\t$tree = expression();\n\t\t\t\techo $tree->evaluate() . \"\\n\";\n\t\t\t}\n\t\t} catch (SyntaxErrorException $e) {\n\t\t\techo $e->getMessage() . \"\\n\";\n\t\t\t$tokens = array();\n\t\t\t$cnt = 0;\n\t\t} catch (UndefinedVariableException $e) {\n\t\t\techo $e->getMessage() . \"\\n\";\n\t\t\t$tokens = array();\n\t\t\t$cnt = 0;\n\t\t}\n\t}\n}\n\nfunction tokenize($line) {\n\t$line = str_replace(' ', '', $line);\n\tpreg_match_all(\"@([0-9]+|\\+|\\-|\\*|/|\\(|\\))@\", $line, $tokens);\n\tif (!is_array($tokens)) {\n\t\treturn array();\n\t}\n\treturn $tokens[0];\n}\n\nfunction is_assignment() {\n\tglobal $tokens;\n\t// 代入にはトークンが少なくとも3つ必要\n\tif (count($tokens) < 3) {\n\t\treturn false;\n\t}\n\t$t0 = $tokens[0];\n\t$t1 = $tokens[1];\n\tif (is_string($t0) && $t1 === '=') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction assign() {\n\tglobal $variables, $tokens, $cnt;\n\t$var = $tokens[0];\n\t$cnt += 2; // '=' を読み飛ばす。\n\t$exp = expression();\n\t$variables[$var] = is_object($exp) ? $exp->evaluate() : null;\n\n}\n\nfunction expression() {\n\tglobal $tokens, $cnt;\n\tif (empty($tokens)) {\n\t\tdie(\"tokens are empty\\n\");\n\t}\n\n\t$node = term();\n\n\twhile (true) {\n\t\tif ($cnt >= count($tokens)) {\n\t\t\tbreak;\n\t\t}\n\t\t$next = $tokens[$cnt];\n\t\tif ($next === '+'|| $next === '-') {\n\t\t\t$cnt++;\n\t\t\t$node = new Node($next, $node, term());\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $node;\n}\n\nfunction term() {\n\tglobal $tokens, $cnt;\n\n\t$node = factor();\n\n\twhile (true) {\n\t\tif ($cnt >= count($tokens)) {\n\t\t\tbreak;\n\t\t}\n\t\t$next = $tokens[$cnt];\n\t\tif ($next === '*' || $next === '/') {\n\t\t\t$cnt++;\n\t\t\t$node = new Node($next, $node, factor());\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $node;\n}\n\nfunction factor() {\n\tglobal $variables, $tokens, $cnt;\n\n\t$next = $tokens[$cnt];\n\n\t// カッコがきたらその中にはexpressionがある。\n\tif ($next === '(') {\n\t\t$cnt++; // 左カッコを読み飛ばす\n\t\t$node = expression();\n\t\tif ($tokens[$cnt++] !== ')') { // 右括弧を読み飛ばす\n\t\t\tthrow new SyntaxErrorException(\"カッコが閉じていない\");\n\t\t}\n\t\treturn $node;\n\t}\n\t// カッコでなければ数か変数として評価\n\t// 数\n\telseif (is_numeric($next)) {\n\t\t$cnt++;\n\t\treturn new Node(intval($next));\n\t}\n\t// 変数\n\telseif (is_string($next)) {\n\t\tif (isset($variables[$next])) {\n\t\t\t$cnt++;\n\t\t\treturn new Node($variables[$next]);\n\t\t}\n\t\tthrow new UndefinedVariableException(\"Undefined variable: \" . $next);\n\t} else {\n\t\tthrow new SyntaxErrorException(\"Syntax error 2.\\n\");\n\t}\n}\n\nclass Node {\n\n\tpublic $value;\n\tpublic $left;\n\tpublic $right;\n\n\tpublic function __construct($value = null, $left = null, $right = null) {\n\t\t$this->value = $value;\n\t\t$this->left = $left;\n\t\t$this->right = $right;\n\t}\n\n\tpublic function evaluate() {\n\t\tif (is_numeric($this->value) || $this->value === null) {\n\t\t\treturn intval($this->value);\n\t\t}\n\n\t\tif ($this->left && $this->right) {\n\t\t\t$left = $this->left->evaluate();\n\t\t\t$right = $this->right->evaluate();\n\t\t\t$op = $this->value;\n\t\t\tswitch ($op) {\n\t\t\t\tcase '+':\n\t\t\t\t\treturn $left + $right;\n\t\t\t\tcase '-':\n\t\t\t\t\treturn $left - $right;\n\t\t\t\tcase '*':\n\t\t\t\t\treturn $left * $right;\n\t\t\t\tcase '/':\n\t\t\t\t\treturn intval($left / $right);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new SyntaxErrorException(\"不明な演算子：$op\");\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new SyntaxErrorException(\"evaluate: ツリー構造がおかしい\");\n\t}\n\n\n\tpublic function show($depth = 0) {\n\t\t$return = \"\";\n\n\t\t$left  = is_a($this->left,  \"Node\") ? \"\\n\" . $this->left->show($depth + 1)  : $this->left;\n\t\t$right = is_a($this->right, \"Node\") ? \"\\n\" . $this->right->show($depth + 1) : $this->right;\n\n\t\t$return .= $this->space($depth) . \"value = {$this->value}\\n\";\n\t\t$return .= $this->space($depth) . \"left  = {$left}\\n\";\n\t\t$return .= $this->space($depth) . \"right = {$right}\\n\";\n\n\n\t\treturn $return;\n\t}\n\n\tprivate function space($depth) {\n\t\t$space = \"\";\n\t\tfor ($i = 0; $i < $depth * 4; $i++) {\n\t\t\t$space .= \" \";\n\t\t}\n\t\treturn $space;\n\t}\n}\n\nclass SyntaxErrorException extends Exception {}\nclass UndefinedVariableException extends RuntimeException {}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\t$fp = fopen('php://stdin', 'r');\n\t$line = $r = '';\n\twhile ( $line = fread( $fp, 1024 ) ) {\n\t\t$e = substr($line, 0, -1);\n\t\t$e = preg_replace('/=/', '', $e);\n\t\teval('$r='.$e.';');\n\t\techo $r;\n\t}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfscanf(STDIN, '%d', $n);\nfor ($i = 0; $i < $n; $i++) {\n    $str = str_replace('=', '', trim(fgets(STDIN)));\n    //括弧は1つだけと想定\n    if (preg_match('/\\(.+\\)/', $str, $matches)) {\n        $str2 = substr($matches[0], 1, -1);\n        $str = str_replace($matches[0], calc($str2), $str);\n    }\n    echo calc($str), PHP_EOL;\n}\n\nfunction calc($str)\n{\n    while (preg_match('|[*/]|', $str, $matches, PREG_OFFSET_CAPTURE)) {\n        $ope = $matches[0][0];\n        $pos = $matches[0][1];\n        $a = '';\n        $b = '';\n        $i = $pos - 1;\n        $j = $pos + 1;\n\n        while (true) {\n            $bool1 = @ctype_digit($str[$i]);\n            $bool2 = @ctype_digit($str[$j]);\n            if (!$bool1 && !$bool2) {\n                break;\n            }\n\n            if ($bool1) {\n                $a = $str[$i] . $a;\n                $i--;\n            }\n\n            if ($bool2) {\n                $b .= $str[$j];\n                $j++;\n            }\n        }\n\n        $result = $ope === '*' ? (int)($a * $b) : (int)($a / $b);\n        $str = substr($str, 0, $i + 1) . $result . substr($str, $j);\n    }\n\n    $arr = array();\n    $n = '';\n    for ($i = 0, $len = strlen($str); $i < $len; $i++) {\n        $ch = $str[$i];\n        if (ctype_digit($ch)) {\n            $n .= $ch;\n        } else {\n            $arr[] = (int)$n;\n            $n = $ch;\n        }\n    }\n    $arr[] = (int)$n;\n\n    return array_sum($arr);\n}"
  },
  {
    "language": "PHP",
    "code": "#!/usr/bin/php\n<?php\nfunction process($s){\n\t$bidx=strpos($s,'(');\n\twhile($bidx!==FALSE){\n\t\t$count=1;\n\t\t$eidx=$bidx+1;\n\t\tfor(;$count;$eidx++){\n\t\t\tif($s{$eidx}=='(')$count++;\n\t\t\tif($s{$eidx}==')')$count--;\n\t\t}\n\t\t$s=substr($s,0,$bidx)+process(substr($s,$bidx+1,$eidx-1-($bidx+1)))+substr($s,$eidx);\n\t\t$bidx=strpos($s,'(');\n\t}\n\t$matches=null;\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([*\\\\/])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='*')\n\t\t\t$s=$matches[1].($matches[2]*$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].floor($matches[2]/$matches[4]).$matches[5];\n\t}\n\twhile(preg_match(\"/^(.*?)(-?\\\\d+)([+Z])(-?\\\\d+)(.*)$/\",$s,$matches)){\n\t\tif($matches[3]=='+')\n\t\t\t$s=$matches[1].($matches[2]+$matches[4]).$matches[5];\n\t\telse\n\t\t\t$s=$matches[1].($matches[2]-$matches[4]).$matches[5];\n\t}\n\treturn $s;\n}\nwhile($s=fgets(STDIN)){\n\t$s=str_replace('-','Z',rtrim($s));\n\techo process(substr($s,0,strlen($s)-1)).\"\\n\";\n}\n?>"
  },
  {
    "language": "OCaml",
    "code": "(* parser ????????????\nexp    = term _exp\n_exp   = + term _exp | eps\nterm   = factor _term\n_term  = * factor _term | eps\nfactor = ( exp ) | num\nnum    = digit(digit)*\ndigit  = 0-9\n*)\n\nlet s = ref \"\"\nlet length = ref 0\nlet cur = ref 0\n\nlet str_access n =\n  if ( n < !length ) then (String.get !s n)\n  else '#'\n\nlet digit ()=\n  let a = Char.escaped (str_access !cur)  in\n  (cur:=!cur+1;int_of_string a)\n\nlet rec number () =\n  let n = ref (digit()) in\n  while (!cur < !length && (str_access !cur) >= '0' && (str_access !cur) <= '9') do\n    n := 10 * !n + digit()\n  done ; !n\n\nand factor ()=\n  match (str_access !cur) with\n    '(' -> (cur := !cur+1;let n=expr() in cur := !cur+1; n)\n  | _   -> number()\n\nand term ()=\n  let n = factor() in (_term n)\n\nand _term m =\n  match (str_access !cur) with\n    '*' -> (cur := !cur+1;let n = m*(factor()) in (_term n))\n  | '/' -> (cur := !cur+1;let n = m/(factor()) in (_term n))\n  | _   -> m\n\nand expr ()=\n  let n = term ()in (_expr n)\n\nand _expr m =\n  match (str_access !cur) with\n    '+' -> (cur := !cur+1;let n = m+(term()) in (_expr n))\n  | '-' -> (cur := !cur+1;let n = m-(term()) in (_expr n))\n  | _   -> m\n\nand parse () = expr ();;\n\n(* main *)\n\n(*\nignore ( read_line () )\nlet rec loop() =\n  try\n    s := read_line();\n    length := String.length !s;\n    cur := 0;\n    print_int @@ parse ();print_newline();\n    loop()\n  with End_of_file -> ()\nlet () = loop()\n*)\nlet nn = int_of_string @@ read_line()\nlet () =\nfor i = 1 to nn do\n  s := read_line();\n  length := String.length !s;\n  cur := 0;\n  print_int @@ parse ();print_newline();\ndone"
  },
  {
    "language": "OCaml",
    "code": "(* parser ????????????\nexp    = term _exp\n_exp   = + term _exp | eps\nterm   = factor _term\n_term  = * factor _term | eps\nfactor = ( exp ) | num\nnum    = digit(digit)*\ndigit  = 0-9\n*)\n\nlet s = ref \"\"\nlet length = ref 0\nlet cur = ref 0\n\nlet str_access n =\n  if ( n < !length ) then (String.get !s n)\n  else '#'\n\nlet digit ()=\n  let a = Char.escaped (str_access !cur)  in\n  (cur:=!cur+1;int_of_string a)\n\nlet rec number () =\n  let n = ref (digit()) in\n  while (!cur < !length && (str_access !cur) >= '0' && (str_access !cur) <= '9') do\n    n := 10 * !n + digit()\n  done ; !n\n\nand factor ()=\n  match (str_access !cur) with\n    '(' -> (cur := !cur+1;let n=expr() in cur := !cur+1; n)\n  | _   -> number()\n\nand term ()=\n  let n = factor() in (_term n)\n\nand _term m =\n  match (str_access !cur) with\n    '*' -> (cur := !cur+1;let n = m*(factor()) in (_term n))\n  | '/' -> (cur := !cur+1;let n = m/(factor()) in (_term n))\n  | _   -> m\n\nand expr ()=\n  let n = term ()in (_expr n)\n\nand _expr m =\n  match (str_access !cur) with\n    '+' -> (cur := !cur+1;let n = m+(term()) in (_expr n))\n  | '-' -> (cur := !cur+1;let n = m-(term()) in (_expr n))\n  | _   -> m\n\nand parse () = expr ();;\n\n(* main *)\nignore ( read_line () )\n\nlet rec loop() =\n  try\n    s := read_line();\n    length := String.length !s;\n    cur := 0;\n    print_int @@ parse ();print_newline();\n    loop()\n  with End_of_file -> ()\n\nlet () = loop()"
  },
  {
    "language": "OCaml",
    "code": "\nlet s = ref \"\"\nlet length = ref 0\nlet cur = ref 0\n\nlet str_access n =\n  if ( n < !length ) then (String.get !s n)\n  else '#'\n\nlet digit ()=\n  let a = Char.escaped (str_access !cur)  in\n  (cur:=!cur+1;int_of_string a)\n\nlet rec number () =\n  let n = ref (digit()) in\n  while (!cur < !length && (str_access !cur) >= '0' && (str_access !cur) <= '9') do\n    n := 10 * !n + digit()\n  done ; !n\n\nand factor ()=\n  match (str_access !cur) with\n    '(' -> (cur := !cur+1;let n=expr() in cur := !cur+1; n)\n  | _   -> number()\n\nand term ()=\n  let n = factor() in (_term n)\n\nand _term m =\n  match (str_access !cur) with\n    '*' -> (cur := !cur+1;let n = m*(factor()) in (_term n))\n  | '/' -> (cur := !cur+1;let n = m/(factor()) in (_term n))\n  | _   -> m\n\nand expr ()=\n  let n = term ()in (_expr n)\n\nand _expr m =\n  match (str_access !cur) with\n    '+' -> (cur := !cur+1;let n = m+(term()) in (_expr n))\n  | '-' -> (cur := !cur+1;let n = m-(term()) in (_expr n))\n  | _   -> m\n\nand parse () = expr ();;\n\n(* main *)\nignore ( read_line () )\n\nlet rec loop() =\n  try\n    s := read_line();\n    length := String.length !s;\n    cur := 0;\n    print_int @@ parse ();print_newline();\n    loop()\n  with End_of_file -> ()\n\nlet () = loop()"
  },
  {
    "language": "OCaml",
    "code": "(* parser ????????????\nexp    = term _exp\n_exp   = + term _exp | eps\nterm   = factor _term\n_term  = * factor _term | eps\nfactor = ( exp ) | num\nnum    = digit(digit)*\ndigit  = 0-9\n*)\nignore(read_line())\nlet s = read_line()\nlet length = String.length s\nlet cur = ref 0\n\nlet str_access n =\n  if ( n < length ) then s.[n]\n  else '#'\n\nlet digit ()=\n  let a = Char.escaped (str_access !cur)  in\n  (cur:=!cur+1;int_of_string a)\n\nlet rec number () =\n  let n = ref (digit()) in\n  while (!cur < length && (str_access !cur) >= '0' && (str_access !cur) <= '9') do\n    n := 10 * !n + digit()\n  done ; !n\n\nand factor ()=\n  match (str_access !cur) with\n    '(' -> (cur := !cur+1;let n=expr() in cur := !cur+1; n)\n  | _   -> number()\n\nand term ()=\n  let n = factor() in (_term n)\n\nand _term m =\n  match (str_access !cur) with\n    '*' -> (cur := !cur+1;let n = m*(factor()) in (_term n))\n  | '/' -> (cur := !cur+1;let n = m/(factor()) in (_term n))\n  | _   -> m\n\nand expr ()=\n  let n = term ()in (_expr n)\n\nand _expr m =\n  match (str_access !cur) with\n    '+' -> (cur := !cur+1;let n = m+(term()) in (_expr n))\n  | '-' -> (cur := !cur+1;let n = m-(term()) in (_expr n))\n  | _   -> m\n\nand parse() = expr()\n\n\nlet () = print_int @@ parse () ; print_newline()"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nint s;\n\nlong number (string str) {\n\tauto l = s;\n\ts++;\n\twhile (str[s] >= '0' && str[s] <= '9') s++;\n\t\n\treturn str[l..s].to!long;\n}\n\nlong factor (string str) {\n\tlong res;\n\n\tif (str[s] == '(') {\n\t\ts++;\n\t\tres = expression(str);\n\t\ts++;\n\t} else {\n\t\tres = number(str);\n\t}\n\n\treturn res;\n}\n\nlong term (string str) {\n\tauto res = factor(str);\n\t\n\twhile (1) {\n\t\tif (str[s] == '*') {\n\t\t\ts++;\n\t\t\tres *= factor(str);\n\t\t} else if (str[s] == '/') {\n\t\t\ts++;\n\t\t\tres /= factor(str);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nlong expression (string str) {\n\tauto res = term(str);\n\n\twhile (1) {\n\t\tif (str[s] == '+') {\n\t\t\ts++;\n\t\t\tres += term(str);\n\t\t} else if (str[s] == '-') {\n\t\t\ts++;\n\t\t\tres -= term(str);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid main()\n{\n\tauto n = readln.chomp.to!int;\n\tforeach (i; 0..n) {\n\t\ts = 0;\n\t\tauto eqn = readln.chomp.to!string;\n\t\teqn.expression.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii, std.array;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs = mul;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '+':\n                line.popFront;\n                lhs += mul;\n                break;\n            case '-':\n                line.popFront;\n                lhs += mul;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint mul()\n{\n    int lhs = prim;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '*':\n                line.popFront;\n                lhs *= prim;\n                break;\n            case '/':\n                line.popFront;\n                lhs /= prim;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = add;\n        line.popFront;\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -prim;\n    }\n    else\n    {\n        int i;\n        while(line[i].isDigit) ++i;\n        r = line[0 .. i].to!int;\n        line = line[i .. $];\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "\nimport std.stdio, std.ascii, std.array, std.string;\n\nalias int function(int, int) Op;\n\nenum Type {LParen, RParen, Plus, Minus, Multi, Div, Number, Equal}\n\nstruct Token {\n  Type type;\n  union V {\n    int number;\n    Op op;\n  }\n  V variant;\n}\n\nToken[char] table;\nToken[] state;\n\nstatic this() {\n  table =\n    ['+': Token(Type.Plus),\n     '-': Token(Type.Minus),\n     '*': Token(Type.Multi),\n     '/': Token(Type.Div),\n     '(': Token(Type.LParen),\n     ')': Token(Type.RParen),\n     '=': Token(Type.Equal)];\n  \n  table['+'].variant.op = (x, y) => x + y;\n  table['-'].variant.op = (x, y) => x - y;\n  table['*'].variant.op = (x, y) => x * y;\n  table['/'].variant.op = (x, y) => x / y;\n}\n\nToken[] tokenize(string str) {\n  Token[] tokens;\n  int i = 0;\n  while(str.length > i) {\n    if (isDigit(str[i])) {\n      Token token;\n      int number = 0;\n      do {\n        number = 10 * number + (str[i] - '0');\n      } while(isDigit(str[++i]));\n      token.type = Type.Number;\n      token.variant.number = number;\n      tokens ~= token;\n    }\n    else {\n      tokens ~= table[str[i++]];\n    }    \n  }\n  return tokens;\n}\n\nToken[] expect(Token[] tokens, Type type) {  \n  if (tokens[0].type != type) throw new Exception(\"unexpected token.\");\n  else\n    return tokens[1..$];\n}\n\nvoid operate(Token token) {\n  Token a = state.back; state.popBack;\n  Token b = state.back; state.popBack;\n  assert(a.type == Type.Number && b.type == Type.Number);\n  Token t;\n  t.type = Type.Number;\n  t.variant.number = token.variant.op(b.variant.number, a.variant.number);\n  state ~= t;\n}\n\nToken[] factor(Token[] tokens) {\n  switch(tokens[0].type) {\n  case Type.Number:\n    state ~= tokens.front;\n    tokens.popFront;\n    break;\n  case Type.LParen:\n    tokens.popFront;\n    tokens = expect(expression(tokens), Type.RParen);\n    break;\n  default:\n    throw new Exception(\"error occured\");\n    break;\n  }\n  return tokens;\n}\n\nToken[] term(Token[] tokens) {\n  tokens = factor(tokens);\n  while(tokens[0].type == Type.Multi ||\n        tokens[0].type == Type.Div) {\n    Token front = tokens.front;\n    tokens.popFront;\n    tokens = factor(tokens);\n    operate(front);\n  }\n  return tokens;\n}\n\nToken[] expression(Token[] tokens) {\n  tokens = term(tokens);\n  while(tokens[0].type == Type.Plus ||\n        tokens[0].type == Type.Minus) {\n    Token front = tokens.front;\n    tokens.popFront;\n    tokens = term(tokens);\n    operate(front);\n  }\n  return tokens;\n}\n\nalias expression parse;\n\nint eval(string line) {\n  state = [];\n  parse(line.tokenize);\n  return state[0].variant.number;\n}\n\nvoid main() {\n  int times;\n  readf(\"%d\\n\", &times);\n  foreach(t; 0..times) {\n    readln.chomp.eval.writeln;\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nint s;\n\nlong number (string str) {\n\tauto l = s;\n\ts++;\n\twhile (str[s] >= '0' && str[s] <= '9') s++;\n\t\n\treturn str[l..s].to!long;\n}\n\nlong factor (string str) {\n\tlong res;\n\n\tif (str[s] == '(') {\n\t\ts++;\n\t\tres = expression(str);\n\t\ts++;\n\t} else {\n\t\tres = number(str);\n\t}\n\n\treturn res;\n}\n\nlong term (string str) {\n\tauto res = number(str);\n\t\n\twhile (1) {\n\t\tif (str[s] == '*') {\n\t\t\ts++;\n\t\t\tres *= factor(str);\n\t\t} else if (str[s] == '/') {\n\t\t\ts++;\n\t\t\tres /= factor(str);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nlong expression (string str) {\n\tauto res = term(str);\n\n\twhile (1) {\n\t\tif (str[s] == '+') {\n\t\t\ts++;\n\t\t\tres += term(str);\n\t\t} else if (str[s] == '-') {\n\t\t\ts++;\n\t\t\tres -= term(str);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid main()\n{\n\tauto n = readln.chomp.to!int;\n\tforeach (i; 0..n) {\n\t\ts = 0;\n\t\tauto eqn = readln.chomp.to!string;\n\t\teqn.expression.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii, std.array;\n \nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n \nstring line;\n \nint add()\n{\n    int lhs = mul;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '+':\n            line.popFront;\n            return lhs + add;\n        case '-':\n            line.popFront;\n            return lhs - add;\n        default:\n            return lhs;\n    }\n}\n \nint mul()\n{\n    int lhs = prim;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '*':\n            line.popFront;\n            return lhs * mul;\n        case '/':\n            line.popFront;\n            return lhs / mul;\n        default:\n            return lhs;\n    }\n}\n \nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = prim;\n        line = line[1 .. $];\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -add;\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r = r * 10 + (line[0] - '0');\n            line.popFront;\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii, std.array;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs = mul;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '+':\n            line.popFront;\n            return lhs + add;\n        case '-':\n            line.popFront;\n            return lhs - add;\n        default:\n            return lhs;\n    }\n}\n\nint mul()\n{\n    int lhs = prim;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '*':\n            line.popFront;\n            return lhs * mul;\n        case '/':\n            line.popFront;\n            return lhs / mul;\n        default:\n            return lhs;\n    }\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = add;\n        line = line[1 .. $];\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -add;\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r = r * 10 + (line[0] - '0');\n            line.popFront;\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii, std.array;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs = mul;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '+':\n                line.popFront;\n                lhs += mul;\n                break;\n            case '-':\n                line.popFront;\n                lhs += mul;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint mul()\n{\n    int lhs = prim;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '*':\n                line.popFront;\n                lhs *= prim;\n                break;\n            case '/':\n                line.popFront;\n                lhs /= prim;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = add;\n        line.popFront;\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -mul;\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r = r * 10 + (line[0] - '0');\n            line.popFront;\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nint s;\n\nint number (string str) {\n\tauto l = s;\n\ts++;\n\twhile (str[s] >= '0' && str[s] <= '9') s++;\n\t\n\treturn str[l..s].to!int;\n}\n\nint factor (string str) {\n\tint res;\n\n\tif (str[s] == '(') {\n\t\ts++;\n\t\tres = expression(str);\n\t\ts++;\n\t} else {\n\t\tres = number(str);\n\t}\n\n\treturn res;\n}\n\nint term (string str) {\n\tauto res = number(str);\n\t\n\twhile (1) {\n\t\tif (str[s] == '*') {\n\t\t\ts++;\n\t\t\tres *= factor(str);\n\t\t} else if (str[s] == '/') {\n\t\t\ts++;\n\t\t\tres /= factor(str);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint expression (string str) {\n\tauto res = term(str);\n\n\twhile (1) {\n\t\tif (str[s] == '+') {\n\t\t\ts++;\n\t\t\tres += term(str);\n\t\t} else if (str[s] == '-') {\n\t\t\ts++;\n\t\t\tres -= term(str);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid main()\n{\n\tauto n = readln.chomp.to!int;\n\tforeach (i; 0..n) {\n\t\ts = 0;\n\t\tauto eqn = readln.chomp.to!string;\n\t\teqn.expression.writeln;\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.string;\nimport std.conv;\n\nstring s;\n\nvoid main(){\n\tint n;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\ts = chomp(readln());\n\t\twriteln(expression());\n\t}\n}\n\nint expression(){\n\tint result = term();\n\twhile (1) {\n\t\tif (s[0] == '+') {\n\t\t\ts.popFront();\n\t\t\tresult += term();\n\t\t}else if (s[0] == '-') {\n\t\t\ts.popFront();\n\t\t\tresult -= term();\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nint term(){\n\tint result = factor();\n\twhile (1) {\n\t\tif (s[0] == '*') {\n\t\t\ts.popFront();\n\t\t\tresult *= factor();\n\t\t}else if (s[0] == '/') {\n\t\t\ts.popFront();\n\t\t\tresult /= factor();\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nint factor(){\n\tint result;\n\tif (s[0] == '(') {\n\t\ts.popFront();\n\t\tresult = expression();\n\t\ts.popFront();\n\t}else if (s[0] == '-') {\n\t\ts.popFront();\n\t\tresult = -factor();\n\t}else {\n\t\tint i;\n\t\tfor (i = 0; s[i] >= '0' && s[i] <= '9'; i++) {\n\t\t}\n\t\tresult = to!int(s[0..i]);\n\t\ts = s[i..$];\n\t}\n\treturn result;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\n\n\nstring[] operators = [\"=\",\"(\", \")\", \"+\", \"-\", \"*\", \"/\"];\nbool isOperator(string s) {\n\treturn operators.canFind(s);\n}\nint priority(string op) {\n\tint i = 0;\n\twhile(operators[i] != op)\n\t\t++i;\n\treturn (i+1)/2;\n}\n\nstring nextToken(ref string s) {\n\tstring t = \"\";\n\twhile(s[0].isDigit()) {\n\t\tt ~= s[0];\n\t\ts.popFrontN(1);\n\t}\n\tif(t == \"\") {\n\t\tt ~= s[0];\n\t\ts.popFrontN(1);\n\t}\n\treturn t;\n}\n\nint apply(string op, int l, int r) {\n\tswitch(op){\n\t\tcase \"+\":\n\t\t\treturn l+r;\n\t\tcase \"-\":\n\t\t\treturn l-r;\n\t\tcase \"*\":\n\t\t\treturn l*r;\n\t\tcase \"/\":\n\t\t\treturn l/r;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nvoid apply(string op, ref int[] vstack) {\n\tauto r = vstack.back;\n\tvstack.popBackN(1);\n\tauto l = vstack.back;\n\tvstack.popBackN(1);\n\tvstack ~= apply(op, l, r);\n}\n\nint calc(string s) {\n\tint[] vstack;\n\tstring[] opstack;\n\twhile(!s.empty()) {\n\t\tauto t = nextToken(s);\n\t\tif(!t.isOperator()) {\n\t\t\tvstack ~= to!int(t);\n\t\t} else {\n\t\t\tif(opstack.empty || t == \"(\" || t.priority() > opstack.back.priority())\n\t\t\t\topstack ~= t;\n\t\t\telse {\n\t\t\t\tauto op = opstack.back;\n\t\t\t\topstack.popBackN(1);\n\t\t\t\tif(op == \"(\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tapply(op, vstack);\n\t\t\t\ts = t~s;\n\t\t\t}\n\t\t}\n\t}\n\treturn vstack.front;\n}\nvoid main() {\n\tint n = to!int(readln().strip());\n\tforeach(i; 0..n) {\n\t\tauto s = readln().strip();\n\t\twriteln(calc(s));\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.string;\nimport std.conv;\n\nvoid main(){\n\tint n;\n\tstring s;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\ts = chomp(readln());\n\t\ts.popBack();\n\t\twriteln(expression(s));\n\t}\n}\n\nint expression(string s){\n\tfor (int i = 0; i < s.length; i++) {\n\t\tif (s[i] == '(') {\n\t\t\tfor (int j = i+1; j < s.length; j++) {\n\t\t\t\tif (s[j] == ')') {\n\t\t\t\t\tstring tmp = to!string(expression(s[i+1..j]));\n\t\t\t\t\ts = replace(s, s[i..j+1], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn factor(s);\n}\n\nint factor(string s){\n\tint start = 0;\n\tfor (int i = 0; i < s.length; i++) {\n\t\tif (s[i] == '-' || s[i] == '+') start = i + 1;\n\t\tif (s[i] == '*' || s[i] == '/') {\n\t\t\tfor (int j = i+1; j <= s.length; j++) {\n\t\t\t\tif (j == s.length || s[j] < '0' || s[j] > '9') {\n\t\t\t\t\tint tmp;\n\t\t\t\t\tif (s[i] == '*') tmp = to!int(s[start..i]) * to!int(s[i+1..j]);\n\t\t\t\t\telse if (s[i] == '/') tmp = to!int(s[start..i]) / to!int(s[i+1..j]);\n\t\t\t\t\ts = replace(s, s[start..j], to!string(tmp));\n\t\t\t\t\ti = start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn term(s);\n}\n\nint term(string s){\n\tfor (int i = 0; i < s.length; i++) {\n\t\tif (s[i] == '-' || s[i] == '+') {\n\t\t\tfor (int j = i+1; j <= s.length; j++) {\n\t\t\t\tif (j == s.length || s[j] < '0' || s[j] > '9') {\n\t\t\t\t\tint tmp;\n\t\t\t\t\tif (s[i] == '-') tmp = to!int(s[0..i]) - to!int(s[i+1..j]);\n\t\t\t\t\telse if (s[i] == '+') tmp = to!int(s[0..i]) + to!int(s[i+1..j]);\n\t\t\t\t\ts = replace(s, s[0..j], to!string(tmp));\n\t\t\t\t\ti = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn number(s);\n}\n\nint number(string s){\n\treturn to!int(s);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs = mul;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '+':\n            line = line[1 .. $];\n            return lhs + add;\n        case '-':\n            line = line[1 .. $];\n            return lhs - add;\n        default:\n            return lhs;\n    }\n}\n\nint mul()\n{\n    int lhs = prim;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '*':\n            line = line[1 .. $];\n            return lhs * mul;\n        case '/':\n            line = line[1 .. $];\n            return lhs / mul;\n        default:\n            return lhs;\n    }\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line = line[1 .. $];\n        r = add;\n        line = line[1 .. $];\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r = r * 10 + (line[0] - '0');\n            line = line[1 .. $];\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii, std.array;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs = mul;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '+':\n            line.popFront;\n            return lhs + add;\n        case '-':\n            line.popFront;\n            return lhs - add;\n        default:\n            return lhs;\n    }\n}\n\nint mul()\n{\n    int lhs = prim;\n    if(line[0] == '=') return lhs;\n    switch(line[0])\n    {\n        case '*':\n            line.popFront;\n            return lhs * mul;\n        case '/':\n            line.popFront;\n            return lhs / mul;\n        default:\n            return lhs;\n    }\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = add;\n        line = line[1 .. $];\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -mul;\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r = r * 10 + (line[0] - '0');\n            line.popFront;\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.ascii, std.array;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs = mul;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '+':\n                line.popFront;\n                lhs += mul;\n                break;\n            case '-':\n                line.popFront;\n                lhs += mul;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint mul()\n{\n    int lhs = prim;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '*':\n                line.popFront;\n                lhs *= prim;\n                break;\n            case '/':\n                line.popFront;\n                lhs /= prim;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = add;\n        line.popFront;\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -prim;\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r = r * 10 + (line[0] - '0');\n            line.popFront;\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.string;\nimport std.conv;\n\nvoid main(){\n\tint n;\n\tstring s;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\ts = chomp(readln());\n\t\ts.popBack();\n\t\twriteln(expression(s));\n\t}\n}\n\nint expression(string s){\n\tfor (int i = 0; i < s.length; i++) {\n\t\tif (s[i] == '(') {\n\t\t\tfor (int j = i+1; j < s.length; j++) {\n\t\t\t\tif (s[j] == ')') {\n\t\t\t\t\tstring tmp = to!string(expression(s[i+1..j]));\n\t\t\t\t\ts = replace(s, s[i..j+1], tmp);\n\t\t\t\t\ti = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn factor(s);\n}\n\nint factor(string s){\n\tint start = 0;\n\tfor (int i = 1; i < s.length; i++) {\n\t\tif (s[i] == '-' || s[i] == '+') start = i + 1;\n\t\tif (s[i] == '*' || s[i] == '/') {\n\t\t\tfor (int j = i+2; j <= s.length; j++) {\n\t\t\t\tif (j == s.length || s[j] < '0' || s[j] > '9') {\n\t\t\t\t\tint tmp;\n\t\t\t\t\tif (s[i] == '*') tmp = to!int(s[start..i]) * to!int(s[i+1..j]);\n\t\t\t\t\telse if (s[i] == '/') tmp = to!int(s[start..i]) / to!int(s[i+1..j]);\n\t\t\t\t\ts = replace(s, s[start..j], to!string(tmp));\n\t\t\t\t\ti = start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn term(s);\n}\n\nint term(string s){\n\tfor (int i = 1; i < s.length; i++) {\n\t\tif (s[i] == '-' || s[i] == '+') {\n\t\t\tfor (int j = i+2; j <= s.length; j++) {\n\t\t\t\tif (j == s.length || s[j] < '0' || s[j] > '9') {\n\t\t\t\t\tint tmp;\n\t\t\t\t\tif (s[i] == '-') tmp = to!int(s[0..i]) - to!int(s[i+1..j]);\n\t\t\t\t\telse if (s[i] == '+') tmp = to!int(s[0..i]) + to!int(s[i+1..j]);\n\t\t\t\t\ts = replace(s, s[0..j], to!string(tmp));\n\t\t\t\t\ti = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn number(s);\n}\n\nint number(string s){\n\treturn to!int(s);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,  std.string,  std.conv,  std.ascii,  std.array;\n\nvoid main()\n{\n    foreach(_; 0 .. readln.chomp.to!int)\n    {\n        line = readln.chomp;\n        add.writeln;\n\n    }\n}\n\nstring line;\n\nint add()\n{\n    int lhs  =  mul;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '+':\n                line.popFront;\n                lhs += mul;\n                break;\n            case '-':\n                line.popFront;\n                lhs -= mul;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint mul()\n{\n    int lhs = prim;\n    loop:\n    while(true)\n    {\n        switch(line[0])\n        {\n            case '*':\n                line.popFront;\n                lhs *= prim;\n                break;\n            case '/':\n                line.popFront;\n                lhs /= prim;\n                break;\n            default:\n                break loop;\n        }\n    }\n    return lhs;\n}\n\nint prim()\n{\n    int r;\n    if(line[0] == '(')\n    {\n        line.popFront;\n        r = add;\n        line.popFront;\n    }\n    else if(line[0] == '-')\n    {\n        line.popFront;\n        r = -mul;\n\n    }\n    else while(line[0] != '=')\n    {\n        if(line[0].isDigit)\n        {\n            r  =  r * 10 + (line[0] - '0');\n            line.popFront;\n        } \n        else break;\n    }\n    return r;\n}"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp,brac=None):\n    i = 0 # ループカウンタ?\n    num = deque() # 数字をためておく\n    ops = deque() # +-をためておく\n    ope = \"\" # */を保存\n    \n    if not brac:\n        # 対応する括弧の位置を記録しておいて計算量を削減\n        brac = [-1 for j in range(len(exp))]\n        tmpbrac = []\n        for j in range(len(exp) - 1, 0, -1):\n            if exp[j] == ')':\n                tmpbrac.append(j)\n            elif exp[j] == '(':\n                brac[j] = tmpbrac.pop()\n\n    # かっこの中身と乗除算\n    while i < len(exp):\n        # かっこの中身は再帰的に計算\n        if exp[i] == '(':\n            num.append(calc(exp[i + 1:brac[i]],brac))\n            i = brac[i]\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        elif exp[i].isnumeric():\n            temp = exp[i] # 数値 2桁以上にも対応させる\n            i += 1\n            while i < len(exp) and exp[i].isnumeric():\n                temp += exp[i]\n                i += 1\n            i -= 1 # 最後の数字に戻る(最後にi+=1しているのでこれでいい)\n            num.append(int(temp))\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        num.appendleft(eva(num.popleft(),num.popleft(),ops.popleft()))\n\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    print(calc(input()))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfor exp in sys.stdin:\n    if exp[-1] == '=':\n        print eval(exp[1:])\n    else:\n        print eval(exp)"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nwhile n:\n    s = raw_input()\n    print eval(s[:-1])\n    n -= 1"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nn = input()\nfor i in xrange(n):\n\tline = raw_input()\n\texec(\"x = %s\" % line[:-1])\n\tprint x"
  },
  {
    "language": "Python",
    "code": "import re\nn = int(input())\nfor i in range(n):\n    eq = input()\n    meq = re.sub(r'([\\d*]+)/(\\d+)',r'(\\1//\\2)', eq)\n    print(eval(meq.replace(\"=\",\"\")))"
  },
  {
    "language": "Python",
    "code": "from __future__ import division\nfor i in range(input()):\n    print int(eval(raw_input()[:-1]))"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\nfor loop in xrange(N):\n    print eval(raw_input()[:-1].replace(\"/\",\"//\"))"
  },
  {
    "language": "Python",
    "code": "for u in xrange(input()):print int(eval(raw_input().strip(\"=\")))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# ???????????????????¨?????????°???????????????????????????????????????????????????\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = int(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n    \n    return St[0]\n\n\n# ??????????????????????????????????????¬??§?????°???????????????????????????????????????\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n# ???????¨?????????°????????????????????????????????????????¨?????????°????????????????????????\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and table[S[-1]] > table[i]:\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef main():\n    N = int(raw_input())\n\n    for i in range(N):\n        s = raw_input()\n        L = String2List(s[:-1])\n        L = RPN_list(L)\n        print RPN_cul(L)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "# ????????±?????¬??§??????????????????[l, r)??§??????\ndef getLR(li):\n    l, r = 0, 0\n    for i in range(len(li)):\n        if li[i] == \"(\":\n            l = i\n        if li[i] == \")\":\n            r = i + 1\n            return l, r\n    return l, r\n\n# li????¨?????????????????????????(li?????¬??§???????????????)\ndef calc(li):\n    # *, / ?????????\n    t_li = []\n    while True:\n        for i in range(len(li) - 2):\n            if li[i + 1] == \"*\":\n                t_li = li[:i] + [li[i] * li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n            elif li[i + 1] == \"/\":\n                t_li = li[:i] + [li[i] // li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n        else:\n            # ??´??°??????????????°????????????????????????\n            break\n\n    # +, - ?????????\n    while True:\n        for i in range(len(li) - 2):\n            if li[i + 1] == \"+\":\n                t_li = li[:i] + [li[i] + li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n            elif li[i + 1] == \"-\":\n                t_li = li[:i] + [li[i] - li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n        else:\n            # ??´??°??????????????°????????????????????????\n            break\n\n    return t_li\n\n\nn = int(input())\nfor _ in range(n):\n    s = input()[:-1]\n\n    # ??°?????¨?¨????????????????????????? (\"#\"?????????)\n    s = \"#(\" + s + \")#\"\n    li = []\n    number = \"\"\n    for i in range(len(s)):\n        if s[i].isdigit():\n            number += s[i]\n        else:\n            if number != \"\":\n                li.append(int(number))\n                number = \"\"\n            li.append(s[i])\n\n    # ??¬??§??????????????±?????¨??????????????????????????????\n    while True:\n        # print(li)\n        l, r = getLR(li)\n\n        # ??¬??§????????????????????°??????\n        if r == 0:\n            break\n\n        li = li[:l] + calc(li[l + 1 : r - 1]) + li[r:]\n\n    print(li[1])"
  },
  {
    "language": "Python",
    "code": "import sys\n#from me.io import dup_file_stdin\n\ndef prec(op):\n    if op in \"+-\":return 1\n    if op in \"*/\":return 2\n    raise NotImplementedError()\n    \ndef postFix(expr):\n    stack = []\n    operators = []\n    num = 0\n    isdigit = False\n    for ch in expr:\n        if ch.isdigit():\n            isdigit = True\n            num*=10\n            num+=int(ch)\n            continue\n        else :\n            if isdigit:\n                stack.append(num)\n                num = 0\n            isdigit = False\n            \n            if ch == ')':\n                while len(operators) > 0:\n                    op = operators.pop()\n                    if op == '(':\n                        break\n                    else:\n                        stack.append(op)\n                else:\n                    raise ValueError\n            elif ch == '(':\n                operators.append(ch)\n            else:\n                while len(operators) > 0 and operators[-1]!='(' and prec(operators[-1]) >= prec(ch):\n                    stack.append(operators.pop())\n                operators.append(ch)\n    if isdigit:\n        stack.append(num)\n    for op in operators[::-1]:\n        if op not in \"()\":\n            stack.append(op)\n    return stack\n        \ndef evaluate(stack):\n    op = stack.pop()\n    if type(op) is int:\n        return op;\n    else:\n        b = evaluate(stack);\n        a = evaluate(stack);\n        return int(eval(str(a)+op+str(b)))\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        expr = sys.stdin.readline()[:-1].strip(\"=\")\n        print(evaluate(postFix(expr)))\n        \nsolve()"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    print int((eval(\"\".join([str(float(i)) if i.isdigit() else i for i in raw_i\\\nnput() if i!=\"=\"]))))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp,brac=None):\n    i = 0 # ループカウンタ?\n    num = deque() # 数字をためておく\n    ops = deque() # +-をためておく\n    ope = \"\" # */を保存\n    \n    if not brac:\n        # 対応する括弧の位置を記録しておいて計算量を削減\n        brac = [-1 for j in range(len(exp))]\n        tmpbrac = []\n        for j in range(len(exp) - 1, 0, -1):\n            if exp[j] == ')':\n                tmpbrac.append(j)\n            elif exp[j] == '(':\n                brac[j] = tmpbrac.pop()\n\n    # かっこの中身と乗除算\n    while i < len(exp):\n        # かっこの中身は再帰的に計算\n        if exp[i] == '(':\n            num.append(calc(exp[i + 1:brac[i]],brac))\n            i = brac[i]\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\" # 数値 2桁以上にも対応させる\n            while i < len(exp) and exp[i].isnumeric():\n                temp += exp[i]\n                i += 1\n            i -= 1 # 最後の数字に戻る(最後にi+=1しているのでこれでいい)\n            num.append(int(temp))\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        num.appendleft(eva(num.popleft(),num.popleft(),ops.popleft()))\n\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport re\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        expr = sys.stdin.readline()[:-1].strip(\"=\")\n        expr = re.sub(r\"\\.\\d+\",\"\",expr)\n        print(eval(expr.replace(\"/\",\"//\")))\n \nsolve()"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            elif item == \"/\":\n                result = num2 / num1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\nfrom functools import reduce\nfrom operator import add\ndef f(): return [int(i) for i in input().split()]\ndef debug(*x, sep=\" \", end=\"\\n\"):\n    for item in x:\n        stderr.write(repr(item))\n        stderr.write(sep)\n    stderr.write(end)\n\n\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    debug(exp)\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            num.append(calc(exp[i+1:i+end]))\n            i += end\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            r = b/a\n            if b < 0 and b % a != 0:\n                r += 1\n            St.append(r)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "def calc(eqt):\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])//calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt):\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1:\n    return calc(eqt)\n  else:\n    ll = l[0].rsplit('(',maxsplit=1)\n    ll.append(l[1])\n    ll[1] = str(calc(ll[1]))\n    l=\"\".join(ll)\n    return unfold_brackets(l)\n\ndatasets=[]\nwhile True:\n  try:\n    datasets.append(input())\n  except EOFError:\n    break\nfor line in datasets:\n  if line[-1] != '=':\n    continue\n  else:\n    l = line.split(\"=\",maxsplit=1)[0]\n    print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor _t in range(n):\n    print eval(raw_input().rstrip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# 写経した\nimport re\nclass Num:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self, value):\n        self.x = value\n    def __add__(self, value):\n        return Num(self.x + value.x)\n    def __sub__(self, value):\n        return Num(self.x - value.x)\n    def __mul__(self, value):\n        return Num(self.x * value.x)\n    def __truediv__(self, value):\n        return Num(self.x // value.x)\n      \nN = int(input())\nfor i in range(N):\n    s = input()[:-1]\n    s = re.sub(r'(\\d+)',r'Num(\\1)',s)\n    print(eval(s))\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    try:\n        for i in range(int(input())):\n            print(str(int(eval(input().replace('=', '')))))\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "while True:\n    line = raw_input()\n    if line == '':\n        break\n\n    for i in range(int(line)):\n        a = eval(raw_input().replace('/', '//')[:-1])\n        print int(a)"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    return abs(x) / abs(y) * s     \n\noperator = {\"+\":(lambda x,y: x+y),\n            \"-\":(lambda x,y: x-y),\n            \"*\":(lambda x,y: x*y),\n            \"/\":divide\n            }\n\ndef ind(src, x):\n    if x not in src:return 1<<30\n    return src.index(x)\n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n    \n    pos = min(ind(src, \"*\"), ind(src,\"/\"))\n    if(pos == 1<<30):\n        pos = min(ind(src, \"+\"), ind(src, \"-\"))\n    op = src[pos]\n    l, r = src[pos - 1], src[pos + 1]\n    mid = operator[op](l, r)\n    return evaluate(src[:pos - 1] + [mid] + src[pos + 2:])\n\n     \nfor t in xrange(input()):\n    _src = raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\nimport re\ninput = stdin.readline\n\n\nclass SmartInt(int):\n    def __truediv__(self, other):\n        sign = 1\n        if self.n < 0:\n            sign = -1\n            self.n *= -1\n        return (self.n // other) * sign\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        # txt = '4*(8+4+3)='\n        txt = input().strip()\n        p = re.sub('(\\d+)', 'SmartInt(\\\\1)', txt)\n        exp = p[:-1]\n        print(eval(exp))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nnum = int(raw_input())\nfor i in range(num):\n\tinput_line = raw_input()\n\teval_line = input_line[0:-1]\n\tresult = eval(eval_line)\n\tprint result"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):print(int(eval(input()[:-1])))"
  },
  {
    "language": "Python",
    "code": "def get_input():\n    while True:\n        try:\n            yield ''.join(input())\n        except EOFError:\n            break\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\nNline = int(input())\nfor ll in range(Nline):\n\n    S = input()\n    p = Generate_RPN(String2List(S[0:-1]))\n    N = len(p)\n\n    s = []\n    for i in range(len(p)):\n        if p[i] == \"+\":\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(str(b+a))\n        elif p[i] == \"-\":\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(str(b-a))\n        elif p[i] == \"*\":\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(str(b*a))\n        elif p[i] == \"/\":\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(str(int(b/a)))\n        else:\n            s.append(p[i])\n    print(s[0])\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom sys import stdin, exit\n\n\ndef main(readline=stdin.readline):\n    n = int(readline())\n    for _ in range(n):\n        print(eval(readline().replace('/', '//').replace('=', '')))\n    exit()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "for i in xrange(input()):\n\tprint int(eval(raw_input().strip().strip('=').replace('/','.0/')))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\npriority = {\"*\":1,\"/\":1, \"+\":0, \"-\":0, \"(\":-1, \")\":-1}\n\nn = int(input())\nfor i in range(n):\n    s = input()\n    out = []\n    ope = deque([])\n    for j in range(len(s)):\n        inp = s[j]\n        if inp == \"=\":\n            while len(ope):\n                out.append(ope.pop())\n            break\n        elif inp.isdecimal():\n            if len(out) and s[j - 1].isdecimal():\n                tmp = out.pop()\n                out.append(tmp*10 + int(inp))\n            else:\n                out.append(int(inp))\n        elif inp == \"(\":\n            ope.append(inp)\n        elif inp == \")\":\n            while True:\n                tmp = ope.pop()\n                if tmp == \"(\":\n                    break\n                out.append(tmp)\n        elif priority[inp] == 1:\n            while len(ope) and priority[ope[-1]] >= 1:\n                tmp = ope.pop()\n                out.append(tmp)\n            else:\n                ope.append(inp)\n        elif priority[inp] == 0:\n            while len(ope) and priority[ope[-1]] >= 0:\n                tmp = ope.pop()\n                out.append(tmp)\n            else:\n                ope.append(inp)\n    ans = deque([])\n    for k in range(len(out)):\n        if out[k] == \"+\":\n            a = ans.pop()\n            ans[-1] += a\n        elif out[k] == \"-\":\n            a = ans.pop()\n            ans[-1] -= a\n        elif out[k] == \"*\":\n            a = ans.pop()\n            ans[-1] *= a\n        elif out[k] == \"/\":\n            a = ans.pop()\n            b = ans.pop()\n            ans.append(int(b/a))\n        else:\n            ans.append(out[k])\n    print(ans[0])\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor T in range(n):\n    s=input()[0:-1]\n    s=s.replace('/','//')\n    print(eval(s))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor i in range(n):\n    s = input()\n    print(eval(s[:-1:]))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor _ in range(n):\n    print(int(eval(input()[:-1])))"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor i in range(n):\n    print eval(raw_input().replace(\"/\",\"//\")[:-1])"
  },
  {
    "language": "Python",
    "code": "pos = 0\ndef number(s):\n\tglobal pos\n\tx = pos\n\tif s[pos] == '-' or s[pos] == '+':\n\t\tpos += 1\n\twhile s[pos].isdigit():\n\t\tpos += 1\n\treturn int(s[x:pos])\nexpression = None\ndef factor(s):\n\tglobal pos\n\tif s[pos] == '(':\n\t\tpos += 1\n\t\tresult = expression(s)\n\t\tpos += 1\n\t\treturn result\n\telse:\n\t\treturn number(s)\ndef term(s):\n\tglobal pos\n\tresult = factor(s)\n\twhile True:\n\t\tif s[pos] == '*':\n\t\t\tpos += 1\n\t\t\tresult *= factor(s)\n\t\telif s[pos] == '/':\n\t\t\tpos += 1\n\t\t\tx = factor(s)\n\t\t\tresult = int(abs(result) / abs(x)) * cmp(x, 0) * cmp(result, 0)\n\t\telse:\n\t\t\tbreak\n\treturn result\ndef _expression(s):\n\tglobal pos\n\tresult = term(s)\n\twhile True:\n\t\tif s[pos] == '+':\n\t\t\tpos += 1\n\t\t\tresult += term(s)\n\t\telif s[pos] == '-':\n\t\t\tpos += 1\n\t\t\tresult -= term(s)\n\t\telse:\n\t\t\tbreak\n\treturn result\nexpression = _expression\n\nfor i in xrange(input()):\n\tpos = 0\n\tprint expression(raw_input())"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef factor(t, i):\n    if t[i[0]] == '(':\n        i[0] += 1\n        r = expr(t, i)\n        i[0] += 1\n        return r\n    else:\n        i[0] += 1\n        return int(t[i[0]-1])\n\ndef term(t, i):\n    r = factor(t, i)\n    while True:\n        if t[i[0]] == '*':\n            i[0] += 1\n            r *= factor(t, i)\n        elif t[i[0]] == '/':\n            i[0] += 1\n            r /= factor(t, i)\n        else:\n            break\n    return r\n\ndef expr(t, i):\n    r = term(t, i)\n    while True:\n        if t[i[0]] == '+':\n            i[0] += 1\n            r += term(t, i)\n        elif t[i[0]] == '-':\n            i[0] += 1\n            r -= term(t, i)\n        else:\n            break\n    return r\n\nn = int(raw_input())\nfor _ in range(n):\n    t = re.sub(r'([\\+\\-\\*\\/\\(\\)=])', r' \\1 ', raw_input()).split()\n    print expr(t, [0])"
  },
  {
    "language": "Python",
    "code": "import math;\nfor i in range(int(raw_input())):\n\tprint int(math.floor(eval(raw_input()[:-1])));"
  },
  {
    "language": "Python",
    "code": "def f(s):\n  while 1:\n    b=s.find(\")\")\n    if b<0: return g(s)\n    a=s[:b].rfind(\"(\")\n    s1=s[a:b+1]\n    s=s.replace(s1,f(s1[1:-1]))\n\ndef g(s):\n  a=\"\"\n  f=1\n  x=[]\n  def F(a,b):\n    x.append(a)\n    x.append(b)\n    return 1,\"\"\n  for c in s:\n    if c==\"=\": continue\n    elif c in \"*/\": f,a=F(a,c)\n    elif c in \"+-\":\n      if f==1: f,a=0,c\n      else: f,a=F(a,c)\n    else: f,a=0,a+c\n  x.append(a)\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e in \"+-\": x.append(e)\n    elif e in \"*/\": f=e\n    else:\n      a=int(e)\n      if f==\"*\": a*=x.pop()\n      elif f==\"/\": a=x.pop()/a\n      x.append(a)\n      f==\"\"\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e==\"+\" or e==\"-\": f=e\n    else:\n      a=int(e)\n      if f==\"+\": a+=x.pop()\n      elif f==\"-\": a=x.pop()-a\n      x.append(a)\n      f==\"\"\n  return str(x[0])\n\nn=input()\nfor _ in [0]*n: \n  s=raw_input()\n  print f(s)"
  },
  {
    "language": "Python",
    "code": "def RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = int(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n    \n    return St[0]\n\n\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and table[S[-1]] >= table[i]:\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef main():\n    N = int(raw_input())\n\n    for i in range(N):\n        s = raw_input()\n        L = String2List(s[:-1])\n        L = RPN_list(L)\n        print RPN_cul(L)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "pos = 0\ndef number(s):\n\tglobal pos\n\tx = pos\n\tif s[pos] == '-' or s[pos] == '+':\n\t\tpos += 1\n\twhile s[pos].isdigit():\n\t\tpos += 1\n\treturn int(s[x:pos])\nexpression = None\ndef factor(s):\n\tglobal pos\n\tif s[pos] == '(':\n\t\tpos += 1\n\t\tresult = expression(s)\n\t\tpos += 1\n\t\treturn result\n\telse:\n\t\treturn number(s)\ndef term(s):\n\tglobal pos\n\tresult = factor(s)\n\twhile True:\n\t\tif s[pos] == '*':\n\t\t\tpos += 1\n\t\t\tresult *= factor(s)\n\t\telif s[pos] == '/':\n\t\t\tpos += 1\n\t\t\tresult = int(result / factor(s))\n\t\telse:\n\t\t\tbreak\n\treturn result\ndef _expression(s):\n\tglobal pos\n\tresult = term(s)\n\twhile True:\n\t\tif s[pos] == '+':\n\t\t\tpos += 1\n\t\t\tresult += term(s)\n\t\telif s[pos] == '-':\n\t\t\tpos += 1\n\t\t\tresult -= term(s)\n\t\telse:\n\t\t\tbreak\n\treturn result\nexpression = _expression\n\nfor i in xrange(input()):\n\tpos = 0\n\tprint expression(raw_input())"
  },
  {
    "language": "Python",
    "code": "def f1(line):\n    p = None\n    q = None\n    for i, s in enumerate(line):\n        if s == '(':\n            p = i\n        elif s == ')':\n            q = i\n        if q:\n            break\n    else:\n        return f2(line)\n    before = line[:p]\n    after = line[q + 1:]\n    x = f2(line[p + 1:q])\n    return f1(before + str(x) + after)\n\n\ndef f2(f_line):\n    foo = []\n    digit = ''\n    for x in f_line:\n        if x.isdigit():\n            digit += x\n        else:\n            foo.append(int(digit))\n            foo.append(x)\n            digit = ''\n    foo.append(int(digit))\n    return f3(foo, 'first')\n\n\ndef f3(foo, flg):\n    if len(foo) == 1:\n        return foo[0]\n    target = None\n    for i, fo in enumerate(foo):\n        if flg == 'first':\n            target = f4(foo, fo, i)\n        elif flg == 'second':\n            target = f5(foo, fo, i)\n        if target:\n            break\n    else:\n        flg = 'second'\n        return f3(foo, flg)\n    foo = foo[:i-1] + [target] + foo[i+2:]\n    return f3(foo, flg)\n\n\ndef f4(foo, fo, i):\n    target = None\n    if fo == '*':\n        target = foo[i-1] * foo[i+1]\n    elif fo == '/':\n        target = int(foo[i-1] / foo[i+1])\n    return target\n\n\ndef f5(foo, fo, i):\n    target = None\n    if fo == '+':\n        target = foo[i-1] + foo[i+1]\n    elif fo == '-':\n        target = int(foo[i-1] - foo[i+1])\n    return target\n\n\nfor _ in range(int(input())):\n    ans = f1(input())\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom sys import stdin, exit\nfrom operator import add, sub, mul, truediv\n\n\ndef div(a, b):\n    return int(truediv(a, b))\n\n\nclass Parser(list):\n    \"\"\"\n    <statement> ::= <expression> \"=\"\n    <expression> ::= <term> [ (\"+\"|\"-\") <term> ]\n    <term> ::= <factor> [ (\"*\"|\"/\") <factor> ]\n    <factor> ::= <number> | \"(\" <expression> \")\"\n    \"\"\"\n\n    def __init__(self, tokens):\n        self._iter_tokens = iter(tokens)\n\n        self._next_symbol()\n        while self.symbol != '=':\n            self._expression()\n\n    def _expression(self, fn_table={'+': add, '-': sub}):\n        if self.symbol in fn_table:\n            op_sign = self.symbol\n            self._next_symbol()\n            self._term()\n            self.append(fn_table[op_sign])\n        else:\n            self._term()\n\n        while self.symbol in fn_table:\n            op_sign = self.symbol\n            self._next_symbol()\n            self._term()\n            self.append(fn_table[op_sign])\n\n    def _term(self, fn_table={'*': mul, '/': div}):\n        self._factor()\n        while self.symbol in fn_table:\n            op_sign = self.symbol\n            self._next_symbol()\n            self._factor()\n            self.append(fn_table[op_sign])\n\n    def _factor(self):\n        if self.symbol.isdigit():\n            self.append(int(self.symbol))\n            self._next_symbol()\n        elif self.symbol == '(':\n            self._next_symbol()\n            self._expression()\n            if self.symbol != ')':\n                raise SyntaxError(self.symbol)\n            self._next_symbol()\n        else:\n            raise SyntaxError(self.symbol)\n\n    def _next_symbol(self):\n        self.symbol = next(self._iter_tokens)\n\n\ndef tokenize(line):\n    buf = []\n    tokens = []\n\n    for c in line:\n        if c.isdigit():\n            buf.append(c)\n        else:\n            if buf:\n                tokens.append(''.join(buf))\n                del buf[:]\n            tokens.append(c)\n            if c == '=':\n                return tokens\n\n\ndef run(commands):\n    stack = []\n\n    for cmd in commands:\n        if isinstance(cmd, int):\n            stack.append(cmd)\n        else:\n            buf = stack.pop()\n            stack[-1] = cmd(stack[-1], buf)\n    return stack[-1]\n\n\ndef main(readline=stdin.readline):\n    for _ in range(int(readline())):\n        print(run(Parser(tokenize(readline()))))\n    exit()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint(input().strip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif s=='':\n\t\treturn 0\n\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\t\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\t\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\ts=raw_input()[:-1]\n\t\tprint calc(s) #, eval(s)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(str(answer))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor _ in range(n):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"/\", divide),\n                 (\"*\", lambda x,y:x * y)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = len(src) - 1 - src[::-1].index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "def digit():\n    global S\n    global cur\n    if S[cur].isdigit():\n        n = int(S[cur])\n        cur += 1\n        return n\ndef number():\n    global S\n    L = len(S)\n    global cur\n    n = digit()\n    while (cur < L and S[cur].isdigit()):\n        n = n*10 + digit()\n    return n\ndef expression():\n    global S\n    global cur\n    L = len(S)\n    a = term()\n    while (cur < L and (S[cur] == '+' or S[cur] == '-')):\n        op = S[cur]\n        cur += 1\n        b = term()\n        if op == '+':\n            a += b\n        else:\n            a -= b\n    return a\nimport math\ndef term():\n    global S\n    global cur\n    L = len(S)\n    a = factor()\n    while (cur < L and (S[cur] == '*' or S[cur] == '/')):\n        op = S[cur]\n        cur += 1\n        b = factor()\n        if op == '*':\n            a *= b\n        else:\n            a = math.trunc(a/b)\n    return a\ndef factor():\n    global S\n    global cur\n    if (S[cur] != '('):\n        return number()\n    else:\n        cur += 1\n        n = expression()\n        if S[cur] == ')':\n            cur += 1\n            return n\n\nN = int(input().strip())\nfor _ in range(N):\n    S = str(input().strip())\n    S = S[:-1]\n    cur = 0\n    ans = expression()\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(eqt): # assuming that eqt has no brackets.\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2: # if eqt has \"+\", then\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"-\", then\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"*\", then\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"/\", then\n    return (calc(l[0])//calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt): # for example, eqt == \"((3+5)*8+2)*2\"\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1: # if eqt has no brackets, then\n    return calc(eqt)\n  else:\n    # for example, l == [\"((3+5\", \"*8+2)*2\"]\n    ll = l[0].rsplit('(',maxsplit=1)\n    # ll == [\"(\",\"3+5\"]\n    ll.append(l[1])\n    # ll == [\"(\",\"3+5\",\"*8+2)*2\"]\n    ll[1] = str(calc(ll[1]))\n    # ll == [\"(\",8,\"*8+2)*2\"]\n    l=\"\".join(ll)\n    # ll == \"(8*8+2)*2\"\n    return unfold_brackets(l)\n\nwhile True:\n  try:\n    n=int(input())\n    datasets=[input() for i in range(0,n)]\n    for line in datasets:\n      l = line.split(\"=\",maxsplit=1)[0]\n      print(unfold_brackets(l))\n  except EOFError:\n    break"
  },
  {
    "language": "Python",
    "code": "import sys\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        print(eval(sys.stdin.readline()[:-2].replace(r\"/\",r\"//\")))\n \nsolve()"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print int(fx(formula))\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "def getLR(li):\n    l, r = 0, 0\n    for i in range(len(li)):\n        if li[i] == \"(\":\n            l = i\n        if li[i] == \")\":\n            r = i + 1\n            return l, r\n    return l, r\n\ndef calc(li):\n    # *, /\n    t_li = []\n    while True:\n        for i in range(len(li) - 2):\n            if li[i + 1] == \"*\":\n                t_li = li[:i] + [li[i] * li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n            elif li[i + 1] == \"/\":\n                t_li = li[:i] + [li[i] // li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n        else:\n            # no update\n            break\n\n    # +, -\n    while True:\n        for i in range(len(li) - 2):\n            if li[i + 1] == \"+\":\n                t_li = li[:i] + [li[i] + li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n            elif li[i + 1] == \"-\":\n                t_li = li[:i] + [li[i] - li[i + 2]] + li[i + 3:]\n                li = list(t_li)\n                break\n        else:\n            break\n\n    return t_li\n\n\nn = int(input())\nfor _ in range(n):\n    s = input()[:-1]\n\n    s = \"#(\" + s + \")#\"\n    li = []\n    number = \"\"\n    for i in range(len(s)):\n        if s[i].isdigit():\n            number += s[i]\n        else:\n            if number != \"\":\n                li.append(int(number))\n                number = \"\"\n            li.append(s[i])\n\n    while True:\n        l, r = getLR(li)\n\n        if r == 0:\n            break\n\n        li = li[:l] + calc(li[l + 1 : r - 1]) + li[r:]\n\n    print(li[1])"
  },
  {
    "language": "Python",
    "code": "for unused in xrange(input()):print eval(raw_input().strip(\"=\"))+0"
  },
  {
    "language": "Python",
    "code": "def calc(eqt):\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])/calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt):\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1:\n    return calc(eqt)\n  else:\n    ll = l[0].rsplit('(',maxsplit=1)\n    ll.append(l[1])\n    ll[1] = str(calc(ll[1]))\n    l=\"\".join(ll)\n    return unfold_brackets(l)\n\nn=int(input())\ndatasets=[input() for i in range(n)]\nfor line in datasets:\n  l = line.split(\"=\",maxsplit=1)[0]\n  print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "for i in range(int(raw_input())):\n\tprint int(eval(raw_input()[:-1]));"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):\n    print(int(eval(input()[:-1].replace('/', '//'))))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(input())\nwhile n != 0:\n\ts = input()\n\tprint(eval(s[0:len(s)-1]));\n\tn -= 1\n\tsys.stdout.flush()"
  },
  {
    "language": "Python",
    "code": "\nimport re\nn = int(input())\nfor i in range(n):\n    s = raw_input().split('=')\n    print(s)\n    print(eval(s[0]))"
  },
  {
    "language": "Python",
    "code": "# AOJ 0109 Smart Calculator\n# Python3 2018.6.18 bal4u\n\nINF = 1000000010\nLEFT  = INF+1\nRIGHT = INF+2\nPLUS  = INF+3\nMINUS = INF+4\nMUL   = INF+5\nDIV   = INF+6\ntoken = { '+':PLUS, '-':MINUS, '*':MUL, '/':DIV }\nrank = { PLUS:2, MINUS:2, MUL:3, DIV:3, LEFT:1, RIGHT:1 }\n\nS, top = [0]*200, 0\nQ, end = [0]*200, 0\n\ndef getInt():\n\tglobal id\n\tglobal buf\n\tk = ''\n\twhile buf[id] >= '0' and buf[id] <= '9':\n\t\tk += buf[id]\n\t\tid += 1\n\treturn int(k)\n\nn = int(input())\nfor i in range(n):\n\tbuf = list(input())\n\tid, f, top, end = 0, True, 0, 0\n\twhile True:\n\t\tif buf[id] == '=':\n\t\t\twhile top > 0:\n\t\t\t\ttop -= 1\n\t\t\t\tQ[end] = S[top]\n\t\t\t\tend += 1\n\t\t\tbreak;\n\t\tif buf[id] == '-' and f and buf[id+1] >= '0' and buf[id+1] <= '9':\n\t\t\tid += 1\n\t\t\tQ[end] = -getInt()\n\t\t\tend += 1\n\t\t\tf = False\n\t\t\tcontinue\n\t\t\n\t\tf = False\n\t\tif buf[id] >= '0' and buf[id] <= '9':\n\t\t\tQ[end] = getInt()\n\t\t\tend += 1\n\t\telif buf[id] == ')':\n\t\t\twhile S[top - 1] != LEFT:\n\t\t\t\ttop -= 1\n\t\t\t\tQ[end] = S[top]\n\t\t\t\tend += 1\n\t\t\ttop -= 1\n\t\t\tid += 1\n\t\telif buf[id] == '(':\n\t\t\tS[top] = LEFT\n\t\t\ttop += 1\n\t\t\tid += 1\n\t\t\tf = True\n\t\telse:\n\t\t\tk = token[buf[id]]\n\t\t\tid += 1\n\t\t\twhile top > 0:\n\t\t\t\tif rank[k] <= rank[S[top-1]]:\n\t\t\t\t\ttop -= 1\n\t\t\t\t\tQ[end] = S[top];\n\t\t\t\t\tend += 1\n\t\t\t\telse: break\n\t\t\tS[top] = k;\n\t\t\ttop += 1\n\ttop = 0\n\tfor i in range(end):\n\t\tk = Q[i]\n\t\tif k > INF:\n\t\t\td1, d2 = S[top-1], S[top-2]\n\t\t\ttop -= 2\n\t\t\tif k == PLUS: d2 += d1\n\t\t\telif k == MINUS: d2 -= d1\n\t\t\telif k == MUL: d2 *= d1\n\t\t\telse:\n\t\t\t\td2 //= d1\n\t\t\t\tif d2 < 0: d2 += 1\t## -5 // 2 = -3 (Pythonでは)\n\t\t\tS[top] = d2\n\t\telse: S[top] = k\n\t\ttop += 1\n\tprint(S[top-1])\n"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n        \n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=\\\\n')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1\n\n            stack.append(result)\n        print(stack)\n        print(item)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nn = int(input())\n\nfor i in range(n):\n    command = input().strip()\n    command = command.replace('=', '')\n    command = command.replace('/', '//')\n    #print(command)\n    print(int(eval(command)))"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor _t in range(n):\n    print int(eval(\"float(\"+raw_input().rstrip(\"=\")+\")\") + 1e-16)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nn = int(input())\n\nfor i in range(n):\n    command = input().strip()\n    command = command.replace('=', '')\n    command = command.replace('/', '//')\n    print(eval(command))"
  },
  {
    "language": "Python",
    "code": "for u in xrange(input()):print eval(raw_input().strip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "from inspect import currentframe\nfrom sys import exit, stderr\n\ntokens = []\ncur = 0\ndef debug(*args):\n    names = {id(v):k for k,v in currentframe().f_back.f_locals.items()}\n    print(', '.join(names.get(id(arg),'???') + str(id(arg)) +' = '+repr(arg) for arg in args), file=stderr)\ndef parse_expr():\n    global cur\n    if tokens[cur] == \"=\":\n        return\n    lhs = parse_mul()\n    while(tokens[cur] == \"+\" or tokens[cur] == \"-\"):\n        if tokens[cur] == \"+\":\n            cur += 1\n            lhs += parse_mul()\n        elif tokens[cur] == \"-\":\n            cur += 1\n            lhs -= parse_mul()\n        # debug(lhs, cur)\n    return lhs\n\ndef parse_mul():\n    global cur\n    lhs = parse_term()\n    while(tokens[cur] == \"*\" or tokens[cur] == \"/\"):\n        if tokens[cur] == \"*\":\n            cur += 1\n            lhs *= parse_term()\n        elif tokens[cur] == \"/\":\n            cur += 1\n            divisor = parse_term()\n            if lhs < 0 and lhs % divisor != 0:\n                lhs //= divisor\n                lhs += 1\n            else:\n                lhs //= divisor\n    return lhs\n\ndef parse_term():\n    global cur\n    if tokens[cur].isdigit():\n        lhs = int(tokens[cur])\n        cur += 1\n        while(tokens[cur].isdigit()):\n            lhs *= 10\n            lhs += int(tokens[cur])\n            cur += 1\n    elif tokens[cur] == \"(\":\n        cur += 1\n        lhs = parse_expr()\n        if tokens[cur] != \")\":\n            raise Exception(\"not closed\")\n        cur += 1\n    return lhs\n\nN = int(input())\nfor _ in range(N):\n    src = list(str(input()))\n    tokens = [tok for tok in src if tok != \" \"]\n    cur = 0\n\n    print(parse_expr())\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(eqt):\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])//calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt):\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1:\n    return calc(eqt)\n  else:\n    ll = l[0].rsplit('(',maxsplit=1)\n    ll.append(l[1])\n    ll[1] = str(calc(ll[1]))\n    l=\"\".join(ll)\n    return unfold_brackets(l)\n\nn=int(input())\ndatasets=[input() for i in range(n)]\nfor line in datasets:\n  l = line.split(\"=\",maxsplit=1)[0]\n  print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            num.append(calc(exp[i+1:i+end]))\n            i += end\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n# N = int(input())\n# for i in range(N):\n#     print(int(eval(input().replace(\"/\", \"//\").strip(\"=\"))))\n\n"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint int(eval(raw_input().strip('=')))"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\nfor loop in xrange(N):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "for _ in range( int(raw_input()) ): print int(eval( \"1.0\"+raw_input()[:-1] ))"
  },
  {
    "language": "Python",
    "code": "# Edit: 2014/09/26\n# Lang: Python3\n# Time: 0.xxs\n#\n\nif __name__ == \"__main__\":\n    n = int(input())\n    for i in range(n):\n        print(eval(input().strip(\"=\").replace(\"/\", \"//\")))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor _ in range(n):\n    s=input()\n    s=s.replace(\"/\",\"//\")\n    s=s[:-1:]\n    print(eval(s))\n\n"
  },
  {
    "language": "Python",
    "code": "anb2 = lambda a,b: -(abs(int(1.0*a/b)))\n\ndef number(begin):\n\tglobal i\n\t\n\tif begin[i] == \"(\":\n\t\ti += 1\n\t\tres = expression(begin)\n\t\ti += 1 \n\t\treturn res\n\t\n\tres = 0\n\t\n\twhile begin[i].isdigit():\n\t\tres *= 10\n\t\tres += int(begin[i])\n\t\ti+=1\n\t\n\treturn res\n\t\ndef term(begin):# your code goes here\n\n\tglobal i\n\tres = number(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"*\":\n\t\t\ti += 1\n\t\t\tres *= number(begin)\n\t\telif begin[i] == \"/\":\n\t\t\ti += 1\n\t\t\tnum = number(begin)\n\t\t\tif res < 0 or num < 0:\n\t\t\t\tres = abs2(res,num)\n\t\t\telse:\n\t\t\t\tres /= num\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\ndef expression(begin):\n\t\n\tglobal i\n\tres = term(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"+\":\n\t\t\ti += 1\n\t\t\tres += term(begin)\n\t\t\t\n\t\telif begin[i] == \"-\":\n\t\t\ti += 1\n\t\t\tres -= term(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\n\ndef main():\n\tglobal i\n\tfor j in range(input()):\n\t\t\ti = 0\n\t\t\tex = raw_input() +\"=\"\n\t\t\tans = expression(ex)\n\t\n\t\t\tprint ans\nmain()"
  },
  {
    "language": "Python",
    "code": "ops = {\"+\": lambda a, b: b + a,\n       \"-\": lambda a, b: b - a,\n       \"*\": lambda a, b: b * a,\n       \"/\": lambda a, b: b / a,\n       \"@\": lambda a, b: -(abs(int(1.0*a/b)))}\n\ndef calc(temp, v):\n    if v in [\"+\", \"-\", \"*\"]:\n        temp.append(ops[v](temp.pop(), temp.pop()))\n    elif v == \"/\":\n        if temp[-1] < 0 or temp[-2] < 0: temp.append(ops[\"@\"](temp.pop(), temp.pop()))\n        else: temp.append(ops[v](temp.pop(), temp.pop()))\n    else:\n        temp.append(int(v))\n    return temp\n\nn = input()\nfor i in range(n):\n    porand = []\n    temp = []\n    formula = raw_input()\n    for j in formula:\n        if j >= \"0\" and j <= \"9\": porand.append(j)\n        elif (j == \"*\" or j == \"/\") or j == \"(\": temp.append(j)\n        elif j == \"+\" or j == \"-\":\n            if len(temp) > 0:\n                for k in reversed(temp):\n                    if k == \"*\" or k == \"/\": porand.append(temp.pop())\n                    else: break\n            temp.append(j)\n        elif j == \")\":\n            for k in reversed(temp):\n                if k == \"(\":\n                    temp.pop()\n                    break\n                porand.append(temp.pop())\n        elif j == \"=\":\n            for k in reversed(temp): porand.append(k)\n    print reduce(calc, porand, [])[-1]"
  },
  {
    "language": "Python",
    "code": "\ndef solve(s):\n\n    def expr(l):\n        left, mid = term(l)\n        return edum(mid, left)\n    \n    def edum(l, lval):\n        if s[l] == '+':\n            val, mid = term(l + 1)\n            return edum(mid, lval + val)\n        if s[l] == '-':\n            val, mid = term(l + 1)\n            return edum(mid, lval - val)\n        else:\n            return lval, l\n    \n    def term(l):\n        left, mid = value(l)\n        return tdum(mid, left)\n\n    def tdum(l, lval):\n        if s[l] == '*':\n            l += 1\n            val1, mid = value(l)\n            return tdum(mid, lval * val1)\n        if s[l] == '/':\n            l += 1\n            val1, mid = value(l)\n            return tdum(mid, (abs(lval) // abs(val1)) * (-1 if (lval < 0) ^ (val1 < 0) else 1))\n        else:\n            return lval, l\n\n    def value(l):\n        if s[l] == '(':\n            val1, mid = expr(l + 1)\n            return val1, mid + 1\n        else:\n            val = 0\n            fl =  s[l] == '-'\n            if fl:\n                l += 1\n            while s[l].isdecimal():\n                val *= 10\n                val += int(s[l])\n                l += 1\n            if fl:\n                val *= -1\n            return val, l\n\n    res = expr(0)[0]\n    \"\"\"\n    gnd = eval(''.join(s[:-1]).replace('/', '//'))\n    while res != gnd:\n        pass\n    \"\"\"\n    print(res)\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        solve(list(input()))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    e = raw_input()\n    print eval(e[:len(e)-1])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n\"\"\"\nimport sys\nimport re\n\n\ndef solve(exp):\n    exp = exp.replace('=', '')\n    exp = exp.replace('/', '//')\n    return eval(exp)\n\n\ndef solve2(exp):\n    exp = exp.replace('=', '')\n    p = re.compile('(-*\\d)/(\\d)')\n    return eval((p.sub(r'int(\\1/\\2)', exp)))\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        expression = input().strip()\n        result = solve2(expression)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\t\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\tprint int(calc(raw_input()[:-1]))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nimport math\n\n\nclass Scanner:\n    def __init__(self, str):\n        str = str.rstrip('=')\n        str = '(' + str + ')'\n        self.tokens = self.tokenize(str)\n\n    def tokenize(self, str):\n        x = list(str)\n        t = []\n        while True:\n            if not x:\n                break\n            c = x.pop(0)\n            if c == '(':\n                t.append(c)\n            elif c == ')':\n                t.append(c)\n            elif c == '+':\n                t.append(c)\n            elif c == '-':\n                t.append(c)\n            elif c == '*':\n                t.append(c)\n            elif c == '/':\n                t.append(c)\n            else:\n                while True:\n                    if len(x) > 0 and x[0].isdigit():\n                        c = c + x.pop(0)\n                    else:\n                        break\n                t.append(c)\n        return t\n\n    def next(self):\n        if self.tokens:\n            return self.tokens.pop(0)\n        else:\n            return None\n\n\n\nclass Calculator:\n    def __init__(self, scanner):\n        self.scanner = scanner\n        self.stack = []\n\n    def calc(self):\n        while True:\n            t = self.scanner.next()\n            if t:\n                if t == ')':\n                    e = [t]\n                    while True:\n                        t2 = self.stack.pop()\n                        if t2 == '(':\n                            e.insert(0, t2)\n                            e = ''.join(e)\n                            r = eval(e)\n                            self.stack.append(str(r))\n                            break\n                        elif t2 == '/':\n                            t3 = e.pop(0)\n                            t4 = self.stack.pop()\n                            e = ['div(', t4, ',', t3, ')'] + e\n                        else:\n                            e.insert(0, t2)\n                else:\n                    self.stack.append(t)\n            else:\n                return self.stack.pop()\n\n\n\ndef div(a, b):\n    a = float(a)\n    b = float(b)\n    c = a / b\n    if c < 0.0:\n        return int(math.ceil(c))\n    else:\n        return int(math.floor(c))\n\n\ndef solv(expr):\n    scanner = Scanner(expr)\n    calculator = Calculator(scanner)\n    return calculator.calc()\n\n\nwhile True:\n    try:\n        n = int(sys.stdin.readline())\n        for i in range(n):\n            expr = sys.stdin.readline().rstrip('\\n')\n            print solv(expr)\n    except:\n        exit()"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint int(eval(raw_input().strip(\"=\")))"
  },
  {
    "language": "Python",
    "code": "for _ in range( int(raw_input()) ): print int(eval( \"1.0+\"+raw_input()[:-1] ))"
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0109: Smart Calculator\n\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\nN = int(input())\nfor _ in range(N):\n    print(eval(input().replace('=', '').replace('/', '//')))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport re\n\nclass Num:\n    def __str__(self):\n        return str(self.x)\n\n    def __init__(self, value):\n        self.x = value\n\n    def __add__(self,value):\n        return Num(self.x + value.x)\n\n    def __sub__(self, value):\n        return Num(self.x - value.x)\n\n    def __mul__(self, value):\n        return Num(self.x * value.x)\n\n    def __truediv__(self,value):\n        return Num(math.ceil(self.x / value.x))\n\nn = int(input())\n\nfor i in range(n):\n    command = input().strip()\n    command = command.replace('=', '')\n    command = re.sub(r'(\\d+)', r'Num(\\1)', command)\n    print(eval(command))\n\n# Supplement\n# -1 // 2 => -1"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "[print(eval(input().replace(\"/\",\"//\")[:-1])) for _ in range(int(input()))]\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    line = raw_input()\n    if line == '':\n        break\n\n    for i in range(int(line)):\n        a = eval(raw_input().replace('/', '//')[:-1])\n        print(str(a))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n\"\"\"\nimport sys\nimport re\n\n\ndef solve(exp):\n    exp = exp.replace('=', '')\n    exp = exp.replace('/', '//')\n    return eval(exp)\n\n\ndef solve2(exp):\n    exp = exp.replace('=', '')\n    p = re.compile('(\\d)/(\\d)')\n    return eval((p.sub(r'int(\\1/\\2)', exp)))\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        expression = input().strip()\n        result = solve2(expression)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\ns=\"\"\nfor i in range(n):\n    s=input()\n    print(eval(s[0:-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    inputCountent = string[:-1]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            elif item == \"/\":\n                result = num2 / num1\n\n            stack.append(result)\n\n    return stack[0]\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    result = Calculate(rpn)\n\n    print(result)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput()\nfor i in sys.stdin.readlines():\n        print(eval(i[:-2].replace('/', '//')))"
  },
  {
    "language": "Python",
    "code": "s = \"\"; l = 0;\ndef expr(idx):\n    ret, idx = term(idx)\n    while idx<l:\n        if s[idx]=='+':\n            r, idx = term(idx+1)\n            ret += r\n        elif s[idx]=='-':\n            r, idx = term(idx+1)\n            ret -= r\n        else:\n            break\n    return ret, idx\n    \ndef term(idx):\n    ret, idx = fact(idx)\n    while idx<l:\n        if s[idx]=='*':\n            r, idx = fact(idx+1)\n            ret *= r\n        elif s[idx]=='/':\n            r, idx = fact(idx+1)\n            ret = abs(ret) / abs(r) * (-1 if ret*r<0 else 1)\n        else:\n            break\n    return ret, idx\n\ndef fact(idx):\n    ret = 0\n    if s[idx]=='(':\n        ret, idx = expr(idx+1)\n        idx += 1\n    else:\n        ret, idx = num(idx)\n    return ret, idx\n\ndef num(idx):\n    ret = 0\n    while idx<l and s[idx].isdigit():\n        ret = 10*ret + int(s[idx])\n        idx+=1\n    return ret, idx\n\nfor i in xrange(input()):\n    s = raw_input(); l = len(s);\n    print expr(0)[0]"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit()\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = len(src) - 1 - src[::-1].index(\")\")\n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = raw_input()[:-1]\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "t = input()\nfor i in range(t):\n    line = raw_input()\n    print eval(line[:-1])"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    print(\"calculate\",exp)\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        print(num, ope, exp[i])\n        if exp[i] == '(':\n            end = exp[i + 1:].index(\")\")\n            num.append(calc(exp[i + 1:i + 1 + end]))\n            i += end\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        if exp[i].isnumeric():\n            num.append(int(exp[i]))\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            break\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    print(f'function end, return {num[0]}')\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n# N = int(input())\n# for i in range(N):\n#     print(int(eval(input().replace(\"/\", \"//\").strip(\"=\"))))\n\n"
  },
  {
    "language": "Python",
    "code": "ops = {\"+\": lambda a, b: b + a,\n       \"-\": lambda a, b: b - a,\n       \"*\": lambda a, b: b * a,\n       \"/\": lambda a, b: b / a}\n\ndef calc(temp, v):\n    if v in ops:\n        temp.append(ops[v](temp.pop(), temp.pop()))\n    else:\n        temp.append(int(v))\n    return temp\n\nn = input()\nfor i in range(n):\n    porand = []\n    temp = []\n    formula = raw_input()\n    for j in formula:\n        if j >= \"0\" and j <= \"9\": porand.append(j)\n        elif (j == \"*\" or j == \"/\") or j == \"(\": temp.append(j)\n        elif j == \"+\" or j == \"-\":\n            if len(temp) > 0:\n                for k in reversed(temp):\n                    if k == \"*\" or k == \"/\": porand.append(temp.pop())\n                    else: break\n            temp.append(j)\n        elif j == \")\":\n            for k in reversed(temp):\n                if k == \"(\":\n                    temp.pop()\n                    break\n                porand.append(temp.pop())\n        elif j == \"=\":\n            for k in reversed(temp): porand.append(k)\n    print reduce(calc, porand, [])[-1]"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):print(eval(input()[:-1]))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    line = raw_input()\n    if line == '':\n        break\n\n    for i in range(int(line)):\n        a = eval(raw_input().replace('/', '//')[:-1])\n        sys.stderr.writelines(a)"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit(0)\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        tmp = _split(_src[1:])\n        if tmp != [] and tmp[0] == \"-\":\n            tmp = [\"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n        return [_src[0]] + tmp\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = src.index(\")\")\n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \n     \nfor t in xrange(input()):\n    _src = \"0+\" + raw_input()[:-1]\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport re\nn = int(input())\nfor _ in range(n):\n    print(int(eval(re.sub(r'(\\d+/\\d+)', r'int(\\1)', input()[0:-1]))))"
  },
  {
    "language": "Python",
    "code": "def calc(eqt):\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])//calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt):\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1:\n    return calc(eqt)\n  else:\n    ll = l[0].rsplit('(',maxsplit=1)\n    ll.append(l[1])\n    ll[1] = str(calc(ll[1]))\n    l=\"\".join(ll)\n    return unfold_brackets(l)\n\nprint(unfold_brackets(\"(((3+2)*(5+4))+2)\"))"
  },
  {
    "language": "Python",
    "code": "n=int(raw_input())\nfor i in range(n):\n\tprint eval(raw_input().split('=')[0])"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp,brac=None):\n    i = 0 # ループカウンタ?\n    num = deque() # 数字をためておく\n    ops = deque() # +-をためておく\n    ope = \"\" # */を保存\n    \n    if not brac:\n        # 対応する括弧の位置を記録しておいて計算量を削減\n        brac = [-1 for j in range(len(exp))]\n        tmpbrac = []\n        for j in range(len(exp) - 1, 0, -1):\n            if exp[j] == ')':\n                tmpbrac.append(j)\n            elif exp[j] == '(':\n                brac[j] = tmpbrac.pop()\n\n    # かっこの中身と乗除算\n    while i < len(exp):\n        # かっこの中身は再帰的に計算\n        if exp[i] == '(':\n            num.append(calc(exp[i + 1:brac[i]],brac))\n            i = brac[i]\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = exp[i] # 数値 2桁以上にも対応させる\n            i += 1\n            while i < len(exp) and exp[i].isnumeric():\n                temp += exp[i]\n                i += 1\n            i -= 1 # 最後の数字に戻る(最後にi+=1しているのでこれでいい)\n            num.append(int(temp))\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        num.appendleft(eva(num.popleft(),num.popleft(),ops.popleft()))\n\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    print(calc(input()))\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef number(begin):\n\tglobal i\n\t\n\tif begin[i] == \"(\":\n\t\ti += 1\n\t\tres = expression(begin)\n\t\ti += 1 \n\t\treturn res\n\t\n\tres = 0\n\t\n\twhile begin[i].isdigit():\n\t\tres *= 10\n\t\tres += int(begin[i])\n\t\ti+=1\n\t\n\treturn res\n\t\ndef term(begin):# your code goes here\n\n\tglobal i\n\tres = number(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"*\":\n\t\t\ti += 1\n\t\t\tres *= number(begin)\n\t\telif begin[i] == \"/\":\n\t\t\ti += 1\n\t\t\tres /= number(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\ndef expression(begin):\n\t\n\tglobal i\n\tres = term(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"+\":\n\t\t\ti += 1\n\t\t\tres += term(begin)\n\t\t\t\n\t\telif begin[i] == \"-\":\n\t\t\ti += 1\n\t\t\tres -= term(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\n\ndef main():\n\tglobal i\n\tfor j in range(input()):\n\t\t\ti = 0\n\t\t\tex = raw_input() +\"=\"\n\t\t\tans = expression(ex)\n\t\n\t\t\tprint ans\nmain()"
  },
  {
    "language": "Python",
    "code": "[print(eval(input()[:-1])) for _ in range(int(input()))]\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor _ in range(n):\n    print(eval(input()[:-1]))"
  },
  {
    "language": "Python",
    "code": "#n=int(input())\n\ndef lastfind(s,x):\n    n=len(s)\n    s_rev=s[::-1]\n    t=s_rev.find(x)\n    return n-t-1\ndef doublefind(s,x,y):\n    if x in s:\n        p=s.find(x)\n    else:\n        p=len(s)+10\n    if y in s:\n        q=s.find(y)\n    else:\n        q=len(s)+10\n    \n    if p<=q and p<len(s)+5:\n        return [p,x]\n    elif q<len(s)+5:\n        return [q,y]\n    else:\n        return 0\n\ndef calculator(s):\n    if s==\"\":\n        return 0\n    \n    try:\n        return int(s)\n    except:\n        try:\n            x=doublefind(s,\"+\",\"-\")\n            if x[1]==\"+\":\n                return calculator(s[:x[0]:])+calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])-calculator(s[x[0]+1::])\n        except:\n            x=doublefind(s,\"*\",\"/\")\n            if x[1]==\"*\":\n                return calculator(s[:x[0]:])*calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])/calculator(s[x[0]+1::])\n\ndef calc(s):\n    while \"(\" in s:\n        closec=s.find(\")\")\n        openc=lastfind(s[:closec:],\"(\")\n        t=s[:openc:]+str(calculator(s[openc+1:closec:]))+s[closec+1::]\n        s=t\n    return calculator(s)\n        \nn=int(input())\nfor count in range(n):\n    s=input()\n    print(int(calc(s[:-1:])))\n    "
  },
  {
    "language": "Python",
    "code": "pos = 0\ndef number(s):\n\tglobal pos\n\tresult = 0\n\twhile s[pos].isdigit():\n\t\tresult *= 10\n\t\tresult += int(s[pos])\n\t\tpos += 1\n\treturn result;\nexpression = None\ndef factor(s):\n\tglobal pos\n\tif s[pos] == '(':\n\t\tpos += 1\n\t\tresult = expression(s)\n\t\tpos += 1\n\t\treturn result\n\telse:\n\t\treturn number(s)\ndef term(s):\n\tglobal pos\n\tresult = factor(s)\n\twhile True:\n\t\tif s[pos] == '*':\n\t\t\tpos += 1\n\t\t\tresult *= factor(s)\n\t\telif s[pos] == '/':\n\t\t\tpos += 1\n\t\t\tresult /= factor(s)\n\t\telse:\n\t\t\tbreak\n\treturn result\ndef _expression(s):\n\tglobal pos\n\tresult = term(s)\n\twhile True:\n\t\tif s[pos] == '+':\n\t\t\tpos += 1\n\t\t\tresult += term(s)\n\t\telif s[pos] == '-':\n\t\t\tpos += 1\n\t\t\tresult -= term(s)\n\t\telse:\n\t\t\tbreak\n\treturn result\nexpression = _expression\n\nn = input()\nfor i in xrange(n):\n\tpos = 0\n\tprint expression(raw_input())"
  },
  {
    "language": "Python",
    "code": "#n=int(input())\n\ndef lastfind(s,x):\n    n=len(s)\n    s_rev=s[::-1]\n    t=s_rev.find(x)\n    return n-t-1\ndef doublefind(s,x,y):\n    if x in s:\n        p=s.find(x)\n    else:\n        p=len(s)+10\n    if y in s:\n        q=s.find(y)\n    else:\n        q=len(s)+10\n    \n    if p<=q and p<len(s)+5:\n        return [p,x]\n    elif q<len(s)+5:\n        return [q,y]\n    else:\n        return 0\n\ndef calculator(s):\n    if s==\"\":\n        return 0\n    \n    try:\n        return int(s)\n    except:\n        try:\n            x=doublefind(s,\"+\",\"-\")\n            if x[1]==\"+\":\n                return calculator(s[:x[0]:])+calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])-calculator(s[x[0]+1::])\n        except:\n            x=doublefind(s,\"*\",\"/\")\n            if x[1]==\"*\":\n                return calculator(s[:x[0]:])*calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])/calculator(s[x[0]+1::])\ndef remove_brackets(s):\n    if s[0]==\"(\" and s[-1]==\")\":\n        return s[1:-1:]\n    else:\n        return s\ndef calc(s):\n    while \"(\" in s:\n        closec=s.find(\")\")\n        openc=lastfind(s[:closec:],\"(\")\n        s=s[:openc:]+str(calculator(s[openc+1:closec:]))+s[closec+1::]\n    return calculator(s)\n        \nn=int(input())\nfor count in range(n):\n    s=input()\n    print(int(calc(s[:-1:])))\n    "
  },
  {
    "language": "Python",
    "code": "for i in xrange(input()):\n\tprint int(eval(raw_input().strip().strip('=')))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):print(eval(input()[:-1].replace('/','//')))"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "print(*[eval(input()[:-1].replace(\"/\", \"//\")) for _ in range(int(input()))], sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint(int(eval(input().replace(\"=\",\"\"))))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"(\": 0, \")\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = []\n    isContinue = False\n\n    for item in string[:-1]:\n\n        if str.isdigit(item):\n            if not isContinue:\n                stack.append(item)\n                isContinue = True\n            else:\n                stack[-1] += item\n            continue\n        elif item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            while len(signStack) != 0 and priority[item] <= priority[signStack[-1]]:\n                stack.append(signStack.pop())\n\n            signStack.append(item)\n\n        isContinue = False\n\n    while len(signStack) != 0:\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = int(num2 / num1)\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit(0)\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        tmp = _split(_src[1:])\n        if tmp != [] and tmp[0] == \"-\":\n            tmp = [\"+\" , \"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n        return [_src[0]] + tmp\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = src.index(\")\")\n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \n     \nfor t in xrange(input()):\n    _src = raw_input()[:-1]\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n#while 1:\n#        (a,b,c) = map(int , raw_input().split())\ndef isdigit2(n):\n    n = str(n)\n    if(n.isdigit()):return True\n    if(n.startwith(\"-\")):\n        if(len(n)==1):return False\n        if(str(n)[1:].isdigit):return True\n    return False\n\ndef parse(line):\n    lis = []\n    ind =0\n    while(line[ind]!=\"=\"):\n        a = line[ind]\n        if(a.isdigit()==False):\n            lis.append(a)\n            ind+=1\n            continue\n        else:\n            s=ind\n            while(line[ind].isdigit()):ind+=1\n            lis.append(line[s:ind])\n            continue\n    return lis\n\ndef dParen(lis,sind):\n    cnt = 1\n    s = sind\n    sind+=1\n    while 1:\n        if(lis[sind]==\")\"):\n            cnt -= 1\n            if(cnt==0):return (s,sind)\n        elif(lis[sind]==\"(\"):\n            cnt += 1\n        sind+=1\n\n\n           \n\ndef eva(lis):\n    #print lis\n    if(len(lis)==1):return lis[0]\n    if(\"(\" in lis):\n        (s,e) = dParen(lis,lis.index(\"(\"))\n        val = eva(lis[s+1:e])\n        lis[s:e+1]=[val]\n        return eva(lis)\n    if(\"*\" in lis or \"/\" in lis):\n        inmin = 0;\n        if((\"*\" in lis)==False):\n            inmin = lis.index(\"/\")\n        elif((\"/\" in lis)==False):\n            inmin = lis.index(\"*\")\n        else:\n            inmin = min(lis.index(\"x\"),lis.index(\"/\"))\n        if(lis[inmin]==\"*\"):\n            val = int(lis[inmin-1])*int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        else:\n            val = int(lis[inmin-1])/int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        return eva(lis)\n    if(\"+\" in lis or \"-\" in lis):\n        if((\"+\" in lis)==False):\n            inmin = lis.index(\"-\")\n        elif((\"-\" in lis)==False):\n            inmin = lis.index(\"+\")\n        else:\n            inmin = min(lis.index(\"+\"),lis.index(\"-\"))\n        if(lis[inmin]==\"+\"):\n            val = int(lis[inmin-1])+int(lis[inmin+1])\n            lis[inmin-1:inmin+2]= [val]\n        else:\n            val = int(lis[inmin-1])-int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        return eva(lis)\n    \n\nn = int(raw_input())\nfor i in range(n):\n    calcu = parse(raw_input())\n    #print calcu\n    print eva(calcu)"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "import re\nclass o:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self,value):\n        self.x=value\n    def __add__(self,value):\n        return o(self.x+value.x)\n    def __sub__(self,value):\n        return o(self.x-value.x)\n    def __mul__(self,value):\n        return o(self.x*value.x)\n    def __truediv__(self,value):\n        return o(int(self.x/value.x))\n    \nn=int(input())\nfor i in range(n):\n    s=input()[:-1]\n    s=re.sub(r'(\\d+)',r'o(\\1)',s)\n    print(eval(s))\n\n"
  },
  {
    "language": "Python",
    "code": "def expression():\n    global pos\n    ret=term()\n    while True:\n        if L[pos]==\"+\":\n            pos+=1\n            ret+=term()\n        elif L[pos]==\"-\":\n            pos+=1\n            ret-=term()\n        else:\n            break\n    return ret\n\ndef term():\n    global pos\n    ret=factor()\n    while True:\n        if L[pos]==\"(\":\n            ret+=factor()\n        elif L[pos]==\"*\":\n            pos+=1\n            ret*=factor()\n        elif L[pos]==\"/\":\n            pos+=1\n            ret/=factor()\n        else:\n            break\n    return ret\n\ndef factor():\n    global pos\n    if L[pos]==\"(\":\n        pos+=1\n        ret=expression()\n        pos+=1\n    else:\n        return number()\n    return ret\n\ndef number():\n    global pos\n    ret=0\n    while L[pos].isdigit():\n        ret*=10\n        ret+=int(L[pos])\n        pos+=1\n    return ret\n\nfor i in range(input()):\n    L=raw_input()\n    pos=0\n    print expression()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# 写経した\nimport re\nclass Num:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self, value):\n        self.x = value\n    def __add__(self, value):\n        return o(self.x + value.x)\n    def __sub__(self, value):\n        return o(self.x - value.x)\n    def __mul__(self, value):\n        return o(self.x * value.x)\n    def __truediv__(self, value):\n        return o(int(self.x / value.x))\n     \nN = int(input())\nfor i in range(N):\n    s = input()[:-1]\n    s = re.sub(r'(\\d+)',r'Num(\\1)',s)\n    print(eval(s))\n"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n    def __add__(self,n):\n        return c(int(self)+int(n))\n    def __sub__(self,n):\n        return c(int(self)-int(n))\n    def __mul__(self,n):\n        return c(int(self)*int(n))\n    def __truediv__(self,n):\n        return c(int(int(self)/int(n)))\nn = int(input())\nfor i in range(n):\n    print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))\n"
  },
  {
    "language": "Python",
    "code": "def calc(eqt): # assuming that eqt has no brackets.\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2: # if eqt has \"+\", then\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"-\", then\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"*\", then\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"/\", then\n    return (calc(l[0])/calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt): # for example, eqt == \"((3+5)*8+2)*2\"\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1: # if eqt has no brackets, then\n    return calc(eqt)\n  else:\n    # for example, l == [\"((3+5\", \"*8+2)*2\"]\n    ll = l[0].rsplit('(',maxsplit=1)\n    # ll == [\"(\",\"3+5\"]\n    ll.append(l[1])\n    # ll == [\"(\",\"3+5\",\"*8+2)*2\"]\n    ll[1] = str(calc(ll[1]))\n    # ll == [\"(\",8,\"*8+2)*2\"]\n    l=\"\".join(ll)\n    # ll == \"(8*8+2)*2\"\n    return unfold_brackets(l)\n\nn=int(input())\ndatasets=[input() for i in range(n)]\nfor line in datasets:\n  l = line.split(\"=\",maxsplit=1)[0]\n  print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "import re\nclass c:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self,value):\n        self.x=value\n    def __add__(self,value):\n        return c(self.x+value.x)\n    def __sub__(self,value):\n        return c(self.x-value.x)\n    def __mul__(self,value):\n        return c(self.x*value.x)\n    def __truediv__(self,value):\n        return c(int(self.x/value.x))\nn=int(input())\nfor i in range(n):\n    s=input()[:-1]\n    d=re.sub(r'(\\d+)',r'c(\\1)',s)\n    #print(d)\n    print(eval(d))\n    #s.group(1)\n\n"
  },
  {
    "language": "Python",
    "code": "for _ in[0]*int(input()):print(int(eval(input()[:-1])))\n"
  },
  {
    "language": "Python",
    "code": "def rank(ch,st):\n    dic={\"+\":1,\"-\":1,\"*\":2,\"/\":2,\"(\":0,\")\":0}\n    return dic[ch]<=dic[st]\n\nfor i in range(input()):\n    s=raw_input()[:-1]\n    buf=[]\n    stack=[]\n    for ch in s:\n        if ch.isdigit():\n            buf.append(ch)\n        elif ch==\"(\":\n            stack.append(ch)\n        elif ch==\")\":\n            temp=stack.pop()\n            while temp!=\"(\":\n                buf.append(temp)\n                temp=stack.pop()\n        else:\n            while stack!=[] and rank(ch,stack[-1]):\n                buf.append(stack.pop())\n            stack.append(ch)\n    buf+=stack[::-1]\n\n    stack=[]\n    res=0\n    for ch in buf:\n        if ch.isdigit():\n            stack.append(int(ch))\n        else:\n            a=stack.pop()\n            b=stack.pop()\n            if ch==\"+\":\n                stack.append(a+b)\n            elif ch==\"-\":\n                stack.append(b-a)\n            elif ch==\"*\":\n                stack.append(a*b)\n            else:\n                stack.append(b/a)\n    print stack[0]"
  },
  {
    "language": "Python",
    "code": "from __future__ import division\nfor i in range(input()):\n    s=raw_input()[:-1]\n    t=\"\"\n    for ch in s:\n        if ch.isdigit():\n            t+=str(float(ch))\n        elif ch==\"/\":\n            t+=\"//\"\n        else:\n            t+=ch\n    print int(eval(t))"
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0109: Smart Calculator\n\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\nN = int(input())\nfor _ in range(N):\n    print(eval(input().replace('=', '')))"
  },
  {
    "language": "Python",
    "code": "def calc(eqt): # assuming that eqt has no brackets.\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2: # if eqt has \"+\", then\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"-\", then\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"*\", then\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:# if eqt has \"/\", then\n    return (calc(l[0])/calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt): # for example, eqt == \"((3+5)*8+2)*2\"\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1: # if eqt has no brackets, then\n    return calc(eqt)\n  else:\n    # for example, l == [\"((3+5\", \"*8+2)*2\"]\n    ll = l[0].rsplit('(',maxsplit=1)\n    # ll == [\"(\",\"3+5\"]\n    ll.append(l[1])\n    # ll == [\"(\",\"3+5\",\"*8+2)*2\"]\n    ll[1] = str(calc(ll[1]))\n    # ll == [\"(\",8,\"*8+2)*2\"]\n    l=\"\".join(ll)\n    # ll == \"(8*8+2)*2\"\n    return unfold_brackets(l)\n\nn=int(input())\ndatasets=[input() for i in range(0,n)]\nfor line in datasets:\n  l = line.split(\"=\",maxsplit=1)[0]\n  print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = len(src) - 1 - src[::-1].index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    line = raw_input()\n    if line == '':\n        break\n\n    sys.stderr.write(line)\n    for i in range(int(line)):\n        a = eval(raw_input().replace('/', '//')[:-1])\n        print(str(a))"
  },
  {
    "language": "Python",
    "code": "# AOJ 0109 Smart Calculator\n# Python3 2018.6.18 bal4u\n\nINF = 1000000010\nLEFT  = INF+1\nRIGHT = INF+2\nPLUS  = INF+3\nMINUS = INF+4\nMUL   = INF+5\nDIV   = INF+6\ntoken = { '+':PLUS, '-':MINUS, '*':MUL, '/':DIV }\nrank = { PLUS:2, MINUS:2, MUL:3, DIV:3, LEFT:1, RIGHT:1 }\n\nS, top = [0]*200, 0\nQ, end = [0]*200, 0\n\ndef getInt():\n\tglobal id\n\tglobal buf\n\tk = ''\n\twhile buf[id] >= '0' and buf[id] <= '9':\n\t\tk += buf[id]\n\t\tid += 1\n\treturn int(k)\n\nn = int(input())\nfor i in range(n):\n\tbuf = list(input())\n\tid, f, top, end = 0, True, 0, 0\n\twhile True:\n\t\tif buf[id] == '=':\n\t\t\twhile top > 0:\n\t\t\t\ttop -= 1\n\t\t\t\tQ[end] = S[top]\n\t\t\t\tend += 1\n\t\t\tbreak;\n\t\tif buf[id] == '-' and f and buf[id+1] >= '0' and buf[id+1] <= '9':\n\t\t\tid += 1\n\t\t\tQ[end] = -getInt()\n\t\t\tend += 1\n\t\t\tf = False\n\t\t\tcontinue\n\t\t\n\t\tf = False\n\t\tif buf[id] >= '0' and buf[id] <= '9':\n\t\t\tQ[end] = getInt()\n\t\t\tend += 1\n\t\telif buf[id] == ')':\n\t\t\twhile S[top - 1] != LEFT:\n\t\t\t\ttop -= 1\n\t\t\t\tQ[end] = S[top]\n\t\t\t\tend += 1\n\t\t\ttop -= 1\n\t\t\tid += 1\n\t\telif buf[id] == '(':\n\t\t\tS[top] = LEFT\n\t\t\ttop += 1\n\t\t\tid += 1\n\t\t\tf = True\n\t\telse:\n\t\t\tk = token[buf[id]]\n\t\t\tid += 1\n\t\t\twhile top > 0:\n\t\t\t\tif rank[k] <= rank[S[top-1]]:\n\t\t\t\t\ttop -= 1\n\t\t\t\t\tQ[end] = S[top];\n\t\t\t\t\tend += 1\n\t\t\t\telse: break\n\t\t\tS[top] = k;\n\t\t\ttop += 1\n\n\ttop = 0\n\tfor i in range(end):\n\t\tk = Q[i]\n\t\tif k > INF:\n\t\t\td1, d2 = S[top-1], S[top-2]\n\t\t\ttop -= 2\n\t\t\tif k == PLUS: d2 += d1\n\t\t\telif k == MINUS: d2 -= d1\n\t\t\telif k == MUL: d2 *= d1\n\t\t\telse:\n\t\t\t\tif (d2 > 0 and d1 < 0) or (d2 < 0 and d1 > 0):\n\t\t\t\t\td2 //= -d1\n\t\t\t\t\td2 = -d2\n\t\t\t\telse: d2 //= d1\n\t\t\tS[top] = d2\n\t\telse: S[top] = k\n\t\ttop += 1\n\tprint(S[top-1])\n"
  },
  {
    "language": "Python",
    "code": "def f(s):\n  while 1:\n    b=s.find(\")\")\n    if b<0: return g(s)\n    a=s[:b].rfind(\"(\")\n    s1=s[a:b+1]\n    s=s.replace(s1,f(s1[1:-1]))\n\ndef g(s):\n  a=\"\"\n  f=1\n  x=[]\n  def F(a,b):\n    x.append(a)\n    x.append(b)\n    return 1,\"\"\n  for c in s:\n    if c==\"=\": continue\n    elif c in \"*/\": f,a=F(a,c)\n    elif c in \"+-\":\n      if f==1: f,a=0,c\n      else: f,a=F(a,c)\n    else: f,a=0,a+c\n  x.append(a)\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e in \"+-\": x.append(e)\n    elif e in \"*/\": f=e\n    else:\n      a=int(e)\n      if f==\"*\": a*=x.pop()\n      elif f==\"/\": a=int(1.0*x.pop()/a)\n      x.append(a)\n      f=\"\"\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e==\"+\" or e==\"-\": f=e\n    else:\n      a=e\n      if f==\"+\": a+=x.pop()\n      elif f==\"-\": a=x.pop()-a\n      x.append(a)\n      f=\"\"\n  return str(x[0])\n\nn=input()\nfor _ in [0]*n: \n  s=raw_input()\n  print f(s)"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef factor(t, i):\n    if t[i[0]] == '(':\n        i[0] += 1\n        r = expr(t, i)\n        i[0] += 1\n        return r\n    else:\n        i[0] += 1\n        return int(t[i[0]-1])\n\ndef term(t, i):\n    r = factor(t, i)\n    while True:\n        if t[i[0]] == '*':\n            i[0] += 1\n            r *= factor(t, i)\n        elif t[i[0]] == '/':\n            i[0] += 1\n            r /= factor(t, i)\n        else:\n            break\n    return r\n\ndef expr(t, i):\n    r = term(t, i)\n    while True:\n        if t[i[0]] == '+':\n            i[0] += 1\n            r += term(t, i)\n        elif t[i[0]] == '-':\n            i[0] += 1\n            r -= term(t, i)\n        else:\n            break\n    return r\n\nn = int(raw_input())\nfor _ in range(n):\n    t = [s for s in re.sub(r'([\\+\\-\\*\\/\\(\\)=])', r' \\1 ', raw_input()).split() if s != '']\n    print expr(t, [0])"
  },
  {
    "language": "Python",
    "code": "import math\ndef calc_zyouzyo(siki) :\n    j = 0\n    while True :\n        if '*' not in siki and '/' not in siki:\n            break\n        if siki[j] == '*' :\n            siki[j-1] = str(int(siki[j-1]) * int(siki[j+1]))\n            del siki[j:j+2]\n        elif siki[j] == '/' :\n            if (int(siki[j-1]) < 0 and int(siki[j+1]) < 0) or (int(siki[j-1]) >= 0 and int(siki[j+1]) >= 0) :\n                siki[j-1] = str(int(siki[j-1]) // int(siki[j+1]))\n            else :\n                if int(siki[j-1]) % int(siki[j+1]) == 0 :\n                    siki[j-1] = str(int(siki[j-1]) // int(siki[j+1]))\n                else :\n                    siki[j-1] = str(int(siki[j-1]) // int(siki[j+1]) + 1)\n            del siki[j:j+2]\n        else :\n            j += 1\n    if len(siki) == 1 :\n        return(siki[0])\n    else :\n        return(siki)\n    \ndef calc_kagen(siki) :\n    j = 0\n    while True :\n        if '+' not in siki and '-' not in siki:\n            break\n        if siki[j] == '+' :\n            siki[j-1] = str(int(siki[j-1]) + int(siki[j+1]))\n            del siki[j:j+2]\n        elif siki[j] == '-' :\n            siki[j-1] = str(int(siki[j-1]) - int(siki[j+1]))\n            del siki[j:j+2]\n        else :\n            j += 1\n    if len(siki) == 1 :\n        return(siki[0])\n    else :\n        return(siki)\n\ndef calc(siki) :\n    siki = calc_zyouzyo(siki)\n    siki = calc_kagen(siki)\n    return(siki)\n\nn = int(input())\nfor i in range(n) :\n    tmp = list(input())\n    siki = []\n    num = ''\n    for j in range(len(tmp)) :\n        if tmp[j] in ['*', '/', '+', '-', '(', ')', '='] :\n            if num != '' :\n                siki.append(num)\n            siki.append(tmp[j])\n            num = ''\n        else :\n            num += tmp[j]\n    siki.remove('=')\n    j = 0\n    while True :\n        if j == len(siki) or ')' not in siki:\n            break\n        stack = []\n        if siki[j] == ')' :\n            for k in range(j-1,-1, -1) :\n                if siki[k] == '(' :\n                    break\n                else :\n                    stack.append(siki[k])\n            stack.reverse()\n            siki[k] = calc(stack)\n            del siki[k+1 : j+1]\n            j = k+1\n        else :\n            j += 1\n    siki = calc(siki)\n    print(siki)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(raw_input())\n    if n == 0:\n        break\n\n    for i in range(n):\n        print eval(raw_input().strip()[:-1])"
  },
  {
    "language": "Python",
    "code": "\nimport re\nn = int(input())\nfor i in range(n):\n    s = raw_input().split('=')\n    print(s)\n    print(eval(s[0]))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n\ta=input()\n\tprint(eval(a[:len(a)-1]))"
  },
  {
    "language": "Python",
    "code": "def parse(line):\n    lis = []\n    ind =0\n    while(line[ind]!=\"=\"):\n        a = line[ind]\n        if(a.isdigit()==False):\n            lis.append(a)\n            ind+=1\n            continue\n        else:\n            s=ind\n            while(line[ind].isdigit()):ind+=1\n            lis.append(line[s:ind])\n            continue\n    return lis\n\ndef dParen(lis,sind):\n    cnt = 1\n    s = sind\n    sind+=1\n    while 1:\n        if(lis[sind]==\")\"):\n            cnt -= 1\n            if(cnt==0):return (s,sind)\n        elif(lis[sind]==\"(\"):\n            cnt += 1\n        sind+=1\n\n\n           \n\ndef eva(lis):\n    #print lis\n    if(len(lis)==1):return lis[0]\n    if(\"(\" in lis):\n        (s,e) = dParen(lis,lis.index(\"(\"))\n        val = eva(lis[s+1:e])\n        lis[s:e+1]=[val]\n        return eva(lis)\n    if(\"*\" in lis or \"/\" in lis):\n        inmin = 0;\n        if((\"*\" in lis)==False):\n            inmin = lis.index(\"/\")\n        elif((\"/\" in lis)==False):\n            inmin = lis.index(\"*\")\n        else:\n            inmin = min(lis.index(\"x\"),lis.index(\"/\"))\n        if(lis[inmin]==\"*\"):\n            val = int(lis[inmin-1])*int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        else:\n            val = int(lis[inmin-1])/int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        return eva(lis)\n    if(\"+\" in lis or \"-\" in lis):\n        if((\"+\" in lis)==False):\n            inmin = lis.index(\"-\")\n        elif((\"-\" in lis)==False):\n            inmin = lis.index(\"+\")\n        else:\n            inmin = min(lis.index(\"+\"),lis.index(\"-\"))\n        if(lis[inmin]==\"+\"):\n            val = int(lis[inmin-1])+int(lis[inmin+1])\n            lis[inmin-1:inmin+2]= [val]\n        else:\n            val = int(lis[inmin-1])-int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        return eva(lis)\n    \n\nn = int(raw_input())\nfor i in range(n):\n    calcu = parse(raw_input())\n    #print calcu\n    print eva(calcu)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor _ in range (n):\n    print(eval(input().rstrip('=')))"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n        \n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nN = int(raw_input())\nfor i in range(N):\n    formula = raw_input().rstrip('=')\n    up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "def calc(eqt):\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])//calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt):\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1:\n    return calc(eqt)\n  else:\n    ll = l[0].rsplit('(',maxsplit=1)\n    ll.append(l[1])\n    ll[1] = str(calc(ll[1]))\n    l=\"\".join(ll)\n    return unfold_brackets(l)\n\nn=int(input())\ndatasets=[None]*n\nfor i in range(0,n):\n  datasets[i] = input()\nfor line in datasets:\n  l = line.split(\"=\",maxsplit=1)[0]\n  print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "i = 0\n\ndef number(begin):\n\tglobal i\n\t\n\tif begin[i] == \"(\":\n\t\ti += 1\n\t\tres = expression(begin)\n\t\ti += 1 \n\t\treturn res\n\t\n\tres = 0\n\t\n\twhile begin[i].isdigit():\n\t\tres *= 10\n\t\tres += int(begin[i])\n\t\ti+=1\n\t\n\treturn res\n\t\ndef term(begin):# your code goes here\n\n\tglobal i\n\tres = number(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"*\":\n\t\t\ti += 1\n\t\t\tres *= number(begin)\n\t\telif begin[i] == \"/\":\n\t\t\ti += 1\n\t\t\tres /= number(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\ndef expression(begin):\n\t\n\tglobal i\n\tres = term(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"+\":\n\t\t\ti += 1\n\t\t\tres += term(begin)\n\t\t\t\n\t\telif begin[i] == \"-\":\n\t\t\ti += 1\n\t\t\tres -= term(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\n\ndef main():\n\tex = raw_input() +\"=\"\n\tans = expression(ex)\n\t\n\tprint ans\n\tprint i\n\t\nmain()"
  },
  {
    "language": "Python",
    "code": "i = 0\n\ndef number(begin):\n\tglobal i\n\t\n\tif begin[i] == \"(\":\n\t\ti += 1\n\t\tres = expression(begin)\n\t\ti += 1 \n\t\treturn res\n\t\n\tres = 0\n\t\n\twhile begin[i].isdigit():\n\t\tres *= 10\n\t\tres += int(begin[i])\n\t\ti+=1\n\t\n\treturn res\n\t\ndef term(begin):# your code goes here\n\n\tglobal i\n\tres = number(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"*\":\n\t\t\ti += 1\n\t\t\tres *= number(begin)\n\t\telif begin[i] == \"/\":\n\t\t\ti += 1\n\t\t\tres /= number(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\ndef expression(begin):\n\t\n\tglobal i\n\tres = term(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"+\":\n\t\t\ti += 1\n\t\t\tres += term(begin)\n\t\t\t\n\t\telif begin[i] == \"-\":\n\t\t\ti += 1\n\t\t\tres -= term(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\n\ndef main():\n\tex = raw_input() +\"=\"\n\tans = expression(ex)\n\t\n\tprint ans\n\t\nmain()"
  },
  {
    "language": "Python",
    "code": "while True:\n  try:\n    n=int(input())\n    datasets=[input() for i in range(0,n)]\n    for line in datasets:\n      l = line.split(\"=\",maxsplit=1)[0]\n      print(int(eval(l)))\n  except EOFError:\n    break"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor _t in range(n):\n    print eval(raw_input().rstrip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif s=='':\n\t\treturn 0\n\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\t\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\t\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\tprint calc(raw_input()[:-1])\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\tif s[0]=='(' and s[-1]==')' and all(map(lambda t: t!='(' and t!=')', s[1:-1])):\n\t\treturn calc(s[1:-1])\n\t\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\tprint(int(calc(raw_input()[:-1])))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "num = int(raw_input())\nfor i in range(num):\n\tinput_line = raw_input()\n\teval_line = input_line[0:-1]\n\tresult = eval(eval_line)\n\tprint result"
  },
  {
    "language": "Python",
    "code": "n=int(input())\n\nfor t in range(n):\n    print(eval(input()[:-1].replace(\"/\",\"//\")))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"(\": 0, \")\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = []\n    isContinue = False\n\n    for item in string[:-1]:\n\n        if str.isnumeric(item):\n            if not isContinue:\n                stack.append(item)\n                isContinue = True\n            else:\n                stack[-1] += item\n            continue\n        elif item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            while len(signStack) != 0 and priority[item] <= priority[signStack[-1]]:\n                stack.append(signStack.pop())\n\n            signStack.append(item)\n\n        isContinue = False\n\n    while len(signStack) != 0:\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1 // 1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\ns=\"\"\nfor i in range(n):\n    s=raw_input()\n    print(eval(s[0:-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n\ts = 1\n\tif(x < 0):s *= -1\n\tif(y < 0):s *= -1\n\treturn abs(x) / abs(y) * s\n\t\n\ndef _split(_src):\n\tc = 0\n\tl = len(_src)\n\t\n\tif l == 0:\n\t\treturn []\n\n\twhile c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n\t\tc += 1\n\t\t\n\tif c == 0:\n\t\treturn [_src[0]] + _split(_src[1:])\n\t\n\telse:\n\t\treturn [int(_src[:c])] + _split(_src[c:])\n\t\t\n\ndef evaluate(src):\n\tif len(src) == 1:\n\t\treturn src[0]\n\t\t\n\tif \"(\" in src:\n\t\tl = src.index(\"(\")\n\t\tr = src.index(\")\")\n\t\tmid = evaluate(src[l + 1:r])\n\t\treturn evaluate( src[:l] + [mid] + src[r + 1:])\n\t\n\toperators = [(\"+\", lambda x,y:x + y),\n\t\t\t\t (\"-\", lambda x,y:x - y),\n\t\t\t\t (\"*\", lambda x,y:x * y),\n\t\t\t\t (\"/\", divide)\n\t\t\t\t]\t\n\t\n\tfor (op,func) in operators:\n\t\tif op in src:\n\t\t\tp = src.index(op)\n\t\t\tl = evaluate(src[:p])\n\t\t\tr = evaluate(src[p + 1:])\n\t\t\treturn func(l, r)\n\t\n\t\nfor t in xrange(input()):\n\t_src = raw_input()[:-1]\n\tsrc = _split(_src)\n\tprint evaluate(src)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nn = int(input())\n\nfor i in range(n):\n    command = input().strip()\n    command = command.replace('=', '')\n    print(eval(command))"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n        \n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nwhile True:\n    try:\n        N = int(raw_input())\n        for i in range(N):\n            formula = raw_input().rstrip('=')\n            up_to_you(formula)\n    except EOFError:\n        break"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n\ta=input()\n\tb=\"\"\n\tfor i in a:\n\t\tb+=i\n\t\tif i=='/':b+='/'\n\tprint(eval(b[:len(b)-1]))"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n    def __add__(self,n):\n        return c(int(self)+int(n))\n    def __sub__(self,n):\n        return c(int(self)-int(n))\n    def __mul__(self,n):\n        return c(int(self)*int(n))\n    def __truediv__(self,n):\n        return c(int(int(self)/int(n)))\n  \nfor _ in range(int(input())):\n    print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\tif s[0]=='(' and s[-1]==')' and all(map(lambda t: t!='(' and t!=')', s[1:-1])):\n\t\treturn calc(s[1:-1])\n\t\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\tprint calc(raw_input()[:-1])\n\nmain()"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint(int(eval(input().strip(\"=\"))))"
  },
  {
    "language": "Python",
    "code": "def f(s):\n  while 1:\n    b=s.find(\")\")\n    if b<0: return g(s)\n    a=s[:b].rfind(\"(\")\n    s=s.replace(s[a:b+1],f(s[a+1:b]))\n\ndef g(s):\n  a=\"\"\n  f=1\n  x=[]\n  def F(a,b):\n    x.append(a)\n    x.append(b)\n    return 1,\"\"\n  for c in s:\n    if c==\"=\": continue\n    elif c in \"*/\": f,a=F(a,c)\n    elif c in \"+-\":\n      if f==1: f,a=0,c\n      else: f,a=F(a,c)\n    else: f,a=0,a+c\n  x.append(a)\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e in \"+-\": x.append(e)\n    elif e in \"*/\": f=e\n    else:\n      a=int(e)\n      if f==\"*\": a*=x.pop()\n      elif f==\"/\": a=int(1.0*x.pop()/a)\n      x.append(a)\n      f=\"\"\n\n  a,f=0,1\n  for e in x:\n    if e==\"+\": f=1\n    elif e==\"-\": f=-1\n    else: a+=f*e\n  return str(a)"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef expression():\n    global pos\n    ret=term()\n    while True:\n        if L[pos]==\"+\":\n            pos+=1\n            ret+=term()\n        elif L[pos]==\"-\":\n            pos+=1\n            ret-=term()\n        else:\n            break\n    return ret\n\ndef term():\n    global pos\n    ret=factor()\n    while True:\n        if L[pos]==\"*\":\n            pos+=1\n            ret*=factor()\n        elif L[pos]==\"/\":\n            pos+=1\n            ret/=factor()\n        else:\n            break\n    return ret\n\ndef factor():\n    global pos\n    if L[pos]==\"(\":\n        pos+=1\n        ret=expression()\n        pos+=1\n    else:\n        return number()\n    return ret\n\ndef number():\n    global pos\n    ret=0\n    if L[pos].isdigit():\n        ret=int(L[pos])\n        pos+=1\n    return ret\n\nfor i in range(input()):\n    s=raw_input()\n    L=re.findall(r\"\\d+|[/+*-]|[\\(\\)=]\",s)\n    pos=0\n    print expression()"
  },
  {
    "language": "Python",
    "code": "class c:\n    def __init__(self, v):\n        self.value = v\n    def __str__(self):\n        return str(self.value)\n    def __add__(self, other):\n        return c(self.value + other.value)\n    def __sub__(self, other):\n        return c(self.value - other.value)\n    def __mul__(self, other):\n        return c(self.value * other.value)\n    def __truediv__(self, other):\n        return c(int(self.value / other.value))\n\nimport re\n\nn = int(input())\n\nans = (str(eval(re.sub(r'(\\d+)', r'c(\\1)', input()[:-1]))) for i in range(n))\n\nprint('\\n'.join(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    line = raw_input()\n    if line == '':\n        break\n\n    n = int(line)\n    for i in range(n):\n        print int(eval(raw_input().replace('/', '//')[:-1]))"
  },
  {
    "language": "Python",
    "code": "for _ in range( int(raw_input()) ): print int(eval( \"1.0*\"+raw_input()[:-1] ))"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "for unused in xrange(input()):print eval(raw_input().strip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "def calc(array):\n\twhile '(' in array:\n\t\tc1 = array.index('(')\n\t\tc2 = array.index(')')\n\t\tarray[c2] = calc(array[c1 + 1:c2])\n\t\tdel array[c1:c2]\n\twhile len(array) > 1:\n\t\tif '/' in array:\n\t\t\tc = array.index('/')\n\t\t\tarray[c + 1] = array[c - 1] / array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '*' in array:\n\t\t\tc = array.index('*')\n\t\t\tarray[c + 1] = array[c - 1] * array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '-' in array:\n\t\t\tc = array.index('-')\n\t\t\tarray[c + 1] = array[c - 1] - array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '+' in array:\n\t\t\tc = array.index('+')\n\t\t\tarray[c + 1] = array[c - 1] + array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\treturn array[0]\n\nn = input()\nfor i in range(n):\n\tconflict = []\n\tfor var in list(raw_input()):\n\t\ttry:\n\t\t\tconflict.append(int(var))\n\t\texcept:\n\t\t\tconflict.append(var)\n\tprint calc(conflict[0:len(conflict) - 1])"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n  print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n\ts = 1\n\tif(x < 0):s *= -1\n\tif(y < 0):s *= -1\n\treturn abs(x) / abs(y) * s\n\t\n\ndef _split(_src):\n\tc = 0\n\tl = len(_src)\n\tif l == 0:\n\t\treturn []\n\twhile c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n\t\tc += 1\n\tif c == 0:\n\t\ttmp = _split(_src[1:])\n\t\tif tmp != [] and tmp[0] == \"-\":\n\t\t\ttmp = [\"+\" , \"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n\t\treturn [_src[0]] + tmp\n\telse:\n\t\treturn [int(_src[:c])] + _split(_src[c:])\n\t\t\n\ndef evaluate(src):\n\tif len(src) == 1:\n\t\treturn src[0]\n\t\t\n\tif \"(\" in src:\n\t\tl = src.index(\"(\")\n\t\tr = src.index(\")\")\n\t\tmid = evaluate(src[l + 1:r])\n\t\treturn evaluate( src[:l] + [mid] + src[r + 1:])\n\t\n\toperators = [(\"+\", lambda x,y:x + y),\n\t\t\t\t (\"-\", lambda x,y:x - y),\n\t\t\t\t (\"*\", lambda x,y:x * y),\n\t\t\t\t (\"/\", divide)\n\t\t\t\t]\t\n\t\n\tfor (op,func) in operators:\n\t\tif op in src:\n\t\t\tp = src.index(op)\n\t\t\tl = evaluate(src[:p])\n\t\t\tr = evaluate(src[p + 1:])\n\t\t\treturn func(l, r)\n\t\n\t\nfor t in xrange(input()):\n\t_src = raw_input()[:-1]\n\tsrc = _split(_src)\n\tprint evaluate(src)"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n def __add__(self,n):return c(int(self)+int(n))\n def __sub__(self,n):return c(int(self)-int(n))\n def __mul__(self,n):return c(int(self)*int(n))\n def __truediv__(self,n):return c(int(int(self)/int(n)))\nfor _ in[0]*int(input()):print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = exp[i:].rfind(\")\")\n            num.append(calc(exp[i+1:i+end]))\n            i += end + 1\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef Calculate_RPN(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\n\nn = int(raw_input())\n\nfor _ in xrange(n):\n    s = raw_input()\n    print Calculate_RPN(Generate_RPN(String2List(s[:-1])))"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import deque\nfrom enum import Enum\nimport sys\nimport math\nfrom _heapq import heappush, heappop\nimport copy\n\nBIG_NUM = 2000000000\nMOD = 1000000007\nEPS = 0.000000001\n\n\n\nline = []\n\ndef calc_E(left,right):\n    global line\n\n    depth = 0\n    Q = deque()\n\n    #深さ0の、プラスまたはマイナスを探す(単項の-は無いものとする)\n    i = left\n    while i <= right:\n        if line[i] == '(':\n            depth += 1\n        elif line[i] == ')':\n            depth -= 1\n\n        if depth != 0:\n            i += 1\n        elif line[i] != '+' and line[i] != '-':\n            i += 1\n        else:\n            Q.append(i)\n            i += 1\n\n    if len(Q) == 0:\n        return calc_T(left,right)\n\n    tmp = calc_E(left,Q[0]-1)\n\n    while len(Q) > 0:\n        loc = Q.popleft()\n\n        tmp_right = None\n\n        if len(Q) == 0:\n            tmp_right = calc_T(loc+1,right)\n        else:\n            tmp_right = calc_T(loc+1,Q[0]-1)\n\n        if line[loc] == '+':\n            tmp += tmp_right\n        else:\n            tmp -= tmp_right\n\n    return tmp\n\n\ndef calc_T(left,right):\n    global line\n\n    depth = 0\n    Q = deque()\n\n    #深さ0の、*または/を探す\n    i = left\n    while i <= right:\n        if line[i] == '(':\n            depth += 1\n        elif line[i] == ')':\n            depth -= 1\n\n        if depth != 0:\n            i += 1\n        elif line[i] != '*' and line[i] != '/':\n            i += 1\n        else:\n            Q.append(i)\n            i += 1\n\n    if len(Q) == 0:\n        return calc_F(left,right)\n\n    tmp = calc_T(left,Q[0]-1)\n\n    while len(Q) > 0:\n        loc = Q.popleft()\n\n        tmp_right = None\n\n        if len(Q) == 0:\n            tmp_right = calc_F(loc+1,right)\n        else:\n            tmp_right = calc_F(loc+1,Q[0]-1)\n\n        if line[loc] == '*':\n            tmp *= tmp_right\n        else: #注意:たとえば(-3//2はpython3では-2になる模様)\n            if tmp*tmp_right > 0:\n                tmp = abs(tmp)//abs(tmp_right)\n            else:\n                tmp = abs(tmp)//abs(tmp_right)\n                tmp *= -1\n\n    return tmp\n\n\ndef calc_F(left,right):\n    if line[left].isdecimal():\n        return calc_NUM(left,right)\n    elif line[left] == '(':\n\n        depth = 0\n        close_pos = None\n\n        for i in range(left,right+1):\n            if line[i] == '(':\n                depth += 1\n            elif line[i] == ')':\n                depth -= 1\n                if depth == 0:\n                    close_pos = i\n                    break\n\n        return calc_E(left+1,close_pos-1)\n\ndef calc_NUM(left,right):\n    global line\n    ret = 0\n\n    for i in range(left,right+1):\n        ret = 10*ret+int(line[i])\n\n    return ret\n\nN = int(input())\n\nfor _ in range(N):\n    line = str(input())\n    print(\"%d\"%(calc_E(0,len(line)-2)))\n\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n\ta=input()\n\tb=\"\"\n\tfor i in a:\n\t\tb+=i\n\t\tif i=='/':b+='/'\n\tprint(int(eval(b[:len(b)-1])))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n    isContinue = False\n\n    for item in string[:-1]:\n\n        if str.isnumeric(item):\n            if not isContinue:\n                stack.append(item)\n                isContinue = True\n            else:\n                stack[-1] += item\n            continue\n        elif item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            while priority[item] <= priority[signStack[-1]] and signStack[-1] != \"(\" and signStack[-1] != \"Sentinel\":\n                stack.append(signStack.pop())\n\n            signStack.append(item)\n\n        isContinue = False\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1 // 1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom sys import stdin, exit\nfrom operator import add, sub, mul, floordiv\n\n\nOPERATOR = {'+': add, '-': sub, '*': mul, '/': floordiv}\n\n\nclass Parser(list):\n    \"\"\"\n    <statement> ::= <expression> \"=\"\n    <expression> ::= <term> [ (\"+\"|\"-\") <term> ]\n    <term> ::= <factor> [ (\"*\"|\"/\") <factor> ]\n    <factor> ::= <number> | \"(\" <expression> \")\"\n    \"\"\"\n\n    def __init__(self, tokens):\n        self._iter_tokens = iter(tokens)\n\n        self._next_symbol()\n        while self.symbol != '=':\n            self._expression()\n\n    def _expression(self):\n        if self.symbol in ('+', '-'):\n            op_sign = self.symbol\n            self._next_symbol()\n            self._term()\n            self.append(OPERATOR[op_sign])\n        else:\n            self._term()\n\n        while self.symbol in ('+', '-'):\n            op_sign = self.symbol\n            self._next_symbol()\n            self._term()\n            self.append(OPERATOR[op_sign])\n\n    def _term(self):\n        self._factor()\n        while self.symbol in ('*', '/'):\n            op_sign = self.symbol\n            self._next_symbol()\n            self._factor()\n            self.append(OPERATOR[op_sign])\n\n    def _factor(self):\n        if self.symbol.isdigit():\n            self.append(int(self.symbol))\n            self._next_symbol()\n        elif self.symbol == '(':\n            self._next_symbol()\n            self._expression()\n            if self.symbol != ')':\n                raise SyntaxError(self.symbol)\n            self._next_symbol()\n        else:\n            raise SyntaxError(self.symbol)\n\n    def _next_symbol(self):\n        self.symbol = next(self._iter_tokens)\n\n\ndef tokenize(line):\n    buf = []\n    tokens = []\n\n    for c in line:\n        if c.isdigit():\n            buf.append(c)\n        else:\n            if buf:\n                tokens.append(''.join(buf))\n                del buf[:]\n            tokens.append(c)\n            if c == '=':\n                return tokens\n\n\ndef run(commands):\n    stack = []\n\n    for cmd in commands:\n        if isinstance(cmd, int):\n            stack.append(cmd)\n        else:\n            buf = stack.pop()\n            stack[-1] = cmd(stack[-1], buf)\n    return stack[-1]\n\n\ndef main(readline=stdin.readline):\n    for _ in range(int(readline())):\n        print(run(Parser(tokenize(readline()))))\n    exit()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "ops = {\"+\": lambda a, b: b + a,\n       \"-\": lambda a, b: b - a,\n       \"*\": lambda a, b: b * a,\n       \"/\": lambda a, b: b // a}\n\ndef calc(temp, v):\n    if v in ops:\n        temp.append(ops[v](temp.pop(), temp.pop()))\n    else:\n        temp.append(int(v))\n    return temp\n\nn = input()\nfor i in range(n):\n    porand = []\n    temp = []\n    formula = raw_input()\n    for j in formula:\n        if j >= \"0\" and j <= \"9\": porand.append(j)\n        elif (j == \"*\" or j == \"/\") or j == \"(\": temp.append(j)\n        elif j == \"+\" or j == \"-\":\n            if len(temp) > 0:\n                for k in reversed(temp):\n                    if k == \"*\" or k == \"/\": porand.append(temp.pop())\n                    else: break\n            temp.append(j)\n        elif j == \")\":\n            for k in reversed(temp):\n                if k == \"(\":\n                    temp.pop()\n                    break\n                porand.append(temp.pop())\n        elif j == \"=\":\n            for k in reversed(temp): porand.append(k)\n    print reduce(calc, porand, [])[-1]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport math\nimport re\n\nclass Num:\n    def __str__(self):\n        return str(self.x)\n\n    def __init__(self, value):\n        self.x = value\n\n    def __add__(self,value):\n        return Num(self.x + value.x)\n\n    def __sub__(self, value):\n        return Num(self.x - value.x)\n\n    def __mul__(self, value):\n        return Num(self.x * value.x)\n\n    def __truediv__(self,value):\n        return Num(int(self.x / value.x))\n\nn = int(input())\n\nfor i in range(n):\n    command = input().strip()\n    command = command.replace('=', '')\n    command = re.sub(r'(\\d+)', r'Num(\\1)', command)\n    print(eval(command))\n\n# Supplement\n\"\"\"\n>>> math.floor(0.5)\n0\n>>> -1 // 2\n-1\n>>> int(0.5)\n0\n>>> int(-0.5)\n0\n\"\"\""
  },
  {
    "language": "Python",
    "code": "n=input()\nfor i in range(n):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp,brac=None):\n    i = 0 # ループカウンタ?\n    num = deque() # 数字をためておく\n    ops = deque() # +-をためておく\n    ope = \"\" # */を保存\n    \n    if not brac:\n        # 対応する括弧の相対位置を記録しておいて計算量を削減\n        brac = [-1 for j in range(len(exp))]\n        tmpbrac = []\n        for j in range(len(exp) - 1, 0, -1):\n            if exp[j] == ')':\n                tmpbrac.append(j)\n            elif exp[j] == '(':\n                brac[j] = tmpbrac.pop() - j\n\n    # かっこの中身と乗除算\n    while i < len(exp):\n        # かっこの中身は再帰的に計算\n        if exp[i] == '(':\n            num.append(calc(exp[i + 1:i + brac[i]],brac[i+1:i+brac[i]]))\n            i += brac[i] - 1\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        elif exp[i].isnumeric():\n            temp = exp[i] # 数値 2桁以上にも対応させる\n            i += 1\n            while i < len(exp) and exp[i].isnumeric():\n                temp += exp[i]\n                i += 1\n            i -= 1 # 最後の数字に戻る(最後にi+=1しているのでこれでいい)\n            num.append(int(temp))\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        num.appendleft(eva(num.popleft(),num.popleft(),ops.popleft()))\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    print(calc(input()))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport re\n\nclass Num:\n    def __init__(this, x):\n        this.x = x\n\n    def __str__(this):\n        return str(this.x)\n\n    def __add__(this, that):\n        return Num(this.x + that.x)\n\n    def __sub__(this, that):\n        return Num(this.x - that.x)\n\n    def __truediv__(this, that):\n        return Num(int(this.x / that.x))\n\n    def __mul__(this, that):\n        return Num(this.x * that.x)\n\n    def __neg__(this):\n        return Num(-this.x)\n\nn = int(input())\nfor _ in range(n):\n    expr = input()[0:-1]\n    expr = re.sub(r'(\\d+)', r'Num(\\1)', expr)\n    print(eval(expr))"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  S+=[str(eval(s.pop(-2)+p+s.pop()))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    e = map(str, raw_input().split(\"/\"))\n    a = \"//\".join(map(str, e))\n    print eval(a[:len(a)-1])"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    inputCountent = string[:-1]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            elif item == \"/\":\n                result = num2 / num1\n\n            stack.append(result)\n\n    return stack[0]\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    result = Calculate(rpn)\n\n    print(result)\n\n"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "for i in range( int(raw_input()) ): print eval( raw_input()[:-1] )"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(str(answer))\n\n"
  },
  {
    "language": "Python",
    "code": "#n=int(input())\n\ndef lastfind(s,x):\n    n=len(s)\n    s_rev=s[::-1]\n    t=s_rev.find(x)\n    return n-t-1\ndef doublefind(s,x,y):\n    if x in s:\n        p=lastfind(s,x)\n    else:\n        p=-1\n    if y in s:\n        q=lastfind(s,y)\n    else:\n        q=-1\n    \n    if p==-1 and q==-1:\n        return 0\n    elif p<=q:\n        return [q,y]\n    else:\n        return [p,x]\n\ndef calculator(s):\n    if s==\"\":\n        return 0\n    \n    try:\n        return int(s)\n    except:\n        try:\n            x=doublefind(s,\"+\",\"-\")\n            if x[1]==\"+\":\n                return calculator(s[:x[0]:])+calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])-calculator(s[x[0]+1::])\n        except:\n            x=doublefind(s,\"*\",\"/\")\n            if x[1]==\"*\":\n                return calculator(s[:x[0]:])*calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])/calculator(s[x[0]+1::])\n\ndef calc(s):\n    while \"(\" in s:\n        closec=s.find(\")\")\n        openc=lastfind(s[:closec:],\"(\")\n        s=s[:openc:]+str(calculator(s[openc+1:closec:]))+s[closec+1::]\n        print (s)\n    return calculator(s)\n        \nn=int(input())\nfor count in range(n):\n    s=input()\n    print(int(calc(s[:-1:])))\n    "
  },
  {
    "language": "Python",
    "code": "def f1(line):\n    p = None\n    q = None\n    for i, s in enumerate(line):\n        if s == '(':\n            p = i\n        elif s == ')':\n            q = i\n        if q:\n            break\n    else:\n        return f2(line)\n    before = line[:p]\n    after = line[q + 1:]\n    x = f2(line[p + 1:q])\n    return f1(before + str(x) + after)\n\n\ndef f2(f_line):\n    foo = []\n    digit = ''\n    for x in f_line:\n        if x.isdigit():\n            digit += x\n        else:\n            foo.append(int(digit))\n            foo.append(x)\n            digit = ''\n    foo.append(int(digit))\n    return f3(foo, 'first')\n\n\ndef f3(foo, flg):\n    if len(foo) == 1:\n        return foo[0]\n    target = None\n    for i, fo in enumerate(foo):\n        if flg == 'first':\n            target = f4(foo, fo, i)\n        elif flg == 'second':\n            target = f5(foo, fo, i)\n        if target:\n            break\n    else:\n        flg = 'second'\n        return f3(foo, flg)\n    foo = foo[:i-1] + [target] + foo[i+2:]\n    return f3(foo, flg)\n\n\ndef f4(foo, fo, i):\n    target = None\n    if fo == '*':\n        target = foo[i-1] * foo[i+1]\n    elif fo == '/':\n        target = int(foo[i-1] / foo[i+1])\n    return target\n\n\ndef f5(foo, fo, i):\n    target = None\n    if fo == '+':\n        target = foo[i-1] + foo[i+1]\n    elif fo == '-':\n        target = foo[i-1] - foo[i+1]\n    return target\n\n\nfor _ in range(int(input())):\n    ans = f1(input()[:-1])\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import re\nclass Num:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self, value):\n        self.x = value\n    def __add__(self, value):\n        return Num(self.x + value.x)\n    def __sub__(self, value):\n        return Num(self.x - value.x)\n    def __mul__(self, value):\n        return Num(self.x * value.x)\n    def __truediv__(self, value):\n        return Num(int(self.x / value.x))\n\nN = int(input())\nfor i in range(N):\n    s = input()[:-1]\n    s = re.sub(r'(\\d+)',r'Num(\\1)',s)\n    print(eval(s))\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n\ta=input()\n\tb=\"\"\n\tfor i in a:\n\t\tb+=i\n\t\tif i=='/':b+='/'\n\tprint(int(eval(a[:len(a)-1])))"
  },
  {
    "language": "Python",
    "code": "import re\nn = int(input())\nfor i in range(n):\n    s = raw_input().split('=')\n    print(eval(s[0]))"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    s=raw_input()[:-1]\n    s=\"\".join(str(float(i)) if i.isdigit() else i for i in s)\n    print int(eval(s))"
  },
  {
    "language": "Python",
    "code": "import re\nclass c:\n\tdef __str__(self):\n\t\treturn str(self.x)\n\tdef __init__(self,value):\n\t\tself.x=value\n\tdef __add__(self,value):\n\t\treturn c(self.x+value.x)\n\tdef __sub__(self,value):\n\t\treturn c(self.x-value.x)\n\tdef __mul__(self,value):\n\t\treturn c(self.x*value.x)\n\tdef __truediv__(self,value):\n\t\treturn c(int(self.x/value.x))\nn=int(input())\nfor i in range(n):\n\ts=input()[:-1]\n\ts=re.sub(r'(\\d+)',r'c(\\1)',s)\n\tprint(eval(s))"
  },
  {
    "language": "Python",
    "code": "for _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=t\n P,S=[],[]\n table={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\n for i in L:\n  if i in'*/+-':\n   while S and table[S[-1]]>=table[i]:P+=S.pop()\n   S+=i\n  elif\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  if x in'+-*/':t=S.pop();S+=[str(int(eval(S.pop()+x+t)))]\n  else:S+=[x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            num.append(calc(exp[i+1:i+end]))\n            i += end\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(a,b,op):\n    if op == \"+\":\n        return b+a\n    if op == \"-\":\n        return b-a\n    if op == \"*\":\n        return b*a\n    if op == \"/\":\n        return b/a\ndef RPN(reg):\n    OP = [\"+\",\"-\",\"*\",\"/\"]\n    stack = []\n    for r in reg:\n        if r in OP:\n            stack.append(calc(stack.pop(),stack.pop(),r))\n        else:\n            r = int(r)\n            stack.append(r)\n    return stack[0]\ndef toRPN(exp):\n    OP = [\"+\",\"-\",\"*\",\"/\",\"(\",\")\"]\n    PR = {\"+\":1,\"-\":1,\"*\":2,\"/\":2,\"(\":0,\")\":0}\n    rpn = []\n    stack = []\n    for e in exp:\n        if e in OP:\n            if e == \"(\":\n                stack.append(e)\n            elif e == \")\":\n                while True:\n                    s = stack.pop()\n                    if s == \"(\":\n                        break\n                    rpn.append(s)\n            else:\n                stack.append(e)\n                while True:\n                    s = stack.pop()\n                    if (not stack) or s in [\"(\",\")\"] or (PR[stack[-1]] <= PR[s]):\n                        stack.append(s)\n                        break\n                    rpn.append(stack.pop())\n                    stack.append(s)\n        else:\n            rpn.append(e)\n    for s in stack[::-1]:\n        rpn.append(s)\n    return rpn\ndef splitEXP(st):\n    OP = [\"+\",\"-\",\"*\",\"/\",\"(\",\")\"]\n    temp = \"\"\n    exp = []\n    for s in st:\n        if s in OP:\n            if not temp == \"\":\n                exp.append(temp)\n                temp = \"\"\n            exp.append(s)\n        else:\n            temp += s\n    if not temp == \"\":\n        exp.append(temp)\n    return exp\n    \nif __name__ == \"__main__\":\n    \"\"\"\n    print toRPN([\"3\",\"+\",\"2\",\"/\",\"2\"])\n    print toRPN([\"(\",\"2\",\"+\",\"2\",\")\",\"/\",\"(\",\"2\",\"+\",\"2\",\")\"])\n    print toRPN([\"2\",\"/\",\"2\",\"+\",\"2\",\"/\",\"2\",\"+\",\"2\",\"/\",\"2\"])\n    \"\"\"\n    for u in xrange(input()):\n        exp = splitEXP(raw_input().strip(\"=\"))\n        print RPN(toRPN(exp))"
  },
  {
    "language": "Python",
    "code": "pos = 0\ndef number(s):\n\tglobal pos\n\tx = pos\n\tif s[pos] == '-' or s[pos] == '+':\n\t\tpos += 1\n\twhile s[pos].isdigit():\n\t\tpos += 1\n\treturn int(s[x:pos])\nexpression = None\ndef factor(s):\n\tglobal pos\n\tif s[pos] == '(':\n\t\tpos += 1\n\t\tresult = expression(s)\n\t\tpos += 1\n\t\treturn result\n\telse:\n\t\treturn number(s)\ndef term(s):\n\tglobal pos\n\tresult = factor(s)\n\twhile True:\n\t\tif s[pos] == '*':\n\t\t\tpos += 1\n\t\t\tresult *= factor(s)\n\t\telif s[pos] == '/':\n\t\t\tpos += 1\n\t\t\tx = factor(s)\n\t\t\tresult = int(result / abs(x)) * cmp(x, 0)\n\t\telse:\n\t\t\tbreak\n\treturn result\ndef _expression(s):\n\tglobal pos\n\tresult = term(s)\n\twhile True:\n\t\tif s[pos] == '+':\n\t\t\tpos += 1\n\t\t\tresult += term(s)\n\t\telif s[pos] == '-':\n\t\t\tpos += 1\n\t\t\tresult -= term(s)\n\t\telse:\n\t\t\tbreak\n\treturn result\nexpression = _expression\n\nfor i in xrange(input()):\n\tpos = 0\n\tprint expression(raw_input())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport re\nn = int(input())\nfor _ in range(n):\n    print(eval(re.sub(r'(\\d+/\\d+)', r'int(\\1)', input()[0:-1])))"
  },
  {
    "language": "Python",
    "code": "n=input()\nfor _ in [0]*n: \n  print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# ???????????????????¨?????????°???????????????????????????????????????????????????\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + float(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + float(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * float(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n    \n    return St[0]\n\n\n# ??????????????????????????????????????¬??§?????°???????????????????????????????????????\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n# ???????¨?????????°????????????????????????????????????????¨?????????°????????????????????????\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and table[S[-1]] >= table[i]:\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n        \n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n\"\"\"\nimport sys\n\n\ndef solve(exp):\n    exp = exp.replace('=', '')\n    exp = exp.replace('/', '//')\n    return eval(exp)\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        expression = input().strip()\n        result = solve(expression)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def calc(array):\n\twhile not len(array) == 1:\n\t\tif '*' in array:\n\t\t\tx = array.index('*')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) * int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\t\tif '/' in array:\n\t\t\tx = array.index('/')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) / int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\t\tif '-' in array:\n\t\t\tx = array.index('-')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) - int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\t\tif '+' in array:\n\t\t\tx = array.index('+')\n\t\t\tarray[x + 1] = str(int(array[x - 1]) + int(array[x + 1]))\n\t\t\tdel array[x - 1:x + 1]\n\t\t\tcontinue\n\treturn str(array[0])\n\nn = input()\nfor i in xrange(n):\n\tarray = list(raw_input())\n\t\n\twhile '(' in array:\n\t\tx1 = array.index('(') + 1\n\t\tx2 = array.index(')')\n\t\tjon = array[x1:x2]\n\t\tarray[x2] = calc(jon)\n\t\tdel array[x1 - 1:x2]\n\tprint calc(array[0:len(array) - 1])"
  },
  {
    "language": "Python",
    "code": "def f(s):\n  while 1:\n    b=s.find(\")\")\n    if b<0: return g(s)\n    a=s[:b].rfind(\"(\")\n    s=s.replace(s[a:b+1],f(s[a+1:b]))\n\ndef g(s):\n  a=\"\"\n  f=1\n  x=[]\n  def F(a,b):\n    x.append(a)\n    x.append(b)\n    return 1,\"\"\n  for c in s:\n    if c==\"=\": continue\n    elif c in \"*/\": f,a=F(a,c)\n    elif c in \"+-\":\n      if f==1: f,a=0,c\n      else: f,a=F(a,c)\n    else: f,a=0,a+c\n  x.append(a)\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e in \"+-\": x.append(e)\n    elif e in \"*/\": f=e\n    else:\n      a=int(e)\n      if f==\"*\": a*=x.pop()\n      elif f==\"/\": a=int(1.0*x.pop()/a)\n      x.append(a)\n      f=\"\"\n\n  a,f=0,1\n  for e in x:\n    if e==\"+\": f=1\n    elif e==\"-\": f=-1\n    else: a+=f*e\n  return str(a)\n\nn=input()\nfor _ in [0]*n:\n  print f(raw_input())"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n    s=input()\n    print(s)\n    \n"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  S+=[str(eval(S.pop(-2)+p+S.pop()))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        try:\n            if exp[i] == '(':\n                end = 1\n                s = 1\n                while True:\n                    if exp[i+end] == \"(\":\n                        s += 1\n                    elif exp[i+end] == \")\":\n                        s -= 1\n                    if s == 0:\n                        break\n                    end += 1\n                num.append(calc(exp[i+1:i+end]))\n                i += end\n                if ope:\n                    l = num.pop()\n                    r = num.pop()\n                    num.append(eva(l, r, ope))\n                    ope = \"\"\n            if exp[i] in [\"*\", \"/\"]:\n                ope = exp[i]\n            elif exp[i] in [\"+\", \"-\"]:\n                ops.append(exp[i])\n            elif exp[i] == \"=\":\n                pass\n            else:\n                temp = \"\"\n                j = 0\n                while i + j < len(exp) and exp[i+j].isnumeric():\n                    temp += exp[i+j]\n                    j += 1\n                num.append(int(temp))\n                i += j - 1\n                if ope:\n                    num.append(eva(num.pop(), num.pop(), ope))\n                    ope = \"\"\n            i += 1\n        except:\n            stderr.write(exp)\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n# N = int(input())\n# for i in range(N):\n#     print(int(eval(input().replace(\"/\", \"//\").strip(\"=\"))))\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n    s=input()\n    print(int(eval(s[0:-1])))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\nfrom functools import reduce\nfrom operator import add\ndef f(): return [int(i) for i in input().split()]\ndef debug(*x, sep=\" \", end=\"\\n\"):\n    for item in x:\n        stderr.write(repr(item))\n        stderr.write(sep)\n    stderr.write(end)\n\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = exp[i:].rfind(\")\")\n            num.append(calc(exp[i+1:i+end]))\n            i += end + 1\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i].isnumeric():\n            num.append(int(exp[i]))\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            break\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    debug(exp, num)\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    line = raw_input()\n    if line == '':\n        break\n\n    n = int(line)\n    for i in range(n):\n        print eval(raw_input().replace('/', '//')[:-1])"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput()\nfor i in sys.stdin.readlines():\n        print(int(eval(i[:-2])))"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):print(eval(input()[:-1].replace('/', '//')))"
  },
  {
    "language": "Python",
    "code": "def calc(array):\n\twhile '(' in array:\n\t\tc1 = array.index('(')\n\t\tc2 = array.index(')')\n\t\tarray[c2] = calc(array[c1 + 1:c2])\n\t\tdel array[c1:c2]\n\twhile len(array) > 1:\n\t\tif '/' in array:\n\t\t\tc = array.index('/')\n\t\t\tarray[c + 1] = int(array[c - 1] / array[c + 1])\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '*' in array:\n\t\t\tc = array.index('*')\n\t\t\tarray[c + 1] = array[c - 1] * array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '-' in array:\n\t\t\tc = array.index('-')\n\t\t\tarray[c + 1] = array[c - 1] - array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '+' in array:\n\t\t\tc = array.index('+')\n\t\t\tarray[c + 1] = array[c - 1] + array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\treturn array[0]\n\nn = input()\nfor i in range(n):\n\tconflict = []\n\tfor var in list(raw_input()):\n\t\ttry:\n\t\t\tconflict.append(int(var))\n\t\texcept:\n\t\t\tconflict.append(var)\n\tprint calc(conflict[0:len(conflict) - 1])"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor i in range(n):\n    eq = input().replace(\"=\",\"\")\n    print(eval(eq))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\n\nfor t in range(n):\n    s=input()\n    s=s[:-1]\n    s=s.replace(\"/\",\"//\")\n    print(eval(s))"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    e = map(str, raw_input().split(\"/\"))\n    a = \"//\".join(map(str, e))\n    print eval(a[:-1])"
  },
  {
    "language": "Python",
    "code": "pos = 0\ndef number(s):\n\tglobal pos\n\tx = pos\n\twhile s[pos].isdigit():\n\t\tpos += 1\n\treturn int(s[x:pos])\nexpression = None\ndef factor(s):\n\tglobal pos\n\tif s[pos] == '(':\n\t\tpos += 1\n\t\tresult = expression(s)\n\t\tpos += 1\n\t\treturn result\n\telse:\n\t\treturn number(s)\ndef term(s):\n\tglobal pos\n\tresult = factor(s)\n\twhile True:\n\t\tif s[pos] == '*':\n\t\t\tpos += 1\n\t\t\tresult *= factor(s)\n\t\telif s[pos] == '/':\n\t\t\tpos += 1\n\t\t\tresult = int(result / factor(s))\n\t\telse:\n\t\t\tbreak\n\treturn result\ndef _expression(s):\n\tglobal pos\n\tresult = term(s)\n\twhile True:\n\t\tif s[pos] == '+':\n\t\t\tpos += 1\n\t\t\tresult += term(s)\n\t\telif s[pos] == '-':\n\t\t\tpos += 1\n\t\t\tresult -= term(s)\n\t\telse:\n\t\t\tbreak\n\treturn result\nexpression = _expression\n\nn = input()\nfor i in xrange(n):\n\tpos = 0\n\tprint expression(raw_input())"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "for t in xrange(input()):\n\tprint eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "import re\nclass c:\n def __init__(self,value):self.x=value\n def __str__(self):return str(self.x)\n def __add__(self,value):return c(self.x+value.x)\n def __sub__(self,value):return c(self.x-value.x)\n def __mul__(self,value):return c(self.x*value.x)\n def __truediv__(self,value):return c(int(self.x/value.x))\nfor i in[0]*int(input()):print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor i in range(n):\n    s = raw_input().split('=')\n    print(eval(s[0]))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor i in range(n):\n    eq = input().replace(\"/\",\"//\").replace(\"=\",\"\")\n    print(eval(eq))"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint(eval(input().replace(\"=\",\"\")))"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    e = map(str, raw_input().split(\"/\"))\n    a = \"//\".join(map(str, e))\n    print eval(a[:len(a)-1])"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n  print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef Calculate_RPN(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\n\nn = int(raw_input())\n\nfor i in xrange(n):\n    s = raw_input()\n    print Calculate_RPN(Generate_RPN(String2List(s)))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n    isContinue = False\n\n    for item in string[:-1]:\n\n        if str.isnumeric(item):\n            if not isContinue:\n                stack.append(item)\n                isContinue = True\n            else:\n                stack[-1] += item\n            continue\n        elif item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if priority[item] <= priority[signStack[-1]]:\n                while signStack[-1] != \"(\" and signStack[-1] != \"Sentinel\":\n                    stack.append(signStack.pop())\n\n            signStack.append(item)\n\n        isContinue = False\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1 // 1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit()\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        tmp = _split(_src[1:])\n        if tmp != [] and tmp[0] == \"-\":\n            tmp = [\"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n        return [_src[0]] + tmp\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = len(src) - 1 - src[::-1].index(\")\")\n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = \"0+\" + raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "import sys\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        print(eval(sys.stdin.readline()[:-1].strip(\"=\").replace(\"/\",\"//\")))\n \nsolve()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    try:\n        i = 0\n        num = deque()\n        ops = deque()\n        ope = \"\"\n        while i < len(exp):\n            if exp[i] == '(':\n                end = 1\n                s = 1\n                while True:\n                    if exp[i+end] == \"(\":\n                        s += 1\n                    elif exp[i+end] == \")\":\n                        s -= 1\n                    if s == 0:\n                        break\n                    end += 1\n                num.append(calc(exp[i+1:i+end]))\n                i += end\n                if ope:\n                    l = num.pop()\n                    r = num.pop()\n                    num.append(eva(l, r, ope))\n                    ope = \"\"\n            if exp[i] in [\"*\", \"/\"]:\n                ope = exp[i]\n            elif exp[i] in [\"+\", \"-\"]:\n                ops.append(exp[i])\n            elif exp[i] == \"=\":\n                pass\n            else:\n                temp = \"\"\n                j = 0\n                while i + j < len(exp) and exp[i+j].isnumeric():\n                    temp += exp[i+j]\n                    j += 1\n                num.append(int(temp))\n                i += j - 1\n                if ope:\n                    num.append(eva(num.pop(), num.pop(), ope))\n                    ope = \"\"\n            i += 1\n        while len(ops) != 0:\n            l = num.popleft()\n            r = num.popleft()\n            num.appendleft(eva(l,r,ops.popleft()))\n    except:\n        stderr.write(exp)\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfor s in sys.stdin:\n\tif '=' in s:\n\t\tprint eval(s.strip().strip('='))"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor i in range(int(n)):\n    command = input()\n    answer = eval(command[0:-1])\n    print(answer)"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):\n    print(eval(input()[:-1].replace('/', '//')))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n\"\"\"\nimport sys\n\n\ndef solve(exp):\n    exp = exp.replace('=', '')\n    #exp = exp.replace('/', '//')\n    return int(eval(exp))\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        expression = input().strip()\n        result = solve(expression)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "[print(int(eval(input()[:-1]))) for i in range(int(input()))]\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput()\nfor i in sys.stdin.readlines():\n        print(int(eval(i[:-2].replace('/', '//'))))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1\n                result = int(result)\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(str(answer))\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# ??????????????????????????????????????¬??§?????°???????????????????????????????????????\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\n# ???????¨?????????°????????????????????????????????????????¨?????????°????????????????????????\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\n# ???????????????????¨?????????°???????????????????????????????????????????????????\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n    if St[0] == -0.0:\n        return 0.0\n    else:\n        return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):\n    print(eval(input().replace('/', '//')[:-1]))"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint input().strip(\"=\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = exp[i + 1:].index(\")\")\n            num.append(calc(exp[i + 1:i + 1 + end]))\n            i += end\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        if exp[i].isnumeric():\n            num.append(int(exp[i]))\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            break\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n"
  },
  {
    "language": "Python",
    "code": "import re\nclass c:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self,n):\n        self.x=n\n    def __add__(self,n):\n        return c(self.x+n.x)\n    def __sub__(self,n):\n        return c(self.x-n.x)\n    def __mul__(self,n):\n        return c(self.x*n.x)\n    def __truediv__(self,n):\n        return c(self.x//n.x)\n  \nfor _ in range(int(input())):\n    print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        tmp = _split(_src[1:])\n        if tmp != [] and tmp[0] == \"-\":\n            tmp = [\"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n        return [_src[0]] + tmp\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = \"0+\" + raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor tc in range(0,T) :\n\tprint eval(raw_input().strip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef Calculate_RPN(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\nn = int(raw_input())\n\nfor _ in xrange(n):\n    s = raw_input()\n    print Calculate_RPN(Generate_RPN(String2List(s)))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nfor i in range(N):\n    print(eval(input().strip(\"=\")))\n"
  },
  {
    "language": "Python",
    "code": "def RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + float(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + float(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * float(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n    \n    return St[0]\n\n\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and table[S[-1]] >= table[i]:\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef main():\n    N = int(raw_input())\n\n    for i in range(N):\n        s = raw_input()\n        L = String2List(s[:-1])\n        L = RPN_list(L)\n        print int(RPN_cul(L))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    add = ''\n    if gemstone[0] == '-':\n        gemstone = gemstone[1:]\n        add = '-'\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(add+n)\n            lis.append(c)\n            n = ''\n            add = ''\n    else:\n        lis.append(add+n)\n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n        if o1 < 0: r += 1\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "import sys\n#from me.io import dup_file_stdin\n\ndef prec(op):\n    if op in \"+-\":return 1\n    if op in \"*/\":return 2\n    raise NotImplementedError()\n    \ndef postFix(expr):\n    stack = []\n    operators = []\n    num = 0\n    isdigit = False\n    for ch in expr:\n        if ch.isdigit():\n            isdigit = True\n            num*=10\n            num+=int(ch)\n            continue\n        else :\n            if isdigit:\n                stack.append(num)\n                num = 0\n            isdigit = False\n            \n            if ch == ')':\n                while len(operators) > 0:\n                    op = operators.pop()\n                    if op == '(':\n                        break\n                    else:\n                        stack.append(op)\n                else:\n                    raise ValueError\n            elif ch == '(':\n                operators.append(ch)\n            else:\n                while len(operators) > 0 and operators[-1]!='(' and prec(operators[-1]) >= prec(ch):\n                    stack.append(operators.pop())\n                operators.append(ch)\n    if isdigit:\n        stack.append(num)\n    for op in operators[::-1]:\n        if op not in \"()\":\n            stack.append(op)\n    return stack\n        \ndef evaluate(stack):\n    op = stack.pop()\n    if type(op) is int:\n        return op;\n    else:\n        b = evaluate(stack);\n        a = evaluate(stack);\n        return int(eval(str(a)+op+str(b)))\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        expr = sys.stdin.readline()[:-1].strip(\"=\")\n        print(postFix(expr))\n        print(evaluate(postFix(expr)))\n        \nsolve()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport re\nn = input()\nfor i in xrange(n):\n\tline = raw_input()\n\tre.sub(\"\\.\\d*\", \"\", line)\n\texec(\"x = %s\" % line[:-1])\n\tprint x"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nn = int(input())\n\nfor i in range(n):\n    command = input().strip()\n    command = command.replace('=', '')\n    command = command.replace('/', '//')\n    print(command)\n    print(int(eval(command)))"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n        \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            lis.append(n)\n            lis.append(c)\n            n = ''\n    else:\n        lis.append(n)\n        \n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor i in range(n):\n    s = raw_input()[:-1]\n    print eval(s)"
  },
  {
    "language": "Python",
    "code": "ol = input()\nfor oi in xrange(ol):\n\ts = raw_input()\n\ts = s[:-1]\n\tr = eval(s)\n\tprint r"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif s=='':\n\t\treturn 0\n\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\t\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\t\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\tprint test(raw_input()[:-1])\n\nmain()"
  },
  {
    "language": "Python",
    "code": "n = int(input())\n[print(eval(input()[:-1])) for i in range(n)]"
  },
  {
    "language": "Python",
    "code": "import re\nimport decimal\n\ndef main():\n    decimal.getcontext().rounding = decimal.ROUND_DOWN\n    n = int(input())\n    for i in range(n):\n        s = input()\n        s = re.sub(r'(\\d+)', r'decimal.Decimal(\\1)', s).replace('=', '').replace('/', '//')\n        print(int(eval(s)))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def get_input():\n    while True:\n        try:\n            yield ''.join(input())\n        except EOFError:\n            break\n\nN = int(input())\nfor l in range(N):\n    S = input()\n    if S == \"exit\":\n        break\n    S = S[0:len(S)-1]\n    print(eval(S))\n\n"
  },
  {
    "language": "Python",
    "code": "def f1(line):\n    p = None\n    q = None\n    for i, s in enumerate(line):\n        if s == '(':\n            p = i\n        elif s == ')':\n            q = i\n        if q:\n            break\n    else:\n        return f2(line)\n    before = line[:p]\n    after = line[q + 1:]\n    x = f2(line[p + 1:q])\n    return f1(before + str(x) + after)\n\n\ndef f2(f_line):\n    foo = []\n    digit = ''\n    for x in f_line:\n        if x.isdigit():\n            digit += x\n        else:\n            foo.append(int(digit))\n            foo.append(x)\n            digit = ''\n    foo.append(int(digit))\n    return f3(foo, 'first')\n\n\ndef f3(foo, flg):\n    if len(foo) == 1:\n        return foo[0]\n    target = None\n    for i, fo in enumerate(foo):\n        if flg == 'first':\n            target = f4(foo, fo, i)\n        elif flg == 'second':\n            target = f5(foo, fo, i)\n        if target:\n            break\n    else:\n        flg = 'second'\n        return f3(foo, flg)\n    foo = foo[:i-1] + [target] + foo[i+2:]\n    return f3(foo, flg)\n\n\ndef f4(foo, fo, i):\n    target = None\n    if fo == '*':\n        target = foo[i-1] * foo[i+1]\n    elif fo == '/':\n        target = int(foo[i-1] / foo[i+1])\n    return target\n\n\ndef f5(foo, fo, i):\n    target = None\n    if fo == '+':\n        target = foo[i-1] + foo[i+1]\n    elif fo == '-':\n        target = int(foo[i-1] - foo[i+1])\n    return target\n\n\nfor _ in range(int(input())):\n    input_line = input()\n    ans = f1(input_line[:-1])\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n    print(input())\n\n"
  },
  {
    "language": "Python",
    "code": "for _ in range(input()):print(eval(raw_input()[:-1]))"
  },
  {
    "language": "Python",
    "code": "r=[eval(input()[:-1].replace(\"/\",\"//\")) for i in range(int(input()))]\n[print(i) for i in r]\n\n"
  },
  {
    "language": "Python",
    "code": "\nn = int(input())\nfor i in range(n):\n    s = input()\n    print(s)"
  },
  {
    "language": "Python",
    "code": "# AOJ 0109 Smart Calculator\n# Python3 2018.6.18 bal4u\n\nINF = 1000000010\nLEFT  = INF+1\nRIGHT = INF+2\nPLUS  = INF+3\nMINUS = INF+4\nMUL   = INF+5\nDIV   = INF+6\ntoken = { '+':PLUS, '-':MINUS, '*':MUL, '/':DIV }\nrank = { PLUS:2, MINUS:2, MUL:3, DIV:3, LEFT:1, RIGHT:1 }\n\nS, top = [0]*200, 0\nQ, end = [0]*200, 0\n\ndef getInt():\n\tglobal id\n\tk = ''\n\twhile buf[id] >= '0' and buf[id] <= '9':\n\t\tk += buf[id]\n\t\tid += 1\n\treturn int(k)\n\nn = int(input())\nfor i in range(n):\n\tbuf = list(input())\n\tid, f, top, end = 0, True, 0, 0\n\twhile True:\n\t\tif buf[id] == '=':\n\t\t\twhile top > 0:\n\t\t\t\ttop -= 1\n\t\t\t\tQ[end] = S[top]\n\t\t\t\tend += 1\n\t\t\tbreak;\n\t\tif buf[id] == '-' and f and buf[id+1] >= '0' and buf[id+1] <= '9':\n\t\t\tid += 1\n\t\t\tQ[end] = -getInt()\n\t\t\tend += 1\n\t\t\tf = False\n\t\t\tcontinue\n\t\t\n\t\tf = False\n\t\tif buf[id] >= '0' and buf[id] <= '9':\n\t\t\tQ[end] = getInt()\n\t\t\tend += 1\n\t\telif buf[id] == ')':\n\t\t\twhile S[top - 1] != LEFT:\n\t\t\t\ttop -= 1\n\t\t\t\tQ[end] = S[top]\n\t\t\t\tend += 1\n\t\t\ttop -= 1\n\t\t\tid += 1\n\t\telif buf[id] == '(':\n\t\t\tS[top] = LEFT\n\t\t\ttop += 1\n\t\t\tid += 1\n\t\t\tf = True\n\t\telse:\n\t\t\tk = token[buf[id]]\n\t\t\tid += 1\n\t\t\twhile top > 0:\n\t\t\t\tif rank[k] <= rank[S[top-1]]:\n\t\t\t\t\ttop -= 1\n\t\t\t\t\tQ[end] = S[top];\n\t\t\t\t\tend += 1\n\t\t\t\telse: break\n\t\t\tS[top] = k;\n\t\t\ttop += 1\n\ttop = 0\n\tfor i in range(end):\n\t\tk = Q[i]\n\t\tif k > INF:\n\t\t\td1, d2 = S[top-1], S[top-2]\n\t\t\ttop -= 2\n\t\t\tif k == PLUS: d2 += d1\n\t\t\telif k == MINUS: d2 -= d1\n\t\t\telif k == MUL: d2 *= d1\n\t\t\telse: d2 //= d1\n\t\t\tS[top] = d2\n\t\telse: S[top] = k\n\t\ttop += 1\n\tprint(S[top-1])\n"
  },
  {
    "language": "Python",
    "code": "for i in range(int(raw_input())):\n\tprint eval(raw_input()[:-1]);"
  },
  {
    "language": "Python",
    "code": "import sys\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        print(eval(sys.stdin.readline()[:-2]))\n \nsolve()\n        "
  },
  {
    "language": "Python",
    "code": "def calc(eqt):\n  l = eqt.split(\"+\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])+calc(l[1]))\n  l = eqt.split(\"-\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])-calc(l[1]))\n  l = eqt.split(\"*\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])*calc(l[1]))\n  l = eqt.split(\"/\",maxsplit=1)\n  if len(l) == 2:\n    return (calc(l[0])//calc(l[1]))\n  return (int(eqt))\n\ndef unfold_brackets(eqt):\n  l = eqt.split(')',maxsplit=1)\n  if len(l) == 1:\n    return calc(eqt)\n  else:\n    ll = l[0].rsplit('(',maxsplit=1)\n    ll.append(l[1])\n    ll[1] = str(calc(ll[1]))\n    l=\"\".join(ll)\n    return unfold_brackets(l)\n\nn=int(input())\ndatasets=[input() for i in range(n)]\nfor line in datasets:\n  l = line.split(\"=\",maxsplit=1)[0]\n  print(unfold_brackets(l))"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    print eval(\"\".join([i for i in raw_input() if i!=\"=\"]))"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit()\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        tmp = _split(_src[1:])\n        if tmp != [] and tmp[0] == \"-\":\n            tmp = [\"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n        return [_src[0]] + tmp\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = src.index(\")\")\n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = \"0+\" + raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "for i in range(int(raw_input())):\n    print eval(raw_input().rstrip(' \\t\\r\\n='))"
  },
  {
    "language": "Python",
    "code": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef Calculate_RPN(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = Generate_RPN(String2List(s[:-1]))\n    print int(Calculate_RPN(L))"
  },
  {
    "language": "Python",
    "code": "def f(s):\n  while 1:\n    b=s.find(\")\")\n    if b<0: return g(s)\n    a=s[:b].rfind(\"(\")\n    s=s.replace(s[a:b+1],f(s[a+1:b]))\n\ndef g(s):\n  a=\"\"\n  f=1\n  x=[]\n  def F(a,b):\n    x.append(a)\n    x.append(b)\n    return 1,\"\"\n  for c in s:\n    if c==\"=\": continue\n    elif c in \"*/\": f,a=F(a,c)\n    elif c in \"+-\":\n      if f==1: f,a=0,c\n      else: f,a=F(a,c)\n    else: f,a=0,a+c\n  x.append(a)\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e in \"+-\": x.append(e)\n    elif e in \"*/\": f=e\n    else:\n      a=int(e)\n      if f==\"*\": a*=x.pop()\n      elif f==\"/\": a=int(1.0*x.pop()/a)\n      x.append(a)\n      f=\"\"\n  x=\"\".join(map(str,x))\n  return str(eval(x))\n\nn=input()\nfor _ in [0]*n:\n  print f(raw_input())"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    print int((eval(\"\".join([str(float(i)) if i.isdigit() else i for i in raw_input() if i!=\"=\"]))))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nfor i in range(N):\n    print(int(eval(input().strip(\"=\"))))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    stderr.write(exp)\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            num.append(calc(exp[i+1:i+end]))\n            i += end\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n"
  },
  {
    "language": "Python",
    "code": "for i in range(int(raw_input())):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n    def __add__(self,n):\n        return c(int(self)+int(n))\n    def __sub__(self,n):\n        return c(int(self)-int(n))\n    def __mul__(self,n):\n        return c(int(self)*int(n))\n    def __floordiv__(self,n):\n        return c(int(self)//int(n))\n\nfor _ in range(int(input())):\n    f = input().replace('/','//')[:-1]\n    f = eval(re.sub(r'(\\d+)',r'c(\\1)',f))\n    print(f)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    line = raw_input()\n    if line == '':\n        break\n\n    for i in range(int(line)):\n        a = eval(raw_input().replace('/', '//')[:-1])\n        sys.stderr.write(str(a))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor _ in range (n):\n    print(eval(input().rstrip('=').replace('/','//')))"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n    \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    add = ''\n    if gemstone[0] == '-':\n        gemstone = gemstone[1:]\n        add = '-'\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            if n == '':\n                add = '-'\n            else:\n                lis.append(add+n)\n                lis.append(c)\n                n = ''\n                add = ''\n    else:\n        lis.append(add+n)\n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n        if o1 < 0 and o1 % o2 != 0: r += 1\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nn = int(input())\n\nfor _ in range(n):\n    print(eval(input()[0:-1]))"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit(0)\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        tmp = _split(_src[1:])\n        if tmp != [] and tmp[0] == \"-\":\n            tmp = [\"(\", 0 , \"-\", 1, \")\", \"*\"] + tmp[1:]\n        return [_src[0]] + tmp\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = src.index(\")\")\n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n    exit()\n     \nfor t in xrange(input()):\n    _src = \"0+\" + raw_input()[:-1]\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "import re\nn = int(input())\nfor _ in range(n):\n    expr = input()[0:-1]\n    print(eval(expr))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = 0\n            num2 = 0\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n\n\nclass Scanner:\n    def __init__(self, str):\n        str = str.rstrip('=')\n        str = '(' + str + ')'\n        self.tokens = self.tokenize(str)\n\n    def tokenize(self, str):\n        x = list(str)\n        t = []\n        while True:\n            if not x:\n                break\n            c = x.pop(0)\n            if c == '(':\n                t.append(c)\n            elif c == ')':\n                t.append(c)\n            elif c == '+':\n                t.append(c)\n            elif c == '-':\n                t.append(c)\n            elif c == '*':\n                t.append(c)\n            elif c == '/':\n                t.append(c)\n            else:\n                while True:\n                    if len(x) > 0 and x[0].isdigit():\n                        c = c + x.pop(0)\n                    else:\n                        break\n                t.append(c)\n        return t\n\n    def next(self):\n        if self.tokens:\n            return self.tokens.pop(0)\n        else:\n            return None\n\n\n\nclass Calculator:\n    def __init__(self, scanner):\n        self.scanner = scanner\n        self.stack = []\n\n    def calc(self):\n        while True:\n            t = self.scanner.next()\n            if t:\n                if t == ')':\n                    e = t\n                    while True:\n                        t2 = self.stack.pop()\n                        if not t2 == '(':\n                            e = t2 + e\n                        else:\n                            e = t2 + e\n                            e = ''.join(e)\n                            r = eval(e)\n                            self.stack.append(str(r))\n                            break\n                else:\n                    self.stack.append(t)\n            else:\n                return self.stack.pop()\n\n\n\ndef solv(expr):\n    scanner = Scanner(expr)\n    calculator = Calculator(scanner)\n    return calculator.calc()\n\n\nwhile True:\n    try:\n        n = int(sys.stdin.readline())\n        for i in range(n):\n            expr = sys.stdin.readline().rstrip('\\n')\n            print solv(expr)\n    except:\n        exit()"
  },
  {
    "language": "Python",
    "code": "r={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in r:\n   while S and r[S[-1]]>=r[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  if x in'+-*/':t=S.pop();S+=[str(int(eval(S.pop()+x+t)))]\n  else:S+=[x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nprint(*[eval(input()[:-1].replace(\"/\", \"//\")) for _ in range(int(input()))], sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif s=='':\n\t\treturn 0\n\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\t\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return calc(s[:p])/calc(s[p+1:])\n\t\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\ts=raw_input()[:-1]\n\t\tprint calc(s) #, eval(s)\n\nmain()\n\n#?????????WA??????"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    e = map(str, raw_input().split(\"/\"))\n    a = \"//\".join(map(str, e))\n    print eval(a[:-1])"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    a = raw_input()\n    print eval(a[:-1])"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\nfor loop in xrange(N):\n    print eval(raw_input().replace(\"/\",\"//\"))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            num.append(calc(exp[i+1:i+end]))\n            i += end\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n# N = int(input())\n# for i in range(N):\n#     print(int(eval(input().replace(\"/\", \"//\").strip(\"=\"))))\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    line = raw_input()\n    if line == '':\n        break\n\n    n = int(line)\n    for i in range(n):\n        print eval(raw_input().strip()[:-1])"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\n# generate Reverse Polish Notation\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\n# calculate Reverse Polish Notation\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n    print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n    def __add__(self,n):\n        return c(int(self)+int(n))\n    def __sub__(self,n):\n        return c(int(self)-int(n))\n    def __mul__(self,n):\n        return c(int(self)*int(n))\n    def __truediv__(self,n):\n        return c(int(self)//int(n))\n \nfor _ in range(int(input())):\n    print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))"
  },
  {
    "language": "Python",
    "code": "import re\n\nclass Num:\n    def __init__(self, x):\n        self.x = x\n\n    def __str__(self):\n        return str(self.x)\n\n    def __add__(self, other):\n        return Num(self.x + other.x)\n\n    def __sub__(self, other):\n        return Num(self.x - other.x)\n\n    def __truediv__(self, other):\n        return Num(int(self.x / other.x))\n\n    def __mul__(self, other):\n        return Num(self.x * other.x)\n\n    def __neg__(self):\n        return Num(-self.x)\n\nn = int(input())\nfor _ in range(n):\n    expr = input()[0:-1]\n    expr = re.sub(r'(\\d+)', r'Num(\\1)', expr)\n    print(eval(expr))"
  },
  {
    "language": "Python",
    "code": "def calc(array):\n\twhile len(array) > 1:\n\t\tif '/' in array:\n\t\t\tc = array.index('/')\n\t\t\tarray[c + 1] = array[c - 1] / array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\t\tif '*' in array:\n\t\t\tc = array.index('*')\n\t\t\tarray[c + 1] = array[c - 1] * array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\t\tif '-' in array:\n\t\t\tc = array.index('-')\n\t\t\tarray[c + 1] = array[c - 1] - array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\t\tif '+' in array:\n\t\t\tc = array.index('+')\n\t\t\tarray[c + 1] = array[c - 1] + array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\treturn array[0]\n\nn = input()\nfor i in range(n):\n\tconflict = []\n\tfor var in list(raw_input()):\n\t\ttry:\n\t\t\tconflict.append(int(var))\n\t\texcept:\n\t\t\tconflict.append(var)\n\twhile '(' in conflict:\n\t\tc1 = conflict.index('(')\n\t\tc2 = conflict.index(')')\n\t\tconflict[c2] = calc(conflict[c1 + 1:c2])\n\t\tdel conflict[c1:c2]\n\tprint calc(conflict[0:len(conflict) - 1])"
  },
  {
    "language": "Python",
    "code": "for i in xrange(int(raw_input())):\n\ts = raw_input()\n\tprint eval(s[:-1])"
  },
  {
    "language": "Python",
    "code": "# Edit: 2014/09/26\n# Lang: Python3\n# Time: 0.xxs\n#\n\nif __name__ == \"__main__\":\n    n = int(input())\n    for i in range(n):\n        print(eval(input().strip(\"=\").replace(\"/\",\"//\")))"
  },
  {
    "language": "Python",
    "code": "for i in range(int(raw_input())):\n    eval(raw_input()[:-1]);"
  },
  {
    "language": "Python",
    "code": "import re\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        expr = sys.stdin.readline()[:-1].strip(\"=\")\n        expr = re.sub(\".d+\",\"\",expr)\n        print(eval(expr.replace(\"/\",\"//\")))\n \nsolve()"
  },
  {
    "language": "Python",
    "code": "r={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=t\n P,S=[],[]\n for i in L:\n  if i in'*/+-':\n   while S and r[S[-1]]>=r[i]:P+=S.pop()\n   S+=i\n  elif\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  if x in'+-*/':t=S.pop();S+=[str(int(eval(S.pop()+x+t)))]\n  else:S+=[x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "def f(s):\n  while 1:\n    b=s.find(\")\")\n    if b<0: return g(s)\n    a=s[:b].rfind(\"(\")\n    s1=s[a:b+1]\n    s=s.replace(s1,f(s1[1:-1]))\n\ndef g(s):\n  a=\"\"\n  f=1\n  x=[]\n  def F(a,b):\n    x.append(a)\n    x.append(b)\n    return 1,\"\"\n  for c in s:\n    if c==\"=\": continue\n    elif c in \"*/\": f,a=F(a,c)\n    elif c in \"+-\":\n      if f==1: f,a=0,c\n      else: f,a=F(a,c)\n    else: f,a=0,a+c\n  x.append(a)\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e in \"+-\": x.append(e)\n    elif e in \"*/\": f=e\n    else:\n      a=int(e)\n      if f==\"*\": a*=x.pop()\n      elif f==\"/\": a=x.pop()/a\n      x.append(a)\n      f=\"\"\n\n  s=x[:]\n  x=[]\n  f=\"\"\n  for e in s:\n    if e==\"+\" or e==\"-\": f=e\n    else:\n      a=int(e)\n      if f==\"+\": a+=x.pop()\n      elif f==\"-\": a=x.pop()-a\n      x.append(a)\n      f=\"\"\n  return str(x[0])\n\nn=input()\nfor _ in [0]*n: \n  s=raw_input()\n  print f(s)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport re\nn = int(input())\nfor _ in range(n):\n    expr = input()[0:-1]\n    expr = expr.replace('/', '//');\n    print(eval(expr))"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:\n  S+=[str(eval(S.pop(-2)+x+S.pop()))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor i in range(n):\n  print int(eval(raw_input()[:-1]))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            \n            num.append(calc(exp[i+1:i+end]))\n            i += end + 1\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n\n\ndef solv(expr):\n    expr = expr.rstrip('=')\n    return eval(expr)\n\n\n\nwhile True:\n    try:\n        n = int(sys.stdin.readline())\n        for i in range(n):\n            expr = sys.stdin.readline().rstrip('\\n')\n            print solv(expr)\n    except:\n        exit()"
  },
  {
    "language": "Python",
    "code": "print(*[eval(input()[:-1]) for _ in range(int(input()))], sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "abs2 = lambda a,b: -(abs(int(1.0*a/b)))\n\ndef number(begin):\n\tglobal i\n\t\n\tif begin[i] == \"(\":\n\t\ti += 1\n\t\tres = expression(begin)\n\t\ti += 1 \n\t\treturn res\n\t\n\tres = 0\n\t\n\twhile begin[i].isdigit():\n\t\tres *= 10\n\t\tres += int(begin[i])\n\t\ti+=1\n\t\n\treturn res\n\t\ndef term(begin):# your code goes here\n\n\tglobal i\n\tres = number(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"*\":\n\t\t\ti += 1\n\t\t\tres *= number(begin)\n\t\telif begin[i] == \"/\":\n\t\t\ti += 1\n\t\t\tnum = number(begin)\n\t\t\tif res < 0 or num < 0:\n\t\t\t\tres = abs2(res,num)\n\t\t\telse:\n\t\t\t\tres /= num\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\ndef expression(begin):\n\t\n\tglobal i\n\tres = term(begin)\n\t\n\twhile True:\n\t\tif begin[i] == \"+\":\n\t\t\ti += 1\n\t\t\tres += term(begin)\n\t\t\t\n\t\telif begin[i] == \"-\":\n\t\t\ti += 1\n\t\t\tres -= term(begin)\n\t\telse:\n\t\t\tbreak\n\treturn res\n\t\n\ndef main():\n\tglobal i\n\tfor j in range(input()):\n\t\t\ti = 0\n\t\t\tex = raw_input() +\"=\"\n\t\t\tans = expression(ex)\n\t\n\t\t\tprint ans\nmain()"
  },
  {
    "language": "Python",
    "code": "[print(eval(input()[:-1].replace(\"/\",\"//\"))) for i in range(int(input()))]\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\n所要時間は、分位であった。\n'''\n\n\n# ライブラリのインポート\n#import re\nimport sys\ninput = sys.stdin.readline\n#import heapq\n#import bisect\nfrom collections import deque\n#import math\n\ndef main():\n    n = int(input())\n    for _ in range(n): \n        IN = input().strip()\n        exp1 = calcmold(IN)\n        exp2 = calc1(exp1)\n        exp3 = calcmult(exp2)\n        print(calcplus(exp3))\n\ndef calcmold(exp):\n    # seikei\n    tmp = \"\"\n    EXP = deque()\n    oplist = [\"+\",\"-\",\"*\",\"/\",\"(\",\")\",\"=\"]\n    for i in range(len(exp)):\n        if exp[i] not in oplist:\n            tmp += exp[i]\n        else:\n            if tmp == \"\":\n                EXP.append(exp[i])\n                continue\n            EXP.append(int(tmp))\n            EXP.append(exp[i])\n            tmp = \"\"\n    return EXP\n\n\ndef calc1(IN):\n    #calculate()\n    EXP = deque()\n    while(IN):\n        check = IN.popleft()\n        if check == \")\":\n            TMP = deque()\n            while(1):\n                look = EXP.pop()\n                if look == \"(\": break\n                TMP.appendleft(look)\n            TMP.append(\"=\")\n            EXP.append(calcplus(calcmult(TMP)))\n        else: EXP.append(check)\n    return EXP\n        \n\n\ndef calcmult(exp):\n    # no()\n    EXP = deque()\n    while(exp):\n        check = exp.popleft()\n        if check == \"*\":\n            arg1 = EXP.pop()\n            arg2 = exp.popleft()\n            EXP.append(arg1*arg2)\n        elif check == \"/\":\n            arg1 = EXP.pop()\n            arg2 = exp.popleft()\n            EXP.append(int(arg1/arg2))\n        else: EXP.append(check)\n    return EXP\n\n\ndef calcplus(exp):\n    # no()\n    EXP = deque()\n    while(exp):\n        check = exp.popleft()\n        if check == \"+\":\n            arg1 = EXP.pop()\n            arg2 = exp.popleft()\n            EXP.append(arg1+arg2)\n        elif check == \"-\":\n            arg1 = EXP.pop()\n            arg2 = exp.popleft()\n            EXP.append(arg1-arg2)\n        elif check == \"=\":\n            return EXP.pop()\n        else: EXP.append(check)\n    return EXP\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "s = \"\"; l = 0;\ndef expr(idx):\n    ret, idx = term(idx)\n    while idx<l:\n        if s[idx]=='+':\n            r, idx = term(idx+1)\n            ret += r\n        elif s[idx]=='-':\n            r, idx = term(idx+1)\n            ret -= r\n        else:\n            break\n    return ret, idx\n    \ndef term(idx):\n    ret, idx = fact(idx)\n    while idx<l:\n        if s[idx]=='*':\n            r, idx = fact(idx+1)\n            ret *= r\n        elif s[idx]=='/':\n            r, idx = fact(idx+1)\n            ret /= r\n        else:\n            break\n    return ret, idx\n\ndef fact(idx):\n    ret = 0\n    if s[idx]=='(':\n        ret, idx = expr(idx+1)\n        idx += 1\n    else:\n        ret, idx = num(idx)\n    return ret, idx\n\ndef num(idx):\n    ret = 0\n    while idx<l and s[idx].isdigit():\n        ret = 10*ret + int(s[idx])\n        idx+=1\n    return ret, idx\n\nfor i in xrange(input()):\n    s = raw_input(); l = len(s);\n    print expr(0)[0]"
  },
  {
    "language": "Python",
    "code": "for i in range(int(raw_input())): print eval(raw_input()[:-1])"
  },
  {
    "language": "Python",
    "code": "l=[eval(input()[:-1]) for i in range(int(input()))]\n[print(i) for i in l]\n\n"
  },
  {
    "language": "Python",
    "code": "#n=int(input())\n\ndef lastfind(s,x):\n    n=len(s)\n    s_rev=s[::-1]\n    t=s_rev.find(x)\n    return n-t-1\ndef doublefind(s,x,y):\n    if x in s:\n        p=s.find(x)\n    else:\n        p=len(s)+10\n    if y in s:\n        q=s.find(y)\n    else:\n        q=len(s)+10\n    \n    if p<=q and p<len(s)+5:\n        return [p,x]\n    elif q<len(s)+5:\n        return [q,y]\n    else:\n        return 0\n\ndef calculator(s):\n    if s==\"\":\n        return 0\n    \n    try:\n        return int(s)\n    except:\n        try:\n            x=doublefind(s,\"+\",\"-\")\n            if x[1]==\"+\":\n                return calculator(s[:x[0]:])+calculator(s[x[0]+1::])\n            else:\n                return calculator(s[:x[0]:])-calculator(s[x[0]+1::])\n        except:\n            x=doublefind(s,\"*\",\"/\")\n            if x[1]==\"*\":\n                return calculator(s[:x[0]:])*calculator(s[x[0]+1::])\n            else:\n                return int(calculator(s[:x[0]:])/calculator(s[x[0]+1::]))\ndef remove_brackets(s):\n    if s[0]==\"(\" and s[-1]==\")\":\n        return s[1:-1:]\n    else:\n        return s\ndef calc(s):\n    while \"(\" in s:\n        closec=s.find(\")\")\n        openc=lastfind(s[:closec:],\"(\")\n        s=s[:openc:]+str(calculator(s[openc+1:closec:]))+s[closec+1::]\n    return calculator(s)\n        \nn=int(input())\nfor count in range(n):\n    s=input()\n    print(calc(s[:-1:]))\n    "
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    exec \"c=\"+raw_input()[:-1]\n    print c"
  },
  {
    "language": "Python",
    "code": "[print(eval(input()[:-1])) for _ in range(int(input()))]\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp,brac=None):\n    i = 0 # ループカウンタ?\n    num = deque() # 数字をためておく\n    ops = deque() # +-をためておく\n    ope = \"\" # */を保存\n    \n    if not brac:\n        # 対応する括弧の位置を記録しておいて計算量を削減\n        brac = [-1 for j in range(len(exp))]\n        tmpbrac = []\n        for j in range(len(exp) - 1, 0, -1):\n            if exp[j] == ')':\n                tmpbrac.append(j)\n            elif exp[j] == '(':\n                brac[j] = tmpbrac.pop()\n\n    # かっこの中身と乗除算\n    while i < len(exp):\n        # かっこの中身は再帰的に計算\n        if exp[i] == '(':\n            num.append(calc(exp[i + 1:brac[i]],brac))\n            i = brac[i]\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\" # 数値 2桁以上にも対応させる\n            while i < len(exp) and exp[i].isnumeric():\n                temp += exp[i]\n                i += 1\n            i -= 1 # 最後の数字に戻る(最後にi+=1しているのでこれでいい)\n            num.append(int(temp))\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        num.appendleft(eva(num.popleft(),num.popleft(),ops.popleft()))\n\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ninput()\nfor i in sys.stdin.readlines():\n        print(eval(i[:-2]))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    line = raw_input()\n    if line == '':\n        break\n\n    for i in range(int(line)):\n        a = eval(raw_input().replace('/', '//')[:-1])\n        sys.stderr.write(a)"
  },
  {
    "language": "Python",
    "code": "R={\"*\":2,\"/\":2,\"+\":1,\"-\":1,\"(\":0,\")\":0}\nfor _ in[0]*int(input()):\n L=[];t=''\n for e in input()[:-1]:\n  if e.isdigit():t+=e\n  else:\n   if t:L+=[t];t=''\n   L+=e\n if t:L+=[t]\n P,S=[],[]\n for i in L:\n  if\"(\"==i:S+=i\n  elif\")\"==i:\n   while\"(\"!=S[-1]:P+=S.pop()\n   S.pop()\n  elif i in R:\n   while S and R[S[-1]]>=R[i]:P+=S.pop()\n   S+=i\n  else:P+=[i]\n while S:P+=S.pop()\n for x in P:S+=[str(int(eval(S.pop(-2)+x+S.pop())))if x in\"+-*/\"else x]\n print(*S)\n"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor i in range(n):\n    print eval(raw_input().strip(\"=\"))"
  },
  {
    "language": "Python",
    "code": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n \n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n \n    return L\n \n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n \n    while len(S) != 0:\n        L2.append(S.pop())\n \n    return L2\n \n \ndef RPN_cal(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n \n \nN = int(raw_input())\n \nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cal(L))"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):\n    ans = eval(input().replace('/', '//')[:-1])\n    print(str(ans))"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nfor _ in range(n):\n  s = raw_input()\n  ans = eval(s[:-1])\n  print ans\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport re\n#from me.io import dup_file_stdin\n\n#@dup_file_stdin\ndef solve():\n    for _ in range(int(sys.stdin.readline())):\n        expr = sys.stdin.readline()[:-1].strip(\"=\")\n        expr = re.sub(\".d+\",\"\",expr)\n        print(eval(expr.replace(\"/\",\"//\")))\n \nsolve()"
  },
  {
    "language": "Python",
    "code": "l=[eval(raw_input()[:-1]) for i in range(int(input()))]\nfor i in l:\n    print i\n"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):\n    e = input()[:-1].replace(\"/\", \"//\")\n    print(eval(e))"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n def __add__(self,n):return c(int(self)+int(n))\n def __sub__(self,n):return c(int(self)-int(n))\n def __mul__(self,n):return c(int(self)*int(n))\n def __truediv__(self,n):return c(int(int(self)/int(n)))\nfor _ in[0]*int(input()):print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))\n"
  },
  {
    "language": "Python",
    "code": "for _ in range(int(input())):\n    print(eval(input()[:-1]))\n"
  },
  {
    "language": "Python",
    "code": "from __future__ import division\nfor i in range(input()):\n    print int(eval(raw_input()[:-1]))"
  },
  {
    "language": "Python",
    "code": "for i in xrange(input()):\n\tprint int(eval(raw_input().strip().strip('=').replace('/','//')))"
  },
  {
    "language": "Python",
    "code": "# In the name of Allah\nfor i in range(input()):\n    x=raw_input()[:-1]\n    print eval(x)\n\n"
  },
  {
    "language": "Python",
    "code": "\nn = int(input())\nfor i in range(n):\n    s = input()\n    print(s)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nif __name__ == '__main__':\n\tnum = int(raw_input())\n\tfor i in range(num):\n\t\tinput_line = raw_input()\n\t\teval_line = input_line[0:-1]\n\t\tresult = eval(eval_line)\n\t\tprint result"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# 写経した\nimport re\nclass Num:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self, value):\n        self.x = value\n    def __add__(self, value):\n        return Num(self.x + value.x)\n    def __sub__(self, value):\n        return Num(self.x - value.x)\n    def __mul__(self, value):\n        return Num(self.x * value.x)\n    def __truediv__(self, value):\n        return Num(int(self.x / value.x))\n      \nN = int(input())\nfor i in range(N):\n    s = input()[:-1]\n    s = re.sub(r'(\\d+)',r'Num(\\1)',s)\n    print(eval(s))\n"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef factor(t, i):\n    if t[i[0]] == '(':\n        i[0] += 1\n        return expr(t, i)\n    else:\n        r = int(t[i[0]])\n        i[0] += 1\n        return r\n\ndef term(t, i):\n    r = factor(t, i)\n    while True:\n        if t[i[0]] == '*':\n            i[0] += 1\n            r *= factor(t, i)\n        elif t[i[0]] == '/':\n            i[0] += 1\n            r /= factor(t, i)\n        else:\n            break\n    return r\n\ndef expr(t, i):\n    r = term(t, i)\n    while True:\n        if t[i[0]] == '+':\n            i[0] += 1\n            r += term(t, i)\n        elif t[i[0]] == '-':\n            i[0] += 1\n            r -= term(t, i)\n        else:\n            break\n    return r\n\nn = int(raw_input())\nfor _ in range(n):\n    t = re.sub(r'([\\+\\-\\*\\/\\(\\)=])', r' \\1 ', raw_input()).split()\n    print expr(t, [0])"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    if x == 0:exit()\n    return abs(x) / abs(y) * s     \n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n     \n    operators = [(\"+\", lambda x,y:x + y),\n                 (\"-\", lambda x,y:x - y),\n                 (\"*\", lambda x,y:x * y),\n                 (\"/\", divide)\n                ]  \n     \n    for (op,func) in operators:\n        if op in src:\n            p = src.index(op)\n            l = evaluate(src[:p])\n            r = evaluate(src[p + 1:])\n            return func(l, r)\n     \nfor t in xrange(input()):\n    _src = raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom sys import stderr\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    stderr.write(exp)\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = exp[i:].rfind(\")\")\n            num.append(calc(exp[i+1:i+end]))\n            i += end + 1\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        if exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n# N = int(input())\n# for i in range(N):\n#     print(int(eval(input().replace(\"/\", \"//\").strip(\"=\"))))\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# Convert String to List\ndef String2List(s):\n    L = []; tmp = \"\"\n    for i in s:\n        if i.isdigit():\n            tmp += i\n        else:\n            if tmp != \"\":\n                L.append(tmp)\n                tmp = \"\"\n            L.append(i)\n    if tmp != \"\":\n        L.append(tmp)\n\n    return L\n\n# generate Reverse Polish Notation\ndef Generate_RPN(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            while len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())\n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\ndef Calculate_RPN(L):\n    St = []\n \n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n \n    return St[0]\n\n\ns = raw_input()\nprint Calculate_RPN(Generate_RPN(String2List(s)))"
  },
  {
    "language": "Python",
    "code": "inputs=[]\nwhile True:\n  try:\n    inputs.append(input())\n  except EOFError:\n    break\n\nfor i in inputs:\n  a,c=i.split(\"=\")\n  a,b=a.split(\"+\")\n  # a+b=c\n  for x in range(0,10):\n    if x==0 and (a[0]==\"X\" or b[0]==\"X\" or c[0]==\"X\"):\n        next\n    A=a.replace(\"X\",str(x))\n    B=b.replace(\"X\",str(x))\n    C=c.replace(\"X\",str(x))\n    if int(A)+int(B)==int(C):\n      print(x)\n      break\n    if x == 9:\n      print(\"NA\")"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0109&lang=jp\n\"\"\"\nimport sys\n\n\n\ndef solve(exp):\n    exp = exp.replace('=', '')\n    exp = exp.replace('/', '//')\n    return eval(exp)\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        expression = input()\n        result = solve(expression)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input());\nfor i in range(n):\n\tprint \"%d\" % eval(raw_input()[:-1]);"
  },
  {
    "language": "Python",
    "code": "\ndef parse(line):\n    lis = []\n    ind =0\n    while(line[ind]!=\"=\"):\n        a = line[ind]\n        if(ind==0 and a==\"-\"):\n            s=ind\n            ind += 1\n            while(line[ind].isdigit()):ind+=1\n            lis.append(int(line[s:ind]))\n            continue\n        if(a.isdigit()==False):\n            lis.append(a)\n            ind+=1\n            continue\n        else:\n            s=ind\n            while(line[ind].isdigit()):ind+=1\n            lis.append(line[s:ind])\n            continue\n    return lis\n\ndef dParen(lis,sind):\n    cnt = 1\n    s = sind\n    sind+=1\n    while 1:\n        if(lis[sind]==\")\"):\n            cnt -= 1\n            if(cnt==0):return (s,sind)\n        elif(lis[sind]==\"(\"):\n            cnt += 1\n        sind+=1\n\n\n           \n\ndef eva(lis):\n    #print lis\n    if(len(lis)==1):return lis[0]\n    if(\"(\" in lis):\n        (s,e) = dParen(lis,lis.index(\"(\"))\n        val = eva(lis[s+1:e])\n        lis[s:e+1]=[val]\n        return eva(lis)\n    if(\"*\" in lis or \"/\" in lis):\n        inmin = 0;\n        if((\"*\" in lis)==False):\n            inmin = lis.index(\"/\")\n        elif((\"/\" in lis)==False):\n            inmin = lis.index(\"*\")\n        else:\n            inmin = min(lis.index(\"x\"),lis.index(\"/\"))\n        if(lis[inmin]==\"*\"):\n            val = int(lis[inmin-1])*int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        else:\n            val = int(lis[inmin-1])/int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        return eva(lis)\n    if(\"+\" in lis or \"-\" in lis):\n        if((\"+\" in lis)==False):\n            inmin = lis.index(\"-\")\n        elif((\"-\" in lis)==False):\n            inmin = lis.index(\"+\")\n        else:\n            inmin = min(lis.index(\"+\"),lis.index(\"-\"))\n        if(lis[inmin]==\"+\"):\n            val = int(lis[inmin-1])+int(lis[inmin+1])\n            lis[inmin-1:inmin+2]= [val]\n        else:\n            val = int(lis[inmin-1])-int(lis[inmin+1])\n            lis[inmin-1:inmin+2]=[val]\n        return eva(lis)\n    \n\nn = int(raw_input())\nfor i in range(n):\n    calcu = parse(raw_input())\n    #print calcu\n    print eva(calcu)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfor s in sys.stdin:\n\tif '=' in s:\n\t\tprint int(eval(s.strip().strip('=')))"
  },
  {
    "language": "Python",
    "code": "for _ in[0]*int(input()):print(eval(input()[:-1]))\n"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n\n    print(rpn)\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(array):\n\twhile len(array) > 1:\n\t\tif '/' in array:\n\t\t\tc = array.index('/')\n\t\t\tarray[c + 1] = array[c - 1] / array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '*' in array:\n\t\t\tc = array.index('*')\n\t\t\tarray[c + 1] = array[c - 1] * array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '-' in array:\n\t\t\tc = array.index('-')\n\t\t\tarray[c + 1] = array[c - 1] - array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\telif '+' in array:\n\t\t\tc = array.index('+')\n\t\t\tarray[c + 1] = array[c - 1] + array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\treturn array[0]\n\nn = input()\nfor i in range(n):\n\tconflict = []\n\tfor var in list(raw_input()):\n\t\ttry:\n\t\t\tconflict.append(int(var))\n\t\texcept:\n\t\t\tconflict.append(var)\n\twhile '(' in conflict:\n\t\tc1 = conflict.index('(')\n\t\tc2 = conflict.index(')')\n\t\tconflict[c2] = calc(conflict[c1 + 1:c2])\n\t\tdel conflict[c1:c2]\n\tprint calc(conflict[0:len(conflict) - 1])"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n# ??????????????????????????????????????¬??§?????°???????????????????????????????????????\ndef String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\n# ???????¨?????????°????????????????????????????????????????¨?????????°????????????????????????\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and (table[S[-1]] >= table[i]):\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\n# ???????????????????¨?????????°???????????????????????????????????????????????????\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(int(St.pop()) + int(St.pop()))\n        elif i == '-':\n            St.append(-int(St.pop()) + int(St.pop()))\n        elif i == '*':\n            St.append(int(St.pop()) * int(St.pop()))\n        elif i == '/':\n            a = int(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n    if St[0] == -0.0:\n        return 0.0\n    else:\n        return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "def rank(ch,st):\n    dic={\"+\":1,\"-\":1,\"*\":3,\"/\":2,\"(\":0}\n    return dic[ch]<dic[st]\nfor i in range(input()):\n    s=raw_input()[:-1]\n    buf=[]\n    stack=[]\n    for ch in s:\n        if ch.isdigit():\n            buf.append(ch)\n        elif ch==\")\":\n            temp=stack.pop()\n            while temp!=\"(\":\n                buf.append(temp)\n                temp=stack.pop()\n        elif ch==\"(\":\n            stack.append(ch)\n        elif stack==[]:\n            stack.append(ch)\n        elif rank(ch,stack[-1]):\n            while stack!=[] and rank(ch,stack[-1]):\n                buf.append(stack.pop())\n            stack.append(ch)\n        else:\n            stack.append(ch)\n    buf+=stack[::-1]\n    stack=[]\n    res=0\n    for ch in buf:\n        if ch.isdigit():\n            stack.append(int(ch))\n        else:\n            a=stack.pop()\n            b=stack.pop()\n            if ch==\"+\":\n                stack.append(a+b)\n            elif ch==\"-\":\n                stack.append(b-a)\n            elif ch==\"*\":\n                stack.append(a*b)\n            else:\n                stack.append(b/a)\n    print stack[0]"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport sys\n\ndef main():\n\tn = input()\n\tfor i in xrange(n):\n\t\tline = raw_input()\n\t\texec(\"print %s\" % line[:-1])\n\treturn 0\n\nif __name__ == '__main__':\n\tsys.exit(main())"
  },
  {
    "language": "Python",
    "code": "def seekBackOperatorInLand(op,s):\n\tdepth = 0\n\tfor i in xrange(len(s)-1,-1,-1):\n\t\tif s[i]==')': depth+=1\n\t\tif s[i]=='(': depth-=1\n\t\tif s[i]==op and depth==0: return i\n\treturn None\n\ndef calc(s):\n\tif all(map(lambda t: t in \"0123456789\", s)):\n\t\treturn int(s)\n\tif s[0]=='(' and s[-1]==')' and all(map(lambda t: t!='(' and t!=')', s[1:-1])):\n\t\treturn calc(s[1:-1])\n\t\n\tp = seekBackOperatorInLand('-',s)\n\tif not p is None: return calc(s[:p])-calc(s[p+1:])\n\tp = seekBackOperatorInLand('+',s)\n\tif not p is None: return calc(s[:p])+calc(s[p+1:])\n\tp = seekBackOperatorInLand('/',s)\n\tif not p is None: return 1.0*calc(s[:p])/calc(s[p+1:])\n\tp = seekBackOperatorInLand('*',s)\n\tif not p is None: return calc(s[:p])*calc(s[p+1:])\n\n\treturn calc(s[1:-1])\n\ndef main():\n\tol=input()\n\tfor oi in xrange(ol):\n\t\tprint int(calc(raw_input()[:-1]))\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n\n    for item in string[:-1]:\n        if item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if item in priority.keys():\n                if priority[signStack[-1]] < priority[item]:\n                    signStack.append(item)\n                else:\n                    top = signStack.pop()\n                    stack.append(top)\n                    signStack.append(item)\n            else:\n                stack.append(item)\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n            #\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                #result = num2 / num1\n                pass\n\n            stack.append(int(result))\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(str(answer))\n\n"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef expression():\n    global pos\n    ret=term()\n    while True:\n        if L[pos]==\"+\":\n            pos+=1\n            ret+=term()\n        elif L[pos]==\"-\":\n            pos+=1\n            ret-=term()\n        else:\n            break\n    return ret\n\ndef term():\n    global pos\n    ret=factor()\n    while True:\n        if L[pos]==\"(\":\n            ret+=factor()\n        elif L[pos]==\"*\":\n            pos+=1\n            ret*=factor()\n        elif L[pos]==\"/\":\n            pos+=1\n            ret/=factor()\n        else:\n            break\n    return ret\n\ndef factor():\n    global pos\n    if L[pos]==\"(\":\n        pos+=1\n        ret=expression()\n        pos+=1\n    else:\n        return number()\n    return ret\n\ndef number():\n    global pos\n    ret=0\n    if L[pos].isdigit():\n        ret=int(L[pos])\n        pos+=1\n    return ret\n\nfor i in range(input()):\n    s=raw_input()\n    L=re.findall(r\"\\d+|[/+*-]|[\\(\\)=]\",s)\n    pos=0\n    print expression()"
  },
  {
    "language": "Python",
    "code": "ops = {\"+\": lambda a, b: b + a,\n       \"-\": lambda a, b: b - a,\n       \"*\": lambda a, b: b * a,\n       \"/\": lambda a, b: b / a,\n       \"@\": lambda a, b: -(abs(int(1.0*b/a)))}\n\ndef calc(stack, v):\n    if v in [\"+\", \"-\", \"*\"]:\n        stack.append(ops[v](stack.pop(), stack.pop()))\n    elif v == \"/\":\n        if stack[-1] < 0 or stack[-2] < 0: stack.append(ops[\"@\"](stack.pop(), stack.pop()))\n        else: stack.append(ops[v](stack.pop(), stack.pop()))\n    else:\n        stack.append(int(v))\n    return stack\n\nn = input()\nfor i in range(n):\n    porand = []\n    temp = []\n    stack = []\n    formula = raw_input()\n    for j in formula:\n        if j >= \"0\" and j <= \"9\": porand.append(j)\n        elif (j == \"*\" or j == \"/\") or j == \"(\": stack.append(j)\n        elif j == \"+\" or j == \"-\":\n            if len(stack) > 0:\n                for k in reversed(stack):\n                    if k == \"*\" or k == \"/\": temp.append(stack.pop())\n                    else:\n                        porand.extend(temp)\n                        temp = []\n                        break\n            temp.append(j)\n        elif j == \")\":\n            for k in reversed(stack):\n                if k == \"(\":\n                    porand.extend(temp)\n                    stack.pop()\n                    break\n                else: temp.append(stack.pop())\n        elif j == \"=\": porand.extend(stack)\n    print reduce(calc, porand, [])[-1]"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp,brac=None):\n    i = 0 # ループカウンタ?\n    num = deque() # 数字をためておく\n    ops = deque() # +-をためておく\n    ope = \"\" # */を保存\n    \n    if not brac:\n        # 対応する括弧の位置を記録しておいて計算量を削減\n        brac = [-1 for j in range(len(exp))]\n        tmpbrac = []\n        for j in range(len(exp) - 1, 0, -1):\n            if exp[j] == ')':\n                tmpbrac.append(j)\n            elif exp[j] == '(':\n                brac[j] = tmpbrac.pop()\n\n    # かっこの中身と乗除算\n    while i < len(exp):\n        # かっこの中身は再帰的に計算\n        if exp[i] == '(':\n            num.append(calc(exp[i + 1:brac[i]],brac))\n            i = brac[i]\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\" # 数値 2桁以上にも対応させる\n            while i < len(exp) and exp[i].isnumeric():\n                temp += exp[i]\n                i += 1\n            i -= 1 # 最後の数字に戻る(最後にi+=1しているのでこれでいい)\n            num.append(int(temp))\n            if ope:\n                r = num.pop()\n                l = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        num.appendleft(eva(num.popleft(),num.popleft(),ops.popleft()))\n\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n"
  },
  {
    "language": "Python",
    "code": "for i in range(input()):\n    s=raw_input()\n    s=s.replace(\"/\",\"//\")\n    print eval(s[:-1])"
  },
  {
    "language": "Python",
    "code": "def up_to_you(formula):\n    l_p = None\n    r_p = None\n    for i, c in enumerate(formula):\n        if c == '(':\n            l_p = i\n        elif c == ')':\n            r_p = i\n            break\n    else:\n        print fx(formula)\n        return\n    \n    r = fx(formula[l_p+1:r_p])\n    n_formula = formula[:l_p]+r+formula[r_p+1:]\n    return up_to_you(n_formula)\n            \ndef fx(gemstone):\n    n = ''\n    lis = []\n    add = ''\n    if gemstone[0] == '-':\n        gemstone = gemstone[1:]\n        add = '-'\n    for c in gemstone:\n        if c.isdigit():\n            n += c\n        else:\n            if n == '':\n                add = '-'\n            else:\n                lis.append(add+n)\n                lis.append(c)\n                n = ''\n                add = ''\n    else:\n        lis.append(add+n)\n    return isolation(lis)\n    \ndef isolation(lis):\n    if len(lis) == 1:\n        return str(lis[0])\n    o1 = None\n    o = None\n    o2 = None\n    o_i = None\n    n_lis = None\n    if '*' in lis or '/' in lis:\n        for i, v in enumerate(lis):\n            if o1 == None:\n                o1 = v\n            elif v == '*' or v == '/':\n                o = v\n                o_i = i\n            elif v == '+' or v == '-':\n                o1 = None\n            else:\n                o2 = v\n                r = discomfort(int(o1), o, int(o2))\n                n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n                return isolation(n_lis)\n    else:\n        o1 = lis[0]\n        o = lis[1]\n        o2 = lis[2]\n        o_i = 1\n        r = discomfort(int(o1), o, int(o2))\n        n_lis = lis[:(o_i-1)]+[r]+lis[(o_i+2):]\n        return isolation(n_lis)\n                \ndef discomfort(o1, o, o2):\n    r = None\n    if o == '*':\n        r = o1 * o2\n    elif o == '/':\n        r = o1 / o2\n        if o1 < 0: r += 1\n    elif o == '+':\n        r = o1 + o2\n    elif o == '-':\n        r = o1 - o2\n    return str(r)\n    \nif __name__ == '__main__':\n    N = int(raw_input())\n    for i in range(N):\n        formula = raw_input().rstrip('=')\n        up_to_you(formula)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = 1\n            s = 1\n            while True:\n                if exp[i+end] == \"(\":\n                    s += 1\n                elif exp[i+end] == \")\":\n                    s -= 1\n                if s == 0:\n                    break\n                end += 1\n            num.append(calc(exp[i+1:i+end]))\n            i += end\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            pass\n        else:\n            temp = \"\"\n            j = 0\n            while i + j < len(exp) and exp[i+j].isnumeric():\n                temp += exp[i+j]\n                j += 1\n            num.append(int(temp))\n            i += j - 1\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    \n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "import re\nclass c(int):\n def __add__(self,n):return c(int(self)+int(n))\n def __sub__(self,n):return c(int(self)-int(n))\n def __mul__(self,n):return c(int(self)*int(n))\n def __truediv__(self,n):return c(int(int(self)/int(n)))\nfor _ in[0]*int(input()):print(eval(re.sub(r'(\\d+)',r'c(\\1)',input()[:-1])))\n"
  },
  {
    "language": "Python",
    "code": "n = input()\nfor i in range(n):\n    str = raw_input()[:-1]\n    print eval(str)"
  },
  {
    "language": "Python",
    "code": "def divide(x, y):\n    s = 1\n    if(x < 0):s *= -1\n    if(y < 0):s *= -1\n    return abs(x) / abs(y) * s     \n\noperator = {\"+\":(lambda x,y: x+y),\n            \"-\":(lambda x,y: x-y),\n            \"*\":(lambda x,y: x*y),\n            \"/\":divide\n            }\n\ndef ind(src, x):\n    if x not in src:return 1<<30\n    return src.index(x)\n \ndef _split(_src):\n    c = 0\n    l = len(_src)\n    if l == 0:\n        return []\n    while c < l and ord('0') <= ord(_src[c]) <= ord('9'):\n        c += 1\n\n    if c == 0:\n        return [_src[0]] + _split(_src[1:])\n    else:\n        return [int(_src[:c])] + _split(_src[c:])\n         \n \ndef evaluate(src):\n    if len(src) == 1:\n        return src[0]\n         \n    if \"(\" in src:\n        l = src.index(\"(\")\n        r = l\n        st = 1\n        while st:\n            r += 1\n            if src[r] == \"(\": st += 1\n            if src[r] == \")\": st -= 1\n        \n        mid = evaluate(src[l + 1:r])\n        return evaluate( src[:l] + [mid] + src[r + 1:])\n    \n    if \"*\" in src or \"/\" in src:\n        pos = min(ind(src, \"*\"), ind(src,\"/\"))\n        op = src[pos]\n        l, r = src[pos - 1], src[pos + 1]\n        mid = operator[op](l, r)\n        return evaluate(src[:pos - 1] + [mid] + src[pos + 2:])\n    \n    else:\n        pos = min(ind(src, \"+\"), ind(src, \"-\"))\n        op = src[pos]\n        l, r = src[pos - 1], src[pos + 1]\n        mid = operator[op](l, r)\n        return evaluate(src[:pos - 1] + [mid] + src[pos + 2:])\n     \nfor t in xrange(input()):\n    _src = raw_input().strip(\"=\")\n    src = _split(_src)\n    print evaluate(src)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\n\nfor t in range(n):\n    s=input()\n    s=s[:-1]\n    print(eval(s))"
  },
  {
    "language": "Python",
    "code": "import re\nclass o:\n    def __str__(self):\n        return str(self.x)\n    def __init__(self,value):\n        self.x=value\n    def __add__(self,value):\n        return o(self.x+value.x)\n    def __sub__(self,value):\n        return o(self.x-value.x)\n    def __mul__(self,value):\n        return o(self.x*value.x)\n    def __truediv__(self,value):\n        return o(self.x//value.x)\n    \nn=int(input())\nfor i in range(n):\n    s=input()[:-1]\n    s=re.sub(r'(\\d+)',r'o(\\1)',s)\n    print(eval(s))\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nfor i in range(n):\n\ta=input()\n\tprint(int(eval(a[:len(a)-1])))"
  },
  {
    "language": "Python",
    "code": "def ReversePolishNotation(string):\n\n    priority = {\"Sentinel\": 0, \"(\": 0, \"+\": 1, \"-\": 1, \"*\": 2, \"/\": 2}\n\n    stack = []\n    signStack = [\"Sentinel\"]\n    isContinue = False\n\n    for item in string[:-1]:\n        if str.isnumeric(item):\n            if not isContinue:\n                stack.append(item)\n                isContinue = True\n            else:\n                stack[-1] += item\n            continue\n        elif item == \"(\":\n            signStack.append(item)\n        elif item == \")\":\n            while signStack[-1] != \"(\":\n                stack.append(signStack.pop())\n            signStack.pop()\n        else:\n            if priority[signStack[-1]] < priority[item]:\n                signStack.append(item)\n            else:\n                top = signStack.pop()\n                stack.append(top)\n                signStack.append(item)\n        isContinue = False\n\n    while signStack[-1] != \"Sentinel\":\n        stack.append(signStack.pop())\n\n    return stack\n\n\ndef Calculate(formulaList):\n\n    signs = [\"+\", \"-\", \"*\", \"/\"]\n\n    stack = []\n\n    for item in formulaList:\n\n        if item not in signs:\n            stack.append(item)\n        else:\n            num1 = int(stack.pop())\n            num2 = int(stack.pop())\n\n            result = 0\n\n            if item == \"+\":\n                result = num2 + num1\n            elif item == \"-\":\n                result = num2 - num1\n            elif item == \"*\":\n                result = num2 * num1\n            else:\n                result = num2 / num1 // 1\n\n            stack.append(result)\n\n    return int(stack[0])\n\n\ninputCount = int(input())\n\nfor lp in range(inputCount):\n    formula = input()\n\n    rpn = ReversePolishNotation(formula)\n    answer = Calculate(rpn)\n\n    print(str(answer))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfor i in range(n):\n    eq = input().replace(\"/\",\"//\")\n    print(eval(eq))"
  },
  {
    "language": "Python",
    "code": "def String2List(s):\n    L = []\n    flag = True\n    l = len(s)\n    for i in range(l):\n        if s[i].isdigit() and flag:\n            t = \"\"\n            j = 0\n            while s[i+j].isdigit():\n                t += s[i+j]\n                if i+j == l-1:\n                    break\n                j += 1\n            L.append(t)\n            flag = False\n\n        elif not s[i].isdigit():\n            L.append(s[i])\n            flag = True\n\n    return L\n\n\ndef RPN_list(L):\n    S, L2 = [], []\n    table = {\"*\": 1, \"/\": 1, \"+\": 0, \"-\": 0, \"(\": -1, \")\": -1}\n    rpn = \"\"\n    for i in L:\n        if i.isdigit():\n            L2.append(i)\n        elif i == \"(\":\n            S.append(i)\n        elif i == \")\":\n            while S[-1] != \"(\":\n                L2.append(S.pop())\n            S.pop()\n        else:\n            if len(S) != 0 and table[S[-1]] >= table[i]:\n                L2.append(S.pop())            \n            S.append(i)\n\n    while len(S) != 0:\n        L2.append(S.pop())\n\n    return L2\n\n\ndef RPN_cul(L):\n    St = []\n\n    for i in L:\n        if i == '+':\n            St.append(float(St.pop()) + float(St.pop()))\n        elif i == '-':\n            St.append(-float(St.pop()) + float(St.pop()))\n        elif i == '*':\n            St.append(float(St.pop()) * float(St.pop()))\n        elif i == '/':\n            a = float(St.pop())\n            b = float(St.pop())\n            St.append(b/a)\n        else:\n            St.append(i)\n\n    return St[0]\n\n\nN = int(raw_input())\n\nfor i in range(N):\n    s = raw_input()\n    L = String2List(s[:-1])\n    L = RPN_list(L)\n    print int(RPN_cul(L))"
  },
  {
    "language": "Python",
    "code": "[print(int(eval(input()[:-1]))) for _ in range(int(input()))]\n\n"
  },
  {
    "language": "Python",
    "code": "def calc(array):\n\twhile len(array) > 1:\n\t\tif '/' in array:\n\t\t\tc = array.index('/')\n\t\t\tarray[c + 1] = array[c - 1] / array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\t\tif '*' in array:\n\t\t\tc = array.index('*')\n\t\t\tarray[c + 1] = array[c - 1] * array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\t\tif '-' in array:\n\t\t\tc = array.index('-')\n\t\t\tarray[c + 1] = array[c - 1] - array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\t\tif '+' in array:\n\t\t\tc = array.index('+')\n\t\t\tarray[c + 1] = array[c - 1] + array[c + 1]\n\t\t\tdel array[c - 1:c + 1]\n\t\t\tcontinue\n\treturn array[0]\n\nn = input()\nfor i in range(n):\n\tconflict = []\n\tfor var in list(raw_input()):\n\t\ttry:\n\t\t\tconflict.append(int(var))\n\t\texcept:\n\t\t\tconflict.append(var)\n\tif '(' in conflict:\n\t\tc1 = conflict.index('(')\n\t\tc2 = conflict.index(')')\n\t\tconflict[c2] = calc(conflict[c1 + 1:c2])\n\t\tdel conflict[c1:c2]\n\tprint calc(conflict[0:len(conflict) - 1])"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef eva(l, r, op):\n    if op == \"+\":\n        return l + r\n    elif op == \"-\":\n        return l - r\n    elif op == \"*\":\n        return l * r\n    elif op == \"/\":\n        return l // r\n\n\ndef calc(exp):\n    i = 0\n    num = deque()\n    ops = deque()\n    ope = \"\"\n    while i < len(exp):\n        if exp[i] == '(':\n            end = exp[i:].rfind(\")\")\n            num.append(calc(exp[i+1:i+end]))\n            i += end + 1\n            if ope:\n                l = num.pop()\n                r = num.pop()\n                num.append(eva(l, r, ope))\n                ope = \"\"\n        elif exp[i].isnumeric():\n            num.append(int(exp[i]))\n            if ope:\n                num.append(eva(num.pop(), num.pop(), ope))\n                ope = \"\"\n        elif exp[i] in [\"*\", \"/\"]:\n            ope = exp[i]\n        elif exp[i] in [\"+\", \"-\"]:\n            ops.append(exp[i])\n        elif exp[i] == \"=\":\n            break\n        i += 1\n    while len(ops) != 0:\n        l = num.popleft()\n        r = num.popleft()\n        num.appendleft(eva(l,r,ops.popleft()))\n    return num[0]\n\n\nn = int(input())\nfor i in range(n):\n    exp = input()\n    print(calc(exp))\n\n"
  },
  {
    "language": "Python",
    "code": "[print(eval(input()[:-1])) for i in range(int(input()))]\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nfor i in range(N):\n    print(int(eval(input().replace(\"/\",\"//\").strip(\"=\"))))\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::stdin;\nuse std::collections::HashMap;\n\nfn main() {\n    let mut s = String::new();\n    stdin().read_line(&mut s).unwrap();\n    let lines: i32 = s.trim().parse().unwrap();\n    for _ in 0..lines {\n        let mut s = String::new();\n        stdin().read_line(&mut s).unwrap();\n        let line = s.trim();\n        println!(\"{:?}\", calc(line));\n    }\n}\n\nfn calc(line: &str) -> i32 {\n    exec_rpn(sort_to_rpn(tokenize(line)))\n}\n\n// Split the line by operators.\nfn tokenize(line: &str) -> Vec<String> {\n    let ops = ['+', '-', '*', '/', '(', ')', '='];\n    let mut tokens: Vec<String> = Vec::new();\n    let mut after_ops = true;\n    for c in line.chars() {\n        let is_op = ops.contains(&c);\n        if after_ops {\n            tokens.push(String::new());\n        }\n        if !after_ops && is_op {\n            tokens.push(String::new());\n        }\n        let last = tokens.len() - 1;\n        tokens[last].push(c);\n        after_ops = is_op;\n    }\n    tokens\n}\n\n// Create the vector of Reverse Polish Notation (RPN).\nfn sort_to_rpn(tokens: Vec<String>) -> Vec<String> {\n    let mut rpn: Vec<String> = Vec::new();\n    let mut buf: Vec<String> = Vec::new();\n    let op_priority: HashMap<String, i32> =\n        [(\"+\", 1), (\"-\", 1), (\"*\", 2), (\"/\", 2)].iter().map(\n            |tuple| { (tuple.0.to_string(), tuple.1) }\n        ).collect();\n    for token in tokens {\n        match op_priority.get(&token) {\n            Some(priority) => {\n                // Pop from the buffer while operator priority is low.\n                loop {\n                    match buf.clone().last() {\n                        Some(last_token) => {\n                            match op_priority.get(last_token) {\n                                Some(last_priority) => {\n                                    if priority <= last_priority {\n                                        rpn.push(buf.pop().unwrap());\n                                    } else {\n                                        break\n                                    }\n                                }\n                                // case of \"(\"\n                                None => { break }\n                            }\n                        },\n                        None => { break }\n                    }\n                }\n                buf.push(token);\n            },\n            None => {\n                // Handle operators without priority.\n                match &*token {\n                    \"=\" => {\n                        loop {\n                            match buf.pop() {\n                                Some(v) => rpn.push(v),\n                                None => break\n                            }\n                        }\n                    },\n                    \"(\" => buf.push(token),\n                    \")\" => {\n                        loop {\n                            let v = buf.pop().unwrap();\n                            if &*v == \"(\" {\n                                break\n                            }\n                            rpn.push(v);\n                        }\n                    },\n                    // Push the numbers.\n                    _ => rpn.push(token)\n                }\n            }\n        }\n    }\n    rpn\n}\n\n// Calc result from the RPM vector.\nfn exec_rpn(rpn: Vec<String>) -> i32 {\n    let mut buf: Vec<i32> = Vec::new();\n    for token in rpn {\n        match &*token {\n            \"+\" => {\n                let v = buf.pop().unwrap() + buf.pop().unwrap();\n                buf.push(v)\n            },\n            \"-\" => {\n                let v1 = buf.pop().unwrap();\n                let v2 = buf.pop().unwrap();\n                buf.push(v2 - v1)\n            },\n            \"*\" => {\n                let v = buf.pop().unwrap() * buf.pop().unwrap();\n                buf.push(v)\n            },\n            \"/\" => {\n                let v1 = buf.pop().unwrap();\n                let v2 = buf.pop().unwrap();\n                buf.push(v2 / v1)\n            },\n            _ => buf.push(token.parse().unwrap())\n        }\n    }\n    buf.pop().unwrap()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::env;\nuse std::io::*;\nuse std::str::FromStr;\nuse std::char;\nuse std::error::Error;\nuse std::io::prelude::*;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char) \n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\nfn main() {\n    \n    let n: u32 = read();\n    \n    let mut cnt:u32 = 0;\n    while n != cnt {\n        let query: String = read();\n        let v: Vec<char> = query.chars().collect();\n            \n            //println!(\"{:?}\", v);\n            let mut i = 0_i32;\n            println!(\"{}\", expr(&v, &mut i));\n\n            //println!(\"{}\", number(&v, &mut i));\n        \n        cnt+=1;\n    }\n}\n\n\nfn expr(s: &Vec<char>, i: &mut i32) -> i32 {\n    let mut val = term(s, i);\n\n    let mut idx = *i as usize;\n    \n    while idx < s.len() && (s[idx] == '+' || s[idx] == '-') {\n        let op = s[idx];\n        *i += 1;\n        let val2 = term(s, i);\n        val = if op == '+' {\n            val + val2\n        }else {\n            val - val2\n        };\n        idx = *i as usize;\n    }\n    \n    val\n}\n\nfn term(s: &Vec<char>, i: &mut i32) -> i32 {\n    let mut val = factor(s, i);\n    \n    let mut idx = *i as usize;\n\n    while idx < s.len() && (s[idx] == '*' || s[idx] == '/') {\n        let op = s[idx];\n        *i += 1;\n        let val2 = factor(s, i);\n\n        val =  if op == '*' {\n            val * val2\n        } else {\n            val / val2\n        };\n        idx = *i as usize;\n    }\n\n    val\n}\n\nfn factor(s: &Vec<char>, i: &mut i32) -> i32 {\n    let idx = *i as usize;\n    if idx < s.len() && s[idx].is_digit(10){\n         return number(s, i);\n    }\n\n    *i += 1;\n    let res = expr(s, i);\n    *i += 1;\n\n    res\n}\n\nfn number(s: &Vec<char>, i: &mut i32) -> i32 {\n    let mut idx = *i as usize;\n    \n    let mut n: u32 = s[idx].to_digit(10).unwrap();\n    \n    *i += 1;\n    idx = *i as usize;\n    while idx < s.len() && s[idx].is_digit(10) {\n        \n        let m: u32 = s[idx].to_digit(10).unwrap();\n        n = n * 10 + m;\n        *i += 1;\n        idx = *i as usize;\n    }\n\n    n as i32\n}\n\n\n/* 参考 \n - http://dai1741.github.io/maximum-algo-2012/docs/parsing/\n\n <expr>   ::= <term> [ ('+'|'-') <term> ]*\n <term>   ::= <factor> [ ('*'|'/') <factor> ]*\n <factor> ::= <number> | '(' <expr> ')'\n <number> :== 1つ以上の数字\n*/\n\n/* &str型\n・文字列を固定する（メモリサイズ）\n・スライスで参照できる\n・文字列長は不変\n\n   String型\n・文字列長は可変\n・サイズが可変であるため参照ができない\n*/\n\n"
  }
]