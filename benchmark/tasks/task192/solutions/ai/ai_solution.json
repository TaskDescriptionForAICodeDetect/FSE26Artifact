[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x;\n    int a;\n} Point;\n\nint compare(const void *a, const void *b) {\n    Point *pointA = (Point *)a;\n    Point *pointB = (Point *)b;\n    return pointA->x - pointB->x;\n}\n\nint main() {\n    int w, h, n, S;\n    scanf(\"%d %d %d %d\", &w, &h, &n, &S);\n    \n    Point *points = (Point *)malloc((n + 2) * sizeof(Point));\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].a);\n    }\n    points[0].x = 0;\n    points[0].a = 0;\n    points[n+1].x = h;\n    points[n+1].a = 0;\n    \n    qsort(points, n + 2, sizeof(Point), compare);\n    \n    int *prefix = (int *)malloc((n + 2) * sizeof(int));\n    prefix[0] = points[0].a;\n    for (int i = 1; i <= n + 1; i++) {\n        prefix[i] = prefix[i-1] + points[i].a;\n    }\n    \n    int min_almonds = INT_MAX;\n    int left = 0;\n    for (int right = 1; right <= n + 1; right++) {\n        while (left < right && (points[right].x - points[left].x) * w >= S) {\n            int current_almonds = prefix[right] - prefix[left];\n            if (current_almonds < min_almonds) {\n                min_almonds = current_almonds;\n            }\n            left++;\n        }\n    }\n    \n    if (min_almonds == INT_MAX) {\n        min_almonds = -1;\n    }\n    \n    printf(\"%d\\n\", min_almonds);\n    \n    free(points);\n    free(prefix);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ChocolateDivision {\n    static int w, h, n;\n    static int[] leftCuts, rightCuts;\n    static int[] almonds;\n    static final int INF = Integer.MAX_VALUE;\n\n    public static int solve(int S) {\n        int minAlmonds = INF;\n        \n        for (int leftStart = 0; leftStart < leftCuts.length; leftStart++) {\n            for (int leftEnd = leftStart; leftEnd < leftCuts.length; leftEnd++) {\n                for (int rightStart = 0; rightStart < rightCuts.length; rightStart++) {\n                    for (int rightEnd = rightStart; rightEnd < rightCuts.length; rightEnd++) {\n                        int area = calculateArea(leftStart, leftEnd, rightStart, rightEnd);\n                        int currentAlmonds = countAlmonds(leftStart, leftEnd, rightStart, rightEnd);\n                        \n                        if (area >= S) {\n                            minAlmonds = Math.min(minAlmonds, currentAlmonds);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return minAlmonds == INF ? -1 : minAlmonds;\n    }\n\n    static int calculateArea(int leftStart, int leftEnd, int rightStart, int rightEnd) {\n        int height = leftCuts[leftEnd] - (leftStart > 0 ? leftCuts[leftStart-1] : 0);\n        int width = rightCuts[rightEnd] - (rightStart > 0 ? rightCuts[rightStart-1] : 0);\n        return height * width;\n    }\n\n    static int countAlmonds(int leftStart, int leftEnd, int rightStart, int rightEnd) {\n        int totalAlmonds = 0;\n        for (int i = leftStart; i <= leftEnd; i++) {\n            for (int j = rightStart; j <= rightEnd; j++) {\n                totalAlmonds += almonds[i * rightCuts.length + j];\n            }\n        }\n        return totalAlmonds;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        w = Integer.parseInt(st.nextToken());\n        h = Integer.parseInt(st.nextToken());\n        \n        n = Integer.parseInt(br.readLine());\n        \n        leftCuts = new int[n];\n        rightCuts = new int[n];\n        almonds = new int[n * n];\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            leftCuts[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            rightCuts[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        for (int i = 0; i < n; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < n; j++) {\n                almonds[i * n + j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        int S = Integer.parseInt(br.readLine());\n        \n        System.out.println(solve(S));\n    }\n}",
    "timestamp": "2025-08-05 19:02:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int w, h, n, S;\n    cin >> w >> h >> n >> S;\n\n    vector<int> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i];\n    }\n\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    vector<pair<int, int>> cuts;\n    for (int i = 0; i < n; ++i) {\n        cuts.emplace_back(x[i], a[i]);\n    }\n    sort(cuts.begin(), cuts.end());\n\n    vector<int> prefix_sum(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + cuts[i].second;\n    }\n\n    int min_almonds = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            int height = cuts[j].first - cuts[i].first;\n            int area = w * height;\n            if (area >= S) {\n                int almonds = prefix_sum[j + 1] - prefix_sum[i];\n                if (almonds < min_almonds) {\n                    min_almonds = almonds;\n                }\n            }\n        }\n    }\n\n    if (min_almonds == INT_MAX) {\n        min_almonds = 0;\n    }\n\n    cout << min_almonds << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_CUTS 50\n#define MAX_ALMONDS 10000\n\ntypedef struct {\n    int x, y, almonds;\n} Point;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int w, h, n, m, S;\n    Point left[MAX_CUTS], right[MAX_CUTS];\n    int dp[MAX_CUTS + 1][MAX_CUTS + 1];\n    \n    scanf(\"%d %d %d %d %d\", &w, &h, &n, &m, &S);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &left[i].x, &left[i].almonds);\n    }\n    \n    for (int j = 0; j < m; j++) {\n        scanf(\"%d %d\", &right[j].x, &right[j].almonds);\n    }\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    \n    dp[0][0] = 0;\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            if (dp[i][j] == INT_MAX) continue;\n            \n            int curr_height = (i == n ? h : left[i].x);\n            int curr_width = (j == m ? w : right[j].x);\n            int curr_area = curr_height * curr_width;\n            int curr_almonds = (i < n ? left[i].almonds : 0) + \n                               (j < m ? right[j].almonds : 0);\n            \n            if (curr_area >= S) {\n                dp[i][j] = min(dp[i][j], curr_almonds);\n            }\n            \n            if (i < n) {\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j]);\n            }\n            \n            if (j < m) {\n                dp[i][j+1] = min(dp[i][j+1], dp[i][j]);\n            }\n        }\n    }\n    \n    int min_almonds = INT_MAX;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            int curr_height = (i == n ? h : left[i].x);\n            int curr_width = (j == m ? w : right[j].x);\n            int curr_area = curr_height * curr_width;\n            \n            if (curr_area >= S) {\n                min_almonds = min(min_almonds, dp[i][j]);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", min_almonds == INT_MAX ? -1 : min_almonds);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int w, h, n, S;\n    cin >> w >> h >> n >> S;\n\n    vector<int> left_cuts(n), right_cuts(n);\n    vector<int> almonds_grid(h + 1, 0);\n\n    for (int i = 0; i < n; i++) {\n        cin >> left_cuts[i] >> right_cuts[i];\n    }\n\n    for (int i = 0; i < h + 1; i++) {\n        cin >> almonds_grid[i];\n    }\n\n    int min_almonds = INT_MAX;\n    for (int i = 0; i < n + 1; i++) {\n        for (int j = 0; j < n + 1; j++) {\n            int left_start = i == 0 ? 0 : left_cuts[i-1];\n            int left_end = i == n ? h : left_cuts[i];\n            int right_start = j == 0 ? 0 : right_cuts[j-1];\n            int right_end = j == n ? w : right_cuts[j];\n\n            int piece_area = (left_end - left_start) * (right_end - right_start);\n            \n            if (piece_area >= S) {\n                int piece_almonds = 0;\n                for (int r = left_start; r < left_end; r++) {\n                    piece_almonds += almonds_grid[r];\n                }\n                min_almonds = min(min_almonds, piece_almonds);\n            }\n        }\n    }\n\n    cout << min_almonds << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int w = sc.nextInt();\n        int h = sc.nextInt();\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int S = sc.nextInt();\n\n        int left = 0;\n        int right = n - 1;\n        int minAlmonds = Integer.MAX_VALUE;\n\n        int[] prefixSum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + a[i];\n        }\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            boolean found = false;\n            for (int i = 0; i <= n - mid; i++) {\n                int sum = prefixSum[i + mid] - prefixSum[i];\n                if (sum >= S) {\n                    found = true;\n                    if (sum < minAlmonds) {\n                        minAlmonds = sum;\n                    }\n                }\n            }\n            if (found) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        System.out.println(minAlmonds == Integer.MAX_VALUE ? -1 : minAlmonds);\n    }\n}",
    "timestamp": "2025-08-05 19:03:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_almonds_for_beko(w, h, cut_lines, S, almonds):\n    from bisect import bisect_left, bisect_right\n    \n    # Preprocess almond positions\n    almond_positions = sorted([y for x, y in almonds])\n\n    def almonds_in_range(y1, y2):\n        # Count almonds in the inclusive range [y1, y2]\n        left = bisect_left(almond_positions, y1)\n        right = bisect_right(almond_positions, y2)\n        return right - left\n    \n    cut_lines = [0] + cut_lines + [h]  # Add full height as cut_line\n    min_almonds = float('inf')\n    \n    for i in range(len(cut_lines) - 1):\n        for j in range(i + 1, len(cut_lines)):\n            y1 = cut_lines[i]\n            y2 = cut_lines[j]\n            area = (y2 - y1) * w\n            if area >= S:\n                almonds_count = almonds_in_range(y1, y2)\n                min_almonds = min(min_almonds, almonds_count)\n    \n    return min_almonds\n\n# Example usage:\nw = 5\nh = 5\ncut_lines = [1, 3, 4]\nS = 6\nalmonds = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\nprint(minimum_almonds_for_beko(w, h, cut_lines, S, almonds))",
    "timestamp": "2025-08-13 02:00:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass ChocolateDivision {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read width, height, and minimum area S\n        int w = scanner.nextInt();\n        int h = scanner.nextInt();\n        int S = scanner.nextInt();\n        \n        // Read number of almonds and their positions\n        int almondCount = scanner.nextInt();\n        int[][] almonds = new int[almondCount][2];\n        for (int i = 0; i < almondCount; i++) {\n            almonds[i][0] = scanner.nextInt();\n            almonds[i][1] = scanner.nextInt();\n        }\n        \n        // Read potential cut lines\n        int n = scanner.nextInt();\n        int[] cutLines = new int[n];\n        for (int i = 0; i < n; i++) {\n            cutLines[i] = scanner.nextInt();\n        }\n        \n        scanner.close();\n        \n        int minAlmonds = Integer.MAX_VALUE;\n\n        // Process each pair of cut lines\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int topLine = cutLines[i];\n                int bottomLine = cutLines[j];\n\n                // Calculate area of the chocolate piece for Be-ko\n                int area = w * (bottomLine - topLine);\n\n                if (area >= S) {\n                    // Count almonds for Be-ko's piece\n                    int almondCountForBekko = 0;\n\n                    for (int[] almond : almonds) {\n                        int almondY = almond[1];\n\n                        if (almondY >= topLine && almondY < bottomLine) {\n                            almondCountForBekko++;\n                        }\n                    }\n\n                    // Check if this division gives fewer almonds\n                    minAlmonds = Math.min(minAlmonds, almondCountForBekko);\n                }\n            }\n        }\n\n        // Output the minimum number of almonds\n        System.out.println(minAlmonds);\n    }\n}",
    "timestamp": "2025-08-13 02:00:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int y;\n    int almonds;\n} line;\n\n// Comparison function for qsort\nint compare_lines(const void *a, const void *b) {\n    return ((line *)a)->y - ((line *)b)->y;\n}\n\nint main() {\n    int w, h, n, A, S;\n    scanf(\"%d %d %d %d %d\", &w, &h, &n, &A, &S);\n    \n    // Read the horizontal lines\n    line *lines = (line *)malloc((n + 1) * sizeof(line));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &lines[i].y, &lines[i].almonds);\n    }\n    \n    // Add the bottom edge of the chocolate as a line\n    lines[n].y = 0;\n    lines[n].almonds = 0;\n    n++;\n    \n    // Sort the lines by y-coordinate\n    qsort(lines, n, sizeof(line), compare_lines);\n    \n    int min_almonds = INT_MAX;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int area = w * (lines[j].y - lines[i].y);\n            if (area >= S) {\n                int almonds = 0;\n                for (int k = i + 1; k <= j; k++) {\n                    almonds += lines[k].almonds;\n                }\n                if (almonds < min_almonds) {\n                    min_almonds = almonds;\n                }\n            }\n        }\n    }\n    \n    if (min_almonds == INT_MAX) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", min_almonds);\n    }\n    \n    free(lines);\n    return 0;\n}",
    "timestamp": "2025-08-13 02:00:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_chocolate_division(w, h, n, almonds, S):\n    # Sort almonds by their y-coordinate\n    almonds.sort(key=lambda x: x[1])\n    \n    min_almonds = float('inf')\n    \n    # Try all possible cut lines\n    for i in range(n + 1):\n        for j in range(n + 1):\n            # First cut point on left edge\n            y1 = 0 if i == 0 else almonds[i-1][1]\n            y2 = h if i == n else almonds[i][1]\n            \n            # Second cut point on right edge \n            y3 = 0 if j == 0 else almonds[j-1][1]\n            y4 = h if j == n else almonds[j][1]\n            \n            # Calculate Be-ko's piece area\n            area = abs(y2 - y1) * w\n            \n            # Count almonds in Be-ko's piece\n            be_ko_almonds = sum(1 for a in almonds if y1 <= a[1] <= y2)\n            \n            # Check if area and almonds count requirements are met\n            if area >= S:\n                min_almonds = min(min_almonds, be_ko_almonds)\n    \n    return min_almonds if min_almonds != float('inf') else -1\n\n# Input parsing and function call\nw, h, n, S = map(int, input().split())\nalmonds = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    almonds.append((x, y))\n\nresult = solve_chocolate_division(w, h, n, almonds, S)\nprint(result)",
    "timestamp": "2025-08-13 02:00:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    w, h = map(int, sys.stdin.readline().split())\n    left = [0] * (h + 1)\n    right = [0] * (h + 1)\n    \n    n = int(sys.stdin.readline())\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        left[y] += 1\n    \n    m = int(sys.stdin.readline())\n    for _ in range(m):\n        x, y = map(int, sys.stdin.readline().split())\n        right[y] += 1\n    \n    S = int(sys.stdin.readline())\n    \n    prefix_left = [0] * (h + 2)\n    prefix_right = [0] * (h + 2)\n    \n    for y in range(1, h + 1):\n        prefix_left[y] = prefix_left[y - 1] + left[y]\n        prefix_right[y] = prefix_right[y - 1] + right[y]\n    \n    min_almonds = float('inf')\n    left_ptr = 0\n    \n    for right_ptr in range(1, h + 1):\n        while (right_ptr - left_ptr) * w >= S:\n            current_almonds = (prefix_left[right_ptr] - prefix_left[left_ptr]) + (prefix_right[right_ptr] - prefix_right[left_ptr])\n            if current_almonds < min_almonds:\n                min_almonds = current_almonds\n            left_ptr += 1\n    \n    print(min_almonds if min_almonds != float('inf') else 0)\n\nsolve()",
    "timestamp": "2025-08-13 02:00:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Struct to represent each almond's position\nstruct Almond {\n    int x, y;\n};\n\n// Function to find the minimum number of almonds for Be-ko's piece with area at least S\nint findMinAlmonds(int w, int h, int s, vector<int>& cutLinesX, vector<Almond>& almonds) {\n    vector<int> maxCutLine(h + 1, 0);\n    for (int x : cutLinesX) {\n        maxCutLine[x] = x;\n    }\n    \n    vector<int> prefixAlmonds(h + 1, 0);\n    for (const Almond& almond : almonds) {\n        prefixAlmonds[almond.y]++;\n    }\n    \n    for (int i = 1; i <= h; ++i) {\n        prefixAlmonds[i] += prefixAlmonds[i - 1];\n    }\n\n    int minAlmonds = almonds.size();\n    for (int start = 0; start < h; ++start) {\n        for (int end = start + 1; end <= h; ++end) {\n            int area = w * (end - start);\n            if (area >= s) {\n                int almondsCount = prefixAlmonds[end] - prefixAlmonds[start];\n                minAlmonds = min(minAlmonds, almondsCount);\n            }\n        }\n    }\n    return minAlmonds;\n}\n\nint main() {\n    int w, h, s, n, m;\n    cin >> w >> h >> s >> n >> m;\n\n    vector<int> cutLinesX(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> cutLinesX[i];\n    }\n\n    vector<Almond> almonds(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> almonds[i].x >> almonds[i].y;\n    }\n\n    int result = findMinAlmonds(w, h, s, cutLinesX, almonds);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:03:42"
  }
]