[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n#define sz(v) v.size()\n#define mk(x, y) make_pair(x, y)\n#define fst first\n#define scd second\n#define MEMSET(x, n) memset(x, n, sizeof(x))\n#define MEMZERO(x) MEMSET(x, 0)\n#define URU(y) (!(y % 4) && y % 100 || !(y % 400))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nstruct Line\n{\n\tdouble l;\n\tdouble r;\n\tint num;\n};\n\ndouble cross_product( float x1, float y1, float x2, float y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\nbool inRange( Line l, Line h, double x, double y, double w )\n{\n\tdouble v1, v2;\n\t\n\tv1 = cross_product(w, (l.r - l.l), x, (y - l.l));\n\tv2 = cross_product(w, (h.r - h.l), x, (y - h.l));\n\t\n\tif ((0 < v1 && 0 < v2) || (0 > v1 && 0 > v2))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nint main( void )\n{\n\tint n, m, w, h, S;\n\tLine T[30010];\n\tint N1[30010], N2[30010];\n\tint S1[30010], S2[30010];\n\t\n\twhile ( cin >> n >> m >> w >> h >> S, n | m | w | h | S )\n\t{\n\t\tMEMZERO(T);\n\t\tMEMZERO(S1);\n\t\tMEMZERO(S2);\n\t\t\n\t\trep2 (i, 1, (m + 1))\n\t\t{\n\t\t\tcin >> T[i].l >> T[i].r;\n\t\t}\n\t\t\n\t\trep (i, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\trep2 (j, 1, (m + 1))\n\t\t\t{\n\t\t\t\tif (inRange(T[j-1], T[j], x, y, (double)w))\n\t\t\t\t{\n\t\t\t\t\t++T[j].num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = n, sum = 0;\n\t\t\n\t\trep (i, (m + 1))\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tN1[i] = sum;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif ((S * 2) <= (S1[i] = ((T[i].l + T[i].r) * w)))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout << ans << endl;\n/*\n\t\tsum = 0;\n\t\trepm (i, m, 0)\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tN2[i] = sum;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif((S * 2) <= (S2[i] = ((2 * h - (T[i-1].l + T[i-1].r)) * w)))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n*/\n\t\t// cout << ans << endl;\n\t\t\n\t\tsum = 0;\n\t\trep2 (i, 0, m)\n\t\t{\n\t\t\tif (ans <= N1[i])\n\t\t\t\tbreak;\n\t\t\tint sub_sum = 0;\n\t\t\trepm (j, m, (i + 1))\n\t\t\t{\n\t\t\t\tsub_sum += T[j].num;\n\t\t\t\tif (ans <= (N1[i] + sub_sum))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((S * 2) <= (((2 * h - (T[j-1].l + T[j-1].r)) * w) + S1[i]))\n\t\t\t\t{\n\t\t\t\t\tans = N1[i] + sub_sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nint arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  \n  return (b.x*c.y-b.y*c.x>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i])) up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n \nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=((L[mid][0].y-L[i][0].y)+(L[mid][1].y-L[i][1].y))*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    L[0][0]=point(0,0);\n    L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  while (true) {\n    long long n, m, w, h, s;\n    cin >> n >> m >> w >> h >> s;\n    s *= 2;\n    if (n == 0 && m == 0 && w == 0 && h == 0 && s == 0) break;\n    vector<long long> l(m), r(m), a(m + 2), c(m + 2);\n    vector<double> x(n), y(n);\n    rep (i, m) cin >> l[i] >> r[i];\n    rep (i, n) cin >> x[i] >> y[i];\n    rep (i, m) a[i + 1] = (l[i] + r[i]) * h;\n    a[0] = 0;\n    a[m + 1] = w * h * 2;\n    rep (i, c.size()) c[i] = 0;\n    rep (i, n) {\n      int a = -1, b = m;\n      while (a < b - 1) {\n\tint m = (a + b) / 2;\n\tif (w * (y[i] - l[m]) - (r[m] - l[m]) * x[i] > 0) a = m;\n\telse b = m;\n      }\n      ++c[b + 1];\n    }\n    rep (i, c.size() - 1) c[i + 1] += c[i];\n    //rep (i, a.size()) cout << i << \" \" << a[i] << endl;\n    //rep (i, c.size()) cout << i << \" \" << c[i] << endl;\n    long long res = n;\n    rep (i, m + 2) {\n      int p = upper_bound(a.begin(), a.end(), w * h * 2 - s + a[i]) - a.begin();\n      --p;\n      //cout << i << \" \" << p << \" \" << n - c[p] + c[i] << endl;\n      res = min(res, n - c[p] + c[i]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-8; \ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\n/*\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n}\n*/\nint contains(vector<P> v, P p){ \n  bool in = false; \n  for(int i=0;i<v.size();i++){ \n    P a = v[i] - p; \n    P b = v[(i+1)%v.size()] - p; \n    if(imag(a) > imag(b)) swap(a,b); \n    if((imag(a) <= 0 || fabs(imag(a))<EPS) && EPS < imag(b)) \n      if(cross(a,b) < -EPS) in = !in; \n    if(fabs(cross(a,b))<EPS && dot(a,b) < EPS) return 1;\n  } \n  return in ? 2 : 0; \n} \n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint main() {\n  int n,m,w,h,s;\n  while(cin >> n >> m >> w >> h >> s && n) {\n    P a[m];\n    int d[m+1];\n    double d2[m+1];\n    d2[0]=0;\n    memset(d,0,sizeof(d));\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n      vector<P> v(4);\n      v[0]=P(0,0);\n      v[1]=P(w,0);\n      v[2]=P(w,a[i].imag());\n      v[3]=P(0,a[i].real());\n      d2[i+1]=area(v);\n    }\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      P p=P(x,y);\n      int l=0,r=m;\n      while(l+1!=r) {\n        int k=(l+r)/2;\n        vector<P> v(4);\n        v[0]=P(0,0);\n        v[1]=P(w,0);\n        v[2]=P(w,a[k].imag());\n        v[3]=P(0,a[k].real());\n        if(contains(v,p)<2) l=k;\n        else r=k;\n      }\n      d[l+1]++;\n    }\n    for(int i=0; i<m; i++) d[i+1]+=d[i];\n    //for(int i=0; i<=m; i++) cout << i << \" \" << d[i] << \" \" << d2[i] << endl;\n    int l=0,ans=n;\n    for(int r=0; r<=m; r++) {\n      while(l<r&&d2[m]-d2[r]+d2[l]<s) l++;\n      int x=l?d[l-1]:0;\n      int y=r?d[r-1]:0;\n      if(d2[m]-d2[r]+d2[l]>=s) ans=min(ans,d[m]-y+x);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nint n,m;\ndouble w,h;\ndouble s;\ndouble l[30005],r[30005];\ndouble x[30005],y[30005];\nint num[30005];\nint sum[30005];\ndouble mj[30005];\n\ndouble cal(double a,double b,double c)\n{\n\tdouble p=(a+b+c)*0.5;\n\treturn sqrt(p*(p-a)*(p-b)*(p-c));\n}\nint main()\n{\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s))\n\t{\n\t\tif(n==0&&m==0&&w==0&&h==0&&s==0) break;\n\t\t\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%lf%lf\",&l[i],&r[i]);\n\t\tl[m+1]=h;r[m+1]=h;\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf\",&x[i],&y[i]);\n\t\t\n\t\tmemset(num,0,sizeof(num));\n\t\t\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint lo=1,hi=m+1;\n\t\t\twhile(lo<hi)\n\t\t\t{\n\t\t\t\tint mid=(lo+hi)/2;\n\t\t\t\tif((r[mid]-l[mid])*x[i]<(y[i]-l[mid])*w) lo=mid+1;\n\t\t\t\telse hi=mid-1;\n\t\t\t}\n\t\t\tif((r[lo]-l[lo])*x[i]<(y[i]-l[lo])*w) lo++;\n\t\t\tnum[lo-1]++;\n\t\t}\n\t\t\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor(int i=0;i<=m;i++)\n\t\t{\n\t\t\tif(i==0) sum[i]=num[i];\n\t\t\telse sum[i]=sum[i-1]+num[i];\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=m+1;i++)\n\t\t{\n\t\t\tif(i==1) \n\t\t\t{\n\t\t\t\tif(l[i]==l[i-1])\n\t\t\t\tmj[i-1]=cal(r[i]-r[i-1],sqrt((r[i]-l[i])*(r[i]-l[i])+w*w),sqrt((r[i-1]-l[i])*(r[i-1]-l[i])+w*w));\n\t\t\t\telse if(r[i]==r[i-1])\n\t\t\t\tmj[i-1]=cal(l[i]-l[i-1],sqrt((r[i]-l[i])*(r[i]-l[i])+w*w),sqrt((r[i]-l[i-1])*(r[i]-l[i-1])+w*w));\n\t\t\t\telse\n\t\t\t\tmj[i-1]=cal(l[i]-l[i-1],sqrt((l[i]-r[i-1])*(l[i]-r[i-1])+w*w),sqrt((l[i-1]-r[i-1])*(l[i-1]-r[i-1])+w*w))+\n\t\t\t\tcal(r[i]-r[i-1],sqrt((r[i]-l[i])*(r[i]-l[i])+w*w),sqrt((l[i]-r[i-1])*(l[i]-r[i-1])+w*w));\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(l[i]==l[i-1])\n\t\t\t\tmj[i-1]=mj[i-2]+cal(r[i]-r[i-1],sqrt((r[i]-l[i])*(r[i]-l[i])+w*w),sqrt((r[i-1]-l[i])*(r[i-1]-l[i])+w*w));\n\t\t\t\telse if(r[i]==r[i-1])\n\t\t\t\tmj[i-1]=mj[i-2]+cal(l[i]-l[i-1],sqrt((r[i]-l[i])*(r[i]-l[i])+w*w),sqrt((r[i]-l[i-1])*(r[i]-l[i-1])+w*w));\n\t\t\t\telse\n\t\t\t\tmj[i-1]=mj[i-2]+cal(l[i]-l[i-1],sqrt((l[i]-r[i-1])*(l[i]-r[i-1])+w*w),sqrt((l[i-1]-r[i-1])*(l[i-1]-r[i-1])+w*w))+\n\t\t\t\tcal(r[i]-r[i-1],sqrt((r[i]-l[i])*(r[i]-l[i])+w*w),sqrt((l[i]-r[i-1])*(l[i]-r[i-1])+w*w));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=sum[m];\n\t\tfor(int i=0;i<=m;i++)\n\t\t{\n\t\t\tdouble ss=mj[m]-mj[i];\n\t\t\tdouble left=s-ss;\n\t\t\tif(left<=0) {\n\t\t\tans=min(ans,sum[m]-sum[i]);\n\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint lo=0,hi=i;\n\t\t\twhile(lo<hi)\n\t\t\t{\n\t\t\t\tint mid=(lo+hi)/2;\n\t\t\t\tif(left-mj[mid]>0) lo=mid+1;\n\t\t\t\telse hi=mid-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(left-mj[lo]>0) lo++;\n\t\t\tans=min(ans,sum[m]-sum[i]+sum[lo]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=conj(b);\n  return (c.y>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n   \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n  arm[m+1]=n;\n}\n \nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  assert(n-res>=0);\n  return n-res;\n}\n \nint main(){\n   \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n     \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 30005\n\nclass Point{\npublic:\n\tdouble x,y;\n\n\tPoint(double x = 0,double y = 0):x(x),y(y){}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Info{\n\tint value;\n\tPolygon polygon;\n\tdouble min_y,max_y,S;\n};\n\nint num_almond,num_section;\nint ruiseki_value[NUM];\ndouble W,H,total_S,need_S;\ndouble ruiseki_S[NUM];\nInfo info[NUM];\nPoint pre_L,pre_R,L,R;\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\n//ベクトルaとbの外積を求める関数\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\n//ベクトルaとbの内積を求める関数\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\nPoint calc_minus(Point a,Point b){\n\tPoint ret;\n\n\tret.x = a.x-b.x;\n\tret.y = a.y-b.y;\n\n\treturn ret;\n}\n\n/*\n * IN 2\n * ON 1\n * OUT 0\n *\n */\nint contains(Polygon g,Point p){\n\tint n = g.size();\n\tbool x = false;\n\tfor(int i = 0; i < n; i++){\n\t\tPoint a = g[i]-p,b = g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n\t\tif(a.y > b.y)swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n\t}\n\treturn (x ? 2:0);\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < num_section; i++){\n\t\tinfo[i].value = 0; //断片内のアーモンドの個数\n\t\tinfo[i].polygon.clear();\n\t}\n\n\tpre_L.x = 0;\n\tpre_R.x = W;\n\n\tpre_L.y = 0;\n\tpre_R.y = 0;\n\n\tL.x = 0;\n\tR.x = W;\n\n\tfor(int i = 0; i < num_section; i++){\n\n\t\tscanf(\"%lf %lf\",&L.y,&R.y);\n\n\t\t//左下から反時計回りに点を記録\n\t\tinfo[i].polygon.push_back(pre_L);\n\t\tinfo[i].polygon.push_back(pre_R);\n\t\tinfo[i].polygon.push_back(R);\n\t\tinfo[i].polygon.push_back(L);\n\n\t\tinfo[i].min_y = min(pre_L.y,pre_R.y);\n\t\tinfo[i].max_y = max(L.y,R.y);\n\n\t\tinfo[i].S = (((L.y-pre_L.y)+(R.y-pre_R.y))*W)/2.0; //台形の面積\n\n\t\tpre_L = L;\n\t\tpre_R = R;\n\t}\n\n\t//アーモンドの処理\n\tPoint tmp;\n\tint left,right,m;\n\tint min_index,max_index;\n\n\tfor(int loop = 0; loop < num_almond; loop++){\n\n\t\tscanf(\"%lf %lf\",&tmp.x,&tmp.y);\n\n\t\t//アーモンドが所属し得る最小のインデックスを求める\n\t\tleft = 0,right = num_section-1,m = (left+right)/2;\n\t\tmin_index = num_section-1;\n\n\t\twhile(left <= right){\n\t\t\tif(info[m].max_y > tmp.y){\n\n\t\t\t\tmin_index = m;\n\t\t\t\tright = m-1;\n\n\t\t\t}else{\n\n\t\t\t\tleft = m+1;\n\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\t//アーモンドが所属し得る最大のインデックスを求める\n\t\tleft = 0,right = num_section-1,m = (left+right)/2;\n\t\tmax_index = 0;\n\n\t\twhile(left <= right){\n\n\t\t\tif(info[m].min_y < tmp.y){\n\n\t\t\t\tmax_index = m;\n\t\t\t\tleft = m+1;\n\n\t\t\t}else{\n\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tif(min_index > max_index)continue;\n\n\t\tfor(int i = min_index; i <= max_index; i++){\n\n\t\t\tif(contains(info[i].polygon,tmp) == 2){ //問題仕様上、ONは無いはず\n\t\t\t\tinfo[i].value++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//累積和テーブルを作成する\n\truiseki_S[0] = info[0].S;\n\truiseki_value[0] = info[0].value;\n\n\tfor(int i = 1; i < num_section; i++){\n\t\truiseki_S[i] = info[i].S;\n\t\truiseki_S[i] += ruiseki_S[i-1];\n\t\truiseki_value[i] = info[i].value;\n\t\truiseki_value[i] += ruiseki_value[i-1];\n\t}\n\n\ttotal_S = H*W;\n\tint ans = num_almond;\n\n\tdouble tmp_S;\n\tint tmp_almond;\n\n\tfor(int i = 0; i < num_section; i++){\n\t\t/*★シータの面積は大きいほど良い★*/\n\n\t\t//2分探索で、残チョコの面積がS以上となる、最大の上端を求める\n\t\tleft = 0,right = num_section-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\t//シータの面積を求める\n\t\t\tif(i != 0){\n\n\t\t\t\ttmp_S = ruiseki_S[m]-ruiseki_S[i-1];\n\n\t\t\t}else{\n\n\t\t\t\ttmp_S = ruiseki_S[m];\n\t\t\t}\n\n\t\t\tif(total_S-tmp_S >= need_S){ //残りがneed_S以上\n\n\t\t\t\tif(i != 0){\n\n\t\t\t\t\ttmp_almond = ruiseki_value[m]-ruiseki_value[i-1];\n\n\t\t\t\t}else{\n\n\t\t\t\t\ttmp_almond = ruiseki_value[m];\n\t\t\t\t}\n\n\t\t\t\tans = min(ans,num_almond-tmp_almond);\n\n\t\t\t\tleft = m+1;\n\n\t\t\t}else{\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %lf %lf %lf\",&num_almond,&num_section,&W,&H,&need_S);\n\t\tif(num_almond == 0 && num_section == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint n,m,w,h,S;\n// A[hªüªæèºÉ é©Ç¤©\nbool check(pair<int,int> p,double x,double y){\n    // X«\n    double d=(double)(p.first-p.second)/(0-w);\n    double yv=d*(x-0)+p.first;\n    return (yv>y);\n}\n\nint main(){\n    while(cin>>n>>m>>w>>h>>S&&!(n==0&&m==0&&w==0&&h==0&&S==0)){\n        int l,r;\n        vector<pair<int,int> > ps;\n        int armond[30001];\n        memset(armond,0,sizeof(armond));\n        ps.push_back(make_pair(0,0));\n        for(int i = 0; i < m; i++){\n            cin>>l>>r;\n            ps.push_back(make_pair(l,r));\n        }\n        // A[hªÇÌfÐãÉ é©ÍL¯µÄ¨­\n        for(int i = 0; i < n; i++){\n            double x,y;\n            cin>>x>>y;\n            // A[hª»ÌüæèºÉ éºÀðTõ\n            int ub=m;int lb=-1;\n            while(ub-lb>1){\n                bool b;\n                int med=(ub+lb)/2;\n                if(check(ps[med],x,y))\n                    ub=med;\n                else\n                    lb=med;\n            }\n            // ubÌlªºÀÌüª\n            armond[ub]++;\n        }\n        // µá­Æè@Å`R[gãðTõ\n        int head=0;int tail=0;\n        double peco=w*h;\n        int arNum=n;\n        const int INF=100000000;\n        int minArNum=INF;\n        // tailªÍÍ©çoéÜÅTõ\n        while(tail<=m&&head<=tail){\n            // ¶å¤¯ñð½µÄ¢éÈçXV\n            if(EQ(peco,S)||peco>S)\n                minArNum=min(minArNum,arNum);\n            // àµ»ÝÌ×[±Ì`R[gÌÊÏªSÈºÈçAheadðâ·\n            // »¤ÅÈ¢ÈçAtailðâ·\n            if(EQ(peco,S)||peco>S){\n                // tailðâ·\n                tail++;\n                if(!(tail<=m&&head<=tail))\n                    break;\n                // ÊÏðXV\n                double ss=((double)abs(ps[tail-1].first-ps[tail].first)+abs(ps[tail-1].second-ps[tail].second))*w/2.0;\n                peco-=ss;\n                arNum-=armond[tail];\n            }\n            else{\n                head++;\n                if(!(tail<=m&&head<=tail))\n                    break;\n                // ÊÏðXV\n                double ss=((double)abs(ps[head-1].first-ps[head].first)+abs(ps[head-1].second-ps[head].second))*w/2.0;\n                peco+=ss;\n                arNum+=armond[head];\n            }\n        }\n        cout<<minArNum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\n\nint pfind(int p){\n  int l = 0, r = m;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n    for(int i=0;i<n;i++){\n      int p = pfind(i);\n      hasa[p]++;\n    }\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag())\n        + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      if(i <= p && p <= m){\n        int cnt = n - (sumA[p] - sumA[i-1]);\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nint arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i])) up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n \nint solve(){\n  int res=0;\n  for(int i=0;i<=m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=((L[mid][0].y-L[i][0].y)+(L[mid][1].y-L[i][1].y))*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    L[0][0]=point(0,0);\n    L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF 101010\n\nstruct Point {\n    double x, y;\n    \n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Point a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS)  return -1; // COUNTER CLOCK WISE\n    return +0;\n}\n\n#define next(G,i) (G[(i+1)%G.size()])\n\ndouble get_area(double l, double r, int W)\n{\n    vector<Point> pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(W, 0);\n    pg[2] = Point(W, r);\n    pg[3] = Point(0, l);\n    \n    double res = 0;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tres += cross(pg[i], next(pg, i));\n    }\n    return abs(res)/2.0;\n}\n\n\nint main()\n{\n    int N, M, W, H, S;\n    while (cin >> N >> M >> W >> H >> S, N) {\n        vector<double> l(M+1), r(M+1);\n        l[0] = r[0] = 0;\n        \n        vector<int> s(M+1, 0);\n        for (int i = 1; i <= M; i++) {\n            cin >> l[i] >> r[i];\n            s[i] = get_area(l[i], r[i], W);\n        }        \n\n        vector<int> choco(M+1, 0);\n        \n        Point p;\n        for (int i = 0; i < N; i++) {\n            cin >> p.x >> p.y;\n            int lb = 0, ub = M+1;\n            while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ccw(Point(0, l[mid]), Point(W, r[mid]), p) == -1) {\n                    lb = mid;\n                } else {\n                    ub = mid;\n                }\n            }\n            choco[ub]++;\n        }\n\n        for (int i = 1; i <= M; i++) {\n            choco[i] += choco[i-1];\n        }\n        int res = INF;\n        for (int i = 0; i <= M; i++) {\n            int lb = i, ub = M+1;\n            int ns = s[i];\n            while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ns + (s[M] - s[mid]) < S) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n\n            if (ns + (s[M] - s[lb]) >= S) {\n                res = min(res, choco[M] - (choco[lb] - choco[i]));\n            }\n        }\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n      int test = 0;\n      REP(j,pos,m){\n\ttest++;\n\tassert(test<=10);\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-5)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      //if(!(p1 == Point(0,l[i])))\n\tpoly[i].push_back(p1);\n      poly[i].push_back(p2);\n      //if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n/*\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n*/\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      //if(!(p1 == Point(0,l[i])))\n\tpoly[i].push_back(p1);\n      poly[i].push_back(p2);\n      //if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n/*\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n*/\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\n\nint main(){\n\tint n,m,W,H;\n\tdouble S;\n\twhile(cin >> n >> m >> W >> H >> S && n){\n\t\tvector<double> x(n),y(n);\n\t\tvector< pair<int,int> > ln;\n\t\tvector<int> con;\n\t\tvector<int> idx;\n\t\tvector<int> rr;\n\t\tint prev = 0;\n\t\tvector<double> size(m+10);\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,rev=0;\n\t\t\tcin >> a >> b;\n\t\t\tif( a > b ) swap(a,b) , rev = 1;\n\t\t\t\n\t\t\tsize[i] += ((a-prev) * W + W * (b-a) / 2.0 );\n\t\t\tsize[i+1] += W*(b-a) / 2.0;\n\t\t\tif( prev != a ){\n\t\t\t\tln.push_back(make_pair(prev,a));\t\n\t\t\t\tcon.push_back(0);\n\t\t\t\tidx.push_back(i);\n\t\t\t\trr.push_back(0);\n\t\t\t}\n\t\t\tif( a != b ){\n\t\t\t\tln.push_back(make_pair(a,b));\n\t\t\t\tcon.push_back(1);\n\t\t\t\tidx.push_back(i);\n\t\t\t\trr.push_back(rev);\n\t\t\t}\n\t\t\tprev = b;\n\t\t}\n\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\t//scout << endl;\n\t\tvector<int> have(m+10);\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint id = upper_bound(ln.begin(),ln.end(),make_pair((int)(y[i]+1e-9),0)) - ln.begin() - 1;\n\t\t\tif( con[id] ){\n\t\t\t\tif( rr[id] ){\n\t\t\t\t\tdouble h = ln[id].second - (W-x[i]) * (ln[id].second - ln[id].first) / W;\n\t\t\t\t\tif( y[i] < h ){\n\t\t\t\t\t\thave[idx[id]]++;\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\thave[idx[id]+1]++;\t\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdouble h = ln[id].first + x[i] * (ln[id].second - ln[id].first) / W;\n\t\t\t\t\tif( y[i] < h ){\n\t\t\t\t\t\thave[idx[id]]++;\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\thave[idx[id]+1]++;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\thave[idx[id]]++;\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0 ; i < m ; i++){\n\t\t\tcout << have[i] << \" \" << size[i] << endl;\n\t\t}*/\n\t\tint l = 0 , r = 0;\n\t\tdouble sz = 0;\n\t\tint ans = 0 , get = 0;\n\t\twhile( l < m && r <= m ){\n\t\t\tif( W*H-sz + 1e-9 >= S  ){\n\t\t\t\tif( r >= m ) break;\n\t\t\t\tsz += size[r];\n\t\t\t\tget += have[r];\n\t\t\t\tr++;\n\t\t\t}else{\n\t\t\t\tsz -= size[l];\n\t\t\t\tget -= have[l];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\t//cout << l << \" \" << r << \" \" << W*H-sz << \" \" << S << \" \" << get << endl;\n\t\t\tif( get >= 0 && W*H-sz+1e-9 >= S  ) ans = max(get,ans);\n\n\t\t}\n\t\tcout << n - ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\ndouble ss[30001];\nint arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n\nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nvoid mk_area(){\n  ss[0]=0;\n  for(int i=1;i<=m;i++){\n    ss[i]=ss[i-1]+((L[i][0].y-L[i-1][0].y)+(L[i][1].y-L[i-1][1].y))*w/2.0;    \n  }\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    //mk_area();\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n      else assert(false);\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  while (true) {\n    long long n, m, w, h, s;\n    cin >> n >> m >> w >> h >> s;\n    s *= 2;\n    if (n == 0 && m == 0 && w == 0 && h == 0 && s == 0) break;\n    vector<long long> l(m), r(m), a(m + 1), c(m + 1);\n    vector<double> x(n), y(n);\n    rep (i, m) cin >> l[i] >> r[i];\n    rep (i, n) cin >> x[i] >> y[i];\n    rep (i, m) a[i + 1] = (l[i] + r[i]) * h;\n    a[0] = 0;\n    rep (i, c.size()) c[i] = 0;\n    rep (i, n) {\n      int a = -1, b = m;\n      while (a < b - 1) {\n\tint mid = (a + b) / 2;\n\tif (w * (y[i] - l[mid]) - (r[mid] - l[mid]) * x[i] > 1e-6) a = mid;\n\telse b = mid;\n      }\n      ++c[b + 1];\n    }\n    rep (i, c.size() - 1) c[i + 1] += c[i];\n    //rep (i, a.size()) cout << i << \" \" << a[i] << endl;\n    //rep (i, c.size()) cout << i << \" \" << c[i] << endl;\n    long long res = n;\n    rep (i, m + 2) {\n      int p = upper_bound(a.begin(), a.end(), w * h * 2 - s + a[i]) - a.begin();\n      --p;\n      //cout << i << \" \" << p << \" \" << n - c[p] + c[i] << endl;\n      res = min(res, n - c[p] + c[i]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX],lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      lower_y[i] = min(p1.y,p2.y);\n      lower_y[i] = min(lower_y[i],r[i]);\n      lower_y[i] = min(lower_y[i],l[i]);\n\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n\n    rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n    if(s == 0){\n      cout << 0 << endl;\n      continue;\n    }\n\n    rep(i,n){\n\n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos<0)pos++;\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n      continue;\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])) break;\n\telse if(check(M,i)) R = M;\n\telse L = M+1;\n      }\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else assert(false);\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n\tint add = talmond[pos];\n\tans = min(ans,add+counter);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nstruct Choco{\n\tint nut;\n\tdouble S;\n};\n\nint n,m,w,h,thre;\nChoco ch[30000];\n\nint solve(){\n\tstatic Choco acc[30001];\n\tacc[0]=(Choco){0,0};\n\trep(i,m) acc[i+1]=(Choco){acc[i].nut+ch[i].nut,acc[i].S+ch[i].S};\n\n\tint ans=INF;\n\trep(i,m){\n\t\tint lo=i,hi=m;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi+1)/2;\n\t\t\tif(acc[mi].S-acc[i].S<w*h-thre+EPS) lo=mi; else hi=mi-1;\n\t\t}\n\t\tans=min(ans,n-(acc[lo].nut-acc[i].nut));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&thre),n;){\n\t\tstatic int l[30001],r[30001];\n\t\tl[0]=r[0]=0;\n\t\trep(i,m) scanf(\"%d%d\",l+i+1,r+i+1);\n\n\t\trep(i,m){\n\t\t\tch[i].S=((l[i+1]-l[i])+(r[i+1]-r[i]))/2.0*w;\n\t\t\tch[i].nut=0;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble cx,cy; scanf(\"%lf%lf\",&cx,&cy);\n\n\t\t\tint lo=0,hi=m+1;\n\t\t\twhile(lo<hi){\n\t\t\t\tint mi=(lo+hi+1)/2;\n\t\t\t\tif(cx*l[mi]+(w-cx)*r[mi]<w*cy) lo=mi; else hi=mi-1;\n\t\t\t}\n\t\t\tch[lo].nut++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 30000;\nconst int INF = 100000000;\nconst double EPS = 1e-9;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0, double y = 0.0):x(x),y(y){}\n  Point operator + (Point &p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p) {return Point(x-p.x,y-p.y);}\n  bool operator < (const Point &s) const {\n    return y < s.y;\n  }\n  double norm(void){return x*x+y*y;}\n};\n\nint amd[N+1];\nint n, m, h, S;\nint W;\npair<double,double> line[N+2];\ndouble area[N+1];\nPoint amdData[N+1];\n\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a, Point b){\n  return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n  b = b - a;\n  c = c - a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(b.norm() < c.norm()) return -2;\n  return 0;\n}\n\ndouble calcArea(int p){\n  double l = line[p+1].first - line[p].first;\n  double r = line[p+1].second - line[p].second;\n  double area = (double)W*(l+r)/2.0;\n\n  return area;\n}\n\nint pos;\n\nint calcAmd(int p){\n  int res = 0;\n  double w = (double)W;\n  for(int i=pos;i<n;i++){\n    if(ccw(Point(0.0,line[p].first),amdData[i],Point(w,line[p].second)) * ccw(Point(0.0,line[p].first),amdData[i],Point(0.0,line[p+1].first)) <= 0){\n      if(ccw(Point(w,line[p+1].second),amdData[i],Point(w,line[p].second)) * ccw(Point(w,line[p+1].second),amdData[i],Point(0.0,line[p+1].first)) <= 0){\n        res++;\n        pos++;\n      }\n    }\n  }\n  //cout << \"(p,res) \" << p << \" \" << res << endl;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m >> W >> h >> S && (n|m|W|h|S)){\n    pos = 0;\n    fill(amd, amd+n, 0);\n    line[0] = pair<double,double>(0.0, 0.0);\n    for(int i=1;i<=m;i++){\n      double a, b;\n      cin >> a >> b;\n      line[i] = pair<double,double>(a, b);\n    }\n    for(int i=0;i<n;i++){\n      cin >> amdData[i].x >> amdData[i].y;\n    }\n    sort(amdData, amdData+n);\n    int cc = 0;\n    for(int i=0;i<m;i++){\n      if(cc < n) amd[i] = calcAmd(i);\n      else amd[i] = 0;\n      cc += amd[i];\n      area[i] = calcArea(i);\n    }\n    int ans = n;\n    for(int i=0;i<m;i++){\n      int sumamd = 0;\n      double sum = 0.0;\n      //cout << \"===== \" << i << ' ';\n      for(int j=i;j<m;j++){\n        //cout << j << ' ' ;\n        sumamd += amd[j];\n        sum += area[j];\n        if((double)h*W - sum < (double)S) break;\n        ans = min(ans, n-sumamd);\n      }\n      //cout << endl;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n#define EPS 1e-12\n\nstruct point{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (point p){ return point(x+p.x,y+p.y);}\n    point operator - (point p){ return point(x-p.x,y-p.y);}\n    void make(){ cin>>x>>y; }\n};\n\ndouble cross(point a,point b){return a.x*b.y - a.y*b.x; }\n\nint ccw(point p0,point p1,point p2){\n    point a = p1-p0;\n    point b = p2-p0;\n    if( cross(a,b) > EPS )return 1;\n    else return -1;\n}\nstruct line{\n    point s,t;\n    line(){}\n    line(point s,point t):s(s),t(t){}\n};\nint main(){\n    while(1){\n\tint n,m,w,h,S;\n\tcin>>n>>m>>w>>h>>S;\n\tif(n==0)break;\n\tpoint p0 = point(0,0);\n\tpoint p1 = point(w,0);\n\tpoint p2 = point(0,h);\n\tpoint p3 = point(w,h);\n\tvector<line> ls(m+2);\n\tvector<double> l(m),r(m),s(m+1);\n\tls[0] = line(p0,p1);\n\ts[0] = 0;\n\tfor(int i=0;i<m;i++){\n\t    cin>>l[i]>>r[i];\n\t    s[i+1] = (((double)(l[i]+r[i]))*w)/2.0;\n\t    ls[i+1] = line( point(0,l[i]),point(w,r[i]) );\n\t}\n\tls[m+1] = line(p2,p3);\n\t//s[m+1] = w*h;\n\tvector<int> cnt(m+1,0);\n\tfor(int i=0;i<n;i++){\n\t    point p;\n\t    p.make();\n\t    int upper = m+1,low = 0;\n\t    while(upper-low>1){\n\t\tint mid = (upper+low)/2;\n\t\tif( ccw(ls[mid].s,ls[mid].t,p) * ccw(ls[mid+1].s,ls[mid+1].t,p) <= -1 )break;\n\t\tif( ccw(ls[mid].s,ls[mid].t,p) > 0 ) low =mid;\n\t\telse upper= mid;\n\t    }\n\t    int mid = (upper+low)/2;\n\t //   if( ccw(ls[mid].s,ls[mid].t,p) * ccw(ls[mid+1].s,ls[mid+1].t,p) <= -1 ) cnt[mid]++;\n\t    cnt[ mid+1 ]++;\n\t    //if( mid< m+1&&ccw(ls[mid].s,ls[mid].t,p) * ccw(ls[mid+1].s,ls[mid+1].t,p) <= -1 ) cnt[mid]++;\n\t}\n\tfor(int i=0;i<m;i++) cnt[i+1] +=cnt[i];\n\tint res = 0;\n\t//for(int i=0;i<=m+1;i++){\n\t  //  cout<<cnt[i]<<' '<<s[i]<<endl;\n\t//}\n\tfor(int i=0;i<m;i++){\n\t    double ss = s[i];\n\t    int cc = cnt[i];\n\t    auto it = upper_bound(s.begin(),s.end(),w*h - S+ss );\n\t    //if(it == s.end() ) continue;\n\t    it--;\n\t    int index = it-s.begin();\n\t    res = max(res, cnt[index]-cc);\n\t}\n\tcout<<n-res<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst int M = 30010;\nstruct Point {\n\tdouble x, y;\n} almond[M], center;\nstruct Vector {\n\tPoint a, b;\n} line[M];\n\ndouble xmulti(const Point p1, const Point p2, const Point p0) {\n\treturn (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);\n}\n\ndouble same_side(const Point p1, const Point p2, const Vector vec) {\n\treturn xmulti(vec.a, p1, vec.b) * xmulti(vec.a, p2, vec.b);  // >0 sameside\n}\n\nint main() {\n    int n, m, w, h, s;\n    while (scanf(\"%d%d%d%d%d\", &n, &m, &w, &h, &s), n) {\n        int sum[M] = {0};\n        center.x = w / 2.0;\n        center.y = 0;\n        for (int i = 1; i <= m; i++) {\n            scanf(\"%lf%lf\", &line[i].a.y, &line[i].b.y);\n            line[i].a.x = 0;\n            line[i].b.x = w;\n        }\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf%lf\", &almond[i].y, &almond[i].x);\n            int L = 0, R = m, idx = -1;\n            while (L <= R) {\n                int mid = (L + R) / 2;\n                if (same_side(almond[i], center, line[mid]) < EPS) {\n                    L = mid + 1;\n                } else {\n                    R = mid - 1;\n                    idx = mid;\n                }\n            }\n            sum[idx]++;\n        }\n        for (int i = 1; i <= m; i++) {\n            sum[i] += sum[i-1];\n        }\n        int res = 1 << 29;\n        for (int i = 0; i <= m; i++) {\n            int L = 0, R = i, idx = -1;\n            while (L <= R) {\n                int mid = (L + R) / 2;\n                if ((line[i].a.y + line[i].b.y - line[mid].a.y - line[mid].b.y) * w > 2 * (w * h - s)) {\n                    L = mid + 1;\n                } else {\n                    R = mid - 1;\n                    idx = mid;\n                }\n            }\n            if (idx != -1) {\n                int cnt = n - (sum[i] - sum[idx]);\n                res = min(res, cnt);\n            }\n        }\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nconst int MAX_N = 30001;\n\nint L[MAX_N], R[MAX_N], sum[MAX_N];\nint n, m, w, h, s;\n\nint bin_search_line(double x, double y) {\n\tint l = 0, r = m, line = 0;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif ((y - L[mid]) * w > x * (R[mid] - L[mid])) {\n\t\t\tl = mid + 1;\n\t\t} else r = mid - 1, line = mid;\n    }\n    return line;\n}\n\nint bin_search_level(int end) {\n\tint l = 0, r = end, level = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif ((L[end] - L[mid] + R[end] - R[mid]) * w > 2 * (w * h - s)) {\n\t\t\tl = mid + 1;\n\t\t} else r = mid - 1, level = mid;\n\t}\n\treturn level;\n}\n\nvoid solve() {\n\tL[0] = R[0] = 0.;\n\tfill(sum, sum + m + 1, 0);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &L[i], &R[i]);\n\t}\n\tdouble x, y;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t++sum[bin_search_line(x, y)];\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tsum[i] += sum[i - 1];\n\t}\n\tint res = n;\n\tfor (int i = 0; i <= m; i++) {\n\t\tint index = bin_search_level(i);\n\t\tif (-1 == index) continue;\n\t\tres = min(res, n - (sum[i] - sum[index]));\n\t}\n\tprintf(\"%d\\n\", res);\n}\n\nint main() {\n\twhile (5 == scanf(\"%d%d%d%d%d\", &n, &m, &w, &h, &s)) {\n\t\tif (0 == n) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\ndouble ss[30001];\nint arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n\nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(w*h-(ss[mid]-ss[i])<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nvoid mk_area(){\n  ss[0]=0;\n  for(int i=1;i<=m;i++){\n    ss[i]=ss[i-1]+((L[i][0].y-L[i-1][0].y)+(L[i][1].y-L[i-1][1].y))*w/2.0;    \n  }\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_area();\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nstruct Choco{\n\tint nut;\n\tdouble S;\n};\n\nint n,m,w,h,thre;\nChoco ch[30000];\n\nint solve(){\n\tstatic Choco acc[30001];\n\tacc[0]=(Choco){0,0};\n\trep(i,m) acc[i+1]=(Choco){acc[i].nut+ch[i].nut,acc[i].S+ch[i].S};\n\n\tint ans=INF;\n\trep(i,m){\n\t\tint lo=i,hi=m;\n\t\twhile(lo<hi){\n\t\t\tint mi=(lo+hi+1)/2;\n\t\t\tif(acc[mi].S-acc[i].S<w*h-thre+EPS) lo=mi; else hi=mi-1;\n\t\t}\n\t\tans=min(ans,n-(acc[lo].nut-acc[i].nut));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&thre),n;){\n\t\tstatic int l[30001],r[30001];\n\t\tl[0]=r[0]=0;\n\t\trep(i,m) scanf(\"%d%d\",l+i+1,r+i+1);\n\n\t\trep(i,m){\n\t\t\tch[i].S=((l[i+1]-l[i])+(r[i+1]-r[i]))/2.0*w;\n\t\t\tch[i].nut=0;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble cx,cy; scanf(\"%lf%lf\",&cx,&cy);\n\n\t\t\tint lo=0,hi=m+1;\n\t\t\twhile(lo<hi){\n\t\t\t\tint mi=(lo+hi+1)/2;\n\t\t\t\tif((w-cx)*l[mi]+cx*r[mi]<w*cy) lo=mi; else hi=mi-1;\n\t\t\t}\n\t\t\tch[lo].nut++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t} else if(inPolygon(poly[L],ps[i])){\n\t  M = L;\n\t  break;\n\t} else if( R < m && inPolygon(poly[R],ps[i])){\n\t  M = R;\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tbool found = false;\n\trep(k,10){\n\t  if(L-k >= 0 && inPolygon(poly[L-k],ps[i])){\n\t    almond[L-k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t  if(R+k < m && inPolygon(poly[R+k],ps[i])){\n\t    almond[R+k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nint arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  b/=abs(b);\n  c*=b;\n  return (c.y>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i])) up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n \nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=((L[mid][0].y-L[i][0].y)+(L[mid][1].y-L[i][1].y))*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    L[0][0]=point(0,0);\n    L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define eps 1e-8\n#define _sign(x) ((x)<-eps?-1:(x)>eps)\n\nstruct point\n{\n    double x, y;\n} tem, p[30050];\n\nstruct line\n{\n    point a, b;\n\n    bool operator<(const line & x)const\n    {\n        if (fabs(a.y - x.a.y) < eps) return b.y < x.b.y + eps;\n        return a.y < x.a.y + eps;\n    }\n} l[30050];\nint n, m, w, h, s;\nint cnt[30050];\ndouble area[30050];\n\ndouble xmult(point p0, point p1, point p2)\n{\n    return (p1.x - p0.x)*(p2.y - p0.y)-(p2.x - p0.x)*(p1.y - p0.y);\n}\nint Xmult(line l, point p) {\n    return (l.a.x - l.b.x)*(p.y - l.b.y)-(p.x - l.b.x)*(l.a.y - l.b.y);\n}\nint fuck(point aa)\n{\n    int lef = 0, rig = n;\n    while (lef <= rig)\n    {\n        int mid = (lef + rig) / 2;\n        if(_sign(Xmult(l[mid-1], aa))<0&&_sign(Xmult(l[mid], aa))>0)\n            return mid-1;\n        if (_sign(Xmult(l[mid], aa))<0)\n            lef = mid+1;\n        else rig = mid-1;\n    }\n}\n\ndouble sss(line x, line y)\n{\n    return fabs(xmult(x.a, x.b, y.b)) +fabs(xmult(x.a, y.b, y.a));\n}\n\nint main()\n{\n    while (scanf(\"%d%d%d%d%d\", &m, &n, &w, &h, &s) && n)\n    {\n        l[n].a.x = 0, l[n].a.y = 0;\n        l[n].b.x = w, l[n].b.y = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            scanf(\"%lf%lf\", &l[i].a.y, &l[i].b.y);\n            l[i].a.x = 0;\n            l[i].b.x = w;\n        }\n        n++;\n        sort(l, l + n);\n        for (int i = 0; i < n; ++i) cnt[i] = 0;\n        for (int i = 1; i < n; ++i)\n            area[i - 1] = sss(l[i - 1], l[i]) / 2.0;\n        for (int i = 0; i < m; ++i){\n            point tem;\n            scanf(\"%lf%lf\",&tem.x,&tem.y);\n            cnt[fuck(tem)]++;\n        }\n        double ss = 0;\n        int up = 0, down = 0, ans=-1, temp = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            up = i;\n            ss += area[up];\n            temp += cnt[up];\n            while (w * h - ss < s - eps)\n            {\n                ss -= area[down];\n                temp -= cnt[down];\n                down++;\n            }\n            ans = max(ans, temp);\n        }\n        printf(\"%d\\n\", m - ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint n, m, w, h;\ndouble S;\ndouble l[30002], r[30002];\ndouble x[30002], y[30002], s[30002];\nint a[30002];\n\ndouble cross(const P &A, const P&B){\n  return imag(conj(A) * B);\n}\n\ndouble dot(const P &A, const P &B){\n  return real(conj(A) * B);\n}\n\nint ccw(P A, P B, P C){\n  B -= A;\n  C -= A;\n  if(cross(B, C) > 0) return +1;\n  if(cross(B, C) < 0) return -1;\n  if(dot(B, C) < 0) return +2;\n  if(norm(B) < norm(C)) return -2;\n  return 0;\n}\n\nint getPos(int X, int Y){\n  int L = 0, H = m - 1;\n\n  while(L < H){\n    int mid = (L + H) / 2;\n    int dir = ccw(P(0, l[mid]), P(w, r[mid]), P(X, Y));\n\n    if(dir == -1){\n      H = mid;\n    }\n    else{\n      L = mid + 1;\n    }\n  }\n\n  return L;\n}\n\nint main(){\n  while(cin >> n >> m >> w >> h >> S, n){\n    memset(a, 0, sizeof(a));\n\n    for(int i = 0; i < m; i++){\n      cin >> l[i] >> r[i];\n      s[i] = (l[i] + r[i]) * w / 2.0;\n    }\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i];\n      int pos = getPos(x[i], y[i]);\n      a[pos]++;\n    }\n\n    for(int i = 1; i < m; i++){\n      a[i] += a[i - 1];\n    }\n\n    int L = 0, H = 0;\n    int ans = 0;\n\n    while(L < m){\n      H = L;\n\n      while(H < m){\n        double area = s[H] - (0 <= L - 1 ? s[L - 1] : 0);\n        if(area > w * h - S){\n          break;\n        }\n        H++;\n      }\n\n      H--;\n\n      if(L <= H){\n        ans = max(ans, a[H] - (0 <= L - 1 ? a[L - 1] : 0));\n      }\n\n      L++;\n    }\n\n    cout << n - ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30000;\nconst int M = 30000;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\nP t;\n\nbool comp(const P &p1, const P &p2){\n  bool f1 = t.imag() <= (p1.imag() - p1.real()) * t.real() / w + p1.real();\n  //bool f2 = t.imag() <= (p2.imag() - p2.real()) * t.real() / w + p2.real();\n  return f1;\n  //return f1 < f2;\n}\n\nint pfind(int p){\n  int l = 0, r = m - 1;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n/*\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n        if(a[j].imag() <= (ver[i].imag() - ver[i].real()) * a[j].real() / w + ver[i].real()){\n          cout << a[j].imag() << ' ' <<  (ver[i].imag() - ver[i].real()) * a[j].real() / w + ver[i].real() << endl;\n          cout << i << ' ' << j << endl;\n        }\n      }\n    }\n*/\n    for(int i=0;i<n;i++){\n      t = a[i];\n      //int p = lower_bound(ver.begin(), ver.end(), true, comp) - ver.begin();\n      int p = pfind(i);\n      //cout << i << \": p = \" << p << endl;\n      hasa[p]++;\n    }\n    /*for(int i=0;i<m;i++){\n      cout << hasa[i] << ' ';\n      }\n      cout << endl;*/\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag()) + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    /*for(int i=0;i<=m;i++){\n      cout << sumS[i] << ' ';\n    }\n    cout << endl;*/\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    /*for(int i=0;i<=m;i++){\n      cout << sumA[i] << ' ';\n    }\n    cout << endl;*/\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS+i, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      //cout << i << \": p = \" << p << endl;\n      if(0 <= p && p <= m){\n        int cnt = n - (sumA[p] - sumA[i-1]);\n        //cout << \"n = \" << n << \", cnt = \" << cnt << endl;\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos-=4;\n      if(pos < 0)pos++;\n\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n\tassert( j != m-1 );\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = (1<<29),M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(R >= m){\n\t  R = M;\n\t  continue;\n\t}\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t} else if(inPolygon(poly[L],ps[i])){\n\t  M = L;\n\t  break;\n\t} else if( R < m && inPolygon(poly[R],ps[i])){\n\t  M = R;\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FILEIN (freopen (\"in\", \"r\", stdin))\n#define FILEOUT (freopen (\"out\", \"w\", stdout))\n\nconst int maxn = 33333;\nconst double eps = 1e-8;\n\ndouble area[maxn];\nint num[maxn];\ndouble sumA[maxn];\nint sumN[maxn];\n\nint n, m;\ndouble w, h, s;\nstruct point {\n\tdouble x, y;\n} p;\nstruct line {\n\tpoint a, b;\n} L[maxn];\n\ndouble xmult (const point &p1, const point &p2, const point &p0) {\n\treturn (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);\n}\n\nvoid sumArea () {\n\tdouble u, d;\n\tfor (int i = 0; i <= m; ++ i) {\n\t\tu = L[i+1].a.y - L[i].a.y;\n\t\td = L[i+1].b.y - L[i].b.y;\n\t\tarea[i] = (u + d) * w / 2;\n\t}\n}\nint bin (const point &p, int l, int r) {\n\tint m;\n\tint ret = -1;\n\twhile (l <= r) {\n\t\tm = (l+r) / 2;\n\t\tif (xmult (L[m].a, L[m].b, p) >= 0) {\n\t\t\tret = m;\n\t\t\tl = m + 1;\n\t\t}\n\t\telse {\n\t\t\tr = m - 1;\n\t\t}\n\t}\n\treturn ret;\n}\nvoid sumNum () {\n\tfor (int i = 0; i < n; ++ i) {\n\t\tscanf (\"%lf%lf\", &p.x, &p.y);\n\t\tint pos = bin (p, 0, m+1); // 二分在&#21738;一条&#32447;后面,不可能在M+1后面\n\t\tnum[pos] ++;\n\t}\n}\nint main () {\n\t/*FILEIN;\n\tFILEOUT;*/\n\twhile (~scanf (\"%d%d%lf%lf%lf\", &n, &m, &w, &h, &s)) {\n\t\tif (!n) break;\n\t\tmemset (area, 0, sizeof (area));\n\t\tmemset (num, 0, sizeof (num));\n\t\tfor (int i = 1; i <= m; ++ i) {\n\t\t\tscanf (\"%lf%lf\", &L[i].a.y, &L[i].b.y);\n\t\t\tL[i].a.x = 0, L[i].b.x = w;\n\t\t}\n\t\tL[m+1].a.x = 0, L[m+1].a.y = h, L[m+1].b.x = w, L[m+1].b.y = h;\n\t\tsumArea ();\n\t\tsumNum ();\n\t\tmemset (sumA, 0, sizeof (sumA));\n\t\tmemset (sumN, 0, sizeof (sumN));\n\t\tsumA[1] = area[0], sumN[1] = num[0];\n\t\tfor (int i = 2; i <= m+1; ++ i) {\n\t\t\tsumA[i] = sumA[i-1] + area[i-1];\n\t\t\tsumN[i] = sumN[i-1] + num[i-1];\n\t\t}\n\t\ts = w * h - s;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= m+1; ++ i) {\n\t\t\tint l = i, r = m+1;\n\t\t\twhile (l <= r) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (sumA[m] - sumA[i-1] <= s) {\n\t\t\t\t\tl = m + 1;\n\t\t\t\t\tif (ans < sumN[m] - sumN[i-1]) ans = sumN[m] - sumN[i-1];\n\t\t\t\t}\n\t\t\t\telse r = m - 1;\n\t\t\t}\n\t\t}\n\t\tprintf (\"%d\\n\", n - ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAXN 30050\n#define eps 1e-8\ntypedef struct point {\n    double x,y;\n\tpoint (){\n  \n\t}\n\tpoint (double xx,double yy){\n          x = xx;\n\t\t  y = yy;\n\t}\n\tvoid setxy(double xx,double yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tpoint operator-(point aa){\n        return point (x-aa.x,y-aa.y);\n\t}\n\tvoid read(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n};\ntypedef struct Lines{\n    point st,ed;\n\tvoid setp(point aa,point bb){\n\t\tst = aa;\n\t\ted = bb;\n\t}\n};\ntypedef point Vector;\ntypedef struct node{\n    double s,pres;\n\tint chm,prechm;\n\tdouble lh,rh;\n\tpoint LP,RP;\n\tvoid init(){\n       s = pres = 0.0;\n\t   chm = prechm = 0;\n\t}\n\tvoid read(){\n      scanf(\"%lf%lf\",&lh,&rh);\n\t}\n\tvoid setlr(double Lx,double Rx){\n\t\tLP.setxy(Lx,lh);\n\t\tRP.setxy(Rx,rh);\n\t}\n};\nnode no[MAXN];\npoint chmo[MAXN];\nLines LL[MAXN];\ndouble Cross(point aa,point bb){\n    return aa.x*bb.y-aa.y*bb.x;\n}\nint dcmp(double x){\n   if(fabs(x)<eps) return 0;\n   return x<0?-1:1;\n}\ndouble prearea(point aa,point bb,point cc,point dd){\n      double area1 = fabs(Cross(aa-bb,dd-bb));\n\t  double area2 = fabs(Cross(dd-bb,cc-bb));\n\t  return (area1+area2)/2;\n}\nvoid presoch(int n,int m,int k){\n\t   int L,R,Mid;\n\t  for(int i=0;i<n;++i){\n\t\t L = 1;R = m;\n\t\t while(L<R){\n\t\t\t Mid = (L+R)>>1;\n\t\t\t if(dcmp(Cross(LL[Mid].st - chmo[i],LL[Mid].ed-chmo[i]))<=0)\n\t\t\t\t R = Mid;\n\t\t\t else L = Mid+1;\n\t\t }\n\t\t while(1){\n\t\t\t if(dcmp(Cross(LL[L].st - chmo[i],LL[L].ed-chmo[i]))>0)\n\t\t\t\t --L;\n\t\t\t else break;\n\t\t }\n\t\t no[L-1].chm++;\n\t  }\n\t  for(int i=1;i<=k;++i){\n             no[i].prechm = no[i].chm+no[i-1].prechm;\n\t  }\n\t//  return L;\n}\ndouble gets(int ind1,int ind2){\n\n      if(!ind1){\n\t\t  return no[ind2].pres;\n\t  }\n\t   return (no[ind2].pres - no[ind1-1].pres); \n}\nint getch(int L,int R){\n        if(!L){\n\t\t\treturn no[R].prechm;\n\t\t}\n\t\treturn no[R].prechm - no[L-1].prechm;\n}\nint solve(int n,int m,double S){\n\n\tint ans = n;\n\tint L,R,Mid;\n\tdouble AS = no[m].pres - S;\n\tdouble ALLS = no[m].pres;\n\tint Chms = no[m].prechm;\n\tdouble tmps;\n\tint tmpch;\n\tfor(int i=0;i<=m;++i){\n\t\tL = i;\n\t\tR = m;\n\t\twhile(L<R){\n\t\t\tMid = (L+R)>>1;\n\t\t\ttmps = gets(i,Mid);\n\t\t\tif(dcmp(tmps-AS)>0){\n\t\t\t\tR = Mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL = Mid+1;\n\t\t\t}\n\t\t}\n\t\t//謇セ蛻ー莠?\t\ttmps = gets(i,L);\n\t\ttmps = ALLS -tmps;\n\t\tif(dcmp(tmps-S)>=0){\n\t\ttmpch = Chms -  getch(i,L);\n\t\tif(tmpch<ans){ans = tmpch;}\n\t\t}\n\t\tif(L-1>=i){\n\t\t\t--L;\n\t\ttmps = gets(i,L);\n\t\ttmps = ALLS -tmps;\n\t\tif(tmps>=S){\n\t\t\ttmpch = Chms -  getch(i,L);\n\t\t\tif(tmpch<ans){ans = tmpch;}\n\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint n,m;\n\tdouble w,h,S;\n\tpoint dwL,dwR,upL,upR;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tscanf(\"%lf%lf%lf\",&w,&h,&S);\n\t\tif(!n&&!m&&!w&&!h&&!S)break;\n\t\tdwL.setxy(0,0);\n\t\tdwR.setxy(w,0);\n\t\tLL[0].setp(dwL,dwR);\n\t\tupL.setxy(0,h);\n\t\tupR.setxy(w,h);\n\t\tLL[m+1].setp(upL,upR);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tno[i].read();\n\t\t\tno[i].setlr(0,w);\n\t\t\tno[i].init();\n\t\t\tLL[i+1].setp(no[i].LP,no[i].RP);\n\t\t}\n\t\tno[m].init();\n\t\tfor(int i=0;i<n;++i){\n\t\t\tchmo[i].read();\n\t\t}\n\t\tdouble area = prearea(no[0].LP,dwL,dwR,no[0].RP);\n\t\tno[0].s = area;\n\t\tno[0].pres = area;\n\t\tint tmpup = m-1;\n\t\tfor(int i=1;i<=tmpup;++i){\n\t\t   no[i].s = prearea(no[i].LP,no[i-1].LP,no[i-1].RP,no[i].RP);\n\t\t   no[i].pres = no[i].s+no[i-1].pres;\n\t\t}\n\t\tif(m>=1){\n\t\tno[m].s  = prearea(upL,no[m-1].LP,no[m-1].RP,upR);\n\t\tno[m].pres=no[m].s+no[m-1].pres;\n\t\t}\n\t\t//譚丈サ∵焚\n\t\tpresoch(n,m+2,m);\n\t\tint ans = solve(n,m,S);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF 101010\n\nstruct Point {\n    double x, y;\n    \n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Point a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS)  return -1; // COUNTER CLOCK WISE\n    return +0;\n}\n\n#define next(G,i) (G[(i+1)%G.size()])\n\ndouble get_area(double l, double r, int W)\n{\n    vector<Point> pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(W, 0);\n    pg[2] = Point(W, r);\n    pg[3] = Point(0, l);\n    \n    double res = 0;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tres += cross(pg[i], next(pg, i));\n    }\n    return abs(res)/2.0;\n}\n\n\nint main()\n{\n    int N, M, W, H, S;\n    while (cin >> N >> M >> W >> H >> S, N) {\n        vector<double> l(M+1), r(M+1);\n        l[0] = r[0] = 0;\n        \n        vector<int> s(M+1, 0);\n        for (int i = 1; i <= M; i++) {\n            cin >> l[i] >> r[i];\n            s[i] = get_area(l[i], r[i], W);\n        }        \n\n        vector<int> choco(M+1, 0);\n        \n        Point p;\n        for (int i = 0; i < N; i++) {\n            cin >> p.x >> p.y;\n            int lb = 0, ub = M+1;\n            while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ccw(Point(0, l[mid]), Point(W, r[mid]), p) == -1) {\n                    lb = mid;\n                } else {\n                    ub = mid;\n                }\n            }\n            choco[ub]++;\n        }\n\n        for (int i = 1; i <= M; i++) {\n            choco[i] += choco[i-1];\n        }\n        int res = INF;\n        for (int i = 0; i <= M; i++) {\n            int lb = i, ub = M+1;\n            int ns = s[i];\n            while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ns + (s[M] - s[mid]) < S) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n\n            if (ns + (s[M] - s[lb]) >= S) {\n                res = min(res, choco[M] - (choco[lb] - choco[i]));\n            }\n        }\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n}\n \ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n \nint main() {\n  int n,m,w,h,s;\n  while(cin >> n >> m >> w >> h >> s && n) {\n    P a[m];\n    int d[m+1];\n    double d2[m+1];\n    d2[0]=0;\n    memset(d,0,sizeof(d));\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n      vector<P> v(4);\n      v[0]=P(0,0);\n      v[1]=P(w,0);\n      v[2]=P(w,a[i].imag());\n      v[3]=P(0,a[i].real());\n      d2[i+1]=area(v);\n    }\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      P p=P(x,y);\n      int l=0,r=m;\n      while(l+1!=r) {\n        int k=(l+r)/2;\n        vector<P> v(4);\n        v[0]=P(0,0);\n        v[1]=P(w,0);\n        v[2]=P(w,a[k].imag());\n        v[3]=P(0,a[k].real());\n        if(convex_contains(v,p)<2) l=k;\n        else r=k;\n      }\n      d[l+1]++;\n    }\n    for(int i=0; i<m; i++) d[i+1]+=d[i];\n    int l=0,ans=1<<29;\n    for(int r=0; r<=m; r++) {\n      while(l<r&&d2[r]-d2[l]>d2[m]-s) l++;\n      int x=l?d[l-1]:0;\n      int y=r?d[r-1]:0;\n      if(d2[m]-d2[r]+d2[l]>=s) ans=min(ans,d[m]-y+x);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad テ」ツ?ッティツァツ津・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテヲツ個?」ツ?淌」ツ?崚」ツつ凝」ツ?禿」ツ?ィ\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// テ・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//テ・ツ、ツ堙ィツァツ津・ツスツ「polyテ・ツ??ッツシツ暗ァツキツ堙・ツ按?、ツクツ甘」ツつづ・ツ青ォテ」ツつ?ッツシツ嘉」ツ?ォテァツつケpテ」ツ?古・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?ッテ・ツ按、テ・ツョツ堙」ツ?凖」ツつ? \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n\n    rep(i,n) cin >> ps[i].x >> ps[i].y;\n\n    if(s == 0){\n      cout << 0 << endl;\n      continue;\n    }\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])) break;\n\telse if(check(M,i)) R = M;\n\telse L = M+1;\n      }\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else assert(false);\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n\tint add = talmond[pos];\n\tans = min(ans,add+counter);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n#define sz(v) v.size()\n#define mk(x, y) make_pair(x, y)\n#define fst first\n#define scd second\n#define MEMSET(x, n) memset(x, n, sizeof(x))\n#define MEMZERO(x) MEMSET(x, 0)\n#define URU(y) (!(y % 4) && y % 100 || !(y % 400))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nstruct Line\n{\n\tdouble l;\n\tdouble r;\n\tint num;\n};\n\nenum Check\n{\n\tLOW = 0,\n\tMID,\n\tHIGH,\n};\n\ndouble cross_product( float x1, float y1, float x2, float y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\ninline Check inRange( Line l, Line h, double x, double y, double w )\n{\n\tdouble v1, v2;\n\t\n\tv1 = cross_product(w, (l.r - l.l), x, (y - l.l));\n\tv2 = cross_product(w, (h.r - h.l), x, (y - h.l));\n\t\n\tif (0 < v1 && 0 < v2)\n\t\treturn HIGH;\n\tif (0 > v1 && 0 > v2)\n\t\treturn LOW;\n\telse\n\t\treturn MID;\n}\n\nint main( void )\n{\n\tint n, m, w, h, S;\n\tLine T[30010];\n\tint N1[30010], S1[30010];\n\t\n\twhile ( cin >> n >> m >> w >> h >> S, n | m | w | h | S )\n\t{\n\t\tMEMZERO(T);\n\t\t\n\t\trep2 (i, 1, (m + 1))\n\t\t{\n\t\t\tcin >> T[i].l >> T[i].r;\n\t\t}\n\t\t\n\t\trep (i, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\tint low = 1, high = m;\n\t\t\twhile (low <= high)\n\t\t\t{\n\t\t\t\tint mid = (low + high) / 2;\n\t\t\t\tCheck c = inRange(T[mid-1], T[mid], x, y, (double)w);\n\t\t\t\t\n\t\t\t\tif (c == LOW)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse if (c == HIGH)\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\telse // c == Check::MID\n\t\t\t\t{\n\t\t\t\t\t// cout << mid << endl;\n\t\t\t\t\t++T[mid].num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n/*\n\t\t\trep2 (j, 1, (m + 1))\n\t\t\t{\n\t\t\t\tif (inRange(T[j-1], T[j], x, y, (double)w))\n\t\t\t\t{\n\t\t\t\t\t++T[j].num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint ans = n, sum = 0;\n\t\t\n\t\trep (i, (m + 1))\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tN1[i] = sum;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif ((S * 2) <= (S1[i] = ((T[i].l + T[i].r) * w)))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout << ans << endl;\n/*\n\t\tsum = 0;\n\t\trepm (i, m, 0)\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tN2[i] = sum;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif((S * 2) <= (S2[i] = ((2 * h - (T[i-1].l + T[i-1].r)) * w)))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n*/\n\t\t// cout << ans << endl;\n\t\t\n\t\tsum = 0;\n\t\trep2 (i, 0, m)\n\t\t{\n\t\t\tif (ans <= N1[i])\n\t\t\t\tbreak;\n\t\t\tint sub_sum = 0;\n\t\t\trepm (j, m, (i + 1))\n\t\t\t{\n\t\t\t\tsub_sum += T[j].num;\n\t\t\t\tif (ans <= (N1[i] + sub_sum))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((S * 2) <= (((2 * h - (T[j-1].l + T[j-1].r)) * w) + S1[i]))\n\t\t\t\t{\n\t\t\t\t\tans = N1[i] + sub_sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\n\nint pfind(int p){\n  int l = 0, r = m;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n    for(int i=0;i<n;i++){\n      int p = pfind(i);\n      hasa[p]++;\n    }\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag())\n        + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS+i, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      if(i <= p && p <= m){\n        int cnt = n - (sumA[p] - sumA[i-1]);\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 30010\n#define eps 1e-10\nstruct Nodes{\n\tdouble l,r;\n}line[maxn];\nstruct Point{\n\tdouble x,y;\n}p[maxn];\nint n,m,w,h;\nint S;\nint sum[maxn],pos[maxn];\ndouble area[maxn];\ndouble cross(Point a,Point b,Point c)\n{\n\tdouble dx1=b.x-a.x,dx2=c.x-a.x,dy1=b.y-a.y,dy2=c.y-a.y;\n\treturn dx1*dy2-dy1*dx2;\n}\nint check(int id,int now)\n{\n\tPoint a,b,c;\n\ta.x=0;a.y=line[id].l;\n\tb.x=w;b.y=line[id].r;\n\tc=p[now];\n\tif(cross(a,c,b)>0)return 1;\n\treturn 0;\n}\ndouble Area(int id1,int id2)\n{\n\treturn (line[id2].l-line[id1].l+line[id2].r-line[id1].r)*w/2.0;\n}\nint min(int x,int y)\n{\n\treturn x<y?x:y;\n}\nint main()\n{\n\tint i,j,k;\n\tint L,R,mid;\n\tint ans;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&S),n||m||w||h||S){\n\t\tfor(i=1;i<=m;i++){\n\t\t\tscanf(\"%lf%lf\",&line[i].l,&line[i].r);\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tmemset(sum,0,sizeof(sum));\n\t\tsum[0]=0;\n\t\tline[0].l=line[0].r=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tL=0;R=m;\n\t\t\twhile(L<=R){\n\t\t\t\tmid=(L+R)/2;\n\t\t\t\tif(check(mid,i)){\n\t\t\t\t\tpos[i]=mid;\n\t\t\t\t\tR=mid-1;\n\t\t\t\t}else L=mid+1;\n\t\t\t}\n\t\t\tsum[pos[i]]++;\n\t\t}\n\t\tarea[0]=0;\n\t\tfor(i=1;i<=m;i++){\n\t\t\tsum[i]+=sum[i-1];\n\t\t\tarea[i]=area[i-1]+Area(i-1,i);\n\t\t}\n\t\tif(S==0){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(S==w*h){\n\t\t    printf(\"%d\\n\",n);\n\t\t    continue;\n\t\t}\n\t\tS=w*h-S;\n\t\tans=n;\n\t\tfor(i=1;i<=m;i++){\n\t\t\t//if(area[i]>S-eps){\n\t\t\t\t\n\t\t\t\tk=lower_bound(area,area+m+1,area[i]-S-eps)-area;\n\t\t\t\t//printf(\"%d %lf %d %d %d\\n\",i,area[i],k,sum[k-1],sum[i]);\n\t\t\t\tans=min(ans,n-sum[i]+sum[k]);\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n}\n \ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n \nint main() {\n  int n,m,w,h,s;\n  while(cin >> n >> m >> w >> h >> s && n) {\n    P a[m];\n    int d[m+1];\n    double d2[m+1];\n    d2[0]=0;\n    memset(d,0,sizeof(d));\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n      vector<P> v(4);\n      v[0]=P(0,0);\n      v[1]=P(w,0);\n      v[2]=P(w,a[i].imag());\n      v[3]=P(0,a[i].real());\n      d2[i+1]=area(v);\n    }\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      P p=P(x,y);\n      int l=0,r=m;\n      while(l+1!=r) {\n        int k=(l+r)/2;\n        vector<P> v(4);\n        v[0]=P(0,0);\n        v[1]=P(w,0);\n        v[2]=P(w,a[k].imag());\n        v[3]=P(0,a[k].real());\n        if(convex_contains(v,p)<2) l=k;\n        else r=k;\n      }\n      d[l+1]++;\n    }\n    for(int i=0; i<m; i++) d[i+1]+=d[i];\n    //for(int i=0; i<=m; i++) cout << i << \" \" << d[i] << \" \" << d2[i] << endl;\n    int l=0,ans=n;\n    for(int r=0; r<=m; r++) {\n      while(l<r&&d2[m]-d2[r]+d2[l]<s) l++;\n      int x=l?d[l-1]:0;\n      int y=r?d[r-1]:0;\n      //cout << r << \" \" << l << \" \" << d2[m]-d2[r]+d2[l] << endl;//\" \" << d[m]-d[r]+d[l] << endl;\n      if(d2[m]-d2[r]+d2[l]>=s) ans=min(ans,d[m-1]-y+x);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint bs(double x, double y, int l[], int r[], int w, int m) {\n\n    int lower = 0;\n    int upper = m + 1;\n\n    while( true ) {\n        int t = (lower + upper) / 2;\n\n        if ( y < x * (r[t] - l[t]) / (w + 0.0) + l[t] ) {\n            if ( y > x * (r[t-1] - l[t-1]) / (w + 0.0) + l[t-1] ) {\n                return t - 1;\n            } else {\n                upper = t;     \n            }\n        } else {\n            lower = t;\n        }\n    }\n}\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        int l[m+1];\n        int r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        int fromd_area[m+1];\n        int fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        for(int i = 0; i < n; i++) {\n            nuts[bs(x[i], y[i], l, r, w, m)] += 1;\n        }\n\n        int fromd_nuts[m+1];\n        int fromu_nuts[m+1];\n        fromd_nuts[0] = 0;\n        fromu_nuts[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_nuts[i] = fromd_nuts[i-1] + nuts[i-1];\n            fromu_nuts[i] = fromu_nuts[i-1] + nuts[m-i];\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            if (nuts[i] == 0) continue;\n\n            int j = lower_bound(fromu_area, fromu_area + m, S - fromd_area[i]) - fromu_area;\n            if (minnuts > fromd_nuts[i] + fromu_nuts[j]) {\n                minnuts = fromd_nuts[i] + fromu_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n      assert(inPolygon(poly[M],ps[i]));\n      almond[M]++;\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint main() {\n  int n,m,w,h,s;\n  while(cin >> n >> m >> w >> h >> s && n) {\n    P a[m];\n    int d[m+1];\n    double d2[m+1];\n    d2[0]=0;\n    memset(d,0,sizeof(d));\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n      vector<P> v(4);\n      v[0]=P(0,0);\n      v[1]=P(w,0);\n      v[2]=P(w,a[i].imag());\n      v[3]=P(0,a[i].real());\n      d2[i+1]=area(v);\n    }\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      P p=P(x,y);\n      int l=0,r=m;\n      while(l+1!=r) {\n        int k=(l+r)/2;\n        vector<P> v(4);\n        v[0]=P(0,0);\n        v[1]=P(w,0);\n        v[2]=P(w,a[k].imag());\n        v[3]=P(0,a[k].real());\n        if(convex_contains(v,p)<2) l=k;\n        else r=k;\n      }\n      d[l+1]++;\n    }\n    for(int i=0; i<m; i++) d[i+1]+=d[i];\n    int l=0,ans=1<<29;\n    for(int r=0; r<=m; r++) {\n      while(l<r&&d2[m]-d2[r]+d2[l]<s) l++;\n      int x=l?d[l-1]:0;\n      int y=r?d[r-1]:0;\n      if(d2[m]-d2[r]+d2[l]>=s) ans=min(ans,d[m]-y+x);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define MAX 30010\n#define EPS 0.0000000001\nusing namespace std;\ntypedef pair<double,double> P;\n\tdouble ar[MAX],erea[MAX],w,h,S;\n\tvector<double> l(MAX),r(MAX);\n\tvector<P> iti(MAX);\nint main(){\n\tint n,m ;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\titi[i] = P(y,x);\n\t\t}\n\t\tsort(iti.begin(),iti.begin() + m);\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint j1 = lower_bound(l.begin(), l.begin() + m, iti[i].first) - l.begin();\n\t\t\tint j2 = lower_bound(r.begin(), r.begin() + m, iti[i].first) - r.begin();\n\t\t\tint minj = min(j1, j2);\n\t\t\tfor(int j=minj;j<=m;j++){\n\t\t\t\n\t\t\t\tif(iti[i].first<(r[j]-l[j])*(iti[i].second)/w+l[j]) {\n\t\t\t\t\tar[j-1]++;\n\t\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S && upper >= 0) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tif(upper >= 0)\n\t\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 0.0000000001;\nconst double LEPS = 0.00000001;\n\nstruct Point2D {\n\tdouble x, y;\n\tPoint2D(double _x = 0.0, double _y = 0.0) : x(_x), y(_y) { }\n\tbool operator==(const Point2D &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point2D &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point2D &p) const {\n\t\tif(x < p.x){ return true; }\n\t\tif(x > p.x){ return false; }\n\t\treturn y < p.y;\n\t}\n};\n\nPoint2D operator+(const Point2D &a, const Point2D &b){ return Point2D(a.x + b.x, a.y + b.y); }\nPoint2D operator-(const Point2D &a, const Point2D &b){ return Point2D(a.x - b.x, a.y - b.y); }\n\ndouble cross2d(const Point2D &a, const Point2D &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble convexArea(const vector<Point2D> &convex){\n\tdouble sum = 0.0;\n\tfor(int i = 1; i < convex.size(); ++i){ sum += cross2d(convex[i - 1], convex[i]); }\n\tsum += cross2d(convex.back(), convex[0]);\n\treturn sum / 2;\n}\n\nbool testConvexAndPoint(const vector<Point2D> &convex, const Point2D &p){\n\tvector<Point2D> triangle(3);\n\tfor(int i = 1; i < convex.size(); ++i){\n\t\ttriangle[0] = convex[i - 1];\n\t\ttriangle[1] = convex[i];\n\t\ttriangle[2] = p;\n\t\tif(convexArea(triangle) < 0.0){ return false; }\n\t}\n\ttriangle[0] = convex.back();\n\ttriangle[1] = convex[0];\n\ttriangle[2] = p;\n\tif(convexArea(triangle) < 0.0){ return false; }\n    return true;\n}\n\nstruct YComparator {\n\tbool operator()(const Point2D &a, const Point2D &b){\n\t\tif(a.y < b.y){ return true; }\n\t\tif(a.y > b.y){ return false; }\n\t\treturn a.x < b.x;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, w, h, S;\n\t\tcin >> n >> m >> w >> h >> S;\n\t\tif(n == 0 && m == 0 && w == 0 && h == 0 && S == 0){ break; }\n\t\tvector<double> left, right;\n\t\tleft.push_back(0.0);\n\t\tright.push_back(0.0);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tdouble l, r;\n\t\t\tcin >> l >> r;\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\tsort(left.begin(), left.end());\n\t\tsort(right.begin(), right.end());\n\t\tvector<Point2D> peanuts;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tPoint2D p;\n\t\t\tcin >> p.x >> p.y;\n\t\t\tpeanuts.push_back(p);\n\t\t}\n\t\tsort(peanuts.begin(), peanuts.end(), YComparator());\n\t\tvector<double> pieceSize;\n\t\tvector<int> peanutsOnPiece;\n\t\tvector<bool> checked(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tvector<Point2D> convex(4);\n\t\t\tconvex[0] = Point2D(0.0, left[i]);\n\t\t\tconvex[1] = Point2D(w, right[i]);\n\t\t\tconvex[2] = Point2D(w, right[i + 1]);\n\t\t\tconvex[3] = Point2D(0.0, left[i + 1]);\n\t\t\tint peanutsNum = 0;\n\t\t\tfor(\n\t\t\t\tint j = distance(\n\t\t\t\t\tpeanuts.begin(), lower_bound(\n\t\t\t\t\t\tpeanuts.begin(), peanuts.end(),\n\t\t\t\t\t\tPoint2D(0.0, min(left[i], right[i])), YComparator()\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tj < n; ++j\n\t\t\t){\n\t\t\t\tif(peanuts[j].y > max(left[i + 1], right[i + 1])){ break; }\n\t\t\t\tif(checked[j]){ continue; }\n\t\t\t\tif(testConvexAndPoint(convex, peanuts[j])){\n\t\t\t\t\tchecked[j] = true;\n\t\t\t\t\t++peanutsNum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpieceSize.push_back(convexArea(convex));\n\t\t\tpeanutsOnPiece.push_back(peanutsNum);\n\t\t}\n\t\tvector<double> integralPieceSize;\n\t\tvector<int> integralPeanutsOnPiece;\n\t\tfor(int i = 0; i < m; ++i){\n//\t\t\tcerr << i << \" > \" << pieceSize[i] << \", \" << peanutsOnPiece[i] << endl;\n\t\t\tif(i == 0){\n\t\t\t\tintegralPieceSize.push_back(pieceSize[0]);\n\t\t\t\tintegralPeanutsOnPiece.push_back(peanutsOnPiece[0]);\n\t\t\t}else{\n\t\t\t\tintegralPieceSize.push_back(pieceSize[i] + integralPieceSize[i - 1]);\n\t\t\t\tintegralPeanutsOnPiece.push_back(peanutsOnPiece[i] + integralPeanutsOnPiece[i - 1]);\n\t\t\t}\n\t\t}\n\t\tdouble totalSize = w * h;\n\t\tint answer = n;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tdouble thr = totalSize - (S - EPS) + integralPieceSize[i] - pieceSize[i];\n//\t\t\tcerr << thr << endl;\n\t\t\tvector<double>::iterator it = upper_bound(\n\t\t\t\tintegralPieceSize.begin(), integralPieceSize.end(), thr\n\t\t\t);\n\t\t\tif(it == integralPieceSize.begin()){ cerr << endl; break; }\n\t\t\tint j = distance(integralPieceSize.begin(), it) - 1;\n\t\t\tif(j < i){ continue; }\n\t\t\tanswer = min(answer, n - (integralPeanutsOnPiece[j] - integralPeanutsOnPiece[i] + peanutsOnPiece[i]));\n/*\t\t\tfor(int j = i; j < m; ++j){\n\t\t\t\tif(totalSize - (integralPieceSize[j] - integralPieceSize[i]) < S - LEPS){ continue; }\n\t\t\t\tanswer = min(answer, n - (integralPeanutsOnPiece[j] - integralPeanutsOnPiece[i]));\n\t\t\t}*/\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nstruct Choco{\n\tint nut;\n\tdouble S;\n};\n\nint n,m,w,h,thre;\nChoco ch[30000];\n\nint solve(){\n\tint nut=0,ans=INF;\n\tdouble S=0;\n\tfor(int i=0,j=0;i<m;i++){\n\t\tfor(;j<i;j++){\n\t\t\tS+=ch[j].S;\n\t\t\tnut+=ch[j].nut;\n\t\t}\n\n\t\tfor(;j<m;j++){\n\t\t\tif(w*h-thre+EPS<S) break;\n\t\t\tans=min(ans,n-nut);\n\t\t\tS+=ch[j].S;\n\t\t\tnut+=ch[j].nut;\n\t\t}\n\t\tif(w*h-thre+EPS>S) ans=min(ans,n-nut);\n\n\t\tS-=ch[i].S;\n\t\tnut-=ch[i].nut;\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&thre),n;){\n\t\tstatic int l[30001],r[30001];\n\t\tl[0]=r[0]=0;\n\t\trep(i,m) scanf(\"%d%d\",l+i+1,r+i+1);\n\n\t\trep(i,m){\n\t\t\tch[i].S=((l[i+1]-l[i])+(r[i+1]-r[i]))/2.0*w;\n\t\t\tch[i].nut=0;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble cx,cy; scanf(\"%lf%lf\",&cx,&cy);\n\n\t\t\tint lo=0,hi=m+1;\n\t\t\twhile(lo<hi){\n\t\t\t\tint mi=(lo+hi+1)/2;\n\t\t\t\tif((w-cx)*l[mi]+cx*r[mi]<w*cy) lo=mi; else hi=mi-1;\n\t\t\t}\n\t\t\tch[lo].nut++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 30010\n#define eps 1e-10\nstruct Nodes{\n\tdouble l,r;\n}line[maxn];\nstruct Point{\n\tdouble x,y;\n}p[maxn];\nint n,m,w,h;\nint S;\nint sum[maxn],pos[maxn];\ndouble area[maxn];\ndouble cross(Point a,Point b,Point c)\n{\n\tdouble dx1=b.x-a.x,dx2=c.x-a.x,dy1=b.y-a.y,dy2=c.y-a.y;\n\treturn dx1*dy2-dy1*dx2;\n}\nint check(int id,int now)\n{\n\tPoint a,b,c;\n\ta.x=0;a.y=line[id].l;\n\tb.x=w;b.y=line[id].r;\n\tc=p[now];\n\tif(cross(a,c,b)>0)return 1;\n\treturn 0;\n}\ndouble Area(int id1,int id2)\n{\n\treturn (line[id2].l-line[id1].l+line[id2].r-line[id1].r)*w/2.0;\n}\nint min(int x,int y)\n{\n\treturn x<y?x:y;\n}\nint main()\n{\n\tint i,j,k;\n\tint L,R,mid;\n\tint ans;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&S),n||m||w||h||S){\n\t\tfor(i=1;i<=m;i++){\n\t\t\tscanf(\"%lf%lf\",&line[i].l,&line[i].r);\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tmemset(sum,0,sizeof(sum));\n\t\tsum[0]=0;\n\t\tline[0].l=line[0].r=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tL=0;R=m;\n\t\t\twhile(L<=R){\n\t\t\t\tmid=(L+R)/2;\n\t\t\t\tif(check(mid,i)){\n\t\t\t\t\tpos[i]=mid;\n\t\t\t\t\tR=mid-1;\n\t\t\t\t}else L=mid+1;\n\t\t\t}\n\t\t\tsum[pos[i]]++;\n\t\t}\n\t\tarea[0]=0;\n\t\tfor(i=1;i<=m;i++){\n\t\t\tsum[i]+=sum[i-1];\n\t\t\tarea[i]=area[i-1]+Area(i-1,i);\n\t\t}\n\t\tif(S==0){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(S==w*h){\n\t\t    printf(\"%d\\n\",n);\n\t\t    continue;\n\t\t}\n\t\tS=w*h-S;\n\t\tans=n;\n\t\tfor(i=1;i<=m;i++){\n\t\t\t//if(area[i]>S-eps){\n\t\t\t\t\n\t\t\t\tk=lower_bound(area,area+m+1,area[i]-S-eps)-area;\n\t\t\t\t//printf(\"%d %lf %d %d %d\\n\",i,area[i],k,sum[k-1],sum[i]);\n\t\t\t\tans=min(ans,n-sum[i]+sum[k]);\n\t\t\t//}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t} else if(inPolygon(poly[L],ps[i])){\n\t  M = L;\n\t  break;\n\t} else if( R < m && inPolygon(poly[R],ps[i])){\n\t  M = R;\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\t\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\n\nint pfind(int p){\n  int l = 0, r = m;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n    for(int i=0;i<n;i++){\n      int p = pfind(i);\n      hasa[p]++;\n    }\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag())\n        + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      if(i <= p && p <= m){\n        int cnt = max(0, n - (sumA[p] - sumA[i-1]));\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n      else if(L-1>=0 && inPolygon(poly[L-1],ps[i]))almond[L-1]++;\n      else if(R+1<m && inPolygon(poly[R+1],ps[i]))almond[R+1]++;\n      else if(L-2>=0 && inPolygon(poly[L-2],ps[i]))almond[L-2]++;\n      else if(R+2<m && inPolygon(poly[R+2],ps[i]))almond[R+2]++;\n      else if(L-3>=0 && inPolygon(poly[L-3],ps[i]))almond[L-3]++;\n      else if(R+3<m && inPolygon(poly[R+3],ps[i]))almond[R+3]++;\n      else if(L-4>=0 && inPolygon(poly[L-4],ps[i]))almond[L-4]++;\n      else if(R+4<m && inPolygon(poly[R+4],ps[i]))almond[R+4]++;\n      else assert(false);\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nint n,m,w,h,S;\n// A[hªüªæèºÉ é©Ç¤©\nbool check(pair<int,int> p,double x,double y){\n    // X«\n    double d=(double)(p.first-p.second)/(0-w);\n    double yv=d*(x-0)+p.first;\n    return (yv>y);\n}\n\nint main(){\n    while(cin>>n>>m>>w>>h>>S&&!(n==0&&m==0&&w==0&&h==0&&S==0)){\n        int l,r;\n        vector<pair<int,int> > ps;\n        int armond[30001];\n        memset(armond,0,sizeof(armond));\n        ps.push_back(make_pair(0,0));\n        for(int i = 0; i < m; i++){\n            cin>>l>>r;\n            ps.push_back(make_pair(l,r));\n        }\n        // A[hªÇÌfÐãÉ é©ÍL¯µÄ¨­\n        for(int i = 0; i < n; i++){\n            double x,y;\n            cin>>x>>y;\n            // A[hª»ÌüæèºÉ éºÀðTõ\n            int ub=m;int lb=-1;\n            while(ub-lb>1){\n                bool b;\n                int med=(ub+lb)/2;\n                if(check(ps[med],x,y))\n                    ub=med;\n                else\n                    lb=med;\n            }\n            // ubÌlªºÀÌüª\n            armond[ub]++;\n        }\n        // µá­Æè@Å`R[gãðTõ\n        int head=0;int tail=0;\n        double peco=w*h;\n        int arNum=n;\n        const int INF=100000000;\n        int minArNum=INF;\n        // tailªÍÍ©çoéÜÅTõ\n        while(tail<=m&&head<=tail){\n            // ¶å¤¯ñð½µÄ¢éÈçXV\n            if(EQ(peco,S)||peco>S)\n                minArNum=min(minArNum,arNum);\n            // àµ»ÝÌ×[±Ì`R[gÌÊÏªSÈºÈçAheadðâ·\n            // »¤ÅÈ¢ÈçAtailðâ·\n            if(EQ(peco,S)||peco>S){\n                // tailðâ·\n                tail++;\n                if(!(tail<=m&&head<=tail))\n                    break;\n                // ÊÏðXV\n                double ss=((double)abs(ps[tail-1].first-ps[tail].first)+abs(ps[tail-1].second-ps[tail].second))*w/2.0;\n                peco-=ss;\n                arNum-=armond[tail];\n            }\n            else{\n                head++;\n                if(!(tail<=m&&head<=tail))\n                    break;\n                // ÊÏðXV\n                double ss=((double)abs(ps[head-1].first-ps[head].first)+abs(ps[head-1].second-ps[head].second))*w/2.0;\n                peco+=ss;\n                arNum+=armond[head];\n            }\n        }\n        cout<<minArNum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int INFI = 1 << 30;\nconst int V = 20;\n\nint n;\nint use[V], ans[V];\nstruct MAT\n{\n\tint lx,ly,rx,ry,id;\n\tvoid rd()\n\t{\n\t\tscanf(\"%d%d%d%d\",&lx,&ly,&rx,&ry);\n\t}\n\tbool operator <(const MAT &a)const\n\t{\n\t\treturn lx < a.lx || (lx == a.lx && ly < a.ly); \n\t}\n}mat[V];\n\nint main()\n{\n\tbool first = true;\n\twhile (1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif (n == 0) break;\n\t\t\n\t\tfor (int i=0;i<n;i++)\n\t\t{\n\t\t\tmat[i].rd();\n\t\t\tmat[i].id = i;\n\t\t}\n\t\tsort(mat,mat+n);\n\t\tmemset(use,0,sizeof(use));\n\t\tint now = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (c != -1)\n\t\t\t{\n\t\t\tint topx = -INFI, topy = INFI, c = -1;\n\t\t\tfor (int j=0;j<n;j++)\n\t\t\tif (!use[j] && (mat[j].lx > topx || (mat[j].lx == topx && mat[j].ly < topy)) )\n\t\t\t{\n\t\t\t\ttopx = mat[j].lx;\n\t\t\t\ttopy = mat[j].ly;\n\t\t\t\tc = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"c is %d %d\\n\",mat[c].id,mat[c].ry);\n\t\t\tif (c != -1) \n\t\t\t\tuse[c] = ++now;\n\t\t\telse\tbreak;\n\t\t\t\n\t\t\tint bx = mat[c].rx;\n\t\t\tint by = mat[c].ry;\n\t\t\tbool find;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tfind = false;\n\t\t\t\tfor (int k=0;k<n;k++)\n\t\t\t\tif (mat[k].lx == bx && mat[k].ry == by)\n\t\t\t\t{\n\t\t\t\t\tfind = true;\n\t\t\t\t\tbx = mat[k].rx;\n\t\t\t\t}\t\t\n\t\t\t}while (find);\n\t\t\t\n\t\t\tint get = -1;\n\t\t\tfor (int k=0;k<n;k++)\n\t\t\tif (!use[k] && mat[k].lx <= bx && mat[k].ly >= mat[c].ry)\n\t\t\t{\n\t\t\t\t//printf(\"color %d\\n\",mat[k].id);\n\t\t\t\tuse[k] = ++now;\n\t\t\t\tget = k;\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//if (get != -1) c = \n\t\t}\n\t\tif (!first) printf(\"\\n\"); \n\t\tfirst = false;\n\t\t\n\t\tfor (int i=0;i<n;i++) ans[ mat[i].id ] = use[i];\n\t\tfor (int i=0;i<n;i++)\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define MAX 30010\n#define EPS 0.0000000001\nusing namespace std;\ntypedef pair<double,double> P;\n\tdouble ar[MAX],erea[MAX],w,h,S;\n\tvector<double> l(MAX),r(MAX);\n\tvector<P> iti(MAX);\nint main(){\n\tint n,m ;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\titi[i] = P(y,x);\n\t\t}\n\t\tsort(iti.begin(),iti.begin() + m);\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint j1 = lower_bound(l.begin(), l.begin() + m, iti[i].first) - l.begin();\n\t\t\tint j2 = lower_bound(r.begin(), r.begin() + m, iti[i].first) - r.begin();\n\t\t\tint minj = min(j1, j2);\n\t\t\tfor(int j=minj;j<=m;j++){\n\t\t\t\n\t\t\t\tif(iti[i].first<(r[j]-l[j])*(iti[i].second)/w+l[j]) {\n\t\t\t\t\tar[j-1]++;\n\t\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S && upper >= 0) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while( cur < m && !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(  !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF 101010\n\nstruct Point {\n    double x, y;\n    \n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Point a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS)  return -1; // COUNTER CLOCK WISE\n    return +0;\n}\n\n#define next(G,i) (G[(i+1)%G.size()])\n\ndouble get_area(double l, double r, int W)\n{\n    vector<Point> pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(W, 0);\n    pg[2] = Point(W, r);\n    pg[3] = Point(0, l);\n    \n    double res = 0;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tres += cross(pg[i], next(pg, i));\n    }\n    return abs(res)/2.0;\n}\n\n\nint main()\n{\n    int N, M, W, H, S;\n    while (cin >> N >> M >> W >> H >> S, N) {\n        vector<double> l(M+1), r(M+1);\n        l[0] = r[0] = 0;\n        \n        vector<int> s(M+1, 0);\n        for (int i = 1; i <= M; i++) {\n            scanf(\"%lf %lf\", &l[i], &r[i]);\n            s[i] = get_area(l[i], r[i], W);\n        }        \n\n        vector<int> choco(M+1, 0);\n        \n        Point p;\n        for (int i = 0; i < N; i++) {\n            scanf(\"%lf %lf\", &p.x, &p.y);\n            int lb = 0, ub = M+1;\n            while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ccw(Point(0, l[mid]), Point(W, r[mid]), p) == -1) {\n                    lb = mid;\n                } else {\n                    ub = mid;\n                }\n            }\n            choco[ub]++;\n        }\n\n        for (int i = 1; i <= M; i++) {\n            choco[i] += choco[i-1];\n        }\n        int res = INF;\n        for (int i = 0; i <= M; i++) {\n            int lb = i, ub = M+1;\n            int ns = s[i];\n            while (ub - lb > 1) {\n                int mid = (lb + ub) / 2;\n                if (ns + (s[M] - s[mid]) < S) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n\n            if (ns + (s[M] - s[lb]) >= S) {\n                res = min(res, choco[M] - (choco[lb] - choco[i]));\n            }\n        }\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos < i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  mybestwishes\n * Created Time:  2011/8/22 15:54:32\n * File Name: F.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <set>\n#include <time.h>\nusing namespace std;\n#define Abs(x) (((x) > 0)?(x):(-(x)))\ntypedef long long lint;\n#define N 30010\nconst double eps = 1e-8 ;\n\nint n , m , w , h , s ; \nstruct Point{\n    double x , y ;\n    Point(double _x = 0 , double _y = 0 ): x(_x) , y(_y) {}\n    double dis() const {\n        return sqrt(x * x + y * y) ;\n    }\n};\n\nstruct Area{\n    int l1 , r1 , l2 , r2 ; \n    int squ ;\n    int cnt ; \n};\n\nPoint p[N] ;\nArea A[N] ;\nint Cn[N] ;\n\nbool cmp(Point p1 , Point p2){\n    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y) ? true : false ;\n}\n\nint sgn2(double ans){\n    if(ans > eps) return 1 ;\n    if(ans < -eps) return -1 ;\n    return 0 ;\n}\n\nbool jud(Area kk , Point pp){\n    double tmp1 = (double)((kk.r1-kk.l1)*pp.x) / (double)(w) + (double)(kk.l1) ;\n    tmp1 -= pp.y ;\n    if(sgn2(tmp1) != -1) return false ;\n    \n    double tmp2 = (double)((kk.r2-kk.l2)*pp.x) / (double)(w) + (double)(kk.l2) ;\n    tmp2 -= pp.y ;\n    if(sgn2(tmp2) == -1) return false ;\n    \n    return true ;\n}\n\nint main() {\n    while(scanf(\"%d%d%d%d%d\" , &n , &m , &w , &h , &s) != EOF){\n        if(n == 0 && m == 0 && w == 0 && h == 0 && s == 0) break ;\n        int l = 0 , r = 0 ; \n        int i = 0 ;\n        lint total = 0 ; \n        for( ; i < m ; i++){\n            int a , b ; \n            scanf(\"%d%d\" , &a , &b);\n            A[i].l1 = l ; A[i].r1 = r ; \n            A[i].l2 = a ; A[i].r2 = b ;\n            A[i].squ = (a-l+b-r)*w ;    // squ * 2 ;\n            total += (lint)(A[i].squ) ;\n            A[i].cnt = 0 ;\n            l = a ; r = b ; \n        }\n        A[i].l1 = l ; A[i].r1 = w ; \n        A[i].l2 = h ; A[i].r2 = h ;\n        A[i].squ = (h-l+h-w)*w ; \n        total += (lint)(A[i].squ) ;\n        A[i].cnt = 0 ; \n        i++ ;\n        //cout<<i<<endl;\n        \n        sort(p , p+n , cmp) ;\n        for(int j = 0 ; j < n ; j++){\n            scanf(\"%lf%lf\" , &p[j].x , &p[j].y);\n            //cout<<p[j].x<<\" \"<<p[j].y<<endl;\n            /*\n            int k = 0 ; \n            while(k < i){\n                if(jud(A[k] , p[j])){\n                    A[k].cnt++ ;\n                    break ;\n                }\n                k++ ;\n            }\n            */\n        }\n        sort(p , p+n , cmp) ;\n        int k = 0 , j = 0 ; \n        while(j < n && k < i){\n            if(jud(A[k] , p[j])){\n                A[k].cnt++ ;\n                j++ ;\n            }\n            else k++ ;\n        }\n        int maxn = 0 ;\n        \n        int cal = 0 ; \n        lint tmp = 0 ;\n        lint left = total-2*lint(s) ;\n        j = 0 , k = 0 ; \n        \n        while(k <= j && j < i && k < i){\n            tmp = tmp + (lint)(A[j].squ) ;\n            cal += A[j].cnt ;\n            if(tmp <= left){\n                if(cal > maxn)\n                    maxn = cal ;\n                j++ ;\n            }\n            else{\n                while(tmp > left){\n                    tmp -= (lint)(A[k].squ) ;\n                    cal -= A[k].cnt ;\n                    k++ ;\n                }\n                if(cal > maxn)\n                    maxn = cal ;\n                j++ ;\n            }\n        }\n        cout<<n - maxn<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 80000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    if(false){\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      //if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      //if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n/*\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n*/\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n\tassert( j != m-1 );\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-7;\n\nbool equals(double a, double b) { return abs(a-b) < eps; }\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(a.real() != b.real()) return a.real() < b.real();\n    return a.imag() < b.imag();\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\ndouble dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nvector<L> ls;\nvector<P> ps;\nint A[30010];\ndouble Area[30010];\n\nint f(P p) {\n  int l = 0;\n  int r = ls.size();\n  int ans = -1;\n  while(l < r) {\n    int m = (l+r)/2;\n    if(ccw(ls[m][0],ls[m][1],p) == 1) {\n      ans = m;\n      l = m+1;\n    } else {\n      r = m;\n    }\n  }\n  return ans;\n}\n\ndouble getArea(int a, int b) {\n  if(a <= 0) return Area[b];\n  return Area[b] - Area[a-1];\n}\n\nint getArm(int a, int b) {\n  if(a <= 0) return A[b];\n  return A[b] - A[a-1];\n}\n\nint main() {\n  int n,m,w,h,S;\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S))  {\n    ls.clear();\n    ps.clear();\n\n    for(int i = 0; i < m; ++i) {\n      P a,b;\n      cin >> a.imag() >> b.imag();\n      a.real() = 0;\n      b.real() = w;\n      ls.push_back(L(a,b));\n    }\n    ls.push_back(L(P(0,0),P(w,0)));\n\n    sort(ls.begin(), ls.end());\n    for(int i = 0; i < n; ++i) {\n      P p;\n      cin >> p.real() >> p.imag();\n      ps.push_back(p);\n    }\n\n\n    fill(A,A+30010,0);\n    for(int i = 0; i < ps.size(); ++i) {\n      ++A[f(ps[i])];\n    }\n\n    for(int i = 1; i < m; ++i) A[i] += A[i-1];\n\n//     for(int i = 0; i < m; ++i) {\n//       if(i) cout << \" \";\n//       cout << A[i];\n//     }\n//     cout << endl;\n\n    // calc Area\n    for(int i = 0; i+1 < ls.size(); ++i) {\n      if(i) Area[i] = Area[i-1];\n      else Area[i] = 0;\n      Area[i] += ( (ls[i+1][0].imag()-ls[i][0].imag())\n                + (ls[i+1][1].imag()-ls[i][1].imag()) ) * w / 2.0;\n    }\n\n    int head = 0;\n    int tail = 0;\n    int mx = 0;\n    double T = h*w-S;\n\n    while (tail < m) {\n      while (getArea(tail, head + 1) <= T && head + 1 < m) ++head;\n      if (getArea(tail, head) <= T) {\n        // cout << tail << \", \" << head << \" : \" << getArm(tail, head) << endl;\n        mx = max(mx, getArm(tail, head));\n      }\n      ++tail;\n      if (head <= tail) {\n        // cout << \"head <= tail  \" << tail << \", \" << head << endl;\n        head = tail;        \n      }\n    }\n    cout << n - mx << endl;\n\n//     int ans = 0;\n//     double T = h*w-S;\n//     for(int l = 0, r = 0, sum = 0; l < m && r < m; ) {\n//       // cout << l << \", \" << r << \", \" << sum << endl;\n//       cout << \"T = \" << T << endl;\n//       while(r < m && getArea(l,r) < T) ++r;\n//       cout << getArea(l,r) << endl;\n//       --r;\n//       cout << \"inc : \" << l << ' ' << r << endl;\n//       if( l <= r ){\n//         cout << \"inc get : \" << getArm(l,r) << endl;\n//         ans = max(ans,getArm(l,r));\n//       }\n//       ++r;\n// //      if(r == m) break;\n      \n//       while((equals(getArea(l,r),T) || getArea(l,r) > T)) {\n//         ++l;\n//       }\n      \n      \n//       // if(l > r) r = l;\n//       //if(l < m && getArea(l,r) < T)\n//       /*\n//       cout << \"dec : \" << l << ' ' << r << endl;\n//       if( l <= r ){\n//         cout << \"dec get : \" << getArm(l,r) << endl;\n//         ans = max(ans,getArm(l,r));\n//       }\n//       */\n    // }\n    // cout << n-ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tbool found = false;\n\trep(k,1000){\n\t  if(L-k >= 0 && inPolygon(poly[L-k],ps[i])){\n\t    almond[L-k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t  if(R+k < m && inPolygon(poly[R+k],ps[i])){\n\t    almond[R+k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t}\n\t\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <string.h>\n#define maxn 60068\n#define maxm 60074\n#define inf 2147483647\n\nconst double EPS=1e-8;\nstruct point \n{\n\tdouble x,y;\n};\nstruct segment\n{\n\tpoint a,b;\n};\nsegment seg[maxm];\npoint pt[maxn];\n\n/*テゥツ催ィツスツス - ティツソツ静ァツョツ療ァツャツヲ*/\npoint operator-(point a,point b)\n{\n\tpoint p;\n\tp.x=a.x-b.x; p.y=a.y-b.y;\n\treturn p;\n}\n/*テァツャツヲテ・ツ渉キテ・ツステヲツ閉ー*/\nint dbcmp(double d){\n\tif (fabs(d)<EPS)return 0;\n\treturn (d>0)?1:-1;\n}\n/*テ・ツ渉嘉ァツァツッ*/\ndouble cross(point a,point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble s[maxm];\nint a[maxm];\n\nint main()\n{\n\tint n,m;\n\tdouble w,h,S,l,r;\n\n\twhile (1)\n\t{\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(a,0,sizeof(a));\n\t\tscanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&S);\n\t\tif (!n) break;\n\n\t\tseg[0].a.x=0; seg[0].a.y=0;\n\t\tseg[0].b.x=w; seg[0].b.y=0;\n\t\tfor (int i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&l,&r);\n\t\t\tseg[i+1].a.x=0; seg[i+1].a.y=l;\n\t\t\tseg[i+1].b.x=w; seg[i+1].b.y=r;\n\t\t}\n\t\tseg[m+1].a.x=0; seg[m+1].a.y=h;\n\t\tseg[m+1].b.x=w; seg[m+1].b.y=h;\n\t\tfor (int i=0;i<n;i++)\n\t\t\tscanf(\"%lf%lf\",&pt[i].x,&pt[i].y);\n\t\tpt[n].x=inf; pt[n].y=inf;\n\n\t\tint who=0;\n\t\tfor (int i=0;i<m;i++)\n\t\t{\n\t\t\ts[i]=((seg[i+1].a.y+seg[i+1].b.y)-(seg[i].a.y+seg[i].b.y))*w/2;\n\t\t\twhile (( dbcmp( cross(seg[i].b-seg[i].a,pt[who]-seg[i].a) )^dbcmp( cross(seg[i+1].b-seg[i+1].a,pt[who]-seg[i+1].a) ))==-2)\n\t\t\t\ta[i]++,who++;\n\t\t}\n\t\t/*m+1*/\n\t\tint p1=0,p2=0;\n\t\tdouble area=w*h;\n\t\tint min=2147483647;\n\t\tint almond=n;\n\n\t\twhile (1)\n\t\t{\n\t\t\twhile (area>=S && p2!=m+1)\n\t\t\t{\n\t\t\t\tif (area>=S && almond<min) min=almond;\n\t\t\t\tarea-=s[p2],almond-=a[p2++];\n\t\t\t}\n\n\t\t\twhile (area<S  && p1<p2)\n\t\t\t{\n\t\t\t\tarea+=s[p1],almond+=a[p1++];\n\t\t\t\tif (area>=S && almond<min) min=almond;\n\t\t\t}\n\t\t\tif (p2==m+1 && area>=S) break;\n\t\t}\n\t\tprintf(\"%d\\n\",min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t} else if(inPolygon(poly[L],ps[i])){\n\t  M = L;\n\t  break;\n\t} else if( R < m && inPolygon(poly[R],ps[i])){\n\t  M = R;\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tassert(false);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\n\nint sgn(double d)\n{\n    if (d>eps) return 1;\n\tif (d<-eps) return -1;\n\treturn 0;\n}\n\nstruct point\n{\n    double x,y;\n\tpoint(double _x=0,double _y=0):x(_x),y(_y){}\n\tvoid input()\n\t{\n\t   scanf(\"%lf%lf\",&x,&y);\n\t}\n\tdouble len()\n\t{\n\t   return sqrt(x*x+y*y);\n\t}\n}p[30010];\npoint operator+(const point& p1,const point& p2)\n{\n    return point(p1.x+p2.x,p1.y+p2.y);\n}\npoint operator-(const point& p1,const point& p2)\n{\n    return point(p1.x-p2.x,p1.y-p2.y);\n}\n\ndouble yy1[30010],yy2[30010];\ndouble sum[30010];\nint he[30010];\nint n,m;\ndouble s,w,h;\nint a[30010];\n\nbool check(double yy1,double yy2,point p)\n{\n   double y=yy1+((yy2-yy1)/(double)w)*p.x;\n   return sgn(y-p.y)>=0;\n}\n\nint find_pos(point p)\n{\n   int L=1,R=m;\n   while(L<R)\n   {\n      if (L==R-1) break;\n\t  int mid=(L+R)>>1;\n\t  if (check(yy1[mid],yy2[mid],p)) R=mid;\n\t  else L=mid;\n   }\n   if (check(yy1[L],yy2[L],p)) R=L;\n   return R;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s))\n\t{\n\t   if (n+m+w+h+s==0) break;\n\t   yy1[0]=0;yy2[0]=0;\n\t   for (int i=1;i<=m;i++)\n\t   {\n\t      scanf(\"%lf%lf\",&yy1[i],&yy2[i]);\n\t   }\n\t   for (int i=0;i<n;i++)\n\t\t   p[i].input();\n\t   memset(a,0,sizeof(a));\n\t   for (int i=0;i<n;i++)\n\t   {\n\t\t   a[find_pos(p[i])]++;\n\t   }\n\t   memset(he,0,sizeof(he));\n\t   for (int i=1;i<=m;i++)\n\t\t   he[i]=he[i-1]+a[i];\n\t   for (int i=1;i<=m;i++)\n\t\t   sum[i]=(yy1[i]+yy2[i])*w/2.0;\n\t   double ts=0;\n\t   a[m+1]=0;\n\t   int tmp=0,ans=100000000;\n\t   for (int i=m;i>=1;i--)\n\t   {\n\t\t  tmp+=a[i+1];\n\t      ts=(2*h-yy1[i]-yy2[i])*w/2.0;\n\t\t  int L=1,R=i;\n\t\t  while(L<R)\n\t\t  {\n\t\t     if (L==R-1) break;\n\t\t\t int mid=(L+R)>>1;\n\t\t\t if (sgn(ts+sum[mid]-s)>=0) R=mid;\n\t\t\t else L=mid;\n\t\t  }\n\t\t  if (sgn(ts+sum[L]-s)>=0) R=L;\n\t\t  ans=min(ans,he[R]+tmp);\n\t   }\n\t   printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-8; \ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\n/*\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n}\n*/\nint contains(vector<P> v, P p){ \n  bool in = false; \n  for(int i=0;i<v.size();i++){ \n    P a = v[i] - p; \n    P b = v[(i+1)%v.size()] - p; \n    if(imag(a) > imag(b)) swap(a,b); \n    if((imag(a) <= 0 || fabs(imag(a))<EPS) && EPS < imag(b)) \n      if(cross(a,b) < -EPS) in = !in; \n    if(fabs(cross(a,b))<EPS && dot(a,b) < EPS) return 1;\n  } \n  return in ? 2 : 0; \n} \n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint main() {\n  int n,m,w,h,s;\n  while(cin >> n >> m >> w >> h >> s && n) {\n    P a[m];\n    int d[m+1];\n    double d2[m+1];\n    d2[0]=0;\n    memset(d,0,sizeof(d));\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n      vector<P> v(4);\n      v[0]=P(0,0);\n      v[1]=P(w,0);\n      v[2]=P(w,a[i].imag());\n      v[3]=P(0,a[i].real());\n      d2[i+1]=area(v);\n    }\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      P p=P(x,y);\n      int l=0,r=m;\n      while(l+1!=r) {\n        int k=(l+r)/2;\n        vector<P> v(4);\n        v[0]=P(0,0);\n        v[3]=P(w,0);\n        v[2]=P(w,a[k].imag());\n        v[1]=P(0,a[k].real());\n        if(contains(v,p)<2) l=k;\n        else r=k;\n      }\n      d[l+1]++;\n    }\n    for(int i=0; i<m; i++) d[i+1]+=d[i];\n    //for(int i=0; i<=m; i++) cout << i << \" \" << d[i] << \" \" << d2[i] << endl;\n    int l=0,ans=1<<29;\n    for(int r=0; r<=m; r++) {\n      while(l<r&&d2[m]-d2[r]+d2[l]<s) l++;\n      int x=l?d[l-1]:0;\n      int y=r?d[r-1]:0;\n      if(d2[m]-d2[r]+d2[l]>=s) ans=min(ans,d[m]-y+x);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 30000;\nconst int INF = 100000000;\nconst double EPS = 1e-9;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0, double y = 0.0):x(x),y(y){}\n  Point operator + (Point &p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p) {return Point(x-p.x,y-p.y);}\n  double norm(void){return x*x+y*y;}\n};\n\nint amd[N+1];\nint n, m, h, S;\nint W;\npair<double,double> line[N+2];\ndouble area[N+1];\nPoint amdData[N+1];\n\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a, Point b){\n  return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n  b = b - a;\n  c = c - a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(b.norm() < c.norm()) return -2;\n  return 0;\n}\n\ndouble calcArea(int p){\n  double l = line[p+1].first - line[p].first;\n  double r = line[p+1].second - line[p].second;\n  return (double)W*(l+r)/2.0;\n}\n\nint calcAmd(int p){\n  int res = 0;\n  double w = (double)W;\n  for(int i=0;i<n;i++){\n    if(ccw(Point(0.0,line[p].first),amdData[i],Point(w,line[p].second)) * ccw(Point(0.0,line[p].first),amdData[i],Point(0.0,line[p+1].first)) <= 0){\n      if(ccw(Point(w,line[p+1].second),amdData[i],Point(w,line[p].second)) * ccw(Point(w,line[p+1].second),amdData[i],Point(0.0,line[p+1].first)) <= 0){\n        res++;\n      }\n    }\n  }\n  //cout << \"(p,res) \" << p << \" \" << res << endl;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m >> W >> h >> S && (n|m|W|h|S)){\n    fill(amd, amd+n, 0);\n    line[0] = pair<double,double>(0.0, 0.0);\n    for(int i=1;i<=m;i++){\n      double a, b;\n      cin >> a >> b;\n      line[i] = pair<double,double>(a, b);\n    }\n    for(int i=0;i<n;i++){\n      cin >> amdData[i].x >> amdData[i].y;\n    }\n    for(int i=0;i<m;i++){\n      area[i] = calcArea(i);\n      amd[i] = calcAmd(i);\n    }\n    int ans = n;\n    for(int i=0;i<m;i++){\n      int sumamd = 0;\n      double sum = 0.0;\n      //cout << \"===== \" << i << ' ';\n      for(int j=i;j<m;j++){\n        //cout << j << ' ' ;\n        sumamd += amd[j];\n        sum += area[j];\n        if((double)h*W - sum < (double)S) break;\n        ans = min(ans, n-sumamd);\n      }\n      //cout << endl;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while( cur < m && !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 80000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\ncontinue;\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 80000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\nP t;\n\nint pfind(int p){\n  int l = 0, r = m - 1;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n    for(int i=0;i<n;i++){\n      t = a[i];\n      int p = pfind(i);\n      hasa[p]++;\n    }\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag()) + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS+i, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      if(i <= p && p <= m){\n        int cnt = n - (sumA[p] - sumA[i-1]);\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint bs(double x, double y, int l[], int r[], int w, int m) {\n\n    int lower = 0;\n    int upper = m + 1;\n\n    while( true ) {\n        int t = (lower + upper) / 2;\n\n        if ( y < x * (r[t] - l[t]) / (w + 0.0) + l[t] ) {\n            if ( y > x * (r[t-1] - l[t-1]) / (w + 0.0) + l[t-1] ) {\n                return t - 1;\n            } else {\n                upper = t;     \n            }\n        } else {\n            lower = t;\n        }\n    }\n}\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        int l[m+1];\n        int r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        int fromd_area[m+1];\n        int fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        for(int i = 0; i < n; i++) {\n            nuts[bs(x[i], y[i], l, r, w, m)] += 1;\n        }\n\n        deque<int> from_down_nuts;\n        deque<int> from_up_nuts;\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            if (nuts[i] == 0) continue;\n            int j = lower_bound(fromu_area, fromu_area + m, S - fromd_area[i]) - fromu_area;\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos-=2;\n      if(pos < 0)pos=0;\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n\tassert( j != m-1);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nconst int maxn=30000+10;\nstruct node\n{\n   double x,y;\n}no[maxn];\nstruct line\n{\n   node l,r;\n   bool operator<(line b)const\n   {\n      return l.y<b.l.y||(l.y==b.l.y&&r.y<b.r.y);\n   }\n}a[maxn];\nint sum[maxn];\ndouble area[maxn];\nint n,m,w,h,s;\ninline double xmulti(node a,line b)//å°äºé¶ç¹å¨ç´çº¿ä¸ \n{\n       return (b.l.x-a.x)*(b.r.y-a.y)-(b.l.y-a.y)*(b.r.x-a.x);\n}\nint main()\n{\n    int ans=0;\n    while(scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&s)&&(n+m+w+h+s))\n    {\n        a[0].l.y=a[0].r.y=0;\n        a[0].l.x=0;a[0].r.x=w;\n        for(int i=1;i<=m;i++)\n        {\n           scanf(\"%lf%lf\",&a[i].l.y,&a[i].r.y);\n           a[i].l.x=0;a[i].r.x=w;\n        }\n        m++;\n        a[m].l.y=a[m].r.y=h;\n        a[m].l.x=0;a[m].r.x=w;\n        for(int i=0;i<n;i++)\n        {\n           scanf(\"%lf%lf\",&no[i].x,&no[i].y);\n        }\n        sort(a,a+m);\n        for(int i=0;i<m;i++)\n        {\n           area[i]=((a[i+1].l.y-a[i].l.y)+(a[i+1].r.y-a[i].r.y))*w/2;\n        }\n        memset(sum,0,sizeof(sum));\n        for(int i=0;i<n;i++)\n        {\n           int l=0,r=m;\n           int mid;\n           while(l<=r)\n           {\n             mid=(l+r)/2;\n             if(xmulti(no[i],a[mid])>0)\n             {\n               if(xmulti(no[i],a[mid+1])<0)\n                 break;\n               else\n                 l=mid+1;\n             }\n             else\n                r=mid-1;\n           }\n           sum[mid]++;\n           //cout<<mid<<endl;\n        }\n        ans=-1;\n        int tot=0;\n        double totarea=0;\n        int i=0,j=0;\n        /*while(j<m&&totarea+area[j]<=w*h-s)\n        {\n          totarea+=area[j];\n          tot+=sum[j];\n          j++;\n        }\n        if(j>0)\n        {\n          ans=max(tot,ans);\n        }\n        for(i=1;i<m;i++)\n        {\n          totarea-=area[i-1];\n          tot-=sum[i-1];\n          while(j<m&&totarea+area[j]<=w*h-s)\n          {\n            totarea+=area[j];\n            tot+=sum[i-1];\n          }\n          ans=max(tot,ans);\n        }       */\n        /*while(j<m)\n        {\n          if(totarea>0)\n          {\n             totarea-=area[i-1];\n             tot-=sum[i-1];\n          }\n          while(j<m&&totarea+area[j]<=w*h-s)\n          {\n            totarea+=area[j];\n            tot+=sum[j];\n            j++;\n          }\n          i++;\n          if(totarea==0)\n            j++;\n          ans=max(tot,ans);\n          //cout<<totarea<<' '<<tot<<endl; \n        }*/\n        for(i=0;i<m;i++)\n        {\n           j=max(i,j);\n           if(totarea>0)\n           {\n             totarea-=area[i-1];\n             tot-=sum[i-1];\n           }\n           while(j<m&&area[j]+totarea<=w*h-s)\n           {\n             totarea+=area[j];\n             tot+=sum[j];\n             j++;\n           }\n           //cout<<totarea<<' '<<tot<<endl; \n           ans=max(ans,tot);\n        } \n            \n        printf(\"%d\\n\",n-ans);     \n    }\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\nconst double EPS = 1e-5;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\n\nint pfind(int p){\n  int l = 0, r = m;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() - EPS < (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n    for(int i=0;i<n;i++){\n      int p = pfind(i);\n      hasa[p]++;\n    }\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag())\n        + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      if(i <= p && p <= m){\n        int cnt = max(0, n - (sumA[p] - sumA[i-1]));\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 10000\nusing namespace std;\nint main(){\n\tint n,m ;\n\tdouble ar[MAX],erea[MAX],l[MAX],r[MAX],x[MAX],y[MAX],w,h,S;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<=m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(y[i]<(r[j]-l[j])*(x[i])/w+l[j]){\n\t\t\t\tar[j-1]++;\n\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nint arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  //  c*=b;\n  \n  return (b.x*c.y-b.y*c.x>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i])) up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n \nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=((L[mid][0].y-L[i][0].y)+(L[mid][1].y-L[i][1].y))*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    L[0][0]=point(0,0);\n    L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define MAX 30010\n#define EPS 0.0000000001\nusing namespace std;\ntypedef pair<double,double> P;\n\tdouble ar[MAX],erea[MAX],w,h,S;\n\tvector<double> l(MAX),r(MAX);\n\tvector<P> iti(MAX);\nint main(){\n\tint n,m ;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\titi[i] = P(y,x);\n\t\t}\n\t\tsort(iti.begin(),iti.begin() + m);\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint j1 = lower_bound(l.begin(), l.begin() + m, iti[i].first) - l.begin();\n\t\t\tint j2 = lower_bound(r.begin(), r.begin() + m, iti[i].first) - r.begin();\n\t\t\tint minj = min(j1, j2);\n\t\t\tfor(int j=minj;j<=m;j++){\n\t\t\t\n\t\t\t\tif(iti[i].first<(r[j]-l[j])*(iti[i].second)/w+l[j]) {\n\t\t\t\t\tar[j-1]++;\n\t\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S - EPS) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S - EPS && upper >= 0) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//42\n#include<iostream>\n#include<complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  for(int n,m,w,h,s;cin>>n>>m>>w>>h>>s,n|m|w|h|s;){\n    P l[30001][2]={{P(0,0),P(w,0)}};\n    int ly[30001]={},ry[30001]={};\n    for(int i=1;i<=m;i++){\n      cin>>ly[i]>>ry[i];\n      l[i][0]=P(0,ly[i]);\n      l[i][1]=P(w,ry[i]);\n    }\n    int a[30001]={};\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      P ap(x,y);\n      int hi=m+1,lo=0;\n      while(hi-lo>1){\n\tint md=(hi+lo)/2;\n\tif(cr(l[md][1]-l[md][0],ap-l[md][0])<0){\n\t  hi=md;\n\t}else{\n\t  lo=md;\n\t}\n      }\n      a[lo+1]++;\n    }\n    int ac[30001]={};\n    for(int i=0;i<m;i++){\n      ac[i+1]=ac[i]+a[i+1];\n    }\n    int ll=0,hh=0;\n    int ma=0;\n    for(;;){\n      if((ly[hh]-ry[ll]+ry[hh]-ly[ll])*w/2<w*h-s){\n\thh++;\n      }else{\n\tll++;\n      }\n      if(hh>m||ll>m)break;\n      if((ly[hh]-ry[ll]+ry[hh]-ly[ll])*w/2<=w*h-s){\n\tma=max(ma,ac[hh]-ac[ll]);\n      }\n    }\n    cout<<n-ma<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n      almond[M]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-8)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nconst int maxn=30000+10;\nstruct node\n{\n   double x,y;\n}no[maxn];\nstruct line\n{\n   node l,r;\n   bool operator<(line b)const\n   {\n      return l.y<b.l.y||(l.y==b.l.y&&r.y<b.r.y);\n   }\n}a[maxn];\nint sum[maxn];\ndouble area[maxn];\nint n,m,w,h,s;\ndouble xmulti(node a,line b)//å°äºé¶ç¹å¨ç´çº¿ä¸ \n{\n       return (b.l.x-a.x)*(b.r.y-a.y)-(b.l.y-a.y)*(b.r.x-a.x);\n}\nint main()\n{\n    int ans=0;\n    while(cin>>n>>m>>w>>h>>s&&(n+m+w+h+s))\n    {\n        a[0].l.y=a[0].r.y=0;\n        a[0].l.x=0;a[0].r.x=w;\n        for(int i=1;i<=m;i++)\n        {\n           scanf(\"%lf%lf\",&a[i].l.y,&a[i].r.y);\n           a[i].l.x=0;a[i].r.x=w;\n        }\n        m++;\n        a[m].l.y=a[m].r.y=h;\n        a[m].l.x=0;a[m].r.x=w;\n        for(int i=0;i<n;i++)\n        {\n           scanf(\"%lf%lf\",&no[i].x,&no[i].y);\n        }\n        sort(a,a+n);\n        for(int i=0;i<m;i++)\n        {\n           area[i]=((a[i+1].l.y-a[i].l.y)+(a[i+1].r.y-a[i].r.y))*w/2;\n        }\n        memset(sum,0,sizeof(sum));\n        for(int i=0;i<n;i++)\n        {\n           int l=0,r=m;\n           int mid;\n           while(l<=r)\n           {\n             mid=(l+r)/2;\n             if(xmulti(no[i],a[mid])>0)\n             {\n               if(xmulti(no[i],a[mid+1])<0)\n                 break;\n               else\n                 l=mid+1;\n             }\n             else\n                r=mid+1;\n           }\n           sum[mid]++;\n           //cout<<mid<<endl;\n        }\n        ans=-1;\n        int tot=0;\n        double totarea=0;\n        int i=0,j=0;\n        /*while(j<m&&totarea+area[j]<=w*h-s)\n        {\n          totarea+=area[j];\n          tot+=sum[j];\n          j++;\n        }\n        if(j>0)\n        {\n          ans=max(tot,ans);\n        }\n        for(i=1;i<m;i++)\n        {\n          totarea-=area[i-1];\n          tot-=sum[i-1];\n          while(j<m&&totarea+area[j]<=w*h-s)\n          {\n            totarea+=area[j];\n            tot+=sum[i-1];\n          }\n          ans=max(tot,ans);\n        }       */\n        while(j<m)\n        {\n          if(totarea>0)\n          {\n             totarea-=area[i-1];\n             tot-=sum[i-1];\n          }\n          while(j<m&&totarea+area[j]<=w*h-s)\n          {\n            totarea+=area[j];\n            tot+=sum[j];\n            j++;\n          }\n          i++;\n          if(totarea==0)\n            j++;\n          ans=max(tot,ans);\n          //cout<<totarea<<' '<<tot<<endl; \n        }\n        cout<<(n-ans)<<endl;      \n    }\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst double inf =1e99;\ndouble sqr(double x){\n\treturn x*x;\n}\nint sgn(double x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double _x,double _y):x(_x),y(_y){}\n\tbool operator==(const Point &p)const{\n\t\treturn (sgn(p.x-x)==0&&sgn(p.y-y)==0);\n\t}\n\tbool operator<(const Point &p)const{\n\t\treturn y+eps<p.y||(y<p.y+eps&&x+eps<p.x);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn x*p.y-y*p.x;\n\t}\n\tdouble operator/(const Point &p)const{//轤ケ遘ッ \n\t\treturn x*p.x+y*p.y;\n\t}\n\tPoint operator-(const Point &p)const{\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator+(const Point &p)const{\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator*(const double &k)const{\n\t\treturn Point(x*k,y*k);\n\t}\n\tPoint operator/(const double &k)const{\n\t\treturn Point(x/k,y/k);\n\t}\n\tvoid input(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)\\n\",x,y);\n\t}\n};\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point _a,Point _b):a(_a),b(_b){}\n\tLine(double _x1,double _y1,double _x2,double _y2){\n\t\ta=Point(_x1,_y1),b=Point(_x2,_y2);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn (b-a)*(p-a);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)-(%.3f %.3f)\\n\",a.x,a.y,b.x,b.y);\n\t}\n\tint Direction(const Point &p)const{  //蟾ヲ1?悟承-1?檎コソ荳? \n\t\treturn sgn((*this)*p);\n\t}\n};\ndouble lp[32000],rp[32000];\nPoint pt[32000];\nint sz[32000];\ndouble area[32000],sp[32000];\nint st[32000];\nLine ls[32000];\nint main(){\n\tint n,m;\n\tdouble w,h,s;\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s)){\n\t\tif(n==0&&m==0&&sgn(w)==0&&sgn(h)==0&&sgn(s)==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&lp[i],&rp[i]);\n\t\t}\n\t\tsort(lp,lp+n),sort(rp,rp+n);\n\t\tfor(int i=0;i<m;i++) pt[i].input();\n\t\tmemset(sz,0,sizeof(sz));\n\t\tint cnt=0;\n\t//\tprintf(\"&&&&&%f %f\\n\",lp[n-1],rp[n-1]);\n\t\tif(sgn(h-lp[n-1])||sgn(h-rp[n-1]))\n\t\tls[cnt++]=Line(Point(0,h),Point(w,h));\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tls[cnt++]=Line(Point(0,lp[i]),Point(w,rp[i]));\n\t\t}\n\t\tls[cnt++]=Line(Point(0,0),Point(w,0));\n\t//\tprintf(\"~~~%d\\n\",cnt);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint l=0,r=cnt-1,md,res=-1;\n\t\t\twhile(l<=r){\n\t\t\t\tmd=(l+r)>>1;\n\t\t\t\tif(ls[md].Direction(pt[i])==-1) {\n\t\t\t\t\tl=md+1;\n\t\t\t\t\tres=md;\n\t\t\t\t} else r=md-1;\n\t\t\t}\n\t\t\tsz[res]++;\n\t\t}\n\t\tdouble pl=h,pr=h;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i==n) {\n\t\t\t\tarea[i]=(fabs(pl)+fabs(pr))*w*0.5;\n\t\t\t} else {\n\t\t\t\tarea[i]=(fabs(lp[n-i-1]-pl)+fabs(rp[n-i-1]-pr))*w*0.5;\n\t\t\t\tpl=lp[n-i-1],pr=rp[n-i-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tsp[n]=area[n];st[n]=sz[n];\n\t\tsz[n+1]=0;\n\t\tsp[n+1]=0;\n\t\tfor(int i=n-1;i>=0;i--) sp[i]=area[i]+sp[i+1],st[i]=sz[i]+st[i+1];\n\t\tint mi=m,rb=0,has=0;\n\t\t\n\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\tif(sgn(sp[rb]-s)>=0)\n\t\tmi=min(mi,st[rb]);\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\ts-=area[i];\n\t\t\thas+=sz[i];\n\t\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\t\tif(sgn(sp[rb]-s)>=0)\n\t\t\tmi=min(has+st[rb],mi);\n\t\t}\n\t\tprintf(\"%d\\n\",mi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\nconst double EPS = 1e-5;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\n\nint pfind(int p){\n  int l = 0, r = m;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() - EPS < (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  for(int i=0;i<M+1;i++){\n    sumA[i] = 0;\n    sumS[i] = 0;\n  }\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n    for(int i=0;i<n;i++){\n      int p = pfind(i);\n      hasa[p]++;\n    }\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag())\n        + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      if(i <= p && p <= m){\n        int cnt = max(0, n - (sumA[p] - sumA[i-1]));\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\nusing namespace std;\nconst int maxn=30000+10;\nstruct node\n{\n   double x,y;\n}no[maxn];\nstruct line\n{\n   node l,r;\n   bool operator<(line b)const\n   {\n      return l.y<b.l.y||(l.y==b.l.y&&r.y<b.r.y);\n   }\n}a[maxn];\nint sum[maxn];\ndouble area[maxn];\nint n,m,w,h,s;\ninline double xmulti(node a,line b)//å°äºé¶ç¹å¨ç´çº¿ä¸ \n{\n       return (b.l.x-a.x)*(b.r.y-a.y)-(b.l.y-a.y)*(b.r.x-a.x);\n}\nint main()\n{\n    int ans=0;\n    while(scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&s)&&(n+m+w+h+s))\n    {\n        a[0].l.y=a[0].r.y=0;\n        a[0].l.x=0;a[0].r.x=w;\n        for(int i=1;i<=m;i++)\n        {\n           scanf(\"%lf%lf\",&a[i].l.y,&a[i].r.y);\n           a[i].l.x=0;a[i].r.x=w;\n        }\n        m++;\n        a[m].l.y=a[m].r.y=h;\n        a[m].l.x=0;a[m].r.x=w;\n        for(int i=0;i<n;i++)\n        {\n           scanf(\"%lf%lf\",&no[i].x,&no[i].y);\n        }\n        sort(a,a+m);\n        for(int i=0;i<m;i++)\n        {\n           area[i]=((a[i+1].l.y-a[i].l.y)+(a[i+1].r.y-a[i].r.y))*w/2;\n        }\n        memset(sum,0,sizeof(sum));\n        for(int i=0;i<n;i++)\n        {\n           int l=0,r=m;\n           int mid;\n           while(l<=r)\n           {\n             mid=(l+r)/2;\n             if(xmulti(no[i],a[mid])>0)\n             {\n               if(xmulti(no[i],a[mid+1])<0)\n                 break;\n               else\n                 l=mid+1;\n             }\n             else\n                r=mid-1;\n           }\n           sum[mid]++;\n           //cout<<mid<<endl;\n        }\n        ans=-1;\n        int tot=0;\n        double totarea=0;\n        int i=0,j=0;\n        /*while(j<m&&totarea+area[j]<=w*h-s)\n        {\n          totarea+=area[j];\n          tot+=sum[j];\n          j++;\n        }\n        if(j>0)\n        {\n          ans=max(tot,ans);\n        }\n        for(i=1;i<m;i++)\n        {\n          totarea-=area[i-1];\n          tot-=sum[i-1];\n          while(j<m&&totarea+area[j]<=w*h-s)\n          {\n            totarea+=area[j];\n            tot+=sum[i-1];\n          }\n          ans=max(tot,ans);\n        }       */\n        /*while(j<m)\n        {\n          if(totarea>0)\n          {\n             totarea-=area[i-1];\n             tot-=sum[i-1];\n          }\n          while(j<m&&totarea+area[j]<=w*h-s)\n          {\n            totarea+=area[j];\n            tot+=sum[j];\n            j++;\n          }\n          i++;\n          if(totarea==0)\n            j++;\n          ans=max(tot,ans);\n          //cout<<totarea<<' '<<tot<<endl; \n        }*/\n        for(i=0;i<m;i++)\n        {\n           j=max(i,j);\n           if(totarea>0)\n           {\n             totarea-=area[i-1];\n             tot-=sum[i-1];\n           }\n           while(j<m&&area[j]+totarea<=w*h-s)\n           {\n             totarea+=area[j];\n             tot+=sum[j];\n             j++;\n           }\n           //cout<<totarea<<' '<<tot<<endl; \n           ans=max(ans,tot);\n        } \n            \n        printf(\"%d\\n\",n-ans);     \n    }\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tbool found = false;\n\trep(k,100){\n\t  if(L-k >= 0 && inPolygon(poly[L-k],ps[i])){\n\t    almond[L-k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t  if(R+k < m && inPolygon(poly[R+k],ps[i])){\n\t    almond[R+k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define eps 1e-8\n#define _sign(x) ((x)<-eps?-1:(x)>eps)\n\nstruct point\n{\n    double x, y;\n} tem, p[30050];\n\nstruct line\n{\n    point a, b;\n\n    bool operator<(const line & x)const\n    {\n        if (fabs(a.y - x.a.y) < eps) return b.y < x.b.y + eps;\n        return a.y < x.a.y + eps;\n    }\n} l[30050];\nint n, m, w, h, s;\nint cnt[30050];\ndouble area[30050];\n\ndouble xmult(point p0, point p1, point p2)\n{\n    return (p1.x - p0.x)*(p2.y - p0.y)-(p2.x - p0.x)*(p1.y - p0.y);\n}\nint Xmult(line l, point p) {\n    return (l.a.x - l.b.x)*(p.y - l.b.y)-(p.x - l.b.x)*(l.a.y - l.b.y);\n}\nint fuck(point aa)\n{\n    int lef = 0, rig = n;\n    while (lef <= rig)\n    {\n        int mid = (lef + rig) / 2;\n        if(_sign(Xmult(l[mid-1], aa))<0&&_sign(Xmult(l[mid], aa))>0)\n            return mid-1;\n        if (_sign(Xmult(l[mid], aa))<0)\n            lef = mid+1;\n        else rig = mid-1;\n    }\n}\n\ndouble sss(line x, line y)\n{\n    return fabs(xmult(x.a, x.b, y.b)) +fabs(xmult(x.a, y.b, y.a));\n}\n\nint main()\n{\n    while (scanf(\"%d%d%d%d%d\", &m, &n, &w, &h, &s) && n)\n    {\n        for (int i = 0; i < m; ++i)\n            scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n        l[n].a.x = 0, l[n].a.y = 0;\n        l[n].b.x = w, l[n].b.y = 0;\n        l[n+1].a.x = 0, l[n+1].a.y = h;\n        l[n+1].b.x = w, l[n+1].b.y = h;\n        for (int i = 0; i < n; ++i)\n        {\n            scanf(\"%lf%lf\", &l[i].a.y, &l[i].b.y);\n            l[i].a.x = 0;\n            l[i].b.x = w;\n        }\n        n+=2;\n        sort(l, l + n);\n        if(fabs(l[n+1].a.y-l[n].a.y)<eps&&fabs(l[n+1].b.y-l[n].b.y)<eps) n--;\n        for (int i = 0; i < n; ++i) cnt[i] = 0;\n        for (int i = 1; i < n; ++i)\n            area[i - 1] = sss(l[i - 1], l[i]) / 2.0;\n        for (int i = 0; i < m; ++i) cnt[fuck(p[i])]++;\n        double ss = 0;\n        int up = 0, down = 0, ans=-1, temp = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            up = i;\n            ss += area[up];\n            temp += cnt[up];\n            while (w * h - ss < s - eps)\n            {\n                ss -= area[down];\n                temp -= cnt[down];\n                down++;\n            }\n            ans = max(ans, temp);\n        }\n        printf(\"%d\\n\", m - ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if (cross(a, b) > eps) return 1;\n  if (cross(a, b) < -eps) return -1;\n  if (dot(a, b) < -eps) return 2;\n  if (norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for (int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i + 1) % ps.size()];\n    if (ccw(p1, p2, a) != dir) v.push_back(a);\n    if (ccw(p1, p2, a) * ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nconst int MAXM = 33333;\n\nint n, m;\ndouble w, h, S;\nP L[MAXM], R[MAXM];\nvector<P> ps;\n\ndouble area[MAXM];\nint num[MAXM];\n\nvoid assign(vector<P> ps, int l, int r) {\n  if (r - l < 1) return;\n  if (r - l == 1) {\n    num[l] += ps.size();\n    return;\n  }\n  vector<P> pl, pr;\n  int x = (l + r) / 2;\n  P a = L[x-1];\n  P b = R[x-1];\n  for (int i = 0; i < ps.size(); ++i) {\n    if (ccw(a, b, ps[i]) == 1) {\n      pr.push_back(ps[i]);\n    } else {\n      pl.push_back(ps[i]);\n    }\n  }\n  assign(pl, l, x);\n  assign(pr, x, r);\n}\n\nint main() {\n  while (cin >> n >> m >> w >> h >> S &&\n         (n|m|(int)w|(int)h|(int)S)) {\n    for (int i = 0; i < m; ++i) {\n      cin >> L[i].imag() >> R[i].imag();\n      L[i].real() = 0, R[i].real() = w;\n    }\n    ps.resize(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n\n    area[0] = (L[0].imag() + R[0].imag()) * w / 2.0;\n    for (int i = 1; i < m; ++i) {\n      double hl= L[i].imag() - L[i-1].imag();\n      double hr= R[i].imag() - R[i-1].imag();\n      area[i] = (hl + hr) * w / 2.0;\n    }\n    fill(num, num + m, 0);\n    assign(ps, 0, m);\n\n    int ans = n;\n    double ns = 0;\n    for (int i = 0, j = 0, cnt = 0; i < m;) {\n      while (j < m && h * w - (ns + area[j]) + eps > S) {\n        cnt += num[j];\n        ns += area[j];\n        ++j;\n      }\n      if (i != j) {\n        ans = min(ans, n - cnt);\n        cnt -= num[i];\n        ns -= area[i];\n        i++;\n      } else {\n        j++;\n        i++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n\n    /*\n    int cur = 0;\n    rep(i,n){\n      while( cur < m && !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n    */\n    rep(i,n){\n\n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst double inf =1e99;\ndouble sqr(double x){\n\treturn x*x;\n}\nint sgn(double x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double _x,double _y):x(_x),y(_y){}\n\tbool operator==(const Point &p)const{\n\t\treturn (sgn(p.x-x)==0&&sgn(p.y-y)==0);\n\t}\n\tbool operator<(const Point &p)const{\n\t\treturn y+eps<p.y||(y<p.y+eps&&x+eps<p.x);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn x*p.y-y*p.x;\n\t}\n\tdouble operator/(const Point &p)const{//轤ケ遘ッ \n\t\treturn x*p.x+y*p.y;\n\t}\n\tPoint operator-(const Point &p)const{\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator+(const Point &p)const{\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator*(const double &k)const{\n\t\treturn Point(x*k,y*k);\n\t}\n\tPoint operator/(const double &k)const{\n\t\treturn Point(x/k,y/k);\n\t}\n\tvoid input(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)\\n\",x,y);\n\t}\n};\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point _a,Point _b):a(_a),b(_b){}\n\tLine(double _x1,double _y1,double _x2,double _y2){\n\t\ta=Point(_x1,_y1),b=Point(_x2,_y2);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn (b-a)*(p-a);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)-(%.3f %.3f)\\n\",a.x,a.y,b.x,b.y);\n\t}\n\tint Direction(const Point &p)const{  //蟾ヲ1?悟承-1?檎コソ荳? \n\t\treturn sgn((*this)*p);\n\t}\n};\ndouble lp[32000],rp[32000];\nPoint pt[32000];\nint sz[32000];\ndouble area[32000],sp[32000];\nint st[32000];\nLine ls[32000];\nint main(){\n\tint n,m;\n\tdouble w,h,s;\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s)){\n\t\tif(n==0&&m==0&&sgn(w)==0&&sgn(h)==0&&sgn(s)==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&lp[i],&rp[i]);\n\t\t}\n\t\tsort(lp,lp+n),sort(rp,rp+n);\n\t\tfor(int i=0;i<m;i++) pt[i].input();\n\t\tmemset(sz,0,sizeof(sz));\n\t\tint cnt=0;\n\t//\tprintf(\"&&&&&%f %f\\n\",lp[n-1],rp[n-1]);\n\t\tif(sgn(h-lp[n-1])||sgn(h-rp[n-1]))\n\t\tls[cnt++]=Line(Point(0,h),Point(w,h));\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tls[cnt++]=Line(Point(0,lp[i]),Point(w,rp[i]));\n\t\t}\n\t\tls[cnt++]=Line(Point(0,0),Point(w,0));\n\t//\tprintf(\"~~~%d\\n\",cnt);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint l=0,r=cnt-1,md,res=-1;\n\t\t\twhile(l<=r){\n\t\t\t\tmd=(l+r)>>1;\n\t\t\t\tif(ls[md].Direction(pt[i])==-1) {\n\t\t\t\t\tl=md+1;\n\t\t\t\t\tres=md;\n\t\t\t\t} else r=md-1;\n\t\t\t}\n\t\t\tsz[res]++;\n\t\t}\n\t\tdouble pl=h,pr=h;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i==n) {\n\t\t\t\tarea[i]=(fabs(pl)+fabs(pr))*w*0.5;\n\t\t\t} else {\n\t\t\t\tarea[i]=(fabs(lp[n-i-1]-pl)+fabs(rp[n-i-1]-pr))*w*0.5;\n\t\t\t\tpl=lp[n-i-1],pr=rp[n-i-1];\n\t\t\t}\n\t\t}\n\t\tsp[n]=area[n];st[n]=sz[n];\n\t\tsz[n+1]=0;\n\t\tsp[n+1]=0;\n\t\tfor(int i=n-1;i>=0;i--) sp[i]=area[i]+sp[i+1],st[i]=sz[i]+st[i+1];\n\t\tint mi=m,rb=0,has=0;\n\t\twhile(sgn(sp[rb+1]-s)>=0) rb++;\n\t\tif(sgn(sp[rb]-s)>=0)\n\t\tmi=min(mi,st[rb]);\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\ts-=area[i];\n\t\t\thas+=sz[i];\n\t\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\t\tif(sgn(sp[rb]-s)>=0)\n\t\t\tmi=min(has+st[rb],mi);\n\t\t}\n\t\tprintf(\"%d\\n\",mi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      //if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      //if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint l[31000];\nint r[31000];\ndouble x[31000];\ndouble y[31000];\nint h[31000];\nint s[31000];\nint sum[31000];\nint hsum[31000];\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",l+i,r+i);\n\t\t}\n\t\tfor(int i=0;i<b;i++)h[i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(i)s[i]=(l[i]+r[i]-l[i-1]-r[i-1])*c;\n\t\t\telse s[i]=(l[0]+r[0])*c;\n\t\t}\n\t\tsum[0]=s[0];\n\t\tfor(int i=1;i<b;i++){\n\t\t\tsum[i]=sum[i-1]+s[i];\n\t\t}\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\te*=2;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint L=0;\n\t\t\tint R=b;\n\t\t\twhile(L+1<R){\n\t\t\t\tint M=(L+R)/2;\n\t\t\t\tdouble at=(double)l[M-1]+(double)(r[M-1]-l[M-1])/c*x[i];\n\t\t\t\tif(at>y[i])R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\th[L]++;\n\t\t}\n\t\tfor(int i=0;i<=b;i++)hsum[i]=0;\n\t\tfor(int i=0;i<b;i++)hsum[i+1]=hsum[i]+h[i];\n\t\tint ret=999999999;\n\t\tint now=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\t//if(c*d*2-now<e)break;\n\t\t\tint to=upper_bound(sum,sum+b,now+c*d*2-e)-sum;\n\t\t\tret=min(ret,a-(hsum[to]-hsum[i]));\n\t\t\tnow+=s[i];\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst double inf =1e99;\ndouble sqr(double x){\n\treturn x*x;\n}\nint sgn(double x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double _x,double _y):x(_x),y(_y){}\n\tbool operator==(const Point &p)const{\n\t\treturn (sgn(p.x-x)==0&&sgn(p.y-y)==0);\n\t}\n\tbool operator<(const Point &p)const{\n\t\treturn y+eps<p.y||(y<p.y+eps&&x+eps<p.x);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn x*p.y-y*p.x;\n\t}\n\tdouble operator/(const Point &p)const{//轤ケ遘ッ \n\t\treturn x*p.x+y*p.y;\n\t}\n\tPoint operator-(const Point &p)const{\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator+(const Point &p)const{\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator*(const double &k)const{\n\t\treturn Point(x*k,y*k);\n\t}\n\tPoint operator/(const double &k)const{\n\t\treturn Point(x/k,y/k);\n\t}\n\tvoid input(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)\\n\",x,y);\n\t}\n};\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point _a,Point _b):a(_a),b(_b){}\n\tLine(double _x1,double _y1,double _x2,double _y2){\n\t\ta=Point(_x1,_y1),b=Point(_x2,_y2);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn (b-a)*(p-a);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)-(%.3f %.3f)\\n\",a.x,a.y,b.x,b.y);\n\t}\n\tint Direction(const Point &p)const{  //蟾ヲ1?悟承-1?檎コソ荳? \n\t\treturn sgn((*this)*p);\n\t}\n};\ndouble lp[32000],rp[32000];\nPoint pt[32000];\nint sz[32000];\ndouble area[32000],sp[32000];\nint st[32000];\nLine ls[32000];\nint main(){\n\tint n,m;\n\tdouble w,h,s;\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s)){\n\t\tif(n==0&&m==0&&sgn(w)==0&&sgn(h)==0&&sgn(s)==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&lp[i],&rp[i]);\n\t\t}\n\t\tsort(lp,lp+n),sort(rp,rp+n);\n\t\tfor(int i=0;i<m;i++) pt[i].input();\n\t\tmemset(sz,0,sizeof(sz));\n\t\tint cnt=0;\n\t//\tprintf(\"&&&&&%f %f\\n\",lp[n-1],rp[n-1]);\n\t\tif(sgn(h-lp[n-1])||sgn(h-rp[n-1]))\n\t\tls[cnt++]=Line(Point(0,h),Point(w,h));\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tls[cnt++]=Line(Point(0,lp[i]),Point(w,rp[i]));\n\t\t}\n\t\tls[cnt++]=Line(Point(0,0),Point(w,0));\n\t//\tprintf(\"~~~%d\\n\",cnt);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint l=0,r=cnt-1,md,res=-1;\n\t\t\twhile(l<=r){\n\t\t\t\tmd=(l+r)>>1;\n\t\t\t\tif(ls[md].Direction(pt[i])==-1) {\n\t\t\t\t\tl=md+1;\n\t\t\t\t\tres=md;\n\t\t\t\t} else r=md-1;\n\t\t\t}\n\t\t\tsz[res]++;\n\t\t}\n\t\tdouble pl=h,pr=h;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i==n) {\n\t\t\t\tarea[i]=(fabs(pl)+fabs(pr))*w*0.5;\n\t\t\t} else {\n\t\t\t\tarea[i]=(fabs(lp[n-i-1]-pl)+fabs(rp[n-i-1]-pr))*w*0.5;\n\t\t\t\tpl=lp[n-i-1],pr=rp[n-i-1];\n\t\t\t}\n\t\t}\n\t\t//for(int i=0;i<=n;i++) printf(\"%d\\n\",sz[i]);\n\t\tsp[n]=area[n];st[n]=sz[n];\n\t\tst[n+1]=0;\n\t\tsp[n+1]=0;\n\t\tfor(int i=n-1;i>=0;i--) sp[i]=area[i]+sp[i+1],st[i]=sz[i]+st[i+1];\n\t\tint mi=m,rb=0,has=0;\n\t\t\n\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\tif(sgn(sp[rb]-s)>=0)\n\t\tmi=min(mi,st[rb]);\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\ts-=area[i];\n\t\t\thas+=sz[i];\n\t\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\t\tif(sgn(sp[rb]-s)>=0)\n\t\t\tmi=min(has+st[rb],mi);\n\t\t}\n\t\tprintf(\"%d\\n\",mi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    if(s == 0){\n      cout << 0 << endl;\n      continue;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n      else if(L-1>=0 && inPolygon(poly[L-1],ps[i]))almond[L-1]++;\n      else if(R+1<m && inPolygon(poly[R+1],ps[i]))almond[R+1]++;\n      else if(L-2>=0 && inPolygon(poly[L-2],ps[i]))almond[L-2]++;\n      else if(R+2<m && inPolygon(poly[R+2],ps[i]))almond[R+2]++;\n      else if(L-3>=0 && inPolygon(poly[L-3],ps[i]))almond[L-3]++;\n      else if(R+3<m && inPolygon(poly[R+3],ps[i]))almond[R+3]++;\n      else if(L-4>=0 && inPolygon(poly[L-4],ps[i]))almond[L-4]++;\n      else if(R+4<m && inPolygon(poly[R+4],ps[i]))almond[R+4]++;\n      else assert(false);\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  if(L-k >= 0 && inPolygon(poly[L-k],ps[i])){\n\t    almond[L-k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t  if(R+k < m && inPolygon(poly[R+k],ps[i])){\n\t    almond[R+k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t}\n\t\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n\n    /*\n    int cur = 0;\n    rep(i,n){\n      while( cur < m && !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n    */\n    rep(i,n){\n      rep(j,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n  arm[m+1]=n;\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n\n    assert(L[m][0]==point(0,h)&&L[m][1]==point(w,h));\n\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <complex>\nusing namespace std;\nusing W = double;\nusing P = complex<W>;\nusing L = pair<P,P>;\n\n#define X real()\n#define Y imag()\n\nconstexpr W EPS = 1e-8;\n\nW cross(const P& a, const P& b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nbool is_below(const L &l, const P &p){\n  P d = l.second - l.first;\n  P q = p - l.first;\n  return cross(d,q) < EPS;\n}\n\nint main(){\n  int n, m;\n  W w, h, s;\n  while(cin >> n >> m >> w >> h >> s, n){\n    vector<L> lines;\n    lines.emplace_back(P(0,0),P(w,0));\n\n    vector<W> S(m+2,0);\n    for(int i = 0; i < m; ++i){\n      W l, r;\n      cin >> l >> r;\n      lines.emplace_back(P(0,l),P(w,r));\n      S[i+1] = (l+r)/2*w;\n    }\n\n    lines.emplace_back(P(0,h),P(w,h));\n    S[m+1] = w*h;\n\n    for(int i = m+1; i > 0; --i) S[i] -= S[i-1];\n\n    vector<int> C(m+2,0);\n    for(int i = 0; i < n; ++i){\n      W x, y;\n      cin >> x >> y;\n      P a(x,y);\n      int ng = 0, ok = m+1;\n      while(ok - ng > 1){\n\tint m = (ok+ng)/2;\n\tif(is_below(lines[m],a)){\n\t  ok = m;\n\t}else{\n\t  ng = m;\n\t}\n      }\n      ++C[ok];\n      // cerr << i << \" \" << ok << endl;\n    }\n\n    double curS = 0, lim = h * w - s;\n    int curA = 0, ub = 0, ans = n;\n    for(int lb=0; lb<m+2; lb++) {\n      while(ub < m+2 and (curS + S[ub] <= lim + EPS)) {\n\tcurS += S[ub]; curA += C[ub];\n\tub++;\n      }\n      // fprintf(stderr, \"[%d, %d): curS = %.12f, curA = %d\\n\", lb, ub, curS, curA);\n      ans = min(ans, n - curA);\n\n      if(lb == ub) {\n\tub++;\n      }\n      else {\n\tcurS -= S[lb];\n\tcurA -= C[lb];\n      }\n    }\n\n    /*\n    cerr << \"S\" << endl;\n    for(auto s : S) cerr << s << \" \" ;\n    cerr << endl;\n\n    cerr << \"C\" << endl;\n    for(auto c : C) cerr << c << \" \" ;\n    cerr << endl;\n    */\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30005;\nconst int M = 30005;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\nP t;\n\nbool comp(const P &p1, const P &p2){\n  bool f1 = t.imag() <= (p1.imag() - p1.real()) * t.real() / w + p1.real();\n  //bool f2 = t.imag() <= (p2.imag() - p2.real()) * t.real() / w + p2.real();\n  return f1;\n  //return f1 < f2;\n}\n\nint pfind(int p){\n  int l = 0, r = m - 1;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n/*\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n        if(a[j].imag() <= (ver[i].imag() - ver[i].real()) * a[j].real() / w + ver[i].real()){\n          cout << a[j].imag() << ' ' <<  (ver[i].imag() - ver[i].real()) * a[j].real() / w + ver[i].real() << endl;\n          cout << i << ' ' << j << endl;\n        }\n      }\n    }\n*/\n    for(int i=0;i<n;i++){\n      t = a[i];\n      //int p = lower_bound(ver.begin(), ver.end(), true, comp) - ver.begin();\n      int p = pfind(i);\n      //cout << i << \": p = \" << p << endl;\n      hasa[p]++;\n    }\n    /*for(int i=0;i<m;i++){\n      cout << hasa[i] << ' ';\n      }\n      cout << endl;*/\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag()) + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    /*for(int i=0;i<=m;i++){\n      cout << sumS[i] << ' ';\n    }\n    cout << endl;*/\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    /*for(int i=0;i<=m;i++){\n      cout << sumA[i] << ' ';\n    }\n    cout << endl;*/\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS+i, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      //cout << i << \": p = \" << p << endl;\n      if(0 <= p && p <= m){\n        int cnt = n - (sumA[p] - sumA[i-1]);\n        //cout << \"n = \" << n << \", cnt = \" << cnt << endl;\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint main(){\n    while(1){\n        int n,m,w,h,s;\n        cin >> n >> m >> w >> h >> s;\n        if(n==0) break;\n\n        vector<double> l(m+1, 0), r(m+1, 0);\n        for(int i=1; i<=m; i++){\n            cin >> l[i] >> r[i];\n        }\n        VP p(n);\n        for(int i=0; i<n; i++){\n            double x,y;\n            cin >> x >> y;\n            p[i] = P(x, y);\n        }\n\n        vector<double> area(m+1, 0);\n        for(int i=1; i<=m; i++){\n            VP poly = {P(0, l[i-1]), P(w, r[i-1]), P(w, r[i]), P(0, l[i])};\n            area[i] = getarea(poly);\n            area[i] += area[i-1];\n        }\n        vector<int> num(m+1, 0);\n        for(int i=0; i<n; i++){\n            int ub=m, lb=0;\n            while(lb +1 < ub){\n                int mid = (lb +ub)/2;\n                if(ccw(P(0, l[mid]), P(w, r[mid]), p[i]) == 1){\n                    lb = mid;\n                }else{\n                    ub = mid;\n                }\n            }\n            num[ub]++;\n        }\n        for(int i=0; i<m; i++){\n            num[i+1] += num[i];\n        }\n\n        int ans = 1e9;\n        for(int i=0; i<m; i++){\n            if(area[i] +EPS >= s){\n                ans = min(ans, num[i]);\n                break;\n            }\n            int lb=i, ub=m;\n            while(lb +1 < ub){\n                int mid = (lb +ub)/2;\n                if(h*w -(area[mid] -area[i]) +EPS > s){\n                    lb = mid;\n                }else{\n                    ub = mid;\n                }\n            }\n            ans = min(ans, n-(num[lb] -num[i]));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tbool found = false;\n\trep(k,100){\n\t  if(L-k >= 0 && inPolygon(poly[L-k],ps[i])){\n\t    almond[L-k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t  if(R+k < m && inPolygon(poly[R+k],ps[i])){\n\t    almond[R+k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t}\n\t\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, M, W, H;\ndouble S;\nbool under(double x, double y, double l, double r){\n  double crs = (double)W * (y - l) - (r - l) * x;\n  return crs < 0;\n}\n\nint main(){\n  while(cin >> N >> M >> W >> H >> S && N){\n    double l[30000], r[30000];\n    REP(i, M) cin >> l[i] >> r[i];\n    double cx[30000], cy[30000];\n    REP(i, N) cin >> cx[i] >> cy[i];\n    int choco[30000] = {};\n    REP(i, N){\n      int lb = -1, ub = M - 1;\n      while(ub - lb > 1){\n        int m = (ub + lb) / 2;\n        if(under(cx[i], cy[i], l[m], r[m])){\n          ub = m;\n        }else{\n          lb = m;\n        }\n      }\n      choco[ub]++;\n    }\n    double area[30000];\n    REP(i, M){\n      double l1 = i - 1 >= 0 ? l[i - 1] : 0;\n      double r1 = i - 1 >= 0 ? r[i - 1] : 0;\n      double l2 = l[i], r2 = r[i];\n      double L = l2 - l1, R = r2 - r1;\n      area[i] = (L + R) / 2.0 * W;\n    }\n    int accumC[30001] = {};\n    double accumS[30001] = {};\n    REP(i, M) accumS[i + 1] = accumS[i] + area[i];\n    REP(i, M) accumC[i + 1] = accumC[i] + choco[i];\n    //debug(accumS, accumS + M + 1);\n    //debug(accumC, accumC + M + 1);\n    int ans = N;\n    int e = 0;\n    for(int b = 0; b < M; b++){\n      while(e < M && accumS[e + 1] - accumS[b] < (double) W * H - S + EPS) e ++;\n      ans = min(ans, N - (accumC[e] - accumC[b]));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\n\nclass Solver {\n};\n\n\nint main() {\n\twhile (true) {\n\t\tint n, m, w, h, s;\n\t\tcin >> n >> m >> w >> h >> s;\n\t\tif (n == 0)break;\n\n\t\tvector<int> ls(m);\n\t\tvector<int> rs(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> ls[i] >> rs[i];\n\t\t}\n\n\t\tvector<tuple<double, double>> xys;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\txys.emplace_back(x, y);\n\t\t}\n\n\t\tvector<double> range_s(m);\n\t\tvector<int> range_cnt(m, 0);\n\t\tdouble s_sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tdouble s_tmp = (ls[i] + rs[i]) * 0.5 * w;\n\t\t\trange_s[i] = s_tmp - s_sum;\n\t\t\ts_sum = s_tmp;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint bottom = -1;\n\t\t\tint top = m - 1;\n\t\t\tdouble x, y;\n\t\t\ttie(x, y) = xys[i];\n\t\t\twhile (bottom + 1 < top) {\n\t\t\t\tint mid = (bottom + top + 1) / 2;\n\n\t\t\t\tdouble yy = (rs[mid] - ls[mid]) * x / w + ls[mid];\n\t\t\t\tif (yy >= y)top = mid;\n\t\t\t\telse bottom = mid;\n\t\t\t}\n\n\t\t\trange_cnt[top]++;\n\t\t}\n\n\t\tvector<int> sums(m, 0);\n\t\tsums[0] = range_cnt[0];\n\t\tfor (int i = 1; i < m; i++) {\n\t\t\tsums[i] = sums[i - 1] + range_cnt[i];\n\t\t}\n\n\t\tint res = n;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint bottom = i;\n\t\t\tint top = m;\n\t\t\twhile (bottom + 1 < top) {\n\t\t\t\tint mid = (bottom + top) / 2;\n\t\t\t\tint l_delta = ls[mid];\n\t\t\t\tint r_delta = rs[mid];\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tl_delta -= ls[i - 1];\n\t\t\t\t\tr_delta -= rs[i - 1];\n\t\t\t\t}\n\t\t\t\tdouble sum_tmp = (l_delta + r_delta) * 0.5 * w;\n\t\t\t\tdouble remain_s = h * w - sum_tmp;\n\n\t\t\t\tif (remain_s >= s)bottom = mid;\n\t\t\t\telse top = mid;\n\t\t\t}\n\n\t\t\tdouble l_d = ls[bottom];\n\t\t\tdouble r_d = rs[bottom];\n\t\t\tif (i > 0) {\n\t\t\t\tl_d -= ls[i - 1];\n\t\t\t\tr_d -= rs[i - 1];\n\t\t\t}\n\t\t\tdouble sum = (l_d + r_d) * 0.5 * w;\n\t\t\tif (w * h - sum < s)continue;\n\n\t\t\tint tmp = sums[m - 1] - sums[bottom];\n\t\t\tif (i > 0)tmp += sums[i - 1];\n\t\t\tres = min(res, tmp);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  assert(c.y!=0);\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n  arm[m+1]=n;\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 30010\nusing namespace std;\n\tdouble ar[MAX],erea[MAX],l[MAX],r[MAX],x[MAX],y[MAX],w,h,S;\nint main(){\n\tint n,m ;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<=m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(y[i]<(r[j]-l[j])*(x[i])/w+l[j]){\n\t\t\t\tar[j-1]++;\n\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S && upper >= 0) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n  \nvoid getnum(const int l, const int r, const vector<pair<ld, ld>>&armonds, const vector<pair<ld, ld>>&lines,vector<pair<int,ld>>&areas) {\n\tif (l + 1 == r) {\n\t\tareas[l].first = armonds.size();\n\t}\n\telse {\n\t\tint m = (l + r) / 2;\n\t\tpair<ld, ld>line(lines[m]);\n\t\tvector<pair<ld, ld>>larmonds, rarmonds;\n\t\tfor (auto armond : armonds) {\n\t\t\tld ay = line.first + line.second*armond.first;\n\t\t\tif (ay > armond.second) {\n\t\t\t\tlarmonds.emplace_back(armond);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trarmonds.emplace_back(armond);\n\t\t\t}\n\t\t}\n\t\tgetnum(l, m, larmonds, lines, areas);\n\t\tgetnum(m, r, rarmonds, lines, areas);\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M, W, H, S; cin >> N >> M >> W >> H >> S;\n\t\tif (!N)break;\n\t\tvector<pair<ld, ld>>lines;\n\t\tlines.emplace_back(0, 0);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tld l, r; cin >> l >> r;\n\t\t\tlines.emplace_back(l, (r - l) / W);\n\t\t}\n\t\tvector<pair<ld, ld>>armonds;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tarmonds.emplace_back(x, y);\n\t\t}\n\t\tvector<pair<int, ld>>areas(M);\n\t\t{\n\t\t\tint froml = 0, fromr = 0;\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tareas[i].second = (lines[i+1].first + lines[i+1].second - froml - fromr)*W;\n\t\t\t\tfroml = lines[i+1].first;\n\t\t\t\tfromr = lines[i+1].second;\n\t\t\t}\n\t\t}\n\t\tgetnum(0, M, armonds, lines, areas);\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tld needarea = W*H - S + eps;\n\t\tld sum = 0;\n\t\tint num = 0;\n\t\tint ans = 0;\n\t\tbool flag = true;\n\t\twhile (1) {\n\t\t\twhile (sum < needarea) {\n\t\t\t\tans = max(ans, num);\n\t\t\t\tif (r == M) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum += areas[r].second;\n\t\t\t\t\tnum += areas[r].first;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif (!flag)break;\n\t\t\twhile (sum > needarea) {\n\t\t\t\tsum -= areas[l].second;\n\t\t\t\tnum -= areas[l].first;\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tcout << N-ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint bs(double x, double y, long l[], long r[], long w, int m) {\n\n    int lower = 0;\n    int upper = m + 1;\n\n    while( true ) {\n        int t = (lower + upper) / 2;\n\n        if ( y < x * (r[t] - l[t]) / (w + 0.0) + l[t] ) {\n            if ( y > x * (r[t-1] - l[t-1]) / (w + 0.0) + l[t-1] ) {\n                return t - 1;\n            } else {\n                upper = t;     \n            }\n        } else {\n            lower = t;\n        }\n    }\n}\n\nint main() {\n\n    int n, m;\n    long w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        long l[m+1];\n        long r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        long fromd_area[m+1];\n        long fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        fill(nuts, nuts + m, 0);\n        for(int i = 0; i < n; i++) {\n            nuts[bs(x[i], y[i], l, r, w, m)] += 1;\n        }\n\n        int fromd_nuts[m+1];\n        int fromu_nuts[m+1];\n        fromd_nuts[0] = 0;\n        fromu_nuts[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_nuts[i] = fromd_nuts[i-1] + nuts[i-1];\n            fromu_nuts[i] = fromu_nuts[i-1] + nuts[m-i];\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = lower_bound(fromu_area, fromu_area + m + 1, S - fromd_area[i]) - fromu_area;\n            if (minnuts > fromd_nuts[i] + fromu_nuts[j]) {\n                minnuts = fromd_nuts[i] + fromu_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nint arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=conj(b); \n   return (c.y>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i])) up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n \nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=((L[mid][0].y-L[i][0].y)+(L[mid][1].y-L[i][1].y))*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    L[0][0]=point(0,0);\n    L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n\n    /*\n    int cur = 0;\n    rep(i,n){\n      while( cur < m && !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n    */\n    rep(i,n){\n\n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int N = 30000;\nconst int M = 30000;\n\nint n, m, w, h, S;\nvector<P> ver, a;\nint hasa[M], sumA[M+1];\ndouble sumS[M+1];\nP t;\n\nbool comp(const P &p1, const P &p2){\n  bool f1 = t.imag() <= (p1.imag() - p1.real()) * t.real() / w + p1.real();\n  //bool f2 = t.imag() <= (p2.imag() - p2.real()) * t.real() / w + p2.real();\n  return f1;\n  //return f1 < f2;\n}\n\nint pfind(int p){\n  int l = 0, r = m;\n  while(l + 1 < r){\n    int mid = (l + r) / 2;\n    if(a[p].imag() <= (ver[mid].imag() - ver[mid].real()) * a[p].real() / w + ver[mid].real()){\n      r = mid;\n    }else{\n      l = mid;\n    }\n  }\n  return r;\n}\n\nvoid init(){\n  ver.clear();\n  a.clear();\n  fill(hasa, hasa+M+1, 0);\n}\n\nmain(){\n  while(cin >> n >> m >> w >> h >> S && (n|m|w|h|S)){\n    init();\n    for(int i=0;i<m;i++){\n      double l, r;\n      cin >> l >> r;\n      ver.push_back(P(l, r));\n    }\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      a.push_back(P(x, y));\n    }\n/*\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n        if(a[j].imag() <= (ver[i].imag() - ver[i].real()) * a[j].real() / w + ver[i].real()){\n          cout << a[j].imag() << ' ' <<  (ver[i].imag() - ver[i].real()) * a[j].real() / w + ver[i].real() << endl;\n          cout << i << ' ' << j << endl;\n        }\n      }\n    }\n*/\n    for(int i=0;i<n;i++){\n      t = a[i];\n      //int p = lower_bound(ver.begin(), ver.end(), true, comp) - ver.begin();\n      int p = pfind(i);\n      //cout << i << \": p = \" << p << endl;\n      hasa[p]++;\n    }\n    /*for(int i=0;i<m;i++){\n      cout << hasa[i] << ' ';\n      }\n      cout << endl;*/\n    sumS[0] = 0;\n    for(int i=0;i<m;i++){\n      sumS[i+1] = (double)w * min(ver[i].real(), ver[i].imag()) + fabs(ver[i].real() - ver[i].imag()) * (double)w / 2.0;\n    }\n    /*for(int i=0;i<=m;i++){\n      cout << sumS[i] << ' ';\n    }\n    cout << endl;*/\n    sumA[0] = 0;\n    for(int i=0;i<m;i++){\n      sumA[i+1] = sumA[i] + hasa[i];\n    }\n    /*for(int i=0;i<=m;i++){\n      cout << sumA[i] << ' ';\n    }\n    cout << endl;*/\n    int ans = n;\n    for(int i=1;i<=m;i++){\n      int p = upper_bound(sumS+i, sumS+m+1, w * h - S + sumS[i-1]) - sumS - 1;\n      //cout << i << \": p = \" << p << endl;\n      if(p < m + 1){\n        int cnt = n - (sumA[p] - sumA[i-1]);\n        //cout << \"n = \" << n << \", cnt = \" << cnt << endl;\n        ans = min(ans, cnt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 80000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    /*\n    int cur = 0;\n    rep(i,n){\n      while( cur < m && !inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n    */\n    rep(i,n){\n\n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        deque<int> l;\n        deque<int> r;\n        l.push_back(0);\n        r.push_back(0);\n        for(int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            l.push_back(a);\n            r.push_back(b);\n        }\n        vector<double> x;\n        vector<double> y;\n        for(int i = 0; i < n; i++) {\n            double a, b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n        }\n\n        vector<int> area;\n        vector<int> nuts;\n        for(int i = 0; i < m; i++) {\n            area.push_back((l[i+1] - l[i] + r[i+1] - r[i]) * w); \n            nuts.push_back(0);\n        }\n\n        for(int i = 0; i < n; i++) {\n            int j1 = distance( l.begin(), lower_bound(l.begin(), l.end(), y[i] ));\n            int j;\n            for(j = 0; j < j1; j++) {\n                if( y[i] <= x[i] * ( r[j] - l[j] ) / (w + 0.0) + l[j] ) break;\n            }\n            nuts[j - 1] += 1;\n        }\n\n        deque<int> from_down;\n        deque<int> from_up;\n        deque<int> from_down_nuts;\n        deque<int> from_up_nuts;\n        from_up.push_back(0);\n        from_down.push_back(0);\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down.push_back(area[i - 1] + from_down[i - 1]);\n            from_up.push_back(area[m - i] + from_up[i - 1]);\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = distance(from_up.begin(), lower_bound(from_up.begin(), from_up.end(), S - from_down[i]));\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n#define sz(v) v.size()\n#define mk(x, y) make_pair(x, y)\n#define fst first\n#define scd second\n#define MEMSET(x, n) memset(x, n, sizeof(x))\n#define MEMZERO(x) MEMSET(x, 0)\n#define URU(y) (!(y % 4) && y % 100 || !(y % 400))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nstruct Line\n{\n\tdouble l;\n\tdouble r;\n\tint num;\n};\n\nenum Check\n{\n\tLOW = 0,\n\tMID,\n\tHIGH,\n};\n\ndouble cross_product( float x1, float y1, float x2, float y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\ninline Check inRange( Line l, Line h, double x, double y, double w )\n{\n\tdouble v1, v2;\n\t\n\tv1 = cross_product(w, (l.r - l.l), x, (y - l.l));\n\tv2 = cross_product(w, (h.r - h.l), x, (y - h.l));\n\t\n\tif (0 < v1 && 0 < v2) // 上\n\t\treturn HIGH;\n\tif (0 > v1 && 0 > v2) // 下\n\t\treturn LOW;\n\telse\t\t\t\t  // 中\n\t\treturn MID;\n}\n\nint main( void )\n{\n\tint n, m, w, h, S;\n\tLine T[30010];\n\tint N1[30010], S1[30010];\n\t\n\twhile ( cin >> n >> m >> w >> h >> S, n | m | w | h | S )\n\t{\n\t\tMEMZERO(T);\n\t\t\n\t\trep2 (i, 1, (m + 1))\n\t\t{\n\t\t\tcin >> T[i].l >> T[i].r;\n\t\t}\n\t\t\n\t\trep (i, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\tint low = 1, high = m;\n\t\t\twhile (low <= high)\n\t\t\t{\n\t\t\t\tint mid = (low + high) / 2;\n\t\t\t\tCheck c = inRange(T[mid-1], T[mid], x, y, (double)w);\n\t\t\t\t\n\t\t\t\tif (c == LOW)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse if (c == HIGH)\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\telse // c == Check::MID\n\t\t\t\t{\n\t\t\t\t\t++T[mid].num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = n, sum = 0;\n\t\t\n\t\trep (i, (m + 1))\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tN1[i] = sum;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif ((S * 2) <= (S1[i] = ((T[i].l + T[i].r) * w)))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout << ans << endl;\n\t\t\n\t\trep2 (i, 0, m)\n\t\t{\n\t\t\tif (ans <= N1[i])\n\t\t\t\tbreak;\n\t\t\tsum = 0;\n\t\t\trepm (j, m, (i + 1))\n\t\t\t{\n\t\t\t\tsum += T[j].num;\n\t\t\t\tif (ans <= (N1[i] + sum))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((S * 2) <= (((2 * h - (T[j-1].l + T[j-1].r)) * w) + S1[i]))\n\t\t\t\t{\n\t\t\t\t\tans = N1[i] + sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,w,h,S;\n\nstruct Line{\n  double a;\n  double b;\n  double l;\n  double r;\n\n  double gety(double x){\n    return a*x+b;\n  }\n};\nstruct Point{\n  double x;\n  double y;\n\n  bool operator < (const Point &a)const{\n    return y < a.y;\n  }\n};\n\n\nvector <Line> lr;\nvector <Point> ar;\n\nint main(){\n\n  while(cin>>n>>m>>w>>h>>S, n|m|w|h|S){\n    m += 2;\n    lr.clear();\n    lr = vector<Line>(m);\n    ar.clear();\n    ar = vector<Point>(n);\n    lr[0].l = lr[0].b = lr[0].a = lr[0].r = 0;\n\n    for(int i = 1; i < m-1; i++){\n      double l,r;\n      cin>>l>>r;\n      lr[i].a = (r-l)/(double)w;\n      lr[i].b = l;\n      lr[i].l = l;\n      lr[i].r = r;\n    }\n    lr[m-1].l = lr[m-1].b = lr[m-1].r = h;\n    lr[m-1].a = 0;\n    for(int i = 0; i < n; i++){\n      double x, y; cin >> x >> y;\n      ar[i].x = x; ar[i].y = y;\n    }\n    sort(ar.begin(), ar.end());\n    vector< pair<int, double> > area(m-1, make_pair(0, 0));\n\n    for(int i = 0; i < n; i++){\n      int l = 0, r = m;\n      while(l + 1 < r){\n        int mid = (l+r)/2;\n        if(ar[i].y >= lr[mid].gety(ar[i].x)){\n          l = mid;\n        }else{\n          r = mid;\n        }\n      }\n      area[l].first++;\n    }\n    for(int i = 0; i < m-1; i++){\n      area[i].second = (lr[i+1].l - lr[i].l + lr[i+1].r - lr[i].r)*w/2.0;\n    }\n\n    /*\n    for(int i = 0; i < area.size(); i++){\n      cout << i+1 << \". \" << area[i].first << \" amds, \" << area[i].second << \" sqs\" << endl;\n    }\n    */\n\n    vector<double> areasum(area.size()+1, 0);\n    vector<int> amsum(area.size()+1, 0);\n    double totalarea = h*w;\n    for(size_t i = 1; i < areasum.size(); i++){\n      areasum[i] += areasum[i-1] + area[i-1].second;\n    }\n    for(size_t i = 1; i < amsum.size(); i++){\n      amsum[i] += amsum[i-1] + area[i-1].first;\n    }\n\n\n    int ans =0;\n    for(size_t bottom = 0; bottom < area.size(); bottom++){\n      int l = bottom, r = amsum.size();\n      while(l+1 < r){\n        int mid = (l+r)/2;\n        if(areasum[mid] - areasum[bottom] > totalarea - S){\n          r = mid;\n        }else{\n          l = mid;\n        }\n      }\n      ans = max(ans, amsum[l] - amsum[bottom]);\n    }\n    cout << n - ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,MAX)l[i] = r[i] = area[i] = total[i] = almond[i] = talmond[i] = 0;\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n      assert(inPolygon(poly[M],ps[i]));\n      almond[M]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  //npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 80000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      continue;\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    assert(equals(total[m-1],(double)(h*w)));\n    assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        vector<int> l;\n        vector<int> r;\n        l.push_back(0);\n        r.push_back(0);\n        for(int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            l.push_back(a);\n            r.push_back(b);\n        }\n        vector<double> x;\n        vector<double> y;\n        for(int i = 0; i < n; i++) {\n            double a, b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n        }\n\n        vector<int> area;\n        vector<int> nuts;\n        for(int i = 0; i < m; i++) {\n            area.push_back((l[i+1] - l[i] + r[i+1] - r[i]) * w); \n            nuts.push_back(0);\n        }\n\n        for(int i = 0; i < n; i++) {\n            int j = 0;\n            for(j = 0; j < m; j++) {\n                if( y[i] <= x[i] * ( r[j] - l[j] ) / (w + 0.0) + l[j] ) break;\n            }\n            nuts[j - 1] += 1;\n        }\n\n        vector<int> from_down;\n        vector<int> from_up;\n        vector<int> from_down_nuts;\n        vector<int> from_up_nuts;\n        from_up.push_back(0);\n        from_down.push_back(0);\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down.push_back(area[i - 1] + from_down[i - 1]);\n            from_up.push_back(area[m - i] + from_up[i - 1]);\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = 0;\n            while(from_up[i] + from_down[j] < S) {\n                j++;\n            }\n            if (minnuts > from_up_nuts[i] + from_down_nuts[j]) {\n                minnuts = from_up_nuts[i] + from_down_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n      else assert(false);\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  npoly.push_back(Point(0,0));\n  npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      almond[M]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos--;\n      if(pos < 0)pos++;\n\n      int test = 0;\n      REP(j,pos,m){\n\ttest++;\n\tassert(test<=2);\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\n\nint main(){\n\tint n,m,W,H;\n\tdouble S;\n\twhile(cin >> n >> m >> W >> H >> S && n){\n\t\tvector<double> x(n),y(n);\n\t\tvector< pair<int,int> > ln;\n\t\tvector<int> con;\n\t\tvector<int> idx;\n\t\tvector<int> rr;\n\t\tint prev = 0;\n\t\tvector<double> size(m+10);\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,rev=0;\n\t\t\tcin >> a >> b;\n\t\t\tif( a > b ) swap(a,b) , rev = 1;\n\t\t\t\n\t\t\tsize[i] += ((a-prev) * W + W * (b-a) / 2.0 );\n\t\t\tsize[i+1] += W*(b-a) / 2.0;\n\t\t\tif( prev != a ){\n\t\t\t\tln.push_back(make_pair(prev,a));\t\n\t\t\t\tcon.push_back(0);\n\t\t\t\tidx.push_back(i);\n\t\t\t\trr.push_back(0);\n\t\t\t}\n\t\t\tif( a != b ){\n\t\t\t\tln.push_back(make_pair(a,b));\n\t\t\t\tcon.push_back(1);\n\t\t\t\tidx.push_back(i);\n\t\t\t\trr.push_back(rev);\n\t\t\t}\n\t\t\tprev = b;\n\t\t}\n\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\t//scout << endl;\n\t\tvector<int> have(m+10);\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint id = upper_bound(ln.begin(),ln.end(),make_pair((int)(y[i]+1e-9),0)) - ln.begin() - 1;\n\t\t\tif( con[id] ){\n\t\t\t\tif( rr[id] ){\n\t\t\t\t\tdouble h = ln[id].second - (W-x[i]) * (ln[id].second - ln[id].first) / W;\n\t\t\t\t\tif( y[i] < h ){\n\t\t\t\t\t\thave[idx[id]+1]++;\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\thave[idx[id]]++;\t\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdouble h = ln[id].first + x[i] * (ln[id].second - ln[id].first) / W;\n\t\t\t\t\tif( y[i] < h ){\n\t\t\t\t\t\thave[idx[id]]++;\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\thave[idx[id]+1]++;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\thave[idx[id]]++;\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0 ; i < m ; i++){\n\t\t\tcout << have[i] << \" \" << size[i] << endl;\n\t\t}*/\n\t\tint l = 0;\n\t\tdouble sz = 0;\n\t\tint ans = 0 , get = 0;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tget += have[i];\n\t\t\tsz  += size[i];\n\t\t\twhile( l <= i && W*H-sz < S - 1e-9 ){\n\t\t\t\tget -= have[l];\n\t\t\t\tsz  -= size[l];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\t//cout << l << \" \" << i << \" \" << W*H-sz << \" \" << get << endl;\n\t\t\tif( W*H - sz > S - 1e-9 ) ans = max( ans , get );\n\t\t}\n\t\tcout << n - ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t} else if(inPolygon(poly[L],ps[i])){\n\t  M = L;\n\t  break;\n\t} else if( R < m && inPolygon(poly[R],ps[i])){\n\t  M = R;\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else {\n\tbool found = false;\n\trep(k,10){\n\t  if(L-k >= 0 && inPolygon(poly[L-k],ps[i])){\n\t    almond[L-k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t  if(R+k < m && inPolygon(poly[R+k],ps[i])){\n\t    almond[R+k]++;\n\t    found = true;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\nconst int MAXN = 30000 + 50;\nconst int MAXM = 30000 + 50;\nconst int MAXINT = -1u >> 1;\n\nconst double EPS = 1e-9;\n\nint sgn(const double &x) {return (int)((x > EPS) - (x < -EPS));}\n\nstruct Point {\n    double x,y;\n    Point() {};\n    Point(const double &_x,const double &_y) :\n        x(_x),y(_y) {};\n    Point operator + (const Point &A) const {\n        return Point(x + A.x,y + A.y);\n    }\n    Point operator - (const Point &A) const {\n        return Point(x - A.x,y - A.y);\n    }\n    double operator * (const Point &A) const {\n        return x * A.y - y * A.x;\n    }\n    double operator ^(const Point &A) const {\n        return x * A.x + y * A.y;\n    }\n    void input() {\n        scanf(\"%lf%lf\",&x,&y);\n    }\n}pt[MAXM];\n\nint choc[MAXM];\nvector< pair<Point,Point> > line;\n\nint main() {\n    int N,M;\n    double w,h,S;\n    while(scanf(\"%d%d%lf%lf%lf\",&M,&N,&w,&h,&S) == 5) {\n        if (N == 0 && M == 0) break;\n        line.clear();\n        memset(choc,0,sizeof(choc));\n        line.PB(MP(Point(0.0,0.0),Point(w,0.0)));\n        for(int i = 0 ; i < N ; i++) {\n            double l,r;\n            Point L,R;\n            scanf(\"%lf%lf\",&l,&r);\n            //L.input();\n            //R.input();\n            line.push_back(MP(Point(0,l),Point(w,r)));\n        }\n        //puts(\"INPUTOVER\");\n        for(int i = 0 ; i < M ; i++) {\n            pt[i].input();\n            //printf(\"SZ %d\\n\",SZ(line));\n            int l = 0 , r = SZ(line),mid,ans;\n            while(l <= r) {                \n                mid = (l + r) >> 1;\n                //printf(\"%d %d\\n\",mid,r);\n                if (sgn((pt[i] - line[mid].first) * (line[mid].second - line[mid].first)) > 0) {\n                    //printf(\"AAAAAA\\n\");\n                    ans = mid;\n                    r = mid - 1;\n                }\n                else l = mid + 1;\n            }\n            //printf(\"test %d\\n\",sgn((pt[i] - line[3].first) * (line[3].second - line[3].first)));\n            //printf(\"-- %d %d\\n\",i,ans);\n            choc[ans]++;\n        }\n        //for(int i = 0 ; i < SZ(line) ; i++) {\n            //printf(\"choc[%d] = %d\\n\",i,choc[i]);\n        //}\n        for(int i = 1 ; i < SZ(line) ; i++) {\n            choc[i] += choc[i - 1];\n        }\n        //puts(\"CHOCOVER\");\n        int res = MAXINT;\n        for(int i = 0 ; i < SZ(line) ; i++) {\n            int l = i,r = SZ(line),mid,ans;\n            double area;\n            while(l <= r) {\n                mid = (l + r) >> 1;\n                area = ((line[mid].first.y - line[i].first.y) + (line[mid].second.y - line[i].second.y)) * w / 2.0;\n                if (sgn(w * h - area - S) >= 0) {\n                    ans = mid;\n                    l = mid + 1;\n                }\n                else r = mid - 1;\n            }\n            //printf(\"%d %d\\n\",i,ans);\n            //res = min(res,M - (choc[ans] - (i == 0 ? 0 : choc[i - 1])));\n            res = min(res,M - (choc[ans] - choc[i]));\n        }\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\nconst int maxn = 30000 + 100;\nconst double eps = 1e-8;\ntypedef long long lint;\n\nint sgn(double x) {\n    return (x > eps) - (x < -eps);\n}\nstruct P {\n    double x, y;\n    P() {}\n    P(double _x, double _y): x(_x), y(_y) {}\n    lint cross(const P &a, const P &b) const {\n        return (a.x - x) * (b.y - y) - (a.y - y) * (b.x - x);\n    }\n    void input() {\n        scanf(\"%lf%lf\", &x, &y);\n    }\n};\n\nint n, m, w, h, s;\nint l[maxn], r[maxn];\ndouble area[maxn];\nint cnt[maxn];\n\nint main() {\n    while (scanf(\"%d%d%d%d%d\", &n, &m, &w, &h, &s) == 5 && (n || m || w || h || s)) {\n        for (int i = 1; i <= m; ++i) {\n            scanf(\"%d%d\", &l[i], &r[i]);\n        }\n        l[0] = r[0] = 0;\n        l[m + 1] = r[m + 1] = h;\n        \n        for (int i = 0; i <= m; ++i) {\n            area[i] = double(r[i + 1] - r[i] + l[i + 1] - l[i]) * w / 2;\n            cnt[i] = 0;\n        }\n        for (int i = 0; i < n; ++i) {\n            P pt;\n            pt.input();\n            int low = 0, high = m, res = -1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (sgn(P(0, l[mid]).cross(P(w, r[mid]), pt)) > 0) {\n                    res = mid;\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            if (res == -1) while (1);\n            if (res != -1) ++cnt[res];\n        }\n        //for (int i = 0; i <= m; ++i) printf(\"%lf \", area[i]); printf(\"\\n\");\n        //for (int i = 0; i <= m; ++i) {\n            //if (i == 0) sum[i] = cnt[i];\n            //else sum[i] = sum[i - 1] + cnt[i];\n        //}\n        int ba = 0;\n        double now = 0;\n        int ct = 0;\n        int ans = 0;\n        for (int i = 0; i <= m; ++i) {\n            now += area[i];\n            ct += cnt[i];\n            while (ba <= i && sgn(now - w * h + s) > 0) {\n                now -= area[ba];\n                ct -= cnt[ba];\n                ++ba;\n            }\n            ans = max(ans, ct);\n        }\n        printf(\"%d\\n\", n - ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n\n      cin >> l[i] >> r[i];\n\n      //if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      //if(!(Point(w,r[i]) == p2))\n\tpoly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      //assert(poly[i].size() >= 3);\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n/*\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n*/\n\tbool found = false;\n\trep(k,m){\n\t  //cout << \"k = \" << k << endl;\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t}\n\tassert(found);\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        int l[m+1];\n        int r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        int fromd_area[m+1];\n        int fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        for(int i = 0; i < n; i++) {\n            int j;\n            for(j = 0; j <= lower_bound(l, l+n, y[i]) - l; j++) {\n                if( y[i] <= x[i] * ( r[j] - l[j] ) / (w + 0.0) + l[j] ) break;\n            }\n            nuts[j - 1] += 1;\n        }\n\n        deque<int> from_down_nuts;\n        deque<int> from_up_nuts;\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            if (nuts[i] == 0) continue;\n            int j = lower_bound(fromu_area, fromu_area + m, S - fromd_area[i]) - fromu_area;\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n            if (from_down_nuts[i] > minnuts)    break;\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-8;\nconst double inf =1e99;\ndouble sqr(double x){\n\treturn x*x;\n}\nint sgn(double x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double _x,double _y):x(_x),y(_y){}\n\tbool operator==(const Point &p)const{\n\t\treturn (sgn(p.x-x)==0&&sgn(p.y-y)==0);\n\t}\n\tbool operator<(const Point &p)const{\n\t\treturn y+eps<p.y||(y<p.y+eps&&x+eps<p.x);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn x*p.y-y*p.x;\n\t}\n\tdouble operator/(const Point &p)const{//轤ケ遘ッ \n\t\treturn x*p.x+y*p.y;\n\t}\n\tPoint operator-(const Point &p)const{\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tPoint operator+(const Point &p)const{\n\t\treturn Point(x+p.x,y+p.y);\n\t}\n\tPoint operator*(const double &k)const{\n\t\treturn Point(x*k,y*k);\n\t}\n\tPoint operator/(const double &k)const{\n\t\treturn Point(x/k,y/k);\n\t}\n\tvoid input(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)\\n\",x,y);\n\t}\n};\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point _a,Point _b):a(_a),b(_b){}\n\tLine(double _x1,double _y1,double _x2,double _y2){\n\t\ta=Point(_x1,_y1),b=Point(_x2,_y2);\n\t}\n\tdouble operator*(const Point &p)const{\n\t\treturn (b-a)*(p-a);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)-(%.3f %.3f)\\n\",a.x,a.y,b.x,b.y);\n\t}\n\tint Direction(const Point &p)const{  //蟾ヲ1?悟承-1?檎コソ荳? \n\t\treturn sgn((*this)*p);\n\t}\n};\ndouble lp[32000],rp[32000];\nPoint pt[32000];\nint sz[32000];\ndouble area[32000],sp[32000];\nint st[32000];\nLine ls[32000];\nint main(){\n\tint n,m;\n\tdouble w,h,s;\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s)){\n\t\tif(n==0&&m==0&&sgn(w)==0&&sgn(h)==0&&sgn(s)==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&lp[i],&rp[i]);\n\t\t}\n\t\tsort(lp,lp+n),sort(rp,rp+n);\n\t\tfor(int i=0;i<m;i++) pt[i].input();\n\t\tif(sgn(s-w*h)<0) while(1);\n\t\tmemset(sz,0,sizeof(sz));\n\t\tint cnt=0;\n\t//\tprintf(\"&&&&&%f %f\\n\",lp[n-1],rp[n-1]);\n\t\tif(sgn(h-lp[n-1])||sgn(h-rp[n-1]))\n\t\tls[cnt++]=Line(Point(0,h),Point(w,h));\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tls[cnt++]=Line(Point(0,lp[i]),Point(w,rp[i]));\n\t\t}\n\t\tls[cnt++]=Line(Point(0,0),Point(w,0));\n\t//\tprintf(\"~~~%d\\n\",cnt);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint l=0,r=cnt-1,md,res=-1;\n\t\t\twhile(l<=r){\n\t\t\t\tmd=(l+r)>>1;\n\t\t\t\tif(ls[md].Direction(pt[i])==-1) {\n\t\t\t\t\tl=md+1;\n\t\t\t\t\tres=md;\n\t\t\t\t} else r=md-1;\n\t\t\t}\n\t\t\tsz[res]++;\n\t\t}\n\t\tdouble pl=h,pr=h;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i==n) {\n\t\t\t\tarea[i]=(fabs(pl)+fabs(pr))*w*0.5;\n\t\t\t} else {\n\t\t\t\tarea[i]=(fabs(lp[n-i-1]-pl)+fabs(rp[n-i-1]-pr))*w*0.5;\n\t\t\t\tpl=lp[n-i-1],pr=rp[n-i-1];\n\t\t\t}\n\t\t}\n\t\t//for(int i=0;i<=n;i++) printf(\"%d\\n\",sz[i]);\n\t\tsp[n]=area[n];st[n]=sz[n];\n\t\tsz[n+1]=0;\n\t\tsp[n+1]=0;\n\t\tfor(int i=n-1;i>=0;i--) sp[i]=area[i]+sp[i+1],st[i]=sz[i]+st[i+1];\n\t\tint mi=m,rb=0,has=0;\n\t\t\n\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\tif(sgn(sp[rb]-s)>=0)\n\t\tmi=min(mi,st[rb]);\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\ts-=area[i];\n\t\t\thas+=sz[i];\n\t\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\t\tif(sgn(sp[rb]-s)>=0)\n\t\t\tmi=min(has+st[rb],mi);\n\t\t}\n\t\tprintf(\"-------------------------------%d\\n\",mi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\nbool equals(double a, double b) { return abs(a-b) < eps; }\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(!equals(a.real(),b.real())) return a.real() < b.real();\n    if(!equals(a.imag(),b.imag())) return a.imag() < b.imag();\n    return false;\n  }\n}\n\nstruct L : public vector<P> {\n  L(P a, P b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\ndouble dot(P a, P b)   { return a.real()*b.real()+a.imag()*b.imag(); }\ndouble cross(P a, P b) { return a.real()*b.imag()-a.imag()*b.real(); }\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\n//----------------------------------------\n\n\nconst int MAX_M = 30010;\n\nint N, M, W, H, S;\nvector<P> Ps;\nvector<L> Ls;\nint num[MAX_M];\ndouble A[MAX_M];\n\nint search(P p) {\n  int l, r, ans;\n  l = 0, r = M, ans = -1;\n  while(l < r) {\n    int m = (l+r)/2;\n    if(ccw(Ls[m][0],Ls[m][1],p) == 1) {\n      l = m+1;\n      ans = m;\n    } else {\n      r = m;\n      ans = m-1;\n    }\n  }\n  return ans+1;\n}\n\nvoid calcArea() {\n  A[0] = 0;\n  for(int i = 0; i+1 < Ls.size(); ++i) {\n    double a = Ls[i+1][0].imag() - Ls[i][0].imag();\n    double b = Ls[i+1][1].imag() - Ls[i][1].imag();\n    A[i+1] = A[i] + (a+b)*W/2.0;\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> W >> H >> S && (N|M|W|H|S)) {\n    Ps.clear();\n    Ls.clear();\n    Ls.push_back(L(P(0,0),P(W,0)));\n    for(int i = 0; i < M; ++i) {\n      double l, r;\n      cin >> l >> r;\n      Ls.push_back(L(P(0,l),P(W,r)));\n    }\n\n    for(int i = 0; i < N; ++i) {\n      P p;\n      cin >> p.real() >> p.imag();\n      Ps.push_back(p);\n    }\n\n    fill(num,num+MAX_M,0);\n    for(int i = 0; i < Ps.size(); ++i)\n      ++num[search(Ps[i])];\n    for(int i = 1; i <= M; ++i) num[i] += num[i-1];\n\n    calcArea();\n\n    int T = W*H-S;\n    int ans = 0;\n    for(int i = 0, j = 1; i <= M && j <= M; ++i) {\n      while(j <= M && A[j]-A[i] < T+eps) ++j;\n      ans = max(ans,num[j-1]-num[i]);\n    }\n    cout << N-ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct Point\n{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y)\n    {\n        x = _x;\n        y = _y;\n    }\n    Point operator -(const Point& b)const\n    {\n        return Point(x-b.x,y-b.y);\n    }\n    double operator *(const Point& b)const\n    {\n        return x*b.y-y*b.x;\n    }\n};\n\nPoint pl[30000],pr[30000];\nint cnt[30000];\nint n,m,w,h,s;\n\nint calc(int a)\n{\n    if (a < 0)  return 0;\n    return ((pl[a].y+pr[a].y)*w);\n}\n\nint main()\n{\n    while (scanf(\"%d\",&n),n)\n    {\n        scanf(\"%d%d%d%d\",&m,&w,&h,&s);\n        for (int i = 0;i < m;i++)\n        {\n            scanf(\"%lf%lf\",&pl[i].y,&pr[i].y);\n            pl[i].x = 0;\n            pr[i].x = w;\n            cnt[i] = 0;\n        }\n        for (int i = 0;i < n;i++)\n        {\n            Point p;\n            scanf(\"%lf%lf\",&p.x,&p.y);\n            int l,r,mid;\n            l = 0,r = m-1;\n            while (l < r)\n            {\n                mid = l+r>>1;\n                if ((p-pl[mid])*(pr[mid]-pl[mid]) > 0)\n                    r = mid;\n                else\n                    l = mid+1;\n            }\n            cnt[l]++;\n            //printf(\"l = %d\\n\",l);\n        }\n        int pre = -1,res = 0,tot = 0;\n        for (int i = 0;i < m;i++)\n        {\n            tot += cnt[i];\n            while (calc(i)-calc(pre) > (w*h-s)*2)\n            {\n                tot -= cnt[pre+1];\n                pre++;\n            }\n            //printf(\"%d %d %d\\n\",i,pre,tot);\n            res = max(res,tot);\n        }\n        printf(\"%d\\n\",n-res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n  arm[m+1]=n;\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  assert(n-res>=0);\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n      else if(L-1>=0 && inPolygon(poly[L-1],ps[i]))almond[L-1]++;\n      else if(R+1<m && inPolygon(poly[R+1],ps[i]))almond[R+1]++;\n      else assert(false);\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        vector<int> l;\n        vector<int> r;\n        l.push_back(0);\n        r.push_back(0);\n        for(int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            l.push_back(a);\n            r.push_back(b);\n        }\n        vector<double> x;\n        vector<double> y;\n        for(int i = 0; i < n; i++) {\n            double a, b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n        }\n\n        vector<int> area;\n        vector<int> nuts;\n        for(int i = 0; i < m; i++) {\n            area.push_back((l[i+1] - l[i] + r[i+1] - r[i]) * w); \n            nuts.push_back(0);\n        }\n\n        for(int i = 0; i < n; i++) {\n            int j = 0;\n            for(j = 0; j < m; j++) {\n                if( y[i] <= x[i] * ( r[j] - l[j] ) / (w + 0.0) + l[j] ) break;\n            }\n            nuts[j - 1] += 1;\n        }\n\n        vector<int> from_down;\n        vector<int> from_up;\n        vector<int> from_down_nuts;\n        vector<int> from_up_nuts;\n        from_up.push_back(0);\n        from_down.push_back(0);\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down.push_back(area[i - 1] + from_down[i - 1]);\n            from_up.push_back(area[m - i] + from_up[i - 1]);\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = distance(from_up.begin(), lower_bound(from_up.begin(), from_up.end(), S - from_down[i]));\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint l[31000];\nint r[31000];\ndouble x[31000];\ndouble y[31000];\nint h[31000];\nint s[31000];\nint sum[31000];\nint hsum[31000];\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d\",l+i,r+i);\n\t\t}\n\t\tfor(int i=0;i<b;i++)h[i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(i)s[i]=(l[i]+r[i]-l[i-1]-r[i-1])*c;\n\t\t\telse s[i]=(l[0]+r[0])*c;\n\t\t}\n\t\tsum[0]=s[0];\n\t\tfor(int i=1;i<b;i++){\n\t\t\tsum[i]=sum[i-1]+s[i];\n\t\t}\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\te*=2;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint L=0;\n\t\t\tint R=b;\n\t\t\twhile(L+1<R){\n\t\t\t\tint M=(L+R)/2;\n\t\t\t\tdouble at=(double)l[M-1]+(double)(r[M-1]-l[M-1])/c*x[i];\n\t\t\t\tif(at>y[i])R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\th[L]++;\n\t\t}\n\t\tfor(int i=0;i<=b;i++)hsum[i]=0;\n\t\tfor(int i=0;i<b;i++)hsum[i+1]=hsum[i]+h[i];\n\t\tint ret=999999999;\n\t\tint now=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(c*d*2-now<e)break;\n\t\t\tint to=upper_bound(sum,sum+b,now+c*d*2-e)-sum;\n\t\t\tret=min(ret,a-(hsum[to]-hsum[i]));\n\t\t\tnow+=s[i];\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  assert( 3 <= npoly.size() && npoly.size() <= 4);\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\tif(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M + 1;\n\t}\n      }\n      assert( 0 <= M && M < m );\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R < m && inPolygon(poly[R],ps[i]))almond[R]++;\n      else if(L-1>=0 && inPolygon(poly[L-1],ps[i]))almond[L-1]++;\n      else if(R+1<m && inPolygon(poly[R+1],ps[i]))almond[R+1]++;\n      else if(L-2>=0 && inPolygon(poly[L-2],ps[i]))almond[L-2]++;\n      else if(R+2<m && inPolygon(poly[R+2],ps[i]))almond[R+2]++;\n      else if(L-3>=0 && inPolygon(poly[L-3],ps[i]))almond[L-3]++;\n      else if(R+3<m && inPolygon(poly[R+3],ps[i]))almond[R+3]++;\n      else if(L-4>=0 && inPolygon(poly[L-4],ps[i]))almond[L-4]++;\n      else if(R+4<m && inPolygon(poly[R+4],ps[i]))almond[R+4]++;\n\n      \n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint main(){\n    while(1){\n        int n,m,w,h,s;\n        cin >> n >> m >> w >> h >> s;\n        if(n==0) break;\n\n        vector<double> l(m+1, 0), r(m+1, 0);\n        for(int i=1; i<=m; i++){\n            cin >> l[i] >> r[i];\n        }\n        VP p(n);\n        for(int i=0; i<n; i++){\n            double x,y;\n            cin >> x >> y;\n            p[i] = P(x, y);\n        }\n\n        vector<double> area(m+1, 0);\n        for(int i=1; i<=m; i++){\n            VP poly = {P(0, l[i-1]), P(w, r[i-1]), P(w, r[i]), P(0, l[i])};\n            area[i] = getarea(poly);\n            area[i] += area[i-1];\n        }\n        vector<int> num(m+1, 0);\n        for(int i=0; i<n; i++){\n            int ub=m, lb=0;\n            while(lb +1 < ub){\n                int mid = (lb +ub)/2;\n                if(ccw(P(0, l[mid]), P(w, r[mid]), p[i]) == 1){\n                    lb = mid;\n                }else{\n                    ub = mid;\n                }\n            }\n            num[ub]++;\n        }\n        for(int i=0; i<m; i++){\n            num[i+1] += num[i];\n        }\n\n        int ans = 1e9;\n        for(int i=0; i<m; i++){\n            if(area[i] +EPS >= s){\n                ans = min(ans, num[i]);\n                break;\n            }\n            int lb=i, ub=m;\n            while(lb +1 < ub){\n                int mid = (lb +ub)/2;\n                if(h*w -(area[mid] -area[i]) +EPS > s){\n                    lb = mid;\n                }else{\n                    ub = mid;\n                }\n            }\n            ans = min(ans, n-(num[lb] -num[i]));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nint arm[30001];\n \nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=conj(b); \n   return (c.y>0);\n}\n \nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i])) up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n \nint solve(){\n  int res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=((L[mid][0].y-L[i][0].y)+(L[mid][1].y-L[i][1].y))*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    L[0][0]=point(0,0);\n    L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n \n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n/*\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n*/\n\tbool found = false;\n\trep(k,m){\n\t  if(inPolygon(poly[k],ps[i])){\n\t    found = true;\n\t    almond[k]++;\n\t    break;\n\t  }\n\t  /*\n\t}\n\t  */\n\tassert(found);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//import java.util.Scanner;\nimport java.io.*;\n\nclass Rmq{\n    int segt[] = new int[(1<<21)*2];\n    public int inp[] =new int[(1<<21)];\n    int MAX_VALUE=2147483647;\n    int min(int a,int b){return a<b?a:b;}\n    int max(int a,int b){return a>b?a:b;}\n    void update(int value,int pos,int n){\n\tint index=n-1+pos;\n\tsegt[index]=value;//[pos,pos]\n\twhile(index>0){\n\t    index=(index-1)/2;\n\t    segt[index]=min(segt[index*2+1],segt[index*2+2]);\n\t}\n    }\n    int query(int l,int r,int now,int ql,int qr){\n\tif (l == ql && r == qr){\n\t    return segt[now];\n\t}\n\tint midr=(l+r)/2,midl=midr+1;\n\tint ret=MAX_VALUE;\n\tif (ql <= midr)ret=min(ret,query(l,midr,now*2+1,ql,min(qr,midr)));\n\tif (midl <= qr)ret=min(ret,query(midl,r,now*2+2,max(midl,ql),qr));\n\treturn ret;\n    }\n\n    public void init(int r,int c,int lim){\n\tboolean isrowmajor=r<=c;\n\tfor(int i=0;i<lim;i++){\n\t    segt[i]=MAX_VALUE;\n\t}\n\tif (isrowmajor){\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i*c+j],i*c+j,lim);\n\t\t}\n\t    }\n\t}else {\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i+j*r],i+j*r,lim);\n\t\t}\n\t    }\n\t}\n    }\n    int searchmin(int r1,int c1,int r2,int c2,int r,int c,int lim){\n\tboolean isrowmajor = r<=c;  \n\tint ret=MAX_VALUE;\n\tlim--;\n\tif (isrowmajor){\n\t    for(int i=r1;i<=r2;i++){\n\t\tret=min(ret,query(0,lim,0,i*c+c1,i*c+c2));\n\t    }\n\t}else {\n\t    for(int j=c1;j<=c2;j++){\n\t\tret=min(ret,query(0,lim,0,j*r+r1,j*r+r2));\n\t    }\n\t}\n\treturn ret;\n    }    \n\n}\n\nclass Main{\n    void run(){\n\tScanner in = new Scanner();\n\t//System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\tint r,c,q;\n\tRmq rmq=new Rmq();\n\twhile(true){\n\t    r=in.nextInt();\n\t    c=in.nextInt();\n\t    q=in.nextInt();\n\t    if (r == 0)break;\n\t    int lim=1;\n\t    boolean isrowmajor = r<=c;\n\t    while(true){\n\t\tif (lim >= r*c)break;\n\t\tlim*=2;\n\t    }\n\t    if (isrowmajor){\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i*c+j]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }else {\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i+j*r]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }\n\t    rmq.init(r,c,lim);\n\t    for(int i=0;i<q;i++){\n\t\tint r1,r2,c1,c2;\n\t\tr1=in.nextInt();\n\t\tc1=in.nextInt();\n\t\tr2=in.nextInt();\n\t\tc2=in.nextInt();\n\t\tSystem.out.println(rmq.searchmin(r1,c1,r2,c2,r,c,lim));\n\t    }\n\t}\n    }\n    public static void main(String args[]){\n\tMain a = new Main();\n\ta.run();\n    }\n}\n\n\nclass Scanner {\n    int nextInt() {\n        try {\n            int c = System.in.read();\n            if (c == -1)\n                return c;\n            while (c != '-' && (c < '0' || '9' < c)) {\n                c = System.in.read();\n                if (c == -1)\n                    return c;\n            }\n            if (c == '-')\n                return -nextInt();\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    long nextLong() {\n        try {\n            int c = System.in.read();\n            if(c==-1)return -1;\n            while (c != '-' && (c < '0' || '9' < c)){\n                c = System.in.read();\n                if(c==-1)return -1;\n            }\n            if (c == '-')\n                return -nextLong();\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n    String next() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (Character.isWhitespace(c))\n                c = System.in.read();\n            do {\n                res.append((char) c);\n            } while (!Character.isWhitespace(c = System.in.read()));\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n \n    String nextLine() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (c == '\\r' || c == '\\n')\n                c = System.in.read();\n            do {\n                res.append((char) c);\n                c = System.in.read();\n            } while (c != '\\r' && c != '\\n');\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double EPS = 1e-8; \ndouble dot(P a, P b){return real(conj(a)*b);}\ndouble cross(P a, P b){return imag(conj(a)*b);}\n/*\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n}\n*/\nint contains(vector<P> v, P p){ \n  bool in = false; \n  for(int i=0;i<v.size();i++){ \n    P a = v[i] - p; \n    P b = v[(i+1)%v.size()] - p; \n    if(imag(a) > imag(b)) swap(a,b); \n    if((imag(a) <= 0 || fabs(imag(a))<EPS) && EPS < imag(b)) \n      if(cross(a,b) < -EPS) in = !in; \n    if(fabs(cross(a,b))<EPS && dot(a,b) < EPS) return 1;\n  } \n  return in ? 2 : 0; \n} \n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint main() {\n  int n,m,w,h,s;\n  while(cin >> n >> m >> w >> h >> s && n) {\n    P a[m];\n    int d[m+1];\n    double d2[m+1];\n    d2[0]=0;\n    memset(d,0,sizeof(d));\n    for(int i=0; i<m; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n      vector<P> v(4);\n      v[0]=P(0,0);\n      v[1]=P(w,0);\n      v[2]=P(w,a[i].imag());\n      v[3]=P(0,a[i].real());\n      d2[i+1]=area(v);\n    }\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      P p=P(x,y);\n      int l=0,r=m;\n      while(l+1!=r) {\n        int k=(l+r)/2;\n        vector<P> v(4);\n        v[0]=P(0,0);\n        v[1]=P(w,0);\n        v[2]=P(w,a[k].imag());\n        v[3]=P(0,a[k].real());\n        if(contains(v,p)<2) l=k;\n        else r=k;\n      }\n      d[l+1]++;\n    }\n    for(int i=0; i<m; i++) d[i+1]+=d[i];\n    int l=0,ans=1<<29;\n    for(int r=0; r<=m; r++) {\n      while(l<r&&d2[m]-d2[r]+d2[l]<s) l++;\n      int x=l?d[l-1]:0;\n      int y=r?d[r-1]:0;\n      if(d2[m]-d2[r]+d2[l]>=s) ans=min(ans,d[m]-y+x);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint bs(double x, double y, int l[], int r[], int w, int m) {\n\n    int lower = 0;\n    int upper = m + 1;\n\n    while( true ) {\n        int t = (lower + upper) / 2;\n\n        if ( y < x * (r[t] - l[t]) / (w + 0.0) + l[t] ) {\n            if ( y > x * (r[t-1] - l[t-1]) / (w + 0.0) + l[t-1] ) {\n                return t - 1;\n            } else {\n                upper = t;     \n            }\n        } else {\n            lower = t;\n        }\n    }\n}\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        int l[m+1];\n        int r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        int fromd_area[m+1];\n        int fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        for(int i = 0; i < n; i++) {\n            nuts[bs(x[i], y[i], l, r, w, m)] += 1;\n        }\n\n        deque<int> from_down_nuts;\n        deque<int> from_up_nuts;\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            if (nuts[i] == 0) continue;\n            int j = lower_bound(fromu_area, fromu_area + m, S - fromd_area[i]) - fromu_area;\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n            if (from_down_nuts[i] > minnuts)    break;\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n  \nvoid getnum(const int l, const int r, const vector<pair<ld, ld>>&armonds, const vector<pair<ld, ld>>&lines,vector<pair<int,ld>>&areas) {\n\tif (l + 1 == r) {\n\t\tareas[l].first = armonds.size();\n\t}\n\telse {\n\t\tint m = (l + r) / 2;\n\t\tpair<ld, ld>line(lines[m]);\n\t\tvector<pair<ld, ld>>larmonds, rarmonds;\n\t\tfor (auto armond : armonds) {\n\t\t\tld ay = line.first + line.second*armond.first;\n\t\t\tif (ay > armond.second) {\n\t\t\t\tlarmonds.emplace_back(armond);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trarmonds.emplace_back(armond);\n\t\t\t}\n\t\t}\n\t\tgetnum(l, m, larmonds, lines, areas);\n\t\tgetnum(m, r, rarmonds, lines, areas);\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M, W, H, S; cin >> N >> M >> W >> H >> S;\n\t\tif (!N)break;\n\t\tvector<pair<ld, ld>>lines;\n\t\tlines.emplace_back(0, 0);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tld l, r; cin >> l >> r;\n\t\t\tlines.emplace_back(l, (r - l) / W);\n\t\t}\n\t\tvector<pair<ld, ld>>armonds;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tarmonds.emplace_back(x, y);\n\t\t}\n\t\tvector<pair<int, ld>>areas(M);\n\t\t{\n\t\t\tld asum = 0;\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tld sum= (2 * lines[i + 1].first + W*lines[i + 1].second)*W / 2;\n\t\t\t\tareas[i].second = sum - asum;\n\t\t\t\tasum = sum;\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tgetnum(0, M, armonds, lines, areas);\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tld needarea = W*H - S + eps;\n\t\tld sum = 0;\n\t\tint num = 0;\n\t\tint ans = 0;\n\t\tbool flag = true;\n\t\twhile (1) {\n\t\t\twhile (sum < needarea) {\n\t\t\t\tans = max(ans, num);\n\t\t\t\tif (r == M) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum += areas[r].second;\n\t\t\t\t\tnum += areas[r].first;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif (!flag)break;\n\t\t\twhile (sum > needarea) {\n\t\t\t\tsum -= areas[l].second;\n\t\t\t\tnum -= areas[l].first;\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tcout << N-ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 30100\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 80000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\ndouble dot(P a,P b ){ return a.real()*a.imag() + b.real()*b.imag(); }\ndouble cross(P a,P b){ return a.real()*b.imag() - a.imag()*b.real(); }\n\nconst double eps = 1e-10;\nint ccw( P p, P a, P b ){\n  a -= p;\n  b -= p;\n  if( cross( a, b ) > eps ) return 1; //ue\n  if( cross( a, b ) < -eps ) return -1; //shita\n  if( dot( a, b ) < -eps ) return 2;\n  if( norm(b) - norm(a) > eps ) return -2;\n  return 0;\n}\n\n\nint N,M,W,H,S;\n\n\nint get(P p,const vector<L> &vec){\n  int st = 0, ed = vec.size()-1; // [st,ed]\n  int res=1e9;\n  //  cout << p << endl;\n  while( st<ed  ){\n    int h = (st+ed)/2;\n    //    cout << st << \" \" << ed <<\" \"<< h << \" \" << ccw( vec[h].first, vec[h].second, p ) << endl;\n\n    if( ccw( vec[h].first, vec[h].second, p ) == 1 ){\n      st = h+1;\n\n    } else {\n      ed = h;\n    }\n  }\n\n  res=st;\n  /*\n  cout<<p<<endl;\n\n  for(int i=0;i<vec.size();i++){\n    cout<<vec[i].first<<' '<<vec[i].second<<endl;\n  }\n  cout<<res<<endl;\n  cout<<endl;\n  */\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M>> W >> H >> S && (N|M|W|H|S) ){\n    vector<L> vec; \n\n    vector<double> area;\n    double pl = 0, pr = 0;\n    for(int i=0;i<M;i++){\n      int l,r; cin >> l >> r;\n      area.push_back( ( l - pl + r - pr ) * W / 2.0 );\n      vec.push_back( L(P(0,l),P(W,r)) );\n      pl = l; pr = r;\n    }\n    \n    vector<int> A;\n    A.resize(M,0);\n    for(int i=0;i<N;i++){\n      double x,y; cin >> x >> y;\n      //      cout << P(x,y) << \" \" << get(P(x,y),vec) << endl;\n      A[get(P(x,y),vec)]++;\n    }\n \n    double L = W*H - S;\n    int mt = 0;\n    double sum = 0.0;\n    int anum = 0;\n    int res = N;\n    for(int i=0;i<M;i++){\n      sum += area[i];\n      anum += A[i];\n      while( sum > L+eps ){\n        anum -= A[mt];\n        sum -= area[mt++];\n      }\n      //cout << area[i] << \" \"<<A[i] << \" \" << sum << \" \"<< anum << endl;\n      res = min( res, N-anum );\n    }\n    cout  << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 進行方向\n// 与えられた三点 a, b, c を a → b → c と進むとき，\n// a → b で時計方向に折れて b → c\n// a → b で半時計方向に折れて b → c\n// a → b で逆を向いて a を通り越して b → c\n// a → b でそのまま b → c\n// a → b で逆を向いて b → c ( または b == c )\nint ccw(P a, P b, P c) {\n b -= a; c -= a;\n if (cross(b, c) > 0)   return +1;       // counter clockwise\n if (cross(b, c) < 0)   return -1;       // clockwise\n if (dot(b, c) < 0)     return +2;       // c--a--b on line\n if (norm(b) < norm(c)) return -2;       // a--b--c on line\n return 0;                               // a--c--b on line\n}\n\nint main(){\n\tint n,m,w,h,s;\n\twhile(cin>>n>>m>>w>>h>>s,n|m|w|h|s){\n\t\tvi l(m),r(m);\n\t\tREP(i,m){\n\t\t\tcin>>l[i]>>r[i];\n\t\t}\n\t\tvector<double> x(n),y(n);\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i];\n\t\t}\n\n\t\tvi almond(m);\n\t\tREP(i,n){\n\t\t\tint lb=-1,ub=m;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint mid=(lb+ub)/2;\n\t\t\t\tif(ccw(P(0,l[mid]),P(w,r[mid]),P(x[i],y[i]))!=1){\n\t\t\t\t\tub=mid;\n\t\t\t\t}else{\n\t\t\t\t\tlb=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\talmond[ub]++;\n\t\t}\n\t\tvi total_almond(m+1);\n\t\tREP(i,m){\n\t\t\ttotal_almond[i+1]=total_almond[i]+almond[i];\n\t\t}\n\n\t\tvi total_area(m+1);\n\t\tREP(i,m){\n\t\t\ttotal_area[i+1]=(l[i]+r[i])*w/2;\n\t\t}\n\n\t\tint ans_almond=INT_MAX;\n\t\tREP(i,m){\n\t\t\tint lb=i-1,ub=m;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint mid=(lb+ub)/2;\n\t\t\t\tif(total_area[mid+1]-total_area[i]>total_area[m]-s){\n\t\t\t\t\tub=mid;\n\t\t\t\t}else{\n\t\t\t\t\tlb=mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans_almond=min(ans_almond,total_almond[m]-(total_almond[ub]-total_almond[i]));\n\t\t}\n\t\tcout<<ans_almond<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 30010\nusing namespace std;\n\tdouble ar[MAX],erea[MAX],l[MAX],r[MAX],x[MAX],y[MAX],w,h,S;\nint main(){\n\tint n,m ;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<=m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(y[i]<(r[j]-l[j])*(x[i])/w+l[j]){\n\t\t\t\tar[j-1]++;\n\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n#define sz(v) v.size()\n#define mk(x, y) make_pair(x, y)\n#define fst first\n#define scd second\n#define MEMSET(x, n) memset(x, n, sizeof(x))\n#define MEMZERO(x) MEMSET(x, 0)\n#define URU(y) (!(y % 4) && y % 100 || !(y % 400))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nstruct Line\n{\n\tdouble l;\n\tdouble r;\n\tint num;\n};\n\ndouble cross_product( float x1, float y1, float x2, float y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\nbool inRange( Line l, Line h, double x, double y, double w )\n{\n\tdouble v1, v2;\n\t\n\tv1 = cross_product(w, (l.r - l.l), x, (y - l.l));\n\tv2 = cross_product(w, (h.r - h.l), x, (y - h.l));\n\t\n\tif ((0 < v1 && 0 < v2) || (0 > v1 && 0 > v2))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nint main( void )\n{\n\tint n, m, w, h, S;\n\tLine T[30010];\n\t\n\twhile ( cin >> n >> m >> w >> h >> S, n | m | w | h | S )\n\t{\n\t\tMEMZERO(T);\n\t\t\n\t\trep2 (i, 1, (m + 1))\n\t\t{\n\t\t\tcin >> T[i].l >> T[i].r;\n\t\t}\n\t\t\n\t\trep (i, n)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\trep2 (j, 1, (m + 1))\n\t\t\t{\n\t\t\t\tif (inRange(T[j-1], T[j], x, y, (double)w))\n\t\t\t\t{\n\t\t\t\t\t++T[j].num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = n, sum = 0;\n\t\t\n\t\trep (i, (m + 1))\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif ((S * 2) <= ((T[i].l + T[i].r) * w))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout << ans << endl;\n\t\t\n\t\tsum = 0;\n\t\trepm (i, m, 0)\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tif((S * 2) <= ((2 * h - (T[i-1].l + T[i-1].r)) * w))\n\t\t\t{\n\t\t\t\tans = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout << ans << endl;\n\t\t\n\t\tsum = 0;\n\t\trep2 (i, 1, m)\n\t\t{\n\t\t\tsum += T[i].num;\n\t\t\tif (ans <= sum)\n\t\t\t\tbreak;\n\t\t\tint ss = (T[i].l + T[i].r) * w;\n\t\t\tint sub_sum = 0;\n\t\t\trepm (j, m, (i + 1))\n\t\t\t{\n\t\t\t\tsub_sum += T[j].num;\n\t\t\t\tif (ans <= (sum + sub_sum))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((S * 2) <= (((2 * h - (T[j-1].l + T[j-1].r)) * w) + ss))\n\t\t\t\t{\n\t\t\t\t\tans = sum + sub_sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    assert(i!=low);\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        deque<int> l;\n        deque<int> r;\n        l.push_back(0);\n        r.push_back(0);\n        for(int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            l.push_back(a);\n            r.push_back(b);\n        }\n        vector<double> x;\n        vector<double> y;\n        for(int i = 0; i < n; i++) {\n            double a, b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n        }\n\n        vector<int> area;\n        vector<int> nuts;\n        for(int i = 0; i < m; i++) {\n            area.push_back((l[i+1] - l[i] + r[i+1] - r[i]) * w); \n            nuts.push_back(0);\n        }\n\n        for(int i = 0; i < n; i++) {\n            int j1 = distance( l.begin(), lower_bound(l.begin(), l.end(), y[i] ));\n            int j;\n            for(j = 0; j < j1; j++) {\n                if( y[i] <= x[i] * ( r[j] - l[j] ) / (w + 0.0) + l[j] ) break;\n            }\n            nuts[j - 1] += 1;\n        }\n\n        deque<int> from_down;\n        deque<int> from_up;\n        deque<int> from_down_nuts;\n        deque<int> from_up_nuts;\n        from_up.push_back(0);\n        from_down.push_back(0);\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down.push_back(area[i - 1] + from_down[i - 1]);\n            from_up.push_back(area[m - i] + from_up[i - 1]);\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            if (nuts[i] == 0) continue;\n            int j = distance(from_up.begin(), lower_bound(from_up.begin(), from_up.end(), S - from_down[i]));\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        vector<int> l;\n        vector<int> r;\n        l.push_back(0);\n        r.push_back(0);\n        for(int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            l.push_back(a);\n            r.push_back(b);\n        }\n        vector<double> x;\n        vector<double> y;\n        for(int i = 0; i < n; i++) {\n            double a, b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n        }\n\n        vector<int> area;\n        vector<int> nuts;\n        for(int i = 0; i < m; i++) {\n            area.push_back((l[i+1] - l[i] + r[i+1] - r[i]) * w); \n            nuts.push_back(0);\n        }\n\n        for(int i = 0; i < n; i++) {\n            int j1 = distance( l.begin(), lower_bound(l.begin(), l.end(), y[i] ));\n            int j;\n            for(j = 0; j < j1; j++) {\n                if( y[i] <= x[i] * ( r[j] - l[j] ) / (w + 0.0) + l[j] ) break;\n            }\n            nuts[j - 1] += 1;\n        }\n\n        vector<int> from_down;\n        vector<int> from_up;\n        vector<int> from_down_nuts;\n        vector<int> from_up_nuts;\n        from_up.push_back(0);\n        from_down.push_back(0);\n        from_up_nuts.push_back(0);\n        from_down_nuts.push_back(0);\n        for(int i = 1; i <= m; i++) {\n            from_down.push_back(area[i - 1] + from_down[i - 1]);\n            from_up.push_back(area[m - i] + from_up[i - 1]);\n            from_down_nuts.push_back(nuts[i - 1] + from_down_nuts[i - 1]);\n            from_up_nuts.push_back(nuts[m - i] + from_up_nuts[i - 1]);\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = distance(from_up.begin(), lower_bound(from_up.begin(), from_up.end(), S - from_down[i]));\n            if (minnuts > from_down_nuts[i] + from_up_nuts[j]) {\n                minnuts = from_down_nuts[i] + from_up_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n    if(false){\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    if(false){\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n  arm[m+1]=n;\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define MAX 30010\n#define EPS 0.0000000001\nusing namespace std;\ntypedef pair<double,double> P;\n\tdouble ar[MAX],erea[MAX],w,h,S;\n\tvector<double> l(MAX),r(MAX);\n\tvector<P> iti(MAX);\nint main(){\n\tint n,m ;\n\twhile(cin>>n>>m>>w>>h>>S,n){\n\t\tfor(int i=1;i<=m;i++)\n\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\titi[i] = P(y,x);\n\t\t}\n\t\tsort(iti.begin(),iti.begin() + m);\n\t\tl[0]=0;r[0]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\terea[i]=(r[i+1]-r[i]+l[i+1]-l[i])*w/2;\n\t\tfor(int i=0;i<m;i++)\n\t\tar[i]=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint j1 = lower_bound(l.begin(), l.begin() + m, iti[i].first) - l.begin();\n\t\t\tint j2 = lower_bound(r.begin(), r.begin() + m, iti[i].first) - r.begin();\n\t\t\tint minj = max(0, min(j1-1, j2-1));\n\t\t\tfor(int j=minj;j<=m;j++){\n\t\t\t\n\t\t\t\tif(iti[i].first<(r[j]-l[j])*(iti[i].second)/w+l[j]) {\n\t\t\t\t\tar[j-1]++;\n\t\t\t\t\t//cout<<\"   \"<<j-1<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=40000;\n\t\t\n\t\tint lower = 0;\n\t\tdouble area = 0;\n\t\tint armond = 0;\n\t\twhile(area < S) {\n\t\t\tarea += erea[lower];\n\t\t\tarmond += ar[lower++];\n\t\t}\n\t\tint upper = m-1;\n\t\tans = armond;\n\t\twhile(lower > 0) {\n\t\t\t\n\t\t\tlower--;\n\t\t\tarea -= erea[lower];\n\t\t\tarmond -= ar[lower];\n\t\t\t\n\t\t\twhile(area < S && upper >= 0) {\n\t\t\t\tarea += erea[upper];\n\t\t\t\tarmond += ar[upper];\n\t\t\t\tupper--;\n\t\t\t}\n\t\t\tif(upper >= 0)\n\t\t\t\tans = min(ans, armond);\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nstruct Choco{\n\tint nut;\n\tdouble S;\n};\n\nint n,m,w,h,thre;\nChoco ch[30000];\n\nint solve(){\n\tint nut=0,ans=INF;\n\tdouble S=0;\n\tfor(int i=0,j=0;i<m;i++){\n\t\tfor(;j<i;j++){\n\t\t\tS+=ch[j].S;\n\t\t\tnut+=ch[j].nut;\n\t\t}\n\n\t\tfor(;j<m;j++){\n\t\t\tif(w*h-thre+EPS<S) break;\n\t\t\tans=min(ans,n-nut);\n\t\t\tS+=ch[j].S;\n\t\t\tnut+=ch[j].nut;\n\t\t}\n\t\tif(w*h-thre+EPS>S) ans=min(ans,n-nut);\n\n\t\tS-=ch[i].S;\n\t\tnut-=ch[i].nut;\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&thre),n;){\n\t\tstatic int l[30001],r[30001];\n\t\tl[0]=r[0]=0;\n\t\trep(i,m) scanf(\"%d%d\",l+i+1,r+i+1);\n\n\t\trep(i,m){\n\t\t\tch[i].S=((l[i+1]-l[i])+(r[i+1]-r[i]))/2.0*w;\n\t\t\tch[i].nut=0;\n\t\t}\n\t\trep(i,n){\n\t\t\tdouble cx,cy; scanf(\"%lf%lf\",&cx,&cy);\n\n\t\t\tint lo=0,hi=m+1;\n\t\t\twhile(lo<hi){\n\t\t\t\tint mi=(lo+hi+1)/2;\n\t\t\t\tif(cx*l[mi]+(w-cx)*r[mi]<w*cy) lo=mi; else hi=mi-1;\n\t\t\t}\n\t\t\tch[lo].nut++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\n\nint main(){\n\tint n,m,W,H;\n\tdouble S;\n\twhile(cin >> n >> m >> W >> H >> S && n){\n\t\tvector<double> x(n),y(n);\n\t\tvector< pair<int,int> > ln;\n\t\tvector<int> con;\n\t\tvector<int> idx;\n\t\tvector<int> rr;\n\t\tint prev = 0;\n\t\tvector<double> size(m+10);\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,rev=0;\n\t\t\tcin >> a >> b;\n\t\t\tif( a > b ) swap(a,b) , rev = 1;\n\t\t\t\n\t\t\tsize[i] += ((a-prev) * W + W * (b-a) / 2.0 );\n\t\t\tsize[i+1] += W*(b-a) / 2.0;\n\t\t\tif( prev != a ){\n\t\t\t\tln.push_back(make_pair(prev,a));\t\n\t\t\t\tcon.push_back(0);\n\t\t\t\tidx.push_back(i);\n\t\t\t\trr.push_back(0);\n\t\t\t}\n\t\t\tif( a != b ){\n\t\t\t\tln.push_back(make_pair(a,b));\n\t\t\t\tcon.push_back(1);\n\t\t\t\tidx.push_back(i);\n\t\t\t\trr.push_back(rev);\n\t\t\t}\n\t\t\tprev = b;\n\t\t}\n\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\t\t//scout << endl;\n\t\tvector<int> have(m+10);\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint id = upper_bound(ln.begin(),ln.end(),make_pair((int)(y[i]+1e-9),0)) - ln.begin() - 1;\n\t\t\tif( con[id] ){\n\t\t\t\tif( rr[id] ){\n\t\t\t\t\tdouble h = ln[id].second - (W-x[i]) * (ln[id].second - ln[id].first) / W;\n\t\t\t\t\tif( y[i] < h ){\n\t\t\t\t\t\thave[idx[id]]++;\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\thave[idx[id]+1]++;\t\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdouble h = ln[id].first + x[i] * (ln[id].second - ln[id].first) / W;\n\t\t\t\t\tif( y[i] < h ){\n\t\t\t\t\t\thave[idx[id]]++;\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\thave[idx[id]+1]++;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\thave[idx[id]]++;\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0 ; i < m ; i++){\n\t\t\tcout << have[i] << \" \" << size[i] << endl;\n\t\t}*/\n\t\tint l = 0;\n\t\tdouble sz = 0;\n\t\tint ans = 0 , get = 0;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tget += have[i];\n\t\t\tsz  += size[i];\n\t\t\twhile( l <= i && W*H-sz < S - 1e-9 ){\n\t\t\t\tget -= have[l];\n\t\t\t\tsz  -= size[l];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\t//cout << l << \" \" << i << \" \" << W*H-sz << \" \" << get << endl;\n\t\t\tif( W*H - sz > S - 1e-9 ) ans = max( ans , get );\n\t\t}\n\t\tcout << n - ans << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define N 30005\nusing namespace std;\nint n,m,w,h,s,sum;\ndouble area[N],b[N],x,y,tmp,now;\nint cnt[N],pos;\nstruct Line{\n\tdouble l,r;\n}a[N];\nint main(){\n\twhile (~scanf(\"%d%d%d%d%d\",&n,&m,&w,&h,&s) && n){\n\t\ttmp=w*h-s;\n\t\ta[0].l=a[0].r=0;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tscanf(\"%lf%lf\",&a[i].l,&a[i].r);\n\t\t\tarea[i]=((a[i].l-a[i-1].l)+(a[i].r-a[i-1].r))*w/2;\n\t\t\tb[i]=max(a[i].l,a[i].r);\n\t\t}\n\t\tb[0]=0;\n\t\tarea[m+1]=((h-a[m].l)+(h-a[m].r))*w/2;\n\t\t//for (int i=1;i<=m+1;i++)\n\t\t//\tcout<<area[i]<<endl;\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tsum=0;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tif (x<0 || x>w) continue;\n\t\t\tpos=lower_bound(b,b+1+m,y)-b;\n\t\t\t//cout<<\"-----------\"<<pos<<' '<<b[pos]<<endl;\n\t\t\tif (pos<=m+1){\n\t\t\t\tcnt[pos]++;\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\t//for (int i=1;i<=m+1;i++)\n\t\t//\tcout<<cnt[i]<<endl;\n\t\tint l=1,r=0,ans,total=0;\n\t\tans=0;\n\t\tnow=0;\n\t\ttotal=0;\n\t\twhile (r<m+1){\n\t\t\tr++;\n\t\t\ttotal+=cnt[r];\n\t\t\tnow+=area[r];\n\t\t\twhile (now>tmp){\n\t\t\t\ttotal-=cnt[l];\n\t\t\t\tnow-=area[l];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (total>ans)\n\t\t\t\tans=total;\n\t\t}\n\t\tprintf(\"%d\\n\",sum-ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <int,int> P;\nint n,m,w,h,S;\npoint L[30001][2];\npoint A[30001];\nlong long arm[30001];\n\nbool ccw(point a,point b,point c){\n  b-=a,c-=a;\n  c*=b;\n  return (c.y>0);\n}\n\nvoid mk_arm(){\n  memset(arm,0,sizeof(arm));\n  for(int i=0;i<n;i++){\n    int low=0,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      if(!ccw(L[mid][0],L[mid][1],A[i]))up=mid;\n      else low=mid+1;\n    }\n    arm[low]++;\n  }\n  \n  for(int i=1;i<=m;i++)arm[i]+=arm[i-1];\n  assert(arm[m]==n);\n}\n\nint solve(){\n  long long res=0;\n  for(int i=0;i<m;i++){\n    int low=i,mid,up=m+1;\n    while(low<up){\n      mid=(low+up)/2;\n      double sss=(L[mid][0].y-L[i][0].y+L[mid][1].y-L[i][1].y)*w/2.0;\n      if(w*h-(sss)<S) up=mid;\n      else low=mid+1; \n    }\n    res=max(res,(arm[low-1]-arm[i]));\n  }\n  return n-res;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m>>w>>h>>S;\n    if(!n&&!m&&!w&&!h&&!S)break;\n    \n    L[0][0]=point(0,0),L[0][1]=point(w,0);\n    for(int i=1,a,b;i<=m;i++){\n      cin>>a>>b;\n      L[i][0]=point(0,a);\n      L[i][1]=point(w,b);\n    }\n    double a,b;\n    for(int i=0;i<n;i++)cin>>a>>b,A[i]=point(a,b);\n    mk_arm();\n    cout << solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint bs(double x, double y, int l[], int r[], int w, int m) {\n\n    int lower = 0;\n    int upper = m + 1;\n\n    while( true ) {\n        int t = (lower + upper) / 2;\n\n        if ( y < x * (r[t] - l[t]) / (w + 0.0) + l[t] ) {\n            if ( y > x * (r[t-1] - l[t-1]) / (w + 0.0) + l[t-1] ) {\n                return t - 1;\n            } else {\n                upper = t;     \n            }\n        } else {\n            lower = t;\n        }\n    }\n}\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        int l[m+1];\n        int r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        int fromd_area[m+1];\n        int fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        for(int i = 0; i < n; i++) {\n            nuts[bs(x[i], y[i], l, r, w, m)] += 1;\n        }\n\n        int fromd_nuts[m+1];\n        int fromu_nuts[m+1];\n        fromd_nuts[0] = 0;\n        fromu_nuts[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_nuts[i] = fromd_nuts[i-1] + nuts[i-1];\n            fromu_nuts[i] = fromu_nuts[i-1] + nuts[m-i];\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = lower_bound(fromu_area, fromu_area + m, S - fromd_area[i]) - fromu_area;\n            if (minnuts > fromd_nuts[i] + fromu_nuts[j]) {\n                minnuts = fromd_nuts[i] + fromu_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\nint n,m,w,h,s;\nconst int MAXN = 30004;\n#define inf 1e20\n#define eps 1e-8\nconst double PI = 2.*asin(1.0);\nstruct point{double x,y;};\n\n#define _sign(x) ((x)>eps?1:((x)<-eps?2:0))\n#define zero(x) (((x)>0?(x):(x))<eps)\n\ndouble xmult(point p1, point p2, point p0) {\n\treturn (p1.x-p0.x)*(p2.y - p0.y) - (p2.x-p0.x)*(p1.y-p0.y);\n}\n\nint inside_convex(point q, int n, point* p) {\n\tint i,s[3] = {1,1,1};\n\tfor (i = 0; i < n && s[0] && s[1] | s[2]; i++) {\n\t\ts[_sign(xmult(p[(i+1)%n],q,p[i]))] = 0;\n\t}\n\treturn s[0]&&s[1]|s[2];\n}\n\ndouble area_polygon(int n, point* p) {\n\tdouble s1 = 0, s2 = 0;\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\ts1 += p[(i+1)%n].y*p[i].x,s2 += p[(i+1)%n].y * p[(i+2)%n].x;\n\treturn fabs(s1 - s2)/2;\n}\n\npoint po1[MAXN],po2[MAXN];\ndouble area[MAXN],cho[MAXN],sumar[MAXN],sumcho[MAXN];\n\nbool cmp(const point& p1, const point& p2) {\n\tif (p1.y == p2.y)\n\t\treturn p1.x < p2.x;\n\telse return p1.y < p2.y;\n}\n\nvoid solve() {\n\tint stp = 0;\n\tint l,r;\n\tdouble sum = 0,ss;\n\tdouble maxret = 0;\n\tmemset(cho,0,sizeof(cho));\n\tmemset(sumcho,0,sizeof(sumcho));\n\tsort(po2,po2+m,cmp);\n\tcout<<\"===0\"<<endl;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tarea[i] = area_polygon(4,po1+(i*2));\n\t\tif (i == 0)\n\t\t\tsumar[i] = area[i];\n\t\telse sumar[i] = sumar[i-1] + area[i];\n\t}\n\tcout<<\"===1\"<<endl;\n\tfor (int i = 0; i < m ; i++) {\n\t\tif (inside_convex(po2[i],4,po1+(stp*2))) {\n\t\t\tcho[stp]++;\n\t\t\tcout << \"ok\" << endl;\n\t\t}\n\t\telse {\n\t\t\tsumcho[stp] += cho[stp];\n\t\t\tcout<<cho[stp]<<endl;\n\t\t\tstp++;\n\n\t\t}\n\t}\n\tcout<<\"===2\"<<endl;\n\tl = 0;\n\tss = sumar[n-2] - s;\n\n\tfor (int i = 1 ; i < n - 1; i++) {\n\t\tif (l < i && sumar[i] - sumar[l] > ss) {\n\t\t\tl++;\n\t\t}\n\t\tmaxret = max(maxret,sumcho[i] - sumcho[l-1]);\n\t}\n\tcout<<maxret<<endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d %d %d %d\",&n,&m,&w,&h,&s) != EOF) {\n\t\tif(0 == n+m+w+h+s)\n\t\t\tbreak;\n\t\tn++;\n\t\tpo1[0].x = 0;\n\t\tpo1[0].y = 0;\n\t\tpo1[1].x = w;\n\t\tpo1[1].y = 0;\n\t\tfor (int i = 1; i < 2 * n; i+=2) {\n\t\t\tscanf(\"%lf\",&po1[i].y);\n\t\t\tpo1[i].x = 0;\n\t\t\tscanf(\"%lf\",&po1[i+1].y);\n\t\t\tpo1[i+1].x = w;\n\t\t}\n\t//\tcout<<\"ok\"<<endl;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tscanf(\"%lf %lf\",&po2[i].x,&po2[i].y);\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\n/*\n3 32 64 7\n4 35 89 5\n5 555 442 3\n5 777 465 11\n100000 666 701622763 65537\n0 0 0 0\n */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    rep(i,n){\n \n      int pos = lower_bound(lower_y,lower_y+m,ps[i].y) - lower_y;\n      pos-=4;\n      if(pos < 0)pos=0;\n\n\n      REP(j,pos,m){\n\tif(inPolygon(poly[j],ps[i])){\n\t  almond[j]++;\n\t  break;\n\t}\n\tassert( j != m-1 );\n      }\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      /*\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      */\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      /* \n     if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      */\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n    if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n    }\n\n    sort(ps,ps+n);\n    if(false){\n    int cur = 0;\n    rep(i,n){\n      while(!inPolygon(poly[cur],ps[i]))cur++;\n      //assert(cur < m);\n      almond[cur]++;\n    }\n    }\n\n    if(false){\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n    }\n    //assert(equals(total[m-1],(double)(h*w)));\n    //assert(talmond[m-1] == n);\n    int ans = IINF;\n\n    if(false){\n    rep(i,m){\n      //cout << \"i = \" << i << endl;\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n      //cout << \"remain = \" << remain << \" counter = \" << counter << endl;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      if(S-remain < 0){\n\twhile(true);\n      }\t\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      //cout << \"pos = \" << pos << endl;\n      if(m-1-pos <= i)continue;\n\n      //cout << \"i = \" << i << \" pos = \" << pos << \" area[\" << i << \"] = \" << area[i] << \" + \" << total[pos] << \" >= \" << S << endl;\n      if(!(0 <= pos && pos < m)){\n\twhile(true);\n      }\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n    }\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<stack>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nconst double eps=1e-7;\nint sgn(double x){\n\treturn (x>eps)-(x<-eps);\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double _x,double _y):x(_x),y(_y){}\n\tdouble operator*(const Point &p)const{\n\t\treturn x*p.y-y*p.x;\n\t}\n\tdouble operator/(const Point &p)const{//轤ケ遘ッ \n\t\treturn x*p.x+y*p.y;\n\t}\n\tPoint operator-(const Point &p)const{\n\t\treturn Point(x-p.x,y-p.y);\n\t}\n\tvoid input(){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)\\n\",x,y);\n\t}\n};\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point _a,Point _b):a(_a),b(_b){}\n\tdouble operator*(const Point &p)const{\n\t\treturn (b-a)*(p-a);\n\t}\n\tvoid output(){\n\t\tprintf(\"(%.3f %.3f)-(%.3f %.3f)\\n\",a.x,a.y,b.x,b.y);\n\t}\n\tint Direction(const Point &p)const{  //蟾ヲ1?悟承-1?檎コソ荳? \n\t\treturn sgn((*this)*p);\n\t}\n};\ndouble lp[32000],rp[32000];\nPoint pt[32000];\nint sz[32000];\ndouble area[32000],sp[32000];\nint st[32000];\nLine ls[32000];\nint main(){\n\tint n,m;\n\tdouble w,h,s;\n\twhile(scanf(\"%d%d%lf%lf%lf\",&n,&m,&w,&h,&s)){\n\t\tif(n==0&&m==0&&sgn(w)==0&&sgn(h)==0&&sgn(s)==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf\",&lp[i],&rp[i]);\n\t\t}\n\t\tsort(lp,lp+n),sort(rp,rp+n);\n\t\tfor(int i=0;i<m;i++) pt[i].input();\n\t\tmemset(sz,0,sizeof(sz));\n\t\tint cnt=0;\n\t\tif(sgn(h-lp[n-1])||sgn(h-rp[n-1]))\n\t\tls[cnt++]=Line(Point(0,h),Point(w,h));\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tls[cnt++]=Line(Point(0,lp[i]),Point(w,rp[i]));\n\t\t}\n\t\tif(sgn(lp[0])||sgn(rp[0]))\n\t\tls[cnt++]=Line(Point(0,0),Point(w,0));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint l=0,r=cnt-1,md,res=-1;\n\t\t\twhile(l<=r){\n\t\t\t\tmd=(l+r)>>1;\n\t\t\t\tif(ls[md].Direction(pt[i])!=1) {\n\t\t\t\t\tl=md+1;\n\t\t\t\t\tres=md;\n\t\t\t\t} else r=md-1;\n\t\t\t}\n\t\t\tsz[res]++;\n\t\t}\n\t\tdouble pl=h,pr=h;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i==n) {\n\t\t\t\tarea[i]=(fabs(pl)+fabs(pr))*w*0.5;\n\t\t\t} else {\n\t\t\t\tarea[i]=(fabs(lp[n-i-1]-pl)+fabs(rp[n-i-1]-pr))*w*0.5;\n\t\t\t\tpl=lp[n-i-1],pr=rp[n-i-1];\n\t\t\t}\n\t\t}\n\t\t//for(int i=0;i<=n;i++) printf(\"%d\\n\",sz[i]);\n\t\tsp[n]=area[n];st[n]=sz[n];\n\t\tst[n+1]=0;\n\t\tsp[n+1]=0;\n\t\tfor(int i=n-1;i>=0;i--) sp[i]=area[i]+sp[i+1],st[i]=sz[i]+st[i+1];\n\t\tint mi=m,rb=0,has=0;\n\t\t\n\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\tif(sgn(sp[rb]-s)>=0)\n\t\tmi=min(mi,st[rb]);\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\ts-=area[i];\n\t\t\thas+=sz[i];\n\t\t\twhile(rb<=n&&sgn(sp[rb+1]-s)>=0) rb++;\n\t\t\tif(rb<=i) rb=i+1;\n\t\t\tif(sgn(sp[rb]-s)>=0)\n\t\t\tmi=min(has+st[rb],mi);\n\t\t}\n\t\tprintf(\"%d\\n\",mi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  //rep(i,poly.size())\n  //if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\ndouble lower_y[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n\n  int len = poly[M].size();\n  npoly.push_back(Point(0,0)), npoly.push_back(Point(w,0));\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  //if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  //if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = {0,0};\n    Point p2 = {(double)w,0};\n\n    double debug = 0;\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      double min_y = min(p1.y,p2.y);\n\n      cin >> l[i] >> r[i];\n      min_y = min(min_y,l[i]);\n      min_y = min(min_y,r[i]);\n      lower_y[i] = min_y;\n      if(!(p1 == Point(0,l[i])))poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      assert(poly[i].size() >= 3);\n      p1 = {0,l[i]}, p2 = {(double)w,r[i]};\n      area[i] = getArea(poly[i]);\n      debug += area[i];\n      almond[i] = 0;\n    }\n    //assert(equals(debug,(double)(h*w)));\n\n    rep(i,n){\n      cin >> ps[i].x >> ps[i].y;\n      //cout << \"ps[\" << i << \"] = \" << ps[i] << endl;\n    }\n    /*\n    cout << \"poly\" << endl;\n    rep(i,m){\n      cout << i << \"----\" << endl;\n      rep(j,poly[i].size()){\n\tcout << poly[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\n\tif(inPolygon(poly[M],ps[i])){\n\t  break;\n\t}\n\telse if(check(M,i)){//0から\n\t  R = M;\n\t} else {\n\t  L = M+1;\n\t}\n      }\n\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else {\n\tassert(false);\n      }\n\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n\n    rep(i,m){\n\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      double remain = total[m-1] - cost;\n      int counter = talmond[m-1] - cost2;\n\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n\n      int pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n\n      if(m-1-pos <= i)continue;\n\n\n      int add = talmond[pos];\n      ans = min(ans,add+counter);\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint bs(double x, double y, int l[], int r[], int w, int m) {\n\n    int lower = 0;\n    int upper = m + 1;\n\n    while( true ) {\n        int t = (lower + upper) / 2;\n\n        if ( y < x * (r[t] - l[t]) / (w + 0.0) + l[t] ) {\n            if ( y > x * (r[t-1] - l[t-1]) / (w + 0.0) + l[t-1] ) {\n                return t - 1;\n            } else {\n                upper = t;     \n            }\n        } else {\n            lower = t;\n        }\n    }\n}\n\nint main() {\n\n    int n, m, w, h, S;\n    while(cin >> n >> m >> w >> h >> S && (n || m || w || h || S) ) {\n        S *= 2;\n        int l[m+1];\n        int r[m+1];\n        l[0] = 0;\n        r[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            cin >> l[i] >> r[i];\n        }\n        double x[n];\n        double y[n];\n        for(int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        int fromd_area[m+1];\n        int fromu_area[m+1];\n        fromd_area[0] = 0;\n        fromu_area[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_area[i] = fromd_area[i-1] + (l[i] - l[i-1] + r[i] - r[i-1]) * w;\n            fromu_area[i] = fromu_area[i-1] + (l[m+1-i] - l[m-i] + r[m+1-i] - r[m-i]) * w;\n        }\n\n        int nuts[m];\n        for(int i = 0; i < n; i++) {\n            nuts[bs(x[i], y[i], l, r, w, m)] += 1;\n        }\n\n        int fromd_nuts[m+1];\n        int fromu_nuts[m+1];\n        fromd_nuts[0] = 0;\n        fromu_nuts[0] = 0;\n        for(int i = 1; i <= m; i++) {\n            fromd_nuts[i] = fromd_nuts[i-1] + nuts[i-1];\n            fromu_nuts[i] = fromu_nuts[i-1] + nuts[m-i];\n        }\n\n        int minnuts = n + 1;\n        for(int i = 0; i < m; i++) {\n            int j = lower_bound(fromu_area, fromu_area + m + 1, S - fromd_area[i]) - fromu_area;\n            if (minnuts > fromd_nuts[i] + fromu_nuts[j]) {\n                minnuts = fromd_nuts[i] + fromu_nuts[j];\n            }\n        }\n\n        cout << minnuts << endl;\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<climits>\n#include<cstdlib>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define N 30010\n#define M 400010\n#define eps 1e-8\n#define inf 1000000010\ntypedef long long ll;\nint l[N], r[N], sum[N], num[N], m, w;\nstruct node {\n\tdouble x, y;\n}p[N];\nbool cmp(const node &a, const node &b) {\n\treturn a.y < b.y;\n}\nint find(double x, double y) {\n\tint s = 1, t = m, ans;\n\twhile (s <= t) {\n\t\tint mid = s+t >> 1;\n\t\tif (-w * (y-r[mid]) - (l[mid]-r[mid]) * (x-w) >= 0) {\n\t\t\tans = mid;\n\t\t\tt = mid-1;\n\t\t}\n\t\telse s = mid+1;\n\t}\n\treturn ans;\n}\nint find(int s, int x) {\n\tint t = m, ans;\n\twhile (s <= t) {\n\t\tint mid = s+t >> 1;\n\t\tif (sum[m]-sum[mid-1] >= x) {\n\t\t\tans = mid;\n\t\t\ts = mid+1;\n\t\t}\n\t\telse t = mid-1;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n, s, h;\n\tsum[0] = l[0] = r[0] = 0;\n\twhile (scanf(\"%d%d%d%d%d\", &n, &m, &w, &h, &s) != EOF && n) {\n\t\tmemset(num, 0, sizeof(num));\n\t\ts <<= 1;\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\t\tsum[i] = (l[i]-l[i-1] + r[i]-r[i-1])*w + sum[i-1];\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tnum[find(x, y)]++;\n\t\t}\n\t\tfor (int i = 1; i <= m; ++i)\n\t\t\tnum[i] += num[i-1];\n\t\tint ans = n;\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tint ts = s-sum[i-1];\n\t\t\tif (ts <= 0) {\n\t\t\t\tans = min(ans, num[i-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint temp = find(i, ts);\n\t\t\tans = min(ans, num[i-1]+num[m]-num[temp-1]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 40000\n#define EPS (1e-6)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(y,p.y)?y<p.y:x<p.x;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - ccw - begin\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - ccw - end\n\n// Library - inPolygon - begin\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r)\n{\n  return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x);\n}\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r)\n{\n  return fabs(cross3p(p,q,r)) < EPS;\n}\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r)\n{\n  return cross3p(p,q,r) > 0;//can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r)\n{\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p)\n{\n  int sz = (int)p.size();\n  \n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  \n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  \n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft)\n      return false;\n  \n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c)\n{\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p)\n{\n  if((int)poly.size() == 0)return false;\n\n  rep(i,poly.size())\n  if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++)\n    {\n      if(cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0)\n\tsum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n      else\n\tsum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n    }\n  return (fabs(sum - 2*M_PI) < EPS || fabs(sum + 2*M_PI) < EPS);\n\n}  \n\n// Library - inPolygon - end\n\n// Library - area - begin\n\ndouble getArea(vector<Point> vec)\n{\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n// Library - area - end\n\nint n,m,w,h,s;\ndouble S,l[MAX],r[MAX];\nPoint ps[MAX];\nPolygon poly[MAX];\nint almond[MAX],talmond[MAX];\ndouble area[MAX],total[MAX];\n\nbool check(int M,int index){\n  Polygon npoly;\n  int len = poly[M].size();\n  npoly.push_back(poly[M][len-2]), npoly.push_back(poly[M][len-1]);\n  if(!(npoly[1] == Point(0,0)))npoly.push_back(Point(0,0));\n  if(!(npoly[0] == Point(w,0)))npoly.push_back(Point(w,0));\n  return inPolygon(npoly,ps[index]);\n}\n\n\nint main(){\n\n  while(cin >> n >> m >> w >> h >> s,n|m|w|h|s){\n    S = s;\n    Point p1 = Point(0,0);\n    Point p2 = Point((double)w,0);\n    rep(i,m){\n      almond[i] = 0;\n      poly[i].clear();\n      cin >> l[i] >> r[i];\n      if(!(p1 == Point(0,l[i])))\n      poly[i].push_back(p1);\n      poly[i].push_back(p2);\n      if(!(Point(w,r[i]) == p2))poly[i].push_back(Point(w,r[i]));\n      poly[i].push_back(Point(0,l[i]));\n      p1 = Point(0,l[i]), p2 = Point((double)w,r[i]);\n      area[i] = getArea(poly[i]);\n      almond[i] = 0;\n    }\n    rep(i,n) cin >> ps[i].x >> ps[i].y;\n    if(s == 0){\n      cout << 0 << endl;\n      continue;\n    }\n    rep(i,n){\n      int L = 0, R = m,M;\n      while(L < R){\n\tM = (L+R)/2;\n\tif(inPolygon(poly[M],ps[i])) break;\n\telse if(check(M,i)) R = M;\n\telse L = M+1;\n      }\n      if(inPolygon(poly[M],ps[i]))almond[M]++;\n      else if(inPolygon(poly[L],ps[i]))almond[L]++;\n      else if(R<m&&inPolygon(poly[R],ps[i]))almond[R]++;\n      else assert(false);\n    }\n\n    total[0] = area[m-1];\n    talmond[0] = almond[m-1];\n    REP(i,1,m){\n      total[i] = total[i-1] + area[m-1-i];\n      talmond[i] = talmond[i-1] + almond[m-1-i];\n    }\n\n    int ans = IINF;\n    double remain = 0;\n    int counter = 0;\n    int pos = lower_bound(total,total+m,S) - total;\n    ans = min(ans,talmond[pos]);\n\n    rep(i,m){\n      double cost = ( (i == m-1) ? 0 : total[m-1-i-1] );\n      int cost2 =   ( (i == m-1) ? 0 : talmond[m-1-i-1]);\n      remain = total[m-1] - cost;\n      counter = talmond[m-1] - cost2;\n      if(equals(remain,S) || remain > S){\n\tans = min(ans,counter);\n\tcontinue;\n      }\n      pos = lower_bound(total,total+m,(double)(S-remain)) - total;\n      if(m-1-pos <= i)continue;\n      double fofpwaejfoaw = total[pos] + remain;\n      if(equals(fofpwaejfoaw,S) || fofpwaejfoaw > S){\n\tint add = talmond[pos];\n\tans = min(ans,add+counter);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1067 Cutting a Chocolate\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n//#define getchar_unlocked()  getchar()\nint in()        // get a non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()    // get a non-negative real number from stdin  \n{\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\tx = n;\n\tif (c == '.') {\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t}\n\treturn x;\n}\n\n#define EQ(a,b)   (fabs(a-b)<1e-7)\n\ntypedef struct { double x, y; } P;\nP p[30002];\n\nint hl[30002], hr[30002], s[30002], a[30002], d[30002];\n\nint binary_search(int *tbl, int hi, int key)\n{\n\tint lo = 0, mi, r;\n\n    while (lo < hi) {\n        mi = (lo + hi) >> 1;\n\t\tr = tbl[mi] - key;\n\t\tif (!r) return mi;\n        if (r < 0) lo = mi + 1; else hi = mi;\n    }\n\treturn lo-1;\n}\n\nint cmp(P *a, P *b)\n{\n\tdouble d;\n\td = a->y - b->y; if (d < 0) return -1; if (d > 0) return 1;\n\td = a->x - b->x; if (d < 0) return -1; if (d > 0) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint n, m, w, h, wh2, S, i, j, ans;\n\tdouble x, y, y1, y2;\n\n\twhile (n = in()) {\n\t\tm = in()+1, w = in(), h = in(), wh2 = (w*h)<<1, S = wh2-(in()<<1);\n\t\tfor (i = 1; i < m; i++) {\n\t\t\thl[i] = in(), hr[i] = in(), a[i] = 0;\n\t\t\ts[i] = (hl[i] + hr[i])*w, d[i] = hr[i]-hl[i];\n\t\t}\n\t\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\t\tqsort(p, n, sizeof(P), cmp);\n\n\t\tj = 1; for (i = 0; i < n; i++) {\n\t\t\tx = p[i].x, y = p[i].y;\n\t\t\twhile (1) {\n\t\t\t\ty1 = d[j-1] * x / w + hl[j-1];\n\t\t\t\ty2 = d[j  ] * x / w + hl[j  ];\n\t\t\t\tif (y1 < y) {\n\t\t\t\t\tif (y < y2) break;\n\t\t\t\t\tj++;\n\t\t\t\t} else j--;\n\t\t\t}\n\t\t\ta[j]++;\n\t\t}\n\t\tfor (i = 1; i < m; i++) a[i] += a[i-1];\n\n\t\tif      (S == 0  ) { printf(\"%d\\n\", n); continue; }\n\t\telse if (S == wh2) { puts(\"0\");         continue; }\n\n\t\tj = binary_search(s, m, S); ans = a[j++];\n\t\tfor (i = 1; j < m; j++) {\n\t\t\twhile (s[j]-s[i] > S) i++;\n\t\t\tif (a[j]-a[i] > ans) ans = a[j]-a[i];\n\t\t}\n\t\tprintf(\"%d\\n\", n - ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1067 Cutting a Chocolate\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//#define getchar_unlocked()  getchar()\nint in()        // get a non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()    // get a non-negative real number from stdin  \n{\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\tx = n;\n\tif (c == '.') {\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t}\n\treturn x;\n}\n\nint hl[30002], hr[30002], s[30002], a[30002];\n\nint binary_search(int *tbl, int hi, int k, int key)\n{\n\tint lo = 0, mi, r;\n\t\n\twhile (lo+1 < hi) {\n\t\tmi = (lo + hi) >> 1;\n\t\tr = tbl[mi] * k - key;\n\t\tif (!r) return mi;\n\t\tif (r < 0) lo = mi; else hi = mi;\n\t}\n\treturn lo;\n}\n\nint main()\n{\n\tint n, m, w, h, S, ans;\n\tint i, j;\n\tdouble x, y, y1, y2;\n\n\twhile (n = in()) {\n\t\tm = in(), w = in(), h = in(), S = (w*h-in()) << 1;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\thl[i] = in(), hr[i] = in(), a[i] = 0;\n\t\t\ts[i] = hl[i] + hr[i];\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tx = dbl(), y = dbl();\n\t\t\tj = binary_search(hl, m, 1, (int)y);\n\t\t\ty1 = (hr[j] - hl[j]) * x / w + hl[j], j++;\n\t\t\twhile (1) {\n\t\t\t\ty2 = (hr[j] - hl[j]) * x / w + hl[j];\n\t\t\t\tif (y1 < y && y < y2) break;\n\t\t\t\ty1 = y2, j++;\n\t\t\t}\n\t\t\ta[j]++;\n\t\t}\n\t\tfor (i = 1; i < m; i++) a[i] += a[i-1];\n\n\t\tif (S == 0) { printf(\"%d\\n\", n); continue; }\n\t\telse if (S == 2*w*h) { puts(\"0\"); continue; }\n\n\t\tj = binary_search(s, m, w, S); ans = a[j++];\n\t\ti = 0; while (j < m) {\n\t\t\twhile ((s[j] - s[i])*w > S) i++;\n\t\t\tif (a[j] - a[i] > ans) ans = a[j] - a[i];\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"%d\\n\", n - ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1067 Cutting a Chocolate\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define getchar_unlocked()  getchar()\nint in()        // get a non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()    // get a non-negative real number from stdin  \n{\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\tx = n;\n\tif (c == '.') {\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t}\n\treturn x;\n}\n\n#define EQ(a,b)   (fabs(a-b)<1e-7)\n\ntypedef struct { double x, y; } P;\nP p[30002];\n\nint hl[30002], hr[30002], s[30002], a[30002];\n\nint binary_search(int *tbl, int hi, int k, int key)\n{\n\tint lo = 0, mi, r;\n\n    while (lo < hi) {\n        mi = (lo + hi) >> 1;\n\t\tr = tbl[mi]*k - key;\n\t\tif (!r) return mi;\n        if (r < 0) lo = mi + 1; else hi = mi;\n    }\n\treturn lo-1;\n}\n\nint cmp(P *a, P *b)\n{\n\tif (!EQ(a->y, b->y)) { if (a->y <= b->y) return -1;\treturn 1; }\n\tif ( EQ(a->x, b->x)) return 0; if (a->x <= b->x) return -1; return 1;\n}\n\nint main()\n{\n\tint n, m, w, h, S, i, j, ans;\n\tdouble x, y, y1, y2;\n\n\twhile (n = in()) {\n\t\tm = in(), w = in(), h = in(), S = (w*h-in()) << 1;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\thl[i] = in(), hr[i] = in(), a[i] = 0;\n\t\t\ts[i] = hl[i] + hr[i];\n\t\t}\n\t\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\t\tqsort(p, n, sizeof(P), cmp);\n\n\t\tj = 0; for (i = 0; i < n; i++) {\n\t\t\tx = p[i].x, y = p[i].y;\n\t\t\twhile (1) {\n\t\t\t\tif (j == 0) y1 = 0;\n\t\t\t\telse y1 = (hr[j-1] - hl[j-1]) * x / w + hl[j-1];\n\t\t\t\ty2 = (hr[j] - hl[j]) * x / w + hl[j];\n\t\t\t\tif (y1 < y && y < y2) break;\n\t\t\t\tif (y < y1) j--;\n\t\t\t\telse j++;\n\t\t\t}\n\t\t\ta[j]++;\n\t\t}\n\t\tfor (i = 1; i < m; i++) a[i] += a[i-1];\n\n\t\tif      (S == 0    ) { printf(\"%d\\n\", n); continue; }\n\t\telse if (S == 2*w*h) { puts(\"0\");         continue; }\n\n\t\tj = binary_search(s, m, w, S); ans = a[j++];\n\t\tfor (i = 0; j < m; j++) {\n\t\t\twhile ((s[j] - s[i])*w > S) i++;\n\t\t\tif (a[j] - a[i] > ans) ans = a[j] - a[i];\n\t\t}\n\t\tprintf(\"%d\\n\", n - ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1067 Cutting a Chocolate\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n//#define getchar_unlocked()  getchar()\nint in()        // get a non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()    // get a non-negative real number from stdin  \n{\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\tx = n;\n\tif (c == '.') {\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t}\n\treturn x;\n}\n\n#define EQ(a,b)   (fabs(a-b)<1e-7)\n\ntypedef struct { double x, y; } P;\nP p[30002];\n\nint hl[30002], hr[30002], s[30002], a[30002];\n\nint binary_search(int *tbl, int hi, int k, int key)\n{\n\tint lo = 0, mi, r;\n\n    while (lo < hi) {\n        mi = (lo + hi) >> 1;\n\t\tr = tbl[mi]*k - key;\n\t\tif (!r) return mi;\n        if (r < 0) lo = mi + 1; else hi = mi;\n    }\n\treturn lo-1;\n}\n\nint cmp(P *a, P *b)\n{\n\tif (!EQ(a->y, b->y)) { if (a->y <= b->y) return -1;\treturn 1; }\n\tif (EQ(a->x, b->x)) return 0; if (a->x <= b->x) return -1; return 1;\n}\n\nint main()\n{\n\tint n, m, w, h, S, ans;\n\tint i, j;\n\tdouble x, y, y1, y2;\n\n\twhile (n = in()) {\n\t\tm = in(), w = in(), h = in(), S = (w*h-in()) << 1;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\thl[i] = in(), hr[i] = in(), a[i] = 0;\n\t\t\ts[i] = hl[i] + hr[i];\n\t\t}\n\t\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\t\tqsort(p, n, sizeof(P), cmp);\n\n\t\tj = 0; for (i = 0; i < n; i++) {\n\t\t\tif (j < 0) j = 0;\n\t\t\tx = p[i].x, y = p[i].y;\n\t\t\twhile (1) {\n\t\t\t\tif (j == 0) y1 = 0;\n\t\t\t\telse y1 = (hr[j-1] - hl[j-1]) * x / w + hl[j-1];\n\t\t\t\ty2 = (hr[j] - hl[j]) * x / w + hl[j];\n\t\t\t\tif (y1 < y && y < y2) break;\n\t\t\t\twhile (y < y1) {\n\t\t\t\t\tj--;\n\t\t\t\t\tif (j == 0) y1 = 0;\n\t\t\t\t\telse y1 = (hr[j-1] - hl[j-1]) * x / w + hl[j-1];\n\t\t\t\t\ty2 = (hr[j] - hl[j]) * x / w + hl[j];\n\t\t\t\t\tif (y1 < y && y < y2) goto done;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\ndone:\t\ta[j]++;\n\t\t}\n\t\tfor (i = 1; i < m; i++) a[i] += a[i-1];\n\n\t\tif (S == 0) { printf(\"%d\\n\", n); continue; }\n\t\telse if (S == 2*w*h) { puts(\"0\"); continue; }\n\n\t\tj = binary_search(s, m, w, S); ans = a[j++];\n\t\ti = 0; while (j < m) {\n\t\t\twhile ((s[j] - s[i])*w > S) i++;\n\t\t\tif (a[j] - a[i] > ans) ans = a[j] - a[i];\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"%d\\n\", n - ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1067 Cutting a Chocolate\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n//#define getchar_unlocked()  getchar()\nint in()        // get a non-negative integer from stdin\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()    // get a non-negative real number from stdin  \n{\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\tx = n;\n\tif (c == '.') {\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t}\n\treturn x;\n}\n\n#define EQ(a,b)   (fabs(a-b)<1e-7)\n\ntypedef struct { double x, y; } P;\nP p[30002];\n\nint hl[30002], hr[30002], s[30002], a[30002];\n\nint binary_search(int *tbl, int hi, int k, int key)\n{\n\tint lo = 0, mi, r;\n\n    while (lo < hi) {\n        mi = (lo + hi) >> 1;\n\t\tr = tbl[mi]*k - key;\n\t\tif (!r) return mi;\n        if (r < 0) lo = mi + 1; else hi = mi;\n    }\n\treturn lo-1;\n}\n\nint cmp(P *a, P *b)\n{\n\tif (!EQ(a->y, b->y)) { if (a->y <= b->y) return -1;\treturn 1; }\n\tif ( EQ(a->x, b->x)) return 0; if (a->x <= b->x) return -1; return 1;\n}\n\nint main()\n{\n\tint n, m, w, h, S, i, j, ans;\n\tdouble x, y, y1, y2;\n\n\twhile (n = in()) {\n\t\tm = in(), w = in(), h = in(), S = (w*h-in()) << 1;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\thl[i] = in(), hr[i] = in(), a[i] = 0;\n\t\t\ts[i] = hl[i] + hr[i];\n\t\t}\n\t\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\t\tqsort(p, n, sizeof(P), cmp);\n\n\t\tj = 0; for (i = 0; i < n; i++) {\n\t\t\tx = p[i].x, y = p[i].y;\n\t\t\twhile (1) {\n\t\t\t\tif (j == 0) y1 = 0;\n\t\t\t\telse y1 = (hr[j-1] - hl[j-1]) * x / w + hl[j-1];\n\t\t\t\ty2 = (hr[j] - hl[j]) * x / w + hl[j];\n\t\t\t\tif (y1 < y && y < y2) break;\n\t\t\t\tif (y2 < y) j++;\n\t\t\t\telse        j--;\n\t\t\t}\n\t\t\ta[j]++;\n\t\t}\n\t\tfor (i = 1; i < m; i++) a[i] += a[i-1];\n\n\t\tif      (S == 0    ) { printf(\"%d\\n\", n); continue; }\n\t\telse if (S == 2*w*h) { puts(\"0\");         continue; }\n\n\t\tj = binary_search(s, m, w, S); ans = a[j++];\n\t\tfor (i = 0; j < m; j++) {\n\t\t\twhile ((s[j] - s[i])*w > S) i++;\n\t\t\tif (a[j] - a[i] > ans) ans = a[j] - a[i];\n\t\t}\n\t\tprintf(\"%d\\n\", n - ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, w, h, S;\n\tstatic int l[], r[];\n\tstatic int a[];\n\t\n\tstatic int mid;\n\tstatic double v1x, v1y, v2x, v2y;\n\tstatic double cross;\n\n\tpublic static int check(int aid, int low, int high, double x, double y) {\n\t\tif (high - low == 1) {\n\t\t\treturn low;\n\t\t}\n\n\t\tmid = (low + high) / 2;\n\t\tv1x = -w;\n\t\tv1y = l[mid] - r[mid];\n\t\tv2x = x - w;\n\t\tv2y = y - r[mid];\n\t\tcross = v1x * v2y - v1y * v2x;\n\n\t\tif (0 < cross) {\n\t\t\treturn check(aid, low, mid, x, y);\n\t\t} else {\n\t\t\treturn check(aid, mid, high, x, y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint low;\n\t\tint high;\n\t\tint max;\n\t\tint amdh, amdl;\n\t\tint amd;\n\n\t\tl = new int[30005];\n\t\tr = new int[30005];\n\t\ta = new int[30005];\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif ((n | m | w | h | S) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tArrays.fill(a, 0);\n\n\t\t\tl[0] = r[0] = 0;\n\t\t\tfor (int i = 0; i < m ;i++) {\n\t\t\t\tl[i + 1] = sc.nextInt();\n\t\t\t\tr[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n ;i++) {\n\t\t\t\ta[check(i, 0, m + 1, sc.nextDouble(), sc.nextDouble())]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\ta[i] = a[i - 1] + a[i];\n\t\t\t}\n\n\t\t\tlow = 0;\n\t\t\thigh = 0;\n\t\t\tmax = 0;\n\t\t\twhile (low <= m && high <= m) {\n\t\t\t\tif ((l[high] - l[low] + r[high] - r[low]) * w / 2 <= w * h - S) {\n\t\t\t\t\tamdh = 0;\n\t\t\t\t\tamdl = 0;\n\t\t\t\t\tif (0 < high) {\n\t\t\t\t\t\tamdh = a[high - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 < low) {\n\t\t\t\t\t\tamdl = a[low - 1];\n\t\t\t\t\t}\n\t\t\t\t\tamd = amdh - amdl;\n\t\t\t\t\tmax = Math.max(max,  amd);\n\t\t\t\t\thigh++;\n\t\t\t\t} else {\n\t\t\t\t\tlow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, w, h, S;\n\tstatic int l[], r[];\n\tstatic int a[];\n\n\tpublic static int check(int aid, int low, int high, double x, double y) {\n\t\tif (high - low == 1) {\n\t\t\treturn low;\n\t\t}\n\n\t\tint mid = (low + high) / 2;\n\t\tdouble v1x = -w;\n\t\tdouble v1y = l[mid] - r[mid];\n\t\tdouble v2x = x - w;\n\t\tdouble v2y = y - r[mid];\n\t\tdouble cross = v1x * v2y - v1y * v2x;\n\n\t\tif (0 < cross) {\n\t\t\treturn check(aid, low, mid, x, y);\n\t\t} else {\n\t\t\treturn check(aid, mid, high, x, y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint low;\n\t\tint high;\n\t\tint max;\n\t\tint amdh, amdl;\n\t\tint amd;\n\n\t\tl = new int[30005];\n\t\tr = new int[30005];\n\t\ta = new int[30005];\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif ((n | m | w | h | S) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(a, 0);\n\n\t\t\tl[0] = r[0] = 0;\n\t\t\tfor (int i = 0; i < m ;i++) {\n\t\t\t\tl[i + 1] = sc.nextInt();\n\t\t\t\tr[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n ;i++) {\n\t\t\t\ta[check(i, 0, m + 1, sc.nextDouble(), sc.nextDouble())]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\ta[i] = a[i - 1] + a[i];\n\t\t\t}\n\n\t\t\tlow = 0;\n\t\t\thigh = 0;\n\t\t\tmax = 0;\n\t\t\twhile (low <= m && high <= m) {\n\t\t\t\tif ((l[high] - l[low] + r[high] - r[low]) * w / 2 <= w * h - S) {\n\t\t\t\t\tamdh = 0;\n\t\t\t\t\tamdl = 0;\n\t\t\t\t\tif (0 < high) {\n\t\t\t\t\t\tamdh = a[high - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 < low) {\n\t\t\t\t\t\tamdl = a[low - 1];\n\t\t\t\t\t}\n\t\t\t\t\tamd = amdh - amdl;\n\t\t\t\t\tmax = Math.max(max,  amd);\n\t\t\t\t\thigh++;\n\t\t\t\t} else {\n\t\t\t\t\tlow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, w, h, S;\n\tstatic double l[], r[];\n\tstatic double x[], y[];\n\tstatic int a[];\n\n\tpublic static int check(int aid, int low, int high) {\n\t\tif (high - low == 1) {\n\t\t\treturn low;\n\t\t}\n\n\t\tint mid = (low + high) / 2;\n\t\tdouble v1x = -w;\n\t\tdouble v1y = l[mid] - r[mid];\n\t\tdouble v2x = x[aid] - w;\n\t\tdouble v2y = y[aid] - r[mid];\n\t\tdouble cross = v1x * v2y - v1y * v2x;\n\n\t\tif (0 < cross) {\n\t\t\treturn check(aid, low, mid);\n\t\t} else {\n\t\t\treturn check(aid, mid, high);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif ((n | m | w | h | S) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = new double[m + 1];\n\t\t\tr = new double[m + 1];\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\ta = new int[m];\n\t\t\t\n\t\t\tl[0] = r[0] = 0;\n\t\t\tfor (int i = 0; i < m ;i++) {\n\t\t\t\tl[i + 1] = sc.nextDouble();\n\t\t\t\tr[i + 1] = sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n ;i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[check(i, 0, m + 1)]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\ta[i] = a[i - 1] + a[i];\n\t\t\t}\n\t\t\t\n\t\t\tint low = 0;\n\t\t\tint high = 0;\n\t\t\tint max = 0;\n\t\t\twhile (low <= m && high <= m) {\n\t\t\t\tif ((l[high] - l[low] + r[high] - r[low]) * w / 2 <= w * h - S) {\n\t\t\t\t\tint amdh = 0;\n\t\t\t\t\tint amdl = 0;\n\t\t\t\t\tif (0 < high) {\n\t\t\t\t\t\tamdh = a[high - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 < low) {\n\t\t\t\t\t\tamdl = a[low - 1];\n\t\t\t\t\t}\n\t\t\t\t\tint amd = amdh - amdl;\n\t\t\t\t\tmax = Math.max(max,  amd);\n\t\t\t\t\thigh++;\n\t\t\t\t} else {\n\t\t\t\t\tlow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, w, h, S;\n\tstatic double l[], r[];\n\tstatic double x[], y[];\n\tstatic int a[];\n\n\tpublic static int check(int aid, int low, int high) {\n\t\tif (high - low == 1) {\n\t\t\treturn low;\n\t\t}\n\n\t\tint mid = (low + high) / 2;\n\t\tdouble v1x = -w;\n\t\tdouble v1y = l[mid] - r[mid];\n\t\tdouble v2x = x[aid] - w;\n\t\tdouble v2y = y[aid] - r[mid];\n\t\tdouble cross = v1x * v2y - v1y * v2x;\n\n\t\tif (0 < cross) {\n\t\t\treturn check(aid, low, mid);\n\t\t} else {\n\t\t\treturn check(aid, mid, high);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tl = new double[30005];\n\t\tr = new double[30005];\n\t\tx = new double[30005];\n\t\ty = new double[30005];\n\t\ta = new int[30005];\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif ((n | m | w | h | S) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tArrays.fill(a, 0);\n\t\t\t\n\t\t\tl[0] = r[0] = 0;\n\t\t\tfor (int i = 0; i < m ;i++) {\n\t\t\t\tl[i + 1] = sc.nextDouble();\n\t\t\t\tr[i + 1] = sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n ;i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[check(i, 0, m + 1)]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\ta[i] = a[i - 1] + a[i];\n\t\t\t}\n\t\t\t\n\t\t\tint low = 0;\n\t\t\tint high = 0;\n\t\t\tint max = 0;\n\t\t\twhile (low <= m && high <= m) {\n\t\t\t\tif ((l[high] - l[low] + r[high] - r[low]) * w / 2 <= w * h - S) {\n\t\t\t\t\tint amdh = 0;\n\t\t\t\t\tint amdl = 0;\n\t\t\t\t\tif (0 < high) {\n\t\t\t\t\t\tamdh = a[high - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 < low) {\n\t\t\t\t\t\tamdl = a[low - 1];\n\t\t\t\t\t}\n\t\t\t\t\tint amd = amdh - amdl;\n\t\t\t\t\tmax = Math.max(max,  amd);\n\t\t\t\t\thigh++;\n\t\t\t\t} else {\n\t\t\t\t\tlow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, w, h, S;\n\tstatic double l[], r[];\n\tstatic double x[], y[];\n\tstatic double s[];\n\tstatic int a[];\n\n\tpublic static int check(int aid, int low, int high) {\n\t\tif (high - low == 1) {\n\t\t\treturn low;\n\t\t}\n\n\t\tint mid = (low + high) / 2;\n\t\tdouble v1x = -w;\n\t\tdouble v1y = l[mid] - r[mid];\n\t\tdouble v2x = x[aid] - w;\n\t\tdouble v2y = y[aid] - r[mid];\n\t\tdouble cross = v1x * v2y - v1y * v2x;\n\n\t\tif (0 < cross) {\n\t\t\treturn check(aid, low, mid);\n\t\t} else {\n\t\t\treturn check(aid, mid, high);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif ((n | m | w | h | S) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = new double[m + 1];\n\t\t\tr = new double[m + 1];\n\t\t\tx = new double[n];\n\t\t\ty = new double[n];\n\t\t\ta = new int[m];\n\t\t\ts = new double[m];\n\t\t\tl[0] = r[0] = 0;\n\t\t\tfor (int i = 0; i < m ;i++) {\n\t\t\t\tl[i + 1] = sc.nextDouble();\n\t\t\t\tr[i + 1] = sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n ;i++) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[check(i, 0, m + 1)]++;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\ts[i] = (l[i + 1] - l[i] + r[i + 1] - r[i]) * w / 2;\n\t\t\t}\n\t\t\tint low = 0;\n\t\t\tint high = 0;\n\t\t\tint max = 0;\n\t\t\tint ns = 0;\n\t\t\tint na = 0;\n\t\t\twhile (low < m && high < m) {\n\t\t\t\tns = 0;\n\t\t\t\tna = 0;\n\t\t\t\tfor (int i = low; i <= high; i++) {\n\t\t\t\t\tns += s[i];\n\t\t\t\t\tna += a[i];\n\t\t\t\t}\n\t\t\t\tif (ns <= w * h - S) {\n\t\t\t\t\thigh++;\n\t\t\t\t\tmax = Math.max(max, na);\n\t\t\t\t} else {\n\t\t\t\t\tlow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, w, h, S;\n\tstatic int l[], r[];\n\tstatic int a[];\n\n\tpublic static int check(int aid, int low, int high, double x, double y) {\n\t\tif (high - low == 1) {\n\t\t\treturn low;\n\t\t}\n\n\t\tint mid = (low + high) / 2;\n\t\tdouble v1x = -w;\n\t\tdouble v1y = l[mid] - r[mid];\n\t\tdouble v2x = x - w;\n\t\tdouble v2y = y - r[mid];\n\t\tdouble cross = v1x * v2y - v1y * v2x;\n\n\t\tif (0 < cross) {\n\t\t\treturn check(aid, low, mid, x, y);\n\t\t} else {\n\t\t\treturn check(aid, mid, high, x, y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tS = sc.nextInt();\n\t\t\tif ((n | m | w | h | S) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = new int[m + 1];\n\t\t\tr = new int[m + 1];\n\t\t\ta = new int[m];\n\n\t\t\tl[0] = r[0] = 0;\n\t\t\tfor (int i = 0; i < m ;i++) {\n\t\t\t\tl[i + 1] = sc.nextInt();\n\t\t\t\tr[i + 1] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n ;i++) {\n\t\t\t\tdouble x = sc.nextDouble();\n\t\t\t\tdouble y = sc.nextDouble();\n\t\t\t\ta[check(i, 0, m + 1, x, y)]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < m; i++) {\n\t\t\t\ta[i] = a[i - 1] + a[i];\n\t\t\t}\n\n\t\t\tint low = 0;\n\t\t\tint high = 0;\n\t\t\tint max = 0;\n\t\t\twhile (low <= m && high <= m) {\n\t\t\t\tif ((l[high] - l[low] + r[high] - r[low]) * w / 2 <= w * h - S) {\n\t\t\t\t\tint amdh = 0;\n\t\t\t\t\tint amdl = 0;\n\t\t\t\t\tif (0 < high) {\n\t\t\t\t\t\tamdh = a[high - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 < low) {\n\t\t\t\t\t\tamdl = a[low - 1];\n\t\t\t\t\t}\n\t\t\t\t\tint amd = amdh - amdl;\n\t\t\t\t\tmax = Math.max(max,  amd);\n\t\t\t\t\thigh++;\n\t\t\t\t} else {\n\t\t\t\t\tlow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - max);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//6.12\nimport java.util.Scanner;\nimport java.io.*;\n\nclass Main{\n    int num[]=new int[30000];\n    int l[]=new int[30000],r[] =new int[30000];\n    int max(int a,int b){return a>b?a:b;}\n    boolean islower_line(double x,double y,double a,double b){\n\treturn y < a*x+b;\n    } \n    void put_xy(int m,int w,double x,double y){\n\tint tl=0,tr=m;\n\tint mid=0,ans=-1;\n\twhile(tl <= tr){\n\t    mid =(tl+tr)/2;\n\t    if (islower_line(x,y,(r[mid]-l[mid])/(double)w,l[mid])){\n\t\tans=mid;\n\t\ttr=mid-1;\n\t    }else tl=mid+1;\n\t}\n\t//System.out.println(islower_line(x,y,(r[ans]-l[ans])/(double)w,\n\t//l[ans]));\n\tnum[ans]++;\n\treturn;\n    }\n    int solve(int m,int s,int w){\n\tint ret=0,now=0;\n\tint head=0,tail=0;\n\tint lbase=0,rbase=0;\n\twhile(true){\n\t    //back++\n\t    while(tail < m){\n\t\tif ((long)w*(long)(l[tail]-lbase+r[tail]-rbase) > 2*s)break;\n\t\tnow+=num[tail];\n\t\ttail++;\n\t    }\n\t    ret=max(ret,now);\n\t    if (tail == m)break;\n\t    //head++;\n\t    head++;\n\t    lbase=l[head-1];\n\t    rbase=r[head-1];\n\t    now-=num[head-1];\n\t}\n\treturn ret;\n    }\n\n    /*\n    void run(){\n\tScanner in = new Scanner(System.in);\n\t//System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\tint n,m,w,h;\n\tint s;\n\twhile(true){\n\t    n=in.nextInt();\n\t    m=in.nextInt();\n\t    w=in.nextInt();\n\t    h=in.nextInt();\n\t    s=in.nextInt();\n\t    if (n == 0)break;\n\t    for(int i=0;i<m;i++)num[i]=0;\n\t    for(int i=0;i<m;i++){\n\t\tint tmp;\n\t\tl[i]=in.nextInt();\n\t\tr[i]=in.nextInt();\n\t    }\n\t    for(int i=0;i<n;i++){\n\t\tdouble x,y;\n\t\tx=in.nextDouble();\n\t\ty=in.nextDouble();\n\t\tput_xy(m,w,x,y);\n\t    }\n\t    s=w*h-s;\n\t    System.out.println(n-solve(m,s,w));\n\t}\n    }\n    */\n\n    void run(){\n\tScanner in = new Scanner(System.in);\n\t//System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\tint n,m,w,h;\n\tint s;\n\twhile(true){\n\t    n=Integer.parseInt(in.next());\n\t    m=Integer.parseInt(in.next());\n\t    w=Integer.parseInt(in.next());\n\t    h=Integer.parseInt(in.next());\n\t    s=Integer.parseInt(in.next());\n\t    if (n == 0)break;\n\t    for(int i=0;i<m;i++)num[i]=0;\n\t    for(int i=0;i<m;i++){\n\t\tint tmp;\n\t\tl[i]=Integer.parseInt(in.next());\n\t\tr[i]=Integer.parseInt(in.next());\n\t    }\n\t    for(int i=0;i<n;i++){\n\t\tdouble x,y;\n\t\tx=Double.parseDouble(in.next());\n\t\ty=Double.parseDouble(in.next());\n\t\tput_xy(m,w,x,y);\n\t    }\n\t    s=w*h-s;\n\t    System.out.println(n-solve(m,s,w));\n\t}\n    }\n\n    public static void main(String args[]){\n\tMain a = new Main();\n\ta.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "//import java.util.Scanner;\nimport java.io.*;\n\nclass Rmq{\n    int segt[] = new int[(1<<21)*2];\n    public int inp[] =new int[(1<<21)];\n    int MAX_VALUE=2147483647;\n    int min(int a,int b){return a<b?a:b;}\n    int max(int a,int b){return a>b?a:b;}\n    void update(int value,int pos,int n){\n\tint index=n-1+pos;\n\tsegt[index]=value;//[pos,pos]\n\twhile(index>0){\n\t    index=(index-1)/2;\n\t    segt[index]=min(segt[index*2+1],segt[index*2+2]);\n\t}\n    }\n    int query(int l,int r,int now,int ql,int qr){\n\tif (l == ql && r == qr){\n\t    return segt[now];\n\t}\n\tint midr=(l+r)/2,midl=midr+1;\n\tint ret=MAX_VALUE;\n\tif (ql <= midr)ret=min(ret,query(l,midr,now*2+1,ql,min(qr,midr)));\n\tif (midl <= qr)ret=min(ret,query(midl,r,now*2+2,max(midl,ql),qr));\n\treturn ret;\n    }\n\n    public void init(int r,int c,int lim){\n\tboolean isrowmajor=r<=c;\n\tfor(int i=0;i<lim;i++){\n\t    segt[i]=MAX_VALUE;\n\t}\n\tif (isrowmajor){\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i*c+j],i*c+j,lim);\n\t\t}\n\t    }\n\t}else {\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i+j*r],i+j*r,lim);\n\t\t}\n\t    }\n\t}\n    }\n    int searchmin(int r1,int c1,int r2,int c2,int r,int c,int lim){\n\tboolean isrowmajor = r<=c;  \n\tint ret=MAX_VALUE;\n\tlim--;\n\tif (isrowmajor){\n\t    for(int i=r1;i<=r2;i++){\n\t\tret=min(ret,query(0,lim,0,i*c+c1,i*c+c2));\n\t    }\n\t}else {\n\t    for(int j=c1;j<=c2;j++){\n\t\tret=min(ret,query(0,lim,0,j*r+r1,j*r+r2));\n\t    }\n\t}\n\treturn ret;\n    }    \n\n}\n\nclass Main{\n    void run(){\n\tScanner in = new Scanner();\n\t//System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\tint r,c,q;\n\tRmq rmq=new Rmq();\n\twhile(true){\n\t    r=in.nextInt();\n\t    c=in.nextInt();\n\t    q=in.nextInt();\n\t    if (r == 0)break;\n\t    int lim=1;\n\t    boolean isrowmajor = r<=c;\n\t    while(true){\n\t\tif (lim >= r*c)break;\n\t\tlim*=2;\n\t    }\n\t    if (isrowmajor){\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i*c+j]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }else {\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i+j*r]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }\n\t    rmq.init(r,c,lim);\n\t    for(int i=0;i<q;i++){\n\t\tint r1,r2,c1,c2;\n\t\tr1=in.nextInt();\n\t\tc1=in.nextInt();\n\t\tr2=in.nextInt();\n\t\tc2=in.nextInt();\n\t\tSystem.out.println(rmq.searchmin(r1,c1,r2,c2,r,c,lim));\n\t    }\n\t}\n    }\n    public static void main(String args[]){\n\tMain a = new Main();\n\ta.run();\n    }\n}\n\n\nclass Scanner {\n    int nextInt() {\n        try {\n            int c = System.in.read();\n            if (c == -1)\n                return c;\n            while (c != '-' && (c < '0' || '9' < c)) {\n                c = System.in.read();\n                if (c == -1)\n                    return c;\n            }\n            if (c == '-')\n                return -nextInt();\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    long nextLong() {\n        try {\n            int c = System.in.read();\n            if(c==-1)return -1;\n            while (c != '-' && (c < '0' || '9' < c)){\n                c = System.in.read();\n                if(c==-1)return -1;\n            }\n            if (c == '-')\n                return -nextLong();\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n    String next() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (Character.isWhitespace(c))\n                c = System.in.read();\n            do {\n                res.append((char) c);\n            } while (!Character.isWhitespace(c = System.in.read()));\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n \n    String nextLine() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (c == '\\r' || c == '\\n')\n                c = System.in.read();\n            do {\n                res.append((char) c);\n                c = System.in.read();\n            } while (c != '\\r' && c != '\\n');\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "### inner classes\n\nclass BIT\n  def initialize(n)\n    @n = n\n    @bits = (n + 1).times.map{0}\n  end\n\n  def sum(x)\n    s = 0\n    while x > 0\n      s += @bits[x]\n      x -= (x & -x)\n    end\n    s\n  end\n\n  def add(x, v)\n    while x <= @n\n      @bits[x] += v\n      x += (x & -x)\n    end\n  end\nend\n\n### subroutines\n\ndef bsearch_line(lines, n, x, y)\n  i0 = 0\n  i1 = n\n\n  while i0 <= i1\n    i = (i0 + i1) / 2\n    li0 = lines[i]\n    li1 = lines[i + 1]\n    y0 = li0[4] * x + li0[0]\n    y1 = li1[4] * x + li1[0]\n    #p [i, y, y0, y1]\n\n    if y >= y0 && y <= y1\n      return i\n    elsif y < y0\n      i1 = i - 1\n    else\n      i0 = i + 1\n    end\n  end\n  nil\nend\n\ndef lower_bound(arr, key, i0 = 0, i1 = arr.length)\n  lb = i0 - 1\n  ub = i1\n\n  while lb + 1 < ub\n    m = (lb + ub) / 2\n    if arr[m] >= key\n      ub = m\n    else\n      lb = m\n    end\n  end\n  ub\nend\n\n### main\n\nloop do\n  n, m, w, h, s = gets.split.map(&:to_i)\n  break if (n | m | w | h | s) == 0\n\n  wh2 = w * h * 2\n  s2 = s * 2\n\n  lines = [[0, 0, 0, 0, 0.0]]\n  py0 = py1 = 0\n  ssums = []\n  ssum = 0\n\n  m.times do\n    y0, y1 = gets.split.map(&:to_i)\n    dy0 = y0 - py0\n    dy1 = y1 - py1\n    lines << [y0, y1, dy0, dy1, (y1 - y0).to_f / w]\n    ssum += (dy0 + dy1) * w\n    ssums << ssum\n    py0 = y0\n    py1 = y1\n  end\n  #p lines\n  #p ssums\n\n  abit = BIT.new(m)\n\n  n.times do\n    x, y = gets.split.map(&:to_f)\n    i = bsearch_line(lines, m, x, y)\n    abit.add(i + 1, 1)\n  end\n  #p abit\n\n  min_as = n\n\n  m.downto(1) do |k|\n    srem = s2 - (wh2 - (k == 0 ? 0 : ssums[k - 1]))\n    as0 = n - abit.sum(k)\n    #p [k, srem, as0]\n\n    break if as0 >= min_as\n    if srem < 0\n      min_as = as0 if min_as > as0\n      break\n    end\n\n    i = lower_bound(ssums, srem, 0, k)\n    as = abit.sum(i + 1) + as0\n    #p ['lb', i, ssums[i], as]\n\n    min_as = as if min_as > as\n  end\n\n  puts min_as\nend"
  },
  {
    "language": "Python",
    "code": "# AOJ 1067 Cutting a Chocolate\n# Python3 2018.7.10 bal4u\n\nfrom bisect import bisect_left\n\nwhile True:\n\tn, m, w, h, S = map(int, input().split())\n\tif n == 0: break\n\tm, wh2 = m+1, 2*(w*h)\n\tS = wh2-2*S\n\ttbl, s = [[0,0,0]], [0]\n\tfor i in range(1, m):\n\t\tl, r = map(int, input().split())\n\t\ttbl.append([l, r, r-l])\n\t\ts.append((l+r)*w)\n\tp = []\n\tfor i in range(n):\n\t\tx, y = map(float, input().split())\n\t\tp.append((y, x))\n\tif S == 0:\n\t\tprint(n)\n\t\tcontinue\n\telif S == wh2:\n\t\tprint(0)\n\t\tcontinue\n\tp.sort()\n\tj, a = 1, [0]*m\n\tfor i in range(n):\n\t\ty, x = p[i]\n\t\twhile True:\n\t\t\ty1 = tbl[j-1][2]*x/w + tbl[j-1][0]\n\t\t\ty2 = tbl[j  ][2]*x/w + tbl[j  ][0]\n\t\t\tif y1 < y:\n\t\t\t\tif y < y2: break\n\t\t\t\tj += 1\n\t\t\telse: j -= 1\n\t\ta[j] += 1\n\tfor i in range(1, m): a[i] += a[i-1]\n\n\tj = bisect_left(s, S, 0, m)\n\tif s[j] != S: j -= 1\n\tans, i = a[j], 1\n\twhile j+1 < m:\n\t\tj += 1\n\t\twhile s[j]-s[i] > S: i += 1\n\t\tans = max(ans, a[j]-a[i])\n\tprint(n - ans)\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1067 Cutting a Chocolate\n# Python3 2018.7.10 bal4u\n\nfrom bisect import bisect_left\n\nwhile True:\n\tn, m, w, h, S = map(int, input().split())\n\tif n == 0: break\n\tm, wh2 = m+1, 2*(w*h)\n\tS = wh2-2*S\n\ttbl, s = [[0,0,0,0]], [0]\n\tfor i in range(1, m):\n\t\tl, r = map(int, input().split())\n\t\ttbl.append([l, r, 0, r-l])\n\t\ts.append((l+r)*w)\n\tp = []\n\tfor i in range(n):\n\t\tx, y = map(float, input().split())\n\t\tp.append((x, y))\n\tp.sort(key=lambda x:(x[1],x[0]))\n\tj = 1\n\tfor i in range(n):\n\t\tx, y = p[i]\n\t\twhile True:\n\t\t\ty1 = tbl[j-1][3]*x/w + tbl[j-1][0]\n\t\t\ty2 = tbl[j  ][3]*x/w + tbl[j  ][0]\n\t\t\tif y1 < y:\n\t\t\t\tif y < y2: break\n\t\t\t\tj += 1\n\t\t\telse: j -= 1\n\t\ttbl[j][2] += 1\n\tfor i in range(1, m): tbl[i][2] += tbl[i-1][2]\n\tif S == 0:\n\t\tprint(n)\n\t\tcontinue\n\telif S == wh2:\n\t\tprint(0)\n\t\tcontinue\n\tj = bisect_left(s, S, 0, m)\n\tif s[j] != S: j -= 1\n\tans, i = tbl[j][2], 1\n\twhile j+1 < m:\n\t\tj += 1\n\t\twhile s[j]-s[i] > S: i += 1\n\t\tans = max(ans, tbl[j][2]-tbl[i][2])\n\tprint(n - ans)\n"
  }
]