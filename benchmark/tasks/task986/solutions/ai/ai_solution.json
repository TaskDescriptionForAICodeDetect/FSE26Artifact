[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_R 50\n#define MAX_C 50\n\nint grid[MAX_R][MAX_C];\nbool filled[MAX_R][MAX_C];\n\nbool check_condition(int r, int c) {\n    if (r > 0 && r < MAX_R - 1 && c > 0 && c < MAX_C - 1) {\n        return grid[r-1][c-1] + grid[r+1][c+1] == grid[r-1][c+1] + grid[r+1][c-1];\n    }\n    return true;\n}\n\nbool solve(int r, int c) {\n    if (r == MAX_R) {\n        for (int i = 0; i < MAX_R; i++) {\n            for (int j = 0; j < MAX_C; j++) {\n                if (!check_condition(i, j)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    int next_r = r, next_c = c + 1;\n    if (next_c == MAX_C) {\n        next_r++;\n        next_c = 0;\n    }\n\n    if (filled[r][c]) {\n        return solve(next_r, next_c);\n    }\n\n    for (int val = 0; val <= 1000; val++) {\n        grid[r][c] = val;\n        filled[r][c] = true;\n\n        if (solve(next_r, next_c)) {\n            return true;\n        }\n\n        filled[r][c] = false;\n    }\n\n    return false;\n}\n\nint main() {\n    int R, C;\n    scanf(\"%d %d\", &R, &C);\n\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            scanf(\"%d\", &grid[i][j]);\n            filled[i][j] = grid[i][j] != -1;\n        }\n    }\n\n    if (solve(0, 0)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int R, C;\n    scanf(\"%d %d\", &R, &C);\n    \n    int **grid = (int **)malloc(R * sizeof(int *));\n    for (int i = 0; i < R; i++) {\n        grid[i] = (int *)malloc(C * sizeof(int));\n        for (int j = 0; j < C; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int possible = 1;\n    for (int i = 0; i < R - 1; i++) {\n        for (int j = 0; j < C - 1; j++) {\n            if (grid[i][j] != -1 && grid[i][j+1] != -1 && grid[i+1][j] != -1 && grid[i+1][j+1] != -1) {\n                if (grid[i][j] + grid[i+1][j+1] != grid[i][j+1] + grid[i+1][j]) {\n                    possible = 0;\n                    break;\n                }\n            }\n        }\n        if (!possible) break;\n    }\n    \n    if (possible) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    for (int i = 0; i < R; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Cell {\n    int r, c;\n    long long val;\n};\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    vector<vector<long long>> grid(R, vector<long long>(C, -1));\n    queue<Cell> q;\n\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            long long v;\n            cin >> v;\n            if (v != -1) {\n                grid[i][j] = v;\n                q.push({i, j, v});\n            }\n        }\n    }\n\n    bool possible = true;\n    while (!q.empty() && possible) {\n        Cell curr = q.front();\n        q.pop();\n        int r = curr.r;\n        int c = curr.c;\n        long long val = curr.val;\n\n        if (grid[r][c] != -1 && grid[r][c] != val) {\n            possible = false;\n            break;\n        }\n        if (grid[r][c] == val) continue;\n        grid[r][c] = val;\n\n        if (r > 0 && c > 0) {\n            long long sum = grid[r-1][c-1] + grid[r][c];\n            if (grid[r-1][c] != -1) {\n                long long expected = sum - grid[r-1][c];\n                if (grid[r][c-1] != -1 && grid[r][c-1] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r][c-1] = expected;\n                q.push({r, c-1, expected});\n            } else if (grid[r][c-1] != -1) {\n                long long expected = sum - grid[r][c-1];\n                if (grid[r-1][c] != -1 && grid[r-1][c] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r-1][c] = expected;\n                q.push({r-1, c, expected});\n            }\n        }\n        if (r > 0 && c < C-1) {\n            long long sum = grid[r-1][c+1] + grid[r][c];\n            if (grid[r-1][c] != -1) {\n                long long expected = sum - grid[r-1][c];\n                if (grid[r][c+1] != -1 && grid[r][c+1] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r][c+1] = expected;\n                q.push({r, c+1, expected});\n            } else if (grid[r][c+1] != -1) {\n                long long expected = sum - grid[r][c+1];\n                if (grid[r-1][c] != -1 && grid[r-1][c] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r-1][c] = expected;\n                q.push({r-1, c, expected});\n            }\n        }\n        if (r < R-1 && c > 0) {\n            long long sum = grid[r+1][c-1] + grid[r][c];\n            if (grid[r+1][c] != -1) {\n                long long expected = sum - grid[r+1][c];\n                if (grid[r][c-1] != -1 && grid[r][c-1] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r][c-1] = expected;\n                q.push({r, c-1, expected});\n            } else if (grid[r][c-1] != -1) {\n                long long expected = sum - grid[r][c-1];\n                if (grid[r+1][c] != -1 && grid[r+1][c] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r+1][c] = expected;\n                q.push({r+1, c, expected});\n            }\n        }\n        if (r < R-1 && c < C-1) {\n            long long sum = grid[r+1][c+1] + grid[r][c];\n            if (grid[r+1][c] != -1) {\n                long long expected = sum - grid[r+1][c];\n                if (grid[r][c+1] != -1 && grid[r][c+1] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r][c+1] = expected;\n                q.push({r, c+1, expected});\n            } else if (grid[r][c+1] != -1) {\n                long long expected = sum - grid[r][c+1];\n                if (grid[r+1][c] != -1 && grid[r+1][c] != expected) {\n                    possible = false;\n                    break;\n                }\n                grid[r+1][c] = expected;\n                q.push({r+1, c, expected});\n            }\n        }\n    }\n\n    for (int i = 0; i < R && possible; ++i) {\n        for (int j = 0; j < C && possible; ++j) {\n            if (grid[i][j] == -1) {\n                grid[i][j] = 0;\n            }\n            if (i > 0 && j > 0) {\n                if (grid[i][j] + grid[i-1][j-1] != grid[i-1][j] + grid[i][j-1]) {\n                    possible = false;\n                }\n            }\n        }\n    }\n\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GridFilling {\n    static class Cell {\n        int r, c;\n        long value;\n        Cell(int r, int c, long value) {\n            this.r = r;\n            this.c = c;\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int R = sc.nextInt();\n        int C = sc.nextInt();\n        int N = sc.nextInt();\n        List<Cell> cells = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int r = sc.nextInt() - 1;\n            int c = sc.nextInt() - 1;\n            long a = sc.nextLong();\n            cells.add(new Cell(r, c, a));\n        }\n\n        // Group cells by (i + j) % 2\n        Map<Integer, Long>[] groups = new HashMap[2];\n        groups[0] = new HashMap<>();\n        groups[1] = new HashMap<>();\n        boolean possible = true;\n\n        for (Cell cell : cells) {\n            int group = (cell.r + cell.c) % 2;\n            long expectedValue = cell.value;\n            int key = cell.r - cell.c; // Using (r - c) as key since (r + c) is same mod 2\n            if (groups[group].containsKey(key)) {\n                if (groups[group].get(key) != expectedValue) {\n                    possible = false;\n                    break;\n                }\n            } else {\n                groups[group].put(key, expectedValue);\n            }\n        }\n\n        if (possible) {\n            // Check for any conflict between the two groups\n            // The difference between any two cells from different groups should be consistent\n            if (!groups[0].isEmpty() && !groups[1].isEmpty()) {\n                long diff = groups[0].values().iterator().next() - groups[1].values().iterator().next();\n                for (Map.Entry<Integer, Long> entry0 : groups[0].entrySet()) {\n                    for (Map.Entry<Integer, Long> entry1 : groups[1].entrySet()) {\n                        if (entry0.getValue() - entry1.getValue() != diff) {\n                            possible = false;\n                            break;\n                        }\n                    }\n                    if (!possible) break;\n                }\n            }\n        }\n\n        System.out.println(possible ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-05 23:35:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static int R, C;\n    static int[][] grid;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        R = Integer.parseInt(st.nextToken());\n        C = Integer.parseInt(st.nextToken());\n        grid = new int[R][C];\n        \n        for (int i = 0; i < R; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < C; j++) {\n                grid[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        System.out.println(solve() ? \"Yes\" : \"No\");\n    }\n    \n    static boolean solve() {\n        for (int i = 0; i < R - 1; i++) {\n            for (int j = 0; j < C - 1; j++) {\n                if (!checkSquare(i, j)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    static boolean checkSquare(int r, int c) {\n        if (grid[r][c] == -1 || grid[r+1][c] == -1 || \n            grid[r][c+1] == -1 || grid[r+1][c+1] == -1) {\n            return true;\n        }\n        \n        return grid[r][c] + grid[r+1][c+1] == grid[r][c+1] + grid[r+1][c];\n    }\n}",
    "timestamp": "2025-08-05 23:36:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    \n    vector<vector<int>> grid(R, vector<int>(C, -1));\n    \n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < R - 1; i++) {\n        for (int j = 0; j < C - 1; j++) {\n            if (grid[i][j] != -1 && grid[i+1][j+1] != -1) {\n                if (grid[i][j+1] == -1 && grid[i+1][j] == -1) {\n                    grid[i][j+1] = grid[i+1][j] = grid[i+1][j+1] + grid[i][j] - grid[i+1][j+1];\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < R - 1; i++) {\n        for (int j = 0; j < C - 1; j++) {\n            if (grid[i][j] == -1 || grid[i][j+1] == -1 || grid[i+1][j] == -1 || grid[i+1][j+1] == -1) \n                continue;\n            \n            if (grid[i][j] + grid[i+1][j+1] != grid[i][j+1] + grid[i+1][j]) {\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n    \n    cout << \"Yes\" << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_fill_grid(r, c, grid):\n    for i in range(r - 1):\n        for j in range(c - 1):\n            a = grid[i][j]  # Top left\n            b = grid[i][j + 1]  # Top right\n            c1 = grid[i + 1][j]  # Bottom left\n            d = grid[i + 1][j + 1]  # Bottom right\n            if not (a + d == b + c1):\n                return False\n    return True\n\n# Example Usage\ndef main():\n    R, C = 3, 3\n    grid = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8]\n    ]\n    result = can_fill_grid(R, C, grid)\n    print(\"Possible\" if result else \"Impossible\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:13:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GridFill {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int R = scanner.nextInt();\n        int C = scanner.nextInt();\n        int[][] grid = new int[R][C];\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        scanner.close();\n\n        if (isPossible(grid, R, C)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n\n    private static boolean isPossible(int[][] grid, int R, int C) {\n        for (int i = 0; i < R - 1; i++) {\n            for (int j = 0; j < C - 1; j++) {\n                if (grid[i][j] + grid[i + 1][j + 1] != grid[i][j + 1] + grid[i + 1][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 16:13:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_R 50\n#define MAX_C 50\n\nint grid[MAX_R][MAX_C];\nbool filled[MAX_R][MAX_C];\n\nbool isValidGrid(int R, int C) {\n    for (int i = 0; i < R - 1; i++) {\n        for (int j = 0; j < C - 1; j++) {\n            int topLeft = grid[i][j];\n            int topRight = grid[i][j + 1];\n            int bottomLeft = grid[i + 1][j];\n            int bottomRight = grid[i + 1][j + 1];\n            if ((filled[i][j] && filled[i + 1][j + 1] && topLeft + bottomRight != topRight + bottomLeft) ||\n                (filled[i][j + 1] && filled[i + 1][j] && topLeft + bottomRight != topRight + bottomLeft)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int R, C;\n    scanf(\"%d %d\", &R, &C);\n    \n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            int val;\n            scanf(\"%d\", &val);\n            grid[i][j] = val;\n            filled[i][j] = (val != -1);\n        }\n    }\n    \n    if (isValidGrid(R, C)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 16:13:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nbool canFillGrid(const std::vector<std::vector<int>>& grid, int R, int C) {\n    for (int i = 0; i < R - 1; ++i) {\n        for (int j = 0; j < C - 1; ++j) {\n            if ((grid[i][j] + grid[i + 1][j + 1]) != (grid[i][j + 1] + grid[i + 1][j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int R, C;\n    std::cin >> R >> C;\n    std::vector<std::vector<int>> grid(R, std::vector<int>(C));\n    \n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    if (canFillGrid(grid, R, C)) {\n        std::cout << \"Yes\" << std::endl;\n    } else {\n        std::cout << \"No\" << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:13:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_grid(R, C, grid):\n    # Create a copy of the input grid to work on\n    filled_grid = [row[:] for row in grid]\n    \n    # Try to fill in cells using the given condition\n    for r in range(R):\n        for c in range(C):\n            # Skip if cell is already filled\n            if filled_grid[r][c] is not None:\n                continue\n            \n            # Try to determine the value based on surrounding cells\n            if (r > 0 and r < R-1 and c > 0 and c < C-1):\n                # Check 2x2 squares involving this cell\n                if (filled_grid[r-1][c-1] is not None and \n                    filled_grid[r+1][c+1] is not None and \n                    filled_grid[r-1][c+1] is not None):\n                    # Try to solve for this cell's value\n                    filled_grid[r][c] = (filled_grid[r-1][c-1] + \n                                         filled_grid[r+1][c+1] - \n                                         filled_grid[r-1][c+1])\n                elif (filled_grid[r-1][c-1] is not None and \n                      filled_grid[r+1][c+1] is not None and \n                      filled_grid[r+1][c-1] is not None):\n                    # Another way to solve for the cell's value\n                    filled_grid[r][c] = (filled_grid[r-1][c-1] + \n                                         filled_grid[r+1][c+1] - \n                                         filled_grid[r+1][c-1])\n    \n    # Verify the final grid satisfies the condition\n    for r in range(R-1):\n        for c in range(C-1):\n            if (filled_grid[r][c] is None or \n                filled_grid[r+1][c+1] is None or \n                filled_grid[r][c+1] is None or \n                filled_grid[r+1][c] is None):\n                return False\n            \n            # Check 2x2 square condition\n            if (filled_grid[r][c] + filled_grid[r+1][c+1] != \n                filled_grid[r][c+1] + filled_grid[r+1][c]):\n                return False\n    \n    return True\n\n# Read input\nR, C = map(int, input().split())\ngrid = []\nfor _ in range(R):\n    row = list(map(lambda x: int(x) if x != '-' else None, input().split()))\n    grid.append(row)\n\n# Solve and print result\nprint(\"Yes\" if solve_grid(R, C, grid) else \"No\")",
    "timestamp": "2025-08-13 16:14:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    R, C = map(int, sys.stdin.readline().split())\n    grid = []\n    for _ in range(R):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n    \n    # Check all possible 2x2 squares\n    for i in range(R - 1):\n        for j in range(C - 1):\n            a = grid[i][j]\n            b = grid[i][j+1]\n            c = grid[i+1][j]\n            d = grid[i+1][j+1]\n            # If any cell is -1 (unknown), skip this square\n            if a == -1 or b == -1 or c == -1 or d == -1:\n                continue\n            if a + d != b + c:\n                print(\"No\")\n                return\n    \n    print(\"Yes\")\n\nsolve()",
    "timestamp": "2025-08-13 16:14:18"
  }
]