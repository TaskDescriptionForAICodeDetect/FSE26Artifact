[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200000\n#define MAX_CONTESTANTS 1000000000\n\nint N;\nint L[MAX_N], R[MAX_N];\n\nint solve() {\n    int max_joy = 0;\n    \n    for (int mask = 1; mask < (1 << N) - 1; mask++) {\n        int contest1_joy = MAX_CONTESTANTS;\n        int contest2_joy = MAX_CONTESTANTS;\n        \n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                contest1_joy = fmin(contest1_joy, fmin(R[i], MAX_CONTESTANTS) - fmax(L[i], 1) + 1);\n            } else {\n                contest2_joy = fmin(contest2_joy, fmin(R[i], MAX_CONTESTANTS) - fmax(L[i], 1) + 1);\n            }\n        }\n        \n        max_joy = fmax(max_joy, contest1_joy + contest2_joy);\n    }\n    \n    return max_joy;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &L[i], &R[i]);\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int L;\n    int R;\n} Problem;\n\nint compare(const void *a, const void *b) {\n    Problem *p1 = (Problem *)a;\n    Problem *p2 = (Problem *)b;\n    if (p1->L != p2->L) return p1->L - p2->L;\n    return p1->R - p2->R;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Problem *problems = (Problem *)malloc(N * sizeof(Problem));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &problems[i].L, &problems[i].R);\n    }\n\n    qsort(problems, N, sizeof(Problem), compare);\n\n    int *prefix_min_R = (int *)malloc(N * sizeof(int));\n    int *suffix_min_R = (int *)malloc(N * sizeof(int));\n\n    prefix_min_R[0] = problems[0].R;\n    for (int i = 1; i < N; i++) {\n        prefix_min_R[i] = min(prefix_min_R[i - 1], problems[i].R);\n    }\n\n    suffix_min_R[N - 1] = problems[N - 1].R;\n    for (int i = N - 2; i >= 0; i--) {\n        suffix_min_R[i] = min(suffix_min_R[i + 1], problems[i].R);\n    }\n\n    int max_joy = 0;\n    for (int i = 0; i < N - 1; i++) {\n        int joy1 = max(0, prefix_min_R[i] - problems[i].L + 1);\n        int joy2 = max(0, suffix_min_R[i + 1] - problems[i + 1].L + 1);\n        max_joy = max(max_joy, joy1 + joy2);\n    }\n\n    int single_contest_joy = max(0, prefix_min_R[N - 1] - problems[0].L + 1);\n    max_joy = max(max_joy, single_contest_joy);\n\n    printf(\"%d\\n\", max_joy);\n\n    free(problems);\n    free(prefix_min_R);\n    free(suffix_min_R);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Interval {\n    int l, r;\n    bool operator<(const Interval& other) const {\n        return l < other.l || (l == other.l && r < other.r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<Interval> intervals(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> intervals[i].l >> intervals[i].r;\n    }\n\n    sort(intervals.begin(), intervals.end());\n\n    vector<int> prefix_min_r(N), suffix_min_r(N);\n    vector<int> prefix_max_l(N), suffix_max_l(N);\n\n    prefix_min_r[0] = intervals[0].r;\n    prefix_max_l[0] = intervals[0].l;\n    for (int i = 1; i < N; ++i) {\n        prefix_min_r[i] = min(prefix_min_r[i - 1], intervals[i].r);\n        prefix_max_l[i] = max(prefix_max_l[i - 1], intervals[i].l);\n    }\n\n    suffix_min_r[N - 1] = intervals[N - 1].r;\n    suffix_max_l[N - 1] = intervals[N - 1].l;\n    for (int i = N - 2; i >= 0; --i) {\n        suffix_min_r[i] = min(suffix_min_r[i + 1], intervals[i].r);\n        suffix_max_l[i] = max(suffix_max_l[i + 1], intervals[i].l);\n    }\n\n    long long max_joy = 0;\n    for (int k = 0; k < N - 1; ++k) {\n        long long joy1 = max(0, prefix_min_r[k] - prefix_max_l[k] + 1);\n        long long joy2 = max(0, suffix_min_r[k + 1] - suffix_max_l[k + 1] + 1);\n        max_joy = max(max_joy, joy1 + joy2);\n    }\n\n    // Also consider the case where one contest has all problems except one\n    for (int i = 0; i < N; ++i) {\n        int min_r = 1e9, max_l = 0;\n        for (int j = 0; j < N; ++j) {\n            if (j == i) continue;\n            min_r = min(min_r, intervals[j].r);\n            max_l = max(max_l, intervals[j].l);\n        }\n        long long joy1 = max(0, min_r - max_l + 1);\n        long long joy2 = max(0, intervals[i].r - intervals[i].l + 1);\n        max_joy = max(max_joy, joy1 + joy2);\n    }\n\n    cout << max_joy << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ContestJoyfulness {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] L = new int[N];\n        int[] R = new int[N];\n        for (int i = 0; i < N; i++) {\n            L[i] = scanner.nextInt();\n            R[i] = scanner.nextInt();\n        }\n\n        int[] prefixL = new int[N];\n        int[] prefixR = new int[N];\n        int[] suffixL = new int[N];\n        int[] suffixR = new int[N];\n\n        prefixL[0] = L[0];\n        prefixR[0] = R[0];\n        for (int i = 1; i < N; i++) {\n            prefixL[i] = Math.max(prefixL[i - 1], L[i]);\n            prefixR[i] = Math.min(prefixR[i - 1], R[i]);\n        }\n\n        suffixL[N - 1] = L[N - 1];\n        suffixR[N - 1] = R[N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n            suffixL[i] = Math.max(suffixL[i + 1], L[i]);\n            suffixR[i] = Math.min(suffixR[i + 1], R[i]);\n        }\n\n        long maxJoy = 0;\n        for (int i = 0; i < N - 1; i++) {\n            long joy1 = Math.max(0, prefixR[i] - prefixL[i] + 1);\n            long joy2 = Math.max(0, suffixR[i + 1] - suffixL[i + 1] + 1);\n            maxJoy = Math.max(maxJoy, joy1 + joy2);\n        }\n\n        System.out.println(maxJoy);\n    }\n}",
    "timestamp": "2025-08-05 22:43:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static final int MAX_N = 100005;\n    \n    public static void solve(int N, int[] L, int[] R) {\n        long maxJoyfulness = 0;\n        \n        for (int mask = 1; mask < (1 << N) - 1; mask++) {\n            long joy1 = calculateJoyfulness(N, L, R, mask);\n            long joy2 = calculateJoyfulness(N, L, R, ((1 << N) - 1) ^ mask);\n            \n            maxJoyfulness = Math.max(maxJoyfulness, joy1 + joy2);\n        }\n        \n        System.out.println(maxJoyfulness);\n    }\n    \n    static long calculateJoyfulness(int N, int[] L, int[] R, int mask) {\n        long maxLeft = 1;\n        long minRight = (long) 1e9;\n        \n        for (int i = 0; i < N; i++) {\n            if ((mask & (1 << i)) != 0) {\n                maxLeft = Math.max(maxLeft, L[i]);\n                minRight = Math.min(minRight, R[i]);\n            }\n        }\n        \n        return Math.max(0, minRight - maxLeft + 1);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        \n        int[] L = new int[N];\n        int[] R = new int[N];\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            L[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            R[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        solve(N, L, R);\n    }\n}",
    "timestamp": "2025-08-05 22:43:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nlong long solve(int N, vector<int>& L, vector<int>& R) {\n    vector<pair<int, int>> problems(N);\n    for (int i = 0; i < N; i++) {\n        problems[i] = {L[i], R[i]};\n    }\n    \n    sort(problems.begin(), problems.end());\n    \n    long long maxJoyfulness = 0;\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        if (mask == 0 || mask == ((1 << N) - 1)) continue;\n        \n        vector<pair<int, int>> contest1, contest2;\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                contest1.push_back(problems[i]);\n            } else {\n                contest2.push_back(problems[i]);\n            }\n        }\n        \n        long long joy1 = 0, joy2 = 0;\n        \n        if (!contest1.empty() && !contest2.empty()) {\n            int left1 = contest1[0].first, right1 = contest1[0].second;\n            int left2 = contest2[0].first, right2 = contest2[0].second;\n            \n            for (const auto& p : contest1) {\n                left1 = max(left1, p.first);\n                right1 = min(right1, p.second);\n            }\n            \n            for (const auto& p : contest2) {\n                left2 = max(left2, p.first);\n                right2 = min(right2, p.second);\n            }\n            \n            if (left1 <= right1 && left2 <= right2) {\n                joy1 = max(0LL, right1 - left1 + 1);\n                joy2 = max(0LL, right2 - left2 + 1);\n                maxJoyfulness = max(maxJoyfulness, joy1 + joy2);\n            }\n        }\n    }\n    \n    return maxJoyfulness;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> L(N), R(N);\n    for (int i = 0; i < N; i++) {\n        cin >> L[i] >> R[i];\n    }\n    \n    cout << solve(N, L, R) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_joyfulness(N, problems):\n    total_contestants = 10**9\n    prefix_min = [0] * (N + 1)\n    suffix_max = [0] * (N + 2)\n\n    prefix_min[0] = total_contestants + 1\n    for i in range(1, N + 1):\n        L, R = problems[i - 1]\n        prefix_min[i] = min(prefix_min[i - 1], R)\n\n    suffix_max[N + 1] = 0\n    for i in range(N, 0, -1):\n        L, R = problems[i - 1]\n        suffix_max[i] = max(suffix_max[i + 1], L)\n\n    max_joy = 0\n    for i in range(1, N):\n        joy1 = prefix_min[i]\n        joy2 = suffix_max[i + 1]\n        max_joy = max(max_joy, joy1 + joy2)\n\n    return max_joy\n\n# Input\nN = int(input().strip())\nproblems = [tuple(map(int, input().strip().split())) for _ in range(N)]\n\n# Solve the problem\nprint(max_joyfulness(N, problems))",
    "timestamp": "2025-08-13 12:11:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ContestJoyfulness {\n    static class Problem {\n        int L, R;\n        public Problem(int L, int R) {\n            this.L = L;\n            this.R = R;\n        }\n    }\n\n    public static long maxJoyfulness(int N, int[] L, int[] R) {\n        Problem[] problems = new Problem[N];\n        for (int i = 0; i < N; i++) {\n            problems[i] = new Problem(L[i], R[i]);\n        }\n\n        Arrays.sort(problems, (a, b) -> Integer.compare(a.L, b.L));\n\n        long[] prefixL = new long[N];\n        long[] suffixR = new long[N];\n\n        prefixL[0] = problems[0].L;\n        for (int i = 1; i < N; i++) {\n            prefixL[i] = Math.max(prefixL[i - 1], problems[i].L);\n        }\n\n        suffixR[N - 1] = problems[N - 1].R;\n        for (int i = N - 2; i >= 0; i--) {\n            suffixR[i] = Math.min(suffixR[i + 1], problems[i].R);\n        }\n\n        long maxJoyfulness = 0;\n        for (int i = 0; i < N - 1; i++) {\n            long joy1 = prefixL[i];\n            long joy2 = suffixR[i + 1];\n            maxJoyfulness = Math.max(maxJoyfulness, joy1 + joy2);\n        }\n\n        return maxJoyfulness;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] L = new int[N];\n        int[] R = new int[N];\n        for (int i = 0; i < N; i++) {\n            L[i] = scanner.nextInt();\n            R[i] = scanner.nextInt();\n        }\n        System.out.println(maxJoyfulness(N, L, R));\n    }\n}",
    "timestamp": "2025-08-13 12:11:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\ntypedef long long ll;\n\nint N;\nint L[MAX_N], R[MAX_N];\n\n// Function to calculate the joyfulness of a contest segment\nll calculate_contest_joyfulness(int start, int end) {\n    ll contest_l = LLONG_MIN, contest_r = LLONG_MAX;\n    for (int i = start; i <= end; ++i) {\n        if (L[i] > contest_l) contest_l = L[i];\n        if (R[i] < contest_r) contest_r = R[i];\n    }\n    return contest_r >= contest_l ? contest_r - contest_l + 1 : 0;\n}\n\n// Function to find the maximum possible total joyfulness\nll max_total_joyfulness() {\n    ll max_joyfulness = 0;\n\n    for (int split = 0; split < N - 1; ++split) {\n        ll joyfulness1 = calculate_contest_joyfulness(0, split);\n        ll joyfulness2 = calculate_contest_joyfulness(split + 1, N - 1);\n        if (joyfulness1 > 0 && joyfulness2 > 0) {\n            ll total_joy = joyfulness1 + joyfulness2;\n            if (total_joy > max_joyfulness) {\n                max_joyfulness = total_joy;\n            }\n        }\n    }\n\n    return max_joyfulness;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &L[i], &R[i]);\n    }\n\n    printf(\"%lld\\n\", max_total_joyfulness());\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:11:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Problem {\n    int L, R;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<Problem> problems(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> problems[i].L >> problems[i].R;\n    }\n    \n    // Initialise joyfulness contributions of two contests\n    int joyfulness1 = problems[0].R;\n    int joyfulness2 = problems[0].R;\n\n    // Process each additional problem, ensuring at least one is in each contest\n    for (int i = 1; i < N; ++i) {\n        joyfulness1 = min(joyfulness1, problems[i].R);\n        joyfulness2 = max(joyfulness2, problems[i].L - 1);\n    }\n    \n    cout << (joyfulness1 - joyfulness2 + problems[0].R) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:11:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, L, R):\n    def count_contestants(contest_problems):\n        if not contest_problems:\n            return 0\n        \n        left = max(L[p] for p in contest_problems)\n        right = min(R[p] for p in contest_problems)\n        \n        return max(0, right - left + 1)\n    \n    max_joy = 0\n    for mask in range(1, (1 << N) - 1):\n        contest1_problems = []\n        contest2_problems = []\n        \n        for i in range(N):\n            if mask & (1 << i):\n                contest1_problems.append(i)\n            else:\n                contest2_problems.append(i)\n        \n        joy = count_contestants(contest1_problems) + count_contestants(contest2_problems)\n        max_joy = max(max_joy, joy)\n    \n    return max_joy\n\n# Input parsing\nN = int(input())\nL = list(map(int, input().split()))\nR = list(map(int, input().split()))\n\n# Output the result\nprint(solve(N, L, R))",
    "timestamp": "2025-08-13 12:11:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    problems = []\n    for _ in range(N):\n        L = int(data[idx])\n        R = int(data[idx + 1])\n        problems.append((L, R))\n        idx += 2\n    \n    # Precompute the intersections for all possible splits\n    # We need to find the best split into two non-empty sets A and B\n    # The total joy is |A ∩ B| + |A' ∩ B'| where A' is the intersection of A and B' of B\n    \n    # Precompute prefix and suffix intersections\n    prefix = []\n    current_L = 0\n    current_R = 10**9\n    for L, R in problems:\n        current_L = max(current_L, L)\n        current_R = min(current_R, R)\n        prefix.append((current_L, current_R))\n    \n    suffix = []\n    current_L = 0\n    current_R = 10**9\n    for L, R in reversed(problems):\n        current_L = max(current_L, L)\n        current_R = min(current_R, R)\n        suffix.append((current_L, current_R))\n    suffix = suffix[::-1]\n    \n    max_joy = 0\n    # Try all possible splits where first contest is first i problems, second is the rest (i from 1 to N-1)\n    for i in range(N - 1):\n        L1, R1 = prefix[i]\n        L2, R2 = suffix[i + 1]\n        joy1 = max(0, R1 - L1 + 1)\n        joy2 = max(0, R2 - L2 + 1)\n        total = joy1 + joy2\n        if total > max_joy:\n            max_joy = total\n    \n    # Also consider the case where one contest is a single problem and the other is the intersection of the rest\n    # Compute the intersection of all problems except each one\n    total_L = 0\n    total_R = 10**9\n    for L, R in problems:\n        total_L = max(total_L, L)\n        total_R = min(total_R, R)\n    \n    for i in range(N):\n        # Exclude problem i\n        L_excluded = 0\n        R_excluded = 10**9\n        for j in range(N):\n            if j == i:\n                continue\n            L, R = problems[j]\n            L_excluded = max(L_excluded, L)\n            R_excluded = min(R_excluded, R)\n        joy1 = max(0, problems[i][1] - problems[i][0] + 1)\n        joy2 = max(0, R_excluded - L_excluded + 1)\n        total = joy1 + joy2\n        if total > max_joy:\n            max_joy = total\n    \n    print(max_joy)\n\nsolve()",
    "timestamp": "2025-08-13 12:11:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxJoyfulness(n, problems) {\n  let joyfulness1 = 0;\n  let joyfulness2 = 0;\n  \n  problems.sort((a, b) => a[1] - b[1]);\n  \n  let rightBound1 = 0;\n  let rightBound2 = 0;\n  \n  let partition = 1;\n  \n  for(const [li, ri] of problems) {\n    if(joyfulness1 == 0 || rightBound1 >= li) {\n      if(rightBound1 < li) {\n        joyfulness1 += ri - li + 1;\n        rightBound1 = ri;\n      } else {\n        joyfulness1 = Math.min(joyfulness1, ri - li + 1);\n        rightBound1 = Math.min(rightBound1, ri);\n      }\n    } else if(partition == 1 || rightBound2 >= li) {\n      partition = 2;\n      if(rightBound2 < li) {\n        joyfulness2 += ri - li + 1;\n        rightBound2 = ri;\n      } else {\n        joyfulness2 = Math.min(joyfulness2, ri - li + 1);\n        rightBound2 = Math.min(rightBound2, ri);\n      }\n    }\n  }\n  \n  return joyfulness1 + joyfulness2;\n}\n\n// Example usage:\n// Given N problems described by L_i and R_i\nconst n = 3;\nconst problems = [\n  [1, 5],\n  [2, 9],\n  [6, 10]\n];\n\nconsole.log(maxJoyfulness(n, problems)); // Outputs the maximum possible total joyfulness",
    "timestamp": "2025-08-13 12:12:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxJoyfulness(N, L, R) {\n    const dp = new Array(N + 1).fill(0).map(() => new Array(2).fill(0));\n    \n    for (let i = 1; i <= N; i++) {\n        for (let j = 0; j < 2; j++) {\n            dp[i][j] = -Infinity;\n        }\n    }\n    \n    dp[1][0] = 0;\n    dp[1][1] = countCommonContestants(L[0], R[0]);\n    \n    for (let i = 2; i <= N; i++) {\n        for (let j = 0; j < 2; j++) {\n            for (let k = 0; k < 2; k++) {\n                if (dp[i-1][1-k] !== -Infinity) {\n                    const joyfulness = (j === 1) ? countCommonContestants(L[i-1], R[i-1]) : 0;\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][1-k] + joyfulness);\n                }\n            }\n        }\n    }\n    \n    return Math.max(dp[N][0], dp[N][1]);\n}\n\nfunction countCommonContestants(L, R) {\n    return Math.max(0, R - L + 1);\n}",
    "timestamp": "2025-08-13 12:12:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N;\n    const problems = [];\n\n    rl.on('line', (line) => {\n        if (N === undefined) {\n            N = parseInt(line.trim(), 10);\n        } else {\n            const [L, R] = line.trim().split(' ').map(Number);\n            problems.push({ L, R });\n            if (problems.length === N) {\n                rl.close();\n            }\n        }\n    });\n\n    rl.on('close', () => {\n        // Precompute prefix and suffix intersections\n        const prefix = Array(N);\n        const suffix = Array(N);\n\n        prefix[0] = { L: problems[0].L, R: problems[0].R };\n        for (let i = 1; i < N; i++) {\n            prefix[i] = {\n                L: Math.max(prefix[i - 1].L, problems[i].L),\n                R: Math.min(prefix[i - 1].R, problems[i].R)\n            };\n        }\n\n        suffix[N - 1] = { L: problems[N - 1].L, R: problems[N - 1].R };\n        for (let i = N - 2; i >= 0; i--) {\n            suffix[i] = {\n                L: Math.max(suffix[i + 1].L, problems[i].L),\n                R: Math.min(suffix[i + 1].R, problems[i].R)\n            };\n        }\n\n        let maxJoy = 0;\n\n        // Case 1: Split into two non-empty contiguous segments\n        for (let i = 0; i < N - 1; i++) {\n            const contest1 = prefix[i];\n            const contest2 = suffix[i + 1];\n            const joy1 = Math.max(0, contest1.R - contest1.L + 1);\n            const joy2 = Math.max(0, contest2.R - contest2.L + 1);\n            maxJoy = Math.max(maxJoy, joy1 + joy2);\n        }\n\n        // Case 2: One contest has one problem, the other has the rest\n        // Find the best single problem (max R - L + 1)\n        let bestSingle = 0;\n        for (const { L, R } of problems) {\n            bestSingle = Math.max(bestSingle, R - L + 1);\n        }\n\n        // The other contest is the intersection of all other problems\n        const allExceptOne = Array(N);\n        for (let i = 0; i < N; i++) {\n            if (i === 0) {\n                allExceptOne[i] = suffix[1];\n            } else if (i === N - 1) {\n                allExceptOne[i] = prefix[N - 2];\n            } else {\n                allExceptOne[i] = {\n                    L: Math.max(prefix[i - 1].L, suffix[i + 1].L),\n                    R: Math.min(prefix[i - 1].R, suffix[i + 1].R)\n                };\n            }\n        }\n\n        for (let i = 0; i < N; i++) {\n            const joy1 = Math.max(0, allExceptOne[i].R - allExceptOne[i].L + 1);\n            const joy2 = Math.max(0, problems[i].R - problems[i].L + 1);\n            maxJoy = Math.max(maxJoy, joy1 + joy2);\n        }\n\n        console.log(maxJoy);\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:12:27"
  }
]