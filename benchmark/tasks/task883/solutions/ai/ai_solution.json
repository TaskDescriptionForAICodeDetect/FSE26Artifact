[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint count_points_in_rectangle(Point points[], int n, int x1, int y1, int x2, int y2) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (points[i].x >= x1 && points[i].x <= x2 && \n            points[i].y >= y1 && points[i].y <= y2) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n, k;\n    Point points[MAX_N];\n    \n    scanf(\"%d %d\", &n, &k);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    \n    int min_area = INT_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int p = 0; p < n; p++) {\n                for (int q = 0; q < n; q++) {\n                    int x1 = min(min(points[i].x, points[j].x), min(points[p].x, points[q].x));\n                    int x2 = max(max(points[i].x, points[j].x), max(points[p].x, points[q].x));\n                    int y1 = min(min(points[i].y, points[j].y), min(points[p].y, points[q].y));\n                    int y2 = max(max(points[i].y, points[j].y), max(points[p].y, points[q].y));\n                    \n                    int point_count = count_points_in_rectangle(points, n, x1, y1, x2, y2);\n                    \n                    if (point_count >= k) {\n                        int area = (x2 - x1) * (y2 - y1);\n                        min_area = min(min_area, area);\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", min_area);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compareX(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return (p1->x - p2->x);\n}\n\nint compareY(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return (p1->y - p2->y);\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    Point points[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    long long min_area = LLONG_MAX;\n\n    qsort(points, N, sizeof(Point), compareX);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + K - 1; j < N; j++) {\n            int x_left = points[i].x;\n            int x_right = points[j].x;\n            Point y_coords[N];\n            int count = 0;\n            for (int k = 0; k < N; k++) {\n                if (points[k].x >= x_left && points[k].x <= x_right) {\n                    y_coords[count++] = points[k];\n                }\n            }\n            if (count < K) continue;\n            qsort(y_coords, count, sizeof(Point), compareY);\n            for (int k = 0; k <= count - K; k++) {\n                int y_bottom = y_coords[k].y;\n                int y_top = y_coords[k + K - 1].y;\n                long long area = (long long)(x_right - x_left) * (y_top - y_bottom);\n                if (area < min_area) {\n                    min_area = area;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", min_area);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<pair<long long, long long>> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n\n    long long min_area = LLONG_MAX;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                for (int l = 0; l < N; ++l) {\n                    long long x_min = min({points[i].first, points[j].first, points[k].first, points[l].first});\n                    long long x_max = max({points[i].first, points[j].first, points[k].first, points[l].first});\n                    long long y_min = min({points[i].second, points[j].second, points[k].second, points[l].second});\n                    long long y_max = max({points[i].second, points[j].second, points[k].second, points[l].second});\n\n                    int count = 0;\n                    for (const auto& p : points) {\n                        if (p.first >= x_min && p.first <= x_max && p.second >= y_min && p.second <= y_max) {\n                            ++count;\n                        }\n                    }\n                    if (count >= K) {\n                        long long area = (x_max - x_min) * (y_max - y_min);\n                        if (area < min_area) {\n                            min_area = area;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << min_area << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimumAreaRectangle {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int[][] points = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            points[i][0] = sc.nextInt();\n            points[i][1] = sc.nextInt();\n        }\n\n        long minArea = Long.MAX_VALUE;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    for (int l = 0; l < N; l++) {\n                        int x1 = points[i][0];\n                        int x2 = points[j][0];\n                        int y1 = points[k][1];\n                        int y2 = points[l][1];\n\n                        if (x1 > x2) continue;\n                        if (y1 > y2) continue;\n\n                        int count = 0;\n                        for (int[] p : points) {\n                            int x = p[0];\n                            int y = p[1];\n                            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n                                count++;\n                            }\n                        }\n                        if (count >= K) {\n                            long area = (long)(x2 - x1) * (y2 - y1);\n                            if (area < minArea) {\n                                minArea = area;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(minArea);\n    }\n}",
    "timestamp": "2025-08-05 23:14:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public double minAreaRect(int[][] points) {\n        Set<String> pointSet = new HashSet<>();\n        for (int[] point : points) {\n            pointSet.add(point[0] + \",\" + point[1]);\n        }\n        \n        int n = points.length;\n        double minArea = Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int x1 = points[i][0], y1 = points[i][1];\n                int x2 = points[j][0], y2 = points[j][1];\n                \n                if (x1 == x2 || y1 == y2) continue;\n                \n                if (pointSet.contains(x1 + \",\" + y2) && pointSet.contains(x2 + \",\" + y1)) {\n                    double area = Math.abs((x1 - x2) * (y1 - y2));\n                    minArea = Math.min(minArea, area);\n                }\n            }\n        }\n        \n        return minArea == Double.MAX_VALUE ? 0 : minArea;\n    }\n}",
    "timestamp": "2025-08-05 23:14:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<pair<int, int>> points(N);\n    for (int i = 0; i < N; i++) {\n        cin >> points[i].first >> points[i].second;\n    }\n    \n    long long minArea = LLONG_MAX;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                for (int l = k; l < N; l++) {\n                    int x1 = min(points[i].first, points[j].first);\n                    int x2 = max(points[i].first, points[j].first);\n                    int y1 = min(points[k].second, points[l].second);\n                    int y2 = max(points[k].second, points[l].second);\n                    \n                    int count = 0;\n                    for (const auto& point : points) {\n                        if (point.first >= x1 && point.first <= x2 && \n                            point.second >= y1 && point.second <= y2) {\n                            count++;\n                        }\n                    }\n                    \n                    if (count >= K) {\n                        long long area = (long long)(x2 - x1) * (y2 - y1);\n                        minArea = min(minArea, area);\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << minArea << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_area_with_k_points(points, K):\n    x_sorted = sorted(points, key=lambda p: p[0])\n    y_sorted = sorted(points, key=lambda p: p[1])\n    \n    N = len(points)\n    min_area = float('inf')\n    \n    for lx in range(N):\n        for rx in range(lx, N):\n            ys = []\n            for i in range(N):\n                if x_sorted[lx][0] <= points[i][0] <= x_sorted[rx][0]:\n                    ys.append(points[i][1])\n            ys.sort()\n            for ly in range(len(ys) - K + 1):\n                ry = ly + K - 1\n                height = ys[ry] - ys[ly]\n                width = x_sorted[rx][0] - x_sorted[lx][0]\n                area = width * height\n                min_area = min(min_area, area)\n    \n    return min_area\n\n# Example usage for testing purposes:\nN = 5\nK = 3\npoints = [(1, 3), (2, 8), (3, 4), (5, 3), (6, 1)]\nprint(min_area_with_k_points(points, K))",
    "timestamp": "2025-08-13 14:12:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinRectangleArea {\n    public static int minArea(int[][] points, int N, int K) {\n        Arrays.sort(points, Comparator.comparingInt(a -> a[0]));\n        int[] xValues = new int[N];\n        int[] yValues = new int[N];\n        for (int i = 0; i < N; i++) {\n            xValues[i] = points[i][0];\n            yValues[i] = points[i][1];\n        }\n        Arrays.sort(yValues);\n\n        int minArea = Integer.MAX_VALUE;\n        for (int xi1 = 0; xi1 < N; xi1++) {\n            for (int xi2 = xi1; xi2 < N; xi2++) {\n                int minX = xValues[xi1];\n                int maxX = xValues[xi2];\n                int maxYIdx = 0;\n                int[] countInRange = new int[N];\n                for (int i = 0; i < N; i++) {\n                    if (xValues[xi1] <= points[i][0] && points[i][0] <= xValues[xi2]) {\n                        countInRange[Arrays.binarySearch(yValues, points[i][1])]++;\n                    }\n                }\n                int count = 0;\n                for (int minYi = 0; minYi < N; minYi++) {\n                    while (maxYIdx < N && count < K) {\n                        count += countInRange[maxYIdx];\n                        maxYIdx++;\n                    }\n                    if (count >= K) {\n                        int minY = yValues[minYi];\n                        int maxY = yValues[maxYIdx - 1];\n                        int area = (maxX - minX) * (maxY - minY);\n                        minArea = Math.min(minArea, area);\n                    }\n                    count -= countInRange[minYi];\n                }\n            }\n        }\n        return minArea;\n    }\n\n    public static void main(String[] args) {\n        int[][] points = {{1, 5}, {2, 6}, {1, 6}, {3, 4}};\n        int N = points.length;\n        int K = 3;\n        System.out.println(minArea(points, N, K));\n    }\n}",
    "timestamp": "2025-08-13 14:12:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compareX(const void *a, const void *b) {\n    return ((Point *)a)->x - ((Point *)b)->x;\n}\n\nint compareY(const void *a, const void *b) {\n    return ((Point *)a)->y - ((Point *)b)->y;\n}\n\nint minAreaRectangle(Point points[], int n, int k) {\n    qsort(points, n, sizeof(Point), compareX);\n\n    int minArea = (1 << 30);\n    for (int i = 0; i + k <= n; i++) {\n        for (int j = i + k - 1; j < n; j++) {\n            int leftX = points[i].x;\n            int rightX = points[j].x;\n\n            Point subPoints[j - i + 1];\n            for (int t = i; t <= j; t++) {\n                subPoints[t - i] = points[t];\n            }\n            int subN = j - i + 1;\n            qsort(subPoints, subN, sizeof(Point), compareY);\n\n            for (int l = 0; l + k <= subN; l++) {\n                for (int m = l + k - 1; m < subN; m++) {\n                    int bottomY = subPoints[l].y;\n                    int topY = subPoints[m].y;\n                    int area = (rightX - leftX) * (topY - bottomY);\n                    if (area < minArea) {\n                        minArea = area;\n                    }\n                }\n            }\n        }\n    }\n    return minArea;\n}\n\nint main() {\n    int n, k;\n    printf(\"Enter the number of points and the value of K: \");\n    scanf(\"%d %d\", &n, &k);\n\n    Point points[n];\n    printf(\"Enter the coordinates of the points: \\n\");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    int result = minAreaRectangle(points, n, k);\n    printf(\"Minimum possible area is: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:12:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minRectangleArea(N, K, points) {\n    const xs = points.map(p => p[0]).sort((a, b) => a - b);\n    const ys = points.map(p => p[1]).sort((a, b) => a - b);\n\n    let minArea = Infinity;\n\n    for (let xi = 0; xi <= N - K; xi++) {\n        for (let xj = xi + K - 1; xj < N; xj++) {\n            for (let yi = 0; yi <= N - K; yi++) {\n                for (let yj = yi + K - 1; yj < N; yj++) {\n                    const x1 = xs[xi];\n                    const x2 = xs[xj];\n                    const y1 = ys[yi];\n                    const y2 = ys[yj];\n\n                    let count = 0;\n                    for (const [x, y] of points) {\n                        if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {\n                            count++;\n                        }\n                    }\n\n                    if (count >= K) {\n                        const area = (x2 - x1) * (y2 - y1);\n                        minArea = Math.min(minArea, area);\n                    }\n                }\n            }\n        }\n    }\n\n    return minArea;\n}\n\n// Example usage:\n// const points = [[1, 1], [2, 3], [3, 4], [5, 1]];\n// console.log(minRectangleArea(4, 3, points)); // Output should be the minimum area",
    "timestamp": "2025-08-13 14:12:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_rectangle_area(points, K):\n    N = len(points)\n    min_area = float('inf')\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                for l in range(k+1, N):\n                    x_coords = [points[i][0], points[j][0], points[k][0], points[l][0]]\n                    y_coords = [points[i][1], points[j][1], points[k][1], points[l][1]]\n                    \n                    x_min, x_max = min(x_coords), max(x_coords)\n                    y_min, y_max = min(y_coords), max(y_coords)\n                    \n                    points_inside = sum(1 for p in points if x_min <= p[0] <= x_max and y_min <= p[1] <= y_max)\n                    \n                    if points_inside >= K:\n                        area = (x_max - x_min) * (y_max - y_min)\n                        min_area = min(min_area, area)\n    \n    return min_area if min_area != float('inf') else -1\n\n# Example usage\nN = 5\npoints = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\nK = 3\nresult = min_rectangle_area(points, K)\nprint(result)",
    "timestamp": "2025-08-13 14:13:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minRectangleArea(points, K) {\n    const N = points.length;\n    let minArea = Infinity;\n\n    for (let i = 0; i < N; i++) {\n        for (let j = i; j < N; j++) {\n            for (let k = 0; k < N; k++) {\n                for (let l = k; l < N; l++) {\n                    const x1 = Math.min(points[i][0], points[j][0]);\n                    const x2 = Math.max(points[i][0], points[j][0]);\n                    const y1 = Math.min(points[k][1], points[l][1]);\n                    const y2 = Math.max(points[k][1], points[l][1]);\n\n                    const pointsInside = points.filter(\n                        point => point[0] >= x1 && point[0] <= x2 && \n                                 point[1] >= y1 && point[1] <= y2\n                    );\n\n                    if (pointsInside.length >= K) {\n                        minArea = Math.min(minArea, (x2 - x1) * (y2 - y1));\n                    }\n                }\n            }\n        }\n    }\n\n    return minArea === Infinity ? -1 : minArea;\n}",
    "timestamp": "2025-08-13 14:13:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, K = map(int, data[idx:idx+2])\n    idx +=2\n    points = []\n    for _ in range(N):\n        x, y = map(int, data[idx:idx+2])\n        points.append((x, y))\n        idx +=2\n    \n    points.sort()\n    min_area = float('inf')\n    \n    for i in range(N):\n        for j in range(i + K - 1, N):\n            x_coords = points[i:j+1]\n            x_coords.sort()\n            ys = [y for x, y in x_coords]\n            ys.sort()\n            m = len(ys)\n            for t in range(m - K + 1):\n                y_min = ys[t]\n                y_max = ys[t + K - 1]\n                area = (x_coords[-1][0] - x_coords[0][0]) * (y_max - y_min)\n                if area < min_area:\n                    min_area = area\n    print(min_area)\n\nsolve()",
    "timestamp": "2025-08-13 14:13:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N, K;\n    let points = [];\n\n    rl.on('line', (line) => {\n        if (!N) {\n            [N, K] = line.split(' ').map(Number);\n        } else {\n            const [x, y] = line.split(' ').map(Number);\n            points.push({ x, y });\n            if (points.length === N) {\n                rl.close();\n            }\n        }\n    });\n\n    rl.on('close', () => {\n        points.sort((a, b) => a.x - b.x);\n        let minArea = Infinity;\n\n        for (let i = 0; i < N; i++) {\n            for (let j = i + K - 1; j < N; j++) {\n                const xPoints = points.slice(i, j + 1);\n                xPoints.sort((a, b) => a.y - b.y);\n                for (let k = 0; k <= xPoints.length - K; k++) {\n                    const y1 = xPoints[k].y;\n                    const y2 = xPoints[k + K - 1].y;\n                    const area = (points[j].x - points[i].x) * (y2 - y1);\n                    if (area < minArea) {\n                        minArea = area;\n                    }\n                }\n            }\n        }\n\n        console.log(minArea);\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:13:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nbool compareX(Point a, Point b) {\n    return a.x < b.x;\n}\n\nbool compareY(Point a, Point b) {\n    return a.y < b.y;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    sort(points.begin(), points.end(), compareX);\n    vector<int> x(N);\n    for (int i = 0; i < N; ++i) {\n        x[i] = points[i].x;\n    }\n\n    sort(points.begin(), points.end(), compareY);\n    vector<int> y(N);\n    for (int i = 0; i < N; ++i) {\n        y[i] = points[i].y;\n    }\n\n    int minArea = INT_MAX;\n    for (int xi1 = 0; xi1 < N; ++xi1) {\n        for (int xi2 = xi1; xi2 < N; ++xi2) {\n            for (int yi1 = 0; yi1 < N; ++yi1) {\n                for (int yi2 = yi1; yi2 < N; ++yi2) {\n                    int count = 0;\n                    int x1 = x[xi1], x2 = x[xi2];\n                    int y1 = y[yi1], y2 = y[yi2];\n                    for (int i = 0; i < N; ++i) {\n                        if (x1 <= points[i].x && points[i].x <= x2 &&\n                            y1 <= points[i].y && points[i].y <= y2) {\n                            ++count;\n                        }\n                    }\n                    if (count >= K) {\n                        int area = (x2 - x1) * (y2 - y1);\n                        minArea = min(minArea, area);\n                    }\n                }\n            }\n        }\n    }\n\n    cout << minArea << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:42:41"
  }
]