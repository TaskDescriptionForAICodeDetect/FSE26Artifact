[
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nvector<edge> ans;\n\nvoid kruskal(){\n  sort(all(es),cmp);\n  \n  init(V);\n  int res=0;\n  rep(i,E){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n      ans.push_back(e);\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n    ans.clear();\n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a,b,c});\n    }\n\n    kruskal();\n    \n    sort(all(ans),cmp);\n    \n    if(ans.size()%2==0)cout << (ans[ans.size()/2].cost+ans[ans.size()/2+1].cost)/2 << endl;\n    else cout << ans[ans.size()/2].cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge es[100000]; int used[100000];\nint V, E; vector<int>v;\nvoid kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V); v.clear();\n\trep(i, 100000)used[i] = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tv.push_back(e.cost);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\twhile (cin >> V >> E,V) {\n\t\tint x, y, z;\n\t\trep(i, E) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tes[i] = { x,y,z };\n\t\t}\n\t\tkruskal();\n\t\tdouble mid = 0;\n\t\trep(i, E) {\n\t\t\tif (used[i] == 0) {\n\t\t\t\tif (v.size() % 2) {\n\t\t\t\t\tmid = v[v.size() / 2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmid = (v[v.size() / 2] + v[v.size() / 2 - 1]) / (double)2;\n\t\t\t\t}\n\t\t\t\tif (mid <= es[i].cost)break;\n\t\t\t\telse v.push_back(es[i].cost);\n\t\t\t}\n\t\t}\n\t\tif (v.size() % 2) {\n\t\t\tmid = v[v.size() / 2];\n\t\t}\n\t\telse {\n\t\t\tmid = (v[v.size() / 2] + v[v.size() / 2 - 1]) / (double)2;\n\t\t}\n\t\tcout << mid << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nstruct UF{\n    vector<ll> d;\n    UF(ll size):d(size,-1){}\n    void init(){\n        fill(d.begin(),d.end(),-1);\n    }\n    bool u(ll x,ll y){\n        x = r(x); y = r(y);\n        if(x != y){\n            if(d[y] < d[x]) swap(x,y);\n            d[x] += d[y]; d[y] = x;\n        }\n        return x!=y;\n    }\n    bool f(ll x,ll y){\n        return r(x) == r(y);\n    }\n    ll r(ll x){\n        return d[x] < 0 ? x:d[x] = r(d[x]);\n    }\n    ll s(ll x){\n        return -d[r(x)];\n    }\n};\n\nll n,m;\nstruct edge{\n    ll u,v,cost;\n    edge(){}\n    edge(ll u,ll v,ll cost):u(u),v(v),cost(cost){}\n    bool operator < (const edge& e) const{\n        return cost < e.cost;\n    }    bool operator > (const edge& e) const{\n        return cost > e.cost;\n    }\n};\nll solve(){\n    ll res = LINF;\n    vector<ll> s(m),t(m),c(m);\n    vector<edge> edges(m);\n    for(int i = 0; i < m;i++){\n        ll s,t,c; cin >> s >> t >> c; s--; t--;\n        edges[i] = edge(s,t,c);\n    }\n    sort(edges.begin(),edges.end());\n    UF uf(n);\n    vector<int> f(m);\n    vector<ll> C;\n    for(int i = 0; i < m;i++){\n        if(uf.f(edges[i].u,edges[i].v)) continue;\n        f[i] = true;\n        uf.u(edges[i].u,edges[i].v);\n        C.push_back(edges[i].cost);\n    }\n    sort(C.begin(),C.end());\n    res = C[(n-1)/2];\n//    for(int i = 0; i < m;i++){\n//        if(edges[i].cost > res) break;\n//        if(f[i]) continue;\n//        C.clear();\n//        uf.init();\n//        C.push_back(edges[i].cost);\n//        uf.u(edges[i].u,edges[i].v);\n//        for(int j = 0; j < m;j++){\n//            if(i == j) continue;\n//            if(uf.f(edges[j].u,edges[j].v)) continue;\n//            uf.u(edges[j].u,edges[j].v);\n//            C.push_back(edges[j].cost);\n//        }\n//        if(uf.s(0) != n) continue;\n//        sort(C.begin(),C.end());\n//        res = min(res,C[(n-1)/2]);\n//    }\n    return res;\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n >> m,n|m){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint par[1000];\n\nstruct Edge {\n  int s, t, c;\n};\n\nbool operator<(const Edge &a, const Edge &b) {\n  return a.c < b.c;\n}\n\nint find(int v) {\n  if (v == par[v]) return v;\n  return par[v] = find(par[v]);\n}\n\nvoid unite(int u, int v) {\n  u = find(u);\n  v = find(v);\n  if (u == v) return;\n\n  par[u] = v;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m;\n  while(cin >> n >> m, n | m) {\n    iota(par, par + n, 0);\n    vector<Edge> e(m);\n    rep(i, m) {\n      cin >> e[i].s >> e[i].t >> e[i].c;\n      e[i].s--, e[i].t--;\n    }\n\n    sort(all(e));\n\n    vector<int> cost;\n    rep(i, m) {\n      if (find(e[i].s) != find(e[i].t)) {\n        unite(e[i].s, e[i].t);\n        cost.pb(e[i].c);\n      }\n    }\n\n    cout << cost[cost.size() / 2] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) { // size(x) > size(y)\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\n\nstruct edge {\n    int s, t;\n    int cost;\n    bool operator<(edge const& e) const {\n        return cost < e.cost;\n    }\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nedges kruskal (int V, edges& es) {\n    sort(es.begin(), es.end());\n    union_find uf(V);\n    edges res;\n    for(int i=0; i<es.size(); ++i) {\n        edge e = es[i];\n        if(!uf.same(e.s, e.t)) {\n            uf.unite(e.s, e.t);\n            res.push_back(e);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        edges es(m);\n        for(int i=0; i<m; ++i) {\n            cin >> es[i].s >> es[i].t >> es[i].cost;\n            es[i].s--;\n            es[i].t--;\n        }\n        auto res = kruskal(n, es);\n        cout << res[n/2-1].cost << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntemplate <typename T>\nstruct edge {\n    int from, to;\n    T cost;\n    edge(){}\n    edge(int _from, int _to, T _cost) : from(_from), to(_to), cost(_cost) {}\n    bool operator< (const edge& e) const {\n        return cost == e.cost ? (from == e.from ? to < e.to : from < e.from) : cost < e.cost;\n    }\n    bool operator> (const edge& e) const {\n        return cost == e.cost ? (from == e.from ? to > e.to : from > e.from) : cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nclass Prim {\nprivate:\n    const int n;\n    vector<vector<edge<T>>> G;\npublic:\n    Prim(int _n) : n(_n), G(_n) {}\n    // undirected\n    void addEdge(int u, int v, T c) {\n        G[u].emplace_back(u, v, c);\n        G[v].emplace_back(v, u, c);\n    }\n    T calc(int s = 0) {\n        T total_weight = 0;\n        vector<bool> visited(n);\n        int num_visited = 0;\n        priority_queue<edge<T>, vector<edge<T>>, greater<edge<T>>> pq;\n        pq.push(edge<T>(-1, s, 0));\n        vector<T> values;\n        while (!pq.empty() && num_visited < n) {\n            auto e = pq.top(); pq.pop();\n            if (visited[e.to]) continue;\n            total_weight += e.cost;\n            values.emplace_back(e.cost);\n            visited[e.to] = true;\n            num_visited++;\n            for (const auto& ne: G[e.to]) {\n                if (!visited[ne.to]) pq.push(ne);\n            }\n        }\n        sort(all(values));\n        return values[1 + (values.size() - 1)/2];\n    }\n};\n/* !!!!! T: ?????????????????????(int, double) !!!!! */\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        Prim<int> prim(n);\n        rep(i, m) {\n            int s, t, c;\n            cin >> s >> t >> c;\n            s--, t--;\n            prim.addEdge(s, t, c);\n        }\n        cout << prim.calc() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost<x.cost; }\n};\n\nclass Kruskal{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Kruskal(int a=0):n(a){ g.resize(n); }\n  \n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  vector<edge> MinSpanningTree(){\n    UF connect(n);\n    vector<edge> edges;\n    for(int v=0;v<n;v++){\n      for(edge e : g[v])edges.push_back(e);\n    }\n    sort(edges.begin(), edges.end());\n    \n    vector<edge> res;\n    for(edge e : edges){\n      if(!connect.same(e.from,e.to)){\n\tres.push_back(e);\n\tconnect.unite(e.from,e.to);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m, n){\n    Kruskal mst(n);\n\n    for(int i=0;i<m;i++){\n      int s,t,c;\n      cin >> s >> t >> c; s--; t--;\n      mst.AddEdge(s,t,c);\n    }\n    vector<edge> res = mst.MinSpanningTree();\n    cout << res[(n-1)/2].cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\nint n, m; tuple<int, int, int>x[1000000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0 && m == 0)break;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s, t, u; cin >> s >> t >> u; x[i] = make_tuple(u, s, t);\n\t\t}\n\t\tUnionFind UF(n + 1); int T = 1; if (n % 2 == 1)T = 2;\n\t\tsort(x, x + m); int cnt = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (UF.same(get<1>(x[i]), get<2>(x[i])) == false) {\n\t\t\t\tUF.unite(get<1>(x[i]), get<2>(x[i]));\n\t\t\t\tif (T == 1 && cnt2 == (n - 1) / 2) { cnt += get<0>(x[i]); }\n\t\t\t\tif (T == 2 && (cnt2 == (n - 1) / 2 || cnt2 == (n - 2) / 2)) { cnt += get<0>(x[i]); }\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt / T << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\n#define lf double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\nclass UnionFind\n{\nprivate:\n\tvector<int> par;\n\tvector<int> rank; \npublic:\n\tUnionFind(int n): par(n), rank(n)\n\t{\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint root(int x)\n\t{\n\t\tif (par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = root(par[x]);\n\t\t}\n\t}\n\tvoid unite(int x, int y)\n\t{\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\tif (rx == ry) return;\n\t\tif (rank[rx] > rank[ry]){\n\t\t\tpar[ry] = rx;\n\t\t}else{\n\t\t\tpar[rx] = ry;\n\t\t\tif (rank[rx] == rank[ry]) rank[ry]++;\n\t\t}\n\t}\n\tint same(int x, int y)\n\t{\n\t\treturn root(x) == root(y);\n\t}\n};\n\ntypedef struct {ll u, v, cost;} edge;\n\nint main(void)\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\twhile(cin>>n>>m, n>0){\n\t\tvector<edge> es(m);\n\t\trep(i, m){\n\t\t\tll s, t, c;\n\t\t\tcin>>s>>t>>c;\n\t\t\tes[i].u = s-1;\n\t\t\tes[i].v = t-1;\n\t\t\tes[i].cost = c;\n\t\t}\n\t\tUnionFind uf(n);\n\t\tvll ans;\n\t\tsort(es.begin(), es.end(),\n\t\t\t[](edge &x, edge &y){return x.cost < y.cost;});\n\t\trep(i, m){\n\t\t\tedge e = es[i];\n\t\t\tif (!uf.same(e.u, e.v)){\n\t\t\t\tuf.unite(e.u, e.v);\n\t\t\t\tans.pb(e.cost);\n\t\t\t}\n\t\t}\n\t\tcout << ans[ans.size()/2] << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nint kruskal(int lim){\n  sort(all(es),cmp);\n  \n  vector<int>res;\n\n  init(V);\n \n  rep(i,lim){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res.push_back(e.cost);\n    }\n  }\n  sort(all(res));\n  if(res.size()%2==0)return (res[res.size()/2-1]+res[res.size()/2])/2;\n  return res[res.size()/2];\n}\n\nbool ok(){\n  bool fg=true;\n  for(int i=0;i+1<V;i++){\n    fg&=same(i,i+1);\n  }\n  return fg;\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n  \n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a-1,b-1,c});\n    }\n\n    if(V==2){\n      cout << es[0].cost << endl;\n      continue;\n    }\n\n    int l=0,r=es.size(),ans=-1;\n    while(r-l>1){\n      int m=(l+r)/2;\n      int res=kruskal(m);\n\n      if(ok())r=m,ans=res;\n      else l=m;\n    }\n\n\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst int INF=1<<20;\n\n\nconst int M_N=200001;\n\nstruct UnionFind{\n    int par[M_N];\n    int rank[M_N];\n\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }\n        else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\nstruct edge { int from;int to;int cost;};\n\nint main(){\n    int n,m;\n    while(cin >> n >> m){\n        if(!n&&!m) break;\n        UnionFind uf; \n        uf.init(n+1);\n        vector<edge> v;\n        for (int i = 0; i < m; i++) {\n            int x,y,c;cin >> x >> y >> c;\n            v.pb({x,y,c});\n        }\n        sort(ALL(v),[](const edge &right ,const edge &left){ return right.cost<left.cost;});\n        int k=0;\n        for (int i = 0; i < m; i++) {\n            edge e=v[i];\n            if(uf.same(e.from,e.to)) continue;\n            uf.unite(e.from,e.to);\n            k++;\n            if(k==n/2){\n                cout << e.cost << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\n#define MAX (10010)\n\nclass UnionFind {\n  \n private:\n  int par[MAX];\n  int rank[MAX];\n  \n public:\n  void init() {\n    for(int i=0; i<MAX; i++) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x) {\n    if(par[x] == x) { return x; }\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    \n    if(x == y) return;\n    \n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x] ++;\n    }\n  }\n  \n  bool same(int x, int y) { return find(x) == find(y); }\n\n  UnionFind() { init(); }\n};\n\nstruct Edge {\n  int from, to, cost;\n  Edge(int f=-1, int t=-1, int c=-1)\n    : from(f), to(t), cost(c) {}\n};\n\nbool comp(const Edge& a, const Edge& b) {\n  return a.cost < b.cost;\n}\n\nint kruskal(vector<Edge>& edges) {\n\n  sort(edges.begin(), edges.end(), comp);\n  UnionFind uf;\n  vector<int> vec;\n  for(int i=0; i<edges.size(); i++) {\n    Edge e = edges[i];\n    if(!uf.same(e.from, e.to)) {\n      uf.unite(e.from, e.to);\n      vec.push_back(edges[i].cost);\n    }\n  }\n  sort(vec.begin(), vec.end());\n  \n  return vec[vec.size()/2];\n}\n\nint main() {\n  \n  int n, m;\n  while(cin >> n >> m && (n|m)) {\n    vector<Edge> es;\n    for(int i=0; i<m; i++) {\n      int s, t, c;\n      cin >> s >> t >> c; s--, t--;\n      es.push_back(Edge(s, t, c));\n    }\n    cout << kruskal(es) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_N 4000\n#define MAX_E 40000\n#include<algorithm>\nusing namespace std;\n \nstruct edge {int u,v,cost;};\n \nint ans[MAX_N],cnt;\n \nbool comp(const edge& e1, const edge& e2){\n  return e1.cost<e2.cost;\n}\n \nedge es[MAX_E];\nint V,E;\n \n \n \nint par[MAX_E];\nint rank[MAX_E];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x] = find (par[x]);\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return ;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n \n \n \nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n  for(int i=0;i<E;i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ans[cnt++]=e.cost;\n      unite(e.u,e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  int a,b,c;\n  while(cin>>V>>E&&V&&E){\n     \n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c;\n      a--;\n      b--;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n      /*\n      es[E+i].u=b;\n      es[E+i].v=a;\n      es[E+i].cost=c;\n      */\n    }\n    //E*=2;\n    cnt=0;\n    int x =kruskal();\n    //cout<<x/(V-1)<<endl;\n    if(cnt%2==0){\n      cout<<(ans[cnt/2]+ans[cnt/2-1])/2<<endl;\n    }\n    else cout<<ans[cnt/2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\n\nclass UnionFind {\n    vector<int> uni;\n    int n;\npublic:\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n};\n\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        vector<tuple<int, int, int>> v(m);\n        for (int i = 0; i < m; ++i) {\n            int s, t, c;\n            cin >> s >> t >> c;\n            s--; t--;\n            v[i] = make_tuple(c, s, t);\n        }\n        sort(v.begin(),v.end());\n        vector<int> e;\n        UnionFind uf(n);\n        for(auto &&i : v){\n            int c, s, t; tie(c, s, t) = i;\n            if(uf.unite(s, t)) e.emplace_back(c);\n        }\n        cout << e[(n-1)/2] << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1005;\nconst int MAXM=10005;\nint fa[MAXN];\npair< int, pair<int, int> > E[MAXM];\nint find(int x){\n    return fa[x]=fa[x]==x?x:find(fa[x]);\n}\nint main(){\n    int n, m;\n    while(cin>>n>>m&&(n||m)){\n        for(int i=1; i<=n; i++){\n            fa[i]=i;\n        }\n        for(int i=0, x, y, w; i<m; i++){\n            scanf(\"%d%d%d\",&x,&y,&w);\n            E[i]=make_pair(w,make_pair(x,y));\n        }\n        sort(E,E+m);\n        for(int i=0, cnt=0; i<m; i++){\n            int u=find(E[i].second.first);\n            int v=find(E[i].second.second);\n            int w=E[i].first;\n            if(u!=v){\n                fa[u]=v;\n                cnt++;\n                if(cnt*2>=n-1){\n                    printf(\"%d\\n\",w);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nvector<edge> es;\nint par[1000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x!=y) par[x]=y;\n}\nbool comp(const edge &x,const edge &y){\n\tif(x.cost!=y.cost) return x.cost<y.cost;\n\tif(x.from!=y.from) return x.from<y.from;\n\treturn x.to<y.to;\n}\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tinit(n);\n\t\tes.clear();\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\tsort(all(es),comp);\n\t\tint cnt=0;\n\t\tfor(auto e:es){\n\t\t\tif(same(e.from,e.to)) continue;\n\t\t\tunite(e.from,e.to);\n\t\t\tcnt++;\n\t\t\tif(cnt==n/2){\n\t\t\t\tcout<<e.cost<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n;\nint g[1005][1005];\nbool use_edge[1005][1005];\n\n\n\nconst int gmax_n = 1005;\n\nint par[gmax_n]; //ティツヲツェ\nint depth[gmax_n];//テヲツ慊ィテ」ツ?ョテヲツキツアテ」ツ??\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint main(){\n    int m;\n    while(cin >> n >> m, n){\n        pair<int, pair<int, int>> p[10005];\n        int ans = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            p[i] = make_pair(c,make_pair(a,b));\n        }\n        sort(p, p + m);\n\n        memset(use_edge, 0, sizeof(use_edge));\n        init(n);\n        rep(i,n / 2){\n            int a = p[i].second.first;\n            int b = p[i].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            unite(a,b);\n\n            set<int> s;\n            rep(i,n) s.insert(find(i));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[i].first);\n            }\n        }\n        init(n);\n        rep(i,n / 2){\n            int a = p[n - i - 1].second.first;\n            int b = p[n - i - 1].second.second;\n            unite(a,b);\n            set<int> s;\n            rep(i,n) s.insert(find(i));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[i].first);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge es[100000];\nint V, E; vector<int>v;\nvoid kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V); v.clear();\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tv.push_back(e.cost);\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\twhile (cin >> V >> E,V) {\n\t\tint x, y, z;\n\t\trep(i, E) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tes[i] = { x,y,z };\n\t\t}\n\t\tkruskal();\n\t\tcout << v[(V - 1) / 2] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef double Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to,cost;\n\t};\n\tvector<edge>G;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tint krk(){\n\t\tint sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\tint co=0;\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tco++;\n\t\t\t\tif(co==n/2)cout<<e.cost<<endl;\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tKRK krk(n);\n\t\twhile(m--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tkrk.add_edge(a,b,c);\n\t\t}\n\t\tkrk.krk();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass UnionFindTree{\nprivate:\n  int* mParent;\n  int* mRank;\n  int mSize;\n\npublic:\n  UnionFindTree(int n){\n    mSize = n;\n    mParent = new int[n];\n    mRank = new int[n];\n\n    for(int i=0; i < n; i++){\n      mParent[i] = i;\n      mRank[i] = 0;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] mParent;\n    delete[] mRank;\n  }\n\n  bool same(int lhs,int rhs){\n    return (find(lhs) == find(rhs) ? true : false);\n  }\n\n  int find(int pos){\n    if(pos == mParent[pos]) return pos;\n    return find(mParent[pos]);\n  }\n  \n  void unite(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    \n    if(lhs == rhs) return;\n    \n    if(mRank[lhs] > mRank[rhs]){\n      mParent[lhs] = rhs;\n      mRank[lhs] = 0;\n      mRank[rhs]++;\n    }\n    else{\n      mParent[rhs] = lhs;\n      mRank[rhs] = 0;\n      mRank[lhs]++;\n    }\n  }\n\n  int size() const{\n    return mSize;\n  }\n};\n\nclass State{\npublic:\n  int from;\n  int to;\n  int cost;\n  State(int _f,int _t,int _c) :\n    from(_f), to(_t), cost(_c) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int num_of_nodes;\n  int num_of_edges;\n  while(~scanf(\"%d %d\",&num_of_nodes,&num_of_edges)){\n    if(num_of_nodes == 0 && num_of_edges == 0) break;\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    for(int edge_idx = 0; edge_idx < num_of_edges; edge_idx++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      from--; to--;\n      que.push(State(from,to,cost));\n    }\n\n    UnionFindTree uft(num_of_nodes);\n\n    vector<int> log;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(!uft.same(s.from,s.to)){\n        uft.unite(s.from,s.to);\n        log.push_back(s.cost);\n      }\n    }\n\n    printf(\"%d\\n\",log[log.size()/2]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n#include <climits>\n\n//{{{ uf.hpp\n#ifndef INCLUDE_UF_HPP\n#define INCLUDE_UF_HPP\n#include <vector>\n#include <algorithm>\nnamespace orliv {\n//{{{ UF merge, same, root, size, count\nstruct UF {\n  std::vector<int> data;\n  int cnt;\n  UF(int n) : data(n, -1), cnt(n) {}\n  bool merge(int a, int b){\n    a = root(a);\n    b = root(b);\n    if (a != b){\n      cnt--;\n      if (data[b] < data[a]) std::swap(a, b);\n      data[a] += data[b];\n      data[b] = a;\n    }\n    return a != b;\n  }\n  bool same(int a, int b){ return root(a) == root(b); }\n  int root(int a){ return data[a] >= 0 ? data[a] = root(data[a]) : a; }\n  int size(int a){ return -data[root(a)]; }\n  int count(){ return cnt; }\n};\n//}}}\n}\n#endif\n//}}}\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\nnamespace orliv {\nstruct Edge {\n  typedef int weight_t;\n  int from, to;\n  weight_t w;\n  Edge(int from, int to, weight_t w) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& e) const {\n    return w != e.w ? w > e.w : from != e.from ? from < e.from : to < e.to;\n  }\n  static const weight_t INF;\n};\nconst int Edge::INF=INT_MAX;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orliv;\n\n//{{{ Edges kruskal(g)\nEdges kruskal(const Graph& g){\n  const int V = g.size();\n  int E = 0;\n  for (const auto& v : g) E += v.size();\n  Edges es;\n  es.reserve(E);\n  for (const auto& v : g){\n    for (const auto& e : v){\n      es.emplace_back(e);\n    }\n  }\n  sort(es.begin(), es.end());\n  reverse(es.begin(), es.end());\n  UF uf(V);\n  Edges result;\n  for (const auto& e : es){\n    if (uf.same(e.from, e.to)) continue;\n    uf.merge(e.from, e.to);\n    result.emplace_back(e);\n  }\n  return result;\n}\n//}}}\n\ntypedef long long ll;\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nint main()\n{\n  int N, M;\n  while (N = in(), M = in()){\n    Graph G(N);\n    for (int i = 0; i < M; i++){\n      int s = in() - 1, t = in() - 1, c = in();\n      G[s].emplace_back(s, t, c);\n      G[t].emplace_back(t, s, c);\n    }\n    Edges stree = kruskal(G);\n    cout << stree[N / 2 - 1].w << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n;\nint g[1005][1005];\nbool use_edge[1005][1005];\n\n\n\nconst int gmax_n = 1005;\n\nint par[gmax_n]; //ティツヲツェ\nint depth[gmax_n];//テヲツ慊ィテ」ツ?ョテヲツキツアテ」ツ??\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint main(){\n    int m;\n    while(cin >> n >> m, n){\n        pair<int, pair<int, int>> p[10005];\n        int ans = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            p[i] = make_pair(c,make_pair(a,b));\n        }\n        sort(p, p + m);\n\n        memset(use_edge, 0, sizeof(use_edge));\n        init(n);\n        rep(i, (m % 2 == 1 ? 1 : 0) + m / 2){\n            int a = p[i].second.first;\n            int b = p[i].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            unite(a,b);\n\n            set<int> s;\n            rep(j,n) s.insert(find(j));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[i].first);\n            }\n        }\n        init(n);\n        rep(i,m / 2){\n            int a = p[m - i - 1].second.first;\n            int b = p[m - i - 1].second.second;\n            unite(a,b);\n            set<int> s;\n            rep(j,n) s.insert(find(j));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[m - i - 1].first);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef double Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to,cost;\n\t};\n\tvector<edge>G;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tint krk(){\n\t\tint sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\tint co=0;\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tco++;\n\t\t\t\tif(co==n/2)cout<<e.cost<<endl;\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tKRK krk(n);\n\t\twhile(m--){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tkrk.add_edge(a,b,c);\n\t\t}\n\t\tkrk.krk();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nstruct UF{\n    vector<ll> d;\n    UF(ll size):d(size,-1){}\n    void init(){\n        fill(d.begin(),d.end(),-1);\n    }\n    bool u(ll x,ll y){\n        x = r(x); y = r(y);\n        if(x != y){\n            if(d[y] < d[x]) swap(x,y);\n            d[x] += d[y]; d[y] = x;\n        }\n        return x!=y;\n    }\n    bool f(ll x,ll y){\n        return r(x) == r(y);\n    }\n    ll r(ll x){\n        return d[x] < 0 ? x:d[x] = r(d[x]);\n    }\n    ll s(ll x){\n        return -d[r(x)];\n    }\n};\n\nll n,m;\nstruct edge{\n    ll u,v,cost;\n    edge(){}\n    edge(ll u,ll v,ll cost):u(u),v(v),cost(cost){}\n    bool operator < (const edge& e) const{\n        return cost < e.cost;\n    }    bool operator > (const edge& e) const{\n        return cost > e.cost;\n    }\n};\nll solve(){\n    ll res = LINF;\n    vector<ll> s(m),t(m),c(m);\n    vector<edge> edges(m);\n    for(int i = 0; i < m;i++){\n        ll s,t,c; cin >> s >> t >> c; s--; t--;\n        edges[i] = edge(s,t,c);\n    }\n    sort(edges.begin(),edges.end());\n    UF uf(n);\n    vector<int> f(m);\n    vector<ll> C;\n    for(int i = 0; i < m;i++){\n        if(uf.f(edges[i].u,edges[i].v)) continue;\n        f[i] = true;\n        uf.u(edges[i].u,edges[i].v);\n        C.push_back(edges[i].cost);\n    }\n    sort(C.begin(),C.end());\n    res = C[(n-1)/2];\n    for(int i = 0; i < m;i++){\n        if(edges[i].cost > res) break;\n        if(f[i]) continue;\n        C.clear();\n        uf.init();\n        C.push_back(edges[i].cost);\n        uf.u(edges[i].u,edges[i].v);\n        for(int j = 0; j < m;j++){\n            if(i == j) continue;\n            if(uf.f(edges[j].u,edges[j].v)) continue;\n            uf.u(edges[j].u,edges[j].v);\n            C.push_back(edges[j].cost);\n        }\n        if(uf.s(0) != n) continue;\n        sort(C.begin(),C.end());\n        res = min(res,C[(n-1)/2]);\n    }\n    \n//    for(auto e:edges){ cout << e.cost << \" \" ;\n//    }cout << endl;\n    return res;\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n >> m,n|m){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\n\ntemplate<typename T>\nT kruskal(const vector<edge<T>> &es, int V) {\n\n    UnionFind uf(V);\n    //T ret = 0;\n    vector<T> ret;\n\n    vector<int> ord(es.size());\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int i,int j){\n            return es[i].cost < es[j].cost;\n            });\n\n    for (auto i : ord) {\n        auto &e = es[i];\n        if (!uf.issame(e.src, e.to)) {\n            //ret += e.cost;\n            ret.emplace_back(e.cost);\n            uf.merge(e.src, e.to);\n        }\n    }\n\n    //return ret;\n    return ret[V/2-1];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) {\n            break;\n        }\n\n        vector<edge<int>> es(m);\n        for (int i = 0; i < m; ++i) {\n            int s, t, c; cin >> s >> t >> c;\n            --s, --t;\n            es[i] = { s, t, c };\n        }\n\n        int ans = kruskal(es, n);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN = 100000;\nstruct node{\n\tint u,v,dist;\n}a[MAXN + 10];\nint n,m;\nint fa[MAXN + 10];\nint cnt;\nint num[MAXN + 10];\nint tot;\n\nbool cmp(const node &x,const node &y){\n\treturn x.dist < y.dist;\n}\n\nint find(int x){\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) == 2 && n && m){\n\t\tcnt = 0;\n\t\ttot = 0;\n\t\tfor(int i = 1;i <= m;i++){\n\t\t\tint u,v,dist;\n\t\t\tscanf(\"%d%d%d\",&u,&v,&dist);\n\t\t\ta[++cnt].u = u;\n\t\t\ta[cnt].v = v;\n\t\t\ta[cnt].dist = dist;\n\t\t\ta[++cnt].v = u;\n\t\t\ta[cnt].u = v;\n\t\t\ta[cnt].dist = dist;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)\n\t\t\tfa[i] = i;\n\t\tsort(a + 1,a + cnt + 1,cmp);\n\t\tfor(int i = 1;i <= cnt;i++){\n\t\t\tint x = find(a[i].u);\n\t\t\tint y = find(a[i].v);\n\t\t\tif(x == y)\n\t\t\t\tcontinue;\n\t\t\tnum[++tot] = a[i].dist;\n\t\t\tfa[x] =y;\n\t\t}\n\t\tprintf(\"%d\\n\",num[(tot + 1) / 2]);\n\t}\n}//"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nvector<edge> ans;\n\nvoid kruskal(){\n  sort(all(es),cmp);\n  \n  init(V);\n  int res=0;\n  rep(i,E){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n      ans.push_back(e);\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n    ans.clear();\n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a,b,c});\n    }\n\n    kruskal();\n    \n    sort(all(ans),cmp);\n    \n    if(ans.size()%2==0)cout << (ans[ans.size()/2].cost+ans[ans.size()/2-1].cost)/2 << endl;\n    else cout << ans[ans.size()/2].cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\n\tvector<int> par;\n\tint find(int a) {\n\t\treturn par[a] < 0 ? a : par[a] = find(par[a]);\n\t}\npublic:\n\tunion_find(int n) : par(n, -1) {}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (par[a] < par[b]) {\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t}\n\t\telse {\n\t\t\tpar[b] += par[a];\n\t\t\tpar[a] = b;\n\t\t}\n\t}\n};\n\nstruct edge {\n\tint from, to;\n\tint cost;\n\tbool operator<(const edge& e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s, t, c;\n\t\t\tcin >> s >> t >> c; --s, --t;\n\t\t\tes.push_back((edge) { s, t, c });\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tvector<int> v;\n\t\tunion_find uf(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!uf.same(es[i].from, es[i].to)) {\n\t\t\t\tuf.unite(es[i].from, es[i].to);\n\t\t\t\tv.push_back(es[i].cost);\n\t\t\t}\n\t\t}\n\t\tcout << v[n / 2 - 1] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tint k;\n\tunion_find(int n) : v(n, -1), k(0) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t\tk++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<int> s(m), t(m), c(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> s[i] >> t[i] >> c[i];\n\t\t\ts[i]--; t[i]--;\n\t\t}\n\t\tfor (int C = 1; C <= 1000; C++) {\n\t\t\tunion_find ufs(n), ufe(n), ufg(n);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tif (c[i] <= C) ufs.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] > C) ufg.unite(s[i], t[i]);\n\t\t\tif (ufs.k >= n / 2 && ufg.k >= n / 2 - 1) {\n\t\t\t\tcout << C << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass UnionFindTree{\nprivate:\n  int* mParent;\n  int* mRank;\n  int mSize;\n\npublic:\n  UnionFindTree(int n){\n    mSize = n;\n    mParent = new int[n];\n    mRank = new int[n];\n\n    for(int i=0; i < n; i++){\n      mParent[i] = i;\n      mRank[i] = 0;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] mParent;\n    delete[] mRank;\n  }\n\n  bool same(int lhs,int rhs){\n    return (find(lhs) == find(rhs) ? true : false);\n  }\n\n  int find(int pos){\n    if(pos == mParent[pos]) return pos;\n    return find(mParent[pos]);\n  }\n  \n  void unite(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    \n    if(lhs == rhs) return;\n    \n    if(mRank[lhs] > mRank[rhs]){\n      mParent[lhs] = rhs;\n      mRank[rhs] += mRank[lhs];\n      mRank[lhs] = 0;\n    }\n    else{\n      mParent[rhs] = lhs;\n      mRank[lhs] += mRank[rhs];\n      mRank[rhs] = 0;\n    }\n  }\n\n  int size() const{\n    return mSize;\n  }\n};\n\nclass State{\npublic:\n  int from;\n  int to;\n  int cost;\n  State(int _f,int _t,int _c) :\n    from(_f), to(_t), cost(_c) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int num_of_nodes;\n  int num_of_edges;\n  while(~scanf(\"%d %d\",&num_of_nodes,&num_of_edges)){\n    if(num_of_nodes == 0 && num_of_edges == 0) break;\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    for(int edge_idx = 0; edge_idx < num_of_edges; edge_idx++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      from--; to--;\n      que.push(State(from,to,cost));\n    }\n\n    UnionFindTree uft(num_of_nodes);\n\n    vector<int> log;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(!uft.same(s.from,s.to)){\n        uft.unite(s.from,s.to);\n        log.push_back(s.cost);\n      }\n    }\n\n    printf(\"%d\\n\",log[log.size()/2]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n\n#define MAX_N 1000\n#define MAX_E 10000\n\nint N,E;\nint par[MAX_N+1],rank[MAX_N+1];\n \nstruct edge{\n    int from,to,cost;\n};\n \nbool cmp(const edge& e1,const edge& e2){\n    return e1.cost < e2.cost;\n}\n \nvoid init(int n){\n    for(int i = 0 ; i < n ; i++){\n\tpar[i] = i;\n\trank[i] = 0;\n    }\n}\n \nint find(int x){\n    if (par[x] == x) {\n\treturn x;\n    } else {\n\treturn par[x] = find(par[x]);\n    }\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n \n    if(x == y) return;\n    if (rank[x] < rank[y]) {\n\tpar[x] = y;\n    } else {\n\tpar[y] = x;\n\tif (rank[x] == rank[y]) {\n\t    rank[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return find(x) == find(y);\n}\n \nedge es[MAX_E+1];\n \nvoid kruskal(vector<int> &v){\n    sort(es ,es + E ,cmp);\n    init(N);\n \n    for(int i = 0 ; i < E ; i++){\n\tedge e = es[i];\n\tif (!same(e.from,e.to)) {\n\t    unite(e.from,e.to);\n\t    v.push_back(e.cost);\n\t}\n    }\n \n}\n \n \nint main(){\n    int a,b,c;\n    while(cin >> N >> E , N | E){\n\tfor(int i = 0 ; i < E ; i++){\n\t    cin >> a >> b >> c;\n  \n\t    es[i].from = --a;\n\t    es[i].to = --b;\n\t    es[i].cost = c;\n\t}\n \n\tvector<int> v;\n\tkruskal(v);\n \n\tint size = (int)v.size();\n\tcout << v[size/2] << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconstexpr long long INF = (long long)1e18;\nconstexpr long long MOD = 1'000'000'007; \n\nstruct fast_io {\n\tfast_io(){\n\t\tstd::cin.tie(nullptr);\n\t\tstd::ios::sync_with_stdio(false);\n\t};\n} fio;\n\nclass union_find\n{\n\tint  _setnum;\n\tvector<int> par, nume;\npublic:\n\tunion_find(){\n\t}\n\t\n\tunion_find(int x){\n\t\tpar.resize(x);\n\t\tnume.resize(x);\n\t\tinit();\n\t}\n\t\n\t~union_find(){\n\t\t//\n\t\t\n\t}\n\t\n\tvoid clear(){\n\t\t_setnum = 0;\n\t\tpar.clear();\n\t\tnume.clear();\n\t}\n\t\n\tvoid init(){\n\t\t_setnum = par.size();\n\t\tfor(int i = 0; i < par.size(); i++){\n\t\t\tpar[i] = i;\n\t\t\tnume[i] = 1;\n\t\t}\n\t}\n\t\n\tvoid resize(int x){\n\t\t\n\t\tpar.resize(x);\n\t\tnume.resize(x);\n\t\tinit();\n\t}\n\n\tint find(int x){\n\t\treturn par[x] == x ? x : par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\n\t\tif(x == y)return;\n\t\t\n\t\t_setnum--;\n\t\t\n\t\tif(nume[x] > nume[y]) std::swap(x,y);\n\t\t\n\t\tpar[x] = y;\n\t\tnume[y] += nume[x];\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tint numel(int x){\n\t\treturn nume[find(x)];\n\t}\n\t\n\tint size(){\n\t\treturn par.size();\n\t}\n\t\n\tint setnum(){\n\t\treturn _setnum;\n\t}\n};\n\nint kruskal(vector<pair<int,pair<int,int>>>& edge, int V){\n\tunion_find uf(V);\n\tvector<int> hoge;\n\tint res = 0, count = 0;\n\t\n\tsort(edge.begin(), edge.end());\n\t\n\tfor(int i = 0; i < edge.size(); i++){\n\t\tif(!uf.same(edge[i].second.first, edge[i].second.second)){\n\t\t\tuf.unite(edge[i].second.first, edge[i].second.second);\n\t\t\thoge.push_back(edge[i].first);\n\t\t\tres += edge[i].first;\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tsort(hoge.begin(), hoge.end());\n\t\n\tif(count == V-1) return hoge[(V-1)/2];\n\treturn -1;\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\t\n\twhile(true) {\n\t\tint n, m;\n\t\tvector<pair<int,pair<int,int>>> edge;\n\t\t\n\t\tcin>>n>>m;\n\t\t\n\t\tif(!n && !m) break;\n\t\n\t\n\t\tedge.resize(m);\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>edge[i].second.first>>edge[i].second.second>>edge[i].first;\n\t\t\tedge[i].second.first--;\n\t\t\tedge[i].second.second--;\n\t\t}\n\t\tcout<<kruskal(edge, n)<<endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nint Kruskal(const Graph& g,vector<Edge>& forest)\n{\n\tint n=g.size();\n\tvector<Edge> es;\n\trep(i,n) es.insert(end(es),all(g[i]));\n\tsort(all(es));\n\t\n\tUnionFind uf(n);\n\tint res=0;\n\tfor(auto e:es)\n\t\tif(uf.Unite(e.src,e.dst)){\n\t\t\tres+=e.weight;\n\t\t\tforest.push_back(e);\n\t\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w; u--,v--;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t}\n\t\tvector<Edge> tree;\n\t\tKruskal(g,tree);\n\t\tcout<<tree[n/2-1].weight<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n// run : ctrl + c \n\ntemplate<class T>bool chmax(T &a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate<class T>bool chmin(T &a,T b){if(b<a){a=b;return 1;} return 0;}\n\n// struct UnionFind{\n//     vector<int> par;\n//     Unionfind(int n){\n//         par = vector<int>(n,-1);\n//     }\n//     int root(int a){\n//         if(par[a]<0) return a;\n//         return par[a] = root(par[a]);\n//     }\n//     int size(int a){\n//         a = root(a);\n//         return -par[a];\n//     }\n//     bool unite(int a,int b){\n//         a = root(a);\n//         b = root(b);\n//         if(a==b) return false;\n\n//         if(par[b] < par[a]){\n//             swap(a,b);\n//         }\n//         par[a] += par[b];\n//         par[b] = a;\n//         return true;\n//     }\n//     bool same(int a,int b){\n//         a = root(a);\n//         b = root(b);\n//         return (a == b);\n//     }\n// };\n\nclass UnionFind{\n    public:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> parent;\n\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n    }\n\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    int size(int A){\n        return -parent[root(A)];\n    }\n\n    bool unite(int A, int B) {\n        A = root(A), B = root(B);\n        if(A == B) return false; \n\n        if(size(A) < size(B)) swap(A,B);\n        parent[A] += parent[B];\n        parent[B] = A;\n        return true;\n    }\n\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    \n    int n,m;\n    while(cin>>n>>m){\n        if(n==0) return 0;\n        array<int,3> d[m];\n        for(int i=0;i<m;i++){\n            int x,y,c;\n            cin>>x>>y>>c;\n            x--,y--;\n            d[i] = {c,x,y};\n        }\n        sort(d,d+m);\n        int cnt = 0;\n        UnionFind uni(n);\n        for(int i=0;i<m;i++){\n            if(uni.same(d[i][1],d[i][2])) continue;\n            cnt++;\nuni.unite(d[i][1],d[i][2]);\n            if(cnt == n/2){\n                cout << d[i][0] << endl;\n                break;\n            }\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint from, to, cost;\n\tedge(int a, int b, int c){\n\t\tfrom = a, to = b, cost = c;\n\t}\n\tbool operator<(const edge& e){\n\t\treturn this->cost < e.cost;\n\t}\n};\n\nint n, m;\nvector<edge> G;\n\nint parent[1005];\nvoid init(){\n\tfor(int i = 0; i < n; i++) parent[i] = i;\n}\n\nint root(int i){\n\tif(i == parent[i]) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j){\n\tint root_i = root(i);\n\tint root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tG.clear();\n\t\t\n\t\tint s, t, c;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> s >> t >> c;\n\t\t\tG.push_back( edge(s, t, c) );\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\t\n\t\tinit();\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(same(G[i].from, G[i].to)) continue;\n\t\t\tunite(G[i].from, G[i].to);\n\t\t\tcnt++;\n\t\t\tif(cnt == n/2){\n\t\t\t\tcout << G[i].cost << endl;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct edge{\n\tint f,t,c;\n\tedge(){}\n\tedge(int ff,int tt ,int cc){\n\t\tf=ff;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge &e)const{\n\t\treturn c<e.c;\n\t}\n};\n\nint n,m;\nbool used[1001];\nedge e[10001];\nint par[1001];\nint rank[1001];\n\nvoid init(int v){\n\tfor(int i=0;i<v;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\n\nint find(int x){\n\tif(x==par[x])return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int a,int b){\n\ta=find(a);\n\tb=find(b);\n\tif(rank[a]<rank[b]){\n\t\tpar[a]=b;\n\t}else{\n\t\tpar[b]=a;\n\t\tif(rank[a]==rank[b])rank[a]++;\n\t}\n}\n\nbool same(int a,int b){\n\treturn find(par[a])==find(par[b]);\n}\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d %d %d\",&e[i].f,&e[i].t,&e[i].c);\n\t\t\te[i].f--;\n\t\t\te[i].t--;\n\t\t}\n\t\tsort(e,e+m);\n\t\tinit(n);\n\t\tint cnt=0,res=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(e[i].f,e[i].t)){\n\t\t\t\tunite(e[i].f,e[i].t);\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==n/2)res=e[i].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i = a; i < b; i++)\n#define REP(i,b) FOR(i,0,b)\n#define RFOR(i,a,b) for (int i = a-1; i >= b; i--)\n#define RREP(i,a) RFOR(i,a,0)\n#define REPALL(i,v) for (int i = 0; i < v.size(); i++)\n#define RREPALL(i,v) for (int i = v.size()-1; i >= 0; i--)\n#define ALL(v) v.begin(), v.end()\n#define SORT(v) sort(v.begin(), v.end())\n#define MIN_ELEMENT(v) min_element(v.begin(), v.end())\n#define MAX_ELEMENT(v) max_element(v.begin(), v.end())\n#define COUNT(v,n) count(v.begin(), v.end(), n)\nvoid YES(bool flag) {cout<<(flag ? \"YES\" : \"NO\")<<endl;}\nvoid Yes(bool flag) {cout<<(flag ? \"Yes\" : \"No\")<<endl;}\nvoid yes(bool flag) {cout<<(flag ? \"yes\" : \"no\")<<endl;}\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1e7;\nconst ll MOD = 1e9 + 7;\n\n//蟻本，螺旋本参考\n//DisjointSet\n//整数配列に対応\nclass UnionFindTree {\npublic:\n    vector<int> rank, p;\n\n    UnionFindTree() {}\n\n    UnionFindTree(int size) {\n        rank.resize(size, 0);\n        p.resize(size, 0);\n        for (int i = 0; i < size; ++i) {\n            makeSet(i);\n        }\n    }\n\n    void makeSet(int x)\n    {\n        p[x] = x;\n        rank[x] = 0;\n    }\n\n    bool same(int x, int y)\n    {\n        return findSet(x) == findSet(y);\n    }\n\n    void unite(int x, int y)\n    {\n        link(findSet(x), findSet(y));\n    }\n\n    void link(int x, int y)\n    {\n        if (rank[x] > rank[y]) {\n            p[y] = x;\n        } else {\n            p[x] = y;\n            if (rank[x] == rank[y]) {\n                rank[y]++;\n            }\n        }\n    }\n\n    int findSet(int x)\n    {\n        if (x != p[x]) {\n            p[x] = findSet(p[x]);\n        }\n        return p[x];\n    }\n\n    int maxUnion()\n    {\n        int size = p.size();\n        int r = 0;\n        REP(i,size) {\n            r = max(r, (int)count(p.begin(), p.end(), i));\n        }\n        return r;\n    }\n};\n\nint n, m;\nvector<bool> used;\nmultimap<int, pair<int, int>> d;\n\nvoid solve()\n{\n    int cnt = 0;\n    used.resize(n, false);\n    UnionFindTree uf(n);\n    REP(i,m) {\n        int s, t, c;\n        cin>>s>>t>>c;\n        d.insert({c, {s-1, t-1}});\n    }\n\n    for (auto itr : d) {\n        //cout<<\"_\"<<itr.first<<\"_\"<<itr.second.first<<\",\"<<itr.second.second<<endl;\n        if (!uf.same(itr.second.first,itr.second.second)) {\n            uf.unite(itr.second.first,itr.second.second);\n            cnt++;\n        }\n\n        if (cnt == n / 2) {\n            cout<<itr.first<<endl;\n            d.clear();\n            return;\n        }\n    }\n}\n\nint main()\n{\n    while (cin>>n>>m, n != 0) {\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI a[1010];\nbool used[1010];\nsigned main(void)\n{\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, m) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      x--, y--;\n      a[i] = {z, x, y};\n    }\n    sort(a, a+m);\n    if(n == 2) { cout << a[0][0] << endl; continue; }\n\n    int ans;\n    memset(used, false, sizeof(used));\n    REP(i, n/2) used[a[i][0]] = used[a[i][1]] = true;\n    FOR(i, n/2, m) {\n      used[a[i][0]] = true;\n      used[a[i][1]] = true;\n      int cnt = 0;\n      REP(i, n) if(used[i]) cnt++;\n      // cout << i << \" \" << cnt << endl;\n      if(cnt >= n/2) {\n        ans = a[i-1][0];\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 10010\n\nusing namespace std;\n\nstruct Data{\n  int from,to,cost;\n  Data(int from=-1,int to=-1,int cost=-1):from(from),to(to),cost(cost){}\n};\n\nbool cmp(const Data& p1,const Data& p2){ return p1.cost < p2.cost; }\n\nint par[MAX+1];\n\nvoid init(){ rep(i,MAX)par[i] = i; }\n\nint find(int x){\n  if( x == par[x] )return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x);\n  y = find(y);\n  if( x != y)par[x] = y;\n}\n\nbool same(int x,int y){ return find(x) == find(y); }\n\nint kruskal(vector<Data>& G){\n  sort(G.begin(),G.end(),cmp);\n  init();\n  vector<int> vec;\n  for(int i=0;i<G.size();i++){\n    Data data = G[i];\n    if(!same(data.from,data.to)){\n      unit(data.from,data.to);\n      vec.push_back(G[i].cost);\n    }\n  }\n\n  sort(vec.begin(),vec.end());\n  int len = vec.size();\n\n  return vec[len/2];\n\n}\n\n\nint n,m;\n\nint main(){\n\n  while(cin >> n >> m,n|m){\n    vector<Data> G;\n    rep(i,m){\n      int s,t,c;\n      cin >> s >> t >> c;\n      s--,t--;\n      G.push_back(Data(s,t,c));\n    }\n    cout << kruskal(G) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<cassert>\n#include<climits>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 10010\n \nusing namespace std;\n \nstruct Data{\n  int from,to,cost;\n  Data(int from=-1,int to=-1,int cost=-1):from(from),to(to),cost(cost){}\n};\n \nbool cmp(const Data& p1,const Data& p2){ return p1.cost < p2.cost; }\n \nint par[MAX+1];\n \nvoid init(){ rep(i,MAX)par[i] = i; }\n \nint find(int x){\n  if( x == par[x] )return x;\n  return par[x] = find(par[x]);\n}\n \nvoid unit(int x,int y){\n  x = find(x);\n  y = find(y);\n  if( x != y)par[x] = y;\n}\n \nbool same(int x,int y){ return find(x) == find(y); }\n \nint kruskal(vector<Data>& G){\n  sort(G.begin(),G.end(),cmp);\n  init();\n  vector<int> vec;\n  for(int i=0;i<G.size();i++){\n    Data data = G[i];\n    if(!same(data.from,data.to)){\n      unit(data.from,data.to);\n      vec.push_back(G[i].cost);\n    }\n  }\n \n  sort(vec.begin(),vec.end());\n  int len = vec.size();\n \n  return vec[len/2];\n \n}\n \n \nint n,m;\n \nint main(){\n \n  while(cin >> n >> m,n|m){\n    vector<Data> G;\n    rep(i,m){\n      int s,t,c;\n      cin >> s >> t >> c;\n      s--,t--;\n      G.push_back(Data(s,t,c));\n    }\n    cout << kruskal(G) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct edge {\n  int f;\n  int t;\n  int c;\n};\nint main() {\n  while (1) {\n    int N, M; cin >> N >> M;\n    if (!N)break;\n    vector<edge>es(N);\n    for(int i = 0; i < M; ++i) {\n      int f, t, c; cin >> f >> t >> c;\n      f--; t--;\n      es.push_back(edge{ f,t,c });\n    }\n    UnionFind uf(N);\n    sort(es.begin(), es.end(), [](const edge&l, const edge&r) {return l.c < r.c; });\n    vector<int>nums;\n    for (int e = 0; e < es.size(); ++e) {\n      int f = es[e].f;\n      int t = es[e].t;\n      if (uf.root(f) == uf.root(t))continue;\n      else {\n        uf.unionSet(f, t);\n        nums.push_back(es[e].c);\n      }\n    }\n    int ans = nums[N / 2-1];\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nint n, m;\nvector<P3> es;\n\nint kruskal(){\n    sort(es.begin(), es.end());\n    UnionFindTree g;\n    g.init(n);\n    vector<int> ls;\n    for(auto e : es){\n        int u = e.second.first, v = e.second.second;\n        if(!g.is_same(u, v)){\n            g.unite(u,v);\n            ls.push_back(e.first);\n        }\n    }\n    sort(ls.begin(), ls.end());\n    return ls[n/2-1];\n}\n\nint main() {\n    while(cin >> n >> m, n){\n        es.clear();\n        for(int i=0;i<m;i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            es.push_back({c,{a,b}});\n        }\n        cout << kruskal() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint solve(int n, vector< vector< pair<int,int> > > &G){\n  vector<bool> connected(n,false);\n  priority_queue< pair<int,int> > wait;\n  vector<int> costs;\n  wait.emplace(0,0);\n  while(!wait.empty()){\n    int c = -wait.top().first, v = wait.top().second;\n    wait.pop();\n    if(connected[v]) continue;\n    connected[v] = true;\n    costs.push_back(c);\n    for(int i = 0; i < G[v].size(); ++i){\n      int v_ = G[v][i].first, c_ = G[v][i].second;\n      if(!connected[v_]){\n        wait.emplace(-c_,v_);\n      }\n    }\n  }\n  sort(costs.begin(),costs.end());\n  return costs[n/2];\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< vector< pair<int,int> > > G(n);\n    int s, t, c;\n    for(int i = 0; i < m; ++i){\n      cin >> s >> t >> c;\n      --s;--t;\n      G[s].emplace_back(t,c);\n      G[t].emplace_back(s,c);\n    }\n\n    cout << solve(n,G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nstruct edge{\n    int s,t,c;\n    edge(int s,int t,int c):s(s),t(t),c(c){}\n    bool operator<(const edge& other)const{ return c<other.c; }\n};\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<edge> edges;\n        rep(i,0,m){\n            int s,t,c;\n            cin >> s >> t >> c;\n            --s;\n            --t;\n            edges.emplace_back(edge(s,t,c));\n        }\n        sort(edges.begin(),edges.end());\n        union_find uf(n);\n        vector<int> costs;\n        for(const auto& e:edges) if(!uf.is_same(e.s,e.t)){\n            uf.unite(e.s,e.t);\n            costs.emplace_back(e.c);\n        }\n        cout << costs[max(0,(n-2)/2)] << endl;\n    }\n}\n\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\nclass DisjointSet{\nprivate:\n  vector< int > rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    } else {\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++) p[i] = i, rank[i] = 0;\n  }\n  void Union(int x,int y){\n    if(Find(x) != Find(y)) link(Find(x),Find(y));\n  }\n  int Find(int x){\n    return( x != p[x] ? p[x] = Find(p[x]) : p[x]);\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< edge > edges;\n    for(int i = 0; i < m; i++){\n      int s, t, c;\n      cin >> s >> t >> c;\n      edges.push_back((edge){ s - 1, t - 1, c});\n    }\n    sort(edges.begin(), edges.end());\n    DisjointSet UnionFind(n);\n    vector< int > cost;\n    for(int i = 0; i < edges.size(); i++){\n      edge& e = edges[i];\n      if(UnionFind.Find(e.u) != UnionFind.Find(e.v)){\n        UnionFind.Union( e.u, e.v);\n        cost.push_back(e.cost);\n      }\n    }\n    if(cost.size() % 2 == 0){\n      cout << (cost[cost.size() / 2] + cost[cost.size() / 2 + 1]) / 2 << endl;\n    } else {\n      cout << cost[cost.size() / 2] << endl;\n    }\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct edge{\n\tint s, t, c;\n\tbool operator< (const edge &e) const{\n\t\treturn c < e.c;\n\t}\n} e[10000];\n\nint par[10001];\n\nint find(int x){\n\treturn x != par[x] ? par[x] = find(par[x]) : x;\n}\n\nint main(){\n\tint n, m;\n\twhile( scanf(\"%d%d\", &n, &m) != EOF && n != 0 ){\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &e[i].s, &e[i].t, &e[i].c);\n\t\t}\n\n\t\tsort(e, e + m);\n\n\t\tint u = n / 2;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint x = find(e[i].s);\n\t\t\tint y = find(e[i].t);\n\t\t\tif( x == y ) continue;\n\t\t\tpar[x] = y;\n\n\t\t\tif( --u == 0 ){\n\t\t\t\tprintf(\"%d\\n\", e[i].c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par, rank;\n\tUF() { rank = vector<int>(um, 0); for (int i = 0; i<um; i++) par.push_back(i); }\n\tint operator[](int x) { return (par[x] == x) ? (x) : (par[x] = operator[](par[x])); }\n\tint operator()(int x, int y) {\n\t\tif ((x = operator[](x)) == (y = operator[](y))) return x;\n\t\tif (rank[x]>rank[y]) return par[x] = y;\n\t\trank[x] += rank[x] == rank[y]; return par[y] = x;\n\t}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (1)\n\t{\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) return 0;\n\t\t\n\t\tvector< pair<int, int> > E;\n\t\trep(i, 0, m)\n\t\t{\n\t\t\tint s, t, c;\n\t\t\tcin >> s >> t >> c;\n\t\t\ts--;\n\t\t\tt--;\n\t\t\tE.push_back(make_pair(c, s * 1000 + t));\n\t\t}\n\n\t\tsort(E.begin(), E.end());\n\n\t\tUF<1010> uf;\n\t\tvector<int> costs;\n\t\tint cnt = 0;\n\n\t\tfor (auto p : E)\n\t\t{\n\t\t\tint s = p.second / 1000;\n\t\t\tint t = p.second % 1000;\n\t\t\tint c = p.first;\n\n\t\t\tif (uf[s] == uf[t]) continue;\n\t\t\t\n\t\t\tuf(s, t);\n\t\t\tcosts.push_back(c);\n\t\t\tcnt++;\n\n\t\t\tif (cnt == n - 1) break;\n\t\t}\n\n\t\tsort(costs.begin(), costs.end());\n\t\tcout << costs[n / 2 - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct Edge{\n    int from,to,cost;\n    Edge(int from,int to,int cost): from(from), to(to), cost(cost){}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool operator < (const Edge &e, const Edge &f){\n    return e.cost < f.cost;\n}\n\nstruct UF {\n\tvector<int> data;\n\tUF(int size) : data(size, -1) { }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;\n    while(cin>>n>>m,n){\n        UF uf(n);\n        Edges es;\n        vector<int> ans;\n        for(int i=0;i<m;i++){\n            int st,gt,c;cin>>st>>gt>>c;\n            st--;gt--;\n            es.push_back(Edge(st,gt,c));\n        }\n        sort(es.begin(),es.end());\n        for(int i=0;i<m;i++){\n            int st=es[i].from,gt=es[i].to;\n            if(!uf.find(st,gt)){\n                uf.unite(st,gt);\n                ans.push_back(es[i].cost);\n            }\n        }\n        cout<<ans[(n-1)/2]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct unionfind{\n  vector<int> p;\n  unionfind(int n){\n    p = vector<int>(n, -1);\n  }\n  int root(int x){\n    if (p[x] == -1){\n      return x;\n    } else {\n      p[x] = root(p[x]);\n      return p[x];\n    }\n  }\n  bool same(int x, int y){\n    return root(x) == root(y);\n  }\n  void unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    p[x] = y;\n  }\n};\nint main(){\n  while (1){\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0){\n      break;\n    }\n    vector<tuple<int, int, int>> E(m);\n    for (int i = 0; i < m; i++){\n      int s, t, c;\n      cin >> s >> t >> c;\n      s--;\n      t--;\n      E[i] = make_tuple(c, s, t);\n    }\n    sort(E.begin(), E.end());\n    unionfind UF(n);\n    int cnt = 0;\n    for (int i = 0; i < m; i++){\n      int c = get<0>(E[i]);\n      int s = get<1>(E[i]);\n      int t = get<2>(E[i]);\n      if (!UF.same(s, t)){\n        UF.unite(s, t);\n        cnt++;\n        if (cnt == n / 2){\n          cout << c << endl;\n          break;\n        }\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2536.cc: Median Tree\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int MAX_M = 10000;\n\n/* typedef */\n\nstruct UFT {\n  int links[MAX_N], ranks[MAX_N], sizes[MAX_N];\n\n  void clear(int n) {\n    for (int i = 0; i < n; i++) links[i] = i, ranks[i] = sizes[i] = 1;\n  }\n\n  UFT() {}\n  UFT(int n) { clear(n); }\n\n  int root(int i) {\n    int i0 = i;\n    while (links[i0] != i0) i0 = links[i0];\n    return (links[i] = i0);\n  }\n\n  int rank(int i) { return ranks[root(i)]; }\n  int size(int i) { return sizes[root(i)]; }\n  bool same(int i, int j) { return root(i) == root(j); }\n\n  int merge(int i0, int i1) {\n    int r0 = root(i0), r1 = root(i1), mr;\n    if (ranks[r0] == ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      ranks[r0]++;\n      mr = r0;\n    }\n    else if (ranks[r0] > ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      mr = r0;\n    }\n    else {\n      links[r0] = r1;\n      sizes[r1] += sizes[r0];\n      mr = r1;\n    }\n    return mr;\n  }\n};\n\nstruct Edge {\n  int u, v, c;\n  Edge() {}\n  Edge(int _u, int _v, int _c): u(_u), v(_v), c(_c) {}\n  bool operator<(const Edge &e) const { return c < e.c; }\n};\n\n/* global variables */\n\nUFT uft;\nEdge es[MAX_M];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0) break;\n\n    for (int i = 0; i < m; i++) {\n      cin >> es[i].u >> es[i].v >> es[i].c;\n      es[i].u--, es[i].v--;\n    }\n    sort(es, es + m);\n\n    uft.clear(n);\n    int en = 0, me = (n - 1) / 2, ans = -1;\n\n    for (int i = 0; i < m; i++) {\n      Edge &ei = es[i];\n      int ru = uft.root(ei.u);\n      int rv = uft.root(ei.v);\n      if (ru != rv) {\n\tuft.merge(ei.u, ei.v);\n\tif (en == me) {\n\t  ans = ei.c;\n\t  break;\n\t}\n\ten++;\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nsigned main(){\n    int N,M;\n    while(cin>>N>>M,N||M){\n        vector<tuple<int,int,int>>es;\n        rep(i,M){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            es.pb(make_tuple(c,a,b));\n        }\n        sort(all(es));\n        int cnt=0;\n        UF uf;uf.init(N);\n        rep(i,M){\n            int c,a,b;\n            tie(c,a,b)=es[i];\n            if(uf.same(a,b))continue;\n            uf.unite(a,b);\n            cnt++;\n            if(cnt==N/2){\n                cout<<c<<endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nvector<edge> ans;\n\nvoid kruskal(){\n  sort(all(es),cmp);\n  \n  init(V);\n  int res=0;\n  rep(i,E){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n      ans.push_back(e);\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n    ans.clear();\n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a,b,c});\n    }\n\n    kruskal();\n    \n    sort(all(ans),cmp);\n    \n    cout << ans[ans.size()/2].cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass unionfind{\npublic:\n    vector<int> v;\n    vector<int> rank;\n\n    unionfind(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int find(int x){\n        if(v[x] != x){\n            v[x] = find(v[x]);\n        }\n        return v[x];\n    }\n    void marge(int a, int b){\n        a = find(a);\n        b = find(b);\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nstruct edge{\n    int s,t;\n    int cost;\n    edge(int s, int t, int c):s(s), t(t), cost(c){}\n    edge(){}\n    bool operator < (const edge &a) const{\n        return cost < a.cost;\n    }\n};\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        vector<edge> ve(m);\n        for(int i=0; i<m; i++){\n            int s,t,c;\n            cin >> s >> t >> c;\n            s--; t--;\n            ve[i] = edge(s,t,c);\n        }\n        sort(ve.begin(), ve.end());\n\n        unionfind uf(n);\n        int count = 0;\n        for(int i=0; i<m; i++){\n            if(uf.find(ve[i].s) != uf.find(ve[i].t)){\n                uf.marge(ve[i].s, ve[i].t);\n                count++;\n                if(count == n/2){\n                    cout << ve[i].cost << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass uf{\npublic:\n  uf();\n  uf(int _n){\n    init(_n);\n  }\n  void init(int _n){\n    n = _n;\n    rank.resize(n);\n    parent.resize(n);\n    for (int i = 0; i < n; i++) {\n      rank[i] = 0;\n      parent[i] = i;\n    }\n  }\n  int find(int x){\n    if(x == parent[x])return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      parent[x] = y;\n    }else{\n      parent[y] = x;\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\nprivate:\n  int n;\n  vector<int> rank, parent;\n};\n\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge &e)const{\n    return cost < e.cost;\n  }\n};\n\nvector<edge> kruskal(vector<edge> &es, int v){\n  sort(es.begin(), es.end());\n  uf u(v);\n  vector<edge> res;\n  for (int i = 0; i < es.size(); i++) {\n    edge &e = es[i];\n    if(!u.same(e.u, e.v)){\n      u.unite(e.u, e.v);\n      res.push_back(es[i]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, m;\n  while(std::cin >> n >> m, n){\n    vector<edge> ve(m);\n    for (int i = 0; i < m; i++) {\n      std::cin >> ve[i].u >> ve[i].v >> ve[i].cost;\n      ve[i].u--;ve[i].v--;\n    }\n    vector<edge> ans = kruskal(ve, n);\n    std::cout << ans[(n - 1)/2].cost << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int size(int x){ return -data[find(x)]; }\n  int find(int x){ return data[x] < 0 ? x : data[x] = find(data[x]); }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] < data[y]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return -data[x];\n  }\n};\n\nstruct edge {\n  int u, v, cost;\n  edge(){}\n  edge(int u, int v, int cost):u(u), v(v), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nvector<edge> E;\nint n, m;\n\nint Kruskal()\n{\n  sort(E.begin(), E.end());\n  UnionFind uf(n);\n  int cnt = 0;\n  for(int i = 0; i < E.size(); i++) {\n    edge& e = E[i];\n    if(!uf.same(e.u, e.v)) {\n      uf.unite(e.u, e.v);\n      if(++cnt == n/2) return e.cost;\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m) {\n    E.clear();\n    for(int i = 0; i < m; i++) {\n      int s, t, c;\n      cin >> s >> t >> c;\n      --s, --t;\n      E.push_back(edge(s, t, c));\n    }\n    cout << Kruskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_N 4000\n#define MAX_E 40000\n#include<algorithm>\nusing namespace std;\n\nstruct edge {int u,v,cost;};\n\nint ans[MAX_N],cnt;\n\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V,E;\n\n\n\nint par[MAX_E];\nint rank[MAX_E];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x] = find (par[x]);\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return ;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\n\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n  for(int i=0;i<E;i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ans[cnt++]=e.cost;\n      unite(e.u,e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  int a,b,c;\n  while(cin>>V>>E&&V&&E){\n    \n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n      /*\n      es[E+i].u=b;\n      es[E+i].v=a;\n      es[E+i].cost=c;\n      */\n    }\n    //E*=2;\n    cnt=0;\n    kruskal();\n    cout<<ans[cnt/2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxn =10006;\n\nint rank[maxn];\nint v[maxn];\n\nvoid make_set(int x)\n{\n    v[x]=x;\n    rank[x]=0;\n}\n\nint find_set(int x)\n{\n    if(v[x]!=x) v[x]=find_set(v[x]);\n    return v[x];\n}\n\nvoid Union(int x,int y)\n{\n    if(rank[x]>rank[y])\n        v[y]=x;\n    else if(rank[x]<rank[y])\n        v[x]=y;\n    else if(rank[y]==rank[x])\n    {\n        v[x]=y;\n        rank[y]++;\n    }\n}\n\nstruct Edge\n{\n    int x,y,w;\n}e[maxn];\n\nbool cmp(Edge e1,Edge e2)\n{\n    return e1.w<e2.w;\n}\nint main()\n{\n    int n,m;\n    while(cin>>n>>m,n||m)\n    {\n        for(int i=0;i<m;i++)\n            cin>>e[i].x>>e[i].y>>e[i].w;\n        sort(e,e+m,cmp);\n        for(int i=1;i<=n;i++) v[i]=i;\n        int s1,s2;\n        vector<int>ans;\n        for(int i=0;i<m;i++)\n        {\n            s1=find_set(e[i].x);\n            s2=find_set(e[i].y);\n            if(s1!=s2)\n            {\n                ans.push_back(e[i].w);\n                Union(s1,s2);\n            }\n        }\n        sort(ans.begin(),ans.end());\n        cout<<ans[ans.size()/2]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int> T;\n\nconst int MAX_N = 1010;\n\nint n, m;\n\nint par[MAX_N];\nint ranks[MAX_N];\nint ufSize;\n\nvoid init(int n){\n    ufSize = n;\n    for(int i=0; i<n; i++){\n        par[i] = i;\n        ranks[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }\n    else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    ufSize--;\n\n    if(ranks[x] < ranks[y]){\n        par[x] = y;\n    }\n    else{\n        par[y] = x;\n    }\n    \n    if(ranks[x] == ranks[y]){\n        ranks[x]++;\n    }\n}\n\nint kruskal(vector<T> &edge){\n    sort(edge.begin(), edge.end());\n    init(n);\n    int cnt = 0;\n    for(int i=0; i<edge.size(); i++){\n        int cost, cv, nv;\n        tie(cost, cv, nv) = edge[i];\n\n        if(!same(cv, nv)){\n            cnt++;\n\n            if(cnt == n / 2){\n                return cost;\n            }\n\n            unite(cv, nv);\n        }\n    }\n}\n\nint main(){\n    while(1){\n        cin>>n>>m;\n        if(n == 0) return 0;\n\n        vector<T> edge;\n        for(int i=0; i<m; i++){\n            int s, t, c; cin>>s>>t>>c;\n            s--, t--;\n            edge.emplace_back(c, s, t);\n        }\n\n        cout << kruskal(edge) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nint kruskal(int lim){\n  sort(all(es),cmp);\n  \n  vector<int>res;\n\n  init(V);\n \n  rep(i,lim){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res.push_back(e.cost);\n    }\n  }\n  sort(all(res));\n  if(res.size()%2==0)return (res[res.size()/2-1]+res[res.size()/2])/2;\n  return res[res.size()/2];\n}\n\nbool ok(){\n  bool fg=true;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      fg&=same(i,j);\n    }\n  }\n  return fg;\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n  \n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a-1,b-1,c});\n    }\n\n    int l=0,r=es.size(),ans=es[0].cost;\n    while(r-l>1){\n      int m=(l+r)/2;\n      int res=kruskal(m);\n      \n      if(ok())r=m,ans=res;\n      else l=m;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\nnamespace SpanningTree{\n\ttypedef int Cost;\n\tstruct Edge{\n\t\tint id;\n\t\tint from,to;Cost cost;\n\t\tEdge(int id,int from,int to,Cost cost)\n\t\t: id(id),from(from),to(to),cost(cost) {};\n\n\t\tbool operator<(Edge r) const{\n\t\t    return cost<r.cost;\n\t\t}\n\t\tbool operator>(Edge r) const{\n\t\t    return cost>r.cost;\n\t\t}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n\n\t//条件: 連結区間内\n\t//O(E*log(V))\n\t// verified by ACAC002 B\n\t// http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899143&cid=ACAC002\n\tCost prim(Graph& g,vector<Edge>& es,int s){\n\t\tconst int V=g.size();\n\t\tvector<bool> use(es.size());\n\t\tvector<bool> visited(V);\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> que;que.push(Edge(-1,-1,s,0));\n\t\tCost res=0;\n\t\twhile(!que.empty()){\n\t\t\tEdge task=que.top();que.pop();\n\t\t\tint pos=task.to;\n\t\t\tif(visited[pos])continue;\n\t\t\tvisited[pos]=true;\n\t\t\tres+=task.cost;\n\t\t\tif(task.id!=-1)use[task.id]=true;\n\t\t\tfor(Edge e:g[pos])if(!visited[e.to])que.push(e);\n\t\t}\n\t\tvector<Cost> ecosts;\n\t\tREP(i,es.size()){\n\t\t\tif(use[i])ecosts.push_back(es[i].cost);\n\t\t}\n\t\tsort(ALL(ecosts));\n\n\t\tif(ecosts.size()%2==0)return (ecosts[ecosts.size()/2]+ecosts[(1+ecosts.size())/2])/2;\n\t\treturn ecosts[ecosts.size()/2];\n\t}\n\n}\n\nusing namespace SpanningTree;\n\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N,M;nextInt(N);nextInt(M);\n\t\t\tif(N==0)break;\n\t\t\tGraph g(N);\n\t\t\tint id=0;\n\t\t\tvector<Edge> es;\n\t\t\tREP(i,M){\n\t\t\t\tint s,t,c;nextInt(s);nextInt(t);nextInt(c);s--;t--;\n\t\t\t\tg[s].push_back(Edge(id,s,t,c));\n\t\t\t\tes.push_back(Edge(id,s,t,c));\n\t\t\t\tg[t].push_back(Edge(id,t,s,c));\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tcout << (prim(g,es,0))<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost<x.cost; }\n};\n\nclass Kruskal{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Kruskal(int a=0):n(a){ g.resize(n); }\n  \n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  vector<edge> MinSpanningTree(){\n    UF connect(n);\n    vector<edge> edges;\n    for(int v=0;v<n;v++){\n      for(edge e : g[v])edges.push_back(e);\n    }\n    sort(edges.begin(), edges.end());\n    \n    vector<edge> res;\n    for(edge e : edges){\n      if(!connect.same(e.from,e.to)){\n\tres.push_back(e);\n\tconnect.unite(e.from,e.to);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m, n){\n    Kruskal mst(n);\n\n    for(int i=0;i<m;i++){\n      int s,t,c;\n      cin >> s >> t >> c; s--; t--;\n      mst.AddEdge(s,t,c);\n    }\n    vector<edge> res = mst.MinSpanningTree();\n    cout << res[(n-1)/2].cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct Edge{\n    int w, s, t;\n    \n    bool operator < (const Edge r)const{\n        return w < r.w;\n    };\n}Edge;\n\nclass UnionFind {\n    vector<int> par;\n    int cnt;\npublic:\n    UnionFind(int size_) : par(size_, -1), cnt(size_) { }\n    void unite(int x, int y){\n        if ((x = find(x)) != (y = find(y))) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y]; par[y] = x; cnt--;\n        }\n    }\n    bool same(int x, int y){ return find(x) == find(y); }\n    int find(int x){ return par[x] < 0 ? x : par[x] = find(par[x]); }\n    int size(int x){ return -par[find(x)]; }\n    int size(){ return cnt; }\n};\n\nint N, M;\n\nint main(){\n    while(cin >> N >> M, N|M){\n        auto uf = UnionFind(N);\n        \n        vector<Edge> edges;\n        for(int i=0; i<M; i++){\n            int s, t, w;\n            cin >> s >> t >> w; s--; t--;\n            edges.push_back({w, s, t});\n        }\n        sort(edges.begin(), edges.end());\n        \n        int cnt = 0;\n        for(auto &e: edges){\n            if(!uf.same(e.s, e.t)){\n                uf.unite(e.s, e.t);\n                cnt++;\n            }\n            if(cnt == N/2){\n                cout << e.w << endl;\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 1001\n#define rank dfasfds\nusing namespace std;\nint par[MAX_N],rank[MAX_N];\n\nvoid init(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nstruct edge{\n  int a,b,c;\n  bool operator < (edge t) const{return c<t.c;}\n};\n\nint n,m;\nedge e[10001];\nint solve(){\n  init(n+1);\n  for(int i=0,cnt=0;i<m;i++){\n    if(same(e[i].a,e[i].b)) continue;\n    unite(e[i].a,e[i].b);\n    if(cnt++==(n-1)/2) return e[i].c;\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)return 0;\n  for(int i=0;i<m;i++)cin>>e[i].a>>e[i].b>>e[i].c;\n  sort(e,e+m);\n  cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_N 200000\n\nint par[MAX_N];\nint rnk[MAX_N];\n\n// 初期化\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t}\n}\n\n// x の親を返す\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}\n\treturn par[x] = find(par[x]);\n}\n\n// x と y を併合する\nvoid unite(int x, int y){\n\tint x_par = find(x);\n\tint y_par = find(y);\n\tif(x_par == y_par){\n\t\treturn;\n\t}\n\t\n\tif(rnk[x_par] < rnk[y_par]){\n\t\tpar[x_par] = y_par;\n\t}else{\n\t\tpar[y_par] = x_par;\n\t\tif(rnk[x_par] == rnk[y_par]){\n\t\t\trnk[x_par]++;\n\t\t}\n\t}\n}\n\n// x, y が同じグループか判定\nbool same(int x, int y){\n\treturn (find(x) == find(y));\n}\n\nstruct edge{\n\tint u, v, cost;\n};\n\nbool cmp(edge e1, edge e2){\n\treturn e1.cost < e2.cost;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<edge> v;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e;\n\t\t\tcin >> e.u >> e.v >> e.cost;\n\t\t\tv.push_back(e);\n\t\t}\n\t\tsort(v.begin(), v.end(), cmp);\n\t\tinit(2000);\n\t\t\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e = v[i];\n\t\t\tif(!same(e.u, e.v)){\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(cnt == n / 2){\n\t\t\t\tcout << e.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nconst int MAX = 10001;\nconst int INF = 1<<29;\n\nstruct edge { int u, v, cost;};\n\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nedge es[MAX];\nint V,E,ed;\nint par[MAX];\nint rank[MAX];\nvector<int>v;\n\n\nvoid init(int n){\n  for(int i=0; i<n; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n \n  for(int i=0; i<E; i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ed++;\n      unite(e.u,e.v);\n      res += e.cost;\n      v.push_back(e.cost);\n    }\n  }\n\n  return res;\n\n}\nint main(){\n  while(cin >> V >> E,V|E){\n\n    for(int i=0; i<E; i++){\n      int from,to,cost;\n      cin >> from >> to >> cost;\n      from--,to--;\n      es[i].u = from;\n      es[i].v = to;\n      es[i].cost = cost;\n    }\n\n    v.clear();\n\n    int c = kruskal();\n    sort(v.begin(),v.end());\n    cout << v[v.size()/2] << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\n// グラフ用ヘッダ\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n    vector<int> data;\n    int cnt;\n    UnionFind(int size) : data(size, -1), cnt(size) { }\n    // 併合\n    bool set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        if(x != y) cnt--;\n        return x != y;\n    }\n    // 判定\n    bool ask(int x, int y) {\n        return root(x) == root(y);\n    }\n    // 根\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // xが属する集合の位数\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // 集合の数\n    int size() {\n        return cnt;\n    }\n};\n\npair<Weight, Edges> kruskal(Graph const& g){\n    int n = g.size();\n    UnionFind uf(n+1);\n    Edges es;\n    rep(u, n) rep(i,g[u].size()) if (u < g[u][i].dst) es.push_back(g[u][i]);\n    sort(all(es)); // !! INVERSE !!\n    reverse(all(es));\n    Weight total = 0;\n    Edges res;\n    for(auto const & e : es){\n        if(!uf.ask(e.src,e.dst)){\n            res.push_back(e);\n            total += e.weight;\n            uf.set(e.src,e.dst);\n        }\n    }\n    return make_pair(total,res);\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n){\n        Graph g(n+1);\n        rep(i,m){\n            int a,b,c; cin >> a >> b >> c;\n            g[a].eb(a,b,c); g[b].eb(b,a,c);\n        }\n        auto res = kruskal(g).second;\n        cout << res[n/2-1].weight << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define var auto\nusing ll = long long;\nconst char newl = '\\n';\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {if(a > b) a = b;}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {if(a < b) a = b;}\n\nusing namespace std;\nstruct UnionFind{\n    int num;\n    vector<int> r,p;\n    UnionFind(){}\n    UnionFind(int n):num(n), r(n, 1), p(n, 0){iota(p.begin(), p.end(),0);}\n    int find(int x){\n        return (x==p[x] ? x : p[x] = find(p[x]));\n    }\n    bool same(int x, int y){\n        return find(x)==find(y);\n    }\n    void unite(int x, int y){\n        x=find(x);y=find(y);\n        if (x == y) return;\n        if (r[x] < r[y]) swap(x, y);\n        r[x] += r[y];\n        p[y]=x;\n        num--;\n    }\n    int size(int x){\n        return r[find(x)];\n    }\n    int count() const{\n        return num;\n    }\n};\n\nvoid solver(int n, int m) {\n\n    struct edge {\n        int s, t, c;\n        edge() {}\n        edge(int s, int t, int c) : s(s), t(t), c(c) {}\n    };\n\n    vector< edge > edges;\n    for (int i = 0; i < m; i += 1) {\n        int s, t, c;\n        cin >> s >> t >> c;\n        s--; t--;\n\n        edges.emplace_back(s, t, c);\n    }\n\n    sort(edges.begin(), edges.end(), [](edge a, edge b) { return a.c < b.c; });\n\n    vector< int > ans;\n    UnionFind uf(n);\n\n    for (auto e: edges) {\n        if (uf.same(e.s, e.t)) continue;\n        ans.push_back(e.c);\n        uf.unite(e.s, e.t);\n    }\n\n    cout << ans[(n - 1) / 2] << endl;\n    \n}\n\nsigned main() {\n    int n, m;\n    \n    while (cin >> n >> m, n) {\n        solver(n, m);\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1023456789;\n\nint N,M;\ntypedef tuple<int,int,int> node;\nvector<node> graph;\n\nint par[vmax];\nvoid init(){rep(i,vmax) par[i]=i;}\nint find(int x){return (par[x]==x)?x:par[x]=find(par[x]);}\nvoid unite(int a,int b){a=find(a),b=find(b);par[a]=b;}\nbool same(int a,int b){return find(a)==find(b);}\n\nint kruskal(){\n\tinit();\n\tsort(begin(graph),end(graph));\n\tint res=0,num=0;\n\tfor(auto &e:graph){\n\t\tint a,b,c;\n\t\ttie(c,a,b)=e;\n\t\tif(!same(a,b)) unite(a,b),num++;\n\t\tif(num==N/2) res=c;\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> N >> M,N){\n\t\tgraph.clear();\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tgraph.push_back(node(c,a,b));\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint par[1000];\n\nstruct Edge {\n  int s, t, c;\n};\n\nbool operator<(const Edge &a, const Edge &b) {\n  return a.c < b.c;\n}\n\nint find(int v) {\n  if (v == par[v]) return v;\n  return par[v] = find(par[v]);\n}\n\nvoid unite(int u, int v) {\n  u = find(u);\n  v = find(v);\n  if (u == v) return;\n\n  par[u] = v;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m;\n  while(cin >> n >> m, n | m) {\n    iota(par, par + n, 0);\n    vector<Edge> e(m);\n    rep(i, m) {\n      cin >> e[i].s >> e[i].t >> e[i].c;\n      e[i].s--, e[i].t--;\n    }\n\n    sort(all(e));\n\n    vector<int> cost;\n    rep(i, m) {\n      if (find(e[i].s) != find(e[i].t)) {\n        unite(e[i].s, e[i].t);\n        cost.pb(e[i].c);\n      }\n    }\n\n    cout << cost[cost.size() / 2] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n//typedef long long ll;\n\n// `蛻晏ァ句喧?壺蔵莉、m=0?檎┯蜷惹スソ逕ィaddedge豺サ蜉?園譛芽セケ?域?逶エ謗・蛻晏ァ句喧m,u,v,w?峨?`\n//         `竭。n陦ィ遉コ扈鍋せ荳ェ謨ー`\n// `隹?畑?哮ruskal`\n// `豕ィ諢擾シ壺蔵荳区?莉?蠑?ァ具シ帚贈譌?髄蝗セ?帚造<algorithm>`\nconst int MAXN=1010, MAXM=10010;\nint u[MAXM],v[MAXM],w[MAXM];\nbool used[MAXM];\nint lens[MAXM], ll;\n\nint m=0, n;\n\nvoid addedge(int x, int y, int len)\n{\n    u[m]=x, v[m]=y, w[m]=len;\n    m++;\n}\n\nint parent[MAXN], rank[MAXM];     // parent莉」陦ィ蟷カ譟・髮?シ罫ank譏ッ霎ケ逧?コ丞捷\nint comp (const int i, const int j) {return w[i]<w[j];}\n\nint find (int x)    // `蟶ヲ霍ッ蠕?視郛ゥ逧?衍謇セ蜃ス謨ー`\n{\n    return parent[x]==x ? x : parent[x] = find(parent[x]);\n}\n\nint Kruskal()\n{\n    memset(used,0,sizeof(used));\n    int ans = 0;\n    // 蛻晏ァ句喧蟷カ譟・髮?    for (int i=0;i<n;i++) parent[i]=i;\n    for (int i=0;i<m;i++) rank[i]=i;\n    // 謖臥?霎ケ逧?揀蛟シ螟ァ蟆乗賜蠎擾シ瑚ソ呎?蜈郁ソ幄。悟セェ邇ッ逧?ーア譏ッ譛?洒逧?セケ\n    sort(rank, rank+m, comp);\n    for (int i=0;i<m;i++)\n    {\n        int e=rank[i];\n        int x=find(u[e]), y=find(v[e]); // 謇セ蜃コ蠖灘燕霎ケ逧?ク、荳ェ遶ッ轤ケ謇?惠髮?粋逧?シ門捷\n        if (x!=y)   // 螯よ棡荳榊惠蜷御ク?寔蜷?蜷亥ケカ\n        {\n            ans += w[e];\n            used[e]=true;\n            parent[x] = y;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    freopen(\"fuck.in\",\"r\",stdin);\n\n    int M;\n    while (scanf(\"%d%d\",&n,&M)!=EOF and not (n==0 and M==0))\n    {\n\n        m=0;\n        while (M--)\n        {\n            int x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            addedge(x-1,y-1,z);\n        }\n\n        //printf(\"kruskal=%d\\n\",Kruskal());\n        Kruskal();\n\n        ll=0;\n        for (int i=0; i<m; i++) if (used[i]) lens[ll++]=w[i];\n\n\n        //nth_element(lens,lens+n/2,lens+ll);\n        //printf(\"%d\\n\",*(lens+n/2-1));\n\n        sort(lens,lens+ll);\n\n        //for (int i=0; i<ll; i++) printf(\"%d \",lens[i]);\n        //printf(\"\\n\");\n        printf(\"%d\\n\",lens[n/2-1]);\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\nclass DisjointSet{\nprivate:\n  vector< int > rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    } else {\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++) p[i] = i, rank[i] = 0;\n  }\n  void Union(int x,int y){\n    if(Find(x) != Find(y)) link(Find(x),Find(y));\n  }\n  int Find(int x){\n    return( x != p[x] ? p[x] = Find(p[x]) : p[x]);\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< edge > edges;\n    for(int i = 0; i < m; i++){\n      int s, t, c;\n      cin >> s >> t >> c;\n      edges.push_back((edge){ s, t, c});\n    }\n    sort(edges.begin(), edges.end());\n    DisjointSet UnionFind(n);\n    vector< int > cost;\n    for(int i = 0; i < edges.size(); i++){\n      edge& e = edges[i];\n      if(UnionFind.Find(e.u) != UnionFind.Find(e.v)){\n        UnionFind.Union( e.u, e.v);\n        cost.push_back(e.cost);\n      }\n    }\n    if(cost.size() % 2 == 0){\n      cout << (cost[cost.size() / 2] + cost[cost.size() / 2 + 1]) / 2 << endl;\n    } else {\n      cout << cost[cost.size() / 2] << endl;\n    }\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Rank_Union_Find\n#define ___Rank_Union_Find\n\n#include <vector>\n\n// ------ Class ------ //\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\n\n#endif\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int s, t, c; };\nbool operator<(const edge& e1, const edge& e2) { return e1.c < e2.c; }\nint n, m;\nint main() {\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<edge> v(m);\n\t\tfor (int i = 0; i < m; i++) cin >> v[i].s >> v[i].t >> v[i].c, v[i].s--, v[i].t--;\n\t\tsort(v.begin(), v.end());\n\t\tint l = n / 2, r = m;\n\t\twhile (r - l > 1) {\n\t\t\tint t = (l + r) / 2;\n\t\t\tUnionFind uf(n);\n\t\t\tfor (int i = 0; i < t; i++) uf.unite(v[i].s, v[i].t);\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = t; i < m && cnt < n / 2; i++) {\n\t\t\t\tif (!uf.same(v[i].s, v[i].t)) {\n\t\t\t\t\tuf.unite(v[i].s, v[i].t); cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tint w = uf.root(0);\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (w != uf.root(i)) ok = false;\n\t\t\t}\n\t\t\tif (ok) r = t;\n\t\t\telse l = t;\n\t\t}\n\t\tcout << v[l - 1].c << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint solve(int n,int m){\n    vector<vector<pair<int,int>>> vec(n);\n    for(int i=0;i<m;i++){\n        int s,t,c;\n        cin>>s>>t>>c;\n        s--,t--;\n        vec[s].push_back({-c,t});\n        vec[t].push_back({-c,s});\n    }\n\n    vector<int> used(n,0);\n    priority_queue<pair<int,int>> que;\n    auto insert=[&](int v){\n        for(auto &e:vec[v]) que.push(e);\n    };\n    used[0]=true;\n    insert(0);\n    vector<int> costs;\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        int c=-tmp.first;\n        int v=tmp.second;\n        if(used[v]) continue;\n        used[v]=true;\n        costs.push_back(c);\n        insert(v);\n    }\n    sort(costs.begin(),costs.end());\n    return costs[(n-1)/2];\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        cout<<solve(n,m)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nInt par[100001];\nInt sz[100001];\n\nInt root(Int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n}\n\nvoid unite(Int x, Int y) {\n    Int rx = root(x);\n    Int ry = root(y);\n    if (rx == ry) return;\n    par[ry] = rx;\n    sz[rx] += sz[ry];\n}\n\nint main() {\n    vector<Int> res;\n    Int n, m;\n    while (cin >> n >> m and n) {\n        vector<pair<Int, pair<Int, Int>>> G(m);\n        for (Int i = 0; i < m; i++) {\n            cin >> G[i].se.fi >> G[i].se.se >> G[i].fi;\n        }\n        for (Int i = 0; i <= n; i++) {\n            par[i] = i;\n            sz[i] = 1;\n        }\n        sort(all(G));\n        vector<Int> mst;\n        for (Int i = 0; i < m; i++) {\n            pair<Int, Int> p = G[i].se;\n            if (root(p.fi) != root(p.se)) {\n                mst.push_back(G[i].fi);\n                unite(p.fi, p.se);\n            }\n        }\n        sort(all(mst));\n        res.push_back(mst[(n - 1) / 2]);\n    }\n    for (Int i = 0; i < (Int)res.size(); i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint par[1001];\n\nvoid init(int n)\n{\n    memset(par, -1, sizeof(par));\n}\n\nint find(int x)\n{\n    if (par[x] < 0) return (x);\n    return (par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (-par[x] < -par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n\nbool same(int x, int y)\n{\n    return (find(x) == find(y));\n}\n\n\nint main()\n{\n    int n, m;\n    \n    while (scanf(\"%d %d\", &n, &m) && n){\n        vector<pair<int, pair<int, int> > > es(m);\n        \n        for (int i = 0; i < m; i++){\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c);\n            es[i] = make_pair(c, make_pair(a, b));\n        }\n        \n        sort(es.begin(), es.end());\n        \n        init(n + 1);\n        int ec = 0;\n        int i = 0;\n        while (ec != n - 1 && i != m){\n            if (!same(es[i].second.first, es[i].second.second)){\n                merge(es[i].second.first, es[i].second.second);\n                if (++ec == n / 2){\n                    printf(\"%d\\n\", es[i].first);\n                    break;\n                }\n            }\n            i++;\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 999999;\n\nint edge[1000][1000];\nint n,m;\n\n\ndouble prim(bool used[1000],int mincost[1000],vi res,int nextnode){\n//    cout<<\"node : \"<<nextnode<<endl;\n    double mini=INF;\n    if( nextnode==-1 ){\n        sort( all(res) );\n//        rep(i,res.size())cout<<res[i]<<\" \";cout<<endl;\n        if(res.size()%2==1){\n            return min( mini , ( res[ (res.size()-1)/2 ] + res[ (res.size()+2)/2 ] )/2.0 );\n        }else{\n            return min( mini , (double)res[ res.size()/2 ] );\n        }\n    }\n    used[ nextnode ]=true;\n    res.pb(mincost[ nextnode ]);\n    \n    rep(u,n){\n//        cout<<endl<<\"-----------------\"<<endl;\n//        cout<<mincost[u]<<endl;\n//        cout<<nextnode<<\" \"<<u<<\" \"<<edge[nextnode][u]<<endl;\n        mincost[u]=min(mincost[u],edge[nextnode][u]);\n    }\n    \n    \n    int v=-1;\n    rep(u,n){\n        if( used[u]==false && (v==-1 || mincost[u]<mincost[v])){\n            v=u;\n        }\n    }\n    bool flag=false;\n    rep(u,n){\n        if(mincost[v]==mincost[u]){\n            if( used[u]==false ){\n                flag=true;\n                used[u]=true;\n                mini=min( mini , prim(used,mincost,res,u) );\n                used[u]=false;\n            }\n        }\n    }\n    if(flag==false)mini=min( mini , prim(used,mincost,res,-1) );\n\n    return mini;\n}\n\n\nint main(){\n    while(cin>>n>>m){\n        if(n==0 && m==0)break;\n        \n        rep(i,1000)rep(j,1000)edge[i][j]=INF;\n        \n        rep(i,m){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--;t--;\n            edge[s][t]=c;\n            edge[t][s]=c;\n        }\n        \n        bool used[1000];\n        int mincost[1000];\n        vi res;\n        \n        rep(i,n){\n            mincost[i]=INF;\n            used[i]=false;\n        }\n        \n        mincost[0]=0;\n        while(res.size())res.pop_back();\n        \n        cout<<prim(used,mincost,res,0)<<endl;\n        \n        \n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\n#define ALL(x) x.begin(),x.end()\n#define INS(x) inserter(x,x.begin())\n#define rep(i,j,k) for(int i=j;i<=k;i++)\n#define MAXN 10005\n#define MAXM 40005\n#define INF 0x3fffffff\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n#define clr(x,y) memset(x,y,sizeof(x));\nusing namespace std;\ntypedef long long LL;\nint i,j,k,n,m,x,y,T,ans,big,cas,num,len;\nbool flag;\n\nint edge,head[MAXN];\nstruct node\n{\n\tint x,y,w;\n}p[10005];\n\nbool cmp(node a,node b)\n{\n\treturn a.w<b.w;\n}\n\nint pre[10005];   //??根?点，起始??pre[i]=i\nint find(int u)   //?找u?点??集合的根?点\n{\n\tint r=u;\n\twhile (pre[r]!=r) r=pre[r];  //沿着?向上不断找father，直到找到根?点root (存入r中)\n\tint i=u,j;\n\twhile (i!=r)   //路径??，即把向上找???的?个?点（重新沿?点向上找一遍），他?的father都??root\n\t{\n\t\tj=pre[i];\n\t\tpre[i]=r;\n\t\ti=j;\n\t}\n\treturn r;  //返回根?点的?号\n}\n\nint main()\n{\n\twhile (scanf(\"%d%d\",&n,&m),n+m)\n\t{\n\t\tmemset(head,-1,sizeof(head));\n\t\tedge=0;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&p[i].x,&p[i].y,&p[i].w);\n\t\t}\n\t\tsort(p,p+m,cmp);\n\t\tfor (i=1;i<=n;i++) pre[i]=i;\n\t\tint t=n/2;num=0;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tint fx=find(p[i].x);\n\t\t\tint fy=find(p[i].y);\n\t\t\tif (fx!=fy)\n\t\t\t{\n\t\t\t\tpre[fx]=fy;\n\t\t\t\tnum++;\n\t\t\t\tif (num==t)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",p[i].w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n#define INF 999999;\n\nint edge[10001][10001];\nint n,m;\n\n\ndouble prim(bool used[2000],int mincost[2000],vi res,int nextnode){\n//    cout<<\"node : \"<<nextnode<<endl;\n    double mini=INF;\n    if( nextnode==-1 ){\n        sort( all(res) );\n//        rep(i,res.size())cout<<res[i]<<\" \";cout<<endl;\n        if(res.size()%2==1){\n            return min( mini , ( res[ (res.size()-1)/2 ] + res[ (res.size()+2)/2 ] )/2.0 );\n        }else{\n            return min( mini , (double)res[ res.size()/2 ] );\n        }\n    }\n    used[ nextnode ]=true;\n    res.pb(mincost[ nextnode ]);\n    \n    rep(u,n){\n//        cout<<endl<<\"-----------------\"<<endl;\n//        cout<<mincost[u]<<endl;\n//        cout<<nextnode<<\" \"<<u<<\" \"<<edge[nextnode][u]<<endl;\n        mincost[u]=min(mincost[u],edge[nextnode][u]);\n    }\n    \n    \n    int v=-1;\n    rep(u,n){\n        if( used[u]==false && (v==-1 || mincost[u]<mincost[v])){\n            v=u;\n        }\n    }\n    bool flag=false;\n    rep(u,n){\n        if(mincost[v]==mincost[u]){\n            if( used[u]==false ){\n                flag=true;\n                used[u]=true;\n                mini=min( mini , prim(used,mincost,res,u) );\n                used[u]=false;\n            }\n        }\n    }\n    if(flag==false)mini=min( mini , prim(used,mincost,res,-1) );\n\n    return mini;\n}\n\n\nint main(){\n    while(cin>>n>>m){\n        if(n==0 && m==0)break;\n        \n        rep(i,10001)rep(j,10001)edge[i][j]=INF;\n        \n        rep(i,m){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--;t--;\n            edge[s][t]=c;\n            edge[t][s]=c;\n        }\n        \n        bool used[2000];\n        int mincost[2000];\n        vi res;\n        \n        rep(i,n){\n            mincost[i]=INF;\n            used[i]=false;\n        }\n        \n        mincost[0]=0;\n        while(res.size())res.pop_back();\n        \n        cout<<prim(used,mincost,res,0)<<endl;\n        \n        \n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int size(int x){ return -data[find(x)]; }\n  int find(int x){ return data[x] < 0 ? x : data[x] = find(data[x]); }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] < data[y]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return -data[x];\n  }\n};\n\nstruct edge {\n  int u, v, cost;\n  edge(){}\n  edge(int u, int v, int cost):u(u), v(v), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nvector<edge> E;\nint n, m;\n\nint Kruskal()\n{\n  sort(E.begin(), E.end());\n  UnionFind uf(n);\n  for(int i = 0; i < E.size(); i++) {\n    edge& e = E[i];\n    if(!uf.same(e.u, e.v)) {\n      uf.unite(e.u, e.v);\n      if(i+1 == n/2) return e.cost;\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> n >> m, n || m) {\n    E.clear();\n    for(int i = 0; i < m; i++) {\n      int s, t, c;\n      cin >> s >> t >> c;\n      --s, --t;\n      E.push_back(edge(s, t, c));\n    }\n    cout << Kruskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n \nclass UF{\nprivate:\n    vector<int> par,rank,elm;\npublic:\n    int groups;\n    \n    UF(int __size):par(__size) , rank(__size,0) , elm(__size,1) , groups(__size){\n        for(int i=0;i<__size;i++)par[i]=i;\n    }\n    \n    int elements(int n){\n        return elm[find(n)];\n    }\n    \n    int find(int x){\n        if(par[x]==x) {\n            return x;\n        }else{\n            return par[x]=find(par[x]);\n        }\n    }\n    \n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        \n        groups--;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n            elm[y]+=elm[x];\n        }else{\n            par[y]=x;\n            elm[x]+=elm[y];\n            if(rank[x]==rank[y])rank[x]++;\n        }\n    }\n    \n    bool isSame(int x,int y){\n        return find(x)==find(y);\n    }\n};\n \n#define MAX_N 1000\nstruct edge{int to,cost;};\nvector<edge> G[MAX_N];\nint kraskal(int n,vector<int> &list){\n    int ret = 0;\n    vector< pair< int,pii > > edges;\n    \n    rep(i,MAX_N){\n        rep(j,G[i].size()){\n            edges.pb( make_pair(G[i][j].cost,make_pair(i,G[i][j].to)) );\n        }\n    }\n    \n    sort(all(edges));\n    \n    UF uf(n);\n    \n    rep(i,edges.size()){\n        pii e = edges[i].second;\n        \n        if(!uf.isSame(e.first,e.second)){\n            uf.unite(e.first,e.second);\n            ret+=edges[i].first;\n            list.pb(edges[i].first);\n        }\n    }\n    return ret;\n}\n \n \n \nint main(){\n    int n,m;\n    while(cin>>n>>m&&(n||m)){\n        rep(i,MAX_N)G[i].clear();\n        rep(i,m){\n            int s,t,c;\n            cin>>s>>t>>c;\n            s--,t--;\n            G[s].pb(edge{t,c});\n            G[t].pb(edge{s,c});\n        }\n        vector<int> list;\n        kraskal(n,list);\n        sort(all(list));\n        cout<<list[list.size()/2]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\tint a,b,c;\n};\nbool operator < (const Edge &a, const Edge &b){\n\treturn a.c < b.c;\n}\nint n,m;\n\nint uf[10010];\nint get(int x){\n\treturn x == uf[x] ? x : uf[x] = get(uf[x]);\n}\nint unite(int x,int y){\n\tif( rand() & 1 ) swap(x,y);\n\tuf[get(x)] = get(y);\n}\n\nvector<Edge> es;\nint check(int lim){\n\tfor(int i = 0 ; i < n ; i++) uf[i] = i;\n\tint need1 = 0;\n\tint need2 = 0;\n\tfor(int i = 0 ; i < es.size() ; i++){\n\t\tauto &e = es[i];\t\t\n\t\tif( get(e.a) != get(e.b) ){\n\t\t\tunite(e.a,e.b);\n\t\t\tif( e.c <= lim ){\n\t\t\t\tneed1++;\n\t\t\t}else need2++;\n\t\t}\n\t}\n\treturn need1 > need2;\n}\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tes.resize(m);\n\t\tfor(int i = 0 ; i < m ; i++) cin >> es[i].a >> es[i].b >> es[i].c;\n\t\tsort(es.begin(),es.end());\n\t\tint l = 0 , r = 1000;\n\t\twhile( l != r ){\n\t\t\tint lim = (l+r)/2;\n\t\t\tif( check(lim) ){\n\t\t\t\tr = lim;\n\t\t\t}else{\n\t\t\t\tl = lim+1;\n\t\t\t}\n\t\t}\n\t\tcout << l << endl;\n\t}\n\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nint par[10001];\nint rank_aa[10001];\n\nvoid init(int n)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank_aa[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (rank_aa[x] < rank_aa[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif (rank_aa[x] == rank_aa[y]) rank_aa[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nstruct edge{ll u, v, cost;};\n\nbool comp(const edge& x, const edge& y){\n\treturn x.cost < y.cost;\n}\n\nedge es[10001];\nll V, E;\n\nint main() {\n\twhile(cin>>V>>E, V>0){\n\t\tfor(int i=0; i<E; i++){\n\t\t\tint s, t, c; cin>>s>>t>>c;\n\t\t\tes[i].u = s-1;\n\t\t\tes[i].v = t-1;\n\t\t\tes[i].cost = c;\n\t\t}\n\t\tsort(es, es+E, comp);\n\t\tinit(V);\n\t\tvector<int> ans;\n\t\tfor(int i=0; i<E; i++){\n\t\t\tedge e = es[i];\n\t\t\tif (!same(e.u, e.v)){\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tans.push_back(e.cost);\n\t\t\t}\n\t\t}\n\t\tll mid;\n\t\tmid = ans[ans.size()/2];\n\t\tcout << mid << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n\nclass Edge {\n\tpublic:\n\t\tint to, cost;\n\t\tEdge(int to, int cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint prim(const Graph &g, int s = 0) {\n\tint n = g.size();\n\tint total = 0;\n\n\tvector<bool> visited(n);\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\t//priority_queue<pair<int, int> > q;\n\n\tq.push(make_pair(0,s));\n\n\tvector<int> res;\n\twhile (not q.empty()) {\n\t\tpair<int, int> u = q.top(); q.pop();\n\t\tif (visited[u.second]) continue;\n\t\ttotal += u.first;\n\t\tres.emplace_back(u.first);\n\t\tvisited[u.second] = true;\n\t\tfor(auto it : g[u.second]) {\n\t\t\tif (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n\t\t}\n\t}\n\tsort(all(res));\n\t//for(auto i : res){ show(i) }\n\treturn res[res.size() / 2];\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tg[a].emplace_back(b,c);\n\t\t\tg[b].emplace_back(a,c);\n\t\t}\n\t\tcout << prim(g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nusing CST = tuple<int, int, int>;\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        vector<vi> edge(n);\n        vector<CST> cst(m);\n        rep(i, m){\n            int s, t, c; cin >> s >> t >> c;\n            s--, t--;\n            edge[s].push_back(t);\n            edge[s].push_back(s);\n            cst[i] = tie(c, s, t);\n        }\n        sort(_all(cst));\n\n        UnionFind uf(n);\n\n        int cnt = 0, res;\n        for(auto & e : cst){\n            int c, s, t; tie(c, s, t) = e;\n\n            if(uf.findSet(s, t)) continue;\n\n            uf.unionSet(s, t);\n            cnt++;\n\n            if(cnt == n / 2){\n                res = c;\n                break;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct UF {\n    vector<int> data;\n\n    UF(int n) {\n        data.resize(n, -1);\n    }\n\n    int root(int i) {\n        return data[i] < 0 ? i : data[i] = root(data[i]);\n    }\n\n    int size(int i) {\n        return -data[root(i)];\n    }\n\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n\n        if (x == y) return ;\n\n        if (size(x) < size(y)) swap(x, y);\n\n        data[x] += data[y];\n        data[y] = x;\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nint N, M;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (cin >> N >> M, N) {\n        UF uf(N);\n\n        vector<pair<int, pii>> edges;\n\n        for (int i = 0; i < M; ++i) {\n            int s, t, c; cin >> s >> t >> c;\n\n            --s, --t;\n\n            edges.push_back(make_pair(c, pii(s, t)));\n        }\n\n        sort(begin(edges), end(edges));\n\n        vector<int> a;\n\n        for (pair<int, pii> e : edges) {\n            int cost = e.first;\n            pii info = e.second;\n            if (!uf.same(info.first, info.second)) {\n                uf.unite(info.first, info.second);\n                a.push_back(cost);\n            }\n        }\n\n        sort(begin(a), end(a));\n\n        cout << a[a.size() / 2] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nstruct st {\n\tint a, b, c;\n};\nbool operator<(st a, st b) { return a.c < b.c; }\nint par[1000];\nint find(int x) {\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tvector<st>v;\n\t\trep(i, m) {\n\t\t\tint s, t, c; scanf(\"%d%d%d\", &s, &t, &c); s--; t--;\n\t\t\tv.push_back({ s,t,c });\n\t\t}\n\t\tiota(par, par + n, 0);\n\t\tsort(v.begin(), v.end());\n\t\tint t = 0;\n\t\tfor (st&s : v) {\n\t\t\tint x = find(s.a), y = find(s.b);\n\t\t\tif (x == y)continue;\n\t\t\tpar[x] = y;\n\t\t\tif (++t == n / 2) {\n\t\t\t\tprintf(\"%d\\n\", s.c); break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) y) { return (f)(begin(y), end(y), ## __VA_ARGS__); })(x)\nusing namespace std;\nstruct disjoint_sets {\n    vector<int> xs;\n    explicit disjoint_sets(size_t n) : xs(n, -1) {}\n    bool is_root(int i) { return xs[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (xs[i] = find_root(xs[i])); }\n    int set_size(int i) { return - xs[find_root(i)]; }\n    int union_sets(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (set_size(i) < set_size(j)) swap(i,j);\n            xs[i] += xs[j];\n            xs[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\nstruct edge_t { int s, t, c; };\nbool operator < (edge_t const & a, edge_t const & b) { return a.c < b.c; } // strict weak ordering\nint main() {\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 and m == 0) break;\n        vector<edge_t> es(m);\n        repeat (i,m) {\n            cin >> es[i].s >> es[i].t >> es[i].c;\n            -- es[i].s;\n            -- es[i].t;\n        }\n        whole(sort, es);\n        disjoint_sets t(n);\n        vector<int> acc;\n        for (edge_t e : es) {\n            if (not t.is_same(e.s, e.t)) {\n                t.union_sets(e.s, e.t);\n                acc.push_back(e.c);\n            }\n        }\n        whole(sort, acc);\n        double ans = (n-1) % 2 == 0 ? (acc[(n-1)/2] + acc[(n-1)/2+1]) / 2.0 : acc[(n-1)/2];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint main(){\n  while(1){\n    int n,m,cost[10000];\n  cin>>n>>m;\n  if(!n&&!m)return 0;\n  for(int i=0,a,b;i<m;i++)cin>>a>>b>>cost[i];\n  sort(cost,cost+m);\n  cout<<cost[(n-1)/2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nint kruskal(){\n  \n  vector<int>res;\n\n  init(V);\n \n  rep(i,E){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res.push_back(e.cost);\n    }\n  }\n  sort(all(res));\n  if(res.size()%2==0)return round((double)((double)res[res.size()/2-1]+(double)res[res.size()/2])/2);\n  return res[res.size()/2];\n}\n\nbool ok(){\n  bool fg=true;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      fg&=same(i,j);\n    }\n  }\n  return fg;\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n  \n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a-1,b-1,c});\n    }\n\n    sort(all(es),cmp);\n    /*\n    int l=0,r=es.size(),ans=0;\n    while(r-l>1){\n      int m=(l+r)/2;\n      kruskal(m);\n      \n      if(ok())r=m,ans=m;\n      else l=m;\n    }\n    if(es.size()%2==0)cout << (es[ans].cost+es[ans+1].cost)/2 << endl;\n    else cout << es[ans].cost << endl;\n    */\n    cout << kruskal() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 1001\n#define rank dfasfds\nusing namespace std;\nint par[MAX_N],rank[MAX_N];\n\nvoid init(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nstruct edge{\n  int a,b,c;\n  bool operator < (edge t) const{return c<t.c;}\n};\n\nint n,m;\nedge e[10001];\nint solve(){\n  init(n+1);\n  for(int i=0,cnt=0;i<m;i++){\n    if(same(e[i].a,e[i].b)) continue;\n    unite(e[i].a,e[i].b);\n    if(cnt++==(n-1)/2) return e[i].c;\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)return 0;\n  for(int i=0;i<m;i++)cin>>e[i].a>>e[i].b>>e[i].c;\n  sort(e,e+m);\n  cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\tint a,b,c;\n};\nbool operator < (const Edge &a, const Edge &b){\n\treturn a.c < b.c;\n}\nint n,m;\n\nint uf[10010];\nint get(int x){\n\treturn x == uf[x] ? x : uf[x] = get(uf[x]);\n}\nint unite(int x,int y){\n\tif( rand() & 1 ) swap(x,y);\n\tuf[get(x)] = get(y);\n}\n\nvector<Edge> es;\nint check(int lim){\n\tfor(int i = 0 ; i < n ; i++) uf[i] = i;\n\tint need1 = n/2;\n\tint need2 = n - 1 - need1;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tauto &e = es[i];\n\t\tif( e.c <= lim ){\n\t\t\tif( need1 ){\n\t\t\t\tauto &e = es[i];\n\t\t\t\tif( get(e.a) != get(e.b) ){\n\t\t\t\t\tunite(e.a,e.b);\n\t\t\t\t\tneed1--;\n\t\t\t\t}\n\t\t\t}else if( need2 ){\n\t\t\t\tunite(e.a,e.b);\n\t\t\t\tneed2--;\n\t\t\t}\n\t\t}else{\n\t\t\tif( need2 ){\n\t\t\t\tunite(e.a,e.b);\n\t\t\t\tneed2--;\n\t\t\t}\n\t\t}\n\t}\n\treturn need1 == 0 && need2 == 0;\n}\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tes.resize(m);\n\t\tfor(int i = 0 ; i < m ; i++) cin >> es[i].a >> es[i].b >> es[i].c;\n\t\tsort(es.begin(),es.end());\n\t\t//for(int i = 0 ; i < 1000 ; i++)\n\t\t//\tcout << i << \":\" << check(i) << endl;\n\t\t//return 0;\n\t\tint l = 0 , r = 1000;\n\t\twhile( l != r ){\n\t\t\tint lim = (l+r)/2;\n\t\t\tif( check(lim) ){\n\t\t\t\tr = lim;\n\t\t\t}else{\n\t\t\t\tl = lim+1;\n\t\t\t}\n\t\t}\n\t\tcout << l << endl;\n\t}\n\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_N 2000\n#define MAX_E 20000\n#include<algorithm>\nusing namespace std;\n\nstruct edge {int u,v,cost;};\n\nint ans[MAX_N],cnt;\n\nbool comp(const edge& e1, const edge&e2){\n  return e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V,E;\n\n\n\nint par[MAX_E];\nint rank[MAX_E];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x] = find (par[x]);\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return ;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\n\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n  for(int i=0;i<E;i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ans[cnt++]=e.cost;\n      unite(e.u,e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  int a,b,c;\n  while(cin>>V>>E&&V&&E){\n    \n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n      es[E+i].u=b;\n      es[E+i].v=a;\n      es[E+i].cost=c;\n    }\n    E*=2;\n    cnt=0;\n    kruskal();\n    cout<<ans[cnt/2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<int,pi> edge;\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nint main()\n{\n    int n,m;\n    while(scanf(\" %d %d\", &n, &m),n)\n    {\n        vector<edge> e(m);\n        rep(i,m)\n        {\n            int s,t,c;\n            scanf(\" %d %d %d\", &s, &t, &c);\n            --s;\n            --t;\n            e[i] = edge(c,pi(s,t));\n        }\n\n        sort(all(e));\n\n        UF uf(n);\n        vector<int> used;\n        rep(i,m)\n        {\n            int a=e[i].se.fi, b=e[i].se.se;\n            if(!uf.same(a,b))\n            {\n                uf.unite(a,b);\n                used.pb(e[i].fi);\n            }\n        }\n\n        printf(\"%d\\n\", used[n/2-1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <complex>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<string> vst;\ntypedef pair<int,int> pint;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define all(s) (s).begin(),(s).end()\n#define each(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define debug(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nint n,m;\n\ntemplate<class T> struct Edge {\n    int from, to;\n    T cost;\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend bool operator < (const Edge &e1, const Edge &e2) {return e1.cost < e2.cost;}\n    friend ostream& operator << (ostream& s, const Edge& E) {s << E.from << \"->\" << E.to << '(' << E.cost << ')';return s;}\n};\n\nconst int MAX_V = 1050;\ntemplate<class T> struct Graph {\n    static const int MAX_V_ = ::MAX_V;\n    int V,E;\n    vector<Edge<T> > list[MAX_V_];\n    \n    Graph(int n = 0) : V(n), E(0) {}\n    void init(int n) {V = n; E = 0; for (int i = 0; i < MAX_V_; ++i) list[i].clear();}\n    inline vector<Edge<T> >& operator [] (int i) {return list[i];}\n    friend ostream& operator << (ostream& s, const Graph& G) {for (int i = 0; i < G.V; ++i) {s << i << \" : \" << G.list[i];}return s;}\n    \n    void connect(int f, int t, T c) {\n        ++E;\n        list[f].push_back(Edge<T>(f,t,c));\n        list[t].push_back(Edge<T>(t,f,c));\n    }\n};\n\nGraph<int> G;\n\nstruct UnionFind {    \n    int size_;\n    int par[MAX_V];\n    int rank[MAX_V];\n    \n    UnionFind(int n = 0) {\n        size_ = n;\n        for (int i = 0; i < n; ++i) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    \n    void init(int n) {\n        size_ = n;\n        for (int i = 0; i < n; ++i) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    \n    int size() {return size_;}\n    int root(int x) {return par[x] == x ? x : par[x] = root(par[x]);}    \n    bool same(int x, int y) {return root(x) == root(y);}\n    \n    void connect(int x, int y) {\n        x = root(x); \n        y = root(y);\n        if (x == y) return;        \n        if (rank[x] < rank[y]) par[x] = y;\n        else {\n            par[y] = x;\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n    }\n    \n};\n\nvint tree;\nUnionFind uf;\n\ntemplate<class T> void Kruskal(Graph<T> &G) {\n    T res = 0.0;\n    tree.clear();\n    uf.init(G.V);\n    vector<Edge<T> > edges;\n    for (int v = 0; v < G.V; ++v) {\n        for (int i = 0; i < G[v].size(); ++i) {\n            edges.push_back(G[v][i]);\n        }\n    }\n    sort(edges.begin(), edges.end());\n    for (int i = 0; i < edges.size(); ++i) {\n        Edge<T> e = edges[i];\n        if (!uf.same(e.from, e.to)) {\n            uf.connect(e.from, e.to);\n            res += e.cost;\n            tree.pb(e.cost);\n        }\n    }\n}\n\n\nint solve() {\n    Kruskal(G);\n    sort(all(tree));\n    //debug(tree);\n    return tree[(n-2)/2];\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/JAG Practice Asia 2012 C - Median Tree.in\", \"r\", stdin );\n    \n    while (cin >> n >> m) {\n        if (n == 0) break;\n        G.init(n);\n        for (int i = 0; i < m; ++i) {\n            int s,t,c;\n            cin >> s >> t >> c;\n            G.connect(s-1, t-1, c);\n        }\n        //debug(G);\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\nvector<ppap> ve;\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\n         signed main(){\n\t\n\tint n,m;\n         \twhile(1){\n         \tcin>>n>>m;\n         \t\tif(n==0) return 0;\n         \t\tve.clear();\n         \t\tshoki(1200);\n         \t\t\n         \t\tfor(int i=0;i<m;i++){\n         \t\t\tint s,t,c;\n         \t\t\tcin>>s>>t>>c;\n         \t\t\tve.pb(mp(c,mp(s,t)));\n         \t\t}\n         \t\tsort(ve.begin(),ve.end());\n         \t\tint cnt=0;\n         \t//\tcout<<\"s\"<<endl;\n         \t\tfor(int i=0;i<m;i++){\n         \t\t\tif(same(ve[i].second.first,ve[i].second.second)) continue;\n         \t\t\tcnt++;\n         \t//\t\tcout<<cnt<<endl;\n         \t\t\tunite(ve[i].second.first,ve[i].second.second);\n         \t\t\tif(cnt==n/2){\n         \t\t\t\tcout<<ve[i].first<<endl;\n         \t\t\t\tbreak;\n         \t\t\t}\n         \t\t}\n         \t\t\n         \t}\n         \n         \t//cout<<ans<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing llong = long long;\n\n//===\nstruct UnionFind {\n    int n;\n    vector<int> parent;\n\n    UnionFind() {}\n    UnionFind(int nmemb) {\n        init(nmemb);\n    };\n\n    void init(int nmemb) {\n        parent.clear();\n        parent.assign(nmemb, -1);\n    };\n\n    int root(int x) {\n        if (parent[x] < 0) {\n            return x;\n        }\n        return parent[x] = root(parent[x]);\n    };\n\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n\n        if (x == y) return;\n\n        if (parent[y] < parent[x]) swap(x, y);\n\n        parent[x] += parent[y];\n        parent[y] = x;\n        \n        return;\n    };\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    };\n    int size(int x) {\n        return -(parent[root(x)]);\n    };\n};\n//===\n\nllong n, m;\nusing Edge = tuple<llong, llong, llong>;\nvector<Edge> edges;\n\nvoid solve() {\n    edges.clear();\n    UnionFind uf(n + 1);\n    for (int i = 0; i < m; i++) {\n        llong s, t, c;\n        cin >> s >> t >> c;\n\n        edges.emplace_back(c, s, t);\n    }\n\n    sort(edges.begin(), edges.end());\n    llong cnt = 0;\n    llong med;\n    for (int i = 0; i < m; i++) {\n        llong s, t, c;\n        tie(c, s, t) = edges[i];\n\n        if (uf.same(s, t)) continue;\n\n        cnt++;\n        uf.unite(s, t);\n\n        if (cnt == n / 2) {\n            med = c;\n        }\n    }\n\n    cout << med << '\\n';\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> m, n) {\n        solve();\n    }\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 100010;\n  int par[MAX_N];\n  int rank[MAX_N];\n  int s[MAX_N];\n  bool used[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, rank[i] = 0, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y; s[y] = s[x] + s[y];\n    } else {\n      par[y] = x; s[x] = s[x] + s[y];\n      if( rank[x] == rank[y] ) rank[x]++;\n    }\n  }\n  int size(int x) { return s[find(x)];}\n  bool same(int x, int y) { return find(x) == find(y);}\n  int group(int n) {\n    REP(i, n) used[find(i)] = true;\n    int ret = 0;\n    REP(i, n) if(used[i]) ret++;\n    return ret;\n  }\n};\nUnionFind uf;\n\nVI a[10010];\nsigned main(void)\n{\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, m) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      x--, y--;\n      a[i] = {z, x, y};\n    }\n    sort(a, a+m);\n    if(n == 2) {\n      cout << a[0][0] << endl;\n      continue;\n    }\n\n    uf.init(n);\n    VI v;\n    REP(i, m) {\n      if(!uf.same(a[i][1], a[i][2])) {\n        v.PB(a[i][0]);\n        uf.unite(a[i][1], a[i][2]);\n      }\n    }\n    sort(ALL(v));\n    cout << v[n/2-1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nstruct data {\n\tint a, b, c;\n} e[10005];\nint n, m, p[1005];\ninline bool cmp(data d1, data d2) { return d1.c < d2.c; }\nint f(int x) {\n\tif (p[x] == x) return x;\n\treturn (p[x] = f(p[x]));\n}\nbool ok(int X) {\n\tfor (int i = 1; i <= n; i++) p[i] = i;\n\tint cnt = 0;\n\tfor (int i = 1; i < X; i++) {\n\t\tint A = f(e[i].a), B = f(e[i].b);\n\t\tif (A == B) continue;\n\t\tcnt++;\n\t\tp[A] = B;\n\t\tif (cnt == (n - 1) / 2) break;\n\t}\n\tif (cnt != (n - 1) / 2) return 0;\n\tcnt++;\n\tp[e[X].a] = p[e[X].b];\n\tfor (int i = X + 1; i <= m; i++) {\n\t\tint A = f(e[i].a), B = f(e[i].b);\n\t\tif (A == B) continue;\n\t\tcnt++;\n\t\tp[A] = B;\n\t\tif (cnt == n - 1) break;\n\t}\n\tif (cnt == n - 1) return 1;\n\treturn 0;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n&&m) {\n\t\tfor (int i = 1; i <= m; i++) scanf(\"%d%d%d\", &e[i].a, &e[i].b, &e[i].c);\n\t\tsort(e + 1, e + m + 1, cmp);\n\t\tfor (int i = (n - 1) / 2 + 1; i <= m; i++) {\n\t\t\tif (ok(i)) {\n\t\t\t\tprintf(\"%d\\n\", e[i].c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI a[10010];\nbool used[1010];\nsigned main(void)\n{\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, m) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      x--, y--;\n      a[i] = {z, x, y};\n    }\n    sort(a, a+m);\n    if(n == 2) { cout << a[0][0] << endl; continue; }\n\n    int ans;\n    int cnt = 0;\n    memset(used, false, sizeof(used));\n    REP(i, n/2) {\n      if(!used[a[i][0]]) cnt++;\n      if(!used[a[i][1]]) cnt++;\n      used[a[i][0]] = used[a[i][1]] = true;\n    }\n    FOR(i, n/2, m) {\n      if(!used[a[i][0]]) cnt++;\n      if(!used[a[i][1]]) cnt++;\n      used[a[i][0]] = true;\n      used[a[i][1]] = true;\n      // cout << i << \" \" << cnt << endl;\n      if(cnt >= n/2) {\n        ans = a[i-1][0];\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#define inf 1000000001\n#define f first\n#define s second\nusing namespace std;\n\nint map[1000][1000];\nint n,m,s,t,c;\n\nint Prim()\n{\n  priority_queue<pair<int,int> > PQ;\n  int d[1000],color[1000];\n  for(int i=0;i<n;i++){\n    d[i]=inf;\n    color[i]=0;\n  }\n  d[0]=0;\n  PQ.push(make_pair(0,0));\n  color[0]=0;\n  while(!PQ.empty()){\n    pair<int,int> p=PQ.top();PQ.pop();\n    int u=p.s;\n    color[u]=2;\n\n    if(d[u]<p.f*(-1))continue;\n\n    for(int i=0;i<n;i++){\n      if(color[i]==2 || map[u][i]==inf)continue;\n      if(d[i]>map[u][i]){\n\td[i]=map[u][i];\n\tPQ.push(make_pair(d[i]*(-1),i));\n\tcolor[i]=1;\n      }\n    }\n  }\n  sort(d,d+n);\n  return d[n/2];\n}  \n\nint main()\n{\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)map[i][j]=inf;\n    for(int i=0;i<m;i++){\n      cin>>s>>t>>c;\n      map[s-1][t-1]=c;\n      map[t-1][s-1]=c;\n    }\n    cout<<Prim()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 1001\n#define rank dfasfds\nusing namespace std;\nint par[MAX_N],rank[MAX_N];\n\nvoid init(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nstruct edge{\n  int a,b,c;\n  bool operator < (edge t) const{return c<t.c;}\n};\n\nint n,m;\nedge e[10001];\nint solve(int s){\n  int cnt=0,used[1001];\n  init(1001);\n  for(int i=s;i<m;i++){\n    if(same(e[i].a,e[i].b)) continue;\n    unite(e[i].a,e[i].b);\n    used[cnt++]=e[i].c;\n  }\n  return cnt==n-1? used[(n-1)/2]:1e9;\n}\n\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)return 0;\n  for(int i=0;i<m;i++)cin>>e[i].a>>e[i].b>>e[i].c;\n  sort(e,e+m);\n  int ans=1e9;\n  for(int i=0;i<m;i++)ans=min(ans,solve(i));\n\n  cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<int,P> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n\n//// UnionFind\nstruct UnionFind{\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t\treturn true;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint n,m;\nint num;\nPPI es[11111];\n\nbool ok(ll x){\n\tset<int> st;\n\tUnionFind uf(n);\n\trep(i,m){\n\t\tif(es[i].fi>x)break;\n\t\tuf.unite(es[i].se.fi,es[i].se.se);\n\t}\n\trep(i,n){\n\t\tst.insert(uf.find(i));\n\t}\n\treturn st.size()-1<n/2;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\trep(i,m){\n\t\t\tcin>>es[i].se.fi>>es[i].se.se>>es[i].fi;\n\t\t\tes[i].se.fi--;\n\t\t\tes[i].se.se--;\n\t\t}\n\t\tsort(es,es+m);\n\t\tint lb=0,ub=1000;\n\t\twhile(ub-lb>1){\n\t\t\tint mid=(lb+ub)/2;\n\t\t\tif(ok(mid))ub=mid;\n\t\t\telse lb=mid;\n\t\t}\n\t\tcout<<ub<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi p,r,s;\n\tUnion_Find_Tree(int n){\n\t\tp=r=vi(n);\n\t\ts=vi(n,1);\n\t\tfor(int i=0;i<n;i++) p[i]=i;\n\t}\n\tint Par(int x){\n\t\tif(p[x]==x) return x;\n\t\treturn p[x]=Par(p[x]);\n\t}\n\tint Size(int x){return s[Par(x)];}\n\tbool Unite(int x,int y){\n\t\tx=Par(x);\n\t\ty=Par(y);\n\t\tif(x==y) return 0;\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\ts[y]+=s[x];\n\t\t}\n\t\telse{\n\t\t\tp[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tif(r[x]==r[y]) r[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){return Par(x)==Par(y);}\n};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tUnion_Find_Tree uft(n);\n\t\tvip a;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,w;\n\t\t\tcin>>u>>v>>w;\n\t\t\tu--;v--;\n\t\t\ta.push_back({w,{u,v}});\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tvi b;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u=a[i].second.first,v=a[i].second.second;\n\t\t\tif(!uft.Same(u,v)){\n\t\t\t\tuft.Unite(u,v);\n\t\t\t\tb.push_back(a[i].first);\n\t\t\t}\n\t\t}\n\t\tcout<<b[n/2-1]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass UnionFindTree{\nprivate:\n  int* mParent;\n  int* mRank;\n  int mSize;\n\npublic:\n  UnionFindTree(int n){\n    mSize = n;\n    mParent = new int[n];\n    mRank = new int[n];\n\n    for(int i=0; i < n; i++){\n      mParent[i] = i;\n      mRank[i] = 0;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] mParent;\n    delete[] mRank;\n  }\n\n  bool same(int lhs,int rhs){\n    return (find(lhs) == find(rhs) ? true : false);\n  }\n\n  int find(int pos){\n    if(pos == mParent[pos]) return pos;\n    return find(mParent[pos]);\n  }\n  \n  void unite(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    \n    if(lhs == rhs) return;\n    \n    if(mRank[lhs] > mRank[rhs]){\n      mParent[rhs] = lhs;\n    }\n    else{\n      mParent[rhs] = lhs;\n      if(mRank[lhs] == mRank[rhs]) mRank[lhs]++;\n    }\n  }\n\n  int size() const{\n    return mSize;\n  }\n};\n\nclass State{\npublic:\n  int from;\n  int to;\n  int cost;\n  State(int _f,int _t,int _c) :\n    from(_f), to(_t), cost(_c) {}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int num_of_nodes;\n  int num_of_edges;\n  while(~scanf(\"%d %d\",&num_of_nodes,&num_of_edges)){\n    if(num_of_nodes == 0 && num_of_edges == 0) break;\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    for(int edge_idx = 0; edge_idx < num_of_edges; edge_idx++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      from--; to--;\n      que.push(State(from,to,cost));\n    }\n\n    UnionFindTree uft(num_of_nodes);\n\n    vector<int> log;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(!uft.same(s.from,s.to)){\n        uft.unite(s.from,s.to);\n        log.push_back(s.cost);\n      }\n    }\n\n    printf(\"%d\\n\",log[log.size()/2]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1000005;\nconst ll INF=1LL<<50;\n\nint par[MAX],size[MAX];\n\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        size[i]=1;\n    }\n}\n\nint root(int a){\n    if(par[a]==a) return a;\n    else return par[a]=root(par[a]);\n}\n\nvoid unite(int a,int b){\n    if(root(a)!=root(b)){\n        size[root(a)]+=size[root(b)];\n        par[root(b)]=root(a);\n    }\n}\n\nbool check(int a,int b){\n    return root(a)==root(b);\n}\n\nstruct edge{\n    int from;\n    int to;\n    int dis;\n};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M;cin>>N>>M;\n        if(N+M==0) break;\n        vector<edge> S(M);\n        for(int i=0;i<M;i++){\n            int a,b,c;cin>>a>>b>>c;\n            a--;b--;\n            S[i]={a,b,c};\n        }\n        sort(all(S),[](edge a,edge b){\n            return a.dis<b.dis;\n        });\n        \n        int cnt=0;\n        init(N);\n        \n        for(int i=0;i<M;i++){\n            int a=S[i].from,b=S[i].to;\n            if(!check(a,b)){\n                cnt++;\n                unite(a,b);\n            }\n            if(cnt==N/2){\n                cout<<S[i].dis<<endl;\n                break;\n            }\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\nstruct edge{\n    int u, v, c;\n    bool operator<(const edge &e)const{\n        return c < e.c;\n    }\n};\n\nstruct UnionFind{\n    vector<int> par, sz;\n    UnionFind(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        for(int i = 0; i < n; i++) par[i] = i;\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        par[y] = x;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nint n, m;\nvector<edge> es; \n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        es.clear();\n        es.resize(m);\n        rep(i, 0, m){\n            cin >> es[i].u >> es[i].v >> es[i].c;\n            es[i].u--; es[i].v--;\n        }\n        UnionFind uf(n);\n        sort(es.begin(), es.end());\n        int ans = -1;\n        int cnt = 0;\n        rep(i, 0, m){\n            if(!uf.same(es[i].u, es[i].v)){\n                uf.unite(es[i].u, es[i].v);\n                cnt++;\n                if(cnt == n / 2){\n                    ans = es[i].c;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint par[1000];\n\nvoid init(int n){\n    REP(i,n){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if (par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid merge(int x, int y){\n    x = find(x);\n    y = find(y);\n    if (x==y) return;\n    par[x] = y;\n}\n\nstruct edge{ int u, v, cost; };\n\nvector<edge> es;\nint n;\n\nbool comp(const edge &e1, const edge &e2){\n    return e1.cost < e2.cost;\n}\n\nint kruskal(){\n    sort(es.begin(), es.end(), comp);\n    init(n);\n    VI e_used;\n    REP(i,es.size()){\n        edge e = es[i];\n        if (!same(e.u, e.v)){\n            merge(e.u, e.v);\n            e_used.push_back(e.cost);\n        }\n    }\n    return e_used[n/2-1];\n}\n\nint main() {\n    int m;\n    while (cin >> n >> m && n){\n        es.clear();\n        while (m--){\n            edge e;\n            cin >> e.u >> e.v >> e.cost;\n            e.u--;\n            e.v--;\n            es.push_back(e);\n        }\n        cout << kruskal() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint par[1001];\n\nvoid init(int n)\n{\n    memset(par, -1, sizeof(par));\n}\n\nint find(int x)\n{\n    if (par[x] < 0) return (x);\n    return (par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (-par[x] < -par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n\nbool same(int x, int y)\n{\n    return (find(x) == find(y));\n}\n\n\nint main()\n{\n    int n, m;\n    \n    while (scanf(\"%d %d\", &n, &m) && n){\n        vector<pair<int, pair<int, int> > > es(m);\n        \n        for (int i = 0; i < m; i++){\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c);\n            es[i] = make_pair(c, make_pair(a, b));\n        }\n        \n        sort(es.begin(), es.end());\n        \n        int l = 1, r = 1000;\n        \n        while (l != r){\n            int mid = l + r >> 1;\n            init(n + 1);\n            int ec = 0;\n            int i = 0;\n            while (ec != n - 1 && i != m){\n                if (ec + 1 <= n / 2 && es[i].first > mid){\n                    i++;\n                    continue;\n                }\n                if (!same(es[i].second.first, es[i].second.second)){\n                    merge(es[i].second.first, es[i].second.second);\n                    ec++;\n                }\n                i++;\n            }\n            \n            if (ec == n - 1) r = mid;\n            else l = mid + 1;\n        }\n        \n        printf(\"%d\\n\", l);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 1005\nint pre[MAX],rank[MAX];\nstruct node\n{\n    int u,v,cost;\n}edge[MAX*10];\nvoid make_set(int x)\n{\n    pre[x]=x;\n    rank[x]=0;\n}\nint find(int x)\n{\n    if (x!=pre[x])\n        pre[x]=find(pre[x]);\n    return pre[x];\n}\nint cmp(node x,node y)\n{\n    return x.cost<y.cost;\n}\nvoid unionone(int a,int b)\n{\n    int len1=find(a);\n    int len2=find(b);\n    if (rank[len1]>rank[len2])\n        pre[len2]=len1;\n    else\n        pre[len1]=len2;\n}\nint kruskal(int n,int min)\n{\n    int i,j;\n    int cnt=0;\n    for(i=0;i<n;i++)\n    {\n        if (find(edge[i].u)!=find(edge[i].v))\n        {\n            cnt++;\n            unionone(edge[i].u,edge[i].v);\n            if (cnt==min)\n                return i;\n        }\n    }\n}\nint main()\n{\n    int m,n;\n    while(scanf(\"%d%d\",&m,&n)&&(m+n))\n    {\n        int i,j;\n        int min=m/2;\n        for(i=1;i<=m;i++)\n            make_set(i);\n        for(i=0;i<n;i++)\n        {\n            scanf(\"%d%d%d\",&edge[i].u,&edge[i].v,&edge[i].cost);\n        }\n        sort(edge,edge+n,cmp);\n        int cnt=kruskal(n,min);\n        printf(\"%d\\n\",edge[cnt].cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nint sgn(const double&r){return (r>EPS)-(r<-EPS);} // a>0  : sgn(a)>0\nint sgn(const double&a,const double&b){return sgn(a-b);} // b<=c : sgn(b,c)<=0\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,m;\n    while(cin>>n>>m, n){\n        vector<vector<pll>> edge(n);\n        ll minc=LINF, v=0;\n        rep(i,m){\n            ll s,t,c;\n            cin>>s>>t>>c;\n            s--;t--;\n            edge[s].emplace_back(t,c);\n            edge[t].emplace_back(s,c);\n            if(minc>c){minc=c; v=s;}\n        }\n        priority_queue<tlll,vector<tlll>, greater<tlll>> q;\n        vl cost(n,LINF);\n        cost[v]=0;\n        for(auto&e:edge[v]){\n            q.emplace(e.sc, v, e.fs);\n        }\n        vl ans;\n        while(!q.empty()){\n            ll c,s,t;\n            tie(c,s,t) = q.top();\n            q.pop();\n            if(cost[t]!=LINF)continue;\n            ans.push_back(c);\n            cost[t]=0;\n            for(auto&e:edge[t]){\n                if(cost[e.fs]==LINF)q.emplace(e.sc, t, e.fs);\n            }\n        }\n        sort(all(ans));\n        cout<<ans[n/2-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tint k;\n\tunion_find(int n) : v(n, -1), k(0) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t\tk++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<int> s(m), t(m), c(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> s[i] >> t[i] >> c[i];\n\t\t\ts[i]--; t[i]--;\n\t\t}\n\t\tfor (int C = 1; C <= 1000; C++) {\n\t\t\tunion_find ufs(n), ufe(n), ufg(n);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tif (c[i] < C) ufs.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] == C) ufe.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] > C) ufg.unite(s[i], t[i]);\n\t\t\tif (ufs.k + ufe.k >= n / 2 && ufe.k + ufg.k >= n / 2) {\n\t\t\t\tcout << C << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N >> M, N) {\n\t\tUnionFind uf(N);\n\t\tvector<pair<int, pair<int, int>>>v(M);\n\t\tfor (auto &i : v)cin >> i.second.first >> i.second.second >> i.first;\n\t\tsort(v.begin(), v.end());\n\t\tint used = 0;\n\t\tfor (auto i : v) {\n\t\t\tif (uf.Check_Same(i.second.first, i.second.second))continue;\n\t\t\tused++;\n\t\t\tuf.Unite(i.second.first, i.second.second);\n\t\t\tif (used * 2 == N) {\n\t\t\t\tcout << i.first << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ntypedef struct UnionFindTree{\n    vector<int> par;\n\n    UnionFindTree(int n){\n        par.resize(n, -1);\n    }\n\n    bool is_root(int x){\n        return par[x]<0;\n    }\n\n    int find(int x){\n        if(is_root(x)) return x;\n        return par[x] = find(par[x]);\n    }\n\n    int size(int x){\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n}UF;\n\ntemplate<typename T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n \ntemplate<typename T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n \n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n \n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n};\n\nint n, m;\n\nvoid solve(){\n    vector<edge<int>> E;\n    rep(i, m){\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        --a; --b;\n        E.emplace_back(a, b, c);\n    }\n    UF uf(n);\n    sort(E.begin(), E.end(), [](const edge<int> &e1, const edge<int> &e2){\n        return e1.cost < e2.cost;\n    });\n    vector<int> mst;\n    for(auto &e: E){\n        if(uf.unite(e.from, e.to)) mst.push_back(e.cost);\n    }\n    printf(\"%d\\n\", mst[n / 2 - 1]);\n}\n\nint main(){\n    while(scanf(\"%d%d\", &n, &m) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tint k;\n\tunion_find(int n) : v(n, -1), k(0) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t\tk++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<int> s(m), t(m), c(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> s[i] >> t[i] >> c[i];\n\t\t\ts[i]--; t[i]--;\n\t\t}\n\t\tfor (int C = 1; C <= 1000; C++) {\n\t\t\tunion_find ufs(n), ufe(n), ufg(n);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tif (c[i] < C) ufs.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] == C) ufe.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] > C) ufg.unite(s[i], t[i]);\n\t\t\tif (ufs.k + ufe.k >= n / 2 && ufg.k >= n / 2 - 1) {\n\t\t\t\tcout << C << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n#define pb push_back\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n    for(auto &e:u) fill_v<T>(e,v...);\n}\n\n/*\nstring s;\nvector<char> ops({'+', '-', '*', '.', '.'});\nmap<char, int> rank;\n\nint64 calc(int64 l, int64 r);\nint64 expr(const string& s, int& p);\nint64 number(const string& s, int& p);\n\nint64 expr(const string& s, int& p, int rank = 0) {\n    int64 now = 0;\n    while (p != s.size()) {\n        if (s[p] == '(') {\n            p++;\n            now = expr(s, p, 0);\n            p++;\n        }\n    }\n}\n\nint main(void){\n    cin >> s;\n    sort(all(ops));\n    int64 res = -INF_LL;\n    do {\n        int cnt = 0;\n        REP(i, ops.size()) {\n            if (ops[i] == '.') cnt++;\n            else rank[ops[i]] = cnt;\n        }\n        int p = 0;\n        expr(s, p, 0);\n    }while(next_permutation(all(ops)));\n}\n*/\n\n\nstruct UnionFind{\n  vector<int32> par;\n\n  UnionFind(int32 n){\n      REP(i,n){\n          par.pb(-1);\n      }\n  }\n\n  int32 root(int32 x){\n      if(par[x] == -1)return x;\n      return par[x] = root(par[x]);\n  }\n\n  void unite(int32 a, int32 b){\n      a = root(a);\n      b = root(b);\n      par[a] = b;\n      return;\n  }\n\n  bool same(int32 x, int32 b){\n    return root(x) == root(b);\n  }\n};\n\nint main(void){\n    int32 n,m;\n    while(cin >> n >> m && n && m){\n        using T = tuple<int64, int64, int64>;\n        UnionFind uf(n);\n        vector<T> edges;\n        REP(i,m){\n            int32 s,t,c;\n            cin >> s >> t >> c;s--;t--;\n            edges.emplace_back(c,s,t);\n        }\n        sort(all(edges));\n        int32 cntEdge = 0;\n        REP(i,m){\n            int32 c,s,t;\n            tie(c,s,t) = edges[i];\n            if(!uf.same(s,t)){\n                uf.unite(s,t);\n                cntEdge++;\n                if(cntEdge == n / 2){\n                    cout << c << endl;\n                    break;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n) {\n    par.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\nstruct Edge {\n  int a, b, c;\n  bool operator < (const Edge &e) const {\n    return c < e.c;\n  }\n};\n\nint main() {\n  for(int n, m; cin >> n >> m && (n|m);) {\n    vector<Edge> es;\n    while(m--) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      es.push_back((Edge){a,b,c});\n    }\n    sort(es.begin(), es.end());\n    UnionFind uf(n);\n    int cnt = 0;\n    for(int i = 0; i < es.size(); ++i) {\n      if(uf.same(es[i].a, es[i].b)) continue;\n      uf.unite(es[i].a, es[i].b);\n      if(++cnt == n / 2) {\n        cout << es[i].c << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <tuple>\n\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par, sz;\n\n    UnionFind(int N) : par(N), sz(N, 1) {\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        return par[v] == v ? v : par[v] = find(par[v]);\n    }\n\n    void unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (sz[u] < sz[v]) swap(u, v);\n\n        sz[u] += sz[v];\n        par[v] = u;\n    }\n};\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0) return false;\n\n    vector<tuple<int, int, int>> edges(M);\n    for (auto& e : edges) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        --u, --v;\n        e = make_tuple(c, u, v);\n    }\n\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(N);\n    int cnt = 0;\n    for (auto e : edges) {\n        int u, v, c;\n        tie(c, u, v) = e;\n        if (uf.find(u) == uf.find(v)) continue;\n        if (++cnt == N / 2) {\n            cout << c << endl;\n            break;\n        }\n        uf.unite(u, v);\n    }\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint uf[1000];\n\nint find(int a){\n  if(uf[a]==a) return a;\n  else return uf[a]=find(uf[a]);\n}\n\nvoid uni(int a,int b){\n  find(a);\n  find(b);\n  uf[uf[a]]=uf[b];\n  return;\n}\n\nstruct node{\n  int s;\n  int t;\n  int c;\n  bool operator<(const struct node& another) const{\n    return c<another.c;\n  }\n};\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<struct node> e(m);\n    int s,t,c;\n    for(int i=0;i<n;i++){\n      uf[i]=i;\n    }\n    for(int i=0;i<m;i++){\n      cin >> e[i].s >> e[i].t >> e[i].c;\n      e[i].s--;\n      e[i].t--;\n    }\n    sort(e.begin(),e.end());\n    int count=0;\n    vector<int> cost(n-1);\n    for(int i=0;i<m;i++){\n      if(find(e[i].s)!=find(e[i].t)){\n        uni(e[i].s,e[i].t);\n        cost[count]=e[i].c;\n        count++;\n      }\n      if(count==n-1){\n        cout << cost[n/2-1] << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge es[100000]; int used[100000];\nint V, E; vector<int>v;\nvoid kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V); v.clear();\n\trep(i, 100000)used[i] = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tv.push_back(e.cost);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\twhile (cin >> V >> E,V) {\n\t\tint x, y, z;\n\t\trep(i, E) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tes[i] = { x,y,z };\n\t\t}\n\t\tkruskal();\n\t\tdouble mid = 0;\n\t\trep(i, E) {\n\t\t\tif (used[i] == 0) {\n\t\t\t\tif (v.size() % 2) {\n\t\t\t\t\tmid = v[v.size() / 2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmid = (v[v.size() / 2] + v[v.size() / 2 - 1]) / (double)2;\n\t\t\t\t}\n\t\t\t\tif (mid <= es[i].cost)break;\n\t\t\t\telse v.push_back(es[i].cost);\n\t\t\t}\n\t\t}\n\t\tif (v.size() % 2) {\n\t\t\tmid = v[v.size() / 2];\n\t\t}\n\t\telse {\n\t\t\tmid = (v[v.size() / 2] + v[v.size() / 2 - 1]) / (double)2;\n\t\t}\n\t\tcout << mid << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nclass Union_Find\n{\npublic:\n    vector<int> par;\n\n    void init(int n) {\n        par.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x < y) par[y] = x;\n        else par[x] = y;\n    }\n};\n\nint N, M;\n\nvoid solve() {\n    vector<PP> V;\n    for (int i = 0; i < M; i++) {\n        int x, y, c;\n        cin >> x >> y >> c;\n        x--; y--;\n        V.push_back(PP(c, P(x, y)));\n    }\n\n    sort(V.begin(), V.end());\n\n    vector<bool> used(N, false);\n    int count = 0;\n    Union_Find uf;\n    uf.init(N);\n    for (int i = 0; i < M; i++) {\n        PP pp = V[i];\n        int cost = pp.first;\n        int x = pp.second.first;\n        int y = pp.second.second;\n        if (uf.find(x) == uf.find(y)) continue;\n        count++;\n        uf.unite(x, y);\n\n        if (count == (N + 1) / 2) {\n            cout << cost << endl;\n            return ;\n        }\n    }\n}\n\nint main() {\n    while (cin >> N >> M, N || M) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 1005\n#define INF (1<<21)\n#define WHITE 0\n#define GRAY  1\n#define BLACK 2\nint M[MAX][MAX];\nint n,x;\nint prim(){\n  vector<int> v;\n  int u,minv;\n  int d[MAX],p[MAX],color[MAX];\n  for(int i=0;i<n;i++){\n    d[i]=INF;\n    p[i]=-1;\n    color[i]=WHITE;\n  }\n  d[0]=0;\n  while(1){\n    minv=INF;\n    u=-1;\n    for(int i=0;i<n;i++){\n      if(minv>d[i]&&color[i]!=BLACK){\n\tu=i;\n\tminv=d[i];\n      }\n    }\n    if(u==-1) break;\n    color[u]=BLACK;\n    for(int i=0;i<n;i++){\n      if(color[i]!=BLACK&&M[u][i]!=INF){\n\tif(d[i]>M[u][i]){\n\t  d[i]=M[u][i];\n\t  p[i]=u;\n\t  color[i]=GRAY;\n\t}\n      }\n    }\n  }\n  for(int i=0;i<n;i++){\n    if(~p[i]) v.push_back(M[i][p[i]]);\n  }\n  sort(v.begin(),v.end());\n  if(v.size()%2) return v[v.size()/2];\n  return (v[v.size()/2]+v[v.size()/2-1])/2;\n}\nint main(){\n  while(cin>>n>>x,n||x){\n    int s,t,c;\n    for(int i=0;i<MAX;i++){\n      for(int j=0;j<MAX;j++){\n\tM[i][j]=INF;\n      }\n    }\n    for(int i=0;i<x;i++){\n      cin>>s>>t>>c;\n      M[s-1][t-1]=c;\n      M[t-1][s-1]=c;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint UF[1100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;\n\tUF[a]+=UF[b];UF[b]=a;\n}\npair<int,pair<int,int> > edge[11000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tp--;q--;\n\t\t\tedge[i]=make_pair(r,make_pair(p,q));\n\t\t}\n\t\tstd::sort(edge,edge+b);\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tint cnt=a;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(FIND(edge[i].second.first)!=FIND(edge[i].second.second)){\n\t\t\t\tcnt--;\n\t\t\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\t\t\tif(cnt==a/2){\n\t\t\t\t\tprintf(\"%d\\n\",edge[i].first);break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\n\ntypedef tuple<int, int, int> Tp;\n#define at(t, i) get<i>(t)\n\nint n, m;\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tUnionFind uf(n);\n\t\tvector<Tp> es;\n\t\tvector<int> v;\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint s, t, c;\n\t\t\tscanf(\"%d %d %d\", &s, &t, &c);\n\t\t\tes.push_back(Tp(c, --s, --t));\n\t\t}\n\t\t\n\t\tsort(es.begin(), es.end());\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tif (uf.unite(at(es[i], 1), at(es[i], 2))){\n\t\t\t\tv.push_back(at(es[i], 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = v[v.size() / 2];\n\t\tif (v.size() % 2 == 0){\n\t\t\tres += v[v.size() / 2 + 1];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<map>\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\n \ntypedef pair<int,int> P;\nstruct edge{int u,v,cost;};\nbool comp(const edge& e1, const edge& e2){return e1.cost<e2.cost;}\n \nint n,m;\nint s,t,c;\nedge e[10100];\nvector<int> sp;\nvector<P> g[1010];\nbool use[1010],h[10100];\n \nint dfs(int pos){\n  if(use[pos])return 0;\n  use[pos] = true;\n  int res = 1;\n  for(int i=0;i<g[pos].size();i++){\n    if(h[g[pos][i].sc])continue;\n    res += dfs(g[pos][i].fs);\n  }\n  return res;\n}\n \nint main(){\n  while(cin >> n >> m,n||m){\n    for(int i=0;i<m;i++){\n      sp.clear();\n      cin >> s >> t >> c;\n      s--; t--;\n      e[i].u = s;\n      e[i].v = t;\n      e[i].cost = c;\n    }\n \n    sort(e,e+m,comp);\n    sp.clear();    \n \n    for(int i=0;i<n;i++)g[i].clear();\n    \n    for(int i=0;i<m;i++){\n      g[e[i].u].pb(P(e[i].v,i));\n      g[e[i].v].pb(P(e[i].u,i));\n      h[i] = false;\n    }\n \n    for(int i=m-1;i>=0;i--){\n      for(int j=0;j<n;j++)use[j] = false;\n      h[i] = true;\n      if(dfs(0) != n){\n\th[i] = false;\n\tsp.pb(e[i].cost);\n      }\n    }\n        \n    sort(sp.begin(),sp.end());\n    cout << sp[n/2-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge es[100000]; int used[100000];\nint V, E; vector<int>v;\nvoid kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V); v.clear();\n\trep(i, 100000)used[i] = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tv.push_back(e.cost);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\twhile (cin >> V >> E,V) {\n\t\tint x, y, z;\n\t\trep(i, E) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tes[i] = { x,y,z };\n\t\t}\n\t\tkruskal();\n\t\tdouble mid = 0;\n\t\trep(i, E) {\n\t\t\tif (used[i] == 0) {\n\t\t\t\tif (v.size() % 2) {\n\t\t\t\t\tmid = v[v.size() / 2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmid = (v[v.size() / 2] + v[v.size() / 2 - 1]) / (double)2;\n\t\t\t\t}\n\t\t\t\tif (mid <= es[i].cost)break;\n\t\t\t\tv.push_back(es[i].cost);\n\t\t\t\tsort(v.begin(), v.end());\n\t\t\t}\n\t\t}\n\t\tif (v.size() % 2) {\n\t\t\tmid = v[v.size() / 2];\n\t\t}\n\t\telse {\n\t\t\tmid = (v[v.size() / 2] + v[v.size() / 2 - 1]) / (double)2;\n\t\t}\n\t\tcout << mid << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct Edge{\n    int a,b,c;\n};\nbool operator < (const Edge &a, const Edge &b){\n    return a.c < b.c;\n}\nint n,m;\n \nint uf[10010];\nint get(int x){\n    return x == uf[x] ? x : uf[x] = get(uf[x]);\n}\nint unite(int x,int y){\n    if( rand() & 1 ) swap(x,y);\n    uf[get(x)] = get(y);\n}\n \nvector<Edge> es;\nint check(int lim){\n    for(int i = 0 ; i < n ; i++) uf[i] = i;\n    int need1 = n/2;\n    int need2 = n - 1 - need1;\n    for(int i = 0 ; i < es.size() ; i++){\n        auto &e = es[i];\n        if( e.c <= lim ){\n            if( need1 ){\n                auto &e = es[i];\n                if( get(e.a) != get(e.b) ){\n                    unite(e.a,e.b);\n                    need1--;\n                }\n            }else if( need2 ){\n                unite(e.a,e.b);\n                need2--;\n            }\n        }else{\n            if( need2 ){\n                unite(e.a,e.b);\n                need2--;\n            }\n        }\n    }\n    return need1 == 0 && need2 == 0;\n}\nint main(){\n    while(cin >> n >> m && n){\n        es.resize(m);\n        for(int i = 0 ; i < m ; i++) cin >> es[i].a >> es[i].b >> es[i].c;\n        sort(es.begin(),es.end());\n        //for(int i = 0 ; i < 1000 ; i++)\n        //  cout << i << \":\" << check(i) << endl;\n        //return 0;\n        int l = 0 , r = 1000;\n        while( l != r ){\n            int lim = (l+r)/2;\n            if( check(lim) ){\n                r = lim;\n            }else{\n                l = lim+1;\n            }\n        }\n        cout << l << endl;\n    }\n             \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int a, int b, int c) : from(a), to(b), cost(c) {}\n    bool operator<(const Edge &x) const {\n        return cost < x.cost;\n    }\n};\n\nstruct UnionFind {\n    int node[1010];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    int size(int x) {\n        return -node[find(x)];\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        if(size(x) > size(y)) swap(x, y);\n        node[y] += node[x];\n        node[x] = y;\n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    while(1) {\n        scanf(\"%d%d\", &N, &M);\n        if(!N) break;\n        vector<Edge> edges;\n        for(int i=0; i<M; i++) {\n            int s, t, c;\n            scanf(\"%d%d%d\", &s, &t, &c); s--; t--;\n            edges.push_back(Edge(s, t, c));\n        }\n\n        sort(edges.begin(), edges.end());\n        vector<int> use_cost;\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            Edge e = edges[i];\n            if(uf.unite(e.from, e.to)) {\n                use_cost.push_back(e.cost);\n            }\n        }\n        int mid = (N-1) / 2;\n        printf(\"%d\\n\", use_cost[mid]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nvector<edge> ans;\n\nvoid kruskal(){\n  sort(all(es),cmp);\n  \n  init(V);\n  rep(i,E){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      ans.push_back(e);\n    }\n  }\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n    ans.clear();\n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a,b,c});\n    }\n\n    kruskal();\n    \n    sort(all(ans),cmp);\n    \n    if(ans.size()%2==0)cout << (int)round((double)(ans[ans.size()/2].cost+ans[ans.size()/2-1].cost)/2) << endl;\n    else cout << ans[ans.size()/2].cost << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct edge {\n    int to, cost;\n    edge(int to, int cost) : to(to), cost(cost) {}\n};\n\nstruct UF {\n    vector<int> data;\n\n    UF(int n) {\n        data.resize(n, -1);\n    }\n\n    int root(int i) {\n        return data[i] < 0 ? i : data[i] = root(data[i]);\n    }\n\n    int size(int i) {\n        return -data[root(i)];\n    }\n\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n\n        if (x == y) return ;\n\n        if (size(x) < size(y)) swap(x, y);\n\n        data[x] += data[y];\n        data[y] = x;\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nvector<edge> G[1010];\n\nint N, M;\n\nint main()\n{\n    while (cin >> N >> M, N) {\n        UF uf(N);\n\n        vector<pair<int, pii>> edges;\n\n        for (int i = 0; i < M; ++i) {\n            int s, t, c; cin >> s >> t >> c;\n\n            --s, --t;\n\n            G[s].push_back(edge(t, c));\n            G[t].push_back(edge(s, c));\n\n            edges.push_back(make_pair(c, pii(s, t)));\n        }\n\n        sort(begin(edges), end(edges));\n\n        vector<int> a;\n\n        for (pair<int, pii> e : edges) {\n            int cost = e.first;\n            pii info = e.second;\n            if (!uf.same(info.first, info.second)) {\n                uf.unite(info.first, info.second);\n                a.push_back(cost);\n            }\n        }\n\n        sort(begin(a), end(a));\n\n        cout << a[a.size() / 2] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) { parent.assign(n, -1); }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    Edges g;\n    REP(i,m){\n      int s,t,c;\n      cin>>s>>t>>c;\n      --s;--t;\n      g.push_back((Edge){s,t,c});\n      g.push_back((Edge){t,s,c});\n    }\n    auto res = kruskal(n, g);\n    cout << res[n/2-1].weight << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nint N, M;\nvector<tuple<int,int,int>> es;\n\nbool check(int idx){\n  int H = (N - 2) / 2;\n  if(idx < H || M - idx - 1 < H)\n\treturn false;\n\t   \n  UnionFind uf1(N);\n  REP(i,idx+1)\n\tuf1.unite(get<1>(es[i]), get<2>(es[i]));\n  VI edges;\n  FOR(i,idx+1,M){\n\tint s, t, c;\n\ttie(c,s,t) = es[i];\n\tif(uf1.same(s, t)) continue;\n\tuf1.unite(s, t);\n\tedges.PB(i);\n  }\n\n  bool ok = true;\n  REP(i,N) if(!uf1.same(i,0)) ok = false;\n  if(SZ(edges) > H || !ok)\n\treturn false;\n\n  UnionFind uf2(N);\n  uf2.unite(get<1>(es[idx]), get<2>(es[idx]));\n  REP(i,SZ(edges)){\n\tint s, t, c;\n\ttie(c,s,t) = es[edges[i]];\n\tuf2.unite(s,t);\n  }\n  for(int i=idx+1;i<M&&SZ(edges)<H;++i){\n\tint s, t, c;\n\ttie(c,s,t) = es[i];\n\tif(uf2.same(s,t)) continue;\n\tuf2.unite(s,t);\n\tedges.PB(i);\n  }\n  if(SZ(edges) != H)\n\treturn false;\n\n  REP(i,idx){\n\tint s, t, c;\n\ttie(c,s,t) = es[i];\n\tif(uf2.same(s,t)) continue;\n\tuf2.unite(s,t);\n  }\n\n  ok = true;\n  REP(i,N) if(!uf2.same(i,0)) ok = false;\n  return ok;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N>>M,N){\n\tes.assign(M, tuple<int,int,int>());\n\tREP(i,M){\n\t  cin >> get<1>(es[i]) >> get<2>(es[i]) >> get<0>(es[i]);\n\t  get<1>(es[i])--;\n\t  get<2>(es[i])--;\n\t}\n\tSORT(es);\n\n\tfor(int i=0;i<M;++i){\n\t  if(check(i)){\n\t\tcout << get<0>(es[i]) << endl;\n\t\tbreak;\n\t  }\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int INF = 0xfffffff;\nconst int MAXN = 2010;\nconst int MAXM = 50010;\nstruct Edge{\n    int u, v, f, nxt;\n};\nint N, M;\nint nume;\nint g[MAXN];\nEdge e[MAXM];\nint fa[MAXN];\nvoid addEdge(int u, int v, int c)\n{\n    e[++nume].v = v;\n    e[nume].u = u;\n    e[nume].f = c;\n    e[nume].nxt = g[u];\n    g[u] = nume;\n}\n\nbool cmp(Edge a, Edge b)\n{\n    return a.f < b.f;\n}\nint getfather(int x)\n{\n    if(x == fa[x])\n        return x;\n    else\n        return fa[x] = getfather(fa[x]);\n}\nint kruscal() {\n    vector<int> vec;\n    sort(e+1, e+nume+1, cmp);\n    int cnt = N;\n    for(int i = 1; i <= N; i++)  fa[i] = i;\n    for(int i = 1; i <= nume; i++) {\n        int t1 = getfather(e[i].u);\n        int t2 = getfather(e[i].v);\n        if(t1 != t2) {\n            fa[t1] = t2;\n            cnt--;\n            vec.push_back(e[i].f);\n            if(cnt==1)\n                break;\n        }\n    }\n    //for(int i = 0; i < vec.size(); i++)\n    //    cout<<vec[i]<<endl;\n    //sort(vec.begin(), vec.end());\n    return vec[vec.size()/2];\n    //if(vec.)\n}\nint main()\n{\n    while(cin>>N>>M&&N&&M) {\n        nume = 0;\n        memset(g, 0, sizeof(g));\n        for(int i = 1; i <= M; i++) {\n            int x, y, xy;\n            cin>>x>>y>>xy;\n            addEdge(x, y, xy);\n            addEdge(y, x, xy);\n        }\n        cout<<kruscal()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, -1)\n\t{}\n\tvoid init(int n) {\n\t\tpar_.assign(n, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn par_[x] < 0 ? x : par_[x] = root(par_[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[x] < par_[y]) {\n\t\t\t\tpar_[x] += par_[y];\n\t\t\t\tpar_[y] = x;\n\t\t\t} else {\n\t\t\t\tpar_[y] += par_[x];\n\t\t\t\tpar_[x] = y;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn -par_[root(x)];\n\t}\n\nprivate:\n\tstd::vector<int> par_;\n};\n\nll n,m;\n\nll solve() {\n\tunion_find uf(n);\n\tll cnct=n;\n\tvector<pair<ll,P>> edg;\n\tREP(i,m) {\n\t\tll s,t,c;\n\t\tcin>>s>>t>>c;\n\t\ts--; t--;\n\t\tedg.pb(make_pair(c,P(s,t)));\n\t}\n\tsort(ALL(edg));\n\tREP(i,m) {\n\t\tif(!uf.same(edg[i].second.first,edg[i].second.second)) cnct--;\n\t\tif(cnct==n/2) return edg[i].first;\n\t\tuf.unite(edg[i].second.first,edg[i].second.second);\n\t}\n\treturn 3939;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = (a); i < n; i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N, M, S, T, C;\npair<int, pii> E[10000];\nint a[1000];\n\nint find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\nvoid unite(int i, int j) { a[find(i)] = find(j); }\n\nint main(void) {\n  while(cin >> N >> M, N || M) {\n    REP(i, 0, M) {\n      cin >> S >> T >> C;\n      E[i] = pair<int, pii>(C, pii(S, T));\n    }\n\n    sort(E, E + M);\n\n    vector<int> cost;\n    REP(i, 0, N) a[i] = i;\n    REP(i, 0, M) {\n      S = E[i].se.fi;\n      T = E[i].se.se;\n      C = E[i].fi;\n      if(find(S) != find(T)) {\n        unite(S, T);\n        cost.push_back(C);\n      }\n    }\n\n    int median;\n    if(cost.size() % 2 == 0) {\n      median = (cost[cost.size() / 2 - 1] + cost[cost.size() / 2]) / 2;\n    } else {\n      median = cost[cost.size() / 2];\n    }\n    cout << median << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nclass QuickFind {\nprivate:\n\tint n;\n\tvector< vector< int > > group;\n\tvector< int > mapping;\n\t\npublic:\n\tQuickFind(int __n) : n(__n), group(__n, vector< int >()), mapping(__n) {\n\t\tfor_(i,0,n) {\n\t\t\tgroup[i].push_back(i);\n\t\t\tmapping[i] = i;\n\t\t}\n\t}\n\t\n\tvoid merge(int x, int y) {\n\t\tint xi = mapping[x], yi = mapping[y];\n\t\tif (group[xi].size() > group[yi].size()) swap(xi, yi);\n\t\tfor (int i : group[xi]) {\n\t\t\tgroup[yi].push_back(i);\n\t\t\tmapping[i] = yi;\n\t\t}\n\t\tgroup[xi] = vector< int >();\n\t}\n\t\n\tbool same(int x, int y) { return mapping[x] == mapping[y]; }\n};\n\nstruct Edge {\n\tint u, v, c;\n\tbool operator < (const Edge& e) const { return c < e.c; }\n};\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n > 0) {\n\t\tvector< Edge > edge;\n\t\tfor_(i,0,m) {\n\t\t\tint u, v, c;\n\t\t\tcin >> u >> v >> c;\n\t\t\t--u; --v;\n\t\t\tedge.push_back(Edge{u, v, c});\n\t\t}\n\t\t\n\t\tsort(edge.begin(), edge.end());\n\t\t\n\t\tQuickFind qf(n);\n\t\t\n\t\tint cnt = n / 2;\n\t\tfor_(i,0,m) {\n\t\t\tEdge e = edge[i];\n\t\t\tif (qf.same(e.u, e.v)) continue;\n\t\t\tqf.merge(e.u, e.v);\n\t\t\t--cnt;\n\t\t\tif (cnt == 0) {\n\t\t\t\tcout << e.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass unionfind{\npublic:\n    vector<int> v;\n    vector<int> rank;\n\n    unionfind(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int find(int x){\n        if(v[x] != x){\n            v[x] = find(v[x]);\n        }\n        return v[x];\n    }\n    void marge(int a, int b){\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nstruct edge{\n    int s,t;\n    int cost;\n    edge(int s, int t, int c):s(s), t(t), cost(c){}\n    edge(){}\n    bool operator < (const edge &a) const{\n        return cost < a.cost;\n    }\n};\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        vector<edge> ve(m);\n        for(int i=0; i<m; i++){\n            int s,t,c;\n            cin >> s >> t >> c;\n            s--; t--;\n            ve[i] = edge(s,t,c);\n        }\n        sort(ve.begin(), ve.end());\n\n        unionfind uf(n);\n        int count = 0;\n        for(int i=0; i<m; i++){\n            if(uf.find(ve[i].s) != uf.find(ve[i].t)){\n                uf.marge(ve[i].s, ve[i].t);\n                count++;\n                if(count == n/2){\n                    cout << ve[i].cost << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n;\nint g[1005][1005];\nbool use_edge[1005][1005];\n\n\n\nconst int gmax_n = 1005;\n\nint par[gmax_n]; //ティツヲツェ\nint depth[gmax_n];//テヲツ慊ィテ」ツ?ョテヲツキツアテ」ツ??\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint main(){\n    int m;\n    while(cin >> n >> m, n){\n        pair<int, pair<int, int>> p[10005];\n        int ans = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            p[i] = make_pair(c,make_pair(a,b));\n        }\n        sort(p, p + m);\n\n        memset(use_edge, 0, sizeof(use_edge));\n        init(n);\n        rep(i,n / 2){\n            int a = p[i].second.first;\n            int b = p[i].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            unite(a,b);\n\n            set<int> s;\n            rep(j,n) s.insert(find(j));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[i].first);\n            }\n        }\n        init(n);\n        rep(i,n / 2){\n            int a = p[n - i - 1].second.first;\n            int b = p[n - i - 1].second.second;\n            unite(a,b);\n            set<int> s;\n            rep(j,n) s.insert(find(j));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[n - i - 1].first);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\npublic:\n\tunion_find(int n):uf(n, -1) {}\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tbool unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\n\t\tif(a == b) return false;\n\n\t\tif(uf[a] > uf[b]) {\n\t\t\tswap(a, b);\n\t\t}\n\t\telse if(uf[a] == uf[b]) {\n\t\t\t--uf[a];\n\t\t}\n\n\t\tuf[b] = a;\n\t\treturn true;\n\t}\n};\n\nstruct edge {\n\tint u, v;\n\tint cost;\n\tedge(int u, int v, int c):u(u), v(v), cost(c){}\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint calc(int n, vector<edge> &edges) {\n\tsort(edges.begin(), edges.end());\n\n\tint cnt = 0;\n\tunion_find uf(n);\n\tfor(const auto &e : edges) {\n\t\tif(uf.unite(e.u, e.v) && ++cnt == n / 2) return e.cost;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<edge> edges;\n\t\tedges.reserve(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint s, t, c;\n\t\t\tcin >> s >> t >> c;\n\t\t\tedges.emplace_back(s - 1, t - 1, c);\n\t\t}\n\t\tcout << calc(n, edges) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge es[100000];\nint V, E; vector<int>v;\nvoid kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V); v.clear();\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tv.push_back(e.cost);\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> V >> E, V) {\n\t\tint x, y, z;\n\t\trep(i, E) {\n\t\t\tcin >> x >> y >> z; x--; y--;\n\t\t\tes[i] = { x,y,z };\n\t\t}\n\t\tkruskal();\n\t\tcout << v[V/ 2-1] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n    int n, m;\n    while(1)\n    {\n        scanf(\"%d%d\", &n, &m);\n        if(n + m == 0)\n            break;\n        int num[1011] = {0};\n        for(int i = 0; i < m; i++)\n        {\n            scanf(\"%*d%*d%d\", num + i);\n        }\n        sort(num, num + m);\n        printf(\"%d\\n\", num[n / 2 - 1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz); rep(i,sz){ par[i] = i; nrank[i] = 0; } }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]){ par[x] = y; }else{ par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; } }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\ntemplate<typename T> class Kruskal{\npublic:\n\tstruct edge{\n\t\tint u,v;\n\t\tT cost;\n\t\tbool operator<(const edge& another) const {\n\t\t\treturn cost < another.cost;\n\t\t}\n\t};\n\tvector<edge> es;\n\tvector<int> par,rrank;\n\tint V;\n    Kruskal(int node_size){\n        V = node_size;\n\t\tpar.resize(node_size), rrank.resize(node_size);\n\t}\n\tvoid add_edge(int u,int v,T cost){\n\t\tes.push_back((edge){u,v,cost});\n\t}\n\tvoid solve(){\n\t\tUF uf(V);\n\t\tT res = 0;\n\t\tint cnt = 0;\n        sort(es.begin(),es.end());\n\t\trep(i,es.size()){\n\t\t\tedge e = es[i];\n\t\t\tif(!uf.same(e.u,e.v)){\n\t\t\t\tuf.unite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt == V/2){\n\t\t\t\t\tcout << e.cost << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(cnt == V-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n};\n\n\nint main(){\n\tint n,m;\n\t\n\twhile(cin >> n >> m&&n!=0){\n\t\tKruskal<int> kr(n);\n\t\trep(i,m){\n\t\t\tint s,t,c;\n\t\t\tcin >> s >> t >> c;\n\t\t\ts--;\n\t\t\tt--;\n\t\t\tkr.add_edge(s,t,c);\n\t\t}\n\t\tkr.solve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\tint a,b,c;\n};\nbool operator < (const Edge &a, const Edge &b){\n\treturn a.c < b.c;\n}\nint n,m;\n\nint uf[10010];\nint get(int x){\n\treturn x == uf[x] ? x : uf[x] = get(uf[x]);\n}\nint unite(int x,int y){\n\tif( rand() & 1 ) swap(x,y);\n\tuf[get(x)] = get(y);\n}\n\nvector<Edge> es;\nint check(int lim){\n\tfor(int i = 0 ; i < n ; i++) uf[i] = i;\n\tint need1 = 0;\n\tint need2 = 0;\n\tfor(int i = 0 ; i < es.size() ; i++){\n\t\tauto &e = es[i];\t\t\n\t\tif( get(e.a) != get(e.b) ){\n\t\t\tunite(e.a,e.b);\n\t\t\tif( e.c <= lim ){\n\t\t\t\tneed1++;\n\t\t\t}else need2++;\n\t\t}\n\t}\n\treturn need1 > need2;\n}\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tes.resize(m);\n\t\tfor(int i = 0 ; i < m ; i++) cin >> es[i].a >> es[i].b >> es[i].c, es[i].a--, es[i].b--;\n\t\tsort(es.begin(),es.end());\n\t\tint l = 0 , r = 1000;\n\t\twhile( l != r ){\n\t\t\tint lim = (l+r)/2;\n\t\t\tif( check(lim) ){\n\t\t\t\tr = lim;\n\t\t\t}else{\n\t\t\t\tl = lim+1;\n\t\t\t}\n\t\t}\n\t\tcout << l << endl;\n\t}\n\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nstruct edge {\n\tint u, v, w;\n\tedge(int _u = 0, int _v = 0, int _w = 0) : u(_u), v(_v), w(_w) {}\n\tbool operator<(const edge& o) const {\n\t\treturn w < o.w;\n\t}\n};\n\nint fa[1005];\n\nint root(int x) {\n\treturn fa[x] = (x == fa[x] ? x : root(fa[x]));\n}\n\nint n, m;\nvector<edge> e;\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m) && n) {\n\t\te.clear();\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tfa[i] = i;\n\t\t}\n\t\tint u, v, w;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\t\te.push_back(edge(u, v, w));\n\t\t}\n\t\tsort(e.begin(), e.end());\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint fa1 = root(e[i].u);\n\t\t\tint fa2 = root(e[i].v);\n\t\t\tif (fa1 != fa2) {\n\t\t\t\tfa[fa1] = fa2;\n\t\t\t\tif (++cnt == (n + 1)/2) {\n\t\t\t\t\tprintf(\"%d\\n\", e[i].w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 中央値がcで、その前後にk本ずつ、計2k+1本の辺を採用するとする\n// 前のk本はなるべくコストが小さい方が良い 後ろのk本のコストはどうでもいい\n// 結局普通に最小全域木を求めて使った辺の中央値が答え\n\nint n, m, a, b, c;\nvector<pair<int,pair<int,int> > > e;\n\nstruct UF {\n\tvector<int> p;\n\tUF(int n) : p(n, -1) {};\n\tbool unite(int u, int v) {\n\t\tif ((u = find(u)) == (v = find(v))) return false;\n\t\tif (p[u] > p[v]) swap(u, v);\n\t\tp[u] += p[v]; p[v] = u;\n\t\treturn true;\n\t}\n\tbool same(int u, int v) { return find(u) == find(v); }\n\tint find(int u) { return p[u] < 0 ? u : p[u] = find(p[u]); }\n\tint usize(int u) { return -p[find(u)]; }\n};\n\nint kruskal() {\n\tsort(e.begin(),e.end());\n\tUF uf(n);\n\tint res = 0;\n\tfor (int i=0; i<m; ++i) {\n\t\tif (!uf.same(e[i].se.fi, e[i].se.se)) {\n\t\t\tuf.unite(e[i].se.fi, e[i].se.se);\n\t\t\tres++;\n\t\t\tif (res==n/2) return e[i].fi;\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n==0) break;\n\t\te.clear();\n\t\trep(i,m) {\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\te.pb({c,{a,b}});\n\t\t}\n\t\tcout << kruskal() << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nint union_tree[2000];\nint union_find(int now) {\n\tif (union_tree[now] == now) return now;\n\treturn union_tree[now] = union_find(union_tree[now]);\n}\nint union_merge(int a, int b) {\n\ta = union_find(a);\n\tb = union_find(b);\n\tif (a == b) return 0;\n\tunion_tree[a] = b;\n\treturn 1;\n}\n\nvoid solve(){\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) return;\n\t\tvector<tuple<int, int, int>> inputs;\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tinputs.push_back(make_tuple(c, a, b));\n\t\t}\n\t\tsort(ALL(inputs));\n\t\tint target = n / 2;\n\t\tREP(i, n) {\n\t\t\tunion_tree[i+1] = i + 1;\n\t\t}\n\t\tREP(i, inputs.size()) {\n\t\t\ttarget -= union_merge(get<1>(inputs[i]), get<2>(inputs[i]));\n\t\t\tif (target <= 0) {\n\t\t\t\tcout << get<0>(inputs[i]) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <string.h>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 100;\nint n, m;\nstruct Node\n{\n    int u, v, w;\n}edge[MAXN];\nint pre[MAXN];\n\nint finds(int x)\n{\n    return x == pre[x] ? x : (pre[x] = finds(pre[x]));\n}\n\nbool cmp(Node a, Node b)\n{\n    return a.w < b.w;\n}\n\nvoid solve()\n{\n    int ans = 0;\n\n    sort(edge, edge + m, cmp);\n\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n    }\n\n    int num = 0;\n\n    for (int i = 0; i < m; i++)\n    {\n        int fa = finds(edge[i].u), fb = finds(edge[i].v);\n\n        if (fa != fb)\n        {\n            pre[fa] = fb;\n            num++;\n            if (num == n / 2) ans = edge[i].w;\n            if (num == n - 1) break;\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n}\n\nvoid input()\n{\n    int u, v, w;\n\n    while (scanf(\"%d %d\", &n, &m) != EOF)\n    {\n        if (n == 0 && m == 0)\n        {\n            break;\n        }\n        for (int i = 0; i < m; i++)\n        {\n            scanf(\"%d %d %d\", &edge[i].u, &edge[i].v, &edge[i].w);\n        }\n\n        solve();\n    }\n}\n\nint main()\n{\n    input();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef pair<int,int> P;\nconst int MAX = 1001;\nconst int INF = 1<<29;\n\nstruct edge { int u, v, cost;};\n\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nedge es[MAX];\nint V,E,ed;\nint par[MAX];\nint rank[MAX];\nvector<int>v;\n\n\nvoid init(int n){\n  for(int i=0; i<n; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n \n  for(int i=0; i<E; i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ed++;\n      unite(e.u,e.v);\n      res += e.cost;\n      v.push_back(e.cost);\n    }\n  }\n\n  return res;\n\n}\nint main(){\n  while(cin >> V >> E,V|E){\n\n    for(int i=0; i<E; i++){\n      int from,to,cost;\n      cin >> from >> to >> cost;\n      from--,to--;\n      es[i].u = from;\n      es[i].v = to;\n      es[i].cost = cost;\n    }\n\n    v.clear();\n\n    int c = kruskal();\n    sort(v.begin(),v.end());\n    cout << v[v.size()/2] << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<utility>    //pair\n#include<vector>\n#include<stdio.h>\n#include<string>\n#include<iostream>\n#include<algorithm> //find的&#22836;文件  string用find的&#26102;候会返回字符串的首地址\n#include<iterator>\n#include<string.h>\n#include<deque>   //双向添加数字的数&#32452;  可以&#21024;除或者添加第一个\n#include<queue>\n#include<set>      //&#24635;&#35273;得没有什&#20040;用&#22788;  无重&#22797;的\n#include<list>    //不支持随机&#35775;&#38382;  即缺少下&#26631;\n#include<map>       //数据&#31867;型很方便 但是会自己排好序  而且不会有重&#22797;的元素\nusing namespace std;\nint cost[1005][1005];\nint mincost[1005];\nbool used[1005];\nconst int INF=10000000;\nint d[1005],flag;\nint main()\n{\n    int V,m,a,b,c,t;\n    while(cin>>V>>m)\n    {\n        for(int i=0;i<1005;i++)\n            for(int j=0;j<1005;j++)\n                cost[i][j]=INF;\n\n        if(V==m&&m==0)\n            break;\n        flag=0;\n        for(int i=0;i<m;i++)\n        {\n\n            cin>>a>>b>>c;\n            cost[a][b]=c;\n            cost[b][a]=c;\n\n        }\n        for(int i=1;i<=V;i++)\n        {\n            mincost[i]=INF;\n            used[i]=false;\n        }\n        mincost[1]=0;\n        while(true)\n        {\n            int v=-1;\n            for(int u=1;u<=V;u++)\n            {\n                if(!used[u]&&(v==-1||mincost[u]<mincost[v]))\n                    v=u;\n            }\n            if(v==-1)\n                break;\n            used[v]=true;\n            d[flag]=mincost[v];flag++;\n            for(int u=1;u<=V;u++)\n            {\n                mincost[u]=min(mincost[u],cost[v][u]);\n            }\n\n        }\n        sort(d,d+flag);\n        cout<<d[V/2]<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n\n#define MAX_V 1000\n#define MAX_E 10000\n#define INF (1<<29)\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << (x) << endl\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define foreach(it,c) for(__typeof__((c).begin()) it=(c).begin();it!=(c).end();it++)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nstring toStr(int num){\n  if(num==0)return \"0\";\n  string res = \"\";\n  while(num){\n    res+=(num%10)+'0';\n    num/=10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint toInt(string s){return atoi(s.c_str());}\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint par[MAX_V],rank[MAX_V];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  \n  if(rank[x]<rank[y])par[x]=y;\n  else {\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\n\nbool cmp(const edge &e1,const edge &e2){\n  return e1.cost<e2.cost;\n}\n\nvector<edge> es;\nint V,E;\n\nint kruskal(int lim){\n  sort(all(es),cmp);\n  \n  vector<int>res;\n\n  init(V);\n \n  rep(i,lim){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res.push_back(e.cost);\n    }\n  }\n  sort(all(res));\n  if(res.size()%2==0)return round((double)(res[res.size()/2-1]+res[res.size()/2])/2);\n  return res[res.size()/2];\n}\n\nbool ok(){\n  bool fg=true;\n  for(int i=0;i+1<V;i++){\n    fg&=same(i,i+1);\n  }\n  return fg;\n}\n\nint main(void){\n\n  while(cin >> V >> E,V|E){\n    es.clear();\n  \n    rep(i,E){\n      int a,b,c;\n      cin >> a >> b >> c;\n      es.push_back((edge){a-1,b-1,c});\n    }\n\n    \n    if(V==2){\n      cout << es[0].cost << endl;\n      continue;\n    }\n    \n\n    int l=0,r=es.size(),ans=-1;\n    while(r-l>1){\n      int m=(l+r)/2;\n      int res=kruskal(m);\n      \n      if(ok())r=m,ans=res;\n      else l=m;\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntypedef tuple<ll,ll,ll> e;\n\nvector<ll> uft;\n\nll parent(ll a){\n    if(uft[a]==a){return a;}\n    return uft[a]=parent(uft[a]);\n}\n\nint main(){\n    ll n,m;\n    while(cin>>n>>m){\n        if(n==0){break;}\n    uft.resize(n);\n    for(int i=0;i<n;i++){uft[i]=i;}\n    priority_queue<e,vector<e>,greater<e>> Q;\n    for(int i=0;i<m;i++){\n        ll a,b,c;\n        cin>>a>>b>>c;\n        a--; b--;\n        Q.push(make_tuple(c,a,b));\n    }\n    ll ans=-1;\n    ll count=0;\n    while(!Q.empty()){\n        e W=Q.top(); Q.pop();\n        if(parent(get<1>(W))!=parent(get<2>(W))){\n            count++;\n            if(count==n/2){ans=get<0>(W);}\n            uft[parent(get<1>(W))]=parent(get<2>(W));\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INFTY 1000001\n#define MAX 1001\nusing namespace std;\n\nclass Edge{\npublic:\n    int target, cost;\n    Edge(int target = 0, int cost = 0) : target(target), cost(cost) {}\n};\n\nbool visited[MAX];\nint parent[MAX], key[MAX];\nint V, minv, min_index;\n\nint minKey() {\n    minv = INFTY;\n    for (int v = 0; v < V; v++)\n        if (!visited[v] && key[v] < minv)\n            minv= key[v], min_index = v;\n    return min_index;\n}\n\nvoid printMST()\n{\n    std::sort(key, key+V);\n    int mid = V /2;\n    printf(\"%d\\n\", key[mid]);\n}\n\nvoid prim(vector<Edge> G[]) {\n    for (int i = 0; i < V; i++) {\n        key[i] = INFTY;\n        visited[i] = false;\n        parent[i] = -1;\n    }\n    key[0] = 0;\n    parent[0] = -1;\n\n    int current, target, cost;\n\n    for (int i = 0; i < V-1; i++) {\n        current = minKey();\n        visited[current] = true;\n\n        for (unsigned long v = 0; v < G[current].size(); v++) {\n            target = G[current][v].target;\n            cost = G[current][v].cost;\n            if (!visited[target] && cost < key[target])\n                parent[target] = current, key[target] = cost;\n        }\n    }\n    printMST();\n}\n\nint main()\n{\n    int E, source, cost, target;\n    for (; ;) {\n        std::scanf(\"%d %d\", &V, &E);\n        vector<Edge> G[V];\n        if (V == 0 && E == 0) break;\n        for (int i = 0; i < E; i++) {\n            std::scanf(\"%d %d %d\", &source, &target, &cost);\n            G[--source].push_back(Edge(--target, cost));\n            G[target].push_back(Edge(source, cost));\n        }\n        prim(G);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Edge{\n    int s, t, c;\n    bool operator < (const Edge& e) const {\n        if(c != e.c) return c < e.c;\n        return make_pair(s, t) < make_pair(e.s, e.t);\n    }\n};\n\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int N) : data(N) {\n        REP(i, N) data[i] = i;\n    }\n    bool merge(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return false;\n        data[x] = y;\n        return true;\n    }\n    int root(int x){\n        if(x == data[x]) return x;\n        return data[x] = root(data[x]);\n    }\n};\n\nint main(){\n    int N, M;\n    while(cin >> N >> M && N){\n        vector<Edge> edges;\n        REP(i, M){\n            Edge e;\n            cin >> e.s >> e.t >> e.c;\n            e.s--; e.t--;\n            edges.push_back(e);\n        }\n        sort(edges.begin(), edges.end());\n        UnionFind uf(N);\n        vector<int> costs;\n        REP(i, M){\n            Edge& e = edges[i];\n            if(uf.merge(e.s, e.t)){\n                costs.push_back(e.c);\n            }\n        }\n        cout << costs[ costs.size() / 2 ] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n;\nint g[1005][1005];\nbool use_edge[1005][1005];\n\n\n\nconst int gmax_n = 1005;\n\nint par[gmax_n]; //ティツヲツェ\nint depth[gmax_n];//テヲツ慊ィテ」ツ?ョテヲツキツアテ」ツ??\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint main(){\n    int m;\n    while(cin >> n >> m, n){\n        pair<int, pair<int, int>> p[10005];\n        int ans = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            p[i] = make_pair(c,make_pair(a,b));\n        }\n        sort(p, p + m);\n\n        memset(use_edge, 0, sizeof(use_edge));\n        init(n);\n\n        int h = m / 2;\n        rep(i, h){\n            int a = p[i].second.first;\n            int b = p[i].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            unite(a,b);\n\n            set<int> s;\n            rep(j,n) s.insert(find(j));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[i].first);\n            }\n        }\n        init(n);\n        rep(i, m - h){\n            int a = p[m - i - 1].second.first;\n            int b = p[m - i - 1].second.second;\n            unite(a,b);\n            set<int> s;\n            rep(j,n) s.insert(find(j));\n            if(s.size() - 1 <= i){\n                ans = min(ans,p[m - i - 1].first);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Rank_Union_Find\n#define ___Rank_Union_Find\n\n#include <vector>\n\n// ------ Class ------ //\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct edge { int s, t, c; };\nbool operator<(const edge& e1, const edge& e2) { return e1.c < e2.c; }\nint n, m;\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n | m) {\n\t\tvector<edge> v(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &v[i].s, &v[i].t, &v[i].c);\n\t\t\tv[i].s--, v[i].t--;\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!uf.same(v[i].s, v[i].t)) {\n\t\t\t\tuf.unite(v[i].s, v[i].t);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt == n / 2) {\n\t\t\t\tprintf(\"%d\\n\", v[i].c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,M;\n\nstruct Node{\n\tbool operator<(const struct Node &arg) const{\n\t\treturn weight < arg.weight;\n\t};\n\tint from,to,weight;\n};\n\nint parent[1001],height[1001];\nNode* nodes;\n\nint getParent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = getParent(parent[id]);\n\t}\n}\n\nbool isSame(int a, int b){\n\treturn getParent(a) == getParent(b);\n}\n\nvoid unite(int a,int b){\n\tint a_parent = getParent(a);\n\tint b_parent = getParent(b);\n\n\tif(a_parent == b_parent)return;\n\n\tif(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tif(height[a_parent] == height[b_parent])height[b_parent]++;\n\t\tparent[a_parent] = b_parent;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d\",&nodes[i].from,&nodes[i].to,&nodes[i].weight);\n\t}\n\n\tsort(nodes,nodes+M);\n\n\tint count = 0,ans;\n\n\tinit();\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(!isSame(nodes[i].from,nodes[i].to)){\n\t\t\tunite(nodes[i].from,nodes[i].to);\n\t\t\tif(count == (N-1)/2){\n\t\t\t\tans = nodes[i].weight;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tnodes = (Node*)malloc(sizeof(Node)*10000);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n#define maxn 10100\n\nstruct N\n{\n    int n1, n2, cost;\n}e[maxn];\n\nint fa[maxn];\n\nbool cmp(N a, N b)\n{\n    return a.cost<b.cost;\n}\n\nvoid init()\n{\n    for(int i=0; i<maxn; i++)\n        fa[i]=i;\n}\n\nint find1(int x)\n{\n    if(x==fa[x])\n        return x;\n    fa[x]=find1(fa[x]);\n    return fa[x];\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n||m))\n    {\n        init();\n        for(int i=0; i<m; i++)\n            scanf(\"%d%d%d\",&e[i].n1,&e[i].n2,&e[i].cost);\n        sort(e,e+m,cmp);\n        int num=0;\n        for(int i=0; i<m; i++)\n        {\n            int a=find1(e[i].n1);\n            int b=find1(e[i].n2);\n            if(a==b)\n                continue;\n            fa[a]=fa[b];\n            num++;\n            if(num==(n+1)/2)\n            {\n                cout << e[i].cost << endl;\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for ( int i = 0; i < (n); i++ )\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nstruct UnionFind {\n  vector< int > data;\n \n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n \n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n \n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n \n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename T >\nT kruskal(Edges< T > &edges, int V) {  \n  sort(begin(edges), end(edges), [](const edge< T > &a, const edge< T > &b) {\n    return (a.cost < b.cost);\n  });\n  UnionFind tree(V);\n  T ret = 0;\n  int cnt = 0;\n  int ans = 0;\n  for(auto &e : edges) {\n    if(tree.unite(e.src, e.to)) {\n      cnt++;\n      if ( cnt == V/2 ) ans = e.cost;      \n      ret += e.cost;\n    }\n  }\n  return (ans);\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while ( cin >> n >> m, n ) {\n    Edges<int> E;\n    for ( int i = 0; i < m; i++ ) {\n      int s, t, c;\n      cin >> s >> t >> c;\n      s--; t--;\n      E.push_back(edge<int>(s, t, c));      \n    }\n\n    cout << kruskal(E, n) << endl;    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<numeric>\n\nusing namespace std;\n\nint par[1001];\n\nint find(int x){\n  return (par[x]==x)?x:par[x]=find(par[x]);\n}\n\nbool unite(int a,int b){\n  int pa=find(a);\n  int pb=find(b);\n  par[pa]=pb;\n  return pa!=pb;\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n;){\n    int s[10000],t[10000],c[10000];\n    for(int i=0;i<m;i++){\n      cin>>s[i]>>t[i]>>c[i];\n    }\n    int l=0,h=1000;\n    while(h-l>1){\n      int mid=(h+l)/2;\n      iota(begin(par),end(par),0);\n      int nu=0;\n      for(int i=0;i<m;i++){\n\tif(c[i]<=mid){\n\t  nu+=unite(s[i],t[i]);\n\t}\n      }\n      if(nu>=n/2){\n\th=mid;\n      }else{\n\tl=mid;\n      }\n    }\n    cout<<h<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tint k;\n\tunion_find(int n) : v(n, -1), k(0) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t\tk++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<int> s(m), t(m), c(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> s[i] >> t[i] >> c[i];\n\t\t\ts[i]--; t[i]--;\n\t\t}\n\t\tfor (int C = 1; C <= 1000; C++) {\n\t\t\tunion_find ufs(n), ufe(n), ufg(n);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tif (c[i] < C) ufs.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] == C) ufe.unite(s[i], t[i]);\n\t\t\t\telse if (c[i] > C) ufg.unite(s[i], t[i]);\n\t\t\tif (ufe.k && ufs.k + ufe.k >= n / 2 && ufe.k + ufg.k >= n / 2) {\n\t\t\t\tcout << C << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Rank_Union_Find\n#define ___Rank_Union_Find\n\n#include <vector>\n\n// ------ Class ------ //\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\n\n#endif\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct edge { int s, t, c; };\nbool operator<(const edge& e1, const edge& e2) { return e1.c < e2.c; }\nint n, m;\nint main() {\n\twhile (cin >> n >> m, n | m) {\n\t\tvector<edge> v(m);\n\t\tfor (int i = 0; i < m; i++) cin >> v[i].s >> v[i].t >> v[i].c, v[i].s--, v[i].t--;\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!uf.same(v[i].s, v[i].t)) {\n\t\t\t\tuf.unite(v[i].s, v[i].t);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt == n / 2) {\n\t\t\t\tcout << v[i].c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = (a); i < n; i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint N, M, S, T, C;\npair<int, pii> E[10000];\nint a[1000];\n\nint find(int i) { return a[i] == i ? i : (a[i] = find(a[i])); }\nvoid unite(int i, int j) { a[find(i)] = find(j); }\n\nint main(void) {\n  while(cin >> N >> M, N || M) {\n    REP(i, 0, M) {\n      cin >> S >> T >> C;\n      E[i] = pair<int, pii>(C, pii(S, T));\n    }\n\n    sort(E, E + M);\n\n    vector<int> cost;\n    REP(i, 0, N) a[i] = i;\n    REP(i, 0, M) {\n      S = E[i].se.fi;\n      T = E[i].se.se;\n      C = E[i].fi;\n      if(find(S) != find(T)) {\n        unite(S, T);\n        cost.push_back(C);\n      }\n    }\n\n    cout << cost[cost.size() / 2] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nstruct data {\n\tint a, b, c;\n} e[10005];\nint n, m, p[1005];\ninline bool cmp(data d1, data d2) { return d1.c < d2.c; }\nint f(int x) {\n\tif (p[x] == x) return x;\n\treturn (p[x] = f(p[x]));\n}\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n&&m) {\n\t\tfor (int i = 1; i <= n; i++) p[i] = i;\n\t\tfor (int i = 1; i <= m; i++) scanf(\"%d%d%d\", &e[i].a, &e[i].b, &e[i].c);\n\t\tsort(e + 1, e + m + 1, cmp);\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint A = f(e[i].a), B = f(e[i].b);\n\t\t\tif (A == B) continue;\n\t\t\tcnt++;\n\t\t\tp[A] = B;\n\t\t\tif (cnt == n / 2) {\n\t\t\t\tprintf(\"%d\\n\", e[i].c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, M;\n\nint s[10000], t[10000], c[10000];\n\ntypedef pair<int, i_i> iii;\n\nbool f(int border) {\n    UnionFind uni(N);\n    vector<iii> v;\n    //cerr << \"--------\" << border << \"---------\" << endl;\n    for(int i = 0; i < M; i++) {\n        v.push_back({0, {s[i], t[i]}});\n        if(c[i] > border) v.back().first = 1;\n    }\n    sort(v.begin(), v.end());\n    int cost = 0;\n    for(auto tmp : v) {\n        //cerr << tmp.first << \" \" << tmp.second.first << \" \" << tmp.second.second << endl;\n        if(uni.merge(tmp.second.first, tmp.second.second)) {\n            cost += tmp.first;\n        }\n    }\n    return cost < N / 2;\n}\n\nvoid solve() {\n    for(int i = 0; i < M; i++) cin >> s[i] >> t[i] >> c[i];\n    int ok = 1e9;\n    int ng = 0;\n    while(abs(ok - ng) > 1) {\n        int mid = (ok + ng) / 2;\n        if(f(mid)) ok = mid;\n        else ng = mid;\n    }\n    cout << ok << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Edge {\n\tint u, v, c;\n\tbool operator < (const Edge& o) const { return c < o.c; }\n};\n\nclass UnionFind {\npublic:\n\tvector< int > data;\n\t\n\tUnionFind(int n) : data(n, -1) {}\n\t\n\tvoid unionSet(int a, int b) {\n\t\ta = root(a); b = root(b);\n\t\t\n\t\tif (a != b) {\n\t\t\tif (data[a] < data[b]) swap(a, b);\n\t\t\tdata[a] += data[b]; data[b] = a;\n\t\t}\n\t}\n\t\n\tbool sameSet(int a, int b) { return root(a) == root(b); }\n\t\n\tint root(int x) { return data[x] < 0 ? x : root(data[x]); }\n};\n\nint n, m;\nvector< Edge > edges;\n\nvoid solve() {\n\tsort(edges.begin(), edges.end());\n\t\n\tUnionFind uf(n);\n\t\n\tvector< int > cv;\n\t\n\tfor_(i,0,m) {\n\t\tEdge e = edges[i];\n\t\t\n\t\tif (!uf.sameSet(e.u, e.v)) {\n\t\t\tuf.unionSet(e.u, e.v);\n\t\t\tcv.push_back(e.c);\n\t\t}\n\t}\n\t\n\tcout << cv[(n - 1) / 2] << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m, n) {\n\t\tedges.clear();\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tint u, v, c;\n\t\t\tcin >> u >> v >> c;\n\t\t\tedges.push_back(Edge{--u, --v, c});\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1023456789;\n\nint N,M;\ntypedef tuple<int,int,int> node;\nvector<node> graph;\n\nint par[vmax];\nvoid init(){rep(i,vmax) par[i]=i;}\nint find(int x){return (par[x]==x)?x:par[x]=find(par[x]);}\nvoid unite(int a,int b){a=find(a),b=find(b);par[a]=b;}\nbool same(int a,int b){return find(a)==find(b);}\n\nint kruskal(){\n\tinit();\n\tsort(begin(graph),end(graph));\n\tint res=inf,num=0;\n\tfor(auto &e:graph){\n\t\tint a,b,c;\n\t\ttie(c,a,b)=e;\n\t\tif(!same(a,b)) unite(a,b),num++;\n\t\tif(num==N/2) res=min(res,c);\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> N >> M,N){\n\t\tgraph.clear();\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tgraph.push_back(node(c,a,b));\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\npublic:\n\tunion_find(int n):uf(n, -1) {}\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tbool unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\n\t\tif(a == b) return false;\n\n\t\tif(uf[a] > uf[b]) {\n\t\t\tswap(a, b);\n\t\t}\n\t\telse if(uf[a] == uf[b]) {\n\t\t\t--uf[b];\n\t\t}\n\n\t\tuf[a] = uf[b];\n\t\treturn true;\n\t}\n};\n\nstruct edge {\n\tint u, v;\n\tint cost;\n\tedge(int u, int v, int c):u(u), v(v), cost(c){}\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint calc(int n, vector<edge> &edges) {\n\tunion_find uf(n);\n\tsort(edges.begin(), edges.end());\n\n\tconst unsigned median = n / 2;\n\tpriority_queue<int> que;\n\n\tfor(const auto &e : edges) {\n\t\tif(uf.unite(e.u, e.v)) {\n\t\t\tque.push(e.cost);\n\t\t\tif(que.size() > median) que.pop();\n\t\t}\n\t}\n\treturn que.top();;\n}\n\nint main() {\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<edge> edges;\n\t\tedges.reserve(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint s, t, c;\n\t\t\tcin >> s >> t >> c;\n\t\t\tedges.emplace_back(s - 1, t - 1, c);\n\t\t}\n\t\tcout << calc(n, edges) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define inf 0x3f3f3f3f\nusing namespace std;\nint ma[1010][1010];\nint cost[1010],a[1010]; \nint n,m;\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++)\n\t\t\tma[i][j]=ma[j][i]=inf;\n\t\tma[i][i]=0;\n\t}\n\tmemset(a,0,sizeof(a));\n}\nint prim(int s){\n\tint i,j;\n\tint k=0;\n\tfor(i=1;i<=n;i++)\n\t\tcost[i]=ma[s][i];\n\tint sum=0;\n\tint mini;\n\tfor(i=1;i<n;i++){\n\t\tmini=inf;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(cost[j]<mini&&cost[j]!=0){\n\t\t\t\ts=j;\n\t\t\t\tmini=cost[j];\n\t\t\t}\n\t\t\tsum+=mini;\n\t\t\tcost[s]=0;\n\t\t\ta[k++]=mini;\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tif(cost[j]>ma[s][j]&&ma[s][j]!=0)\n\t\t\t\t\tcost[j]=ma[s][j];\n\t}\n\tsort(a,a+k);\n\treturn a[k/2];\n}\nint main(){\n\tint from,to,cost;\n\twhile(scanf(\"%d%d\",&n,&m)&&(n+m)!=0){\n\t\tinit();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tscanf(\"%d%d%d\",&from,&to,&cost);\n\t\t\tma[from][to]=ma[to][from]=cost;\n\t\t}\n\t\tprintf(\"%d\\n\",prim(1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  vector<int> par;  // 隕ェ\n  vector<int> rank; // 譛ィ縺ョ豺ア縺?\npublic:\n  // n隕∫エ?〒蛻晄悄蛹?  UnionFind(int n) {\n    par.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  // 譛ィ縺ョ譬ケ繧呈アゅａ繧?  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n\n  // x縺ィy縺悟酔縺倬寔蜷医↓螻槭☆繧九°蜷ヲ縺?  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  \n  // x縺ィy縺ョ螻槭☆繧矩寔蜷医ｒ菴オ蜷?  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\nstruct Edge {\n  int a, b, c;\n  bool operator < (const Edge &e) const {\n    return c < e.c;\n  }\n};\n\nint main() {\n  for(int n, m; cin >> n >> m && (n|m);) {\n    vector<Edge> es;\n    while(m--) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      es.push_back((Edge){a,b,c});\n    }\n    sort(es.begin(), es.end());\n    UnionFind uf(n);\n    int cnt = 0;\n    for(int i = 0; i < es.size(); ++i) {\n      if(uf.same(es[i].a, es[i].b)) continue;\n      uf.unite(es[i].a, es[i].b);\n      if(++cnt == n / 2) {\n        cout << es[i].c << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nstruct UF {\n    vector<int> data;\n\n    UF(int n) {\n        data.resize(n, -1);\n    }\n\n    int root(int i) {\n        return data[i] < 0 ? i : data[i] = root(data[i]);\n    }\n\n    int size(int i) {\n        return -data[root(i)];\n    }\n\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n\n        if (x == y) return ;\n\n        if (size(x) < size(y)) swap(x, y);\n\n        data[x] += data[y];\n        data[y] = x;\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nint N, M;\n\nint main()\n{\n    while (cin >> N >> M, N) {\n        UF uf(N);\n\n        vector<pair<int, pii>> edges;\n\n        for (int i = 0; i < M; ++i) {\n            int s, t, c; cin >> s >> t >> c;\n\n            --s, --t;\n\n            edges.push_back(make_pair(c, pii(s, t)));\n        }\n\n        sort(begin(edges), end(edges));\n\n        vector<int> a;\n\n        for (pair<int, pii> e : edges) {\n            int cost = e.first;\n            pii info = e.second;\n            if (!uf.same(info.first, info.second)) {\n                uf.unite(info.first, info.second);\n                a.push_back(cost);\n            }\n        }\n\n        sort(begin(a), end(a));\n\n        cout << a[a.size() / 2] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nvector<P1> G;\n\ndouble solve(){\n  sort(G.begin(),G.end());\n  vector<int> ans;\n  for(int i=0;i<G.size();i++){\n    int cost=G[i].first;\n    int x=G[i].second.first;\n    int y=G[i].second.second;\n    if(same(x,y))continue;\n    unite(x,y);\n    ans.push_back(cost);\n  }\n  return ans[ans.size()/2];\n}\n\nint main(){\n  int n,m,s,t,c;\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    G.clear();\n    for(int i =0;i<m;i++){\n      cin>>s>>t>>c;\n      s--,t--;\n      G.push_back(P1(c,P(s,t)));\n    }\n    init(n);\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// @snippet<sh19910711/contest-base-simple:header.cpp>\n#define __THIS_IS_CPP11__\n/* default headers {{{ */\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <limits>\n#include <cstdio>\n#include <cmath>\n\n#ifdef __THIS_IS_CPP11__\n#include <memory>\n#include <array>\n#endif\n/* }}} */\n\nnamespace setlib {\n  class DisjointSets {\n  public:\n    std::vector<int> data;\n    DisjointSets( int size ): data(size, -1) {};\n    void init( int size ) { data.resize(size); std::fill( data.begin(), data.end(), -1 ); }\n    bool merge( int x, int y ) {\n      x = root(x), y = root(y);\n      if ( x != y ) {\n        if ( data[y] < data[x] ) std::swap( x, y );\n        data[x] += data[y], data[y] = x;\n      }\n      return x != y;\n    }\n    bool same( int x, int y ) { return root(x) == root(y); }\n    int root( int x ) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n  };\n}\n\n// @snippet<sh19910711/contest-base-simple:solution/template-typedef.cpp>\nnamespace solution {\n  /* primitives {{{ */\n  using namespace std;\n  typedef long long Int;\n  typedef long double Double;\n  typedef string String;\n  /* }}} */\n}\n\n// @snippet<sh19910711/contest-base-simple:solution/template-constants.cpp>\nnamespace solution {\n  const Int MAX_V = 1000 + 11;\n  const Int MAX_E = 10000 + 11;\n}\n\n// @snippet<sh19910711/contest-base-simple:solution/template-storages.cpp>\nnamespace solution {\n  struct Input {\n    Int N;\n    Int M;\n    Int S[MAX_E];\n    Int T[MAX_E];\n    Int C[MAX_E];\n  };\n  \n  struct Output {\n    Int result;\n  };\n}\n\n// @snippet<sh19910711/contest-base-simple:solution/solution-io.cpp>\nnamespace solution {\n  struct SolutionIO {\n    Input in;\n    Output out;\n    \n    template <class Stream> bool input( Stream& s ) {\n      if ( ! ( s >> in.N >> in.M && in.N ) ) return false;\n      for ( auto i = 0; i < in.M; ++ i )\n        if ( ! ( s >> in.S[i] >> in.T[i] >> in.C[i] ) ) return false;\n      return true;\n    }\n    \n    template <class Stream> bool output( Stream& s ) {\n      return s << out.result << endl;\n    }\n  };\n}\n\n// @snippet<sh19910711/contest-base-simple:solution/solution.cpp>\nnamespace solution {\n  struct Solution: SolutionIO {\n    //\n    // Implement here\n    //\n    \n    typedef setlib::DisjointSets UnionFind;\n    typedef std::tuple <Int, Int, Int> Edge;\n    typedef std::priority_queue <Edge, std::vector<Edge>, std::greater<Edge>> EdgeQueue;\n    typedef std::vector<Edge> EdgeVector;\n\n    Int n;\n    Int m;\n\n    Solution() {}\n    \n    bool solve() {\n      n = in.N;\n      m = in.M;\n      out.result = find_good_median();\n      return true;\n    }\n\n    Int find_good_median() {\n      EdgeQueue q;\n      for ( auto i = 0; i < m; ++ i ) {\n        q.push(Edge(in.C[i], in.S[i] - 1, in.T[i] - 1));\n      }\n      EdgeVector edges;\n      UnionFind uf(MAX_V);\n      while ( ! q.empty() ) {\n        auto e = q.top(); q.pop();\n        if ( ! uf.same(get<1>(e), get<2>(e)) ) {\n          edges.push_back(e);\n          uf.merge(get<1>(e), get<2>(e));\n        }\n      }\n      return get<0>(edges[edges.size() / 2]);\n    }\n    \n    /* action methods {{{ */\n    void before_action( const int& t_id ) {}\n    \n    void after_action( const int& t_id ) {}\n    \n    bool action( const int& t_id = -1 ) {\n      before_action(t_id);\n      bool res = input(std::cin) && solve() && output(std::cout);\n      after_action(t_id);\n      return res;\n    }\n    /* }}} */\n  };\n}\n\n// @snippet<sh19910711/contest-base-simple:solution/runner-normal.cpp>\nnamespace solution {\n  /* Runner Class {{{ */\n  struct Runner {\n    static int run() {\n      bool f = false;\n      while ( ! f ) {\n        Solution* sol = new Solution;\n        f = ! sol->action();\n        delete sol;\n      };\n      return 0;\n    }\n  };\n  /* }}} */\n}\n\n// @snippet<sh19910711/contest-base-simple:main_func.cpp>\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  return solution::Runner::run();\n}\n\n// @snippet<sh19910711/contest-base-simple:main.cpp>"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct UF{\n    vector<int> p;\n    int n;\n\n    UF(int siz){\n        n = siz;\n        p.resize(n, 0);\n        for(int i = 0; i < n; i++)  p[i] = i;\n    }\n\n    int parent(int x){\n        if(p[x] != x)   p[x] = parent(p[x]);\n        return p[x];\n    }\n\n    bool same(int x, int y){\n        return parent(x)==parent(y);\n    }\n\n    void unite(int x, int y){\n        x = parent(x), y = parent(y);\n        p[x] = y;\n    }\n};\n\n// MSTやるだけ、は流石に無い？\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        priority_queue<pair<int,pair<int,int>>> pq;\n        int s, t, c;\n        for(int i = 0; i < m; i++){\n            cin >> s >> t >> c;\n            s--, t--;\n            pq.push({-c, {s,t}});\n        }\n        UF uf(n);\n        int cnt = 0;\n        while(true){\n            auto p = pq.top();    pq.pop();\n            int i = p.second.first, j = p.second.second;\n            if(!uf.same(i,j)){\n                uf.unite(i,j);\n                cnt++;\n                if(cnt == n/2){\n                    cout << -p.first << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\n// <<<\n// >>> union find\nstruct UnionFind {\n    int n, sz; // id : 0...n-1\n    vector<int> par;\n\n    UnionFind(int n = 0) : n(n), sz(n), par(n,-1) { }\n    int root(int x) {\n        assert(0 <= x); assert(x < n);\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return false;\n        sz--;\n        if (par[x] < par[y]) swap(x,y);\n        par[y] += par[x];\n        par[x] = y;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -par[root(x)]; }\n    int size() const { return sz; }\n    struct groups_t {\n        vector<vector<int> > grp;\n        vector<pair<int,int> > id;\n    };\n    groups_t groups() {\n        vector<vector<int> > g(n);\n        rep (i,n) if (par[i] < 0) g[i].reserve(-par[i]);\n        rep (i,n) g[root(i)].push_back(i);\n        vector<vector<int> > grp; grp.reserve(size());\n        rep (i,n) if (g[i].size()) grp.emplace_back(move(g[i]));\n        vector<pair<int,int> > id(n);\n        rep (i,grp.size()) rep (j,grp[i].size()) {\n            id[grp[i][j]] = make_pair(i,j);\n        }\n        return { grp, id };\n    }\n};\n// <<<\n\nvoid solve(int n, int m) {\n    vector<int> s(m),t(m),c(m);\n    rep (i,m) cin >> s[i] >> t[i] >> c[i], --s[i], --t[i];\n\n    int l = -1, r = 1e3 + 10;\n    while (l+1 < r) {\n        int mid = (l+r)/2;\n        UnionFind uf(n);\n        rep (i,m) if (c[i] <= mid) {\n            uf.unite(s[i],t[i]);\n        }\n        (uf.size() <= n/2 ? r : l) = mid;\n    }\n    dump(l,r);\n\n    cout << r << \"\\n\";\n}\n\nint32_t main() {\n    while (true) {\n        int n,m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n,m);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 1005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nvector<P1> G;\n\ndouble solve(){\n  sort(G.begin(),G.end());\n  vector<int> ans;\n  for(int i=0;i<G.size();i++){\n    int cost=G[i].first;\n    int x=G[i].second.first;\n    int y=G[i].second.second;\n    if(same(x,y))continue;\n    unite(x,y);\n    ans.push_back(cost);\n  }\n  if(ans.size()%2)return ans[ans.size()/2];\n  return (ans[ans.size()/2]+ans[ans.size()/2+1])/2.0;\n}\n\nint main(){\n  int n,m,s,t,c;\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    G.clear();\n    for(int i =0;i<m;i++){\n      cin>>s>>t>>c;\n      s--,t--;\n      G.push_back(P1(c,P(s,t)));\n    }\n    init(n);\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_N 4000\n#define MAX_E 40000\n#include<algorithm>\nusing namespace std;\n\nstruct edge {int u,v,cost;};\n\nint ans[MAX_N],cnt;\n\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V,E;\n\n\n\nint par[MAX_E];\nint rank[MAX_E];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x] = find (par[x]);\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return ;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\n\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n  for(int i=0;i<E;i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ans[cnt++]=e.cost;\n      unite(e.u,e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  int a,b,c;\n  while(cin>>V>>E&&V&&E){\n    \n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c;\n      a--;\n      b--;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n      /*\n      es[E+i].u=b;\n      es[E+i].v=a;\n      es[E+i].cost=c;\n      */\n    }\n    //E*=2;\n    cnt=0;\n    int x =kruskal();\n    //cout<<x/(V-1)<<endl;\n    if(cnt%2==0){\n      cout<<(ans[cnt/2]+ans[cnt/2-1])/2<<endl;\n    }\n    else cout<<ans[cnt/2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define maxm 10010\n#define maxn 1010\nstruct node \n{\n\tint u,v,w;\n\tbool ed;\n\tbool operator < (const node &rhs)const \n\t{\n\t\treturn w<rhs.w;\n\t}\n}edge[maxm];\nint fa[maxn],n,m;\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main()\n{\n\twhile(~scanf(\"%d%d\",&n,&m))\n\t{\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfa[i]=i;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&edge[i].u,&edge[i].v,&edge[i].w);\n\t\t\tedge[i].ed=0;\n\t\t}\n\t\tsort(edge+1,edge+m+1);\n\t\tint cnt=0,tmp=0,ans=0;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x=find(edge[i].u),y=find(edge[i].v);\n\t\t\tif(x==y)continue;\n\t\t\tfa[x]=y;\n\t\t\tedge[i].ed=1;\n\t\t\tcnt++;\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(edge[i].ed)\n\t\t\t{\n\t\t\t\ttmp++;\n\t\t\t\tif((cnt&1)&&tmp==(cnt+1)/2)\n\t\t\t\t{\n\t\t\t\t\tans=edge[i].w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cnt%2==0&&(tmp==cnt/2||tmp==cnt/2+1))\n\t\t\t\t\tans+=edge[i].w;\n\t\t\t\tif(tmp>(cnt+1)/2+1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",(cnt&1)?ans:ans/2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "2 1\n1 2 5\n4 6\n1 2 1\n1 3 2\n1 4 3\n2 3 4\n2 4 5\n3 4 6\n8 17\n1 4 767\n3 1 609\n8 3 426\n6 5 972\n8 1 607\n6 4 51\n5 1 683\n3 6 451\n3 4 630\n8 7 912\n3 7 43\n4 7 421\n3 5 582\n8 4 538\n5 7 832\n1 6 345\n8 2 608\n0 0"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tvector<int> a;\npublic:\n\tunion_find(int n):a(n,-1){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; }\n\t}\n};\n\nstruct edge{\n\tint u,v,cost;\n\tbool operator<(const edge &e)const{ return cost<e.cost; }\n};\n\nint solve(int n,int m,edge *E){\n\tunion_find U(n);\n\tsort(E,E+m);\n\n\tint cnt=0,res;\n\trep(i,m) if(U.find(E[i].u)!=U.find(E[i].v)) {\n\t\tU.unite(E[i].u,E[i].v);\n\t\tcnt++;\n\t\tif(cnt==n/2){ res=E[i].cost; break; }\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tedge E[10000];\n\t\trep(i,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\t\tE[i]=(edge){u,v,cost};\n\t\t}\n\t\tprintf(\"%d\\n\",solve(n,m,E));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,s,e) for(int i=(s); i<(e);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n)\n#define repe(i,n) for(auto &&i:n)\n#define all(v) (v).begin(),(v).end()\n#define decimal fixed<<setprecision(20)\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\nusing namespace std;\nusing LL = long long;\nusing Graph = vector<vector<int>>;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1e9;\nconst LL LLINF = 1e16;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1){ }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (data[y] < data[x]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return true;\n    }\n\n    int root(int x) {\n        return data[x]<0 ? x : (data[x]=root(data[x]));\n    }\n\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nstruct edge{\n    int src, to, cost;\n};\nusing Edges = vector<edge>;\n\nint kruskal(Edges &E, int V)\n{\n    sort(all(E), [](const edge &a, const edge &b)\n    {\n        return (a.cost < b.cost);\n    });\n    UnionFind tree(V);\n    vector<int> MST;\n    for(auto &e: E) {\n        if(tree.merge(e.src, e.to)) MST.push_back(e.cost);\n    }\n    sort(all(MST));\n    return MST[MST.size()/2];\n}\n\nint main(){\n    fastcin();\n\n    int n, m;\n    cin >> n >> m;\n    while(n > 0){\n        Edges E(m);\n        rep(i, m){\n            int s, t, c;\n            cin >> s >> t >> c;\n            s--; t--;\n            E[i] = edge({s, t, c});\n        }\n        cout << kruskal(E, n) << endl;\n        cin >> n >> m;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint solve(int n, vector< vector< pair<int,int> > > &G){\n  vector<bool> connected(n,false);\n  priority_queue< pair<int,int> > wait;\n  vector<int> costs;\n  wait.emplace(0,0);\n  while(!wait.empty()){\n    int c = -wait.top().first, v = wait.top().second;\n    wait.pop();\n    if(connected[v]) continue;\n    connected[v] = true;\n    costs.push_back(c);\n    for(int i = 0; i < G[v].size(); ++i){\n      int v_ = G[v][i].first, c_ = G[v][i].second;\n      if(!connected[v_]){\n        wait.emplace(-c_,v_);\n      }\n    }\n  }\n  sort(costs.begin(),costs.end());\n  return costs[n/2];\n}\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< vector< pair<int,int> > > G(n);\n    int s, t, c;\n    for(int i = 0; i < m; ++i){\n      cin >> s >> t >> c;\n      --s;--t;\n      G[s].emplace_back(t,c);\n      G[t].emplace_back(s,c);\n    }\n\n    cout << solve(n,G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n};\nint n,m;\nmain()\n{\n\twhile(cin>>n>>m,n)\n\t{\n\t\tvector<pair<int,pair<int,int> > >E;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint s,t,c;cin>>s>>t>>c;\n\t\t\tE.push_back(make_pair(c,make_pair(s,t)));\n\t\t}\n\t\tsort(E.begin(),E.end());\n\t\tUF uf(n+1);\n\t\tint ans,cnt=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tif(uf.unite(E[i].second.first,E[i].second.second))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==n/2)ans=E[i].first;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 6500000\n#define rank Asdfiasofsad\nusing namespace std;\n \nstruct edge{\n  int c,a,b;\n  bool operator < (edge x)const{return c<x.c;}\n};\n \nint par[MAX_N];\nint rank[MAX_N];\nint n,m;\nedge e[50000];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n \nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n \nbool same(int x,int y){return find(x)==find(y);}\n \nint cal(){\n  int c=0;\n  init(n);\n  for(int i=0;i<m;i++){\n    if(same(e[i].a,e[i].b))continue;\n    unite(e[i].a,e[i].b);\n    if(++c==n/2)return e[i].c;\n  }\n}\n \nint main(){\n  while(cin>>n>>m,n){\n    for(int i=0;i<m;i++){\n      cin>>e[i].a>>e[i].b>>e[i].c;\n      e[i].a--,e[i].b--;\n    }\n    sort(e,e+m);\n    cout<<cal()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint par[101],rank[101];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=1;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\nvoid unit(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\nstruct edge{int u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost<e2.cost;\n}\nedge es[10001];\nint V,E;\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int c=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unit(e.u,e.v);\n      if(c++==((V-1)/2))return e.cost;\n    }\n  }\n}\nmain(){\n    while(cin>>V>>E,V){\n        init(V);\n        r(i,E)cin>>es[i].u>>es[i].v>>es[i].cost;\n        cout<<kruskal()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint par[1001],rank[1001];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=1;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\nvoid unit(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\nstruct edge{int u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost<e2.cost;\n}\nedge es[10001];\nint V,E;\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int c=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unit(e.u,e.v);\n      if(c++==((V-1)/2))return e.cost;\n    }\n  }\n}\nmain(){\n    while(cin>>V>>E,V){\n        init(V);\n        r(i,E)cin>>es[i].u>>es[i].v>>es[i].cost;\n        cout<<kruskal()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\tint a,b,c;\n};\nbool operator < (const Edge &a, const Edge &b){\n\treturn a.c < b.c;\n}\nint n,m;\n\nint uf[10010];\nint get(int x){\n\treturn x == uf[x] ? x : uf[x] = get(uf[x]);\n}\nint unite(int x,int y){\n\tif( rand() & 1 ) swap(x,y);\n\tuf[get(x)] = get(y);\n}\n\nvector<Edge> es;\nint check(){\n\tfor(int i = 0 ; i < n ; i++) uf[i] = i;\n\tvector<int> v;\n\tfor(int i = 0 ; i < es.size() ; i++){\n\t\tauto &e = es[i];\t\t\n\t\tif( get(e.a) != get(e.b) ){\n\t\t\tunite(e.a,e.b);\n\t\t\tv.push_back(e.c);\n\t\t}\n\t}\n\t\n\treturn v[v.size()/2];\n}\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tes.resize(m);\n\t\tfor(int i = 0 ; i < m ; i++) cin >> es[i].a >> es[i].b >> es[i].c, es[i].a--, es[i].b--;\n\t\tsort(es.begin(),es.end());\n\t\tcout << check() << endl;\n\t}\n\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\nclass DisjointSet{\nprivate:\n  vector< int > rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    } else {\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++) p[i] = i, rank[i] = 0;\n  }\n  void Union(int x,int y){\n    if(Find(x) != Find(y)) link(Find(x),Find(y));\n  }\n  int Find(int x){\n    return( x != p[x] ? p[x] = Find(p[x]) : p[x]);\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< edge > edges;\n    for(int i = 0; i < m; i++){\n      int s, t, c;\n      cin >> s >> t >> c;\n      edges.push_back((edge){ s - 1, t - 1, c});\n    }\n    sort(edges.begin(), edges.end());\n    DisjointSet UnionFind(n);\n    int mid = 0, sz = 0;\n    for(int i = 0; i < edges.size(); i++){\n      edge& e = edges[i];\n      if(UnionFind.Find(e.u) != UnionFind.Find(e.v)){\n        UnionFind.Union( e.u, e.v);\n        if((n - 1) / 2 == sz) mid = e.cost;\n      }\n    }\n    cout << mid << endl;\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 and m == 0) {\n            break;\n        }\n        using P = pair<int, int>;\n        vector<pair<int, P>> edge(m);\n        for (int i = 0; i < m; i++) {\n            int s, t, c;\n            cin >> s >> t >> c;\n            s--, t--;\n            edge[i] = make_pair(c, make_pair(s, t));\n        }\n        sort(edge.begin(), edge.end());\n        DisjointSets uf(n);\n        vector<int> cost;\n        for (int i = 0; i < m; i++) {\n            const int c = edge[i].first;\n            const int u = edge[i].second.first;\n            const int v = edge[i].second.second;\n            if (not uf.same(u, v)) {\n                uf.unite(u, v);\n                cost.push_back(c);\n            }\n        }\n        cout << ((n - 1) % 2 == 1 ? cost[n / 2 - 1] : (cost[n / 2 - 1] + cost[n / 2]) * 1.0 / 2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\n\ntypedef tuple<int, int, int> Tp;\n#define at(t, i) get<i>(t)\n\nint n, m;\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tUnionFind uf(n);\n\t\tvector<Tp> es;\n\t\tvector<int> v;\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint s, t, c;\n\t\t\tscanf(\"%d %d %d\", &s, &t, &c);\n\t\t\tes.push_back(Tp(c, --s, --t));\n\t\t}\n\t\t\n\t\tsort(es.begin(), es.end());\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tif (uf.unite(at(es[i], 1), at(es[i], 2))){\n\t\t\t\tv.push_back(at(es[i], 0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = v[v.size() / 2];\n\t\tif (v.size() % 2 == 0){\n\t\t\tres += v[v.size() / 2 + 1];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX_N 4000\n#define MAX_E 40000\n#include<algorithm>\nusing namespace std;\n\nstruct edge {int u,v,cost;};\n\nint ans[MAX_N],cnt;\n\nbool comp(const edge& e1, const edge& e2){\n  return e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V,E;\n\n\n\nint par[MAX_E];\nint rank[MAX_E];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x] = find (par[x]);\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return ;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\n\n\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res = 0;\n  for(int i=0;i<E;i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      ans[cnt++]=e.cost;\n      unite(e.u,e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  int a,b,c;\n  while(cin>>V>>E&&V&&E){\n    \n    for(int i=0;i<E;i++){\n      cin>>a>>b>>c;\n      es[i].u=a;\n      es[i].v=b;\n      es[i].cost=c;\n      /*\n      es[E+i].u=b;\n      es[E+i].v=a;\n      es[E+i].cost=c;\n      */\n    }\n    //E*=2;\n    cnt=0;\n    int x =kruskal();\n    //cout<<x/(V-1)<<endl;\n    if(cnt%2==0){\n      cout<<(ans[cnt/2]+ans[cnt/2-1])/2<<endl;\n    }\n    else cout<<ans[cnt/2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct DisjointSet/*{{{*/\n{\n    vector<int> parent;\n\n    int root(int x)\n    {\n        if (parent[x] < 0) {\n            return x;\n        } else {\n            parent[x] = root(parent[x]);\n            return parent[x];\n        }\n    }\n\n    explicit DisjointSet(int n) : parent(n, -1) {}\n\n    bool unite(int x, int y)\n    {\n        const int a = root(x);\n        const int b = root(y);\n        if (a != b) {\n            if (parent[a] < parent[b]) {\n                parent[a] += parent[b];\n                parent[b] = a;\n            } else {\n                parent[b] += parent[a];\n                parent[a] = b;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    bool find(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nstruct Edge {\n    int a, b;\n    int cost;\n\n    bool operator <(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nbool solve() {\n    int N, M;\n    if(!(cin >> N >> M)) return false;\n    if(!N && !M) return false;\n\n    vector<Edge> edges(M);\n    for(int i = 0; i < M; ++i) {\n        Edge &e = edges[i];\n        cin >> e.a >> e.b >> e.cost;\n        e.a--;\n        e.b--;\n    }\n    sort(edges.begin(), edges.end());\n    DisjointSet ds(N);\n    int cnt = 0;\n    for(Edge &e : edges) {\n        if(ds.unite(e.a, e.b)) {\n            ++cnt;\n            if(cnt == N/2) {\n                cout << e.cost << endl;\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct edge{\n\tint f,t,c;\n\tedge(){}\n\tedge(int ff,int tt ,int cc){\n\t\tf=ff;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge &e)const{\n\t\treturn c<e.c;\n\t}\n};\n\nstruct edge2{\n\tint t,id;\n\tedge2(){}\n\tedge2(int tt,int dd){\n\t\tt=tt;\n\t\tid=dd;\n\t}\n};\n\nint n,m;\nbool used[1001];\nbool canuse[10001];\nedge e[10001];\nvector<edge2> G[1001];\nint ng;\nint dfs(int v,int p){\n\tused[v]=true;\n\tint cnt=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge2 e2=G[v][i];\n\t\tif(!canuse[e2.id])continue;\n\t\tif(!used[e2.t]){\n\t\t\tcnt+=dfs(e2.t,v);\n\t\t}else{\n\t\t\tif(p!=e2.t)ng=e2.id;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d %d %d\",&e[i].f,&e[i].t,&e[i].c);\n\t\t\te[i].f--;\n\t\t\te[i].t--;\n\t\t}\n\t\tsort(e,e+m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tG[e[i].f].push_back(edge2(e[i].t,i));\n\t\t\tG[e[i].t].push_back(edge2(e[i].f,i));\n\t\t}\n\t\tmemset(canuse,false,sizeof(canuse));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcanuse[i]=true;\n\t\t\tmemset(used,false,sizeof(used));\n\t\t\tif(dfs(0,-1)==n)break;\n\t\t\telse if(i>=n-2)canuse[ng]=false;\n\t\t}\n\t\tint res=0,cnt=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(canuse[i]){\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt==n/2)res=e[i].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\nclass DisjointSet{\nprivate:\n  vector< int > rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    } else {\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++) p[i] = i, rank[i] = 0;\n  }\n  void Union(int x,int y){\n    if(Find(x) != Find(y)) link(Find(x),Find(y));\n  }\n  int Find(int x){\n    return( x != p[x] ? p[x] = Find(p[x]) : p[x]);\n  }\n};\n\nstruct edge{\n  int u, v, cost;\n  bool operator<(const edge& e) const {\n    return cost < e.cost;\n  }\n};\n\nint main(){\n  int n, m;\n  while(cin >> n >> m, n){\n    vector< edge > edges;\n    for(int i = 0; i < m; i++){\n      int s, t, c;\n      cin >> s >> t >> c;\n      edges.push_back((edge){ s - 1, t - 1, c});\n    }\n    sort(edges.begin(), edges.end());\n    DisjointSet UnionFind(n);\n    int mid = 0, sz = 0;\n    for(int i = 0; i < edges.size(); i++){\n      edge& e = edges[i];\n      if(UnionFind.Find(e.u) != UnionFind.Find(e.v)){\n        UnionFind.Union( e.u, e.v);\n        if((n - 1) / 2 == sz) mid = e.cost;\n        if((n - 1) % 2 == 0 && sz == (n - 1) / 2 + 1) mid = (mid + e.cost) / 2;\n        ++sz;\n      }\n    }\n    cout << mid << endl;\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 1001\n#define rank dfasfds\nusing namespace std;\nint par[MAX_N],rank[MAX_N];\n\nvoid init(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nstruct edge{\n  int a,b,c;\n  bool operator < (edge t) const{return c<t.c;}\n};\n\nint n,m;\nedge e[10001];\nint solve(){\n  int cnt=0,used[1001];\n  init(n+1);\n  for(int i=0;i<m;i++){\n    if(same(e[i].a,e[i].b)) continue;\n    unite(e[i].a,e[i].b);\n    used[cnt++]=e[i].c;\n  }\n  return cnt==n-1? used[(n-1)/2]:1e9;\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)return 0;\n  for(int i=0;i<m;i++)cin>>e[i].a>>e[i].b>>e[i].c;\n  sort(e,e+m);\n  cout<<solve()<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct UF{\n\tint par[1000];\n\tint rank[1000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, m;\nvector<P> v[1000];\nUF uf;\n\nvoid solve(){\n\trep(i,1000) v[i].clear();\n\trep(i,m){\n\t\tint s, t, c;\n\t\tcin >> s >> t >> c;\n\t\ts--; t--;\n\t\tv[s].push_back(P(t,c));\n\t}\n\tint s = 0, e = 10000, mid;\n\twhile(true){\n\t\tif(e-s == 1) break;\n\t\tmid = (s+e)/2;\n\t\tuf.init(n);\n\t\trep(i,n){\n\t\t\trep(j,v[i].size()){\n\t\t\t\tP p = v[i][j];\n\t\t\t\tif(p.second <= mid) uf.unite(i,p.first);\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\trep(i,n) if(uf.par[i] == i) cnt++;\n\t\tif(cnt <= n/2) e = mid;\n\t\telse s = mid;\n\t}\n\tcout << e << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define MAX_N 1000\n#define MAX_E 10000\n\nusing namespace std;\n\nint N,E;\nint par[MAX_N+1],rank[MAX_N+1];\n\nstruct edge{\n  int from,to,cost;\n};\n\nbool cmp(const edge& e1,const edge& e2){\n  return e1.cost < e2.cost;\n}\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n  if (rank[x] < rank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (rank[x] == rank[y]) {\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nedge es[MAX_E+1];\n\nvoid kruskal(vector<int> &v){\n  sort(es ,es + E ,cmp);\n  init(N);\n\n  for(int i = 0 ; i < E ; i++){\n    edge e = es[i];\n    if (!same(e.from,e.to)) {\n      unite(e.from,e.to);\n      v.push_back(e.cost);\n    }\n  }\n\n}\n\n\nint main(){\n  int a,b,c;\n  while(cin >> N >> E , N | E){\n    for(int i = 0 ; i < E ; i++){\n      cin >> a >> b >> c;\n \n      es[i].from = --a;\n      es[i].to = --b;\n      es[i].cost = c;\n    }\n\n    vector<int> v;\n    kruskal(v);\n\n    int size = (int)v.size();\n    cout << v[size/2] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nmain(){\n\tint n,m,s,t,c,i;\n\tfor(;cin>>n>>m,n;){\n\t\tmap<int,vector<P> >E;\n\t\tfor(i=0;i<m;i++){\n\t\t\tcin>>s>>t>>c;\n\t\t\tE[s].push_back(make_pair(c,t));\n\t\t\tE[t].push_back(make_pair(c,s));\n\t\t}\n\t\tmap<int,int>v;\n\t\tvector<int>a;\n\t\tpriority_queue<P,vector<P>,greater<P> >Q;\n\t\tQ.push(make_pair(0,1));\n\t\tfor(;!Q.empty();){\n\t\t\tP p=Q.top();Q.pop();\n\t\t\tif(!v[p.second]){\n\t\t\t\tv[p.second]=1;\n\t\t\t\ta.push_back(p.first);\n\t\t\t\tfor(i=0;i<E[p.second].size();i++)Q.push(make_pair(E[p.second][i].first,E[p.second][i].second));\n\t\t\t}\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tcout<<a[n/2]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n#include <stdlib.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define MAX 1005\nint father[MAX];   /* father[x]陦ィ遉コx逧?宛闃らせ*/\nint Rank[MAX];     /*Rank[x]陦ィ遉コx逧?キア蠎ヲ*/\nstruct Edge{\n    int from,to,c;\n}edge[10005];\nint Tot;\nvoid Make_Set(int x)\n{\n\tfather[x] = x; //譬ケ謐ョ螳樣刔諠??謖?ョ夂噪辷カ闃らせ蜿ッ蜿伜喧\n\tRank[x] = 0;   //譬ケ謐ョ螳樣刔諠??蛻晏ァ句喧遘ゥ荵滓怏謇?序蛹?}\n\n/* 譟・謇セx蜈?エ?園蝨ィ逧?寔蜷?蝗樊コッ譌カ蜴狗シゥ霍ッ蠕?/\nint Find_Set(int x)\n{\n\tif (x != father[x])\n\t{\n\t\tfather[x] = Find_Set(father[x]); //霑吩クェ蝗樊コッ譌カ逧?視郛ゥ霍ッ蠕?弍邊セ蜊?\t}\n\treturn father[x];\n}\n/*\n\n謖臥ァゥ蜷亥ケカx,y謇?惠逧?寔蜷?\n荳矩擇逧?ぅ荳ェif else扈捺桷荳肴弍扈晏ッケ逧?シ悟?菴捺?謐ョ諠??蜿伜喧\n\n菴?弍?悟ョ玲葎譏ッ荳榊序逧?叉?梧潔遘ゥ蜷亥ケカ?悟ョ樊慮譖エ譁ー遘ゥ縲?\n*/\n\nvoid Union(int x, int y)\n{\n\tx = Find_Set(x);\n\ty = Find_Set(y);\n\tif (x == y) return;\n\tif (Rank[x] > Rank[y])\n\t{\n\t\tfather[y] = x;\n\t}\n\telse\n\t{\n\t\tif (Rank[x] == Rank[y])\n\t\t{\n\t\t\tRank[y]++;\n\t\t}\n\t\tfather[x] = y;\n\t}\n}\n\nint cmp(Edge a,Edge b)\n{\n    return a.c<b.c;\n}\nint ans[1005],k;\nbool Kruskal(int N,int &mst)\n{\n    int i,x,y;\n    int count=0;//譛?ー冗函謌先焚譚??諤サ蜥鯉シ御ク主キイ豺サ蜉?せ\n    mst=0;\n    for(i=0;i<N;++i)//蛻晏ァ句喧髮?粋\n    Make_Set(i);\n    sort(edge,edge+Tot,cmp);\n    for(i=0;i<Tot;++i)\n    {\n        if(count==N-1)\n        return true;//莉・謇セ蛻ー譛?ー冗函謌先?\n        x=Find_Set(edge[i].from);\n        y=Find_Set(edge[i].to);\n        if(x!=y)\n        {\n            Union(x,y);\n            //mst+=edge[i].c;\n            ans[k++]=edge[i].c;\n            ++count;\n        }\n    }\n    return false;\n}\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    int n,m;\n    int u,v,c;\n    while(~scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        k=0;\n        for(int i=0;i<m;++i)\n        {\n            scanf(\"%d%d%d\",&u,&v,&c);\n            edge[i].from=u;\n            edge[i].to=v;\n            edge[i].c=c;\n        }\n        Tot=m;\n        Kruskal(n,c);\n        printf(\"%d\\n\",ans[(n>>1)-1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\n\nstruct Unionfind {\n  vector<int> size;\n  vector<int> par;\n\n  Unionfind( int n ) :  size(n, 1), par(n) {\n    iota( par.begin() , par.end() , 0 );\n  }\n\n  int find( int x ) {\n    if ( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n\n  bool unite( int x , int y ) {\n    x = find(x);\n    y = find(y);\n    if ( x == y ) return false;\n\n    if ( size[y] < size[x] ) swap( x , y );\n    par[x] = y;\n    size[y] += size[x];\n\n    return true;\n  }\n\n  bool same( int x , int y ) {\n    return find(x) == find(y);\n  }\n};\nint main(void)\n{\n  for(;;){\n    int n,m;\n    cin >> n >> m;\n    if(!n&&!m) return 0;\n    Unionfind t(n+1);\n    vector<tuple<int,int,int> > e(m);\n    REP(i,m){\n      int a,b,c;\n      cin >> a >> b >> c;\n      e[i]=make_tuple(c,a,b);\n    }\n    SORT(e);\n    int tmp=0,answer;\n    REP(i,m){\n      int a,b,c;\n      tie(c,a,b)=e[i];\n      if(t.unite(a,b)){\n\t++tmp;\n\tif(tmp*2==n) answer=c;\n      }\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\npublic:\n\tunion_find(int n):uf(n, -1) {}\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tbool unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\n\t\tif(a == b) return false;\n\n\t\tif(uf[a] > uf[b]) {\n\t\t\tswap(a, b);\n\t\t}\n\t\telse if(uf[a] == uf[b]) {\n\t\t\t--uf[a];\n\t\t}\n\n\t\tuf[b] = a;\n\t\treturn true;\n\t}\n};\n\nstruct edge {\n\tint u, v;\n\tint cost;\n\tedge(int u, int v, int c):u(u), v(v), cost(c){}\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint calc(int n, vector<edge> &edges) {\n\tsort(edges.begin(), edges.end());\n\n\tint cnt = 0;\n\tunion_find uf(n);\n\tfor(const auto &e : edges) {\n\t\tif(uf.unite(e.u, e.v) && ++cnt == n / 2) return e.cost;\n\t}\n}\n\nint main() {\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<edge> edges;\n\t\tedges.reserve(m);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint s, t, c;\n\t\t\tcin >> s >> t >> c;\n\t\t\tedges.emplace_back(s - 1, t - 1, c);\n\t\t}\n\t\tcout << calc(n, edges) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nstruct UF{\n    vector<ll> d;\n    UF(ll size):d(size,-1){}\n    void init(){\n        fill(d.begin(),d.end(),-1);\n    }\n    bool u(ll x,ll y){\n        x = r(x); y = r(y);\n        if(x != y){\n            if(d[y] < d[x]) swap(x,y);\n            d[x] += d[y]; d[y] = x;\n        }\n        return x!=y;\n    }\n    bool f(ll x,ll y){\n        return r(x) == r(y);\n    }\n    ll r(ll x){\n        return d[x] < 0 ? x:d[x] = r(d[x]);\n    }\n    ll s(ll x){\n        return -d[r(x)];\n    }\n};\n\nll n,m;\nstruct edge{\n    ll u,v,cost;\n    edge(){}\n    edge(ll u,ll v,ll cost):u(u),v(v),cost(cost){}\n    bool operator < (const edge& e) const{\n        return cost < e.cost;\n    }    bool operator > (const edge& e) const{\n        return cost > e.cost;\n    }\n};\nll solve(){\n    ll res = LINF;\n    vector<ll> s(m),t(m),c(m);\n    vector<edge> edges(m);\n    for(int i = 0; i < m;i++){\n        ll s,t,c; cin >> s >> t >> c; s--; t--;\n        edges[i] = edge(s,t,c);\n    }\n    sort(edges.begin(),edges.end());\n    UF uf(n);\n    vector<int> f(m);\n    vector<ll> C;\n    for(int i = 0; i < m;i++){\n        if(uf.f(edges[i].u,edges[i].v)) continue;\n        f[i] = true;\n        uf.u(edges[i].u,edges[i].v);\n        C.push_back(edges[i].cost);\n    }\n    sort(C.begin(),C.end());\n    res = C[(n-1)/2];\n    for(int i = 0; i < m;i++){\n        if(edges[i].cost > res) break;\n        if(f[i]) continue;\n        C.clear();\n        uf.init();\n        C.push_back(edges[i].cost);\n        uf.u(edges[i].u,edges[i].v);\n        for(int j = 0; j < m;j++){\n            if(i == j) continue;\n            if(uf.f(edges[j].u,edges[j].v)) continue;\n            uf.u(edges[j].u,edges[j].v);\n            C.push_back(edges[i].cost);\n        }\n        if(uf.s(0) != n) continue;\n        sort(C.begin(),C.end());\n        res = min(res,C[(n-1)/2]);\n    }\n    \n//    for(auto e:edges){ cout << e.cost << \" \" ;\n//    }cout << endl;\n    return res;\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> n >> m,n|m){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n;\nint g[1005][1005];\nbool use_edge[1005][1005];\n\nbool bfs(int n, int edge, int mid){\n    int dis[1005]; //ティツキツ敕ゥツ崢「\n    queue<int> q; //ティツィツェテ・ツ閉湘」ツ?療」ツ?淌ァツつケテ」ツつ津・ツ?・テ」ツつ古」ツつ?\n    rep(i,1005) dis[i] = INF;\n\n    dis[0] = 0;\n    q.push(0);\n\n    int u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        bool f = false;\n        rep(v,n){\n            if(use_edge[u][v] && dis[v] == INF){\n                dis[v] = dis[u] + 1; //テ」ツつーテ」ツδゥテ」ツδ陛」ツ?ョテヲツキツアテ」ツ??\n                q.push(v);\n                f = true;\n            }\n        }\n        if(not f){\n            rep(i,n){\n                if(dis[i] == INF && g[u][i] <= mid && edge > 0){\n                    dis[i] = dis[u] + 1;\n                    q.push(i);\n                    edge--;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        if(dis[i] == INF) return false;\n    }\n    return true;\n}\n\n\nint main(){\n    int m;\n    while(cin >> n >> m, n){\n        pair<int, pair<int, int>> p[10005];\n        int ans = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = g[b][a] = c;\n            p[i] = make_pair(c,make_pair(a,b));\n        }\n        sort(p, p + m);\n\n        memset(use_edge, 0, sizeof(use_edge));\n\n        int h = m / 2;\n        rep(i, h){\n            int a = p[i].second.first;\n            int b = p[i].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            if(bfs(n,i,p[i].first)){\n                ans = min(ans,p[i].first);\n            }\n        }\n        rep(i, m - h){\n            int a = p[m - i - 1].second.first;\n            int b = p[m - i - 1].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            if(bfs(n,i,p[m - i - 1].first)){\n                ans = min(ans,p[m - i - 1].first);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n    int u;\t//?????????\n    int v;\t//??°??????\n    int cost;\t//??????\n    //???????????????????????§?????§?°???¢????????????\n    bool operator<(const edge& another) const {\n        return cost < another.cost;\n    }\n};\n\nconst int MAX_N = 1002;\nconst int MAX_M = 10002;\n\nint n,m;\nedge es[MAX_M];\nint par[MAX_N];\nint rrank[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\trep(i,n){\n\t\tpar[i] = i;\n\t\trrank[i] = 0;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\t//x???????????¨??¨y???????????¨?????????\n\tx = find(x);\t//x???????????¨??????????????????x??¨??????\n\ty = find(y);\t//y???????????¨??????????????????y??¨??????\n\tif(x == y) return;\n\tif(rrank[x] < rrank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rrank[x] == rrank[y])\n\t\t\trrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\t//x,y???????????¨???????????§?????????\n\treturn find(x) == find(y);\n}\n\nP kruskal(int n,int m){\n    vector<int> vec;\n\tinitial(n);\n\tint res = 0;\n\trep(i,m){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n            vec.push_back(e.cost);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n    if(vec.size() % 2 == 0){\n        int hoge = vec.size() / 2 - 1;\n        int sm = vec[hoge] + vec[hoge+1];\n        if(sm % 2 == 0){\n            return P(sm/2,0);\n        }else{\n            return P(sm/2,1);\n        }\n    }else{\n        return P(vec[(vec.size()-1)/2],0);\n    }\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n == 0){\n            break;\n        }\n        rep(i,m){\n            int p,q,r;\n            scanf(\"%d%d%d\",&p,&q,&r);\n            es[i] = (edge){p-1,q-1,r};\n        }\n        sort(es,es+m);\n        P p = kruskal(n,m);\n        if(p.second == 0){\n            cout << p.first << \"\\n\";\n        }else{\n            cout << p.first + 0.5 << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 6500000\n#define rank dfasfds\nusing namespace std;\nint par[MAX_N],rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nstruct edge{\n  int a,b,c;\n  bool operator < (edge t) const{return c<t.c;}\n};\n\nint n,m;\n\nedge e[10001];\nint solve(int s){\n  int cnt=0,used[1001];\n  init(n);\n  for(int i=s;i<m;i++){\n    if(same(e[i].a,e[i].b)) continue;\n    unite(e[i].a,e[i].b);\n    used[cnt++]=e[i].c;\n  }\n  if(cnt!=n-1) return 1e9;\n  return used[(n-1)/2];\n}\n\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)return 0;\n  for(int i=0;i<m;i++)cin>>e[i].a>>e[i].b>>e[i].c;\n  sort(e,e+m);\n  int ans=1e9;\n  for(int i=0;i<m;i++)ans=min(ans,solve(i));\n  cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nstruct edge{\n    int s,t,c;\n    edge(int s,int t,int c):s(s),t(t),c(c){}\n    bool operator<(const edge& other)const{ return c<other.c; }\n};\n\nvoid solve(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        vector<edge> edges;\n        rep(i,0,m){\n            int s,t,c;\n            cin >> s >> t >> c;\n            --s;\n            --t;\n            edges.emplace_back(edge(s,t,c));\n        }\n        sort(edges.begin(),edges.end());\n        union_find uf(n);\n        vector<int> costs;\n        for(const auto& e:edges) if(!uf.is_same(e.s,e.t)){\n            uf.unite(e.s,e.t);\n            costs.emplace_back(e.c);\n        }\n        cerr << costs << endl;\n        cout << costs[(n-2)/2] << endl;\n    }\n}\n\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <class T>\nstruct Kruskal {\n  struct UnionFind {\n    int N;\n    vector<int> sz_tree, parent;\n    UnionFind() {}\n    UnionFind(int N) : N(N), sz_tree(N, 1), parent(N) {\n      iota(parent.begin(), parent.end(), 0);\n    }\n    int root(int x) {\n      return parent[x] == x ? x : parent[x] = root(parent[x]);\n    }\n    void merge(int x, int y) {\n      if ((x = root(x)) == (y = root(y))) return;\n      if (sz_tree[x] < sz_tree[y]) swap(x, y);\n      sz_tree[x] += sz_tree[y];\n      parent[y] = x;\n    }\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n    int size(int x) {\n      return sz_tree[root(x)];\n    }\n  };\n  struct edge {\n    int from, to; T cost;\n    edge() {}\n    edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n  };\n \n  int N;\n  vector<edge> es;\n  vector<edge> use;\n  Kruskal() {}\n  Kruskal(int N) : N(N) {}\n \n  void add_edge(int from, int to, T cost) {\n    es.emplace_back(from, to, cost);\n  }\n  T mst() {\n    T res = 0;\n    UnionFind uf(N);\n    sort(es.begin(), es.end(), [&](edge a, edge b) {\n      return a.cost < b.cost;\n    });\n    for (auto &e : es) {\n      if (uf.same(e.from, e.to)) continue;\n      uf.merge(e.from, e.to);\n      use.emplace_back(e);\n      res += e.cost;\n    }\n    return res;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n, m;\n  while (cin >> n >> m, n) {\n    Kruskal<int> K(n);\n    for (int i = 0; i < m; i++) {\n      int s, t, c;\n      cin >> s >> t >> c;\n      s--, t--;\n      K.add_edge(s, t, c);\n      K.add_edge(t, s, c);\n    }\n    K.mst();\n    cout << K.use[(n - 1) / 2].cost << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint p[10001],r[10001];\nvoid init(){rep(i,10001)p[i]=i,r[i]=0;}\nint find(int x){return (p[x]==x)?x:(p[x]=find(p[x]));}\nvoid unite(int x,int y) {\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(r[x]<r[y])p[x]=y;\n  else{p[y]=x;if(r[x]==r[y])r[x]++;}\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid Main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    init();\n    PP a[m];\n    rep(i,m) cin >> a[i].S.F >> a[i].S.S >> a[i].F;\n    sort(a,a+m);\n    int c=n/2;\n    rep(i,m) {\n      if(same(a[i].S.F,a[i].S.S)) continue;\n      unite(a[i].S.F,a[i].S.S);\n      c--;\n      if(!c) {\n        pr(a[i].F);\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct union_find {\n\tvector<int> v;\n\tint k;\n\tunion_find(int n) : v(n, -1), k(0) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t\tk++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tvector<int> s(m), t(m), c(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> s[i] >> t[i] >> c[i];\n\t\t\ts[i]--; t[i]--;\n\t\t}\n\t\tfor (int C = 1; C <= 1000; C++) {\n\t\t\tunion_find ufs(n), ufe(n), ufg(n);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (c[i] <= C) ufs.unite(s[i], t[i]);\n\t\t\t\tif (c[i] >= C) ufg.unite(s[i], t[i]);\n\t\t\t}\n\t\t\tif (ufs.k >= n / 2 && ufg.k >= n / 2 - 1) {\n\t\t\t\tcout << C << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n;\nint g[1005][1005];\nbool use_edge[1005][1005];\n\nbool bfs(int n, int edge, int mid){\n    bool used[1005] = {0};\n    queue<int> q; //?¨??????????????????\\??????\n\n    used[0] = 1;\n    q.push(0);\n\n    int u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        bool f = false;\n        rep(v,n){\n            if(use_edge[u][v] && used[v] == false){\n                used[v] = true;\n                q.push(v);\n                f = true;\n            }\n        }\n        if(not f){\n            rep(i,n){\n                if(used[i] == false && g[u][i] <= mid && edge > 0){\n                    used[i] = true;\n                    q.push(i);\n                    edge--;\n                    break;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        if(used[i] == false) return false;\n    }\n    return true;\n}\n\n\nint main(){\n    int m;\n    while(cin >> n >> m, n){\n        pair<int, pair<int, int>> p[10005];\n        int ans = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = g[b][a] = c;\n            p[i] = make_pair(c,make_pair(a,b));\n        }\n        sort(p, p + m);\n\n        memset(use_edge, 0, sizeof(use_edge));\n\n        int h = m / 2;\n        rep(i, h){\n            int a = p[i].second.first;\n            int b = p[i].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            if(bfs(n,i,p[i].first)){\n                ans = min(ans,p[i].first);\n            }\n        }\n        rep(i, m - h){\n            int a = p[m - i - 1].second.first;\n            int b = p[m - i - 1].second.second;\n            use_edge[a][b] = use_edge[b][a] = true;\n            if(bfs(n,i,p[m - i - 1].first)){\n                ans = min(ans,p[m - i - 1].first);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\n\ntypedef long long ll;\n\nusing namespace std;\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> par, rank, size;  //親, 深さ, その木の要素数\n\n    UnionFind(int n): n(n) {\n        for(int i=0;i<n;++i){\n            par.push_back(i);\n            rank.push_back(0);\n            size.push_back(1);\n        }\n    }\n\n    //根を求める\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            int p = find(par[x]);\n            size[x] = size[p];\n            return par[x] = p;\n        }\n    }\n\n    //xとyの属する集合の併合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        \n        size[x] += size[y];\n        size[y] = size[x];\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n\n        x = find(x);\n        y = find(y);\n    }\n\n    //同じ集合に属するか否か\n    bool is_same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nll solve(int n, int m) {\n    vector<tuple<ll,int,int>> edges(m);\n    int s,t; ll c;\n    for(int i=0;i<m;++i){\n        cin >> s >> t >> c;\n        edges[i] = tuple<ll, int, int>{c, s, t};\n    }\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(n+1);\n    vector<int> edge_cnt(m);\n    for(int i=0;i<m;++i){\n        tie(c, s, t) = edges[i];\n        if(uf.is_same(s,t)) {\n            edge_cnt[i] = edge_cnt[i-1];\n        } else {\n            uf.unite(s, t);\n            edge_cnt[i] = (i==0?0:edge_cnt[i-1]) + 1;\n            if(edge_cnt[i] == ((n+1)/2)) {\n                return c;\n            }\n        }\n    }\n\n    return 0LL;\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        cout << solve(n, m) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nclass UF {\n\tpublic:\n\tstatic const int ufmax=1052;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init(){int i; rep(i,ufmax) { ufpar[i]=i; ufrank[i]=0; ufcnt[i]=1; } }\n\tint find(int x) {\treturn (ufpar[x]==x)?(x):(ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x,int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x]=y, ufcnt[y]+=ufcnt[x];\n\t\telse {ufpar[y]=x; ufcnt[x]+=ufcnt[y]; if(ufrank[x]==ufrank[y]) ufrank[x]++;}\n\t}\n};\n\n#define fi first\n#define se second\n\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tusing pii = pair<int,int>;\n\t\tusing P = pair<int,pii>;\n\t\tvector<P> v(m);\n\t\trep(i,m){\n\t\t\tcin>>v[i].se.fi>>v[i].se.se>>v[i].fi;\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tUF uf;\n\t\tvector<int> w;\n\t\tfor(auto x: v){\n\t\t\tint a=x.se.fi,b=x.se.se;\n\t\t\ta--,b--;\n\t\t\tif(uf[a] == uf[b]) continue;\n\t\t\tuf.unite(a,b);\n\t\t\tw.push_back(x.fi);\n\t\t}\n\t\tcout<<w[n/2-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int a, int b, int c) : from(a), to(b), cost(c) {}\n    bool operator<(const Edge &x) const {\n        return cost < x.cost;\n    }\n};\n\nstruct UnionFind {\n    int node[1010];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    int size(int x) {\n        return -node[find(x)];\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        if(size(x) > size(y)) swap(x, y);\n        node[y] += node[x];\n        node[x] = y;\n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    while(1) {\n        scanf(\"%d%d\", &N, &M);\n        if(!N) break;\n        vector<Edge> edges;\n        for(int i=0; i<M; i++) {\n            int s, t, c;\n            scanf(\"%d%d%d\", &s, &t, &c); s--; t--;\n            edges.push_back(Edge(s, t, c));\n        }\n\n        sort(edges.begin(), edges.end());\n        vector<int> use_cost;\n        UnionFind uf;\n        for(int i=0; i<M; i++) {\n            Edge e = edges[i];\n            if(uf.unite(e.from, e.to)) {\n                use_cost.push_back(e.cost);\n            }\n        }\n        int mid = (N-1) / 2;\n        printf(\"%d\\n\", use_cost[mid]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\npair<int, Edges> prim(Graph g)\n{\n\tvector<bool> used(g.size());\n\tEdges res;\n\tint sum = 0;\n\n\tpriority_queue<Edge, vector<Edge>, greater<Edge>> que;\n\tque.push(Edge{ -1, 0, 0 });\n\n\twhile (!que.empty())\n\t{\n\t\tEdge e = que.top(); que.pop();\n\t\tif (used[e.to]) continue;\n\t\tif (e.from >= 0) res.push_back(e);\n\t\tsum += e.cost;\n\t\tused[e.to] = true;\n\t\tfor (Edge i : g[e.to])\n\t\t{\n\t\t\tif (!used[i.to]) que.push(i);\n\t\t}\n\t}\n\treturn make_pair(sum, res);\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint s, t, c; cin >> s >> t >> c;\n\t\t\ts--; t--;\n\t\t\tadd_edge(g, s, t, c);\n\t\t\tadd_edge(g, t, s, c);\n\t\t}\n\t\tEdges es = prim(g).second;\n\t\tsort(ALL(es));\n\t\tcout << es[n / 2 - 1].cost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  while (cin >> n >> m && n + m){\n    vector<tuple<int, int, int> > es;\n    \n    REP(i, m){\n      int s, t, c;\n      cin >> s >> t >> c;\n      es.push_back(make_tuple(s - 1, t - 1, c));\n    }\n    \n    int ub = 1010;\n    int lb = -1;\n\n    while (ub - lb > 1){\n      int mb   = (lb + ub) >> 1;\n      int cost = 0;\n\n      UnionFind uf(n);\n\n      REP(i, m) if (get<2>(es[i]) <= mb){\n        uf.unite(get<0>(es[i]), get<1>(es[i]));\n      }\n      \n      REP(i, m) if (get<2>(es[i]) > mb && !uf.same(get<0>(es[i]), get<1>(es[i]))){\n          uf.unite(get<0>(es[i]), get<1>(es[i]));\n        cost++;\n      }\n\n      if (cost * 2 > n - 1){\n        lb = mb;\n      } else {\n        ub = mb;\n      }\n    }\n    \n    cout << ub << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2536: Median Tree\n// 2017.11.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1002\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\ntypedef struct { int s, t, c; } T;\nT e[10002]; \n\nchar buf[30], *bp;\nint getint()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\treturn n;\n}\n\nint cmp(T *a, T *b) { return a->c - b->c; }\n\nint Kruskal(int n, int m) \n{ \n\tint i, c;\n\tT *ep;\n\n\tfor (i = 1; i <= n; i++) make_set(i);\n\tqsort(e, m, sizeof(T), cmp);\n\tc = 1+(n-1)/2;\n\tfor (ep = e; m--; ep++) {\n\t\tif (find_set(ep->s) != find_set(ep->t)) { \n\t\t\tunion_set(ep->s, ep->t); \n\t\t\tif (--c == 0) return ep->c; \n\t\t} \n\t}\n\treturn 0;\n} \n\nint main()\n{\n\tint n, m, i;\n\n\twhile (fgets(bp=buf, 30, stdin) && *bp != '0') {\n\t\tn = getint(), bp++, m = getint();\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tfgets(bp=buf, 30, stdin);\n\t\t\te[i].s = getint(), bp++, e[i].t = getint(), bp++, e[i].c = getint();\n\t\t}\n\t\tprintf(\"%d\\n\", Kruskal(n, m));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//ティツゥツ陛、ツセツ。テゥツ鳴「テヲツ閉ーテッツシツ暗」ツ??」ツ?セテ」ツ?ッMINテッツシツ?\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//テヲツ個ソテ・ツ?・テゥツ鳴「テヲツ閉ー\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//テ・ツ渉姪」ツつ甘・ツ?コテ」ツ?凖ゥツ鳴「テヲツ閉ー\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint p[100010]={0};\nint d[100010]={0};\nint Find(int a,int b){\n  int r,n;\n  for(r=++a;p[r];r=p[r]);\n  for(;n=p[a];a=n)p[a]=r;\n  for(r=++b;p[r];r=p[r]);\n  for(;n=p[b];b=n)p[b]=r;\n  return a-b?1:0;\n}\nint Union(int a,int b){\n  if(Find(a,b)){\n    for(++a;p[a];a=p[a]);\n    for(++b;p[b];b=p[b]);\n    d[a]<d[b]?(p[a]=b):(p[b]=a);\n    if(d[a]==d[b])d[a]++;\n    return 1;\n  }\n  return 0;\n}\nint main(){\n  int a[10010],b[10010],c,n,m,i,j;\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(i=0;i<n+2;i++)p[i]=d[i]=0;\n    R=C=1;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a[R],&b[R],&c);\n      hin(c);\n    }\n    for(i=0;i<n/2;i+=Union(a[j],b[j]))c=N[j=hout()];\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1000 + 10, MAXM = 1e5 + 100;\n\nint fa[MAXN], ans[MAXN], tot, n, m;\n\nstruct lnk {\n\tint a, b, l;\n\tconst operator < (const lnk p) {\n\t\treturn l < p.l;\n\t}\n}l[2 * MAXM];\n\nint findfa(int x) {\n\treturn (fa[x] == x ? x : (fa[x] = findfa(fa[x])));\n}\n\nint main() {\n\twhile ((~scanf(\"%d%d\", &n, &m)) && (n + m)) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tscanf(\"%d%d%d\", &l[i].a, &l[i].b, &l[i].l);\n\t\t}\n\t\tsort(l + 1, l + m + 1);\n\t\ttot = 0;\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (findfa(l[i].a) != findfa(l[i].b)) {\n\t\t\t\tfa[findfa(l[i].a)] = findfa(l[i].b);\n\t\t\t\tans[++tot] = l[i].l;\n\t\t\t\tif (tot == n - 1) break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans[(tot >> 1) + 1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2536: Median Tree\n// 2017.11.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1002\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\ntypedef struct { int s, t, c; } T;\nT e[10002], e2[10002];\n\nchar buf[30], *bp;\nint getint()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\treturn n;\n}\n\nint f[1001];\nvoid distsort(m)\n{\n\tint i, x;\n\tT *ep;\n\n\tmemset(f, 0, sizeof(f));\n\tfor (ep = e, i = 0; i < m; i++, ep++) f[ep->c]++;\n\tfor (i = 0; i <= 1000; i++) f[i] += f[i-1];\n\tfor (i = m; i--;) x = e[i].c, e2[--f[x]] = e[i];\n}\n\nint Kruskal(int n, int m) \n{ \n\tint i, c;\n\tT *ep;\n\n\tfor (i = 1; i <= n; i++) make_set(i);\n\tdistsort(m);\n\tc = 1+(n-1)/2;\n\tfor (ep = e2; m--; ep++) {\n\t\tif (find_set(ep->s) != find_set(ep->t)) { \n\t\t\tunion_set(ep->s, ep->t); \n\t\t\tif (--c == 0) return ep->c; \n\t\t} \n\t}\n\treturn 0;\n} \n\nint main()\n{\n\tint n, m, i;\n\n\twhile (fgets(bp=buf, 30, stdin) && *bp != '0') {\n\t\tn = getint(), bp++, m = getint();\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tfgets(bp=buf, 30, stdin);\n\t\t\te[i].s = getint(), bp++, e[i].t = getint(), bp++, e[i].c = getint();\n\t\t}\n\t\tprintf(\"%d\\n\", Kruskal(n, m));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define UNION_FIND_MAX 1000\n\nint uf_table[UNION_FIND_MAX];\n\nvoid uf_init(void) {\n\tint i;\n\tfor(i=0;i<UNION_FIND_MAX;i++)uf_table[i]=0;\n}\n\nvoid uf_merge(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\tif(a!=b)uf_table[a]=b+1;\n}\n\nint uf_issame(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\treturn a==b;\n}\n\ntypedef struct {\n\tint s,t,c;\n} edge_t;\n\nint qscedge(const void* x,const void* y) {\n\tint a=((const edge_t*)x)->c;\n\tint b=((const edge_t*)y)->c;\n\tif(a>b)return 1;\n\tif(a<b)return -1;\n\treturn 0;\n}\n\nint main(void) {\n\tint n,m;\n\tstatic edge_t edges[10000];\n\twhile(scanf(\"%d%d\",&n,&m)==2 && (n|m)!=0) {\n\t\tint i;\n\t\tint left,right;\n\t\tfor(i=0;i<m;i++) {\n\t\t\tscanf(\"%d%d%d\",&edges[i].s,&edges[i].t,&edges[i].c);\n\t\t}\n\t\tqsort(edges,m,sizeof(edge_t),qscedge);\n\t\tleft=0;right=m-1;\n\t\twhile(left<=right) {\n\t\t\tint mid=(left+right)/2;\n\t\t\tint count=0;\n\t\t\tuf_init();\n\t\t\tfor(i=0;i<m;i++) {\n\t\t\t\tif(!uf_issame(edges[i].s,edges[i].t)) {\n\t\t\t\t\tuf_merge(edges[i].s,edges[i].t);\n\t\t\t\t\tif(mid<i)count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count<=n/2-1)right=mid-1; else left=mid+1;\n\t\t}\n\t\tprintf(\"%d\\n\",edges[right+1].c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>?): Unit {\n    while(true){\n        val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val union = UnionFind(n)\n        val edges = Array(m){\n            val (s, t, c) = readLine()!!.trim().split(' ').map(String::toInt)\n            Triple(s - 1, t - 1, c)\n        }.sortedBy(Triple<Int, Int, Int>::third)\n        val used = Stack<Int>()\n        for ((s, t, c) in edges){\n            if (!union.isSame(s, t)) {\n                used.push(c)\n                union.merge(s, t)\n            }\n        }\n        used.sort()\n        println(\n                used[used.size / 2]\n        )\n    }\n}\nclass UnionFind(val size: Int){\n    private val array = IntArray(size){-1}\n    private fun find(a: Int): Int {\n        val root = root(a)\n        setRoot(a, root)\n        return root\n    }\n    private tailrec fun root(a: Int): Int {\n        return if (array[a] < 0) a else root(array[a])\n    }\n    private fun setRoot(a: Int, root: Int) {\n        if (a != root) {\n            setRoot(array[a], root)\n            array[a] = root\n        }\n    }\n    fun isSame(u: Int, v: Int): Boolean {\n        return find(u) == find(v)\n    }\n    fun merge(u: Int, v: Int) {\n        val ur = find(u)\n        val vr = find(v)\n        if (ur != vr){\n            if (array[ur] < array[vr]){\n                array[ur] += array[vr]\n                array[vr] = ur\n            }else {\n                array[vr] += array[ur]\n                array[ur] = vr\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint f;\n\t\tint t;\n\t\tint c;\n\n\t\tEdge(int f, int t, int c) {\n\t\t\tthis.f = f;\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Edge s) {\n\t\t\treturn c - s.c;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + f + \" \" + t + \" \" + c;\n\t\t}\n\t}\n\n\tclass UnionFindTree {\n\t\tint[] parent;\n\t\tint size = 1;\n\t\t\n\t\tpublic UnionFindTree(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < parent.length; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (parent[x] == x) return x;\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x, int y) {\n\t\t\tint xx = find(x), yy = find(y);\n\t\t\tif (xx == yy) return;\n\t\t\tparent[xx] = yy;\n\t\t\tsize++;\n\t\t}\n\t\t\n\t\tpublic int getSize() {\n\t\t\treturn size;\n\t\t}\n\t}\n\n\tboolean can(Edge[] es, int n, int mid) {\n\t\tUnionFindTree uft = new UnionFindTree(n);\n\t\tint m = es.length;\n\t\tint cur = 0;\n\t\tfor ( ; cur < m; cur++) {\n\t\t\tif (es[cur].c > mid) break;\n\t\t\tuft.unite(es[cur].f, es[cur].t);\n\t\t}\n\t\t\n\t\tif (uft.getSize() <= (n + 1) / 2) return false;\n\t\t\n\t\tfor ( ; cur < m; cur++) {\n\t\t\tuft.unite(es[cur].f, es[cur].t);\n\t\t}\n\t\t\n\t\treturn uft.getSize() == n;\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tEdge[] es = new Edge[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tes[i] = new Edge(in.nextInt() - 1, in.nextInt() - 1, in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(es);\n\t\t\t\n\t\t\tint lo = 0, hi = 1000000000;\n\t\t\twhile (hi - lo > 1) {\n\t\t\t\tint mid = (lo + hi) / 2;\n\t\t\t\tif (!can(es, n, mid)) \n\t\t\t\t\tlo = mid;\n\t\t\t\telse\n\t\t\t\t\thi = mid;\n\t\t\t}\n\t\t\tSystem.out.println(lo + 1);\n\t\t}\t\t\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N, M;\n    static Edge[] E;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        while(true) {\n            N = sc.nextInt();\n            M = sc.nextInt();\n            if( N == 0 ) break;\n\n            E = new Edge[M];\n            for (int i = 0; i < M; i++) {\n                E[i] = new Edge( sc.nextInt()-1, sc.nextInt()-1, sc.nextInt() );\n            }\n\n            pw.println( solve() );\n        }\n\n        pw.flush();\n    }\n\n    static class Edge {\n        int s, t, c;\n\n        public Edge(int s, int t, int c) {\n            this.s = s;\n            this.t = t;\n            this.c = c;\n        }\n    }\n\n    static int solve() {\n        Arrays.sort(E, Comparator.comparingInt(e -> e.c));\n\n        int MED = N / 2;\n        UnionFind uf = new UnionFind(N);\n        int cnt = 0;\n        for (int i = 0; i < M; i++) {\n            if( !uf.isSame(E[i].s, E[i].t) ) {\n                uf.unite(E[i].s, E[i].t);\n                cnt++;\n            }\n            if( cnt == MED ) return E[i].c;\n        }\n        throw new IllegalArgumentException(\"wtf\");\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] count;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            count = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                count[i] = 1;\n            }\n        }\n\n        public int root(int i) {\n            if (parent[i] == i) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public int unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if (ri == rj) return ri;\n\n\n            int big = count[ri] < count[rj] ? rj : ri;\n            int small = big == ri ? rj : ri;\n            parent[small] = big;\n            count[big] += count[small];\n            return big;\n        }\n\n        public int count(int a) {\n            return count[root(a)];\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\n\tstatic int ans[];\n\tstatic int count = 0;\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile (true) {\n\n\t\t\tString str[] = br.readLine().split(\" \");\n\n\t\t\tint n = Integer.parseInt(str[0]);\n\t\t\tint m = Integer.parseInt(str[1]);\n\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\n\t\t\tans = new int[n];\n\t\t\tArrays.fill(ans, 0);\n\t\t\tcount = 0;\n\n\t\t\tArrayList<ArrayList<Edge>> edge = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tedge.add(new ArrayList<>());\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tstr = br.readLine().split(\" \");\n\n\t\t\t\tint s = Integer.parseInt(str[0]) - 1;\n\t\t\t\tint t = Integer.parseInt(str[1]) - 1;\n\t\t\t\tint c = Integer.parseInt(str[2]);\n\n\t\t\t\tedge.get(s).add(new Edge(t, c));\n\t\t\t\tedge.get(t).add(new Edge(s, c));\n\t\t\t}\n\n\t\t\tprime(edge, n);\n\t\t\tArrays.sort(ans);\n\n\t\t\tSystem.out.println(ans[n / 2]);\n\t\t}\n\t}\n\n\tstatic void prime(ArrayList<ArrayList<Edge>> edges, int n) {\n\t\tboolean[] done = new boolean[n];\n\n\t\tQueue<Edge> q = new PriorityQueue<Edge>();\n\t\tq.add(new Edge(0, 0)); // 0から(ダミー)\n\n\t\tdouble totalCost = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tEdge e = q.poll(); // 最小コストの辺を取り出す\n\t\t\tif (done[e.to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdone[e.to] = true; // 訪問済にする\n\t\t\tans[count++] = e.cost;\n\t\t\tq.addAll(edges.get(e.to)); // 隣接しているすべての辺を追加\n\t\t}\n\t}\n}\n\nclass Edge implements Comparable<Edge> {\n\tint to;\n\tint cost;\n\n\tpublic Edge(int to, int cost) {\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge e) {\n\t\treturn this.cost - e.cost;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tEdge[] edges = new Edge[M];\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint s = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt() - 1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tedges[i] = new Edge(s, t, c);\n\t\t\t}\n\t\t\tArrays.sort(edges);\n\t\t\tArrayList<Integer> costs = new ArrayList<Integer>();\n\t\t\tUnionFind uf = new UnionFind(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tif (!uf.find(edges[i].s, edges[i].e)) {\n\t\t\t\t\tuf.union(edges[i].s, edges[i].e);\n\t\t\t\t\tcosts.add(edges[i].c);\n\t\t\t\t\tif (costs.size() == N - 1) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(costs.get(N / 2 - 1));\n\t\t}\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint s, e, c;\n\n\t\tEdge(int s, int e, int c) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.c - o.c;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tint[] set;\n\n\t\tUnionFind(int n) {\n\t\t\tset = new int[n];\n\t\t\tArrays.fill(set, -1);\n\t\t}\n\n\t\tvoid union(int a, int b) {\n\t\t\tint rtA = root(a);\n\t\t\tint rtb = root(b);\n\t\t\tif (rtA == rtb) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset[rtA] += set[rtb];\n\t\t\tset[rtb] = rtA;\n\t\t}\n\n\t\tboolean find(int a, int b) {\n\t\t\treturn root(a) == root(b);\n\t\t}\n\n\t\tint root(int a) {\n\t\t\tif (set[a] < 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\tset[a] = root(set[a]);\n\t\t\t\treturn set[a];\n\t\t\t}\n\t\t}\n\n\t\tint size(int a) {\n\t\t\treturn -set[root(a)];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\tint  M = 10000000;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] cost = new int[n + 1][n + 1];\n\t\t\tint[] min = new int[n + 1];\n\t\t\tboolean[] use = new boolean[n + 1];\n\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t}\n\t\t\tArrays.fill(min, M);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tcost[s][t] = c;\n\t\t\t\tcost[t][s] = c;\n\t\t\t}\n\t\t\tmin[1] = 0;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor (;;) {\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (!use[j] && (v == -1 || min[v] > min[j])) {\n\t\t\t\t\t\tv = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (min[v] != 0) {\n\t\t\t\t\tlist.add(min[v]);\n\t\t\t\t}\n\t\t\t\tuse[v] = true;\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (!use[j] && min[j] > cost[v][j]) {\n\t\t\t\t\t\tmin[j] = cost[v][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tSystem.out.println(list.get((n-1)/2));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\nloop do\n\tn, m = gets.split.map(&:to_i) \n\tbreak if n == 0\n\tuf = UnionFind.new\n\tedges = (1..m).map { gets.split.map(&:to_i) }.sort_by(&:last)\n\tk = 0\n\tedges.each do |i, j, c|\n\t\tnext if uf.same?(i, j)\n\t\tuf.union(i, j)\n\t\tk += 1\n\t\tif k == n / 2\n\t\t\tputs c\n\t\t\tbreak\n\t\tend\n\t end\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int s, t, c;\n}\n\nclass UnionFind {\n    int[] parent;\n    this(int size) {\n        parent = new int[size];\n        parent[] = -1;\n    }\n    int root(int x) {\n        if (parent[x] < 0) return x;\n        return parent[x] = root(parent[x]);\n    }\n    int query(int x, int y) {\n        return root(x) == root(y);\n    }\n    void merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return;\n        parent[y] = x;\n    }\n}\n \nvoid main() {\n    int N, M;\n    Edge[] es;\n\n    bool input() {\n        scanf(\"%d %d\\n\", &N, &M);\n        if (N == 0 && M == 0) return false;\n        es = [];\n        foreach (i; 0 .. M) {\n            int s, t, c;\n            scanf(\"%d %d %d\", &s, &t, &c);\n            s--; t--;\n            es ~= Edge(s, t, c);\n        }\n        return true;\n    }\n\n    void solve() {\n        auto uf = new UnionFind(N);\n        int[] cs;\n        es.sort!\"a.c < b.c\";\n        foreach (e; es) {\n            if (uf.query(e.s, e.t)) continue;\n            uf.merge(e.s, e.t);\n            cs ~= e.c;\n        }\n        writeln(cs[$ / 2]);\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nwhile True:\n    n, m = map(lambda x:int(x), raw_input().split())\n    if n == 0: break\n    g = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = map(lambda x:int(x), raw_input().split())\n        a -= 1\n        b -= 1\n        g[a].append((b,c))\n        g[b].append((a,c))\n    heap = []\n    visited = [False]*n\n    edges = []\n    heappush(heap, (0,0))\n    while len(heap):\n        d,v = heappop(heap)\n        if visited[v]: continue\n        visited[v] = True\n        edges.append(d)\n        for u,dd in g[v]:\n            if not visited[u]:\n                heappush(heap, (dd,u))\n    print sorted(edges)[len(edges)/2]"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = sorted([LI()[::-1] for _ in range(m)])\n        uf = UnionFind(n+1)\n        b = 0\n        for c,t,s in a:\n            if uf.union(s,t):\n                b += 1\n                if b > (n-1) // 2:\n                    return c\n        return -1\n\n    while True:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    while 1:\n        n,m = LI()\n        if n == 0 and m == 0:\n            break\n        v = [[] for i in range(n)]\n        for i in range(m):\n            a,b = LI()\n            a -= 1\n            b -= 1\n            v[a].append(b)\n            v[b].append(a)\n        bfs_map = [1 for i in range(n)]\n        bfs_map[0] = 0\n        f = [0 for i in range(n)]\n        q = deque()\n        q.append(0)\n        fl = 1\n        while q:\n            if not fl:break\n            x = q.popleft()\n            for y in v[x]:\n                if bfs_map[y]:\n                    bfs_map[y] = 0\n                    f[y] = (1-f[x])\n                    q.append(y)\n                else:\n                    if f[y] == f[x]:\n                        print(0)\n                        fl = 0\n                        break\n        if fl:\n            ans = []\n            k = sum(f)\n            if k%2 == 0:\n                ans.append(k//2)\n            k = len(f)-sum(f)\n            if k%2 == 0:\n                ans.append(k//2)\n            ans = list(set(ans))\n            ans.sort()\n            print(len(ans))\n            for i in ans:\n                print(i)\n    return\n\n#B\ndef B():\n    def gcd(a,b):\n        if a == 0:\n            return b\n        return gcd(b%a, a)\n\n    def factorize(n):\n        if n < 4:\n            return {n:1}\n        i = 2\n        d = defaultdict(int)\n        m = n\n        while i**2 <= n:\n            if m%i == 0:\n                while m%i == 0:\n                    m//=i\n                    d[i] += 1\n            i += 1\n        d[m] += 1\n        return d\n    p,q = LI()\n    g = gcd(p,q)\n    ans = q//g\n    if ans == 1:\n        print(1)\n    else:\n        d = factorize(ans)\n        ans = 1\n        for i in d.keys():\n            ans *= i\n        print(ans)\n    return\n\n#C\ndef C():\n    return\n\n#D\ndef D():\n    def root(x):\n        if par[x] == x:\n            return par[x]\n        par[x] = root(par[x])\n        return par[x]\n    def same(x,y):\n        return root(x) == root(y)\n    def unite(x,y):\n        x = root(x)\n        y = root(y)\n        if rank[x] < rank[y]:\n            par[x] = y\n        else:\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n    while 1:\n        n,m = LI()\n        if n == 0 and m == 0:\n            break\n        l = LIR(m)\n        l.sort(key = lambda x:x[2])\n        for i in range(m):\n            l[i][0] -= 1\n            l[i][1] -= 1\n        ans = []\n        par = [i for i in range(n)]\n        rank = [0 for i in range(n)]\n        for x,y,c in l:\n            if not same(x,y):\n                unite(x,y)\n                ans.append(c)\n        print(ans[(n-1)//2])\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    D()\n\n"
  }
]