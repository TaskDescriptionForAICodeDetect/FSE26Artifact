[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->cost - ((Edge *)b)->cost;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid union_sets(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint kruskal(int n, int m, Edge edges[], int selected_edges[]) {\n    Edge sorted_edges[m];\n    for (int i = 0; i < m; i++) {\n        sorted_edges[i] = edges[i];\n    }\n    qsort(sorted_edges, m, sizeof(Edge), compare);\n\n    int parent[n];\n    int rank[n];\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int edge_count = 0;\n    int selected_index = 0;\n    for (int i = 0; i < m; i++) {\n        int u = sorted_edges[i].u;\n        int v = sorted_edges[i].v;\n        int uroot = find(parent, u);\n        int vroot = find(parent, v);\n        if (uroot != vroot) {\n            selected_edges[selected_index++] = sorted_edges[i].cost;\n            union_sets(parent, rank, uroot, vroot);\n            edge_count++;\n            if (edge_count == n - 1)\n                break;\n        }\n    }\n    return selected_index;\n}\n\nint main() {\n    int n, m;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        Edge edges[m];\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n        }\n\n        int selected_edges[n - 1];\n        int count = kruskal(n, m, edges, selected_edges);\n\n        qsort(selected_edges, count, sizeof(int), compare);\n        printf(\"%d\\n\", selected_edges[(count - 1) / 2]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    Edge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\n};\n\nbool compareEdge(const Edge &a, const Edge &b) {\n    return a.cost < b.cost;\n}\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\npublic:\n    UnionFind(int size) {\n        parent.resize(size);\n        rank.resize(size, 0);\n        for (int i = 0; i < size; ++i) {\n            parent[i] = i;\n        }\n    }\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) {\n            parent[x] = y;\n        } else {\n            parent[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint findMinMedianSpanningTree(int N, int M, vector<Edge> &edges) {\n    sort(edges.begin(), edges.end(), compareEdge);\n    int min_median = INT_MAX;\n    for (int i = 0; i <= M - (N - 1); ++i) {\n        UnionFind uf(N);\n        int count = 0;\n        vector<int> selected_costs;\n        for (int j = i; j < M; ++j) {\n            Edge &e = edges[j];\n            if (!uf.same(e.u, e.v)) {\n                uf.unite(e.u, e.v);\n                selected_costs.push_back(e.cost);\n                count++;\n                if (count == N - 1) break;\n            }\n        }\n        if (count == N - 1) {\n            int median = selected_costs[(N - 2) / 2];\n            if (median < min_median) {\n                min_median = median;\n            }\n        }\n    }\n    return min_median;\n}\n\nint main() {\n    int N, M;\n    while (cin >> N >> M) {\n        if (N == 0 && M == 0) break;\n        vector<Edge> edges;\n        for (int i = 0; i < M; ++i) {\n            int u, v, cost;\n            cin >> u >> v >> cost;\n            edges.emplace_back(u, v, cost);\n        }\n        int result = findMinMedianSpanningTree(N, M, edges);\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int u, v, cost;\n\n    Edge(int u, int v, int cost) {\n        this.u = u;\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void union(int x, int y) {\n        int xRoot = find(x);\n        int yRoot = find(y);\n        if (xRoot == yRoot) return;\n        if (rank[xRoot] < rank[yRoot]) {\n            parent[xRoot] = yRoot;\n        } else if (rank[xRoot] > rank[yRoot]) {\n            parent[yRoot] = xRoot;\n        } else {\n            parent[yRoot] = xRoot;\n            rank[xRoot]++;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            if (n == 0 && m == 0) break;\n            Edge[] edges = new Edge[m];\n            for (int i = 0; i < m; i++) {\n                int u = scanner.nextInt();\n                int v = scanner.nextInt();\n                int cost = scanner.nextInt();\n                edges[i] = new Edge(u, v, cost);\n            }\n            Arrays.sort(edges);\n            int minMedian = Integer.MAX_VALUE;\n            for (int i = 0; i <= m - (n - 1); i++) {\n                UnionFind uf = new UnionFind(n);\n                int edgeCount = 0;\n                List<Integer> selectedCosts = new ArrayList<>();\n                for (int j = i; j < m; j++) {\n                    Edge e = edges[j];\n                    if (uf.find(e.u) != uf.find(e.v)) {\n                        uf.union(e.u, e.v);\n                        selectedCosts.add(e.cost);\n                        edgeCount++;\n                        if (edgeCount == n - 1) break;\n                    }\n                }\n                if (edgeCount == n - 1) {\n                    Collections.sort(selectedCosts);\n                    int median = selectedCosts.get((n - 1) / 2);\n                    if (median < minMedian) {\n                        minMedian = median;\n                    }\n                }\n            }\n            System.out.println(minMedian);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:38:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MedianSpanningTree {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, cost;\n        \n        Edge(int src, int dest, int cost) {\n            this.src = src;\n            this.dest = dest;\n            this.cost = cost;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return false;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        \n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            \n            List<Edge> edges = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                int cost = scanner.nextInt();\n                edges.add(new Edge(u, v, cost));\n            }\n            \n            Collections.sort(edges);\n            \n            List<Integer> medianCandidates = new ArrayList<>();\n            \n            for (int medianIndex = 0; medianIndex < m; medianIndex++) {\n                UnionFind uf = new UnionFind(n);\n                int edgesAdded = 0;\n                int totalCost = 0;\n                \n                for (int i = 0; i < m; i++) {\n                    if (i == medianIndex) continue;\n                    \n                    Edge edge = edges.get(i);\n                    if (uf.union(edge.src, edge.dest)) {\n                        edgesAdded++;\n                        totalCost += edge.cost;\n                    }\n                    \n                    if (edgesAdded == n - 1) break;\n                }\n                \n                if (edgesAdded == n - 1) {\n                    medianCandidates.add(edges.get(medianIndex).cost);\n                }\n            }\n            \n            Collections.sort(medianCandidates);\n            System.out.println(medianCandidates.get(medianCandidates.size() / 2));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:38:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 1001\n#define MAX_EDGES 10001\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint parent[MAX_NODES];\nint rank[MAX_NODES];\n\nint compare(const void* a, const void* b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    \n    if (rootX == rootY) return;\n    \n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint kruskalMST(Edge* edges, int n, int m) {\n    qsort(edges, m, sizeof(Edge), compare);\n    \n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    int treeEdges = 0;\n    int medianIndex = (n - 1) / 2;\n    \n    for (int i = 0; i < m && treeEdges < n - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        \n        if (find(u) != find(v)) {\n            unionSet(u, v);\n            treeEdges++;\n            \n            if (treeEdges == medianIndex + 1)\n                return edges[i].cost;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        \n        Edge edges[MAX_EDGES];\n        \n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n        }\n        \n        int medianCost = kruskalMST(edges, n, m);\n        printf(\"%d\\n\", medianCost);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) swap(px, py);\n        parent[py] = px;\n        if (rank[px] == rank[py]) rank[px]++;\n        return true;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<pair<int, pair<int, int>>> edges(m);\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            cin >> u >> v >> w;\n            edges[i] = {w, {u-1, v-1}};\n        }\n\n        sort(edges.begin(), edges.end());\n        \n        vector<int> spanningTreeEdgeCosts;\n        UnionFind uf(n);\n\n        for (auto& edge : edges) {\n            int w = edge.first;\n            int u = edge.second.first;\n            int v = edge.second.second;\n\n            if (uf.unite(u, v)) {\n                spanningTreeEdgeCosts.push_back(w);\n            }\n        }\n\n        int medianIndex = (spanningTreeEdgeCosts.size() - 1) / 2;\n        cout << spanningTreeEdgeCosts[medianIndex] << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\nfrom itertools import combinations\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal(n, edges):\n    result = []  # This will store the resultant MST\n    i, e = 0, 0  # An index variable, used for sorted edges\n    edges = sorted(edges, key=lambda item: item[2])\n    parent, rank = [], []\n    for node in range(n):\n        parent.append(node)\n        rank.append(0)\n\n    while e < n - 1:\n        u, v, w = edges[i]\n        i += 1\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            e += 1\n            result.append((u, v, w))\n            union(parent, rank, x, y)\n\n    return result\n\ndef median_edge_cost(n, m, edges):\n    edges_subset = []\n    for edges_candidate in combinations(edges, n-1):\n        if is_connected(n, edges_candidate):\n            edges_subset.append(edges_candidate)\n    min_median = float('inf')\n    for edge_set in edges_subset:\n        costs = sorted(edge[2] for edge in edge_set)\n        median_cost = costs[(n - 1) // 2]\n        min_median = min(min_median, median_cost)\n    return min_median\n\ndef is_connected(n, edges):\n    graph = {i: [] for i in range(n)}\n    for u, v, _ in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    dfs(0)\n    return len(visited) == n\n\ndef spanning_tree_median_minimization(graph_datasets):\n    results = []\n    for dataset in graph_datasets:\n        n, m, edges = dataset\n        median = median_edge_cost(n, m, edges)\n        results.append(median)\n    return results\n\ndef parse_input():\n    lines = sys.stdin.read().strip().split('\\n')\n    index = 0\n    datasets = []\n    while index < len(lines):\n        n, m = map(int, lines[index].split())\n        index += 1\n        edges = []\n        for _ in range(m):\n            u, v, w = map(int, lines[index].split())\n            edges.append((u - 1, v - 1, w))\n            index += 1\n        datasets.append((n, m, edges))\n    return datasets\n\ngraph_datasets = parse_input()\nresults = spanning_tree_median_minimization(graph_datasets)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 07:17:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SpanningTreeMedian {\n\n    private static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n\n    private static class UnionFind {\n        private int[] parent;\n\n        UnionFind(int n) {\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                parent[rootX] = rootY;\n            }\n        }\n    }\n\n    private static int findMedianMST(int n, List<Edge> edges) {\n        Collections.sort(edges);\n        int left = 0;\n        int right = edges.size() - n / 2;\n        int median = Integer.MAX_VALUE;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            UnionFind uf = new UnionFind(n);\n\n            List<Edge> mst = new ArrayList<>();\n            for (int i = mid; i < edges.size() && mst.size() < n - 1; i++) {\n                Edge edge = edges.get(i);\n                if (uf.find(edge.u) != uf.find(edge.v)) {\n                    uf.union(edge.u, edge.v);\n                    mst.add(edge);\n                }\n            }\n\n            if (mst.size() == n - 1) {\n                median = Math.min(median, mst.get((n - 1) / 2).cost);\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return median;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt(), m = scanner.nextInt();\n            List<Edge> edges = new ArrayList<>();\n\n            for (int i = 0; i < m; i++) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                int cost = scanner.nextInt();\n                edges.add(new Edge(u, v, cost));\n            }\n\n            System.out.println(findMedianMST(n, edges));\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 07:17:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint compareEdges(const void *a, const void *b) {\n    return ((Edge *)a)->cost - ((Edge *)b)->cost;\n}\n\nint findParent(int *parent, int v) {\n    if (parent[v] != v) {\n        parent[v] = findParent(parent, parent[v]);\n    }\n    return parent[v];\n}\n\nvoid unionSets(int *parent, int *rank, int a, int b) {\n    a = findParent(parent, a);\n    b = findParent(parent, b);\n\n    if (a != b) {\n        if (rank[a] < rank[b]) {\n            parent[a] = b;\n        } else if (rank[a] > rank[b]) {\n            parent[b] = a;\n        } else {\n            parent[b] = a;\n            rank[a]++;\n        }\n    }\n}\n\nint kruskal(Edge *edges, int n, int m, int numNodes) {\n    int parent[numNodes + 1];\n    int rank[numNodes + 1];\n    for (int i = 1; i <= numNodes; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int edgeCount = 0;\n    for (int i = 0; i < m; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int cost = edges[i].cost;\n\n        if (findParent(parent, u) != findParent(parent, v)) {\n            unionSets(parent, rank, u, v);\n            edgeCount++;\n            if (edgeCount == numNodes - 1) {\n                return cost;\n            }\n        }\n    }\n    return edges[m - 1].cost;\n}\n\nint findMinMedian(Edge *edges, int m, int numNodes) {\n    int left = 0;\n    int right = m - 1;\n    int result = edges[m - 1].cost;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        Edge temp[m];\n        int index = 0;\n        for (int i = mid; i < m; i++) {\n            temp[index++] = edges[i];\n        }\n        if (kruskal(temp, index, m - mid, numNodes) <= edges[mid].cost) {\n            result = edges[mid].cost;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        Edge edges[m];\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n        }\n\n        qsort(edges, m, sizeof(Edge), compareEdges);\n        printf(\"%d\\n\", findMinMedian(edges, m, n));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:18:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef find_parent(parent, node):\n    if parent[node] != node:\n        parent[node] = find_parent(parent, parent[node])\n    return parent[node]\n\ndef union(parent, rank, u, v):\n    root_u = find_parent(parent, u)\n    root_v = find_parent(parent, v)\n    \n    if root_u != root_v:\n        if rank[root_u] < rank[root_v]:\n            parent[root_u] = root_v\n        elif rank[root_u] > rank[root_v]:\n            parent[root_v] = root_u\n        else:\n            parent[root_v] = root_u\n            rank[root_u] += 1\n\ndef solve_dataset():\n    n, m = map(int, input().split())\n    edges = []\n    \n    for _ in range(m):\n        u, v, cost = map(int, input().split())\n        edges.append((cost, u-1, v-1))\n    \n    edges.sort()\n    \n    results = []\n    for k in range(m):\n        parent = list(range(n))\n        rank = [0] * n\n        mst_edges = []\n        \n        for i in range(k+1):\n            cost, u, v = edges[i]\n            if find_parent(parent, u) != find_parent(parent, v):\n                union(parent, rank, u, v)\n                mst_edges.append(cost)\n        \n        for i in range(k+1, m):\n            cost, u, v = edges[i]\n            if len(mst_edges) == n - 1:\n                break\n            \n            if find_parent(parent, u) != find_parent(parent, v):\n                union(parent, rank, u, v)\n                mst_edges.append(cost)\n        \n        if len(mst_edges) == n - 1:\n            mid = len(mst_edges) // 2\n            results.append(sorted(mst_edges)[mid])\n    \n    return results\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        results = solve_dataset()\n        print(min(results) if results else 0)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:18:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n    \n    def find(self, x):\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False\n        self.parent[y_root] = x_root\n        return True\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        N = int(input[ptr])\n        M = int(input[ptr+1])\n        ptr +=2\n        edges = []\n        for _ in range(M):\n            u = int(input[ptr]) -1\n            v = int(input[ptr+1]) -1\n            cost = int(input[ptr+2])\n            edges.append((cost, u, v))\n            ptr +=3\n        \n        edges.sort()\n        low = 0\n        high = M -1\n        best_median = float('inf')\n        \n        while low <= high:\n            mid = (low + high) // 2\n            uf = UnionFind(N)\n            selected_edges = []\n            total = 0\n            for i in range(mid, M):\n                cost, u, v = edges[i]\n                if uf.union(u, v):\n                    selected_edges.append(cost)\n                    total +=1\n                    if total == N -1:\n                        break\n            if total == N -1:\n                best_median = min(best_median, edges[mid][0])\n                high = mid -1\n            else:\n                low = mid +1\n        \n        print(best_median)\n\nsolve()",
    "timestamp": "2025-08-13 07:18:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n};\n\n// DSU / Union-Find structure with path compression\nstruct DSU {\n    vector<int> parent, rank;\n\n    DSU(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int rootX = find(x), rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n        return false;\n    }\n};\n\n// Kruskal's algorithm to find MST and its median cost\nint findMedianSpanningTree(int n, vector<Edge>& edges) {\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.cost < b.cost;\n    });\n\n    int m = edges.size();\n    int medianIdx = (n - 1) / 2; // Median index after finding the MST\n    vector<int> possibleMedians;\n\n    for (int i = 0; i + n - 1 <= m; i++) {\n        DSU dsu(n);\n        vector<int> mstCosts;\n        for (int j = i; j < m && mstCosts.size() < n - 1; j++) {\n            if (dsu.unite(edges[j].u, edges[j].v)) {\n                mstCosts.push_back(edges[j].cost);\n            }\n        }\n        if (mstCosts.size() == n - 1) {\n            possibleMedians.push_back(mstCosts[medianIdx]);\n        }\n    }\n\n    return *min_element(possibleMedians.begin(), possibleMedians.end());\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    while (datasets--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<Edge> edges(m);\n        for (int i = 0; i < m; i++) {\n            cin >> edges[i].u >> edges[i].v >> edges[i].cost;\n            edges[i].u--; edges[i].v--; // To make zero-based index\n        }\n\n        int median = findMedianSpanningTree(n, edges);\n        cout << median << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:37:14"
  }
]