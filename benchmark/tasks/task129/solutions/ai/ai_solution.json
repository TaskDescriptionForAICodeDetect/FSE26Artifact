[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nint minCost = INT_MAX;\n\nvoid calculateMinCost(Point* enemies, int enemyCount, int* visited, int cost, int currentX, int currentY) {\n    if (enemyCount == 0) {\n        if (cost < minCost) {\n            minCost = cost;\n        }\n        return;\n    }\n\n    for (int i = 0; i < enemyCount; i++) {\n        if (!visited[i]) {\n            visited[i] = 1;\n            int dx = abs(enemies[i].x - currentX);\n            int dy = abs(enemies[i].y - currentY);\n            int newCost = cost + dx + dy;\n            calculateMinCost(enemies, enemyCount - 1, visited, newCost, enemies[i].x, enemies[i].y);\n            visited[i] = 0;\n        }\n    }\n}\n\nint main() {\n    int W, H, N;\n    scanf(\"%d %d %d\", &W, &H, &N);\n\n    Point* enemies = (Point*)malloc(N * sizeof(Point));\n    int* visited = (int*)calloc(N, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &enemies[i].x, &enemies[i].y);\n    }\n\n    calculateMinCost(enemies, N, visited, 0, 0, 0);\n\n    printf(\"%d\\n\", minCost);\n\n    free(enemies);\n    free(visited);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static int minimumCost(int W, int H, int[] enemyX, int[] enemyY) {\n        Set<Integer> rowsWithEnemies = new HashSet<>();\n        Set<Integer> colsWithEnemies = new HashSet<>();\n        \n        for (int x : enemyX) rowsWithEnemies.add(x);\n        for (int y : enemyY) colsWithEnemies.add(y);\n        \n        int rowsToVisit = W - rowsWithEnemies.size();\n        int colsToVisit = H - colsWithEnemies.size();\n        \n        return rowsToVisit + colsToVisit;\n    }\n    \n    public static void main(String[] args) {\n        int W = 3, H = 3;\n        int[] enemyX = {0, 1};\n        int[] enemyY = {1, 2};\n        \n        System.out.println(minimumCost(W, H, enemyX, enemyY));\n    }\n}",
    "timestamp": "2025-08-05 18:44:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int W, H, N;\n    cin >> W >> H >> N;\n    \n    vector<pair<int, int>> enemies;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        enemies.emplace_back(x, y);\n    }\n    \n    vector<int> rows, cols;\n    for (auto& enemy : enemies) {\n        rows.push_back(enemy.first);\n        cols.push_back(enemy.second);\n    }\n    \n    sort(rows.begin(), rows.end());\n    sort(cols.begin(), cols.end());\n    \n    int median_row = rows[N / 2];\n    int median_col = cols[N / 2];\n    \n    long long cost = 0;\n    for (auto& enemy : enemies) {\n        cost += abs(enemy.first - median_row) + abs(enemy.second - median_col);\n    }\n    \n    cout << cost << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 500\n#define MAX_H 500\n\nint W, H;\nint board[MAX_W][MAX_H];\nint enemies[MAX_W][MAX_H];\nint visited[MAX_W][MAX_H];\nint min_cost = INT_MAX;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y, int current_cost, int remaining_enemies) {\n    if (remaining_enemies == 0) {\n        min_cost = (current_cost < min_cost) ? current_cost : min_cost;\n        return;\n    }\n\n    if (current_cost >= min_cost) return;\n\n    visited[x][y] = 1;\n\n    // Bomb attack (free cost)\n    int temp_enemies = remaining_enemies;\n    int bomb_row_enemies = 0, bomb_col_enemies = 0;\n\n    // Count row enemies\n    for (int j = 0; j < W; j++) {\n        if (enemies[x][j] && !visited[x][j]) {\n            bomb_row_enemies++;\n        }\n    }\n\n    // Count column enemies\n    for (int i = 0; i < H; i++) {\n        if (enemies[i][y] && !visited[i][y]) {\n            bomb_col_enemies++;\n        }\n    }\n\n    if (bomb_row_enemies + bomb_col_enemies > 0) {\n        // Mark enemies in row and column as visited\n        for (int j = 0; j < W; j++) {\n            if (enemies[x][j] && !visited[x][j]) {\n                visited[x][j] = 1;\n                temp_enemies--;\n            }\n        }\n\n        for (int i = 0; i < H; i++) {\n            if (enemies[i][y] && !visited[i][y]) {\n                visited[i][y] = 1;\n                temp_enemies--;\n            }\n        }\n\n        dfs(x, y, current_cost, temp_enemies);\n\n        // Unmark enemies\n        for (int j = 0; j < W; j++) {\n            if (enemies[x][j]) visited[x][j] = 0;\n        }\n\n        for (int i = 0; i < H; i++) {\n            if (enemies[i][y]) visited[i][y] = 0;\n        }\n    }\n\n    // Move to adjacent squares\n    for (int k = 0; k < 4; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n\n        if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n            int move_cost = 1;\n            \n            // Check if there's an enemy at the new position\n            if (enemies[nx][ny] && !visited[nx][ny]) {\n                move_cost = 1;\n                visited[nx][ny] = 1;\n                temp_enemies = remaining_enemies - 1;\n            } else {\n                temp_enemies = remaining_enemies;\n            }\n\n            dfs(nx, ny, current_cost + move_cost, temp_enemies);\n\n            if (enemies[nx][ny]) {\n                visited[nx][ny] = 0;\n            }\n        }\n    }\n\n    visited[x][y] = 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &W, &H);\n\n    int total_enemies = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &enemies[i][j]);\n            if (enemies[i][j]) total_enemies++;\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(0, 0, 0, total_enemies);\n\n    printf(\"%d\\n\", min_cost);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumCost(int W, int H, vector<pair<int, int>>& enemies) {\n        int n = enemies.size();\n        if (n == 0) return 0;\n        \n        vector<int> rows, cols;\n        for (auto& enemy : enemies) {\n            rows.push_back(enemy.first);\n            cols.push_back(enemy.second);\n        }\n        \n        sort(rows.begin(), rows.end());\n        sort(cols.begin(), cols.end());\n        \n        int dp[51][51];\n        memset(dp, 0x3f, sizeof(dp));\n        dp[0][0] = 0;\n        \n        for (int i = 1; i <= rows.size(); i++) {\n            for (int j = 1; j <= cols.size(); j++) {\n                // Move horizontally\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + abs(rows[i-1] - rows[i-1]));\n                \n                // Move vertically\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + abs(cols[j-1] - cols[j-1]));\n                \n                // Bomb row and column\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + abs(rows[i-1]) + abs(cols[j-1]));\n            }\n        }\n        \n        return dp[rows.size()][cols.size()];\n    }\n};\n\nint main() {\n    Solution sol;\n    int W = 5, H = 5;\n    vector<pair<int, int>> enemies = {{1,2}, {3,4}, {2,1}};\n    \n    cout << sol.minimumCost(W, H, enemies) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class DungeonGame {\n    public static int minCostToClear(int W, int H, List<Point> enemies) {\n        if (enemies.isEmpty()) return 0;\n        \n        List<Integer> rows = new ArrayList<>();\n        List<Integer> cols = new ArrayList<>();\n        for (Point enemy : enemies) {\n            rows.add(enemy.y);\n            cols.add(enemy.x);\n        }\n        Collections.sort(rows);\n        Collections.sort(cols);\n        \n        int medianRow = rows.get(rows.size() / 2);\n        int medianCol = cols.get(cols.size() / 2);\n        \n        int cost = 0;\n        for (Point enemy : enemies) {\n            cost += Math.abs(enemy.x - medianCol) + Math.abs(enemy.y - medianRow);\n        }\n        \n        return cost;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int W = scanner.nextInt();\n        int H = scanner.nextInt();\n        int N = scanner.nextInt();\n        List<Point> enemies = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            enemies.add(new Point(x, y));\n        }\n        System.out.println(minCostToClear(W, H, enemies));\n    }\n}",
    "timestamp": "2025-08-05 18:45:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_cost_to_clear_board(W, H, enemies, move_cost):\n    # Directions for moving (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # BFS state: (current x, current y, cost so far)\n    queue = deque([(0, 0, 0)])\n    visited = set((0, 0))\n    enemy_set = set(enemies)\n    \n    min_cost = float('inf')\n    \n    while queue:\n        x, y, cost = queue.popleft()\n        \n        if cost >= min_cost:\n            continue\n        \n        # Bomb all enemies in the same row and column\n        if (x, y) in enemy_set:\n            current_cost = cost\n            row_enemies = sum((x, ey) in enemy_set for ey in range(H))\n            col_enemies = sum((ex, y) in enemy_set for ex in range(W))\n            \n            if row_enemies > 0 or col_enemies > 0:\n                current_cost += 0  # No cost for bombing\n                enemy_set -= {(x, ey) for ey in range(H)}\n                enemy_set -= {(ex, y) for ex in range(W)}\n            \n            if not enemy_set:\n                min_cost = min(min_cost, current_cost)\n        \n        # Move in 4 possible directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < W and 0 <= ny < H and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, cost + move_cost))\n    \n    return min_cost\n\n# Example usage:\nW, H = 3, 3\nenemies = [(0, 1), (1, 2), (2, 1)]\nmove_cost = 1\n\nprint(min_cost_to_clear_board(W, H, enemies, move_cost))  # Output: Minimum cost",
    "timestamp": "2025-08-13 00:46:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DungeonGame {\n    static class State {\n        int x, y, cost;\n\n        State(int x, int y, int cost) {\n            this.x = x;\n            this.y = y;\n            this.cost = cost;\n        }\n    }\n\n    public int minimumCost(int W, int H, boolean[][] enemies) {\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        boolean[][] visited = new boolean[W][H];\n\n        Queue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.cost));\n        pq.offer(new State(0, 0, 0));\n\n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n\n            if (visited[current.x][current.y]) continue;\n            visited[current.x][current.y] = true;\n\n            if (allEnemiesCleared(enemies)) return current.cost;\n\n            for (int[] direction : directions) {\n                int nx = current.x + direction[0];\n                int ny = current.y + direction[1];\n\n                if (nx >= 0 && ny >= 0 && nx < W && ny < H) {\n                    pq.offer(new State(nx, ny, current.cost + 1));\n                }\n            }\n\n            if (enemies[current.x][current.y]) {\n                clearEnemies(current.x, current.y, enemies);\n                pq.offer(new State(current.x, current.y, current.cost));\n            }\n        }\n\n        return Integer.MAX_VALUE;\n    }\n\n    private boolean allEnemiesCleared(boolean[][] enemies) {\n        for (boolean[] row : enemies) {\n            for (boolean cell : row) {\n                if (cell) return false;\n            }\n        }\n        return true;\n    }\n\n    private void clearEnemies(int x, int y, boolean[][] enemies) {\n        Arrays.fill(enemies[x], false);\n        for (int i = 0; i < enemies.length; i++) {\n            enemies[i][y] = false;\n        }\n    }\n\n    public static void main(String[] args) {\n        DungeonGame game = new DungeonGame();\n        boolean[][] enemies = {\n            {false, true, false},\n            {true, false, false},\n            {false, false, true}\n        };\n        int result = game.minimumCost(3, 3, enemies);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 00:46:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAX_W 100\n#define MAX_H 100\n\nint board[MAX_W][MAX_H];\nint cost[MAX_W][MAX_H];\nint W, H;\n\n// Directions for BomBom's movement\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\n// Function to check if a position is within board bounds\nint is_valid(int x, int y) {\n    return (x >= 0 && x < W && y >= 0 && y < H);\n}\n\n// Function to determine minimum cost using a bomb\nint minimum_bomb_cost(int x, int y) {\n    int min_cost = INT_MAX;\n    int nx, ny;\n\n    for (int i = 0; i < 4; ++i) {\n        nx = x + dx[i];\n        ny = y + dy[i];\n        if (is_valid(nx, ny)) {\n            min_cost = board[nx][ny] < min_cost ? board[nx][ny] : min_cost;\n        }\n    }\n\n    return min_cost;\n}\n\n// Function to calculate the minimum cost to clear the dungeon\nint calculate_min_cost() {\n    cost[0][0] = 0; // Starting point\n\n    for (int x = 0; x < W; ++x) {\n        for (int y = 0; y < H; ++y) {\n            cost[x][y] = INT_MAX;\n\n            for (int i = 0; i < 4; ++i) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (is_valid(nx, ny) && cost[nx][ny] != INT_MAX) {\n                    cost[x][y] = cost[nx][ny] + 1 < cost[x][y] ? cost[nx][ny] + 1 : cost[x][y];\n                }\n            }\n\n            // Using a bomb\n            int bomb_cost = minimum_bomb_cost(x, y);\n            if (bomb_cost != INT_MAX) {\n                cost[x][y] = bomb_cost < cost[x][y] ? bomb_cost : cost[x][y];\n            }\n        }\n    }\n\n    int min_cost = INT_MAX;\n    for (int x = 0; x < W; ++x) {\n        for (int y = 0; y < H; ++y) {\n            if (board[x][y] == 1) { // Enemy present\n                min_cost = cost[x][y] < min_cost ? cost[x][y] : min_cost;\n            }\n        }\n    }\n\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d %d\", &W, &H);\n    int enemies;\n    scanf(\"%d\", &enemies);\n\n    for (int i = 0; i < W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            board[i][j] = 0; // Initialize board with no enemies\n        }\n    }\n\n    for (int i = 0; i < enemies; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        board[x][y] = 1; // Place enemy\n    }\n\n    int min_cost = calculate_min_cost();\n    printf(\"%d\\n\", min_cost);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:46:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List\nimport heapq\n\ndef min_cost_to_clear_board(W: int, H: int, enemies: List[List[int]]) -> int:\n    # Create a set of enemy positions for quick lookup\n    enemy_set = set((x, y) for x, y in enemies)\n    \n    # If no enemies, return 0\n    if not enemy_set:\n        return 0\n    \n    # Priority queue for Dijkstra's algorithm\n    pq = [(0, 0, 0, enemy_set)]\n    visited = set()\n    \n    while pq:\n        cost, x, y, remaining_enemies = heapq.heappop(pq)\n        \n        # State key to avoid revisiting same state\n        state_key = (x, y, frozenset(remaining_enemies))\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n        \n        # Check if all enemies cleared\n        if not remaining_enemies:\n            return cost\n        \n        # Try bombing current position\n        bomb_enemies = {(ex, ey) for (ex, ey) in remaining_enemies \n                        if ex == x or ey == y}\n        new_remaining_enemies = remaining_enemies - bomb_enemies\n        \n        heapq.heappush(pq, (cost, x, y, new_remaining_enemies))\n        \n        # Try moving in 4 directions\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < W and 0 <= ny < H:\n                heapq.heappush(pq, (cost + 1, nx, ny, remaining_enemies))\n    \n    return -1  # Impossible to clear board",
    "timestamp": "2025-08-13 00:47:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_cost_to_clear(W, H, enemies):\n    if not enemies:\n        return 0\n    \n    # Collect unique rows and columns\n    rows = set()\n    cols = set()\n    for x, y in enemies:\n        rows.add(x)\n        cols.add(y)\n    rows = sorted(rows)\n    cols = sorted(cols)\n    \n    # Manhattan distance between two points\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    # Priority queue: (current_cost, current_position, remaining_rows, remaining_cols)\n    # Using bitmask to represent remaining rows and cols\n    initial_remaining_rows = (1 << len(rows)) - 1\n    initial_remaining_cols = (1 << len(cols)) - 1\n    heap = []\n    heapq.heappush(heap, (0, (0, 0), initial_remaining_rows, initial_remaining_cols))\n    \n    visited = {}\n    \n    while heap:\n        cost, pos, rem_rows, rem_cols = heapq.heappop(heap)\n        if rem_rows == 0 and rem_cols == 0:\n            return cost\n        \n        key = (pos, rem_rows, rem_cols)\n        if key in visited and visited[key] <= cost:\n            continue\n        visited[key] = cost\n        \n        x, y = pos\n        \n        # Option 1: Move to any row or column and bomb it\n        for i in range(len(rows)):\n            if rem_rows & (1 << i):\n                new_pos = (rows[i], y)\n                new_cost = cost + distance(pos, new_pos)\n                new_rem_rows = rem_rows & ~(1 << i)\n                heapq.heappush(heap, (new_cost, new_pos, new_rem_rows, rem_cols))\n        \n        for j in range(len(cols)):\n            if rem_cols & (1 << j):\n                new_pos = (x, cols[j])\n                new_cost = cost + distance(pos, new_pos)\n                new_rem_cols = rem_cols & ~(1 << j)\n                heapq.heappush(heap, (new_cost, new_pos, rem_rows, new_rem_cols))\n    \n    return 0",
    "timestamp": "2025-08-13 00:47:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Position {\n    int x, y, cost;\n};\n\nbool isValid(int x, int y, int W, int H) {\n    return x >= 0 && x < W && y >= 0 && y < H;\n}\n\nint minCostToClearBoard(int W, int H, const vector<vector<int>>& enemies) {\n    vector<vector<int>> cost(W, vector<int>(H, INT_MAX));\n    queue<Position> q;\n    q.push({0, 0, 0});\n    cost[0][0] = 0;\n\n    while (!q.empty()) {\n        auto [x, y, c] = q.front();\n        q.pop();\n\n        if (cost[x][y] < c) continue;\n\n        bool hasEnemy = enemies[x][y] == 1;\n        if (hasEnemy) {\n            for (int i = 0; i < W; ++i) {\n                if (cost[i][y] > c) {\n                    cost[i][y] = c;\n                    q.push({i, y, c});\n                }\n            }\n            for (int j = 0; j < H; ++j) {\n                if (cost[x][j] > c) {\n                    cost[x][j] = c;\n                    q.push({x, j, c});\n                }\n            }\n        }\n\n        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        for (auto [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (isValid(nx, ny, W, H) && cost[nx][ny] > c + 1) {\n                cost[nx][ny] = c + 1;\n                q.push({nx, ny, c + 1});\n            }\n        }\n    }\n\n    int minCost = INT_MAX;\n    for (int i = 0; i < W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            if (enemies[i][j] == 1) {\n                minCost = min(minCost, cost[i][j]);\n            }\n        }\n    }\n\n    return minCost;\n}\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<vector<int>> enemies(W, vector<int>(H));\n    for (int i = 0; i < W; ++i) {\n        for (int j = 0; j < H; ++j) {\n            cin >> enemies[i][j];\n        }\n    }\n    \n    int result = minCostToClearBoard(W, H, enemies);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:55:55"
  }
]