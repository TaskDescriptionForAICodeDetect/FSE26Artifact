[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\npriority_queue<P> q;\nsigned main(){\n\tint w, h, n;\n\tscanf(\"%lld%lld%lld\",&w, &h, &n);\n\trep(i,n){\n\t\tint x, y;\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tq.push(P(y, x));\n\t}\n\t\n\tint ans = INF;\n\trep(i,w){\n\t\tP p = P(-1, -1);\n\t\twhile(!q.empty()){\n\t\t\tP t = q.top();\n\t\t\tif(t.se <= i){q.pop();continue;}\n\t\t\tp = t;break;\n\t\t}\n\t\tif(p.fi == -1)chmin(ans, i);\n\t\telse chmin(ans, i+p.fi);\n\t\t//printf(\"%lld\\n\", p.fi);\n\t}\n\tif(ans == INF)ans = 0;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int MAX_HW = 101010;\nconst int INF = 1001001001;\n\nll maxY[MAX_HW], maxX[MAX_HW];\n\nint main() {\n    ll w, h, n;\n    cin >> w >> h >> n;\n    ll x, y;\n    for (int i = 0; i < n; i++) {\n        cin >> x >> y;\n        maxY[x] = max(maxY[x], y);\n        maxX[y] = max(maxX[y], x);\n    }\n    for (int i = w - 2; i >= 0; i--) {\n        maxY[i] = max(maxY[i], maxY[i + 1]);\n    }\n    for (int i = h - 2; i >= 0; i--) {\n        maxX[i] = max(maxX[i], maxX[i + 1]);\n    }\n    ll ans = INF;\n    for (ll y = 0; y < h; y++) {\n        ans = min(ans, y + maxX[y + 1]);\n    }\n    for (ll x = 0; x < w; x++) {\n        ans = min(ans, x + maxY[x + 1]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P>v;\nint n,q,w,h,x,y,ans=1e9;\nint data[200000*2];\nvoid Segtree(){\n    int tmp=1;\n    while(tmp<n)tmp*=2;\n    n=tmp;\n}\nvoid update(int k,int x){\n    k+=n-1;\n    data[k]=x;\n    while(k>0){\n        k=(k-1)/2;\n        data[k]=max(data[k*2+1],data[k*2+2]);\n    }\n}\nint find(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    if(a<=l && r<=b)return data[k];\n    int v1=find(a,b,k*2+1,l,(l+r)/2);\n    int v2=find(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,v2);\n}\nmain(){\n    cin>>w>>h>>n;\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&x,&y);\n        v.push_back(P(x,y));\n    }\n    Segtree();\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size();i++)\n        update(i,v[i].second);\n    for(int i=0;i<v.size();i++){\n        while(i!=v.size()-1&&v[i].first==v[i+1].first)i++;\n        if(i==v.size()-1)ans=min(ans,v[i].first);\n        else ans=min(ans,v[i].first+find(i+1,v.size(),0,0,n));\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint xmax[100005];\nint main(){\n  int w, h, n;\n  cin >> w >> h >> n;\n  fill(xmax, xmax+h+1, 0);\n  for(int i=0; i<n; i++) {\u000b    int x, y;\n    cin >> x >> y;\n    xmax[y]=max(xmax[y], x);\n  }\n  for(int i=h-2; i>=0; i--){\n    xmax[i]=max(xmax[i], xmax[i+1]);\n  }\n  int ans=1234567890;\n  for(int i=0; i<h; i++){\n    ans=min(ans, i+xmax[i+1]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<unordered_set>\nusing namespace std;\n/*int p = 998244353;*/\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<int,pin>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define rev(s) reverse(s.begin(),s.end())\nsigned main(){\n\tint w, h, n; cin >> w >> h >> n;\n\tif (h == 1 || w == 1) { cout << 0 << endl; return 0; }\n\tvvel pot(w);\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y;\n\t\tpot[x].push_back(y);\n\t}\n\tint ans = w-1;\n\tvel maxi(w,0); maxi[w - 1] = 0;\n\tfor (int i = w - 2; i >= 0; i--) {\n\t\tmaxi[i] = maxi[i + 1];\n\t\tfor (auto x : pot[i + 1]) {\n\t\t\tmmax(maxi[i], x);\n\t\t}\n\t\tmmin(ans, maxi[i] + i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint wh[10001][10001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint num=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; cin >> x >> y; wh[x][y]++;if(x==0||y==0)num++;\n\t\twh[w][y] = max(wh[w][y], x);\n\t}\n\tif(num==n){cout<<0<<endl;return 0;}\n\n\tint x_position, y_position, MIN;\n    MIN = wh[w][h - 1] + (h - 1); x_position = wh[w][h - 1]; y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[w][b]) {\n\t\t\tx_position = wh[w][y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << MIN << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n    int w,h,n;cin>>w>>h>>n;\n    int mix=0;int miy=0;int ma=0;int may=0;\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        ma=max(ma,x);\n        may=max(may,y);\n        if(x<y){\n            mix=max(mix,x);\n        }else{\n            miy=max(miy,y);\n        }\n    }\n    cout<<min(ma,min(may,mix+miy))<<endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nint W, H, N;\npii p[112345];\nint dp[112345];\n\nint main() {\n\tcin >> W >> H >> N;\n\tREP(i, N) scanf(\"%d %d\", &p[i].fi, &p[i].se);\n\tREP(i, N) p[i].se = -p[i].se;\n\t\n\tsort(p, p + N);\n\t\n\tfor (int i = N - 2; i >= 0; i--) chmax(dp[i], max(dp[i + 1], -p[i + 1].se));\n\t\n\tint ans = INF;\n\tREP(i, N) chmin(ans, p[i].fi + dp[i]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n    int W=0;\n    int H=0;\n    int N=0;\n    \n    int X[100001];\n    int Y[100001];\n    int YMAX=0;\n    int danMAX[100001];\n    int ALLMAX[100001];\n    int ans=0;\n    \n    int i=0;\n    int c=0;\n    int d=0;\n    int j=0;\n    \n    cin>>W>>H>>N;\n    \n    for(i=0;i<N;i++){\n        cin>>X[i]>>Y[i];\n        if(danMAX[Y[i]]==0 || danMAX[Y[i]]<X[i]){\n            danMAX[Y[i]]=X[i];\n        }\n        if(YMAX<Y[i]){\n            YMAX=Y[i];\n        }\n    }\n    \n    ALLMAX[YMAX]=danMAX[YMAX];\n    ans=YMAX;\n    //cout<<ans<<endl;\n    \n    for(i=1;i<YMAX+1;i++){//一番下はすでに入力済み\n        if(danMAX[YMAX-i]>=ALLMAX[YMAX-i+1]){\n            ALLMAX[YMAX-i]=danMAX[YMAX-i];\n        }else{\n            ALLMAX[YMAX-i]=ALLMAX[YMAX-i+1];\n        }\n        //cout<<ALLMAX[YMAX-i]<<endl;\n    }\n    //cout<<ALLMAX[0]<<endl;\n    \n    for(i=0;i<YMAX+1;i++){\n        if(i+ALLMAX[i+1]<ans){\n            ans=ALLMAX[i+1]+i;\n        }\n    }\n    \n    //YMAX-i\n    cout<<ans<<endl;\n    \n    \n    \n    \n    \n    \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\nP pp[100001];\nint main(void)\n{\n\tint w,h,n,i,j,mn;\n\tpriority_queue<int> qu;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++)\t{\n\t\tscanf(\"%d %d\",&pp[i].first,&pp[i].second);\n\t}\n\tpp[n].first=0;\tpp[n].second=0;\n\tsort(pp,pp+n+1);\n\tmn=pp[n].first;\n\tfor(i=n-1;i>=0;i--)\t{\n\t\tqu.push(pp[i+1].second);\n\t\tmn=min(mn,pp[i].first+qu.top());\n\t}\n\tprintf(\"%d\\n\",mn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint w,h,n;\n\tcin>>w>>h>>n;\n\tpair<int,int> bug[n];\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbug[i].first=a; bug[i].second=b;\n\t}\n\tsort(bug,bug+n);\n//\tfor(int i=0;i<n;i++) cout<<bug[i].first<<' '<<bug[i].second<<endl;\n\tint mx=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(bug[i+1].first!=bug[i].first&&bug[i].first!=0&&bug[i].second!=0)\n\t\t\tmx=max(mx,bug[i+1].second);\n\t}\n\tcout<<mx+bug[0].first<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint main(){\n\tint w,h,n;\n\tcin >> w >> h >> n;\n\tstd::vector<int> py(n);\n\tstd::vector<int> px(n);\n\tstd::vector<pair<int,int>> x(n);\n\tstd::vector<pair<int,int>> y(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> px[i] >> py[i];\n\n\t\tx[i]=std::make_pair(px[i], i);\n\t\ty[i]=std::make_pair(py[i], i);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\n\tvector<int> rmax(n+1,0);\n\tfor(int i = n - 1; i != -1; --i){\n\t\trmax[i] = max(rmax[i+1], py[x[i].second]);\n\t}\n\n\tint val = y[n-1].first;\n\tfor(int i = 0; i < n; ++i){\n\t\tval = min(val, rmax[i + 1] + x[i].first);\n\t}\n\tcout << val << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint main(){\n\n\tint W,H,N;\n\tscanf(\"%d %d %d\",&W,&H,&N);\n\n\tint max_y[W];\n\tfor(int i = 0; i < W; i++)max_y[i] = 0;\n\n\tint x,y;\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tmax_y[x] = max(max_y[x],y);\n\t}\n\n\tint ans = W-1;\n\tint to_right_max_y = 0;\n\tfor(int i = W-2; i >= 0; i--){\n\t\tto_right_max_y = max(to_right_max_y,max_y[i+1]);\n\t\tans = min(ans,i+to_right_max_y);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[100001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[y] = max(wh[y], x);\n\t\tat_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[h - 1] + (h - 1);\n    x_position = wh[h - 1];\n    y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[b]) {\n\t\t\tx_position = wh[y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << MIN << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\ntemplate<typename T, T INF>\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\n private:\n  inline int left_child(int node) const {return node << 1;}\n  inline int right_child(int node) const {return (node << 1) + 1;}\n  inline T merge(T vl, T vr) const {return std::max(vl, vr);}\n  inline void propagate(int k) {\n    if(k < size_) {\n      lazy_.at(left_child(k)) += lazy_.at(k);\n      lazy_.at(right_child(k)) += lazy_.at(k);\n    }\n    node_.at(k) += lazy_.at(k);\n    lazy_.at(k) = 0;\n  }\n  T find(int a, int b, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return -INF;\n    if(a <= l && r <= b) return node_.at(k) + lazy_.at(k);\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return merge(vl, vr);\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return node_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (lazy_.at(k) += value);\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = merge(vl, vr);\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  const int INF = 1e6;\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  SegmentTree<int, INF> T(INF);\n  for(auto i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y;\n    T.add(x,x,y);\n  }\n\n  int res = INF;\n\n  for(auto x = 0; x < INF; ++x) {\n    res = min(res, x + T.find(x + 1, INF));\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"set\"\n#include \"stack\"\n \n#define lp(n) for (int i = 0; i < n; i++)\n#define LP(n,i) for (int i = 0; i < n; i++)\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n \nint w, h, n, a[100000], mem, m, x, y;\nvector<pair<int, int> >xy;\n \nint main() {\n    cin >> w >> h >> n;\n    lp(n) {\n        cin >> x >> y;\n        xy.push_back(mkp(x, y));\n    }\n    sort(xy.begin(), xy.end());\n    m = n - 1;\n    mem = 0;\n    for (int i = w-1; i != -1; i--) {\n        a[i] = mem;\n        while (m!=-1&&xy[m].first == i) {\n            mem = max(mem, xy[m].second);\n            m--;\n        }\n    }\n    mem = intmax;\n    lp(w)\n        mem = min(mem, a[i] + i);\n    cout << mem << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[100000],eney[100000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100001,flag=0;\n    int smaller=min(W-1,H-1);\n    for(int j=H-1;j>=0;j--){\n        for(int i=W-1;i>=0;i--){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    //cout<<sum<<i<<j;return(0);\n    \t\t\t    flag=1;\n    \t\t\t    if(i==W-1||j==0){\n    \t\t\t        i=0,j=0;\n    \t\t\t        break;\n    \t\t\t    }\n    \t\t\t    i=W;\n    \t\t\t    j--;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(flag==0){\n        \t\tif(i==0||j==0){\n        \t\t    if(sum>=i+j-1)sum=i+j-1;\n        \t\t}else{\n        \t\t    if(sum>=i+j-2)sum=i+j-2;\n        \t\t}\n    \t\t}\n    \t}\n    }\n    if(sum>smaller)sum=smaller;\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nstruct point\n{\n\tLL x, y;\n\tpoint(LL xx, LL yy) :x(xx), y(yy)\n\t{}\n};\nLL W, H, N;\nvector<point>xsort;//x??????????????????????????????\nvector<point>ysort;//y??????????????????????????????\n\n\t\t\t\t   //?????????P??????s\nbool cond(LL P)\n{\n\tpoint now(P, 0);\n\tLL seive = 0;\n\tfor (point teki : xsort)\n\t{\n\t\tif (teki.x <= now.x || teki.y <= now.y)\n\t\t{\n\t\t\t++seive;\n\t\t}\n\t}\n\tif (seive == N)\n\t{\n\t\treturn true;\n\t}\n\tfor (int k = 0; k < P; ++k)\n\t{\n\t\tnow.x--;\n\t\tnow.y++;\n\t\tauto plussleft = lower_bound(ysort.begin(), ysort.end(), point(1145148101919, now.y), [](const point&p1, const point&p2)\n\t\t{\n\t\t\tif (p1.y == p2.y)return p1.x < p2.x; return p1.y < p2.y;\n\t\t});\n\t\tauto plussright = lower_bound(ysort.begin(), ysort.end(), point(now.x + 2, now.y), [](const point&p1, const point&p2)\n\t\t{\n\t\t\tif (p1.y == p2.y)return p1.x < p2.x; return p1.y < p2.y;\n\t\t});\n\t\tint pluss = plussleft - plussright;\n\t\tint minus = lower_bound(xsort.begin(), xsort.end(), point(now.x + 1, 1145148101919), [](const point&p1, const point&p2)\n\t\t{\n\t\t\tif (p1.x == p2.x)return p1.y < p2.y; return p1.x < p2.x;\n\t\t})\n\t\t\t- lower_bound(xsort.begin(), xsort.end(), point(now.x + 1, now.y + 1), [](const point&p1, const point&p2)\n\t\t{\n\t\t\tif (p1.x == p2.x)return p1.y < p2.y; return p1.x < p2.x;\n\t\t});\n\t\tseive += pluss;\n\t\tseive -= minus;\n\t\tif (seive == N)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\tcin >> W >> H >> N;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\txsort.push_back({ x,y });\n\t\tysort.push_back({ x,y });\n\t}\n\tsort(xsort.begin(), xsort.end(), [](const point&p1, const point&p2)\n\t{\n\t\tif (p1.x == p2.x)return p1.y < p2.y; return p1.x < p2.x;\n\t});\n\tsort(ysort.begin(), ysort.end(), [](const point&p1, const point&p2)\n\t{\n\t\tif (p1.y == p2.y)return p1.x < p2.x; return p1.y < p2.y;\n\t});\n\tint lo = 0, hi = W + H + 1;\n\tif (cond(0))\n\t{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\twhile (lo + 1 < hi)\n\t{\n\t\tint mid = (lo + hi) / 2;\n\t\tif (cond(mid))\n\t\t{\n\t\t\thi = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo = mid;\n\t\t}\n\t}\n\tcout << hi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0364>\n?????????============================================================\n ??¢??????????°???????????????????????????§????????§????????§?????????\n ???????????????W??H ?????????????????¶??????????????????????????¢????????¢?????§???????????????\n ????????????????????¨?????????????????????????????????????????¨??????????????????????????????????????????\n ????????????x???????????????y ????????????(x, y)??§??¨????????????\n ??????????????????(0, 0)?????????????????????(W-1, H-1)??§?????????\n \n ??¢???????????£????????????????????????????????????????????????????????????????????¢???????????????\n ?????????????????????????????????????????°???????????????0, 0???????????????\n ?????¢??????????????¨????????????????????¨?????????????????¢??¨?????????\n ?????????????????¨??????????????????????????????????????\\??????????¨????????????????????????§?????¨????????¨?????§?????????\n \n ???????????????????????????????????????????????????????????¢?????????????????????????????????\n ??????????????¨?????????????????????????????¨??????????????????????????????????????¨?????????????????????????????????????????????????????????\n ??????????????????1 ?????????????????????????????????????¶?????????????\n ??????????????¨?????°?????¶?????????????????????????????¨????????????????????????????????????\n ??????????????????????????????????????±????????????????????¨?????????????????????????????????????§???????????????¨?????§?????????\n \n ?????¢?????§????????¨???????????±????????????????????¨??????????????????????????¨???????????????????????????????°????????????????????????????????????°????????????????????????\n=================================================================\n\n?§£??¬=============================================================\n\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int W,H,N; cin >> W >> H >> N;\n    vector<int> X(W);\n    for(int i = 0; i < N;i++){\n        int x,y; cin >> x>>y;\n        X[x] = max(X[x],y);\n    }\n    int res = INF;\n    int tmp = 0;\n    for(int i = W-1; i>=0;i--){\n        res = min(res,i + tmp);\n        tmp = max(tmp,X[i]);\n    }\n    cout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stdio.h>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <math.h>\n#include <iomanip>\nusing namespace std;\n#define Would\n#define you\nconst int INF = 999999999;\nconst int MOD = 1e9 + 7;\nconst double pi = 3.141592653589793238;\n\nint a, b, c, mon[100005], ans = INF;\nint main() {\n\tcin >> a >> b >> c;\n\tfor (int i = 0; i < c; ++i) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tmon[n] = max(mon[n], m);\n\t}\n\tfor (int i = 0; i < a; ++i) { mon[a - i - 1] = max(mon[a - i - 1], mon[a - i]); }\n\tfor (int i = 0; i < a; ++i) { ans = min(ans, mon[i + 1] + i); }\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n\n  int a = 0, b = 0, c = 0;\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n\n    if (x == y) {\n      c = max(c, x);\n      continue;\n    }\n\n    if (x < y) y = 0;\n    else x = 0;\n\n    a = max(a, x);\n    b = max(b, y);\n  }\n\n  if (a < b) swap(a, b);\n  if (a < c) a = c;\n\n  cout << a + b << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint w, h, n;\nint buttom[100000];\n\nint main()\n{\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tbuttom[x] = max(buttom[x], y);\n\t}\n\n\tint ans = 9999999;\n\tint b = 0;\n\tfor (int i = w - 1; i >= 0; i--)\n\t{\n\t\tans = min(ans, i + b);\n\t\tb = max(b, buttom[i]);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n    int w,h,n;cin>>w>>h>>n;\n    int mx=0;int my=0;int mm=0;\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        if(x<y){\n            mx=max(mx,x);\n        }else if(x>y){\n            my=max(my,y);\n        }else{\n            mm=max(mm,x);\n        }\n    }\n    int ans=mx+my;\n    if(max(mx,my)<mm){\n        ans+=mm-max(mx,my);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while ( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, INF);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if ( a >= r || b <= l ) return INF;\n    if ( a <= l && r <= b ) return tree[k];\n    return min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while ( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = min(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\n\nsigned main() {\n  int W, H, N;\n  //SegT t1(100001), t2(100001);\n  int Y[100001] = {0}, X[100001] = {0};\n  int mY[100001] = {0}, mX[100001] = {0};\n  \n  cin >> W >> H >> N;\n  Rep(i, N) {\n    int x, y;\n    cin >> x >> y;\n    Y[y] = max(Y[y], x);\n    X[x] = max(X[x], y);\n  }\n\n  mX[W-1] = X[W-1];\n  for ( int i = W-2; i >= 0; i-- ) {\n    mX[i] = max(mX[i+1], X[i]);\n  }\n\n  mY[H-1] = Y[H-1];\n  for ( int i = H-2; i >= 0; i-- ) {\n    mY[i] = max(mY[i+1], Y[i]);\n  }\n\n  /* Rep(i, H) {\n    t2.update(i, -X[i]);\n  }\n  */\n  int ans = min(W-1, H-1);\n  Rep(i, W-1) {\n    // ans = min(ans, i + -t1.rmq(i+1, W));\n    ans = min(ans, i + mX[i+1]);\n  }\n\n  Rep(i, H-1) {\n    //ans = min(ans, i + -t2.rmq(i+1, H));\n    ans = min(ans, i + mY[i+1]);\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 100000000000000\ntypedef pair<int, int> P;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\n\nint w, h, k;\n\nint mw[100005] = { 0 };\nint dp[100005] = { 0 };\nint res = INF;\n\nint main() {\n\tcin >> w >> h >> k;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tmw[x] = max(mw[x], y);\n\t}\n\tfor (int i = w - 2; i >= 0; i--) {\n\t\t//out(mw[i]);\n\t\tdp[i] = max(dp[i + 1], mw[i + 1]);\n\t\t//out(dp[i]);\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tres = min(res, i + dp[i]);\n\t}\n\tout(res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nint W, H, N;\npii p[112345];\nint dp[112345];\n\nint main() {\n\tcin >> W >> H >> N;\n\tREP(i, N) scanf(\"%d %d\", &p[i].fi, &p[i].se);\n\tsort(p, p + N);\n\t\n\tfor (int i = N - 2; i >= 0; i--) chmax(dp[i], max(dp[i + 1], p[i + 1].se));\n\t\n\tint ans = max(p[0].se, dp[0]);\n\tREP(i, N) chmin(ans, p[i].fi + dp[i]);\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,w,i,j,a[100000],b[100000],h,y[100000];\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t}\n\tm=10000000;\n\tfor(i=0;i<w;i++) y[i]=0;\n\tfor(i=0;i<n;i++) if(y[a[i]-1]<b[i]) y[a[i]-1]=b[i];\n\t//for(i=0;i<w;i++) printf(\"AA%d\\n\",y[i]);\n\tfor(i=w-2;i>=0;i--) if(y[i]<y[i+1]) y[i]=y[i+1];\n\tfor(i=0;i<w-1;i++){\n\t\tif(i+y[i]<m) m=i+y[i];\n\t}\n\t//for(i=0;i<w;i++) printf(\"BB%d\\n\",y[i]);\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <algorithm>\n\n\nint main(){\n  int W,H,N;\n  cin >> W >> H >> N;\n  int* x = new int[N];\n  int* y = new int[N];\n  int* wenemy = new int[W+1];\n  int* hmm = new int [W+1];\n \n  for(int i = 0; i <= W; i++){\n    wenemy[i] = 0;\n  }\n  for(int i = 0 ; i < N; i++){\n    cin >> x[i];\n    cin >> y[i];\n    if(wenemy[x[i]] < y[i])  wenemy[x[i]] = y[i]; \n  }\n  int current = 0;\n  \n  for(int i = W; i >= 0; i--){\n    hmm[i] = current;\n    if(current < wenemy[i])current = wenemy[i];\n  }\n  int minpppp = 2000000;\n  for(int i = 0; i <= W;i++){\n    minpppp = min(minpppp,hmm[i]+i);\n  }\n  cout << minpppp << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100000,flag=0;\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tint n,a,b;\n\tscanf(\"%d%d%d\",&n,&n,&n);\n\tvector<pair<int,int> >v;\n\tmultiset<int>se;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tv.push_back(make_pair(a,b));\n\t\tse.insert(b);\n\t}\n\tsort(v.begin(),v.end());\n\tint r=min(v.rbegin()->first,*se.rbegin());\n\tfor(int i=0;i<n-1;i++){\n\t\tse.erase(se.find(v[i].second));\n\t\tr=min(r,v[i].first+*se.rbegin());\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint w,h,n;\nint d[100001]={};\n\nint main() {\n\tcin>>w>>h>>n;\n\tint x,y;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x>>y;\n\t\td[x]=max(d[x],y);\n\t}\n\tint total=h+w-2;\n\tint m=0;\n\tfor(int i=w-1;i>0;--i){\n\t\tm=max(m,d[i]);\n\t\ttotal=min(total,i-1+m);\n\t}\n\n\tcout<<total<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <cmath>\n#include <set>\n#include<list>\n#include <map>\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define REP(i, m, n) for(int i = m; i < n; i++)\n#define ALL(v) v.begin(),v.end()\n#define RALL(v) v.rbegin(),v.rend()\n#define check(v) rep(i,v.size()) cout << v[i] << \" \";\\\ncout << endl\n#define INF 1e9\n#define pii pair<int, int>\ntypedef long long ll;\nusing namespace std;\n\nint main() {\n    int w, h, n;\n    cin >> w >> h >> n;\n    set<pii> xlist;\n    set<pii> ylist;\n\n    rep(i, n){\n        int t, s;\n        cin >> t >> s;\n        xlist.insert(pii(t, s));\n        ylist.insert(pii(s, t));\n    }\n\n    int x, y;\n    x = 0;\n    y = 0;\n    int ans = 0;\n    while(true){\n        auto xp = xlist.begin();\n        while((*xp).first == x){\n            ylist.erase(pii((*xp).second, x));\n            xp = xlist.erase(xp);\n            if(xlist.empty()){\n                break;\n            }\n        }\n\n        if(ylist.empty()){\n            break;\n        }\n\n        auto yp = ylist.begin();\n        while((*yp).first == y){\n            xlist.erase(pii((*yp).second, y));\n            yp = ylist.erase(yp);\n            if(ylist.empty()){\n                break;\n            }\n        }\n\n        if(xlist.empty()){\n            break;\n        }else{\n            ++ans;\n\n            if((*xlist.rbegin()).first - x > (*ylist.rbegin()).first - y){\n                ++y;\n            }else{\n                ++x;\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<int> v(w);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        v[x] = max(v[x], y);\n    }\n    for (int i = w - 1; i > 0; i--) v[i - 1] = max(v[i - 1], v[i]);\n\n    int ret = min(w - 1, h - 1);\n    for (int i = 0; i < w - 1; i++) ret = min(ret, i + v[i + 1]);\n\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define H_MAX 100000\nint W, H, N;\nint MX[H_MAX], X[H_MAX];\n\nmain(){\n  int x, y;\n  cin >> W >> H >> N;\n  for ( int i = 0; i < H; i++ ) MX[i] = X[i] = -1;\n  for ( int i = 0; i < N; i++){\n    cin >> x >> y;\n    X[y] = max(X[y], x);\n  }\n  MX[H-1] = 0;\n  for ( int i = H-2; i >= 0; i-- ){\n    MX[i] = max(MX[i+1], X[i+1]);\n  }\n\n  int ans = H;\n  for ( int i = 0; i < H; i++ ){\n    ans = min(ans, i + MX[i]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint main(){\n    int W,H,N;\n    VP V;\n    cin>>W>>H>>N;\n    FOR(i,0,N){\n        int X,Y;\n        cin>>X>>Y;\n        V.PB(MA(X,Y));\n    }\n    sort(V.begin(),V.end());\n    VP mid;\n    int now=0;\n    while(now<N-1){\n        while(now<N-1&&V[now].FI==V[now+1].FI){\n            now++; \n        }\n        mid.PB(V[now]);\n        now++;\n        if(now==N-1){\n            mid.PB(V[now]);\n        }\n    }\n    VP ans;\n    ans.PB(mid.back());\n    ROF(i,0,(int)mid.size()){\n        if(mid[i].SE>ans.back().SE){\n            ans.PB(mid[i]);\n        }\n    }\n    reverse(ans.begin(),ans.end());\n    int a=min(ans[0].SE,ans.back().FI);\n    FOR(i,0,(int)ans.size()-1){\n        a=min(a,ans[i].FI+ans[i+1].SE);\n    }\n    cout<<a<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int (i)=0;(i) < (N); (i)++)\n\nint main(){\n    int W,H,N;\n    cin >> W >> H >> N;\n    vector<int> MAX_X(H,0), MAX_Y(W,0);\n    rep(i,N){\n        int x,y;\n        cin >> x >> y ;\n        MAX_X[y] = max(MAX_X[y], x);\n        MAX_Y[x] = max(MAX_Y[x], y);\n    }\n\n    for(int y=H-2;y>=0;y--) MAX_X[y] = max(MAX_X[y], MAX_X[y+1]);\n    for(int x=W-2;x>=0;x--) MAX_Y[x] = max(MAX_Y[x], MAX_Y[x+1]);\n\n    for(int y=0;y<H-1;y++) MAX_X[y] = MAX_X[y+1];\n    for(int x=0;x<W-1;x++) MAX_Y[x] = MAX_Y[x+1];\n\n    MAX_X[H-1] = 0;\n    MAX_Y[W-1] = 0;\n\n    int ans = 1e9;\n    for(int y=0;y<H;y++) ans = min(ans, y+MAX_X[y]);\n    for(int x=0;x<W;x++) ans = min(ans, x+MAX_Y[x]);\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,w,i,j,a[100000],b[100000],h,y[100000];\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t}\n\tm=10000000;\n\tfor(i=0;i<w;i++) y[i]=0;\n\tfor(i=0;i<n;i++) if(y[a[i]-1]<b[i]) y[a[i]-1]=b[i];\n\t//for(i=0;i<w;i++) printf(\"AA%d\\n\",y[i]);\n\tfor(i=w-2;i>=0;i--) if(y[i]<y[i+1]) y[i]=y[i+1];\n\tfor(i=0;i<w;i++){\n\t\tif(i+y[i]<m) m=i+y[i];\n\t}\n\t//for(i=0;i<w;i++) printf(\"BB%d\\n\",y[i]);\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint wh[10001][10001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint num=0;int at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; cin >> x >> y; wh[x][y]++;if(x==0||y==0)num++;\n\t\twh[w][y] = max(wh[w][y], x);at_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tif(num==n){cout<<0<<endl;return 0;}\n\n\tint x_position, y_position, MIN;\n    MIN = wh[w][h - 1] + (h - 1); x_position = wh[w][h - 1]; y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[w][b]) {\n\t\t\tx_position = wh[w][y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << min(MIN,min(at_most_w,at_most_h)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define dep(i, a, n) for(int i = a; i >= (n); i--)\n#define FOR(i, a, n) for(int i = a; i < (n); i++)\n#define mod (ll)(1e9+7)\n#define int ll\n#define INF 100000000\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nll w, h, n, s[100001], result = INF;\n\nsigned main() {\n  rep(i, 100001) s[i] = 0;\n\tcin >> w >> h >> n;\n  rep(i, n) {\n    ll x, y;\n    cin >> x >> y;\n    s[y] = max(s[y], x);\n  }\n  dep(i, h - 2, 0) s[i] = max(s[i], s[i + 1]);\n  rep(i, h) result = min(result, s[i + 1] + i);\n  cout << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100000,flag=0;\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    cout<<sum;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\n#define FOR(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define FOR1(i,n) for(int (i)=1;(i)<(n);(i)++)\n#define eFOR(i,n) for(int (i)=0;(i)<=(n);(i)++)\n#define eFOR1(i,n) for(int (i)=1;(i)<=(n);(i)++)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\nconstexpr auto INF = 1000000000;\nconstexpr auto LLINF = 1LL << 62;\nconstexpr auto mod = 1000000007;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; }return 0; }\n\nint fx[100000], fy[100000];\nint main() {\n    int w, h, n;\n    cin >> w >> h >> n;\n    int x, y;\n    FOR(i, n) {\n        cin >> x >> y;\n        if (!(x && y))continue;\n        chmax(fx[x - 1], y);\n        chmax(fy[y - 1], x);\n    }\n    FOR1(i, w)chmax(fx[w - i - 1], fx[w - i]);\n    FOR1(i, h)chmax(fy[h - i - 1], fy[h - i]);\n    int ans = INF;\n    FOR(i, w)chmin(ans, i + fx[i]);\n    FOR(i, h)chmin(ans, i + fy[i]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n#include<ctime>\n#include<string>\n#include<cstdlib>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<functional>\n#include<string.h>\n#include<limits.h>\n#define P pair<int,int>\nusing namespace std;\n\nvector<P>V;\nsigned main() {\n \tint a, b, n; cin >> a >> b >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, d; cin >> c >> d;\n\t\tV.push_back({ c,d });\n\t}\n\tV.push_back({ 0, 0 });\n\tsort(V.begin(), V.end(), greater<P>());\n\tint ans = 1 << 29;\n\tint MAX = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tans = min(ans, MAX + V[i].first);\n\t\tMAX = max(MAX, V[i].second);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod (ll)(1e9+7)\n#define int ll\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nint w, h, n;\nP p1[100001];\n\nsigned main() {\n  cin >> w >> h >> n;\n  int mx = 0, my = 0;\n  rep(i, 0, n) {\n    cin >> p1[i].first >> p1[i].second;\n    mx = max(mx, p1[i].first);\n    my = max(my, p1[i].second);\n  }\n  sort(p1, p1 + n);\n  int s, m = 0;\n  int ans = min(mx, my);\n  dep(i, n - 1, 0) {\n    s = p1[i].first;\n    ans = min(ans, s + m);\n    m = max(m, p1[i].second);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=100010;\nint maxY[N];\nint main(){\n    int w,h,n;\n    cin>>w>>h>>n;\n    for(int i=0;i<n;i++){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n\tmaxY[x]=max(maxY[x],y);\n    }\n    int ans=w-1,M=0;\n    for(int x=w-2;x>=0;x--){\n\tM=max(M,maxY[x+1]);\n\tans=min(ans,x+M);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint w, h, n; cin >> w >> h >> n;\n\tvector<pi> v;\n\trep(i, n){\n\t\tint x, y; cin >> x >> y;\n\t\tv.emplace_back(x, y);\n\t}\n\tsort(all(v));\n\t\n\tint ans = w - 1, mx = 0;\n\tfor(int i = w - 1, j = n - 1; i >= 0; i--){\n\t\tans = min(ans, i + mx);\n\t\twhile(j >= 0 && v[j].first == i) mx = max(mx, v[j--].second);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,n;\nvp a;\n\nint main(){\n\tcin>>h>>w>>n;\n\ta=vp(n);\n\tfor(int i=0;i<n;i++) cin>>a[i].first>>a[i].second;\n\tsort(a.begin(),a.end());\n\tvp b;\n\tfor(int i=0;i<n;i++){\n\t\twhile(b.size()&&b.back().second<=a[i].second) b.pop_back();\n\t\tb.push_back(a[i]);\n\t}\n\tint res=inf;\n\tif(b.size()==1) res=min(b[0].first,b[0].second);\n\telse{\n\t\tfor(int i=0;i<b.size()-1;i++) res=min(res,b[i].first+b[i+1].second);\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,w,i,j,a[1000000],b[1000000],h,y[1000000];\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t}\n\tm=10000000;\n\tfor(i=0;i<w;i++) y[i]=0;\n\tfor(i=0;i<n;i++) if(y[a[i]-1]<b[i]) y[a[i]-1]=b[i];\n\t//for(i=0;i<w;i++) printf(\"AA%d\\n\",y[i]);\n\tfor(i=w-2;i>=0;i--) if(y[i]<y[i+1]) y[i]=y[i+1];\n\tfor(i=0;i<w;i++){\n\t\tif(i+y[i]<m) m=i+y[i];\n\t}\n\t//for(i=0;i<w;i++) printf(\"BB%d\\n\",y[i]);\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int X = 100000;\nint my[X]={};\n\nint main()\n{\n    int w,h,n;\n    cin >>w >>h >>n;\n    rep(i,n)\n    {\n        int x,y;\n        cin >>x >>y;\n\n        my[x] = max(my[x],y);\n    }\n\n    int yy = 0;\n    int ans = w-1;\n    for(int i=w-1; i>0; --i)\n    {\n        yy = max(yy,my[i]);\n        ans = min(ans, i-1+yy);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int w,h,n;\n  cin>>w>>h>>n;\n  int d[w];\n  memset(d,0,sizeof(d));\n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    d[x]=max(d[x],y);\n  }\n  int ans=w,k=0;\n  for(int i=w-1;i>=0;i--){\n    ans=min(ans,i+k);\n    k=max(k,d[i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,w,i,j,a[100000],b[100000],h,y[100000];\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t}\n\tm=10000000;\n\tfor(i=0;i<w;i++) y[i]=0;\n\tfor(i=0;i<n;i++) if(y[a[i]-1]<b[i]) y[a[i]-1]=b[i];\n\t//for(i=0;i<w;i++) printf(\"AA%d\\n\",y[i]);\n\tfor(i=w-2;i>=0;i--) if(y[i]<y[i+1]) y[i]=y[i+1];\n\tfor(i=0;i<w;i++){\n\t\tif(i+y[i]<m) m=i+y[i];\n\t}\n\t//for(i=0;i<w;i++) printf(\"BB%d\\n\",y[i]);\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint w,h,n;\n\tcin>>w>>h>>n;\n\tpair<int,int> bug[n];\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbug[i].first=a; bug[i].second=b;\n\t}\n\tsort(bug,bug+n);\n//\tfor(int i=0;i<n;i++) cout<<bug[i].first<<' '<<bug[i].second<<endl;\n\tint mx=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(bug[i+1].first!=bug[i].first&&bug[i].first!=0&&bug[i].second!=0)\n\t\t\tmx=max(mx,bug[i+1].second);\n\t}\n\tcout<<mx+bug[0].first<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace::std;\n//struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n__attribute__((constructor))\nvoid init(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(15);\n}\n// random_device rd;\n// mt19937 mt(rd());\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/dynamic_bitset.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n// #include <boost/math/tools/minima.hpp>\n// using boost::math::tools::brent_find_minima;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<256>> cdouble;\n// typedef mp::cpp_int cint;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T=long long>using pbds=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pbds_map=tree<T,T,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pqueue =__gnu_pbds::priority_queue<T, less<T>,rc_binomial_heap_tag>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\");if(i>INF/2)cout<<\"INF\";else cout<<i;f=1;}cout<<\"\\n\";}while(0);\n#define output2(v) for(auto j:v)output(j);\n#define _output(v) do{bool f=0;rep(i,v.size()){cout<<(f?\" \":\"\");if(v[i]>INF/2)cout<<\"INF\";else cout<<v[i];f=1;}cout<<\"\\n\";}while(0)\n#define _output2(v) rep(j,v.size()){_output(v[j]);}\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n#define MOD 998244353LL\n#define endl \"\\n\"\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ninline lint gcd(lint a,lint b){return b?gcd(b,a%b):a;}\ntemplate<typename T=lint>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<typename T=lint>inline T add(T a,T b){return a+b;}\ntemplate<typename T=lint>inline T minq(T a,T b){return min(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\n\n\n// template<typename T,typename E>\n// struct RBST{\n// \tstruct node{\n// \t\tint cnt=1,l=-1,r=-1;\n// \t\tT key;E val;\n// \t\tnode(){}\n// \t\tnode(T key,E val):key(key),val(val){}\n// \t};\n// \tvector<node> v;\n// \tRBST(){\n// \t}\n// \tint root=1;\n// \tint count(int idx){return idx==-1?0:v[idx].cnt;}\n// \tint update(int idx){\n// \t\tif(idx!=-1)v[idx].cnt=1+count(v[idx].l)+count(v[idx].r);\n// \t\treturn idx;\n// \t}\n// \tprivate:\n// \tinline int merge(int l,int r){\n//         if(l==-1||r==-1)return l==-1?r:l;\n//         if((unsigned long)count(v[l])>rnd()%(unsigned long)(count(v[l])+count(v[r]))){\n//             v[l].r=merge(v[l].r,r);\n//             return update(l);\n//         }else{\n//             v[r].l=merge(l,v[r].l);\n//             return update(r);\n//         }\n//     }\n// \tinline pair<int,int> split(int t,int k){\n//         if(t==-1)return make_pair(-1,-1);\n//         if(k<=count(v[t].l)){\n//             auto s=split(v[t].l,k);\n//             v[t].l=s.second;\n//             return make_pair(s.first,update(t));\n//         }else{\n//             auto s=split(v[t].r,k-count(v[t].l)-1);\n//             v[t].r=s.first;\n//             return make_pair(update(t),s.second);\n//         }\n//     }\n// \tinline unsigned long rnd() {\n//         static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;\n//         unsigned long t=(x^(x<<11));\n//         x=y; y=z; z=w;\n//         return ( w=(w^(w>>19))^(t^(t>>8)) );\n//     }\n// };\n\ntemplate<typename T=long long,typename E=T>\nstruct segment{\n    private:\n    T et;\n    E ee;\n    lint n;\n    lint size;\n    struct node{\n        T val;\n        E lazy;\n        node *lch,*rch;\n        node(segment &seg):lch(nullptr),rch(nullptr){val=seg.et;lazy=seg.ee;}\n    };\n    struct interval{\n        segment<T,E>* seg;\n        lint l,r;\n        interval operator +=(T n){seg->update(l,r,n);return *this;}\n        interval operator =(T n){seg->update(l,r,n);return *this;}\n        operator T(){return seg->get(l,r);}\n    };\n    struct iterator{\n        lint n;\n        segment<T,E>* seg;\n        iterator(segment* seg,lint n):n(n),seg(seg){}\n        auto operator!=(const iterator& rhs){return n!=rhs.n;}\n        auto operator++(){n++;}\n        auto operator--(){n--;}\n        auto operator+=(lint add){n+=add;}\n        auto operator-=(lint sub){n-=sub;}\n        auto operator*(){return seg->get(n,n+1);}\n    };\n    node* root;\n    public:\n    segment(lint size,T et,E ee):et(et),ee(ee),n(1),size(size){\n        while(n<size)n<<=1;\n        root=new node(*this);\n    }\n    segment(T et,E ee):et(et),ee(ee),n((1LL<<61)-1),size(1LL<<60){\n        root=new node(*this);\n    }\n    public:\n    //0-indexed [a,b)\n    T update(lint a,lint b,E x,lint k=0,lint l=0,lint r=-1,node* t=nullptr){\n        if(t==nullptr)t=root;\n        if(r<0)r=n;\n        eval(t,r-l,k);\n        //区間外\n        if(r<=a||b<=l)return t->val;\n        //全部区間内\n        if(a<=l&&r<=b){\n            t->lazy=g(t->lazy,x);\n            return h(t->val,t->lazy,r-l);\n        }\n        //一部区間内\n        if(t->lch==nullptr)t->lch=new node(*this);\n        if(t->rch==nullptr)t->rch=new node(*this);\n        return t->val=f(update(a,b,x,2*k+1,l,(l+r)/2,t->lch),update(a,b,x,2*k+2,(l+r)/2,r,t->rch));\n    }\n    //0-indexed [a,b)\n    T get(lint a,lint b,lint k=0,lint l=0,lint r=-1,node* t=nullptr){\n        if(t==nullptr)t=root;\n        if(r<0)r=n;\n        eval(t,r-l,k);\n        //区間外\n        if(r<=a||b<=l)return et;\n        //全部区間内\n        if(a<=l&&r<=b)return t->val;\n        //一部区間内\n        if(t->lch==nullptr)t->lch=new node(*this);\n        if(t->rch==nullptr)t->rch=new node(*this);\n        return f(get(a,b,2*k+1,l,(l+r)/2,t->lch),get(a,b,2*k+2,(l+r)/2,r,t->rch));\n    }\n    iterator begin(){\n        return iterator(this,0);\n    }\n    iterator end(){\n        return iterator(this,size);\n    }\n    interval operator ()(lint l,lint r){return interval{this,l,r};}\n    interval operator ()(lint n){return interval{this,n,n+1};}\n    interval operator [](lint n){return interval{this,n,n+1};}\n    private:\n    inline void eval(node* t,lint len,lint k){\n        if(t->lazy==ee) return;\n        if(k*2+1<n*2-1){\n            if(t->lch==nullptr)t->lch=new node(*this);\n            if(t->rch==nullptr)t->rch=new node(*this);\n            t->lch->lazy=g(t->lch->lazy,t->lazy);\n            t->rch->lazy=g(t->rch->lazy,t->lazy);\n        }\n        t->val=h(t->val,t->lazy,len);\n        t->lazy=ee;\n    }\n    T f(T a,T b){\n        return a+b;\n    }\n    T h(T a,E b,lint len){\n        return update(a,b);\n    }\n    E g(E a,E b){\n        return update(a,b);\n    }\n    auto update(auto a,auto b){return b==ee?a:b;}\n};\n\nint main(){\n    lint w,h,n;\n    cin>>w>>h>>n;\n    pvec v(n);\n    rep(i,n){\n        cin>>v[i].first>>v[i].second;\n        v[i].second*=-1;\n    }\n    sort(all(v));\n    reverse(all(v));\n    lint mn=0;\n    lint ans=INF;\n    rep(i,n){\n        chmin(ans,mn+v[i].first);\n        chmax(mn,-v[i].second);\n    }\n    chmin(ans,mn);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\nconst int N=1e5+10;\nint min(int a,int b){return a>b?b:a;}\nint main(){\n    int w,h,n,ans;\n    multiset<int> ms;\n    multiset<int>::iterator u;\n    pi a[N];\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&a[i].F,&a[i].S);\n        ms.insert(a[i].S);\n    }\n    sort(a,a+n);\n    u=ms.end();\n    u--;\n    ans=*u;\n    n--;\n    for(int i=0;i<n;i++){\n        ms.erase(ms.find(a[i].S));\n        u=ms.end();\n        u--;\n        ans=min(ans,a[i].F+*u);\n    }\n    ans=min(ans,a[n].F);\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while ( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, INF);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if ( a >= r || b <= l ) return INF;\n    if ( a <= l && r <= b ) return tree[k];\n    return min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while ( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = min(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\n\nsigned main() {\n  int W, H, N;\n  SegT t1(100001), t2(100001);\n  int Y[100001] = {0}, X[100001] = {0};\n\n  cin >> W >> H >> N;\n  Rep(i, N) {\n    int x, y;\n    cin >> x >> y;\n    Y[y] = max(Y[y], x);\n    X[x] = max(X[x], y);\n  }\n\n  Rep(i, W) {\n    t1.update(i, -Y[i]);\n  }\n\n  Rep(i, H) {\n    t2.update(i, -X[i]);\n  }\n\n  int ans = min(W, H);\n  Rep(i, W-1) {\n    ans = min(ans, i + -t1.rmq(i+1, W));\n  }\n\n  Rep(i, H-1) {\n    ans = min(ans, i + -t2.rmq(i+1, H));\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1e+9\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint w,h,n,ma = 0,pos = 0,mi = INF;\n\tvector<P> vec;\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tvec.push_back(P(x,y));\n\t}\n\tsort(vec.begin(),vec.end(),greater<P>());\n\tif(w == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i = w - 1;i >= 1;i--){\n\t\twhile(pos < n && vec[pos].first >= i) ma = max(ma,vec[pos++].second);\n\t\tmi = min(mi,i + ma - 1);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,n)m[n-i-1]=max(m[n-i-1],m[n-i]);\n  r(i,w)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint W,H,N;\nvector<P> t;\nmap<int,int> mp;\nvector<int> X;\n\nint main(){\n  cin>>W>>H>>N;\n  t.resize(N);\n  \n  int ans=0;\n  \n  for(int i=0;i<N;i++){\n    int x,y;\n    cin>>x>>y;\n    t[i]=P(x,y);\n    mp[x]=max(mp[x],y);\n    X.push_back(x);\n    ans=max(ans,y);\n  }\n  \n  sort(X.begin(),X.end());\n  X.erase( unique( X.begin(), X.end() ), X.end() );\n\n  vector<int> u(X.size()+1);\n  \n  u[X.size()]=0;\n  for(int i= (int)X.size()-1;i>=0;i--){\n    u[i]=max(u[i+1],mp[ X[i] ]);\n  }\n    \n  for(int i=0;i<(int)X.size();i++){\n    ans=min(ans, X[i]+u[i+1]);\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\nusing i64 = long long;\n\nint main()\n{\n  i64 w, h, n;\n  cin >> w >> h >> n;\n  vector<i64> x(n), y(n);\n  for (i64 i = 0; i < n; i++)\n    cin >> x[i] >> y[i];\n  vector<i64> m(h);\n  for (i64 i = 0; i < n; i++)\n    m[y[i]] = max(m[y[i]], x[i]);\n  i64 ans = 1e9, mob = 0;\n  for (i64 i = h - 1; 0 <= i; i--)\n  {\n    ans = min(ans, i + mob);\n    mob = max(mob, m[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n\ntypedef std::pair<int, int> pi;\n\nint maxi(int a, int b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  int n, i, j, h, w;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  pi p[n];\n  int max[w];\n  for(i = 0; i < w; ++i) max[i] = 0;\n  for(i = 0; i < n; ++i) scanf(\"%d%d\", &p[i].first, &p[i].second);\n  for(i = n - 1; i >= 0; --i) {\n    if(!p[i].first) continue;\n    if(max[p[i].first - 1] < p[i].second) max[p[i].first - 1] = p[i].second;\n  }\n  /*for(i = 0; i < w; ++i) printf(\"%d \", max[i]);\n  printf(\"\\n\");*/\n  for(i = w - 2; i >= 0; --i) max[i] = maxi(max[i + 1], max[i]);\n  /*for(i = 0; i < w; ++i) printf(\"%d \", max[i]);\n  printf(\"\\n\");*/\n  int ans = 999999999;\n  for(i = 0; i < w; ++i) {\n    if(ans > i + max[i]) ans = i + max[i];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing D = double;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_num(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define RALL(qpqpq)           (qpqpq).rbegin(),(qpqpq).rend()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define RFOR(i,tptpt,ypypy)  for(LL i=(tptpt);i>=(ypypy);i--)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint w, h, n;\nint maxnum[101010];\n\nint main() {\n\tcin >> w >> h >> n;\n\tREP(i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif (maxnum[x] < y)maxnum[x] = y;\n\t}\n\tint ans = w - 1;\n\tint y = 0;\n\tfor (int i = w - 2; i >= 0; i--) {\n\t\tif (y < maxnum[i + 1])y = maxnum[i + 1];\n\t\tif (ans > i + y)ans = i + y;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,w)m[w-i-1]=max(m[w-i-1],m[w-i]);\n  r(i,w)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\n\nusing namespace std;\n\nint main()\n{\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tvector<int> vec(h);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tvec[y] = max(vec[y], x);\n\t}\n\tint ans = 1000000, mob = 0;\n\tfor (int i = h - 1; - 1 < i; i--)\n\t{\n\t\tans = min(ans, i + mob);\n\t\tmob = max(mob, vec[i]);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint box[100001];\nint main(void)\n{\n\tint MIN,i,w,h,n,x,y,MAX,flg;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<w;i++){\n\t\tbox[i]=0;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tbox[x]=max(y,box[x]);\n\t\tif(x!=0&&y!=0){\n\t\t\tflg=1;\n\t\t\t}\n\t}\n\tif(flg==0){\n\t\tprintf(\"0\\n\");\n\t}\n\telse{\n\tMIN=10000001;\n\tMAX=0;\n\tfor(i=w-1;i>=0;i--){\n\t\t\tMIN=min(MIN,MAX+i);\n\t\t\tMAX=max(MAX,box[i]);\n\t}\n\t}\n\tprintf(\"%d\\n\",MIN);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define P pair<int,int>\n#define F first\n#define S second\n#define mod 1000000007\n#define INF 9000000000000000000\nsigned main(void){\n    int w,h,n;cin>>w>>h>>n;\n    vector<int>V[w];\n    vector<int>Max(w,0);\n    int x,y;\n    rep(i,n){\n        cin>>x>>y;\n        V[x].push_back(y);\n    }\n    rep(i,w){\n        int ma=0;\n        rep(j,V[i].size()){\n            ma=max(ma,V[i][j]);\n        }\n        Max[i]=ma;\n    }\n    rep(i,w-1){\n        Max[w-2-i]=max(Max[w-i-1],Max[w-2-i]);\n    }\n    int ans=INF;\n    rep(i,w-1){\n        ans=min(ans,i+Max[i+1]);\n    }\n    ans=min(ans,w-1);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll MOD=10000000;\nconst ll INF=1000000001;\nconst ll LINF=4000000000000000010;\nconst double EPS=1e-9;\nint dx[5]={0,1,0,-1,0};\nint dy[5]={1,0,-1,0,0};\nvector<int> v[100010];\nint ma[100010];\nint main(){\n    int w,h,n;cin>>w>>h>>n;\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        v[x].push_back(y);\n    }\n    for(int i=w-1;i>=1;i--){\n        int maa=0;\n        for(auto a:v[i]){\n            maa=max(a,maa);\n        }\n        ma[i-1]=max(ma[i],maa);\n    }\n    int ans=INF;\n    for(int i=0;i<w;i++){\n        int s=i+ma[i];\n        ans=min(s,ans);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Dscc {\npublic:\n\n\t//fst:belongs , scd:newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nint main() {\t\n\tint W,H,N;cin>>W>>H>>N;\n\tvector<vector<int>>ops(H);\n\tmap<int,int>xs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x,y;cin>>x>>y;\n\t\tops[y].push_back(x);\n\t\txs[x]++;\n\t}\n\tint ans=min(H,W);\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (auto x : ops[i]) {\n\t\t\txs[x]--;\n\t\t\tif (xs[x] == 0) {\n\t\t\t\txs.erase(x);\n\t\t\t}\n\t\t}\n\t\tif (xs.empty()) {\n\t\t\tans=min(ans,i);\n\t\t}\n\t\telse {\n\n\t\t\tint max_x = prev(xs.end())->first;\n\t\t\tans = min(ans, i + max_x);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1001001001;\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n\n  vector<int> a(h + 1, 0);\n\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n\n    a[y] = max(a[y], x);\n  }\n\n  int ans = inf;\n  for (int i = h; i >= 0; --i) {\n    ans = min(ans, i + a[i + 1]);\n    a[i] = max(a[i + 1], a[i]);\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n\ntypedef std::pair<int, int> pi;\n\nint maxi(int a, int b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  int n, i, j, h, w;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  pi p[n];\n  int max[w];\n  for(i = 0; i < w; ++i) max[i] = 0;\n  for(i = 0; i < n; ++i) scanf(\"%d%d\", &p[i].first, &p[i].second);\n  for(i = n - 1; i >= 0 && p[i].first; --i) {\n    if(!p[i].first) continue;\n    if(max[p[i].first - 1] < p[i].second) max[p[i].first - 1] = p[i].second;\n  }\n  for(i = n - 2; i >= 0; --i) max[i] = maxi(max[i + 1], max[i]);\n  int ans = 999999999;\n  for(i = 0; i < n; ++i) {\n    if(ans > i + max[i]) ans = i + max[i];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint w,h,n;\n\tcin>>w>>h>>n;\n\tpair<int,int> bug[n+1];\n\tbug[n].first=0; bug[n].second=0;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbug[i].first=a; bug[i].second=b;\n\t}\n\tsort(bug,bug+n);\n\tint mx=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(bug[i+1].first!=bug[i].first) mx=max(mx,bug[i+1].second);\n\t}\n\tcout<<mx+bug[0].first<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(long long int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(long long int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(long long int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define pb(q) push_back(q)\n#define Abs(a,b) max(a,b)-min(a,b)\n#define YES(condition) if(condition){cout << \"YES\" << endl;}else{cout << \"NO\" << endl;}\n#define Yes(condition) if(condition){cout << \"Yes\" << endl;}else{cout << \"No\" << endl;}\n#define Cout(x) cout<<(x)<<endl\n#define POSSIBLE(condition) if(condition){cout << \"POSSIBLE\" << endl;}else{cout << \"IMPOSSIBLE\" << endl;}\n#define Possible(condition) if(condition){cout << \"Possible\" << endl;}else{cout << \"Impossible\" << endl;}\n#define possible(condition) if(condition){cout << \"possible\" << endl;}else{cout << \"impossible\" << endl;}\n#define Size(n) (n).size()\n\ntypedef long long ll;\n\n\nusing namespace std;\n\nconst int INF = 1e9,MOD = 1e9 + 7,ohara = 1e6;\nconst ll LINF = 1e18;\n\n\nlong long int n,cnt=0,ans=0,a,b,c,d,cmp,cmpp,m,h,w,x,y,sum=0,pos,ma[ohara];\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n      \n      cin >> w >> h >> n;\n      pair<ll,ll> p[ohara];\n      rep(i,n){\n        cin >> x >> y;\n        ans = max(ans,y);\n        p[i] = make_pair(x,y);\n      }\n       sort(p,p + n);\n      ma[n - 1] = p[n - 1].second;\n      rrrep(i,n - 2,0){\n        ma[i] = max(ma[i + 1],p[i].second);\n      }\n      rep(i,n){\n          cnt = p[i].first + ma[i + 1];\n          ans = min(ans,cnt);\n      }\n      Cout(ans);\n     \n\n       \nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,n)m[n-i-1]=max(m[n-i-1],m[n-i]);\n  r(i,w-2)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[100001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[y] = max(wh[y], x);\n\t\tat_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[h - 1] + (h - 1);\n    x_position = wh[h - 1];\n    y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[b]) {\n\t\t\tx_position = wh[y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << #include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[100001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[y] = max(wh[y], x);\n\t\tat_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[h - 1] + (h - 1);\n    x_position = wh[h - 1];\n    y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[b]) {\n\t\t\tx_position = wh[y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << min(MIN,min(at_most_w,at_most_h)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\tvector<P> px(N), py(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tpx[i] = P(a, b);\n\t\tpy[i] = P(b, a);\n\t}\n\n\tsort(px.begin(), px.end());\n\tsort(py.begin(), py.end());\n\tvector<int> mpx(N), mpy(N);\n\tmpx[N - 1] = px[N - 1].second;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tmpx[i] = max(mpx[i + 1], px[i].second);\n\t}\n\tmpy[N - 1] = py[N - 1].second;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tmpy[i] = max(mpy[i + 1], py[i].second);\n\t}\n\tint ans = 114514;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i + 1 != N)\n\t\t\tans = min(ans, px[i].first + mpx[i + 1]);\n\t\telse\n\t\t\tans = min(ans, px[i].first);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i + 1 != N)\n\t\t\tans = min(ans, py[i].first + mpy[i + 1]);\n\t\telse\n\t\t\tans = min(ans, py[i].first);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint H, W, N, maxn, ret = (1 << 30);\nvector<int> X[100009];\n\nint main() {\n\tscanf(\"%d%d%d\", &H, &W, &N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint p, q; scanf(\"%d%d\", &p, &q);\n\t\tX[p].push_back(q);\n\t}\n\tfor (int i = 100000; i >= 0; i--) {\n\t\tret = min(ret, i + maxn);\n\t\tfor (int j : X[i]) maxn = max(maxn, j);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,n;\nvp a;\n\nint main(){\n\tcin>>h>>w>>n;\n\ta=vp(n);\n\tfor(int i=0;i<n;i++) cin>>a[i].first>>a[i].second;\n\tsort(a.begin(),a.end());\n\tvp b;\n\tfor(int i=0;i<n;i++){\n\t\twhile(b.size()&&b.back().second<=a[i].second) b.pop_back();\n\t\tb.push_back(a[i]);\n\t}\n\tint res=min(b[0].second,b.back().first);\n\tfor(int i=0;i<b.size()-1;i++) res=min(res,b[i].first+b[i+1].second);\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n\n/* include file*/\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntemplate <class Monoid>\nstruct Segment {\n  using Func = function<Monoid(Monoid, Monoid)>;\n\n  vector<Monoid> node;\n  Monoid ide;\n  int n = 1;\n\n  Func bin_f;\n  Func update_f;\n\n  Segment(const vector<Monoid>& init, Monoid ide_, Func f_, Func u_f)\n      : bin_f(f_), ide(ide_), update_f(u_f) {\n    int sz = init.size();\n    while (n < sz) n *= 2;\n    node.assign(n * 2 - 1, ide);\n    for (int i = 0; i < sz; i++) node[i + n - 1] = init[i];\n    for (int i = n - 2; i >= 0; i--)\n      node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n  }\n\n  void update(int i, Monoid x) {\n    i += n - 1;\n    node[i] = update_f(node[i], x);\n    while (i) {\n      i = (i - 1) / 2;\n      node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n    }\n  }\n\n  Monoid get_inter(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (r <= a || b <= l) return ide;\n\n    Monoid lm = get_inter(a, b, k * 2 + 1, l, (l + r) / 2);\n    Monoid rm = get_inter(a, b, k * 2 + 2, (l + r) / 2, r);\n    return bin_f(lm, rm);\n  }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730414#1\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730425#1\n\n\nint W,H,N;\n\nvector<int> x,y;\n\nint main(){\n  cin >> W >> H >> N;\n  x.resize(N);\n  y.resize(N);\n\n  rep(i,0,N - 1) cin >> x[i] >> y[i];\n\n  vector<int> init(W,-1);\n\n  rep(i,0,N - 1){\n    init[x[i]] = max(init[x[i]],y[i]);\n  }\n\n  rep(i,0,W - 1){\n    if(init[i] == -1){\n      init[i] = -1;\n    }\n  }\n  Segment<int> seg(init,-1,[](int a,int b){\n    return max(a,b);\n  }\n  ,[](int a,int b){\n    return b;\n  });\n\n  int ans = 1e9;\n\n  rep(i,0,W - 1){\n    int temp = seg.get_inter(i + 1,W);\n    if(temp == -1) temp = 0;\n    ans = min(ans , i + temp);\n\n    //cout << i << \" \" << temp << endl;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _overload2(_1,_2,name,...) name\n#define _re(n) _rep(i,n)\n#define _rep(i,n) _repi(i,0,n)\n#define _repi(i,a,b) for(ll i=a;i<b;++i)\n#define _repc(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_repc,_repi,_rep,_re)(__VA_ARGS__)\n#define _rre(n) _rrep(i,n)\n#define _rrep(i,n) _rrepi(i,0,n)\n#define _rrepi(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrepc(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrepc,_rrepi,_rrep,_rre)(__VA_ARGS__)\n#define sum(...) accumulate(range(__VA_ARGS__),0)\n#define _range(i) (i).begin(),(i).end()\n#define _rangek(i,k) (i).begin(),(i).begin()+k\n#define range(...) _overload2(__VA_ARGS__,_rangek,_range)(__VA_ARGS__)\n#define LINF (ll)1000000000000000000\n#define MOD (ll)1000000007\n#define INF (int)1000000007\n#define Yes(i) out(i?\"Yes\":\"No\")\n#define YES(i) out(i?\"YES\":\"NO\")\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,size) vector<type> name(size);\n#define VEC(type,name,size) vector<type> name(size);in(name)\nstruct aaa{aaa(){cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};}aaaaaaa;\ninline void in() {}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec);\ntemplate<typename T,typename L>\nistream& operator >> (istream& is, pair<T,L>& p);\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec);\ntemplate<typename T,typename L>\nostream& operator << (ostream& os, pair<T,L>& p);\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){for(T& x: vec) is >> x;return is;}\ntemplate<typename T,typename L>\nistream& operator >> (istream& is, pair<T,L>& p){is >> p.first;is >> p.second;return is;}\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& vec){os << vec[0];rep(i,1,vec.size()){os << ' ' << vec[i];}return os;}\ntemplate<typename T,typename L>\nostream& operator << (ostream& os, pair<T,L>& p){os << p.first << \" \" << p.second;return os;}\ntemplate <class Head, class... Tail>\ninline void in(Head&& head,Tail&&... tail){cin>>head;in(move(tail)...);}\ntemplate <class T>\ninline void out(T t){cout<<t<<'\\n';}\ninline void out(){cout<<'\\n';}\ntemplate <class Head, class... Tail>\ninline void out(Head head,Tail... tail){cout<<head<<' ';out(move(tail)...);}\n\n\nint main(){\n    INT(w,h,n);\n    vec(int,a,w);\n    rep(i,0,n){\n        INT(x,y);\n        if(a[x]<y)a[x]=y;\n    }\n    rrep(i,0,w-1){\n        if(a[i]<a[i+1])a[i]=a[i+1];\n    }\n    rep(i,0,w-1)a[i]=i+a[i+1];\n    a[w-1]=w-1;\n    out(*min_element(range(a)));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint w,h,n;\n\tcin>>w>>h>>n;\n\tpair<int,int> bug[n];\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbug[i].first=a; bug[i].second=b;\n\t}\n\tsort(bug,bug+n);\n\tint mx=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(bug[i+1].first!=bug[i].first&&bug[i].first!=0&&bug[i].second!=0)\n\t\t\tmx=max(mx,bug[i+1].second);\n\t}\n\tcout<<mx+bug[0].first<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1 << 30;\n\nint W, H, N;\nvector<P> xy;\nint main() {\n\tcin >> W >> H >> N;\n\trep(i, N) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\txy.emplace_back(x, y);\n\t}\n\txy.emplace_back(0, 0);\n\tsort(xy.begin(), xy.end());\n\n\tint ans = INF;\n\tint mxy = 0;\n\tfor (int i = xy.size() - 1; i >= 0; i--) {\n\t\tans = min(ans, xy[i].first + mxy);\n\t\tmxy = max(mxy, xy[i].second);\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100001,flag=0;\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    if(sum==100001)sum=min(W-1,H-1);\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n    int w,h,n;cin>>w>>h>>n;\n    int mx=0;int my=0;int mm=0;\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        if(x<y){\n            mx=max(mx,x);\n        }else if(x>y){\n            my=max(my,y);\n        }else{\n            mm=max(mm,x);\n        }\n    }\n    int ans=mx+my;\n    if(max(mx,my)<mm){\n        ans+=mm-max(mx,my);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\n\nint main() {\n  int h,w,n;\n  cin >> h >> w >> n;\n  P a[n];\n  for(int i=0; i<n; i++) cin >> a[i].F >> a[i].S;\n  int ans=1<<30;\n  for(int k=0; k<2; k++) {\n    sort(a,a+n);\n    int d[n+1];\n    for(int i=0; i<n; i++) d[i]=a[i].S;\n    d[n]=0;\n    for(int i=n-1; i>=0; i--) d[i]=max(d[i],d[i+1]);\n    for(int i=0; i<n; i++) ans=min(ans,a[i].F+d[i+1]);\n    for(int i=0; i<n; i++) swap(a[i].F,a[i].S);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[100001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[y] = max(wh[y], x);\n\t\tat_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[h - 1] + (h - 1);\n    x_position = wh[h - 1];\n    y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[b]) {\n\t\t\tx_position = wh[y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << min(MIN,min(at_most_w,at_most_h)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tint n,a,b;\n\tscanf(\"%d%d%d\",&n,&n,&n);\n\tvector<pair<int,int> >v;\n\tmultiset<int>se;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tv.emplace_back(a,b);\n\t\tse.insert(b);\n\t}\n\tsort(v.begin(),v.end());\n\tint r=min(v.rbegin()->first,*se.rbegin());\n\tfor(int i=0;i<n-1;i++){\n\t\tse.erase(v[i].second);\n\t\tr=min(r,v[i].first+*se.rbegin());\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint w,h,n,i,x,y,z[100000],cnt;\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<h;i++) z[i]=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tif(z[x]<y) z[x]=y;\n\t}\n\tcnt=w-1; y=0;\n\tfor(i=w-2;i>=0;i--){\n\t\tif(y<z[i+1]) y=z[i+1];\n\t\tif(cnt>i+y) cnt=i+y;\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = long long;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nint main() {\n\tint w, h, n; scanf(\"%d%d%d\", &w, &h, &n);\n\tstd::vector<std::vector<int>> vec(h);\n\tfor(int i = 0; i < n; i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\n\t\tvec[y].push_back(x);\n\t}\n\n\tint ans = 1 << 30, tmp = 0;\n\tfor(int i = h - 1; i >= 0; i--) {\n\t\tans = std::min(ans, i + tmp);\n\t\tsort(begin(vec[i]), end(vec[i]));\n\t\tif(!vec[i].empty()) tmp = std::max(tmp, vec[i].back());\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint main(){\n    int W,H,N;\n    VP V;\n    VE x,y,z;\n    cin>>W>>H>>N;\n    int MX=-1,MY=-1;\n    FOR(i,0,N){\n        int X,Y;\n        cin>>X>>Y;\n        V.PB(MA(X,Y));\n        MX=max(MX,X);\n        MY=max(MY,Y);\n        if(X>Y){\n            y.PB(Y);\n        }else if(X<Y){\n            x.PB(X);\n        }else{\n            z.PB(X);\n        }\n    }\n    sort(V.begin(),V.end());\n    int mx=V.back().FI,my=V.back().SE;\n    if(mx==MX&&my==MY){\n        cout<<min(MX,MY)<<endl;\n    }else{\n        sort(x.begin(),x.end());\n        sort(y.begin(),y.end());\n        sort(z.begin(),z.end());\n        if(z.empty()){\n            cout<<x.back()+y.back()<<endl;\n        }else if(x.empty()&&y.empty()){\n            cout<<z.back()<<endl;\n        }else if(x.empty()){\n            if(z.back()<=y.back()){\n                cout<<y.back()<<endl;\n            }else{\n                cout<<z.back()<<endl;\n            }\n        }else if(y.empty()){\n            if(z.back()<=x.back()){\n                cout<<x.back()<<endl;\n            }else{\n                cout<<z.back()<<endl;\n            }\n        }else{\n            if(z.back()<=x.back()&&z.back()<=y.back()){\n                cout<<x.back()+y.back()<<endl;\n            }else{\n                if(x.back()<=y.back()){\n                    cout<<x.back()+z.back()<<endl;\n                }else{\n                    cout<<z.back()+y.back()<<endl;\n                }\n            }\n        }\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[10001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[y] = max(wh[y], x);\n\t\tat_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[h - 1] + (h - 1);\n    x_position = wh[h - 1];\n    y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[b]) {\n\t\t\tx_position = wh[y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << min(MIN,min(at_most_w,at_most_h)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100001,flag=0;\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    if(sum==100001)sum=min(W-1,H-1);\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100000,flag=0;\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    cout<<sum;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint X[101010];\nint W,H,N;\nint main(){\n  cin >> W >> H >> N;\n  rep(i,0,N - 1){\n    int a,b;\n    cin >> a >> b;\n    X[b] = max(X[b],a);\n  }\n  for(int i = H - 1;i >= 1;i--){\n    X[i - 1] = max(X[i - 1],X[i]);\n  }\n  int ans = W + H;\n  rep(i,0,H - 1){\n    ans = min(ans , i + X[i + 1]);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define ITERATOR map<int,int>::iterator\nusing namespace std;\nclass point {\npublic:\n\tint x;\n\tint y;\n\tvoid in() {\n\t\tcin >> x >> y;\n\t}\n};\nbool compare(point&a, point&b) {\n\treturn a.x < b.x;\n}\n\nvoid add(map<int, int>&, int);\nint gmax(map<int, int>&);\nvoid del(map<int, int>&, int);\n\nint main() {\n\tint a, N;\n\tcin >> a >> a >> N;\n\tvector<point> line(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tline[i].in();\n\t}\n\tsort(line.begin(), line.end(), compare);\n\tmap<int, int> ma;\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd(ma, line[i].y);\n\t}\n\tint ans = gmax(ma);\n\tfor (int i = 0; i < N; ++i) {\n\t\tdel(ma, line[i].y);\n\t\tans = min(ans, line[i].x + gmax(ma));\n\t}\n\tcout << ans << endl;\n\treturn false;\n}\n\nvoid del(map<int, int>&ma, int y) {\n\tif (ma[y] == 1) {\n\t\tma.erase(y);\n\t}\n\telse {\n\t\t--ma[y];\n\t}\n\treturn;\n}\nint gmax(map<int, int>&ma) {\n\tif (ma.empty()) {\n\t\treturn 0;\n\t}\n\tITERATOR pt = ma.end();\n\t--pt;\n\treturn pt->first;\n}\nvoid add(map<int, int>&ma, int y) {\n\tITERATOR pt = ma.find(y);\n\tif (pt == ma.end()) {\n\t\tma[y] = 1;\n\t}\n\telse {\n\t\t++ma[y];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) FOR(i,0,n)\n#define repr(i,n) for(int i=(n)-1;0<=i;--i)\n#define each(e,v) for(auto&& e:(v))\n#define all(v) begin(v),end(v)\n#define dump(x) cerr<<#x<<\": \"<<(x)<<endl\n#define INF 100000000\n#define IINF 9999999999999;\nusing vint = vector<int>;\nusing ll = long long;\nusing vll = vector<ll>;\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int W, H, N;\n    cin >> W >> H >> N;\n    vector<int> X(W);\n    rep(i, N) {\n        int x, y;\n        cin >> x >> y;\n        X[x] = max(X[x], y);\n    }\n    int ans = INF;\n    int temp = 0;\n    repr(i, W) {\n        ans = min(ans, i + temp);\n        temp = max(temp, X[i]);\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while ( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, INF);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if ( a >= r || b <= l ) return INF;\n    if ( a <= l && r <= b ) return tree[k];\n    return min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while ( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = min(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\n\nsigned main() {\n  int W, H, N;\n  SegT t1(100001), t2(100001);\n  int Y[100001] = {0}, X[100001] = {0};\n\n  cin >> W >> H >> N;\n  Rep(i, N) {\n    int x, y;\n    cin >> x >> y;\n    Y[y] = max(Y[y], x);\n    X[x] = max(X[x], y);\n  }\n\n  Rep(i, W) {\n    t1.update(i, -Y[i]);\n  }\n\n  Rep(i, H) {\n    t2.update(i, -X[i]);\n  }\n\n  int ans = min(W-1, H-1);\n  Rep(i, W-1) {\n    ans = min(ans, i + -t1.rmq(i+1, W));\n  }\n\n  Rep(i, H-1) {\n    ans = min(ans, i + -t2.rmq(i+1, H));\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing uint = unsigned int;\nusing int64 = long long;\nusing i64 = int64;\nusing uint64 = unsigned long long;\nusing vint = vector<int>;\nusing vint64 = vector<int64>;\ntemplate<typename T>\nusing p_que = priority_queue<T>;\n#define rep(i,N) for(int i=0;i<(int)(N);++i)\n#define rep1(i,N) for(int i=1;i<=(int)(N);++i)\n#define fs first\n#define sc second\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n\nconst int INF = (1 << 30) - 1;\nconst long long INF64 = (1ll << 60) - 1;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tos << \"[\";\n\tfor (auto& e : v) os << e << \", \";\n\treturn os << \"]\";\n}\n\ntemplate<class T, class U> ostream& operator<<(ostream& os, const pair<T, U> p) {\n\treturn os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate<class T, class U> ostream& operator<<(ostream& os, const map<T, U>& mp) {\n\tos << \"{\";\n\tfor (auto& e : mp) os << e << \" \";\n\treturn os << \"}\";\n}\n\nvoid Main();\nsigned main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tMain();\n}\n\n/* Cut from here! */\n\ntemplate <uint mod> struct ModInt {\n\tuint x;\n\tModInt(int64_t y = 0) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\tModInt& operator+=(const ModInt& p) {\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt& p) {\n\t\tx = (int)(1ll * x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt& p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt operator-() const {\n\t\treturn ModInt(-x);\n\t}\n\tModInt operator+(const ModInt& p) const {\n\t\treturn ModInt(*this) += p;\n\t}\n\tModInt operator-(const ModInt& p) const {\n\t\treturn ModInt(*this) -= p;\n\t}\n\tModInt operator*(const ModInt& p) const {\n\t\treturn ModInt(*this) *= p;\n\t}\n\tModInt operator/(const ModInt& p) const {\n\t\treturn ModInt(*this) /= p;\n\t}\n\tbool operator==(const ModInt& p) const {\n\t\treturn x == p.x;\n\t}\n\tbool operator!=(const ModInt& p) const {\n\t\treturn x != p.x;\n\t}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(int64_t n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}return ret;\n\t}\n\tfriend ostream& operator<<(ostream& os, const ModInt& p) {\n\t\treturn os << p.x;\n\t}\n};\n\ntemplate <typename Monoid> \nstruct SegmentTree {\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid& x) {\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; --k) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid& x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int& k) const {\n\t\treturn seg[k + sz];\n\t}\n};\n\n//#define int long long\nconst uint MOD = 1e9 + 7;\n\ntemplate<typename T>\nT gcd(T x, T y) {\n\tif (x == 0 || y == 0) return 1;\n\tT r;\n\twhile ((r = y % x) != 0) {\n\t\ty = x;\n\t\tx = r;\n\t}\n\treturn x;\n}\n\nvoid Main() {\n\tint W, H, N; cin >> W >> H >> N;\n\tusing pi = pair<int, int>;\n\tvector<pi> v(N);\n\trep(i, N) cin >> v[i].fs >> v[i].sc;\n\tsort(all(v));\n\n\tSegmentTree<int> seg(N, [](int l, int r) {return max(l, r); }, 0);\n\trep(i, N) {\n\t\tseg.set(i, v[i].sc);\n\t}\n\tseg.build();\n\n\tint ans = INF;\n\trep(i, W) {\n\t\tpi target = pi(i, INF);\n\t\tauto itr = upper_bound(all(v), target);\n\n\t\tint idx = itr - v.begin();\n\t\tint res = seg.query(idx, N) + i;\n\n\t\tans = min(ans, res);\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint main(void)\n{\n\tint w,h,n;\n\tP pp[100001];\n\tint i;\n\t\n\tcin>>w>>h>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>pp[i].F>>pp[i].S;\n\t}\n\t\n\tsort(pp,pp+n);\n\t\n\tint MIN=pp[n-1].F;\n\tint MAX=0;\n\tfor(i=n-2;i>=0;i--){\n\t\t//cout<<\"MAX=\"<<MAX<<endl;\n\t //\tcout<<\"P#=\"<<pp[i+1].S<<endl;\n\t\tMAX=max(MAX,pp[i+1].S);\n\t\t//cout<<\"MAX=\"<<MAX<<endl;\n\t\t//cout<<\"MIN=\"<<MIN<<endl;\n\t\t//cout<<\"P!=\"<<pp[i].F<<endl;\n\t\tMIN=min(MIN,pp[i].F+MAX);\n\t\t//cout<<\"MIN=\"<<MIN<<endl;\n\t\t\n\t}\n\tMAX=max(MAX,pp[0].S);\n\tMIN=min(MIN,0+MAX);\n\tcout<<MIN<<endl;\n\treturn 0;\n}\n\t\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long;\n\nll w, h, n;\nll x, y;\nll d[100005];\nll ans = 1ll << 60ll;\n\nint main() {\n    cin >> w >> h >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> x >> y;\n        \n        d[x] = max(d[x], y);\n    }\n\n    for (int i = w - 2; i >= 0; i--) {\n        d[i] = max(d[i], d[i + 1]);\n    }\n\n    for (int i = 0; i < w; i++) {\n        ans = min(ans, i + d[i + 1]);\n    }\n\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define rep(i, a, n) for(int i = a;i < n;++i)\n#define repe(i, a, n) for(int i = a;i <= n;++i)\n#define repr(i, a, n) for(int i = a;i > n;--i)\n#define reper(i, a, n) for(int i = a;i >= n;--i)\nusing namespace std;\n\n\nint w, h, n;\nint seg[131072*2 - 1];\nint N;\n\n\nint p(int i){\n\treturn (int)((i-1) / 2);\n}\n\n\nvoid update(int i){\n\tif(i == 0) return;\n\tif(seg[p(i)] >= seg[i]) return;\n\tseg[p(i)] = seg[i];\n\tupdate(p(i));\n}\n\n\nvoid init(){\n\trep(i, N-1, h+N-1) update(i);\n}\n \n \nint qmax(int a, int b, int k = 0, int l = 0, int r = N){\n\tif(r <= a || b <= l) return -1;\n\tif(a <= l && r <= b) return seg[k];\n\t\n\tint vl = qmax(a, b, 2*k+1, l, (l+r)/2);\n\tint vr = qmax(a, b, 2*k+2, (l+r)/2, r);\n\treturn max(vl, vr);\n}\n\n\nint solve(){\n\tint c = 999999999;\n\trep(i, 0, h-1){\n\t    c = min(c, i+qmax(i+1, h));\n\t}\n\tc = min(c, h-1);\n\treturn c;\n}\n\n\nint main(){\n\tcin >> w >> h >> n;\n\tN = (int)pow(2, (int)floor(log2(h))+1);\n\t\n\trep(i, 0, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tseg[y+N-1] = max(seg[y+N-1], x);\n\t}\n\t\n\tinit();\n\t\n\tcout << solve() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint main(){\n\tint w,h,n;\n\tcin >> w >> h >> n;\n\tstd::vector<int> py(n);\n\tstd::vector<int> px(n);\n\tstd::vector<pair<int,int> > x(n);\n\tstd::vector<pair<int,int> > y(n);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> px[i] >> py[i];\n\n\t\tx[i]=std::make_pair(px[i], i);\n\t\ty[i]=std::make_pair(py[i], i);\n\t}\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\n\tvector<int> rmax(n+1,0);\n\tfor(int i = n - 1; i != -1; --i){\n\t\trmax[i] = max(rmax[i+1], py[x[i].second]);\n\t}\n\n\tint val = y[n-1].first;\n\tfor(int i = 0; i < n; ++i){\n\t\tval = min(val, rmax[i + 1] + x[i].first);\n\t}\n\tcout << val << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n  int w,h,n; cin >> w >> h >> n;\n  vector<int> xmax(h+1); xmax[h]=0;\n  for(int i=0;i<n;++i){\n    int x,y;\n    cin >> x >> y;\n    xmax[y]=max(xmax[y],x);\n  }\n  int ans=1e9,maxi=0;\n  for(int i=h-1;i>=0;--i) {\n    maxi=max(maxi,xmax[i+1]);\n    ans=min(ans,maxi+i);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod (ll)(1e9+7)\n#define int ll\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nsigned main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n  P wd[100001], yd[100001];\n  int ans = 1145141919810;\n  int kx = 0, ky = 0;\n  rep(i, 0, n) {\n    int x, y;\n    cin >> x >> y;\n    wd[i] = {x, y};\n    yd[i] = {y, x};\n    // kx = max(kx, x);\n    // ky = max(ky, y);\n  }\n\n  //ans = min(kx, ky);\n\n  sort(wd, wd + n);\n  sort(yd, yd + n);\n  int mx = 0, my = 0;\n  dep(i, n - 1, 0) {\n    ans = min(ans, wd[i].first + my);\n    my = max(my, wd[i].second);\n  }\n  dep(i, n - 1, 0) {\n    ans = min(ans, yd[i].first + mx);\n    mx = max(mx, yd[i].second);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint xmax[100005];\nint main(){\n  int w, h, n;\n  cin >> w >> h >> n;\n  fill(xmax, xmax+h+1, 0);\n  for(int i=0; i<n; i++) {\u000b    int x, y;\n    cin >> x >> y;\n    xmax[y]=max(xmax[y], x);\n  }\n  for(int i=h-2; i>=0; i--){\n    xmax[i]=max(xmax[i], xmax[i+1]);\n  }\n  int ans=INT_MAX;\n  for(int i=0; i<h; i++){\n    ans=min(ans, i+xmax[i+1]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\ntemplate<typename T, T INF>\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\n private:\n  inline int left_child(int node) const {return node << 1;}\n  inline int right_child(int node) const {return (node << 1) + 1;}\n  inline T merge(T vl, T vr) const {return std::max(vl, vr);}\n  inline void propagate(int k) {\n    if(k < size_) {\n      lazy_.at(left_child(k)) += lazy_.at(k);\n      lazy_.at(right_child(k)) += lazy_.at(k);\n    }\n    node_.at(k) += lazy_.at(k);\n    lazy_.at(k) = 0;\n  }\n  T find(int a, int b, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return -INF;\n    if(a <= l && r <= b) return node_.at(k) + lazy_.at(k);\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return merge(vl, vr);\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return node_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (lazy_.at(k) += value);\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = merge(vl, vr);\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  const int INF = 2e5;\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  SegmentTree<int, INF> T(INF);\n  for(auto i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y;\n    if(T.find(x, x) < y) T.add(x, x, y - T.find(x, x));\n  }\n\n  int res = INF;\n\n  for(auto x = 0; x < INF; ++x) {\n    res = min(res, x + T.find(x + 1, INF));\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\ntemplate<typename T, T INF>\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\n private:\n  inline int left_child(int node) const {return node << 1;}\n  inline int right_child(int node) const {return (node << 1) + 1;}\n  inline T merge(T vl, T vr) const {return std::max(vl, vr);}\n  inline void propagate(int k) {\n    if(k < size_) {\n      lazy_.at(left_child(k)) += lazy_.at(k);\n      lazy_.at(right_child(k)) += lazy_.at(k);\n    }\n    node_.at(k) += lazy_.at(k);\n    lazy_.at(k) = 0;\n  }\n  T find(int a, int b, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return -INF;\n    if(a <= l && r <= b) return node_.at(k) + lazy_.at(k);\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return merge(vl, vr);\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return node_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (lazy_.at(k) += value);\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = merge(vl, vr);\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  const int INF = 2e5;\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  SegmentTree<int, INF> T(INF);\n  for(auto i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y;\n    T.add(x,x,y);\n  }\n\n  int res = INF;\n\n  for(auto x = 0; x < INF; ++x) {\n    res = min(res, x + T.find(x + 1, INF));\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\npair<int,int> z[100010];\nint h,w,n;\nint main(){\n\tcin>>w>>h>>n;\n\tlol(i,n)cin>>z[i].first>>z[i].second;\n\tsort(z,z+n,greater<pair<int,int> >());\n\tint ans=mod,maxi=0;\n\tlol(i,n){\n\t\tans=min(ans,maxi+z[i].first);\n\t\tmaxi=max(maxi,z[i].second);\n\t}\n\tans=min(ans,maxi);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint main(){\n    int W,H,N;\n    VP Vx,Vy;\n    VE x,y;\n    cin>>W>>H>>N;\n    int MX=-1,MY=-1;\n    FOR(i,0,N){\n        int X,Y;\n        cin>>X>>Y;\n        Vx.PB(MA(X,Y));\n        Vy.PB(MA(Y,X));\n        MX=max(MX,X);\n        MY=max(MY,Y);\n        if(X>Y){\n            y.PB(Y);\n        }else if(X<Y){\n            x.PB(X);\n        }else{\n            x.PB(X);\n            y.PB(Y);\n        }\n    }\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(Vx.begin(),Vx.end());\n    sort(Vy.begin(),Vy.end());\n    int mx=Vx.back().FI,my=Vx.back().SE;\n    if(mx==MX&&my==MY){\n        cout<<min(MX,MY)<<endl;\n    }else{\n        int num=max(x.back(),y.back());\n        int nx=upper_bound(Vx.begin(),Vx.end(),MA(num,INF))-Vx.begin();\n        int ny=upper_bound(Vy.begin(),Vy.end(),MA(num,INF))-Vy.begin();\n        int ax=-1,ay=-1;\n        FOR(i,nx,N){\n            ax=max(ax,min(Vx[i].FI-num,Vx[i].SE));\n        }\n        FOR(i,ny,N){\n            ay=max(ay,min(Vy[i].FI-num,Vy[i].SE));\n        }\n        cout<<num+min(ax,ay)<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\nusing LL=long long;\nusing VI=vector<int>;\t\tusing VL=vector<LL>;\nusing VS=vector<string>;\tusing VD=vector<double>;\nusing VVI=vector<VI>;\t\tusing VVL=vector<VL>;\nusing PII=pair<int, int>;\tusing PLL=pair<LL, LL>;\nusing VP=vector<PII>;\t\tusing VPL=vector<PLL>;\nconst int inf = (int)1e9;\tconst double PI = acos(-1.0);\nconst LL MOD = 1000000007;\tconst double EPS = 1e-10;\nconst int dx[] = { -1,0,1,0,-1,-1,1,1 }, dy[] = { 0,1,0,-1,-1,1,-1,1 };\n\ntemplate<class T>void Sort(T& a) { sort(all(a)); }\ntemplate<class T>void RSort(T& a) { sort(rall(a)); }\ntemplate<class T>void Reverse(T& a) { reverse(all(a)); }\ntemplate<class T>void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>T Sorted(T a) { Sort(a); return a; }\ntemplate<class T>T RSorted(T a) { RSort(a); return a; }\ntemplate<class T>T Reversed(T a) { Reverse(a); return a; }\ntemplate<class T>T Uniqued(T a) { Unique(a); return a; }\ntemplate<class T>auto Max(const T& a) { return *max_element(all(a)); }\ntemplate<class T>auto Min(const T& a) { return *min_element(all(a)); }\ntemplate<class T>int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>int Count(const T& a, const  U& v) { return count(all(a), v); }\ntemplate<class T, class U>int Find(const T& a, const U& v) { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>U Sum(const T& a, const U& v) { return accumulate(all(a), v); }\ntemplate<class T, class U>int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>void RemoveIf(T& a, P f) { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>T Age(T n, T m) { return (n + m - 1) / m; }\ntemplate<class T>T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\ntemplate<class T>T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>T Powmod(T a, T n, T m = MOD) { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nstring operator*(string s, int n) { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\ntemplate<class T>T InputF() { T ret; cin >> ret; return ret; }\ntemplate<> char InputF() {\n\tchar ret = '\\0', c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n' && c != '\\t' && c != ' ') { ret = c; c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<> string InputF() {\n\tstring ret; char c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n' && c != '\\t' && c != ' ') { ret.push_back(c); c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<> int InputF() {\n\tint ret = 0; bool neg = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile ('0' <= c && c <= '9') { ret = ret * 10 + (c - '0'); c = getchar_unlocked(); }\n\treturn neg ? -ret : ret;\n}\ntemplate<> LL InputF() {\n\tLL ret = 0; bool neg = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile ('0' <= c && c <= '9') { ret = ret * 10LL + (LL(c) - LL('0')); c = getchar_unlocked(); }\n\treturn neg ? -ret : ret;\n}\ntemplate<> double InputF() {\n\tdouble ret = 0, dp = 1; bool neg = false, adp = false; char c = getchar_unlocked();\n\tif (c == '-') { neg = true; c = getchar_unlocked(); }\n\twhile (('0' <= c && c <= '9') || c == '.') {\n\t\tif (c == '.') {\n\t\t\tadp = true;\n\t\t} else if (adp) {\n\t\t\tdp *= 0.1; ret += (c - '0') * dp;\n\t\t} else {\n\t\t\tret = ret * 10.0 + (c - '0');\n\t\t}\n\t\tc = getchar_unlocked();\n\t}\n\treturn neg ? -ret : ret;\n}\nstring GetLine() {\n\tstring ret; char c = getchar_unlocked();\n\twhile (c != '\\0' && c != '\\n') { ret.push_back(c); c = getchar_unlocked(); }\n\treturn ret;\n}\ntemplate<class T>T Parse(string s) { return s; }\ntemplate<> char Parse(string s) { return s.front(); }\ntemplate<> string Parse(string s) { return s; }\ntemplate<> int Parse(string s) { return stoi(s); }\ntemplate<> LL Parse(string s) { return stoll(s); }\ntemplate<> double Parse(string s) { return stod(s); }\n\nVS InputB;\ntemplate<class T>struct InputC {\n\toperator T() { return InputF<T>(); }\n\tvector<T> operator[](int h) {\n\t\tvector<T> ret(h);\n\t\trep(i, h)ret[i] = InputF<T>();\n\t\treturn ret;\n\t}\n\tvector<vector<T>> operator[](PII p) {\n\t\tint h, w; tie(h, w) = p;\n\t\tvector<vector<T>> ret(h, vector<T>(w));\n\t\trep(i, h)rep(j, w)ret[i][j] = InputF<T>();\n\t\treturn ret;\n\t}\n\tT operator()(int n) {\n\t\twhile (sz(InputB) <= n)InputB.pb(InputF<string>());\n\t\treturn Parse<T>(InputB[n]);\n\t}\n\tvector<T> operator()(int n, int h) {\n\t\tvector<T> ret(h);\n\t\trep(i, h)ret[i] = operator()(i + n);\n\t\treturn ret;\n\t}\n\tvector<vector<T>> operator()(int n, int h, int w) {\n\t\tvector<vector<T>> ret(h, vector<T>(w));\n\t\trep(i, h)rep(j, w)ret[i][j] = operator()(n + i * w + j);\n\t\treturn ret;\n\t}\n};\nInputC<char> inc; InputC<string> ins; InputC<int> ini; InputC<LL> inl; InputC<double> ind;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f;\n\tBoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\");\nstruct DivStr {\n\tconst char* d, * l;\n\tDivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Print {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) { printf(\"%d\", v); }\n\tvoid p(long long v) { printf(\"%lld\", v); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(bool v) { printf(v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) {\n\t\tp(v.first); printf(\"%s\", D.d); p(v.second);\n\t}\n\ttemplate<class T>void p(const vector<T>& v) {\n\t\tfor (int i = 0, s = v.size(); i < s; ++i) { if (i)printf(D.d); p(v[i]); }\n\t}\n\ttemplate<class T>void p(const vector<vector<T>>& v) {\n\t\tfor (int i = 0, s = v.size(); i < s; ++i) { if (i)printf(D.l); p(v[i]); }\n\t}\n\tvoid p(const BoolStr& v) { B = v; }\n\tvoid p(const DivStr& v) { D = v; }\n\ttemplate<class T>bool isPrint(const T& v) {\n\t\treturn !is_same<BoolStr, T>::value && !is_same<DivStr, T>::value;\n\t}\npublic:\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint(h))printf(D.l); B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint(h))printf(D.d); operator()(forward<T>(t)...);\n\t}\n}out;\n\n// --- answer --- //\ntemplate<class T>struct Answer {\n\tT min, max, sum; int cnt;\n\tAnswer() :min(numeric_limits<T>::max()), max(numeric_limits<T>::min()), sum(0), cnt(0) {}\n\tvoid operator=(T n) { min = std::min(min, n); max = std::max(max, n); sum += n; cnt++; }\n\toperator bool() { return cnt; }\n};\n\n// --- dump --- //\n// #define LOCAL\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif // LOCAL\n\n\nclass Step {\n\tstruct It {\n\t\tint x, s;\n\t\tIt(int _x, int _s) :x(_x), s(_s) { assert(s); }\n\t\tint operator*() { return x; }\n\t\tbool operator!=(It& i) { return 0 < s ? x < i.x : x >= i.x; }\n\t\tvoid operator++() { x += s; }\n\t};\n\tint x, y, s;\npublic:\n\tStep(int _y, int _s = 1) :x(0 < _s ? 0 : _y), y(0 < _s ? _y : 0), s(_s) {}\n\tStep(int _x, int _y, int _s) :x(_x), y(_y), s(_s) {}\n\tIt begin() { return { x,s }; }\n\tIt end() { return { y,s }; }\n};\n\nint main() {\n\tint w = ini, h = ini, n = ini;\n\tVI m(w, -1);\n\trep(i, n) {\n\t\tint x = ini, y = ini;\n\t\tchmax(m[x], y);\n\t}\n\tVI a(w, 0);\n\tfor (auto i : Step(w - 2, -1)) {\n\t\ta[i] = max(a[i + 1], m[i + 1]);\n\t}\n\tint ans = inf;\n\trep(i, w) {\n\t\tchmin(ans, i + a[i]);\n\t}\n\tout(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <string>\n#include <stack>\n#include <cmath>\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\nusing namespace std;\n//\nconst int inf=1e9+7;\nconst int mod=1e9+7;\n//\nstruct poi{\n\tint X;int Y;int Z;\n\tbool operator<(const poi&R)const{\n\t\treturn X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n\t}\n};\n//\nll GCD(ll a,ll b){\n\treturn (b==0)?(a):(GCD(b,a%b));\n}\nll LCM(ll a,ll b){\n\treturn a/GCD(a,b)*b;\n}\n//\n//\nint main(){\n\tint W,H,N;\n\tcin>>W>>H>>N;\n\tvector<pair<int,int> > V(N);\n\tpair<int,int> cnt[100000];\n\tfill(cnt,cnt+W,make_pair(-1,-1));\n\tFOR(i,0,N){\n\t\tint X,Y;\n\t\tcin>>X>>Y;\n\t\tif(cnt[X].first<Y){\n\t\t\tcnt[X]=make_pair(Y,i);\n\t\t}\n\t\tV[i]=make_pair(X,Y);\n\t}\n\tvector<pair<int,int> > vv;\n\tFOR(i,0,W){\n\t\tif(cnt[i].first!=-1){\n\t\t\tvv.push_back(V[cnt[i].second]);\n\t\t}\n\t}\n\tsort(vv.rbegin(),vv.rend());\n\tint now=-1;\n\tvector<pair<int,int> > v;\n\tFOR(i,0,vv.size()){\n\t\tif(now<vv[i].second){\n\t\t\tv.push_back(vv[i]);\n\t\t\tnow=vv[i].second;\n\t\t}\n\t}\n\treverse(v.begin(),v.end());\n\tif((int)v.size()==1){\n\t\tcout<<min(v[0].first,v[0].second)<<endl;\n\t}else{\n\t\tint ans=min(v[0].second,v[v.size()-1].first);\n\t\tFOR(i,0,v.size()-1){\n\t\t\tans=min(ans,v[i].first+v[i+1].second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n#include<ctime>\n#include<string>\n#include<cstdlib>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<functional>\n#include<string.h>\n#include<limits.h>\n#define P pair<int,int>\nusing namespace std;\n\nvector<P>V;\nsigned main() {\n \tint a, b, n; cin >> a >> b >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, d; cin >> c >> d;\n\t\tV.push_back({ c,d });\n\t}\n\tV.push_back({ 0, 0 });\n\tsort(V.begin(), V.end(), greater<P>());\n\tint ans = 1 << 29;\n\tint MAX = 0;\n\tfor (int i = 0; i < V.size() - 1; i++) {\n\t\tans = min(ans, MAX + V[i].first);\n\t\tMAX = max(MAX, V[i].second);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1001001001;\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n\n  vector<int> a(h + 2, 0);\n\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n\n    a[y] = max(a[y], x);\n  }\n\n  int ans = inf;\n  for (int i = h; i >= 0; --i) {\n    ans = min(ans, i + a[i + 1]);\n    a[i] = max(a[i], a[i + 1]);\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n\n  int a = 0, b = 0, c = 0;\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n\n    if (x == y) {\n      c = max(c, x);\n      continue;\n    }\n\n    if (x < y) y = 0;\n    else x = 0;\n\n    a = max(a, x);\n    b = max(b, y);\n  }\n\n  if (a < b) swap(a, b);\n  if (a < c) a = c;\n\n  cout << a + b << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll MOD=10000000;\nconst ll INF=1000000001;\nconst ll LINF=4000000000000000010;\nconst double EPS=1e-9;\nint dx[5]={0,1,0,-1,0};\nint dy[5]={1,0,-1,0,0};\nvector<int> v[100010];\nint ma[100010];\nint main(){\n    int w,h,n;cin>>w>>h>>n;\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        v[x].push_back(y);\n    }\n    for(int i=w-1;i>=1;i--){\n        int maa=0;\n        for(auto a:v[i]){\n            maa=max(a,maa);\n        }\n        ma[i-1]=max(ma[i],maa);\n    }\n    int ans=INF;\n    for(int i=0;i<w;i++){\n        int s=i+ma[i];\n        ans=min(s,ans);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nint main () {\n\tint w = ri();\n\tint h = ri();\n\tint n = ri();\n\tstd::pair<int, int> a[n];\n\tfor (int i = 0; i < n; i++) a[i].first = ri(), a[i].second = ri();\n\tstd::sort(a, a + n);\n\tint res = 1000000000;\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tres = std::min(res, max + a[i].first);\n\t\tmax = std::max(max, a[i].second);\n\t}\n\tint res1 = 0;\n\tfor (int i = 0; i < n; i++) res1 = std::max(res1, a[i].second);\n\tstd::cout << std::min(res, res1) << std::endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int, int>;\nusing P3 = pair<int, P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1 << 30;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int di[] = {0, 1, 0, -1};\nconstexpr int dj[] = {1, 0, -1, 0};\n\nbool solve(){\n    int h, w, n;\n    cin >> w >> h >> n;\n    vector<P> pos(n);\n    for(int i=0;i<n;i++){\n        cin >> pos[i].first >> pos[i].second;\n    }\n    int ans = INF;\n    for(int t=0;t<2;t++){\n        sort(pos.begin(),pos.end());\n        vector<int> maxi(n,0);\n        for(int i=n-2;i>=0;i--){\n            maxi[i] = max(maxi[i+1], pos[i+1].second);\n        }\n        for(int i=0;i<n;i++){\n            ans = min(ans, pos[i].first + maxi[i]);\n        }\n        for(int i=0;i<n;i++){\n            swap(pos[i].first, pos[i].second);\n        }\n    }\n    cout << ans << endl;\n    return false;\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\ntemplate<typename T, T INF>\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\n private:\n  inline int left_child(int node) const {return node << 1;}\n  inline int right_child(int node) const {return (node << 1) + 1;}\n  inline T merge(T vl, T vr) const {return std::max(vl, vr);}\n  inline void propagate(int k) {\n    if(k < size_) {\n      lazy_.at(left_child(k)) += lazy_.at(k);\n      lazy_.at(right_child(k)) += lazy_.at(k);\n    }\n    node_.at(k) += lazy_.at(k);\n    lazy_.at(k) = 0;\n  }\n  T find(int a, int b, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return -INF;\n    if(a <= l && r <= b) return node_.at(k) + lazy_.at(k);\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return merge(vl, vr);\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return node_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (lazy_.at(k) += value);\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = merge(vl, vr);\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  const int INF = 1e6;\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  SegmentTree<int, INF> T(INF);\n  for(auto i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y;\n    if(T.find(x, x) < y) T.add(x, x, y);\n  }\n\n  int res = INF;\n\n  for(auto x = 0; x < INF; ++x) {\n    res = min(res, x + T.find(x + 1, INF));\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n\n#define lp(n) for (int i = 0; i < n; i++)\n#define LP(n,i) for (int i = 0; i < n; i++)\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint w, h, n, a[100000], mem, m, x, y;\nvector<pair<int, int>>xy;\n\nint main() {\n\tcin >> w >> h >> n;\n\tlp(n) {\n\t\tcin >> x >> y;\n\t\txy.push_back(mkp(x, y));\n\t}\n\tsort(xy.begin(), xy.end());\n\tm = n - 1;\n\tmem = 0;\n\tfor (int i = w-1; i != -1; i--) {\n\t\ta[i] = mem;\n\t\twhile (m!=-1&&xy[m].first == i) {\n\t\t\tmem = max(mem, xy[m].second);\n\t\t\tm--;\n\t\t}\n\t}\n\tmem = intmax;\n\tlp(w)\n\t\tmem = min(mem, a[i] + i);\n\tcout << mem << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=(j);i<(n);i++)\n#define erep(i,j,n) for(int i=(j);i<=(n);i++)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(),i.rend()\n#define INF 1e9\nconst int mod = 1e9+7;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pi;\ntypedef long long i64;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int w, h, n;\n  cin >> w >> h >> n;\n  vi ymax(w, 0), xmax(h, 0);\n  rep(i, 0, n) {\n    int x, y;\n    cin >> x >> y;\n    ymax[x] = max(ymax[x], y);\n    xmax[y] = max(xmax[y], x);\n  }\n\n  int ans = min(h, w) - 1;\n  {\n    int MAX = 0;\n    for(int i = w - 2; i >= 0; --i) {\n      MAX = max(MAX, ymax[i + 1]);\n      ans = min(ans, i + MAX);\n    }\n  }\n  {\n    int MAX = 0;\n    for(int i = h - 2; i >= 0; --i) {\n      MAX = max(MAX, xmax[i + 1]);\n      ans = min(ans, i + MAX);\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint W,H,N;\n\nsigned main(){\n    cin>>W>>H>>N;\n    vpint p;\n    rep(i,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb({x,y});\n    }\n    sort(all(p));\n\n    int ma=0;\n    int ans=INT_MAX;\n    for(int i=N-1;i>=0;i--){\n        chmin(ans,p[i].fi+ma);\n        chmax(ma,p[i].se);\n    }\n    chmin(ans,ma);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n\ntypedef std::pair<int, int> pi;\n\nint maxi(int a, int b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  int n, i, j, h, w;\n  scanf(\"%d%d%d\", &w, &h, &n);\n  pi p[n];\n  int max[w];\n  for(i = 0; i < w; ++i) max[i] = 0;\n  for(i = 0; i < n; ++i) scanf(\"%d%d\", &p[i].first, &p[i].second);\n  for(i = n - 1; i >= 0 && p[i].first; --i) {\n    if(!p[i].first) continue;\n    if(max[p[i].first - 1] < p[i].second) max[p[i].first - 1] = p[i].second;\n  }\n  for(i = h - 2; i >= 0; --i) max[i] = maxi(max[i + 1], max[i]);\n  //for(i = 0; i < h; ++i) printf(\"%d \", max[i]);\n  int ans = 999999999;\n  for(i = 0; i < h; ++i) {\n    if(ans > i + max[i]) ans = i + max[i];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define VI vector<int>\n#define VVI vector<vector<int>>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define MOD 1000000007\n#define INF 1e9\n#define F first\n#define S second\n#define All(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main(void){\n    int W,H,N,ans=INF;\n    cin>>W>>H>>N;\n    VI ymax(W+1,0);\n    REP(i,N){\n        int x,y;\n        cin>>x>>y;\n        ymax[x]=max(ymax[x],y);\n    }\n    REPR(i,W-2){\n        ymax[i]=max(ymax[i],ymax[i+1]);\n        //cout<<ymax[i]<<\" \"<<i<<endl;\n    }\n    REP(i,W){\n        ans=min(ans,i+ymax[i+1]);\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define rep(i, a, n) for(int i = a;i < n;i++)\nusing namespace std;\n\n\nint w, h, n;\nint seg[131072*2 - 1];\nint N;\n\n\nint p(int i){\n\treturn (int)((i-1) / 2);\n}\n\n\nvoid update(int i){\n\tif(i == 0) return;\n\tif(seg[p(i)] >= seg[i]) return;\n\tseg[p(i)] = seg[i];\n\tupdate(p(i));\n}\n\n\nvoid init(){\n\trep(i, N-1, h+N-1) update(i);\n}\n\n\nint qmax(int a, int b, int k = 0, int l = 0, int r = N){\n\tif(r <= a || b <= l) return -1;\n\tif(a <= l && r <= b) return seg[k];\n\n\tint vl = qmax(a, b, 2*k+1, l, (l+r)/2);\n\tint vr = qmax(a, b, 2*k+2, (l+r)/2, r);\n\treturn max(vl, vr);\n}\n\n\nint solve(){\n\tint c = 999999999;\n\trep(i, 0, h-1){\n\t\tc = min(c, i+qmax(i+1, h));\n\t}\n\tc = min(c, h-1);\n\treturn c;\n}\n\n\nint main(){\n\tcin >> w >> h >> n;\n\tN = (int)pow(2, (int)ceil(log2(h)));\n\t\n\trep(i, 0, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tseg[y+N-1] = max(seg[y+N-1], x);\n\t}\n\t\n\tinit();\n\t\n\tcout << solve() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,w-2)m[n-i-1]=max(m[n-i-1],m[n-i]);\n  r(i,w-2)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\n#ifndef MAX\n#define MAX 400000\n#endif\n\n//Range Update Query+Range Minimum Query\ntemplate<class T>\nclass RUQ_RMQ {\npublic:\n\tint n;\n\tT dat[MAX], lazy[MAX], DEFAULT;\n\tbool(*cmp)(T, T);\n\tvoid init(int n_,\n\t\tbool(*c)(T, T) = [](int a, int b) {return a < b; }, T d = INT_MAX) {\n\t\tcmp = c;\n\t\tDEFAULT = d;\n\t\tn = 1; while (n < n_)n <<= 1;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tdat[i] = lazy[i] = DEFAULT;\n\t\t}\n\t}\n\tinline void push(int k) {\n\t\tif (lazy[k] == DEFAULT)return;\n\t\tdat[k] = lazy[k];\n\t\tif (k < n - 1) {\n\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = DEFAULT;\n\t}\n\tinline void update_node(int k) {\n\t\tif (cmp(dat[k * 2 + 1], dat[k * 2 + 2]))dat[k] = dat[k * 2 + 1];\n\t\telse dat[k] = dat[k * 2 + 2];\n\t}\n\tinline void update(int a, int b, T x, int k, int l, int r) {\n\t\tpush(k);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = x; push(k); return;\n\t\t}\n\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t}\n\tinline T query(int a, int b, int k, int l, int r) {\n\t\tpush(k);\n\t\tif (r <= a || b <= l)return DEFAULT;\n\t\tif (a <= l&&r <= b)return dat[k];\n\t\tT lb = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT rb = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t\tif (cmp(lb, rb))return lb;\n\t\treturn rb;\n\t}\n\tinline void update(int a, int b, T x) {\n\t\tupdate(a, b, x, 0, 0, n);\n\t}\n\tinline void update(int a, T x) {\n\t\tupdate(a, a + 1, x);\n\t}\n\tinline T query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\tinline T query(int a) {\n\t\treturn query(a, a + 1);\n\t}\n};\n\nRUQ_RMQ<int>seg;\nP p[100000];\nint main(){\n\tint w,h,n;scanf(\"%d%d%d\",&w,&h,&n);\n\tseg.init(n,[](int a,int b){return a>b;},0);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&p[i].first,&p[i].second);\n\t}\n\tsort(p,p+n,[](P a,P b){\n\t\tif(a.first==b.first)return a.second>b.second;\n\t\treturn a.first<b.first;\n\t});\n\trep(i,n){\n\t\tseg.update(i,p[i].second);\n\t}\n\tint Min=INT_MAX;\n\trep(i,n+1){\n\t\tMin=min(Min,(i==0?0:p[i-1].first)+seg.query(i,n));\n\t}\n\tcout<<Min<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint main(){\n    int W,H,N;\n    VP V;\n    cin>>W>>H>>N;\n    FOR(i,0,N){\n        int X,Y;\n        cin>>X>>Y;\n        V.PB(MA(X,Y));\n    }\n    sort(V.begin(),V.end());\n    if(N==1){\n        cout<<min(V[0].FI,V[0].SE)<<endl;\n        return 0;\n    }\n    VP mid;\n    int now=0;\n    while(now<N-1){\n        while(now<N-1&&V[now].FI==V[now+1].FI){\n            now++; \n        }\n        mid.PB(V[now]);\n        now++;\n        if(now==N-1){\n            mid.PB(V[now]);\n        }\n    }\n    VP ans;\n    ans.PB(mid.back());\n    ROF(i,0,(int)mid.size()){\n        if(mid[i].SE>ans.back().SE){\n            ans.PB(mid[i]);\n        }\n    }\n    reverse(ans.begin(),ans.end());\n    int a=min(ans[0].SE,ans.back().FI);\n    FOR(i,0,(int)ans.size()-1){\n        a=min(a,ans[i].FI+ans[i+1].SE);\n    }\n    cout<<a<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint w,h,n,x[100000],y[100000],Xmax,cnt,flg[100000],kyori,ymax,i;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tXmax=0;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tif(Xmax<x[i]) Xmax=x[i];\n\t}\n\tfor(i=0;i<=Xmax;i++) flg[i]=-1;\n\tflg[0]=0;\n\tfor(i=0;i<n;i++){\n\t\tif(flg[x[i]]<y[i]) flg[x[i]]=y[i];\n\t}\n\t//for(i=0;i<=Xmax;i++) printf(\"flg[%d]=%d\\n\",i,flg[i]);\n\tkyori=1000000; ymax=0;\n\tfor(i=Xmax;i>=0;i--){\n\t\tif(flg[i]!=-1){\n\t\t\tif(kyori>ymax+i) kyori=ymax+i;\n\t\t\tif(ymax<flg[i]) ymax=flg[i];\n\t\t}\n\t\t//printf(\"i=%d ymax=%d\\n\",i,ymax);\n\t}\n\tprintf(\"%d\\n\",kyori);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define rep(i, a, n) for(int i = a;i < n;i++)\nusing namespace std;\n\n\nint w, h, n;\nint seg[131072*2 - 1];\nint N;\n\n\nint p(int i){\n\treturn (int)((i-1) / 2);\n}\n\n\nvoid update(int i){\n\tif(i == 0) return;\n\tif(seg[p(i)] >= seg[i]) return;\n\tseg[p(i)] = seg[i];\n\tupdate(p(i));\n}\n\n\nvoid init(){\n\trep(i, N-1, h+N-1) update(i);\n}\n\n\nint qmax(int a, int b, int k = 0, int l = 0, int r = N){\n\tif(r <= a || b <= l) return -1;\n\tif(a <= l && r <= b) return seg[k];\n\n\tint vl = qmax(a, b, 2*k+1, l, (l+r)/2);\n\tint vr = qmax(a, b, 2*k+2, (l+r)/2, r);\n\treturn max(vl, vr);\n}\n\n\nint solve(){\n\tint c = INT_MAX;\n\trep(i, 0, h-1){\n\t\tc = min(c, i+qmax(i+1, h));\n\t}\n\tc = min(c, h);\n\treturn c;\n}\n\n\nint main(){\n\tcin >> w >> h >> n;\n\tN = (int)pow(2, (int)ceil(log2(h)));\n\t\n\trep(i, 0, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tseg[y+N-1] = max(seg[y+N-1], x);\n\t}\n\t\n\tinit();\n\t\n\tcout << solve() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\npair<int,int> z[100010];\nint h,w,n;\nint main(){\n\tcin>>w>>h>>n;\n\tlol(i,n)cin>>z[i].first>>z[i].second;\n\tsort(z,z+n,greater<>());\n\tint ans=mod,maxi=0;\n\tlol(i,n){\n\t\tans=min(ans,maxi+z[i].first);\n\t\tmaxi=max(maxi,z[i].second);\n\t}\n\tans=min(ans,maxi);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[10001][10001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[x][y]++;\n\t\twh[w][y] = max(wh[w][y], x);at_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[w][h - 1] + (h - 1); x_position = wh[w][h - 1]; y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[w][b]) {\n\t\t\tx_position = wh[w][y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << min(MIN,min(at_most_w,at_most_h)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int w,h,n,x,y;\n  int d[100010]={};\n  cin >> w >> h >> n;\n  for(int i=0;i<n;i++){\n    cin >> x >> y;\n    d[y] = max(d[y],x);\n  }\n  \n  for(int i=h-1;i>=0;i--){\n    d[i] = max(d[i],d[i+1]);\n  }\n\n  int ans = h;\n  for(int i=0;i<h;i++){\n    ans = min(ans,i+d[i+1]);\n  }\n  cout << ans << endl;\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1001001001;\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n\n  vector<int> a(h + 2, 0);\n\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n\n    a[y] = max(a[y], x);\n  }\n\n  int ans = inf;\n  for (int i = h; i >= 0; --i) {\n    ans = min(ans, i + a[i + 1]);\n    a[i] = max(a[i], a[i + 1]);\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100001,flag=0;\n    int smaller=min(W-1,H-1);\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    if(sum>smaller)sum=smaller;\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int W, H, N;\n    cin >> W >> H >> N;\n    int x[N], y[N];\n    int l = 100001;\n    int t[l + 1]{};\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n        t[x[i]] = max(t[x[i]], y[i]);\n    }\n\n    int Y = 0;\n    int ans = 2 * l;\n    for (int i = l; i >= 0; i--) {\n        ans = min(ans, i + Y);\n        Y = max(Y, t[i]);\n    }\n    cout << ans << \"\\n\";\n    //\n    // for (int i = 0; i < N; i++) {\n    //     cout << d[i].x << \" \" << d[i].y << \"\\n\";\n    // }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int W, H, N, L[100000] = {};\n\n  scanf(\"%d %d %d\", &W, &H, &N);\n  for(int i = 0; i < N; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    L[x] = max(L[x], y);\n  }\n\n  int ret = INF, curr = 0;\n  for(int i = W - 1; i >= 0; i--) {\n    ret = min(ret, i + curr);\n    curr = max(curr, L[i]);\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define dep(i, a, n) for(int i = a; i >= (n); i--)\n#define FOR(i, a, n) for(int i = a; i < (n); i++)\n#define mod (ll)(1e9+7)\n#define int ll\n#define INF 100000000\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nll w, h, n, s[100001], result = INF;\n\nsigned main() {\n  rep(i, 100002) s[i] = 0;\n\tcin >> w >> h >> n;\n  rep(i, n) {\n    ll x, y;\n    cin >> x >> y;\n    s[y] = max(s[y], x);\n  }\n  dep(i, h - 2, 0) s[i] = max(s[i], s[i + 1]);\n  rep(i, h) result = min(result, s[i + 1] + i);\n  cout << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint W, H, N;\nint maxh[101010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> W >> H >> N;\n\n    rep(i, 0, N) {\n        int x, y; cin >> x >> y;\n        chmax(maxh[x], y);\n    }\n    rrep(x, W - 2, 0) chmax(maxh[x], maxh[x + 1]);\n\n    int ans = inf;\n    rep(x, 0, W) chmin(ans, x + maxh[x + 1]);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\ntemplate<typename T, T INF>\nclass SegmentTree {\n public:\n  SegmentTree(int n) : size_(1) {\n    while(size_ < n) size_ <<= 1;\n    node_.assign(size_ << 1, 0);\n    lazy_.assign(size_ << 1, 0);\n  }\n  T find(int left, int right) {return find(left, right + 1, 1, 0, size_);}\n  void add(int left, int right, T value) {add(left, right + 1, value, 1, 0, size_);}\n private:\n  inline int left_child(int node) const {return node << 1;}\n  inline int right_child(int node) const {return (node << 1) + 1;}\n  inline T merge(T vl, T vr) const {return std::max(vl, vr);}\n  inline void propagate(int k) {\n    if(k < size_) {\n      lazy_.at(left_child(k)) += lazy_.at(k);\n      lazy_.at(right_child(k)) += lazy_.at(k);\n    }\n    node_.at(k) += lazy_.at(k);\n    lazy_.at(k) = 0;\n  }\n  T find(int a, int b, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return -INF;\n    if(a <= l && r <= b) return node_.at(k) + lazy_.at(k);\n    auto vl = find(a, b, left_child(k), l, (l + r) / 2);\n    auto vr = find(a, b, right_child(k), (l + r) / 2, r);\n    return merge(vl, vr);\n  }\n  T add(int a, int b, T value, int k, int l, int r) {\n    propagate(k);\n    if(b <= l || r <= a) return node_.at(k);\n    if(a <= l && r <= b) return node_.at(k) + (lazy_.at(k) += value);\n    auto vl = add(a, b, value, left_child(k), l, (l + r) / 2);\n    auto vr = add(a, b, value, right_child(k), (l + r) / 2, r);\n    return node_.at(k) = merge(vl, vr);\n  }\n  int size_;\n  std::vector<T> node_;\n  std::vector<T> lazy_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  const int INF = 1e6;\n\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  SegmentTree<int, INF> T(INF);\n  for(auto i = 0; i < N; ++i) {\n    int x, y;\n    cin >> x >> y;\n    if(T.find(x, x) < y) T.add(x, x, y - T.find(x, x));\n  }\n\n  int res = INF;\n\n  for(auto x = 0; x < INF; ++x) {\n    res = min(res, x + T.find(x + 1, INF));\n  }\n\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,n)m[n-i-1]=max(m[n-i-1],m[n-i]);\n  r(i,w-1)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, n) for(int i = a; i < (n); i++)\n#define mod (ll)(1e9+7)\n#define int ll\n#define INF 100000000\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nsigned main() {\n\tll w, h, n;\n  ll xmax[100005];\n  cin >> w >> h >> n;\n  fill(xmax, xmax + h + 1, 0);\n  ll x, y;\n  rep(i, n) {\n    cin >> x >> y;\n    xmax[y] = max(xmax[y], x);\n  }\n  ll result = INF;\n  for (int i = h - 2; i >= 0; i--) {\n    xmax[i] = max(xmax[i], xmax[i + 1]);\n  }\n  for (int i = 0; i < h; i++) {\n    result = min(result, i + xmax[i + 1]);\n  }\n  cout << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint wh[100001] = {};\n\nint main(void) {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tint at_most_w=0,at_most_h=0;\n\tfor (int i = 0; i<n; i++) {\n\t\tint x, y; \n\t\tscanf(\"%d%d\",&x,&y);\n\t\twh[y] = max(wh[y], x);\n\t\tat_most_w=max(x,at_most_w);at_most_h=max(y,at_most_h);\n\t}\n\t\n\tint x_position, y_position, MIN;\n    MIN = wh[h - 1] + (h - 1);\n    x_position = wh[h - 1];\n    y_position = h - 1;\n\t\n\tfor (int i = 0; i<h - 1; i++) {\n\t\ty_position--;\n\t\tint a = x_position, b = y_position;\n\t\tMIN = min(MIN, a+b);\n\t\t\n\t\tif (a < wh[b]) {\n\t\t\tx_position = wh[y_position];\n\t\t\tint a = x_position, b = y_position;\n\t\t\t\n\t\t\tMIN = min(MIN, a+b);\n\t\t}\n\t}\n\t\t\n\tcout << min(MIN,min(at_most_w,at_most_h)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,w,i,j,a[100000],b[100000],h,y[100000];\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t}\n\tm=10000000;\n\tfor(i=0;i<w;i++) y[i]=0;\n\tfor(i=0;i<n;i++) if(y[a[i]-1]<b[i]) y[a[i]-1]=b[i];\n\t//for(i=0;i<w;i++) printf(\"AA%d\\n\",y[i]);\n\tfor(i=w-2;i>=0;i--) if(y[i]<y[i+1]) y[i]=y[i+1];\n\tfor(i=0;i<w;i++){\n\t\tif(i+y[i]<m) m=i+y[i];\n\t}\n\t//for(i=0;i<w;i++) printf(\"BB%d\\n\",y[i]);\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,w)m[n-i-1]=max(m[n-i-1],m[n-i]);\n  r(i,w)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint w,h,n,x[100000],y[100000],Xmax,cnt,flg[100000],kyori,ymax,i;\n\tscanf(\"%d%d%d\",&w,&h,&n);\n\tXmax=0;\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tif(Xmax<x[i]) Xmax=x[i];\n\t}\n\tfor(i=1;i<=Xmax;i++) flg[i]=-1;\n\tflg[0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(flg[x[i]]<y[i]) flg[x[i]]=y[i];\n\t}\n\t//for(i=1;i<=Xmax;i++) printf(\"flg[%d]=%d\\n\",i,flg[i]);\n\tkyori=1000000; ymax=0;\n\tfor(i=Xmax;i>0;i--){\n\t\tif(flg[i]!=-1){\n\t\t\tif(kyori>ymax+i) kyori=ymax+i;\n\t\t\tif(ymax<flg[i]) ymax=flg[i];\n\t\t}\n\t\t//printf(\"i=%d ymax=%d\\n\",i,ymax);\n\t}\n\tprintf(\"%d\\n\",kyori);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint w,h,n;\n\tcin>>w>>h>>n;\n\tpair<int,int> bug[n+1];\n\tbug[n].first=INT_MAX; bug[n].second=INT_MAX;\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tif (a==0||b==0) bug[i].first=a,bug[i].second=b,cnt++;\n\t}\n\tsort(bug,bug+n);\n\tint mx=0;\n\tfor(int i=cnt-1;i>=1;i--){\n\t\tif(bug[i].first!=bug[i-1].first) mx=max(mx,bug[i].second);\n\t}\n\tcout<<mx+bug[0].first<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint w,h,n;\n\tvector<int> vec[100010];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tvec[x].push_back(y);\n\t}\n\tint ma = 0,mi = INF;\n\tfor(int i = w - 1;i >= 0;i--){\n\t\tmi = min(mi,ma + i);\n\t\tfor(int v : vec[i]) ma = max(ma,v);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > Pi;\nint main()\n{\n    set < Pi > st; //y order\n    Pi data[100005]; // x order\n    int W, H, N;\n    cin >> W >> H >> N;\n    st.insert(Pi(0, -1));\n    for(int i = 0; i < N; i++) {\n        cin >> data[i].first >> data[i].second;\n        st.insert(Pi(data[i].second, data[i].first));\n    }\n    sort(data, data + N);\n    \n    int minv = (--st.end()) -> first;\n    int i;\n    while(i < N) {\n        int val = data[i].first;\n        while(data[i].first == val) {\n            st.erase(Pi(data[i].second, data[i].first));\n            i++;\n        }\n        minv = min(minv, val + (--st.end()) -> first);\n    }\n    cout << minv << endl;\n    return (0);\n}\n        "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\nsigned main(){\n    int h, w, n;\n    cin >> h >> w >> n;\n    vector<pair<int,int>> v;\n    for(int i = 0; i < n; ++i){\n        int x, y;\n        cin >> x >> y;\n        v.emplace_back(x, y);\n    }\n    v.emplace_back(0, 0);\n    int y_bound = 0;\n    sort(v.begin(), v.end());\n    int ans = v[n].first;\n    for(int i = n; i >= 1; --i){\n        y_bound = max(y_bound, v[i].second);\n        int x_bound = v[i - 1].first;\n        ans = min(ans, x_bound + y_bound);\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF (1 << 27)\n\nusing namespace std;\n\nvector<int> unchi[100005];\n\nint main()\n{\n    int ans = INF;\n    int h, w, n;\n    int x, y;\n    int maxv[100005] = {};\n\n    cin >> w >> h >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> x >> y;\n        unchi[y].push_back(x);\n    }\n\n    for (int i = h - 1; i >= 0; i--) {\n        int mv = 0;\n\n        for (int j = 0; j < unchi[i + 1].size(); j++) {\n            mv = max(mv, unchi[i + 1][j]);\n        }\n\n        maxv[i] = max(maxv[i + 1], mv);\n    }\n\n    for (int i = 0; i < h; i++) {\n        ans = min(i + maxv[i], ans);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define int long long\n\nint gcd(int a, int b) {\n\tif (b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\nsigned main() {\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\tvector<pair<int,int> > tmp;\n\tint A = -1, B = -1;\n\tfor (int i = 0; i < N; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tA = max(a, A);\n\t\tB = max(b, B);\n\t\ttmp.push_back(make_pair(a, b));\n\t}\n\tsort(tmp.begin(), tmp.end());\n\tvector<int> ma(N);\n\t\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tma[i] = tmp[i].second;\n\t\tif (i != N - 1) {\n\t\t\tma[i] = max(ma[i], ma[i + 1]);\n\t\t}\n\t}\n\tint ans = 1000000000;\n\tint j = 0;\n\tfor (int i = 0; i < N-1; i++) {\n\t\tif (tmp[i].first != tmp[i + 1].first) {\n\t\t\t//cout << ans << endl;\n\t\t\t//cout << tmp[i].first << \" \" << ma[i + 1] << endl;\n\t\t\tans = min(ans,tmp[i].first + ma[i + 1]);\n\t\t\tj++;\n\t\t}\n\t}\n\tans = min(ans, B);\n\tans = min(ans, A);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tvector<pair<int, int> > bug;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x != 0 && y != 0) bug.push_back(pair<int, int>(x, y));\n\t}\n\tsort(bug.begin(), bug.end());\n\tint siz = bug.size();\n\tif(siz == 0) cout << 0 << endl;\n\telse {\n\t\tint mx = bug[siz - 1].second, mn = bug[siz - 1].first;\n\t\tfor(int i = siz - 1; i >= 0; i--){\n\t\t\tpair<int, int> p = bug[i];\n\t\t\tmn = min(mn, p.first + mx);\n\t\t\tmx = max(mx, p.second);\n\t\t}\n\t\tmn = min(mn, mx);\n\t\tcout << mn << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint w,h,n;\n\tvector<int> vec[100010];\n\tcin >> w >> h >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tvec[x].push_back(y);\n\t}\n\tint ma = 0,mi = INF;\n\tfor(int i = w - 1;i >= 0;i--){\n\t\tmi = min(mi,ma + i);\n\t\tfor(int v : vec[i]) ma = max(ma,v);\n\t}\n\tcout << mi << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define INF 1e9\n#define LINF 1e18\n\nconst int MOD = 1e9 + 7;\nconst int dy[]={0, 0, 1, -1};\nconst int dx[]={1, -1, 0, 0};\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pi;\ntypedef pair<P, P> PP;\n\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\n\nint W, H, N;\nint maxX[100000], maxY[100000];\nint under[100000];\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> W >> H >> N;\n    int res = W;\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        chmax(maxY[x], y);\n    }\n    for(int i = W - 2; i >= 0; --i) {\n        under[i] = max(under[i + 1], maxY[i + 1]);\n    }\n    for(int i = 0; i < W; ++i) {\n        chmin(res, i + under[i]);\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0\n#define int ll\n\n#define MAX 100005\n\nint w,h,n;\n\n// first = yoko / second = tate\nP p[100005];\n\nint yoko[MAX];\nint tate[MAX];\nint max_yoko[MAX];\nint max_tate[MAX];\n\nsigned main(){\n  cin>>w>>h>>n;\n  for(int i=0; i<n; i++){\n    cin>>p[i].first>>p[i].second;\n    yoko[p[i].second]=max(yoko[p[i].second],p[i].first);\n    tate[p[i].first]=max(tate[p[i].first],p[i].second);\n  }\n  \n  for(int i=h-1; i>=0; i--){\n    max_yoko[i]=max(max_yoko[i+1],yoko[i]);\n  }\n  \n  for(int i=w-1; i>=0; i--){\n    max_tate[i]=max(max_tate[i+1],tate[i]);\n  }\n  \n  int ans=INF;\n  bool is0_tate=true;\n  for(int i=1; i<w; i++){\n    ans=min(ans,i+max_tate[i+1]);\n    if(max_tate[i+1]) is0_tate=false;\n  }\n  \n  bool is0_yoko=true;\n  for(int i=1; i<h; i++){\n    ans=min(ans,i+max_yoko[i+1]);\n    if(max_yoko[i+1]) is0_yoko=false;\n  }\n  \n  if(is0_yoko&&is0_tate){\n    cout<<0<<en;\n    RE;\n  }\n  cout<<ans<<en;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <string>\n#include <stack>\n#include <set>\n#include <sstream>\n#include <iomanip>\n#include <limits>\n#include <cstring>\n\nusing namespace std;\nusing ll = long long;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double >pd;\ntypedef pair<string, string> sP;\ntypedef pair<ll, P> PP;\ntypedef pair<P, P> PPP;\n\nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1 << 30;\nconst ll INF2 = 9e18;\nconst double INF3 = 9e14;\nconst double eps = 1e-10;\nconst double PI = 3.14159265358979323846;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define pb push_back\n#define eb emplace_back\n#define fr first\n#define sc second\n\nvector<ll>x, y;\nll n, h, w, hmax[100010], ans = INF;\nP a[100010];\n\nint main() {\n\tcin >> w >> h >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> a[i].fr >> a[i].sc;\n\t}\n\tsort(a, a + n);\n\tfor (int i = n - 1;i >= 0;i--) {\n\t\thmax[a[i].fr - 1] = max(hmax[a[i].fr - 1], a[i].sc);\n\t}\n\tfor (int i = w - 1;i > 0;i--) {\n\t\thmax[i - 1] = max(hmax[i], hmax[i - 1]);\n\t}\n\tfor (ll i = 0;i < w;i++) {\n\t\tll l = -1, r = h, mid;\n\t\twhile (r - l > 1) {\n\t\t\tmid = (r + l) / 2;\n\t\t\tif (mid >= hmax[i])r = mid;\n\t\t\telse l = mid;\n\t\t}\n\t\tans = min(ans, i + r);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2019/03/27 Tazoe\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint W, H, N;\n\tcin >> W >> H >> N;\n\n\tint MX[100000] = {0};\n\n\tfor(int i=0; i<N; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tMX[y] = max(MX[y], x);\n\t}\n\n\tint mx_max = 0;\n\tint ans = W+H;\n\n\tfor(int i=H-1; i>=0; i--){\n//\t\tcout << i+mx_max << endl;\n\t\tans = min(ans, i+mx_max);\n\t\tmx_max = max(mx_max, MX[i]);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#define rep(i,a,n) for(int i =(a);i<(n);i++)\n#define urep(i,a,n) for(int i = (a);i>=(n);i--)\n#define all(x) (x).begin(),(x).end()\ntypedef long long ll;\nusing namespace std;\n\nint W, H, N;\nvector<pair<int, int> > v;\nint Xmax[100000];\nint main() {\n\tcin >> W >> H >> N;\n\trep(i, 0, N){\n\t\tint num[2];\n\t\tcin >> num[0] >> num[1];\n\t\tpair<int, int> p;\n\t\tp.first = num[0];\n\t\tp.second = num[1];\n\t\tv.push_back(p);\n\t}\n\t\n\trep(i, 0, N) {\n\t\tXmax[v[i].second] = max(Xmax[v[i].second],v[i].first);\n\t}\n\tint maxpos = Xmax[H - 1];\n\tint oldmaxx = Xmax[H - 1];\n\tXmax[H - 1] = 0;\n\turep(i, H-2, 0) {\n\t\tif (maxpos < oldmaxx) {\n\t\t\t\n\t\t\tmaxpos = oldmaxx;\n\t\t}\n\t\toldmaxx = Xmax[i];\n\t\tXmax[i] = maxpos;\n\t}\n\tint ans = 10000000;\n\trep(i, 0, H) {\n\t\tans = min(ans, Xmax[i]+i);\n\t}\n\tcout << ans << endl;\n\tcin >> ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\n// template {{{  0 \n// using {{{ 1\nusing ll = long long int;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vii = vector<pii>;\nusing vll = vector<pll>;\n// }}} 1\n// definition {{{ 1\n// scaning {{{ 2\n#define Scd(x) scanf(\"%d\", &x)\n#define Scd2(x,y) scanf(\"%d%d\", &x, &y)\n#define Scd3(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define Scll(x) scanf(\"%lld\", &x)\n#define Scll2(x,y) scanf(\"%lld%lld\", &x, &y)\n#define Scll3(x,y,z) scanf(\"%lld%lld%lld\", &x, &y, &z)\n#define Scc(c) scanf(\"%c\", &c);\n#define Scs(s) scanf(\"%s\", s);\n#define Scstr(s) scanf(\"%s\", &s);\n// }}} 2\n// constants {{{ 2\n#define EPS (1e-7)\n#define INF (2e9)\n#define PI (acos(-1))\n// }}} 2\n// systems {{{ 2\n#define Repe(x,y,z) for(int x = z; x < y; x++)\n#define Rep(x,y) Repe(x,y,0)\n#define RRepe(x,y,z) for(int x = y-z-1; x >= 0; x--)\n#define RRep(x,y) RRepe(x,y,0)\n// }}} 2\n// output {{{ 2\n#define YesNo(a) (a)?printf(\"Yes\\n\"):printf(\"No\\n\")\n#define YESNO(a) (a)?printf(\"YES\\n\"):printf(\"NO\\n\")\n// }}} 2\n// }}} 1\n// input {{{ 1\n// }}} 1\n// }}} 0\n\nint main() {\n\n    int W,H,N;\n    Scd3(W,H,N);\n\n    vii a(N);\n    int x,y;\n    Rep(i,N){\n        Scd2(x,y);\n        a[i] = {x,y};\n    }\n\n    vi w(W);\n    vi h(H);\n\n    Rep(i,N){\n        x = a[i].first;\n        y = a[i].second;\n        if( x ) w[x-1] = max( w[x-1], y );\n        if( y ) h[y-1] = max( h[y-1], x );\n    }\n\n    RRepe(i,W,1){\n        w[i] = max( w[i], w[i+1] );\n    }\n    RRepe(i,H,1){\n        h[i] = max( h[i], h[i+1] );\n    }\n\n    int ans = INF;\n\n    Rep(i,W){\n        ans = min( ans, i + w[i] );\n    }\n    Rep(i,H){\n        ans = min( ans, i + h[i] );\n    }\n\n    printf (\"%d\\n\", ans );\n\n    return 0;\n}\n\n/*\n * ....x 2\n * ..x.. 1\n * ..... 1\n * .x... 0\n * x.... 0\n * \n * 41000\n */\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <string>\n#include <stack>\n#include <cmath>\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\nusing namespace std;\n//\nconst int inf=1e9+7;\nconst int mod=1e9+7;\n//\nstruct poi{\n\tint X;int Y;int Z;\n\tbool operator<(const poi&R)const{\n\t\treturn X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n\t}\n};\n//\nll GCD(ll a,ll b){\n\treturn (b==0)?(a):(GCD(b,a%b));\n}\nll LCM(ll a,ll b){\n\treturn a/GCD(a,b)*b;\n}\n//\n//\nint main(){\n\tint W,H,N;\n\tcin>>W>>H>>N;\n\tvector<pair<int,int> > V(N);\n\tpair<int,int> cnt[100000];\n\tfill(cnt,cnt+W,make_pair(-1,-1));\n\tFOR(i,0,N){\n\t\tint X,Y;\n\t\tcin>>X>>Y;\n\t\tif(cnt[X].first<Y){\n\t\t\tcnt[X]=make_pair(Y,i);\n\t\t}\n\t\tV[i]=make_pair(X,Y);\n\t}\n\tvector<pair<int,int> > vv;\n\tFOR(i,0,W){\n\t\tif(cnt[i].first!=-1){\n\t\t\tvv.push_back(V[cnt[i].second]);\n\t\t}\n\t}\n\tsort(vv.rbegin(),vv.rend());\n\tint now=-1;\n\tvector<pair<int,int> > v;\n\tFOR(i,0,vv.size()){\n\t\tif(now<vv[i].second){\n\t\t\tv.push_back(vv[i]);\n\t\t\tnow=vv[i].second;\n\t\t}\n\t}\n\treverse(v.begin(),v.end());\n\tif((int)v.size()==1){\n\t\tcout<<min(v[0].first,v[0].second)<<endl;\n\t}else{\n\t\tint ans=inf;\n\t\tFOR(i,0,v.size()-1){\n\t\t\tans=min(ans,v[i].first+v[i+1].second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nstruct segtree{\nprivate:\n  ll siz;\n  vector<ll> node;\npublic:\n  segtree(ll n){\n    siz=1;\n    while(siz<=n) siz*=2;\n    node.resize(siz*2+1,0);\n  }\n  void upd(int p,int x){\n    p+=siz-1;\n    node[p]=x;\n    while(p>0){\n      p=(p-1)/2;\n      node[p]=max(node[2*p+1],node[2*p+2]);\n    }\n  }\n  ll max_v(ll a,ll b,ll p,ll l,ll r){\n    if(a<=l&&r<=b) return node[p];\n    if(r<=a||b<=l) return 0;\n    ll mid=(l+r)/2;\n    return max(max_v(a,b,2*p+1,l,mid),max_v(a,b,2*p+2,mid,r));\n  }\n  ll max_q(ll a){\n    return max_v(a,siz,0,0,siz);\n  }\n};\nint main(){\n  vector<ll> vec;\n  vector<P> points;\n  ll h,w,n;\n  cin>>h>>w>>n;\n  for(int i=0;i<n;i++){\n    ll x,y;\n    cin>>x>>y;\n    points.push_back(P(x,y));\n    vec.push_back(x);\n  }\n  vec.push_back(0);\n  points.push_back(P(0,0));\n  sort(vec.begin(),vec.end());\n  sort(points.begin(),points.end());\n// cout<<0<<\" \"<<points[0].first<<\" \"<<points[0].second<<endl;\n  segtree seg=segtree(n+5);\n  for(int i=1;i<=n;i++){\n    seg.upd(i,points[i].second);\n  //  c//out<<i<<\" \"<<points[i].first<<\" \"<<points[i].second<<endl;\n  }\n  ll ans=17441744174417;\n  for(int i=0;i<vec.size();i++){\n    ll kans=vec[i];\n    ll p=lower_bound(points.begin(),points.end(),P(kans+1,0))-points.begin();\n  //  cout<<i<<\" \"<<kans<<\" \"<<p<<\" \"<<seg.max_q(p)<<endl;\n    kans+=seg.max_q(p);\n    ans=min(ans,kans);\n  }\n//  ans=min(ans,vec[])\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n<url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0364>\n?????????============================================================\n ??¢??????????°???????????????????????????§????????§????????§?????????\n ???????????????W??H ?????????????????¶??????????????????????????¢????????¢?????§???????????????\n ????????????????????¨?????????????????????????????????????????¨??????????????????????????????????????????\n ????????????x???????????????y ????????????(x, y)??§??¨????????????\n ??????????????????(0, 0)?????????????????????(W-1, H-1)??§?????????\n \n ??¢???????????£????????????????????????????????????????????????????????????????????¢???????????????\n ?????????????????????????????????????????°???????????????0, 0???????????????\n ?????¢??????????????¨????????????????????¨?????????????????¢??¨?????????\n ?????????????????¨??????????????????????????????????????\\??????????¨????????????????????????§?????¨????????¨?????§?????????\n \n ???????????????????????????????????????????????????????????¢?????????????????????????????????\n ??????????????¨?????????????????????????????¨??????????????????????????????????????¨?????????????????????????????????????????????????????????\n ??????????????????1 ?????????????????????????????????????¶?????????????\n ??????????????¨?????°?????¶?????????????????????????????¨????????????????????????????????????\n ??????????????????????????????????????±????????????????????¨?????????????????????????????????????§???????????????¨?????§?????????\n \n ?????¢?????§????????¨???????????±????????????????????¨??????????????????????????¨???????????????????????????????°????????????????????????????????????°????????????????????????\n=================================================================\n\n?§£??¬=============================================================\n\n================================================================\n*/\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int W,H,N; cin >> W >> H >> N;\n    vector<pii> xy(N);\n    for(auto& in:xy) cin >> in.first >> in.second;\n    sort(xy.begin(),xy.end());\n    int res = INF;\n    for(int i = 0; i < W;i++){\n        int T = i;\n        auto it = upper_bound(xy.begin(), xy.end(), make_pair(i,INF)) - xy.begin();\n        for(;it < N;it++){\n            T = max(T,i + xy[it].second);\n        }\n        res = min(res,T);\n    }\n    cout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1001001001;\n\nint main() {\n  int w, h, n;\n  cin >> w >> h >> n;\n\n  vector<int> a(h + 1, 0);\n\n  for (int i = 0; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n\n    a[y] = max(a[y], x);\n  }\n\n  int ans = inf;\n  for (int i = h; i >= 0; --i) {\n    ans = min(ans, i + a[i]);\n    a[i - 1] = max(a[i], a[i - 1]);\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int W, H, N;\n    int ymax[100005] = {};\n\n    cin >> W >> H >> N;\n    for(int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        ymax[x] = max(ymax[x], y);\n    }\n    \n    int minv = 1 << 28;\n    int mm = 0;\n    for(int i = W - 1; i >= 0; i--) {\n        minv = min(i + mm, minv);\n        mm = max(ymax[i]);\n    }\n\n    cout << minv << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint w,n,m[100009],ans=1e8,x,y;\nmain(){\n  cin>>w>>n>>n;\n  r(i,n){\n    cin>>x>>y;\n    m[x]=max(m[x],y);\n  }\n  r(i,w-1)m[n-i-1]=max(m[n-i-1],m[n-i]);\n  r(i,w-1)ans=min(ans,i+m[i+1]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define rep(i, a, n) for(int i = a;i < n;i++)\nusing namespace std;\n\n\nint w, h, n;\nint seg[131072*2 - 1];\nint N;\n\n\nint p(int i){\n\treturn (int)((i-1) / 2);\n}\n\n\nvoid update(int i){\n\tif(i == 0) return;\n\tif(seg[p(i)] >= seg[i]) return;\n\tseg[p(i)] = seg[i];\n\tupdate(p(i));\n}\n\n\nvoid init(){\n\trep(i, N-1, h+N-1) update(i);\n}\n\n\nint qmax(int a, int b, int k = 0, int l = 0, int r = N){\n\tif(r <= a || b <= l) return -1;\n\tif(a <= l && r <= b) return seg[k];\n\n\tint vl = qmax(a, b, 2*k+1, l, (l+r)/2);\n\tint vr = qmax(a, b, 2*k+2, (l+r)/2, r);\n\treturn max(vl, vr);\n}\n\n\nint solve(){\n\tint c = 999999999;\n\trep(i, 0, h-1){\n\t\tc = min(c, i+qmax(i+1, h));\n\t}\n\tc = min(c, h);\n\treturn c;\n}\n\n\nint main(){\n\tcin >> w >> h >> n;\n\tN = (int)pow(2, (int)ceil(log2(h)));\n\t\n\trep(i, 0, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tseg[y+N-1] = max(seg[y+N-1], x);\n\t}\n\t\n\tinit();\n\t\n\tcout << solve() << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std;\n\nint main(){\n    int W,H,N;\n    cin>>W>>H>>N;\n    int enex[1000],eney[1000];\n    for(int i=0;i<N;i++){\n        cin>>enex[i]>>eney[i];\n    }\n    int sum=100001,flag=0;\n    int smaller=min(W-1,H-1);\n    for(int i=0;i<W;i++){\n    \tfor(int j=0;j<H;j++){\n    \t    flag=0;\n    \t\tfor(int k=0;k<N;k++){\n    \t\t\tif(enex[k]>=i&&eney[k]>=j){\n    \t\t\t    flag=1;\n    \t\t\t    break;\n    \t\t\t}\n    \t\t}\n    \t\tif(i==0||j==0){\n    \t\t    if((flag==0)&&(sum>=i+j-1))sum=i+j-1;\n    \t\t}else{\n    \t\t    if((flag==0)&&(sum>=i+j-2))sum=i+j-2;\n    \t\t}\n    \t}\n    }\n    if(sum>smaller)sum=smaller;\n    cout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define H_MAX 100000\nint W,H,N;\nint MX[H_MAX],X[H_MAX];\n\n\nint main(void){\n\tint x,y;\n\tcin>>W>>H>>N;\n\tfor(int i=0;i<H;i++)MX[i]=X[i]=-1;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>x>>y;\n\t\tX[y]=max(X[y],x);\n\t}\n\tMX[H-1]=0;\n\tfor(int i=H-2;i>=0;i--){\n\t\tMX[i]=max(MX[i+1],X[i+1]);\n\t}\n\t\n\tint ans=H;\n\tfor(int i=0;i<H;i++){\n\t\tans=min(ans,i+MX[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\nconst ll INF = LLONG_MAX - 100;\nconst ll mod = 1e9 + 7;\nconst int MAX_N = 5e5 + 5;\nint dx[] = { -1LL,0,1LL,0 }, dy[] = { 0,1LL,0,-1LL };\nvector<ll> prime;\n\nll inv[MAX_N], fac[MAX_N];\n\ninline ll GCD(ll a, ll b) { ll c; while (b != 0) { c = a % b; a = b; b = c; }return a; }\ninline ll LCM(ll a, ll b) { return a * b / GCD(a, b); }\ninline ll POW(ll a, ll b) { ll c = 1LL; while (b > 0) { if (b & 1LL) { c = a * c%mod; }a = a * a%mod; b >>= 1LL; }return c; }\ninline void _nCr() { fac[0] = 1LL; for (int i = 1LL; i < MAX_N; i++) { fac[i] = fac[i - 1LL] * i%mod; }for (int i = 0; i < MAX_N; i++) { inv[i] = POW(fac[i], mod - 2); } }\ninline ll nCr(ll n, ll r) { return (fac[n] * inv[r] % mod)*inv[n - r] % mod; }\ninline void PRI(ll n) { bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) { a[i] = 1LL; }for (int i = 2; i < n + 1LL; i++) { if (a[i]) { prime.pb(i); ll b = i; while (b <= n) { a[b] = 0; b += i; } } } }\n\nint hmax[100005];\nint acmax[100005];\n\nsigned main() {\n    int W,H,N;cin >> W >> H >> N;\n    REP (i,N) {\n        int w,h;cin >> w >> h;\n        hmax[h] = max(hmax[h],w);\n    }\n\n    for (int i = H - 1;i >= 0;i--) {\n        acmax[i] = max(acmax[i+1],hmax[i]);\n    }\n\n    int ans = INF;\n    REP (i,H) {\n        ans = min(ans,i+acmax[i+1]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\n#ifndef MAX\n#define MAX 400000\n#endif\n\n//Range Update Query+Range Minimum Query\ntemplate<class T>\nclass RUQ_RMQ {\npublic:\n\tint n;\n\tT dat[MAX], lazy[MAX], DEFAULT;\n\tbool(*cmp)(T, T);\n\tvoid init(int n_,\n\t\tbool(*c)(T, T) = [](int a, int b) {return a < b; }, T d = INT_MAX) {\n\t\tcmp = c;\n\t\tDEFAULT = d;\n\t\tn = 1; while (n < n_)n <<= 1;\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tdat[i] = lazy[i] = DEFAULT;\n\t\t}\n\t}\n\tinline void push(int k) {\n\t\tif (lazy[k] == DEFAULT)return;\n\t\tdat[k] = lazy[k];\n\t\tif (k < n - 1) {\n\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t}\n\t\tlazy[k] = DEFAULT;\n\t}\n\tinline void update_node(int k) {\n\t\tif (cmp(dat[k * 2 + 1], dat[k * 2 + 2]))dat[k] = dat[k * 2 + 1];\n\t\telse dat[k] = dat[k * 2 + 2];\n\t}\n\tinline void update(int a, int b, T x, int k, int l, int r) {\n\t\tpush(k);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = x; push(k); return;\n\t\t}\n\t\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t}\n\tinline T query(int a, int b, int k, int l, int r) {\n\t\tpush(k);\n\t\tif (r <= a || b <= l)return DEFAULT;\n\t\tif (a <= l&&r <= b)return dat[k];\n\t\tT lb = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT rb = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\tupdate_node(k);\n\t\tif (cmp(lb, rb))return lb;\n\t\treturn rb;\n\t}\n\tinline void update(int a, int b, T x) {\n\t\tupdate(a, b, x, 0, 0, n);\n\t}\n\tinline void update(int a, T x) {\n\t\tupdate(a, a + 1, x);\n\t}\n\tinline T query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\tinline T query(int a) {\n\t\treturn query(a, a + 1);\n\t}\n};\n\nRUQ_RMQ<int>seg;\nP p[100000];\nint main(){\n\tint w,h,n;scanf(\"%d%d%d\",&w,&h,&n);\n\tseg.init(n,[](int a,int b){return a>b;},0);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&p[i].first,&p[i].second);\n\t}\n\tsort(p,p+n,[](P a,P b){\n\t\tif(a.first==b.first)return a.second>b.second;\n\t\treturn a.first<b.first;\n\t});\n\trep(i,n){\n\t\tseg.update(i,p[i].second);\n\t}\n\tint Min=INT_MAX;\n\trep(i,n+1){\n\t\tMin=min(Min,(i==0?0:p[i-1].first)+seg.query(i,n));\n\t}\n\tcout<<Min<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint main(){\n    int W,H,N;\n    VE x,y,z;\n    cin>>W>>H>>N;\n    FOR(i,0,N){\n        int X,Y;\n        cin>>X>>Y;\n        if(X<Y){\n            x.PB(X);\n        }else if(X>Y){\n            y.PB(Y);\n        }else{\n            z.PB(X);\n        }\n    }\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    if(!z.empty()){\n        sort(z.begin(),z.end());\n        if(x.empty()&&y.empty()){\n            cout<<z.back()<<endl;\n        }else if(x.empty()){\n            if(y.back()>=z.back()){\n                cout<<y.back()<<endl;\n            }else{\n                cout<<z.back()<<endl;\n            }\n        }else if(y.empty()){\n            if(x.back()>=z.back()){\n                cout<<x.back()<<endl;\n            }else{\n                cout<<z.back()<<endl;\n            }\n        }else{\n            if(z.back()>x.back()&&z.back()>y.back()){\n                cout<<x.back()+y.back()+(z.back()-max(x.back(),y.back()))<<endl;\n            }else{\n                cout<<x.back()+y.back()<<endl;\n            }\n        }\n    }else{\n        cout<<x.back()+y.back()<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//y17-8\n#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define segment_size 65536\n#define ROOP() while(true)\nint main(){\n\n    int W,H,N;\n    cin >> W >> H >> N;\n\n    int m[100000];\n    for(int i=0; i<W; i++){\n        m[i] = 0;\n    }\n    for(int i=0; i<N; i++){\n        int x,y;\n        cin >> x >> y;\n        m[x-1] = max(m[x-1], y);\n    }\n    int tmp = 0;\n    for(int i=W-1; i>=0; i--){\n        tmp = max(tmp, m[i]);\n        m[i] = tmp;\n    }\n\n    int ans = INT_MAX;\n    for(int i=0; i<W; i++){\n        //cout << m[i] << endl;\n        ans = min(ans, i+m[i]);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint maxy[100000+1];\n\nint main() {\n\n    int w,h,n;\n\n    cin >> w >> h >> n;\n\n    while(n--){\n        int x,y;\n        cin >> x >> y;\n        maxy[x] = max(maxy[x],y);\n    }\n\n    int ans=w-1,dp=0;\n\n    for(int x=w-2; x>=0; x--){\n        dp = max(dp,maxy[x+1]);\n        ans = min(dp+x,ans);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint n,m,w,i,j,a[100000],b[100000],h,y[1000000];\n\tscanf(\"%d %d %d\",&w,&h,&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t}\n\tm=10000000;\n\tfor(i=0;i<w;i++) y[i]=0;\n\tfor(i=0;i<n;i++) if(y[a[i]-1]<b[i]) y[a[i]-1]=b[i];\n\t//for(i=0;i<w;i++) printf(\"AA%d\\n\",y[i]);\n\tfor(i=w-2;i>=0;i--) if(y[i]<y[i+1]) y[i]=y[i+1];\n\tfor(i=0;i<w;i++){\n\t\tif(i+y[i]<m) m=i+y[i];\n\t}\n\t//for(i=0;i<w;i++) printf(\"BB%d\\n\",y[i]);\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){ll res=1;a%=mod;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}\n\nint main(){\n    ll w,h,n;cin>>w>>h>>n;\n    vp v(n);\n    rep(i,n)cin>>v[i].fi>>v[i].se;\n    sort(all(v));\n    ll ma=0,ans=inf;\n    for(int i=n-1;i>=0;i--){\n        chmin(ans,ma+v[i].fi);\n        chmax(ma,v[i].se);\n    }\n    chmin(ans,ma);\n    out(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int w, h, n; cin >> w >> h >> n;\n    vector<pii> es(n);\n    multiset<int, greater<>> s;\n    for(int i = 0; i < n; ++i) {\n        cin >> es[i].first >> es[i].second;\n        s.insert(es[i].second);\n    }\n    sort(begin(es), end(es));\n    int ans = 1e9;\n    {\n        int maxi_y = 0;\n        for(int i = 0; i < n; ++i) {\n            maxi_y = max(maxi_y, es[i].second);\n        }\n        ans = min(es.back().first, maxi_y);\n    }\n    for(int i = 0; i < n; ++i) {\n        s.erase(s.lower_bound(es[i].second));\n        ans = min(ans, es[i].first + *begin(s));\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n\n/* include file*/\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntemplate <class Monoid>\nstruct Segment {\n  using Func = function<Monoid(Monoid, Monoid)>;\n\n  vector<Monoid> node;\n  Monoid ide;\n  int n = 1;\n\n  Func bin_f;\n  Func update_f;\n\n  Segment(const vector<Monoid>& init, Monoid ide_, Func f_, Func u_f)\n      : bin_f(f_), ide(ide_), update_f(u_f) {\n    int sz = init.size();\n    while (n < sz) n *= 2;\n    node.assign(n * 2 - 1, ide);\n    for (int i = 0; i < sz; i++) node[i + n - 1] = init[i];\n    for (int i = n - 2; i >= 0; i--)\n      node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n  }\n\n  void update(int i, Monoid x) {\n    i += n - 1;\n    node[i] = update_f(node[i], x);\n    while (i) {\n      i = (i - 1) / 2;\n      node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n    }\n  }\n\n  Monoid get_inter(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (r <= a || b <= l) return ide;\n\n    Monoid lm = get_inter(a, b, k * 2 + 1, l, (l + r) / 2);\n    Monoid rm = get_inter(a, b, k * 2 + 2, (l + r) / 2, r);\n    return bin_f(lm, rm);\n  }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730414#1\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730425#1\n\n\nint W,H,N;\n\nvector<int> x,y;\n\nint main(){\n  cin >> W >> H >> N;\n  x.resize(N);\n  y.resize(N);\n\n  rep(i,0,N - 1) cin >> x[i] >> y[i];\n\n  vector<int> init(W,1e9);\n\n  rep(i,0,N - 1){\n    init[x[i]] = min(init[x[i]],y[i]);\n  }\n\n  rep(i,0,W - 1){\n    if(init[i] == 1e9){\n      init[i] = -1;\n    }\n  }\n  Segment<int> seg(init,-1,[](int a,int b){\n    return max(a,b);\n  }\n  ,[](int a,int b){\n    return b;\n  });\n\n  int ans = 1e9;\n\n  rep(i,0,W - 1){\n    int temp = seg.get_inter(i + 1,W);\n    if(temp == -1) temp = 0;\n    ans = min(ans , i + temp);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nint main(){\n    int w, h, n;\n    cin >> w >> h >> n;\n    set<pair<int,int>> x;\n    multiset<int> y;\n    for(int i = 0; i < n; i++){\n        int a, b;\n        cin >> a >> b;\n        x.insert({a, b});\n        y.insert(b);\n    }\n    int ans = *y.rbegin();\n    while(!x.empty()){\n        int take = x.begin()->first;\n        while(!x.empty() && x.begin()->first == take){\n            y.erase(y.find(x.begin()->second));\n            x.erase(x.begin());\n        }\n        ans = min(ans, (y.empty() ? 0 : *y.rbegin())+take);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\n#include<set>\n#include<map>\n#include<functional>\n\nusing namespace std;\n#define LL long long\n#define LLBIG 1999999999999999999\n#define INTBIG 1111111111\n#define MOD 1000000007\n#define PI pair<int,int>\n#define VI vector<int>\n#define VVI vector<vector<int>>\n\nint W, H, N, ans, maxy = 0;\nvector<PI> e;\n\nint main() {\n\tcin >> W >> H >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\te.push_back({x, y});\n\t}\n\tsort(e.begin(), e.end());\n\tans = e[N - 1].first;\n\tfor (int i = N - 1; i >= 0; i--) {//e[i-1]までx\n\t\tmaxy = max(maxy, e[i].second);\n\t\tans = min(ans, (i ? e[i - 1].first : 0) + maxy);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tint n,a,b;\n\tscanf(\"%d%d%d\",&n,&n,&n);\n\tvector<pair<int,int> >v;\n\tmultiset<int>se;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tv.emplace_back(a,b);\n\t\tse.insert(b);\n\t}\n\tsort(v.begin(),v.end());\n\tint r=min(v.rbegin()->first,*se.rbegin());\n\tfor(int i=0;i<n-1;i++){\n\t\tse.erase(v[i].second);\n\t\tr=min(r,v[i].first+*se.rbegin());\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <cmath>\n#include <string>\n#define FI first\n#define SE second\n#define PF push_front\n#define PB push_back\n#define PPF pop_front\n#define PPB pop_back\n#define MA make_pair\n#define ll long long\n#define PA pair<int,int>\n#define VE vector<int>\n#define VP vector<PA>\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ROF(i,a,b) for(int i=b-1;i>=a;i--)\n#define YES(i) cout<<(i?\"YES\":\"NO\")<<endl\n#define Yes(i) cout<<(i?\"Yes\":\"No\")<<endl\nusing namespace std;\n//\nconst int INF=1e9+7;\nconst int mod=1e9+7;\n//\n//\nstruct poi{\n  int X;int Y;int Z;\n  bool operator<(const poi&R)const{\n    return X==R.X ? Y==R.Y ? Z<R.Z : Y<R.Y : X<R.X;\n  }\n};\n//\n//\nint main(){\n    int W,H,N;\n    VP Vx,Vy;\n    VE x,y;\n    cin>>W>>H>>N;\n    int MX=-1,MY=-1;\n    FOR(i,0,N){\n        int X,Y;\n        cin>>X>>Y;\n        Vx.PB(MA(X,Y));\n        Vy.PB(MA(Y,X));\n        MX=max(MX,X);\n        MY=max(MY,Y);\n        if(X>Y){\n            y.PB(Y);\n        }else if(X<Y){\n            x.PB(X);\n        }else{\n            x.PB(X);\n            y.PB(Y);\n        }\n    }\n    sort(x.begin(),x.end());\n    sort(y.begin(),y.end());\n    sort(Vx.begin(),Vx.end());\n    sort(Vy.begin(),Vy.end());\n    int mx=Vx.back().FI,my=Vx.back().SE;\n    if(mx==MX&&my==MY){\n        cout<<min(MX,MY)<<endl;\n    }else{\n        int num=max(x.back(),y.back());\n        int nx=upper_bound(Vx.begin(),Vx.end(),MA(num,INF))-Vx.begin();\n        int ny=upper_bound(Vy.begin(),Vy.end(),MA(num,INF))-Vy.begin();\n        int ax=-1,ay=-1;\n        FOR(i,nx,N){\n            ax=max(ax,min(Vx[i].FI-num,Vx[i].SE));\n        }\n        FOR(i,ny,N){\n            ay=max(ay,min(Vy[i].FI-num,Vy[i].SE));\n        }\n        cout<<num+min(max(ax,0),max(ay,0))<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int W, H, N;\n    int ymax[100005] = {};\n\n    cin >> W >> H >> N;\n    for(int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        ymax[x] = max(ymax[x], y);\n    }\n    \n    int minv = 1 << 28;\n    int mm = 0;\n    for(int i = W - 1; i >= 0; i--) {\n        minv = min(i + mm, minv);\n        mm = max(ymax[i], mm);\n    }\n\n    cout << minv << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int w, h, n; cin >> w >> h >> n;\n    int x[100001] = {}, y[100001] = {};\n    for(int i = 0; i < n; i++){\n        int u, v; cin >> u >> v;\n        x[u] = max(x[u], v);\n        y[v] = max(y[v], u);\n    }\n    for(int i = w-2; i >= 0; i--){\n        x[i] = max(x[i], x[i+1]);\n    }\n    for(int i = h-2; i >= 0; i--){\n        y[i] = max(y[i], y[i+1]);\n    }\n    int ans = w-1;\n    for(int i = 0; i < w; i++){\n        ans = min(ans, i + x[i+1]);\n    }\n    for(int i = 0; i < w; i++){\n        ans = min(ans, i + y[i+1]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n  int W, H, N;\n  cin >> W >> H >> N;\n\n  vector<int> mx(W);\n  for(int i=0;i<N;++i){\n\tint x, y;\n\tcin >> x >> y;\n\tmx[x] = max(mx[x], y);\n  }\n\n  int ans = 1e9;\n  int mx_y = 0;\n  for(int x=W-1;x>=0;--x){\n\tans = min(ans, x + mx_y);\n\tmx_y = max(mx_y, mx[x]);\t\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : AOJ.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint w,h,n;\nint d[100001]={};\n\nint main() {\n\tcin>>w>>h>>n;\n\tint x,y;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x>>y;\n\t\td[x]=max(d[x],y);\n\t}\n\tint total=min(h-1,w-1);\n\tint m=0;\n\tfor(int i=w-1;i>0;--i){\n\t\tm=max(m,d[i]);\n\t\ttotal=min(total,i-1+m);\n\t}\n\n\tcout<<total<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mk make_pair\n#define pb push_back\n\nint W, H, N;\npair<int, int> C[100100];\nint ma[100100];\n\nsigned main()\n{\n    cin >> W >> H >> N;\n    for(int i = 0; i < N; i++){\n        int a, b;\n        cin >> a >> b;\n        C[i] = mk(a, b);\n    }\n    for(int i = 0; i < N; i++){\n        ma[C[i].first] = max(ma[C[i].first], C[i].second);\n    }\n    for(int i = W - 1; i >= 0; i--){\n        ma[i] = max(ma[i], ma[i + 1]);\n    }\n    int ans = 1000000009;\n    for(int i = 0; i < W; i++){\n        ans = min(ans, i + ma[i + 1]);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Array\nimport Data.List\nimport Data.List.Split\n\n\ntype Width = Int\ntype Height = Int\ntype Enemy = (Int,Int)\ntype Player = (Int,Int)\ntype Cost = Int\ntype Situation = (Width, Height, Player, [Enemy], Cost)\n\nmain = do\n  input <- getSplitedLines\n  let (w:h:_) = head input\n  let enemys = map (\\(a:b:_) -> (a, b)) $ drop 1 input\n  let player = (0,0)\n  let cost = 0\n  let minimumCost = calcMinimumCost (w, h, player, enemys, cost)\n  putStrLn $ show minimumCost\n\ncalcMinimumCost :: Situation -> Cost\ncalcMinimumCost situation = calcMinimumCost' [explosion situation]\n  where\n    calcMinimumCost' :: [Situation] -> Cost\n    calcMinimumCost' situations = case getEnd situations of\n      Nothing -> calcMinimumCost' nextSituations\n      Just (_, _, _, _, c)  -> c\n      where\n        nextSituations = situations >>= getNextSituation\n\ngetNextSituation :: Situation -> [Situation]\ngetNextSituation situation = map explosion $ getNextMove situation\n\ngetNextMove :: Situation -> [Situation]\ngetNextMove (w, h, (px,py), es, c)\n  | px < w-1 && py < h-1 = [(w, h, (px + 1,py), es, nextCost), (w, h, (px,py + 1), es, nextCost)]\n  | px < w-1             = [(w, h, (px + 1,py), es, nextCost)]\n  | py < h-1             = [(w, h, (px,py + 1), es, nextCost)]\n  | otherwise\t\t\t = []\n  where \n    nextCost = c + 1\n\nexplosion :: Situation -> Situation\nexplosion (w, h, (px,py), es, c) = (w, h, (px,py), filter (not.isHit) es, c)\n  where\n    isHit (ex,ey) = px == ex || py == ey\n\ngetEnd :: [Situation] -> Maybe Situation\ngetEnd [] = Nothing\ngetEnd ss = safeHead $ filter isEnd ss\n\nisEnd :: Situation -> Bool\nisEnd (_, _, _, [], _) = True\nisEnd (_, _, _, _, _) = False\n    \nsafeHead [] = Nothing\nsafeHead (a:_) = Just a\n\ngetSplitedLines =  do\n  s <- getContents\n  return $ map (map read) $ map (splitOn \" \") $ lines s\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport Data.List.Split\n\n\ntype Width = Int\ntype Height = Int\ntype Enemy = (Int,Int)\ntype Player = (Int,Int)\ntype Cost = Int\ntype Situation = (Width, Height, Player, [Enemy], Cost)\n\nmain = do\n  input <- getSplitedLines\n  let (w:h:_) = head input\n  let enemys = map (\\(a:b:_) -> (a, b)) $ drop 1 input\n  let player = (0,0)\n  let cost = 0\n  let minimumCost = calcMinimumCost (w, h, player, enemys, cost)\n  putStrLn $ show minimumCost\n\ncalcMinimumCost :: Situation -> Cost\ncalcMinimumCost situation = calcMinimumCost' [explosion situation]\n  where\n    calcMinimumCost' :: [Situation] -> Cost\n    calcMinimumCost' situations = case getEnd situations of\n      Nothing -> calcMinimumCost' nextSituations\n      Just (_, _, _, _, c)  -> c\n      where\n        nextSituations = situations >>= getNextSituation\n\ngetNextSituation :: Situation -> [Situation]\ngetNextSituation situation = map explosion $ getNextMove situation\n\ngetNextMove :: Situation -> [Situation]\ngetNextMove (w, h, (px,py), es, c)\n  | py == 0 && px < w-1 = [(w, h, (px + 1,py), es, nextCost), (w, h, (px,py + 1), es, nextCost)]\n  | py < h-1             = [(w, h, (px,py + 1), es, nextCost)]\n  | otherwise\t\t\t = []\n  where \n    nextCost = c + 1\n\nexplosion :: Situation -> Situation\nexplosion (w, h, (px,py), es, c) = (w, h, (px,py), filter (not.isHit) es, c)\n  where\n    isHit (ex,ey) = px == ex || py == ey\n\ngetEnd :: [Situation] -> Maybe Situation\ngetEnd [] = Nothing\ngetEnd ss = safeHead $ filter isEnd ss\n\nisEnd :: Situation -> Bool\nisEnd (_, _, _, [], _) = True\nisEnd (_, _, _, _, _) = False\n    \nsafeHead [] = Nothing\nsafeHead (a:_) = Just a\n\ngetSplitedLines =  do\n  s <- getContents\n  return $ map (map read) $ map (splitOn \" \") $ lines s\n\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport Data.List.Split\n\n\ntype Width = Int\ntype Height = Int\ntype Enemy = (Int,Int)\ntype Player = (Int,Int)\ntype Cost = Int\ntype Situation = (Width, Height, Player, [Enemy], Cost)\n\nmain = do\n  input <- getSplitedLines\n  let (w:h:_) = head input\n  let enemys = map (\\(a:b:_) -> (a, b)) $ drop 1 input\n  let player = (0,0)\n  let cost = 0\n  let minimumCost = calcMinimumCost (w, h, player, enemys, cost)\n  putStrLn $ show minimumCost\n\ncalcMinimumCost :: Situation -> Cost\ncalcMinimumCost situation = calcMinimumCost' [explosion situation]\n  where\n    calcMinimumCost' :: [Situation] -> Cost\n    calcMinimumCost' situations = case getEnd situations of\n      Nothing -> calcMinimumCost' nextSituations\n      Just (_, _, _, _, c)  -> c\n      where\n        nextSituations = situations >>= getNextSituation\n\ngetNextSituation :: Situation -> [Situation]\ngetNextSituation situation = map explosion $ getNextMove situation\n\ngetNextMove :: Situation -> [Situation]\ngetNextMove (w, h, (px,py), es, c)\n  | py == 0 && px < w-1 = [(w, h, (px + 1,py), es, nextCost), (w, h, (px,py + 1), es, nextCost)]\n  | py < h-1             = [(w, h, (px,py + 1), es, nextCost)]\n  | otherwise\t\t\t = []\n  where \n    nextCost = c + 1\n\nexplosion :: Situation -> Situation\nexplosion (w, h, (px,py), es, c) = (w, h, (px,py), filter (not.isHit) es, c)\n  where\n    isHit (ex,ey) = px == ex || py == ey\n\ngetEnd :: [Situation] -> Maybe Situation\ngetEnd [] = Nothing\ngetEnd ss = safeHead $ filter isEnd ss\n\nisEnd :: Situation -> Bool\nisEnd (_, _, _, [], _) = True\nisEnd (_, _, _, _, _) = False\n    \nsafeHead [] = Nothing\nsafeHead (a:_) = Just a\n\ngetSplitedLines =  do\n  s <- getContents\n  return $ map (map read) $ map (splitOn \" \") $ lines s\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0364: Dungeon\n// 2017.12.20\n\n#include <stdio.h>\n\nint max[100001];\nchar buf[30], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint w, h, n, x, y, ans;\n\n\tfgets(p=buf, 30, stdin);\n\tw = in(), h = in(), n = in();\n\twhile (n-- > 0) {\n\t\tfgets(p=buf, 20, stdin);\n\t\tx = in(), y = in();\n\t\tif (y > max[x]) max[x] = y;\n\t}\n\n\tans = 0x7fffff;\n\tx = w, y = 0; while (x--) {\n\t\tif (x+y < ans) ans = x+y;\n\t\tif (max[x] > y) y = max[x];\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val (w, _, n) =\n        readLine()!!.split(\" \").map { it.toInt() }\n    val rangeMaxY = IntArray(w)//iからwまでの間に居る敵のy座標の最大値\n    val maxY = IntArray(w)//i列目の敵のy座標最大値\n    repeat(n) {\n        val (x, y) = readLine()!!.split(\" \").map { it.toInt() }\n        maxY[x] = Math.max(maxY[x], y)\n    }\n    for(i in w - 2 downTo 0) {\n        rangeMaxY[i] = Math.max(maxY[i+1], rangeMaxY[i+1])\n    }\n\n    val min_cost = rangeMaxY.mapIndexed(Int::plus).min()!!\n    println(min_cost)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.max\nimport java.util.*\n\nfun <T> T.also(func:T.() -> Unit):T {\n    this.func()\n    return this\n}\nfun main(args:Array<String>):Unit {\n    val (_, _, n) = readLine()!!.split(' ').map(String::toInt)\n    val enemies = Stack<Enemy>().also{\n        push(Enemy(0, 0))\n        repeat(n){\n            val (x, y) = readLine()!!.split(' ').map(String::toInt)\n            push(Enemy(x, y))\n        }\n        sortedBy(Enemy::x).toTypedArray()\n    }\n    val maxY = Array(n + 1){0}\n    for (i in (n - 1) downTo 0){\n        maxY[i] = max(maxY[i + 1], enemies[i + 1].y)\n    }\n    println(enemies.mapIndexed{index, enemy -> enemy.x + maxY[index]}.min())\n}\ndata class Enemy(val x:Int, val y:Int)\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.max\nimport java.util.*\n\nfun <T> T.also(func:T.() -> Unit):T {\n    this.func()\n    return this\n}\nfun main(args:Array<String>):Unit {\n    val (_, _, n) = readLine()!!.split(' ').map(String::toInt)\n    val enemies = Stack<Enemy>().also{\n        push(Enemy(0, 0))\n        repeat(n){\n            val (x, y) = readLine()!!.split(' ').map(String::toInt)\n            push(Enemy(x, y))\n        }\n    }.sortedBy(Enemy::x).toTypedArray()\n    val maxY = Array(n + 1){0}\n    for (i in (n - 1) downTo 0){\n        maxY[i] = max(maxY[i + 1], enemies[i + 1].y)\n    }\n    println(enemies.mapIndexed{index, enemy -> enemy.x + maxY[index]}.min())\n}\ndata class Enemy(val x:Int, val y:Int)\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.max\n\nfun main(args:Array<String>):Unit {\n    val (w, h, n) = readLine()!!.split(' ').map(String::toInt)\n    val enemy = Array(n){\n        val (x, y) = readLine()!!.split(' ').map(String::toInt)\n        Enemy(x, y)\n    }.sortedBy(Enemy::x)\n    val maxY = Array(n){0}\n    maxY[n - 1] = 0\n    for (i in (n - 2) downTo 0){\n        maxY[i] = max(enemy[i + 1].y, maxY[i + 1])\n    }\n    println(enemy.mapIndexed{index, e -> e.x + maxY[index]}.min())\n\n}\ndata class Enemy(val x:Int, val y:Int)\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.max\n\nfun main(args:Array<String>):Unit {\n    val (_, _, n) = readLine()!!.split(' ').map(String::toInt)\n    val enemy = Array(n){\n        val (x, y) = readLine()!!.split(' ').map(String::toInt)\n        Enemy(x, y)\n    }.sortedBy(Enemy::x)\n    val maxY = Array(n){0}\n    maxY[n - 1] = 0\n    for (i in (n - 2) downTo 0){\n        maxY[i] = max(enemy[i + 1].y, maxY[i + 1])\n    }\n    println(enemy.mapIndexed{index, e -> e.x + maxY[index]}.min())\n\n}\ndata class Enemy(val x:Int, val y:Int)\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var w = int.Parse(line[0]);\n        var h = int.Parse(line[1]);\n        var n = int.Parse(line[2]);\n        var maxX = new int[h];\n        var maxY = new int[w];\n        for (int i = 0; i < n; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            var x = int.Parse(line[0]);\n            var y = int.Parse(line[1]);\n            if (x > maxX[y]) maxX[y] = x;\n            if (y > maxY[x]) maxY[x] = y;\n        }\n        if (w > h)\n        {\n            var t = getMax2(maxX);\n            var ans = getAns(t);\n            Console.WriteLine(ans);\n        }\n        else if (w < h)\n        {\n            var t = getMax2(maxY);\n            var ans = getAns(t);\n            Console.WriteLine(ans);\n        }\n        else\n        {\n            var t = getMax2(maxX);\n            var ans = getAns(t);\n            var t2= getMax2(maxY);\n            var ans2 = getAns(t2);\n            Console.WriteLine(Min(ans,ans2));\n        }\n    }\n    static int getAns(int[] a)\n    {\n        var p = 0;\n        var ans = int.MaxValue;\n        foreach (var x in a)\n            ans = Min(ans, x + p++);\n        return ans;\n    }\n    static int[] getMax2(int[] a)\n    {\n        var aL = a.Length;\n        var b = new int[aL];\n        for (int i = aL - 1; i >= 1; i--)\n            b[i - 1] = Max(b[i], a[i]);\n        return b;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nclass P\n{\n    static void Main()\n    {\n        int[] whn = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        int[] maxH = new int[whn[0]];\n        int[] maxW = new int[whn[1]];\n        for (int i = 0; i < whn[2]; i++)\n        {\n            int[] xy = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            maxH[xy[0]] = Max(maxH[xy[0]], xy[1]);\n            maxW[xy[1]] = Max(maxW[xy[1]], xy[0]);\n        }\n        int[] ruisekiMH = new int[whn[0] + 1];\n        for (int i = whn[0] - 1; i >= 0; i--)\n        {\n            ruisekiMH[i] = Max(ruisekiMH[i + 1], maxH[i]);\n        }\n        int[] ruisekiWH = new int[whn[1] + 1];\n        for (int i = whn[1] - 1; i >= 0; i--)\n        {\n            ruisekiWH[i] = Max(ruisekiWH[i + 1], maxW[i]);\n        }\n        int res = int.MaxValue;\n        for (int i = 0; i < whn[0]; i++)\n        {\n            res = Min(res, i + ruisekiMH[i + 1]);\n        }\n        for (int i = 0; i < whn[1]; i++)\n        {\n            res = Min(res, i + ruisekiWH[i + 1]);\n        }\n        Console.WriteLine(res);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace _0364\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\tint[] max = new int[x[0] + 10];\n\t\t\tfor (int i = 0; i < x[2]; i++)\n\t\t\t{\n\t\t\t\tint[] a = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\t\tif (a[0] > 0) max[a[0] - 1] = Math.Max(max[a[0] - 1], a[1]);\n\t\t\t}\n\t\t\tint n = 0;\n\t\t\tfor (int i = x[0]; i >= 0; i--)\n\t\t\t{\n\t\t\t\tn = Math.Max(n, max[i]);\n\t\t\t\tmax[i] = n;\n\t\t\t}\n\t\t\tint ret = int.MaxValue;\n\t\t\tfor (int i = 0; i <= x[0]; i++)\n\t\t\t{\n\t\t\t\tret = Math.Min(ret, i + max[i]);\n\t\t\t}\n\t\t\tConsole.WriteLine(ret);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "w, h, n = gets.split.map(&:to_i)\na = (1..n).map { gets.split.map(&:to_i) }.sort_by(&:max)\ni = j = 0\nuntil a.empty?\n    y, x = a.pop\n    next if i >= y or j >= x\n    if y < x\n        i = y\n    else\n        j = x\n    end\nend\np i + j\n"
  },
  {
    "language": "Ruby",
    "code": "w, h, n = gets.split.map(&:to_i)\nmax_y = Hash.new(0)\nn.times do\n    x, y = gets.split.map(&:to_i)\n    max_y[x] = y if y > max_y[x]\nend\nd = w - 1\ny = 0\n(w - 2).downto(0) do |x|\n    y = max_y[x + 1] if y < max_y[x + 1]\n    d = x + y if d > x + y\nend\np d\n"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n  import std.typecons;\n\n  int w, h, n; rd(w, h, n);\n  alias P=Tuple!(int, \"x\", int, \"y\");\n  auto a=new P[](0);\n  foreach(_; 0..n){\n    int x, y; rd(x, y);\n    a~=P(x, y);\n  }\n\n  auto b=a.dup;\n  sort(a); reverse(a);\n  sort!\"a[1]==b[1] ? a[0]>b[0] : a[1]>b[1]\"(b);\n  int[P] used;\n  \n  int i=0, j=0, sum=0;\n  while(1){\n    auto p=a[i], q=b[j];\n    sum+=min(p.y, q.x);\n    if(p==q) break;\n\n    while(i<n && a[i].y==p.y) used[a[i++]]=1;\n    while(j<n && b[j].x==q.x) used[b[j++]]=1;\n\n    if(used.length>=n) break;\n  }\n\n  writeln(sum);\n  \n  \n}\n\nvoid chmax(T)(ref T x, T y){\n  if(x<y) x=y;\n}\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}"
  },
  {
    "language": "D",
    "code": "void main(){\n  import std.stdio, std.string, std.conv, std.algorithm;\n  import std.typecons;\n\n  int w, h, n; rd(w, h, n);\n  alias P=Tuple!(int, \"x\", int, \"y\");\n  auto a=new P[](0);\n  foreach(_; 0..n){\n    int x, y; rd(x, y);\n    a~=P(x, y);\n  }\n\n  auto b=a.dup;\n  sort(a); reverse(a);\n  sort!\"a[1]==b[1] ? a[0]>b[0] : a[1]>b[1]\"(b);\n  int[P] used;\n  \n  int i=0, j=0, sum=0;\n  while(1){\n    auto p=a[i], q=b[j];\n    sum+=min(p.y, q.x);\n\n    while(i<n && a[i].y==p.y) used[a[i++]]=1;\n    while(j<n && b[j].x==q.x) used[b[j++]]=1;\n\n    if(used.length>=n) break;\n  }\n\n  writeln(sum);\n  \n  \n}\n\nvoid chmax(T)(ref T x, T y){\n  if(x<y) x=y;\n}\nvoid rd(T...)(ref T x){\n  import std.stdio, std.string, std.conv;\n  auto l=readln.split;\n  foreach(i, ref e; x){\n    e=l[i].to!(typeof(e));\n  }\n}"
  },
  {
    "language": "Python",
    "code": "w, h, n = map(int, input().split())\na = []\nfor _ in range(n):\n    a.append(tuple(map(int, input().split())))\nmins = min(w, h)\ni = 0\nwhile i <  mins:\n    mins = min(mins, i + max((j[0] > i) * j[1] for j in a))\n    i += 1\nprint(mins)\n"
  },
  {
    "language": "Python",
    "code": "class Node(object):#Nodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n\n    def getName(self):#Nodeの名前を返す\n        return self.name\n\n    def __str__(self):\n        return self.name\n\nclass Node_W(Node):#重さ付きNodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n        self.w = 0\n\n    def addWeight(self,weight):\n        self.w += weight\n\n\n\n\nclass Edge(object):#エッジを扱うクラス\n\n    def __init__(self, src, dest):\n        self.src = src\n        self.dest = dest\n\n    def getSource(self):#親Nodeを返す\n        return self.src\n\n    def getDestination(self):#子Nodeを返す\n        return self.dest\n\n    def __str__(self):\n        return self.src + \"->\" + self.dest\n\nclass Graph(object):\n\n    def __init__(self):\n        self.Nodes = []#グラフ上のNode\n        self.Edges = {}#グラフ上のエッジ親Nodeのキーに対して子Nodeのリストを返す\n\n    def addNode(self, node):#グラフにNodeを加える\n        if(node in self.Nodes):\n            raise ValueError(\"そのNodeはもうあるよ\")\n        else:\n            self.Nodes.append(node)\n            self.Edges[node] = []#nodeの子Nodeのリスト\n\n    def addEdges(self, edge):#グラフ上にエッジを加える\n        src = edge.getSource()\n        dest = edge.getDestination()\n        if src not in self.Nodes or dest not in self.Nodes:\n            raise ValueError(\"そのNodeはグラフ上にありません\")\n        else:\n            self.Edges[src].append(dest)\n\n    def getChildList(self,node):#nodeの子Nodeのリストを返す\n        return self.Edges[node]\n\n    def put_player(self, x, y, W, H, L):#x, yはplayerの座標, W, Hはx, y座標の限界,Lは受け取ったNode_W型を含むリスト\n        index = (H*y) + x\n        if index >= H*W:\n            raise ValueError(\"そんな座標はないよ\")\n        else:\n            L[index].w = 1\n\n    def __str__(self):\n        s = \"\"\n        for src in self.Nodes:\n            for dest in self.Edges[src]:\n                s = s + src.getNode() + \"->\" + dest.getNode() + '\\n'\n        return s\n\n\ndef ShowPath(path):#pathはNode_W型からなるリスト\n    s = \"\"\n    for nextNode in range(len(path)):\n        s = s + path[nextNode].getName() + \"(\" +  str(path[nextNode].w) + \")\"\n        if nextNode != len(path) - 1:\n            s = s + \"->\"\n    return s\n\nall_path1 = []#すべての経路を保存する\ncount = 0\n\ndef all_search(g, start, end, path, all_path, toPrint = True):#グラフ上の全経路を保存する\n    path = path + [start]\n    if toPrint == True:\n        ShowPath(path)\n        all_path.append(path)\n    for child in g.getChildList(start):\n        if child not in path:#ループはしない\n            newpath = all_search(g,child,end,path,all_path,toPrint = True)\n\n\ndef make_field(W,H):\n    #W,Hはint型\n    point = [[0 for i in range(H)] for j in range(W)]\n    for x in range(W):\n        for y in range(H):\n            point[x][y] = 0\n    Nodes= [] #pointの要素数分だけNode_Wを作りリストに保存する\n    for i in range(0,W * H,1):\n        Nodes.append(Node_W(str(i)))\n    g = Graph()\n    for i in range(0,W*H, 1):#グラフ上にNodesで作ったNodeを追加する\n        g.addNode(Nodes[i])\n    for i in range(H):\n        for w in range(W):\n           num = (H*i) + w\n           if(i != H - 1):#この時は下につなげるNodeがある\n               g.addEdges(Edge(Nodes[num],Nodes[num + W]))\n           if(w != W - 1):#この時は横につなげるNodeがある\n               g.addEdges(Edge(Nodes[num], Nodes[num + 1]))\n    return g\n\nclass Player(object):\n\n    def __init__(self, x, y, L,g,W,H):#x,yはplayerを配置する座標, LはNode_W型を含むリスト,gはplayerを配置するField,W,Xはx座標y座標の限界\n        g.put_player(x,y,W,H,L)\n        \n\nclass Main(Player):\n\n    def __init__(self,L,g,W,H):\n        g.put_player(0,0,W,H,L)\n        self.cost = 0\n        self.now_position = 0\n        self.W = W\n        self.H = H\n        self.L = L\n\n    def move(self,g, node):#gはgraph型,nodeはNode型,与えられたNodeへ進む\n        g.Nodes[self.now_position].w = 0\n        self.now_position = int(node.getName())\n        g.Nodes[self.now_position].w = 1\n        if(int(node.getName()) == 0):\n            self.cost += 0 #0番に移動する場合はコスト0\n        else:\n            self.cost += 1\n\n\n    def destroy(self, g):\n        h1 = self.H\n        h2 = self.H\n        mod = self.now_position % self.W\n        i = 1\n        j = 1\n        g.Nodes[self.now_position].w = 0\n        while(self.now_position - h1 >= 0):#現在位置の上の敵を消す\n            g.Nodes[self.now_position - h1].w = 0\n            h1 += self.H\n        while(self.now_position + h2 < self.H * self.W):#現在位置の下の敵を消す\n            g.Nodes[self.now_position + h2].w = 0\n            h2 += self.H\n        while((self.now_position - i)  % self.W != self.W - 1 and self.now_position - i < self.H * self.W):#現在位置の左の敵を消す\n            g.Nodes[self.now_position - i].w = 0\n            i += 1\n        while((self.now_position + j) % self.W != 0 and self.now_position + j < self.H * self.W):#現在位置の右の敵を消す\n            g.Nodes[self.now_position + j].w = 0\n            j += 1\n\ndef ShowGraph(g,H,W):#gはgraph型\n    result = \"\"\n    for h in range(H):\n        for w in range(W):\n            result = result + g.Nodes[(H * h) + w].getName() + \"(\" + str(g.Nodes[(H*h) + w].w) + \")\"\n            if(w != W - 1):\n                result = result + \"->\"\n            else:\n                result = result + '\\n'\n        if (h != H -1):\n            for w in range(W):\n                k = int(g.Nodes[(H*h) + w].getName())\n                s = 0\n                while(k//10 != 0):\n                    s += 1\n                    k /= 10\n                result = result + \"↓\" + \"    \" + \" \"*s\n                s = 0\n                if(w == W - 1):\n                    result = result + '\\n'\n    return result\n\ndef SearchWeight(g):#gはgraph型,graph上のNodeがすべて0ならTrue,それ以外ならFalseを返す\n    for i in range(len(g.Nodes)):\n        if g.Nodes[i].w == 1:\n            return False\n    return True\n\n\ndef test7():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    break\n     print(str(min))\n\ntest7()\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Node(object):#Nodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n\n    def getName(self):#Nodeの名前を返す\n        return self.name\n\n    def __str__(self):\n        return self.name\n\nclass Node_W(Node):#重さ付きNodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n        self.w = 0\n\n    def addWeight(self,weight):\n        self.w += weight\n\n\n\n\nclass Edge(object):#エッジを扱うクラス\n\n    def __init__(self, src, dest):\n        self.src = src\n        self.dest = dest\n\n    def getSource(self):#親Nodeを返す\n        return self.src\n\n    def getDestination(self):#子Nodeを返す\n        return self.dest\n\n    def __str__(self):\n        return self.src + \"->\" + self.dest\n\nclass Graph(object):\n\n    def __init__(self):\n        self.Nodes = []#グラフ上のNode\n        self.Edges = {}#グラフ上のエッジ親Nodeのキーに対して子Nodeのリストを返す\n\n    def addNode(self, node):#グラフにNodeを加える\n        if(node in self.Nodes):\n            raise ValueError(\"そのNodeはもうあるよ\")\n        else:\n            self.Nodes.append(node)\n            self.Edges[node] = []#nodeの子Nodeのリスト\n\n    def addEdges(self, edge):#グラフ上にエッジを加える\n        src = edge.getSource()\n        dest = edge.getDestination()\n        if src not in self.Nodes or dest not in self.Nodes:\n            raise ValueError(\"そのNodeはグラフ上にありません\")\n        else:\n            self.Edges[src].append(dest)\n\n    def getChildList(self,node):#nodeの子Nodeのリストを返す\n        return self.Edges[node]\n\n    def put_player(self, x, y, W, H, L):#x, yはplayerの座標, W, Hはx, y座標の限界,Lは受け取ったNode_W型を含むリスト\n        k = W - H\n        index = (H*y) + x + k*y\n        if index >= H*W:\n            raise ValueError(\"そんな座標はないよ\")\n        else:\n            L[index].w = 1\n\n    def __str__(self):\n        s = \"\"\n        for src in self.Nodes:\n            for dest in self.Edges[src]:\n                s = s + src.getNode() + \"->\" + dest.getNode() + '\\n'\n        return s\n\n\ndef ShowPath(path):#pathはNode_W型からなるリスト\n    s = \"\"\n    for nextNode in range(len(path)):\n        s = s + path[nextNode].getName() + \"(\" +  str(path[nextNode].w) + \")\"\n        if nextNode != len(path) - 1:\n            s = s + \"->\"\n    return s\n\nall_path1 = []#すべての経路を保存する\ncount = 0\n\ndef all_search(g, start, end, path, all_path, toPrint = True):#グラフ上の全経路を保存する\n    path = path + [start]\n    if toPrint == True:\n        ShowPath(path)\n        all_path.append(path)\n    for child in g.getChildList(start):\n        if child not in path:#ループはしない\n            newpath = all_search(g,child,end,path,all_path,toPrint = True)\n\n\ndef make_field(W,H):\n    #W,Hはint型\n    k = 0\n    if (W < H):\n        k = W - H\n    elif(W > H):\n        k = W - H\n    Nodes= [] #pointの要素数分だけNode_Wを作りリストに保存する\n    for i in range(0,W * H,1):\n        Nodes.append(Node_W(str(i)))\n    g = Graph()\n    for i in range(0,W*H, 1):#グラフ上にNodesで作ったNodeを追加する\n        g.addNode(Nodes[i])\n    for i in range(H):\n        for w in range(W):\n            num = (H*i) + w + k * i\n            if(i != H - 1):#この時は下につなげるNodeがある\n                g.addEdges(Edge(Nodes[num],Nodes[num + W]))\n            if(w != W - 1):#この時は横につなげるNodeがある\n                g.addEdges(Edge(Nodes[num], Nodes[num + 1]))\n     \n    return g\n\nclass Player(object):\n\n    def __init__(self, x, y, L,g,W,H):#x,yはplayerを配置する座標, LはNode_W型を含むリスト,gはplayerを配置するField,W,Xはx座標y座標の限界\n        g.put_player(x,y,W,H,L)\n        \n\nclass Main(Player):\n\n    def __init__(self,L,g,W,H):\n        g.put_player(0,0,W,H,L)\n        self.cost = 0\n        self.now_position = 0\n        self.W = W\n        self.H = H\n        self.L = L\n\n    def move(self,g, node):#gはgraph型,nodeはNode型,与えられたNodeへ進む\n        g.Nodes[self.now_position].w = 0\n        self.now_position = int(node.getName())\n        g.Nodes[self.now_position].w = 0\n        if(int(node.getName()) == 0):\n            self.cost += 0 #0番に移動する場合はコスト0\n        else:\n            self.cost += 1\n\n\n    def destroy(self, g):\n        h1 = self.H\n        h2 = self.H\n        mod = self.now_position % self.W\n        i = 1\n        j = 1\n        k = self.W - self.H\n        g.Nodes[self.now_position].w = 0\n        while(self.now_position - h1 >= 0):#現在位置の上の敵を消す\n            g.Nodes[self.now_position - h1].w = 0\n            h1 += self.H - k\n        while(self.now_position + h2 < self.H * self.W):#現在位置の下の敵を消す\n            g.Nodes[self.now_position + h2].w = 0\n            h2 += self.H + k\n        while((self.now_position - i)  % self.W != self.W - 1 and self.now_position - i < self.H * self.W and self.now_position - i > 0):#現在位置の左の敵を消す\n            g.Nodes[self.now_position - i].w = 0\n            i += 1\n        while((self.now_position + j) % self.W != 0 and self.now_position + j < self.H * self.W and self.now_position + j > 0):#現在位置の右の敵を消す\n            g.Nodes[self.now_position + j].w = 0\n            j += 1\n\ndef ShowGraph(g,H,W):#gはgraph型\n    result = \"\"\n    k = W - H\n    for h in range(H):\n        for w in range(W):\n            result = result + g.Nodes[(H * h) + w +  k*h].getName() + \"(\" + str(g.Nodes[(H*h) + w + k * h].w) + \")\"\n            if(w != W - 1):\n                result = result + \"->\"\n            else:\n                result = result + '\\n'\n        if (h != H -1):\n            for w in range(W):\n                t = int(g.Nodes[(H*h) + w + k * h].getName())\n                s = 0\n                while(t//10 != 0):\n                    s += 1\n                    t /= 10\n                result = result + \"↓\" + \"    \" + \" \"*s\n                s = 0\n                if(w == W - 1):\n                    result = result + '\\n'\n    return result\n\ndef SearchWeight(g):#gはgraph型,graph上のNodeがすべて0ならTrue,それ以外ならFalseを返す\n    for i in range(len(g.Nodes)):\n        if g.Nodes[i].w == 1:\n            return False\n    return True\n\n\n\n\n\ndef test1():#グラフが正常につくられているかテスト\n    g = make_field(6,6)\n    start = g.Nodes[0]\n    end = g.Nodes[6*6 - 1]\n    all_path = []\n    all_search(g, start, end, [], all_path,toPrint = True )\n    main = Player(0,0,g.Nodes,g,6,6)\n    enemy1 = Player(1,1,g.Nodes,g, 6,6)\n    enemy2 = Player(5,5,g.Nodes,g, 6,6)\n    for i in range(len(all_path)):\n        print(ShowPath(all_path[i]))\n        print(str(i))\n\n\ndef test2():#正常に爆破ができるのかを確かめるテスト\n    W, H = map(int, input().split())\n    g = make_field(W, H)\n    all_path = []\n    start = g.Nodes[0]\n    end = g.Nodes[W*H - 1]\n    main = Main(g.Nodes,g,W,H)\n    N = int(input())\n    for i in range(N):\n        x, y = map(int, input().split())\n        Player(x, y, g.Nodes,g,W,H)\n    all_search(g,start, end, [], all_path, toPrint = True)\n    print(ShowGraph(g, H, W))\n    main.move(g,g.Nodes[6])\n    main.destroy(g)\n    print(\"爆破！\")\n    print(ShowGraph(g,H,W))\n\n\ndef test3():#グラフ上のある経路を正常に動くのかテスト\n     W, H = map(int, input().split())\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     main = Main(g.Nodes,g,W,H)\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         Player(x, y, g.Nodes,g,W,H)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print(ShowPath(all_path[4]))\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for path in (all_path[4]):\n         main.move(g,path)\n         print(str(path.getName())+\"番に移動しました!\")\n         print()#改行\n         print(ShowGraph(g, H, W))\n         print()\n         print(\"現在までのコスト :\",str(main.cost))\n         print()#改行\n     for i in range(len(all_path)):\n        print(ShowPath(all_path[i]))\n        print(str(i))\n\ndef test4():#1つの経路で動くたびに爆発できるのかテスト\n     W, H = map(int, input().split())\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     main = Main(g.Nodes,g,W,H)\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         Player(x, y, g.Nodes,g,W,H)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print(ShowPath(all_path[4]))\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for path in (all_path[4]):\n         main.move(g,path)\n         print(str(path.getName())+\"番に移動しました!\")\n         print()#改行\n         print(ShowGraph(g, H, W))\n         main.destroy(g)\n         print(\"爆破しました!\")\n         print(ShowGraph(g, H, W))\n         print()\n         print(\"現在までのコスト :\",str(main.cost))\n         print()#改行\n\n\ndef test5():#全経路に関して爆発を試す\n     W, H = map(int, input().split())\n     X = []\n     Y = []\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n\ndef test6():#全経路に関して爆発を試す\n     W, H = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n                if main.cost < min:\n                    min = main.cost\n                    break\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n        print(\"現在の最小コスト :\",str(min))\n\ndef test7():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     l = 0\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    l = root\n                    break\n     print(str(min))\n     print(ShowPath(l))\n     for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n     main = Main(g.Nodes, g, W, H)\n     for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n                break\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n         \ndef test8():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    break\n     print(str(min))\n\ntest8()\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "W, H, N = map(int, input().split())\nP = [list(map(int, input().split())) for i in range(N)]\nP.sort()\nst = []\nfor x, y in P:\n    while st and (st[-1][0] == x or st[-1][1] <= y):\n        st.pop()\n    st.append((x, y))\n\nans = 10**9\nprv = 0\nfor x, y in st:\n    ans = min(ans, prv+y)\n    prv = x\nans = min(ans, prv)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "class Node(object):#Nodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n\n    def getName(self):#Nodeの名前を返す\n        return self.name\n\n    def __str__(self):\n        return self.name\n\nclass Node_W(Node):#重さ付きNodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n        self.w = 0\n\n    def addWeight(self,weight):\n        self.w += weight\n\n\n\n\nclass Edge(object):#エッジを扱うクラス\n\n    def __init__(self, src, dest):\n        self.src = src\n        self.dest = dest\n\n    def getSource(self):#親Nodeを返す\n        return self.src\n\n    def getDestination(self):#子Nodeを返す\n        return self.dest\n\n    def __str__(self):\n        return self.src + \"->\" + self.dest\n\nclass Graph(object):\n\n    def __init__(self):\n        self.Nodes = []#グラフ上のNode\n        self.Edges = {}#グラフ上のエッジ親Nodeのキーに対して子Nodeのリストを返す\n\n    def addNode(self, node):#グラフにNodeを加える\n        if(node in self.Nodes):\n            raise ValueError(\"そのNodeはもうあるよ\")\n        else:\n            self.Nodes.append(node)\n            self.Edges[node] = []#nodeの子Nodeのリスト\n\n    def addEdges(self, edge):#グラフ上にエッジを加える\n        src = edge.getSource()\n        dest = edge.getDestination()\n        if src not in self.Nodes or dest not in self.Nodes:\n            raise ValueError(\"そのNodeはグラフ上にありません\")\n        else:\n            self.Edges[src].append(dest)\n\n    def getChildList(self,node):#nodeの子Nodeのリストを返す\n        return self.Edges[node]\n\n    def put_player(self, x, y, W, H, L):#x, yはplayerの座標, W, Hはx, y座標の限界,Lは受け取ったNode_W型を含むリスト\n        k = W - H\n        index = (H*y) + x + k*y\n        if index >= H*W:\n            raise ValueError(\"そんな座標はないよ\")\n        else:\n            L[index].w = 1\n\n    def __str__(self):\n        s = \"\"\n        for src in self.Nodes:\n            for dest in self.Edges[src]:\n                s = s + src.getNode() + \"->\" + dest.getNode() + '\\n'\n        return s\n\n\ndef ShowPath(path):#pathはNode_W型からなるリスト\n    s = \"\"\n    for nextNode in range(len(path)):\n        s = s + path[nextNode].getName() + \"(\" +  str(path[nextNode].w) + \")\"\n        if nextNode != len(path) - 1:\n            s = s + \"->\"\n    return s\n\nall_path1 = []#すべての経路を保存する\ncount = 0\n\ndef all_search(g, start, end, path, all_path, toPrint = True):#グラフ上の全経路を保存する\n    path = path + [start]\n    if toPrint == True:\n        ShowPath(path)\n        all_path.append(path)\n    for child in g.getChildList(start):\n        if child not in path:#ループはしない\n            newpath = all_search(g,child,end,path,all_path,toPrint = True)\n\n\ndef make_field(W,H):\n    #W,Hはint型\n    k = 0\n    k = W - H\n    Nodes= [] #pointの要素数分だけNode_Wを作りリストに保存する\n    for i in range(0,W * H,1):\n        Nodes.append(Node_W(str(i)))\n    g = Graph()\n    for i in range(0,W*H, 1):#グラフ上にNodesで作ったNodeを追加する\n        g.addNode(Nodes[i])\n    for i in range(H):\n        for w in range(W):\n            num = (H*i) + w + k * i\n            if(i != H - 1):#この時は下につなげるNodeがある\n                g.addEdges(Edge(Nodes[num],Nodes[num + W]))\n            if(w != W - 1):#この時は横につなげるNodeがある\n                g.addEdges(Edge(Nodes[num], Nodes[num + 1]))\n     \n    return g\n\nclass Player(object):\n\n    def __init__(self, x, y, L,g,W,H):#x,yはplayerを配置する座標, LはNode_W型を含むリスト,gはplayerを配置するField,W,Xはx座標y座標の限界\n        g.put_player(x,y,W,H,L)\n        \n\nclass Main(Player):\n\n    def __init__(self,L,g,W,H):\n        g.put_player(0,0,W,H,L)\n        self.cost = 0\n        self.now_position = 0\n        self.W = W\n        self.H = H\n        self.L = L\n\n    def move(self,g, node):#gはgraph型,nodeはNode型,与えられたNodeへ進む\n        g.Nodes[self.now_position].w = 0\n        self.now_position = int(node.getName())\n        g.Nodes[self.now_position].w = 0\n        if(int(node.getName()) == 0):\n            self.cost += 0 #0番に移動する場合はコスト0\n        else:\n            self.cost += 1\n\n\n    def destroy(self, g):\n        h1 = self.W\n        h2 = self.W\n        mod = self.now_position % self.W\n        i = 1\n        j = 1\n        k = self.W - self.H\n        g.Nodes[self.now_position].w = 0\n        while(self.now_position - h1 >= 0):#現在位置の上の敵を消す\n            g.Nodes[self.now_position - h1].w = 0\n            h1 += self.W\n        while(self.now_position + h2 < self.H * self.W):#現在位置の下の敵を消す\n            g.Nodes[self.now_position + h2].w = 0\n            h2 += self.W\n        while((self.now_position - i)  % self.W != self.W - 1 and self.now_position - i < self.H * self.W and self.now_position - i > 0):#現在位置の左の敵を消す\n            g.Nodes[self.now_position - i].w = 0\n            i += 1\n        while((self.now_position + j) % self.W != 0 and self.now_position + j < self.H * self.W and self.now_position + j > 0):#現在位置の右の敵を消す\n            g.Nodes[self.now_position + j].w = 0\n\n            j += 1\n    def destroy2(self, g):\n        count = 0\n        h1 = self.W\n        h2 = self.W\n        mod = self.now_position % self.W\n        i = 1\n        j = 1\n        k = self.W - self.H\n        g.Nodes[self.now_position].w = 0\n        while(self.now_position - h1 >= 0):#現在位置の上の敵を消す\n            if(g.Nodes[self.now_position - h1].w == 1):\n                count += 1\n            g.Nodes[self.now_position - h1].w = 0\n            h1 += self.W\n        while(self.now_position + h2 < self.H * self.W):#現在位置の下の敵を消す\n            if(g.Nodes[self.now_position + h2].w == 1):\n                count += 1\n            g.Nodes[self.now_position + h2].w = 0\n            h2 += self.W\n        while((self.now_position - i)  % self.W != self.W - 1 and self.now_position - i < self.H * self.W and self.now_position - i > 0):#現在位置の左の敵を消す\n            if(g.Nodes[self.now_position - i].w == 1):\n                count += 1\n            g.Nodes[self.now_position - i].w = 0\n            i += 1\n        while((self.now_position + j) % self.W != 0 and self.now_position + j < self.H * self.W and self.now_position + j > 0):#現在位置の右の敵を消す\n            if(g.Nodes[self.now_position + j].w == 1):\n                count += 1\n            g.Nodes[self.now_position + j].w = 0\n            j += 1\n        return count\n\ndef ShowGraph(g,H,W):#gはgraph型\n    result = \"\"\n    k = W - H\n    for h in range(H):\n        for w in range(W):\n            result = result + g.Nodes[(H * h) + w +  k*h].getName() + \"(\" + str(g.Nodes[(H*h) + w + k * h].w) + \")\"\n            if(w != W - 1):\n                result = result + \"->\"\n            else:\n                result = result + '\\n'\n        if (h != H -1):\n            for w in range(W):\n                t = int(g.Nodes[(H*h) + w + k * h].getName())\n                s = 0\n                while(t//10 != 0):\n                    s += 1\n                    t /= 10\n                result = result + \"↓\" + \"    \" + \" \"*s\n                s = 0\n                if(w == W - 1):\n                    result = result + '\\n'\n    return result\n\ndef SearchWeight(g):#gはgraph型,graph上のNodeがすべて0ならTrue,それ以外ならFalseを返す\n    for i in range(len(g.Nodes)):\n        if g.Nodes[i].w == 1:\n            return False\n    return True\n\n\n\n\n\ndef test1():#グラフが正常につくられているかテスト\n    g = make_field(6,6)\n    start = g.Nodes[0]\n    end = g.Nodes[6*6 - 1]\n    all_path = []\n    all_search(g, start, end, [], all_path,toPrint = True )\n    main = Player(0,0,g.Nodes,g,6,6)\n    enemy1 = Player(1,1,g.Nodes,g, 6,6)\n    enemy2 = Player(5,5,g.Nodes,g, 6,6)\n    for i in range(len(all_path)):\n        print(ShowPath(all_path[i]))\n        print(str(i))\n\n\ndef test2():#正常に爆破ができるのかを確かめるテスト\n    W, H = map(int, input().split())\n    g = make_field(W, H)\n    all_path = []\n    start = g.Nodes[0]\n    end = g.Nodes[W*H - 1]\n    main = Main(g.Nodes,g,W,H)\n    N = int(input())\n    for i in range(N):\n        x, y = map(int, input().split())\n        Player(x, y, g.Nodes,g,W,H)\n    all_search(g,start, end, [], all_path, toPrint = True)\n    print(ShowGraph(g, H, W))\n    main.move(g,g.Nodes[6])\n    main.destroy(g)\n    print(\"爆破！\")\n    print(ShowGraph(g,H,W))\n\n\ndef test3():#グラフ上のある経路を正常に動くのかテスト\n     W, H = map(int, input().split())\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     main = Main(g.Nodes,g,W,H)\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         Player(x, y, g.Nodes,g,W,H)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print(ShowPath(all_path[4]))\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for path in (all_path[4]):\n         main.move(g,path)\n         print(str(path.getName())+\"番に移動しました!\")\n         print()#改行\n         print(ShowGraph(g, H, W))\n         print()\n         print(\"現在までのコスト :\",str(main.cost))\n         print()#改行\n     for i in range(len(all_path)):\n        print(ShowPath(all_path[i]))\n        print(str(i))\n\ndef test4():#1つの経路で動くたびに爆発できるのかテスト\n     W, H = map(int, input().split())\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     main = Main(g.Nodes,g,W,H)\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         Player(x, y, g.Nodes,g,W,H)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print(ShowPath(all_path[4]))\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for path in (all_path[4]):\n         main.move(g,path)\n         print(str(path.getName())+\"番に移動しました!\")\n         print()#改行\n         print(ShowGraph(g, H, W))\n         main.destroy(g)\n         print(\"爆破しました!\")\n         print(ShowGraph(g, H, W))\n         print()\n         print(\"現在までのコスト :\",str(main.cost))\n         print()#改行\n\n\ndef test5():#全経路に関して爆発を試す\n     W, H = map(int, input().split())\n     X = []\n     Y = []\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n\ndef test6():#全経路に関して爆発を試す\n     W, H = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n                if main.cost < min:\n                    min = main.cost\n                    break\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n        print(\"現在の最小コスト :\",str(min))\n\ndef test7():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     l = 0\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    l = root\n                    break\n     print(str(min))\n     print(ShowPath(l))\n     for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n     main = Main(g.Nodes, g, W, H)\n     for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n                break\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n         \ndef test8():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    break\n     print(str(min))\n\ndef test9():#すべての敵を消したら終わるパターン\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        n = N\n        for path in (root):\n            main.move(g,path)\n            count = main.destroy2(g)\n            n -= count\n            if(n == 0):\n                if main.cost < min:\n                    min = main.cost\n                    break\n     print(str(min))\n\ntest9()\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "w, h, n = map(int, input().split())\nxys = sorted([list(map(int, input().split())) for _ in range(n)])\ny_max = [0]\nfor _, y in reversed(xys):\n  y_max.append(max(y_max[-1], y))\nxs = [0] + [x for x, _ in xys]\nprint(min([xs[i] + y_max[n - i] for i in range(n + 1)]))\n"
  },
  {
    "language": "Python",
    "code": "class Node(object):#Nodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n\n    def getName(self):#Nodeの名前を返す\n        return self.name\n\n    def __str__(self):\n        return self.name\n\nclass Node_W(Node):#重さ付きNodeを扱うクラス\n\n    def __init__(self, name):\n        self.name = name\n        self.w = 0\n\n    def addWeight(self,weight):\n        self.w += weight\n\n\n\n\nclass Edge(object):#エッジを扱うクラス\n\n    def __init__(self, src, dest):\n        self.src = src\n        self.dest = dest\n\n    def getSource(self):#親Nodeを返す\n        return self.src\n\n    def getDestination(self):#子Nodeを返す\n        return self.dest\n\n    def __str__(self):\n        return self.src + \"->\" + self.dest\n\nclass Graph(object):\n\n    def __init__(self):\n        self.Nodes = []#グラフ上のNode\n        self.Edges = {}#グラフ上のエッジ親Nodeのキーに対して子Nodeのリストを返す\n\n    def addNode(self, node):#グラフにNodeを加える\n        if(node in self.Nodes):\n            raise ValueError(\"そのNodeはもうあるよ\")\n        else:\n            self.Nodes.append(node)\n            self.Edges[node] = []#nodeの子Nodeのリスト\n\n    def addEdges(self, edge):#グラフ上にエッジを加える\n        src = edge.getSource()\n        dest = edge.getDestination()\n        if src not in self.Nodes or dest not in self.Nodes:\n            raise ValueError(\"そのNodeはグラフ上にありません\")\n        else:\n            self.Edges[src].append(dest)\n\n    def getChildList(self,node):#nodeの子Nodeのリストを返す\n        return self.Edges[node]\n\n    def put_player(self, x, y, W, H, L):#x, yはplayerの座標, W, Hはx, y座標の限界,Lは受け取ったNode_W型を含むリスト\n        k = W - H\n        index = (H*y) + x + k*y\n        if index >= H*W:\n            raise ValueError(\"そんな座標はないよ\")\n        else:\n            L[index].w = 1\n\n    def __str__(self):\n        s = \"\"\n        for src in self.Nodes:\n            for dest in self.Edges[src]:\n                s = s + src.getNode() + \"->\" + dest.getNode() + '\\n'\n        return s\n\n\ndef ShowPath(path):#pathはNode_W型からなるリスト\n    s = \"\"\n    for nextNode in range(len(path)):\n        s = s + path[nextNode].getName() + \"(\" +  str(path[nextNode].w) + \")\"\n        if nextNode != len(path) - 1:\n            s = s + \"->\"\n    return s\n\nall_path1 = []#すべての経路を保存する\ncount = 0\n\ndef all_search(g, start, end, path, all_path, toPrint = True):#グラフ上の全経路を保存する\n    path = path + [start]\n    if toPrint == True:\n        ShowPath(path)\n        all_path.append(path)\n    for child in g.getChildList(start):\n        if child not in path:#ループはしない\n            newpath = all_search(g,child,end,path,all_path,toPrint = True)\n\n\ndef make_field(W,H):\n    #W,Hはint型\n    k = 0\n    k = W - H\n    Nodes= [] #pointの要素数分だけNode_Wを作りリストに保存する\n    for i in range(0,W * H,1):\n        Nodes.append(Node_W(str(i)))\n    g = Graph()\n    for i in range(0,W*H, 1):#グラフ上にNodesで作ったNodeを追加する\n        g.addNode(Nodes[i])\n    for i in range(H):\n        for w in range(W):\n            num = (H*i) + w + k * i\n            if(i != H - 1):#この時は下につなげるNodeがある\n                g.addEdges(Edge(Nodes[num],Nodes[num + W]))\n            if(w != W - 1):#この時は横につなげるNodeがある\n                g.addEdges(Edge(Nodes[num], Nodes[num + 1]))\n     \n    return g\n\nclass Player(object):\n\n    def __init__(self, x, y, L,g,W,H):#x,yはplayerを配置する座標, LはNode_W型を含むリスト,gはplayerを配置するField,W,Xはx座標y座標の限界\n        g.put_player(x,y,W,H,L)\n        \n\nclass Main(Player):\n\n    def __init__(self,L,g,W,H):\n        g.put_player(0,0,W,H,L)\n        self.cost = 0\n        self.now_position = 0\n        self.W = W\n        self.H = H\n        self.L = L\n\n    def move(self,g, node):#gはgraph型,nodeはNode型,与えられたNodeへ進む\n        g.Nodes[self.now_position].w = 0\n        self.now_position = int(node.getName())\n        g.Nodes[self.now_position].w = 0\n        if(int(node.getName()) == 0):\n            self.cost += 0 #0番に移動する場合はコスト0\n        else:\n            self.cost += 1\n\n\n    def destroy(self, g):\n        h1 = self.W\n        h2 = self.W\n        mod = self.now_position % self.W\n        i = 1\n        j = 1\n        k = self.W - self.H\n        g.Nodes[self.now_position].w = 0\n        while(self.now_position - h1 >= 0):#現在位置の上の敵を消す\n            g.Nodes[self.now_position - h1].w = 0\n            h1 += self.W\n        while(self.now_position + h2 < self.H * self.W):#現在位置の下の敵を消す\n            g.Nodes[self.now_position + h2].w = 0\n            h2 += self.W\n        while((self.now_position - i)  % self.W != self.W - 1 and self.now_position - i < self.H * self.W and self.now_position - i > 0):#現在位置の左の敵を消す\n            g.Nodes[self.now_position - i].w = 0\n            i += 1\n        while((self.now_position + j) % self.W != 0 and self.now_position + j < self.H * self.W and self.now_position + j > 0):#現在位置の右の敵を消す\n            g.Nodes[self.now_position + j].w = 0\n            j += 1\n\ndef ShowGraph(g,H,W):#gはgraph型\n    result = \"\"\n    k = W - H\n    for h in range(H):\n        for w in range(W):\n            result = result + g.Nodes[(H * h) + w +  k*h].getName() + \"(\" + str(g.Nodes[(H*h) + w + k * h].w) + \")\"\n            if(w != W - 1):\n                result = result + \"->\"\n            else:\n                result = result + '\\n'\n        if (h != H -1):\n            for w in range(W):\n                t = int(g.Nodes[(H*h) + w + k * h].getName())\n                s = 0\n                while(t//10 != 0):\n                    s += 1\n                    t /= 10\n                result = result + \"↓\" + \"    \" + \" \"*s\n                s = 0\n                if(w == W - 1):\n                    result = result + '\\n'\n    return result\n\ndef SearchWeight(g):#gはgraph型,graph上のNodeがすべて0ならTrue,それ以外ならFalseを返す\n    for i in range(len(g.Nodes)):\n        if g.Nodes[i].w == 1:\n            return False\n    return True\n\n\n\n\n\ndef test1():#グラフが正常につくられているかテスト\n    g = make_field(6,6)\n    start = g.Nodes[0]\n    end = g.Nodes[6*6 - 1]\n    all_path = []\n    all_search(g, start, end, [], all_path,toPrint = True )\n    main = Player(0,0,g.Nodes,g,6,6)\n    enemy1 = Player(1,1,g.Nodes,g, 6,6)\n    enemy2 = Player(5,5,g.Nodes,g, 6,6)\n    for i in range(len(all_path)):\n        print(ShowPath(all_path[i]))\n        print(str(i))\n\n\ndef test2():#正常に爆破ができるのかを確かめるテスト\n    W, H = map(int, input().split())\n    g = make_field(W, H)\n    all_path = []\n    start = g.Nodes[0]\n    end = g.Nodes[W*H - 1]\n    main = Main(g.Nodes,g,W,H)\n    N = int(input())\n    for i in range(N):\n        x, y = map(int, input().split())\n        Player(x, y, g.Nodes,g,W,H)\n    all_search(g,start, end, [], all_path, toPrint = True)\n    print(ShowGraph(g, H, W))\n    main.move(g,g.Nodes[6])\n    main.destroy(g)\n    print(\"爆破！\")\n    print(ShowGraph(g,H,W))\n\n\ndef test3():#グラフ上のある経路を正常に動くのかテスト\n     W, H = map(int, input().split())\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     main = Main(g.Nodes,g,W,H)\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         Player(x, y, g.Nodes,g,W,H)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print(ShowPath(all_path[4]))\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for path in (all_path[4]):\n         main.move(g,path)\n         print(str(path.getName())+\"番に移動しました!\")\n         print()#改行\n         print(ShowGraph(g, H, W))\n         print()\n         print(\"現在までのコスト :\",str(main.cost))\n         print()#改行\n     for i in range(len(all_path)):\n        print(ShowPath(all_path[i]))\n        print(str(i))\n\ndef test4():#1つの経路で動くたびに爆発できるのかテスト\n     W, H = map(int, input().split())\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     main = Main(g.Nodes,g,W,H)\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         Player(x, y, g.Nodes,g,W,H)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print(ShowPath(all_path[4]))\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for path in (all_path[4]):\n         main.move(g,path)\n         print(str(path.getName())+\"番に移動しました!\")\n         print()#改行\n         print(ShowGraph(g, H, W))\n         main.destroy(g)\n         print(\"爆破しました!\")\n         print(ShowGraph(g, H, W))\n         print()\n         print(\"現在までのコスト :\",str(main.cost))\n         print()#改行\n\n\ndef test5():#全経路に関して爆発を試す\n     W, H = map(int, input().split())\n     X = []\n     Y = []\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n\ndef test6():#全経路に関して爆発を試す\n     W, H = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     N = int(input())\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = True)\n     print()#改行\n     print(ShowGraph(g, H, W))\n     print()#改行\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n                if main.cost < min:\n                    min = main.cost\n                    break\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n        print(\"現在の最小コスト :\",str(min))\n\ndef test7():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     l = 0\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    l = root\n                    break\n     print(str(min))\n     print(ShowPath(l))\n     for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n     main = Main(g.Nodes, g, W, H)\n     for path in (root):\n            print(ShowPath(root))\n            main.move(g,path)\n            print(str(path.getName())+\"番に移動しました!\")\n            print()#改行\n            print(ShowGraph(g, H, W))\n            main.destroy(g)\n            print(\"爆破しました!\")\n            print(ShowGraph(g, H, W))\n            if(SearchWeight(g) == True):\n                print(\"全滅や!\")\n                break\n            else:\n                print(\"まだ敵がおるで!\")\n            print()\n            print(\"現在までのコスト :\",str(main.cost))\n            print()#改行\n         \ndef test8():\n     W, H, N = map(int, input().split())\n     X = []\n     Y = []\n     min = H*W #最小のコストを保存\n     g = make_field(W, H)\n     all_path = []\n     start = g.Nodes[0]\n     end = g.Nodes[W*H - 1]\n     for i in range(N):\n         x, y = map(int, input().split())\n         X.append(x)\n         Y.append(y)\n     all_search(g,start, end, [], all_path, toPrint = False)\n     for root in all_path:\n        for i in range(N):\n         Player(X[i], Y[i], g.Nodes, g, W, H)\n        main = Main(g.Nodes,g,W,H)\n        for path in (root):\n            main.move(g,path)\n            main.destroy(g)\n            if(SearchWeight(g) == True):\n                if main.cost < min:\n                    min = main.cost\n                    break\n     print(str(min))\n\ntest8()\n\n\n"
  }
]