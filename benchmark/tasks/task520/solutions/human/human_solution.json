[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n//    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return d[n+1];\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size())\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  FOR(k,0,P2[j].size())\n    if(contains(P2[i],P2[j][k])!=0)return 0.0;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      Segment seg2(P2[j][l],P2[j][(l+1)%P2[j].size()]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P2[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double x=h[i]/sin(b/180.0*pi);\n    double dis=sqrt(x*x-h[i]*h[i]);\n    Vector v=Point(-cos(a/180.0*pi),-sin(a/180.0*pi))*dis;\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\nusing R = double;\nusing P = complex<R>;\n#define x real()\n#define y imag()\nconst R eps = 1e-9,PI = acos(-1);\n\nbool equal(R a,R b){return abs(b-a)<eps;}\nbool equal0(R a){return equal(a,0.0);}\n\nP operator*(const P& p,const R& d){\n    return P(p.x*d,p.y*d);\n}\n\nistream &operator>>(istream& is,P& p){\n    R a,b;\n    is >> a >> b;\n    p = P(a,b);\n    return is;\n}\n\nostream &operator<<(ostream& os,P& p){\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n//内積\ndouble dot(P a,P b) {return (conj(a)*b).real();}\n//外積\ndouble cross(P a,P b) {return (conj(a)*b).imag();}\n\nstruct L{\n    P a,b;\n    L(P a,P b):a(a),b(b){}\n    L(R A,R B,R C){\n        if(equal(A,0)) a = P(0,C/B),b = P(1,C/B);\n        else if(equal(B,0)) b = P(C/A,0),b = P(C/A,1);\n        else a = P(0,C/B),b = P(C/A,0);\n    }\n};\n\n//pをbに射影\nP projection(P p,P b) {return b*dot(p,b)/norm(b);}\n\n//pとp1 to p2 に射影\nP projection(L l,P p){\n    p -= l.a; l.b -= l.a;\n    P proj = projection(p,l.b);\n    return l.a+proj;\n}\n\nstruct S:L{\n    S(P a,P b):L(a,b){}\n};\n\n//点の回転方向を判定\nint ccw(P p0,P p1,P p2){\n    p1 -= p0,p2 -= p0;\n    if(cross(p1,p2)>eps) return 1; //\"COUNTER_CLOCKWISE\"\n    if(cross(p1,p2)<-eps) return -1; //\"CLOCKWISE\"\n    if(dot(p1,p2)<0) return 2; //\"ONLINE_BACK\"\n    if(norm(p1)<norm(p2)) return -2; //\"ONLINE_FRONT\"\n    return 0; //\"ON_SEGMENT\"\n}\n\nbool is_parallel(L l1,L l2){\n    return equal0(cross(l1.b-l1.a,l2.b-l2.a));\n}\n\nbool is_orthogonal(L l1,L l2){\n    return equal0(dot(l1.b-l1.a,l2.b-l2.a));\n}\n\n//pをlに関して対称移動\nP reflection(L l,P p){\n    P pj = projection(l,p);\n    return 2.0*pj-p;\n}\n\n//pがl上にあるか\nbool is_online(L l,P p){\n    return abs(ccw(l.a,l.b,p))!=1;\n}\n\nbool is_onsegment(S s,P p){\n    return ccw(s.a,s.b,p)==0;\n}\n\n//線分の交差判定\nbool intersect(S s,S t){\n    return ccw(s.a,s.b,t.a)*ccw(s.a,s.b,t.b)<=0 && ccw(t.a,t.b,s.a)*ccw(t.a,t.b,s.b)<=0;\n}\n\n//2直線の交点\nP crosspoint(L l1,L l2){\n    R a = cross(l1.b-l1.a,l2.b-l2.a);\n    R b = cross(l1.b-l1.a,l1.b-l2.a);\n    if(equal0(abs(a)) && equal0(abs(b))) return l2.a;\n    return l2.a+(l2.b-l2.a)*b/a;\n}\n\nP crosspoint(S s1, S s2){\n    return crosspoint(L(s1),L(s2));\n}\n\nR dist(P a,P b){\n    return abs(a-b);\n}\n\nR dist(L l,P p){\n    return abs(p-projection(l,p));\n}\n\nR dist(L l1,L l2){\n    return is_parallel(l1,l2)? 0:dist(l1,l2.a);\n}\n\nR dist(S s,P p){\n    P r = projection(s,p);\n    if(is_onsegment(s,r)) return abs(r-p);\n    return min(dist(s.a,p),dist(s.b,p));\n}\n\nR dist (S s1,S s2){\n    if(intersect(s1,s2)) return 0;\n    return min({dist(s1,s2.a),dist(s1,s2.b),\n    dist(s2,s1.a),dist(s2,s1.b)});\n}\n\nusing Polygon = vec<P>;\n\nR area_of_polygon(Polygon& v){\n    int n = v.size();\n    R res = 0;\n    for(int i=0;i+2<n;i++){\n        res += cross(v[i+1]-v[0],v[i+2]-v[0]);\n    }\n    return res/2;\n}\n\nbool is_convex(Polygon& v){\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P a = v[i%n],b = v[(i+1)%n],c = v[(i+2)%n];\n        if(cross(b-a,c-a)<-eps) return false;\n    }\n    return true;\n}\n\nenum{\n    OUT,ON,IN\n};\n\n//点pと多角形vの関係\nint contains(Polygon& v,P p){\n    bool in = false;\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        P a = v[i]-p,b = v[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<=0 && 0<b.y && cross(a,b)<0) in = !in;\n        if(is_onsegment(S(a,b),P(0,0))) return ON;\n    }\n    return in? IN:OUT;\n}\n\nPolygon convex_hull(Polygon& v){\n    int n = v.size();\n    Polygon res;\n    sort(v.begin(),v.end(),[](P& a,P& b){\n        return (a.x!=b.x? a.x<b.x:a.y<b.y);\n    });\n    for(int i=0;i<n;i++){\n        if(i<2){\n            res.push_back(v[i]);\n            continue;\n        }\n        while(true){\n            int s = res.size();\n            if(s<2){\n                res.push_back(v[i]);\n                break;\n            }\n            R c = cross(res[s-1]-res[s-2],v[i]-res[s-2]);\n            if(c<-eps){\n                res.pop_back();\n            }else{\n                res.push_back(v[i]);\n                break;\n            }\n        }\n    }\n    reverse(v.begin(),v.end());\n    for(int i=0;i<n;i++){\n        while(true){\n            int s = res.size();\n            if(v[i]==res.back()) break;\n            if(s<2){\n                res.push_back(v[i]);\n                break;\n            }\n            R c = cross(res[s-1]-res[s-2],v[i]-res[s-2]);\n            if(c<-eps){\n                res.pop_back();\n            }else{\n                res.push_back(v[i]);\n                break;\n            }\n        }\n    }\n    res.pop_back();\n    return res;\n}\n\nvoid solve(int N){\n    vec<Polygon> pols(N);\n    vec<int> num(N);\n    vec<int> H(N);\n    int id = 0;\n    map<int,int> belong;\n    vec<S> seg;\n    for(int i=0;i<N;i++){\n        cin >> num[i] >> H[i];\n        for(int j=0;j<num[i];j++){\n            int a,b;\n            cin >> a >> b;\n            P p(a,b);\n            pols[i].push_back(p);\n        }\n    }\n\n    double theta,phi;\n    cin >> theta >> phi;\n    theta = 2*PI*theta/360;\n    phi = 2*PI*phi/360;\n    auto get_p = [&](double h,P p){\n        double a = -cos(theta),b = -sin(theta);\n        double len = h/tan(phi);\n        a *= len,b *= len;\n        return P(p.x+a,p.y+b);\n    };\n\n    for(int i=0;i<N;i++){\n        vec<P> v;\n        for(int j=0;j<num[i];j++){\n            v.push_back(pols[i][j]);\n            v.push_back(get_p(H[i],pols[i][j]));\n        }\n        auto res = convex_hull(v);\n        int n = res.size();\n        for(int j=0;j<n;j++){\n            seg.push_back(S(res[j],res[(j+1)%n]));\n            belong[id++] = i;\n        }\n        pols[i] = res;\n    }\n\n    P S,T;\n    cin >> S;\n    cin >> T;\n    int sid = id,tid = id+1;\n    int n = tid+1;\n    vvec<double> d(n,vec<double>(n));\n    //length of i->j;\n    for(int i=0;i<id;i++) for(int j=0;j<id;j++){\n        if(belong[i]==belong[j]){\n            d[i][j] = 0;\n            continue;\n        }\n/*        if(contains(pols[belong[j]],seg[i].a) || contains(pols[belong[j]],seg[i].b)){\n            d[i][j] = 0;\n            continue;\n        }*/\n        if(intersect(seg[i],seg[j])){\n            d[i][j] = 0;\n            continue;\n        }\n        d[i][j] = dist(seg[i],seg[j]);\n    }\n    //S->i\n    for(int i=0;i<id;i++){\n        if(contains(pols[belong[i]],S)){\n            d[sid][i] = 0;\n            continue;\n        }\n        d[sid][i] = dist(seg[i],S);\n    }\n    //i->T\n    for(int i=0;i<id;i++){\n        if(contains(pols[belong[i]],T)){\n            d[i][tid] = 0;\n            continue;\n        }\n        d[i][tid] = dist(seg[i],T);\n    }\n    d[sid][tid] = dist(S,T);\n    double inf = 1e9;\n    vec<double> dp(n,inf);\n    vec<int> vis(n);\n    dp[sid] = 0;\n    while(true){\n        int now = -1;\n        double val = inf;\n        for(int i=0;i<n;i++){\n            if(!vis[i] && dp[i]<val){\n                val = dp[i];\n                now = i;\n            }\n        }\n        if(now==-1) break;\n        vis[now] = 1;\n        for(int j=0;j<n;j++) dp[j] = min(dp[j],dp[now]+d[now][j]);\n    }\n//    cerr << sid << \"\\n\"; \n    cout << fixed << setprecision(10) << dp[tid] << \"\\n\";\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        solve(N);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-5)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      dis=min(dis,getDistanceSP(seg1,P2[j][l]));\n    }\n    if(contains(P2[j],P2[i][k])==2)return 0.0;\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  if(contains(P2[i],p)==2)dis=0.0;\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      add_edge(i,j,min(getdis(i,j),getdis(j,i)));\n    }\n  }\n  FOR(i,0,n)\n    add_edge(n,i,getdis(i,s));\n  FOR(i,0,n)\n    add_edge(i,n+1,getdis(i,t));\n  \n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n;++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-9;\nconst R PI = acos(-1.0);\nconst R INF = 1e10;\ninline int sgn(R x){return (x > EPS) - (x < -EPS);}\n\nusing P = complex<R>;\nconst P O = P(0.0);\nusing L = struct{P s,t;};\nusing VP = vector<P>;\nusing VL = vector<L>;\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\n\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\nP proj(L l,P p){ R u = real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\nauto & operator >> (istream &is,P &p){R x,y; is >> x >> y; p=P(x,y); return is;}\n\nbool iss(L a,L b){\n\tint sa = sdet(a.s,a.t,b.s) * sdet(a.s,a.t,b.t);\n\tint sb = sdet(b.s,b.t,a.s) * sdet(b.s,b.t,a.t);\n\treturn max(sa,sb) < 0;\n}\n\nR dsp(L l,P p){\n\tP h = proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h = l.s;\n\tif(sdot(l.t,l.s,p)<=0) h = l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nbool in_polygon(const VP& pol, const P& p){\n\tint res=0;\n\tauto simag = [](const P &p){return sgn(imag(p));};\n\trep(i,pol.size()){\n\t\tP a=pol[i],b=pol[(i+1)%pol.size()];\n\t\tif(sdet(p,a,b)==0 and sdot(p,a,b)<=0) return true;\n\t\tbool f=simag(p-a)>=0,s=simag(p-b)<0;\n\t\tif(simag(b-a)*sdet(a,b,p)==1 and f==s) res+=(2*f-1);\n\t}\n\treturn res!=0;\n}\n\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0,t=1;\n\t\n\tauto cmp_x=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si=sgn(imag(a-b));\n\t\treturn sr ? sr < 0:si < 0;\n\t};\n\n\tsort(begin(pol),end(pol),cmp_x);\n\tVP res(2*n);\n\n\tauto push = [&](P p)->void{\n\t\twhile(k>t and sdet(res[k-1],res[k-2],p)<=-1) k--;\n\t\tres[k++]=p;\n\t};\n\n\tfor_each(begin(pol),end(pol),push);\n\tt = k;\n\tfor_each(rbegin(pol)+1,rend(pol),push);\n\tres.resize(k-1);\n\treturn res;\n}\n\nint main(void){\n\tint cnt = 0;\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol[110];\n\t\tR h[110];\n\n\t\trep(i,n){\n\t\t\tint nv;\n\t\t\tcin >> nv >> h[i];\n\t\t\tpol[i]=VP(nv);\n\t\t\trep(j,nv) cin >> pol[i][j];\n\t\t}\n\n\n\t\tR theta,phi;\n\t\tcin >> theta >> phi;\n\t\t\n\t\ttheta = theta / 180.0 * PI;\n\t\tphi = phi / 180.0 * PI;\n\n\t\tP s,t;\n\t\tcin >> s >> t;\n\n\t\tvector<L> buildings[110];\n\t\trep(i,n){\n\t\t\tint nv = pol[i].size();\n\t\t\tconst R d = h[i]/tan(phi);\n\t\t\trep(j,nv) pol[i].push_back(pol[i][j] - polar(d,theta));\n\t\t\tpol[i] = convex_hull(pol[i]);\n\t\t\tnv = pol[i].size();\n\t\t\trep(j,nv) buildings[i].push_back(L{pol[i][j],pol[i][(j+1)%nv]});\n\t\t}\n\n\t\tR dist[110][110];\n\t\tconst int total = n + 2;\n\t\trep(i,total)rep(j,total) dist[i][j]=(i==j)?0:INF;\n\n\t\trep(i,n)rep(j,i){\n\t\t\tR cur = INF;\n\t\t\tfor(auto &si:buildings[i]){\n\t\t\t\tfor(auto &sj:buildings[j]){\n\t\t\t\t\tcur = min(cur,dss(si,sj));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[i][j]=dist[j][i]=cur;\n\t\t}\n\n\t\tbool st = true;\n\t\trep(i,n){\n\t\t\tR cur[2] = {INF,INF};\n\t\t\tfor(auto &si:buildings[i]){\n\t\t\t\tcur[0] = min(cur[0],dsp(si,s));\t\n\t\t\t\tcur[1] = min(cur[1],dsp(si,t));\n\t\t\t\tif(iss(si,L{s,t})) st=false;\n\t\t\t}\n\t\t\t\n\t\t\tif(in_polygon(pol[i],s)) cur[0] = 0.0;\n\t\t\tif(in_polygon(pol[i],t)) cur[1] = 0.0;\n\t\t\t\n\n\t\t\tdist[n][i] = dist[i][n] = cur[0];\n\t\t\tdist[n+1][i] = dist[i][n+1] = cur[1];\n\t\t}\n\t\t\t\t\n\t\tif(st) dist[n][n+1] = abs(s-t);\n\n\t\tcout.precision(20);\t\t\n\t\trep(k,total)rep(i,total)rep(j,total) dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\tcout << fixed << dist[n][n+1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-5)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX)\n    e[i].clear();\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      dis=min(dis,getDistanceSP(seg,P2[j][l]));\n    }\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      double dis=min(getdis(i,j),getdis(j,i));\n      add_edge(i,j,dis);\n      add_edge(j,i,dis);\n    }\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      dis=min(dis,abs(s-P2[i][j]));\n    }\n    if(contains(P2[i],s)!=0)dis=0.0;\n    add_edge(n,i,dis);\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size())\n      dis=min(dis,abs(t-P2[i][j]));\n    if(contains(P2[i],t)!=0)dis=0.0;\n    add_edge(i,n+1,dis);\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; scanf(\"%lf%lf\",&x,&y); return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\n//vector<Line> tangent_cp(Circle c, Point p) {\n//    vector<Line> ret;\n//    Point v = c.p - p;\n//    ld d = abs(v);\n//    ld l = sqrt(norm(v) - c.r * c.r);\n//    if (isnan(l)) { return ret; }\n//    Point v1 = v * Point(l / d, c.r / d);\n//    Point v2 = v * Point(l / d, -c.r / d);\n//    ret.push_back(Line(p, p + v1));\n//    if (l < eps) return ret;\n//    ret.push_back(Line(p, p + v2));\n//    return ret;\n//}\n//// 円と円の接線\n//vector<Line> tangent_cc(Circle c1, Circle c2) {\n//    vector<Line> ret;\n//    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n//        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n//        ret = tangent_cp(c1, center);\n//    }\n//    if (abs(c1.r - c2.r) > eps) {\n//        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n//        vector<Line> nret = tangent_cp(c1, out);\n//        ret.insert(ret.end(), nret.begin(), nret.end());\n//    }\n//    else {\n//        Point v = c2.p - c1.p;\n//        v /= abs(v);\n//        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n//        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n//        ret.push_back(Line(q1, q1 + v));\n//        ret.push_back(Line(q2, q2 + v));\n//    }\n//    return ret;\n//}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nld G[110][110];\nld Hs[110];\nPolygon polys[110];\nld solve(){\n    ld res = 0;\n    for(int i = 0; i < N;i++) polys[i].clear();\n//    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; scanf(\"%d%lf\",&n,&Hs[i]);\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull(polys[i]);\n    }\n    \n    fill(*G,*G+110*110,INF);\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                if(is_in_polygon(polys[j],polys[i][k]) > 0){\n                    D = 0;\n                    break;\n                }\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n             ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    \n    \n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n//    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, double> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\n#define equals(a,b)(fabs((a)-(b))<EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(x * a, y * a); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0) :c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p1 - s1.p2, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p1 - s1.p2, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n// ??????s???????§°?????¨?????????p???????§°???\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\ndouble getDistance(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n\n// ????????????(p0,p1)???????????????p2?????????\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK;\n\tif (a.norm() < b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0\n\t\t&& ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\tmin(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\ndouble arg(Vector p) {\n\treturn atan2(p.y, p.x);\n}\n\n// ?????¢a???????§?r\nVector polar(double a, double r) {\n\treturn Point(cos(r)*a, sin(r)*a);\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n// IN:2, ON:1, OUT:0\nint contain(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n// ??????\nPolygon andrewScan(Polygon s) {\n\tPolygon u, l;\n\tif (s.size() < 3)return s;\n\tsort(s.begin(), s.end());\n\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\n\n// ??£??\\??????ver\nvoid Dijkstra(vvd graph, int start, vd &cost, int V) {\n\tvi prev(V);\n\tpriority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> Q;\n\n\tfill(cost.begin(), cost.end(), INF);\n\tcost[start] = 0;\n\n\tQ.push(mp(0, start));\t// (cost, index)\n\n\twhile (!Q.empty()) {\n\t\tpair<double, int> _pos = Q.top();\n\t\tdouble d = _pos.first;\n\t\tint pos = _pos.second;\n\t\tQ.pop();\n\t\trep(i, V) {\n\t\t\tif (i == pos)continue;\n\t\t\tif (cost[i] > cost[pos] + graph[pos][i]) {\n\t\t\t\tcost[i] = cost[pos] + graph[pos][i];\n\t\t\t\tQ.push(mp(cost[i], i));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcout << fixed << setprecision(14);\n\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<Polygon> poly(N);\n\t\tvd h(N);\n\t\tvi nv(N);\n\n\t\trep(i, N) {\n\t\t\tcin >> nv[i] >> h[i];\n\t\t\tpoly[i] = Polygon(2 * nv[i]);\n\t\t\trep(j, nv[i]) {\n\t\t\t\tdouble x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tpoly[i][2 * j] = Point(x, y);\n\t\t\t}\n\t\t}\n\t\tdouble theta, phi;\n\t\tcin >> theta >> phi;\n\t\ttheta *= PI / 180;\n\t\tphi *= PI / 180;\n\t\tdouble sx, sy, tx, ty;\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\tPoint start(sx, sy), goal(tx, ty);\n\n\t\tvector<Polygon> hull(N);\n\n\t\trep(i, N) {\n\t\t\tVector shadow = polar(h[i] / tan(phi), theta + PI);\n\t\t\trep(j, nv[i]) {\n\t\t\t\tpoly[i][2 * j + 1] = poly[i][2 * j] + shadow;\n\t\t\t}\n\t\t\thull[i] = andrewScan(poly[i]);\n\t\t}\n\n\t\tvvd graph(N + 2, vd(N + 2, INF));\n\t\trep(i, N) {\n\t\t\trepl(j, i + 1, N) {\n\t\t\t\tdouble dist = INF;\n\t\t\t\trep(p1, hull[i].size()) {\n\t\t\t\t\tSegment s1(hull[i][p1], hull[i][(p1+1)%hull[i].size()]);\n\t\t\t\t\trep(p3, hull[j].size()) {\n\t\t\t\t\t\tSegment s2(hull[j][p3], hull[j][(p3+1)%hull[j].size()]);\n\t\t\t\t\t\tdist = min(dist, getDistance(s1, s2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgraph[i][j] = dist;\n\t\t\t\tgraph[j][i] = dist;\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\tif (contain(hull[i], start) != 0) {\n\t\t\t\tgraph[i][N] = 0;\n\t\t\t\tgraph[N][i] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble dist = INF;\n\t\t\t\trep(p1, hull[i].size()) {\n\t\t\t\t\tSegment s1(hull[i][p1], hull[i][(p1 + 1) % hull[i].size()]);\n\t\t\t\t\tdist = min(dist, getDistanceSP(s1, start));\n\t\t\t\t}\n\t\t\t\tgraph[i][N] = dist;\n\t\t\t\tgraph[N][i] = dist;\n\t\t\t}\n\n\t\t\tif (contain(hull[i], goal) != 0) {\n\t\t\t\tgraph[i][N + 1] = 0;\n\t\t\t\tgraph[N + 1][i] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble dist = INF;\n\t\t\t\trep(p1, hull[i].size()) {\n\t\t\t\t\tSegment s1(hull[i][p1], hull[i][(p1 + 1) % hull[i].size()]);\n\t\t\t\t\tdist = min(dist, getDistanceSP(s1, goal));\n\t\t\t\t}\n\t\t\t\tgraph[i][N + 1] = dist;\n\t\t\t\tgraph[N + 1][i] = dist;\n\t\t\t}\n\t\t}\n\n\t\tgraph[N][N + 1] = getDistance(start, goal);\n\t\tgraph[N + 1][N] = getDistance(start, goal);\n\n\t\tvd cost(N + 2);\n\t\tDijkstra(graph, N, cost, N + 2);\n\n\t\tcout << cost[N + 1] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x - y*r.y, x*r.y + y*r.x); }\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(::abs(x), ::abs(y)); }\n\n    static Pt2 polar(D le, D th) { return Pt2(le * cos(th), le * sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n};\nusing Pol = V<P>;\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\nbool lessP(P l, P r) {\n    if (sgn(r.x-l.x)) return l.x < r.x;\n    if (sgn(r.y-l.y)) return l.y < r.y;\n    return false;\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec() * P(0, 1);\n    if (ccw(s.s, s.s+s2, p) == 1) return (s.s-p).abs();\n    if (ccw(s.t, s.t+s2, p) == -1) return (s.t-p).abs();\n    return distLP(s, p);\n}\n\nD distSS(const L &s, const L &t) {\n    if (insSS(s, t)) return 0;\n    return min({distSP(s, t.s), distSP(s, t.t), distSP(t, s.s), distSP(t, s.t)});\n}\n\nconst P& c_at(const Pol &pol, int i) {\n    int n = int(pol.size());\n    assert(0 <= i && i < 2*n);\n    return pol[(i<n) ? i : i-n];\n}\n\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < int(pol.size()); i++) {\n        P a = pol[i], b = c_at(pol, i+1);\n        if (ccw(a, b, p) == 0) {\n            return 1;\n        }\n        if (a.y > b.y) swap(a, b);\n        if (!(a.y <= p.y && p.y < b.y)) continue;\n        if (sgn(a.y - p.y) ? (cross(a-p, b-p) > 0) : (a.x > p.x)) in *= -1;\n    }\n    return in + 1;\n}\n\nPol convex(Pol p) {\n    sort(begin(p), end(p), lessP);\n    p.erase(unique(begin(p), end(p), near), end(p));\n    Pol up, down;\n    for (P d: p) {\n        while (up.size() > 1 && ccw(up[up.size()-2], up[up.size()-1], d) == 1) up.pop_back();\n        up.push_back(d);\n    }\n    reverse(begin(up), end(up));\n    for (P d: p) {\n        while (down.size() > 1 && ccw(down[down.size()-2], down[down.size()-1], d) == -1) down.pop_back();\n        down.push_back(d);\n    }\n    down.insert(begin(down), begin(up) + 1, end(up) - 1);\n    return down;\n}\n\nconst D INF = 1e100;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (n == 0) return false;\n    P s, t;\n    V<D> h(n);\n    V<Pol> pols;\n    for (int i = 0; i < n; i++) {\n        int m;\n        cin >> m >> h[i];\n        Pol pol;\n        for (int j = 0; j < m; j++) {\n            D x, y;\n            cin >> x >> y;\n            P p = P(x, y);\n            pol.push_back(p);\n        }\n        pols.push_back(pol);\n    }\n    D th, ph;\n    cin >> th >> ph;\n    th = (th / 360.0) * 2 * PI;\n    ph = (ph / 360.0) * 2 * PI;\n    {\n        D x, y;\n        cin >> x >> y;\n        s = P(x, y);\n        cin >> x >> y;\n        t = P(x, y);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int m = int(pols[i].size());\n        for (int j = 0; j < m; j++) {\n            P p = pols[i][j];\n            pols[i].push_back(p + P::polar(h[i] / tan(ph), PI + th));\n        }\n        pols[i] = convex(pols[i]);\n    }\n\n    VV<D> di(n+2, V<D>(n+2, INF));\n    auto adde = [&](int a, int b, D x) {\n        di[a][b] = min(di[a][b], x);\n        di[b][a] = min(di[b][a], x);\n    };\n    for (int i = 0; i < n+2; i++) {\n        adde(i, i, 0);\n    }\n    adde(n, n+1, (s-t).abs());\n\n    for (int i = 0; i < n; i++) {\n        if (contains(pols[i], s)) adde(i, n, 0);\n        if (contains(pols[i], t)) adde(i, n+1, 0);\n\n        int m = int(pols[i].size());\n        for (int j = 0; j < m; j++) {\n            P a = pols[i][j], b = c_at(pols[i], j+1);\n            L l = L(a, b);\n            adde(i, n, distSP(l, s));\n            adde(i, n+1, distSP(l, t));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            const Pol& lp = pols[i];\n            const Pol& rp = pols[j];\n            if (contains(lp, rp[0]) || contains(rp, lp[0])) adde(i, j, 0);\n            int m1 = int(lp.size()), m2 = int(rp.size());\n            for (int k1 = 0; k1 < m1; k1++) {\n                for (int k2 = 0; k2 < m2; k2++) {\n                    L l1 = L(lp[k1], c_at(lp, k1+1));\n                    L l2 = L(rp[k2], c_at(rp, k2+1));\n                    adde(i, j, distSS(l1, l2));\n                }\n            }\n        }\n    }\n\n\n    for (int k = 0; k < n+2; k++) {\n        for (int i = 0; i < n+2; i++) {\n            for (int j = 0; j < n+2; j++) {\n                di[i][j] = min(di[i][j], di[i][k] + di[k][j]);\n            }\n        }\n    }\n\n    cout << di[n][n+1] << endl;\n    return true;\n}\n\nint main() {\n    cout << setprecision(20);\n    while (solve()) {}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct Line {\npublic:\n\tPoint a, b;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn (cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint n;\nld h[100];\nvector<Point> vp[100];\nvector<Point> rvp[100];\nvector<Line> vl[100];\n\nstruct edge {\n\tint to; ld cost;\n};\nvector<edge> G[102];\nld dist[102];\n\ntypedef pair<ld, int> speP;\npriority_queue<speP, vector<speP>, greater<speP>> q;\nvoid solve() {\n\tcout << fixed << setprecision(5);\n\twhile (cin >> n, n) {\n\t\trep(i, n + 2)G[i].clear();\n\t\trep(i, n) {\n\t\t\tvl[i].clear();\n\t\t\tvp[i].clear();\n\t\t\trvp[i].clear();\n\t\t\tint l; cin >> l>>h[i]; \n\t\t\tvp[i].resize(l);\n\t\t\trep(j, l) {\n\t\t\t\tld x, y; cin >> x >> y; vp[i][j] = { x,y };\n\t\t\t}\n\t\t}\n\t\tld theta, phi; cin >> theta >> phi;\n\t\ttheta = theta * pi / 180.0;\n\t\tphi = phi * pi / 180.0;\n\t\ttheta += pi;\n\t\trep(i, n) {\n\t\t\t\n\t\t\trvp[i].resize(vp[i].size());\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tld dx = cos(theta)*rh, dy = sin(theta)*rh;\n\t\t\t\trvp[i][j] = { dx + real(vp[i][j]),dy + imag(vp[i][j]) };\n\t\t\t\tvl[i].push_back({ vp[i][j],rvp[i][j] });\n\t\t\t}\n\t\t\trep(j, vp[i].size()-1) {\n\t\t\t\tvl[i].push_back({ vp[i][j],vp[i][j + 1] });\n\t\t\t\tvl[i].push_back({ rvp[i][j],rvp[i][j + 1] });\n\t\t\t}\n\t\t\tvl[i].push_back({ vp[i][0], vp[i][vp[i].size() - 1] });\n\t\t\tvl[i].push_back({ rvp[i][0],rvp[i][rvp[i].size() - 1] });\n\t\t}\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tld d = INF;\n\t\t\t\trep(k, vl[i].size()) {\n\t\t\t\t\trep(l, vl[j].size()) {\n\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i].push_back({ j,d });\n\t\t\t\tG[j].push_back({ i, d });\n\t\t\t}\n\t\t}\n\t\tPoint s, g; ld x, y; cin >> x >> y; s = { x,y }; cin >> x >> y; g = { x,y };\n\t\ttheta -= pi;\n\t\tPoint ps, pg;\n\t\trep(i, n) {\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\tps = { real(s) + rh * cos(theta),imag(s) + rh * sin(theta) };\n\t\t\tpg = { real(g) + rh * cos(theta),imag(g) + rh * sin(theta) };\n\t\t\tLine ls = { s,ps };\n\t\t\tLine lg = { g,pg };\n\t\t\tbool fs = false, fg = false;\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tLine vpl = { vp[i][j],vp[i][(j + 1) % vp[i].size()] };\n\t\t\t\tif (isis_ss(ls, vpl)) {\n\t\t\t\t\tfs = true;\n\t\t\t\t}\n\t\t\t\tif (isis_ss(lg, vpl)) {\n\t\t\t\t\tfg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fs) {\n\t\t\t\tG[n].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], s));\n\t\t\t\t}\n\t\t\t\tG[n].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n,d });\n\t\t\t}\n\t\t\tif (fg) {\n\t\t\t\tG[n + 1].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n + 1,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], g));\n\t\t\t\t}\n\t\t\t\tG[n + 1].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n + 1,d });\n\t\t\t}\n\t\t}\n\t\tG[n].push_back({ n + 1,abs(g - s) });\n\t\tG[n + 1].push_back({ n,abs(g - s) });\n\t\tfill(dist, dist + n + 2, INF);\n\t\tdist[n] = 0;\n\t\tq.push({ 0,n });\n\t\twhile (!q.empty()) {\n\t\t\tspeP p = q.top(); q.pop();\n\t\t\tint id = p.second;\n\t\t\tif (p.first > dist[id])continue;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tld nd = G[id][j].cost + p.first;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tq.push({ nd,to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[n + 1] << endl;\n\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\n#define EPS 1e-8\n\ntypedef complex<double> C;\nconst double PI = 4*atan(1.0);\n\nnamespace std{\n\n    bool operator < (const C a, const C b){\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b){\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a,const C b){\n        push_back(a);push_back(b);\n    }\n};\n\ndouble cross(const C a,const C b){\n    return imag(conj(a)*b);\n}\ndouble dot(const C a,const C b){\n    return real(conj(a)*b);\n}\nint ccw(C a,C b,C c){\n    b -= a; c -= a;\n    if(cross(b,c)>0) return +1;\n    if(cross(b,c)<0) return -1;\n    if(dot(b,c)<0)return +2;\n    if(norm(b)<norm(c))return -2;\n    return 0;\n}\n\n\nC projection(const L& l,const C p){\n    double t = dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\nbool intersectSS(const L&s,const L& t){\n    return ccw(s[0],s[1],t[0]) * ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L& s,const C p){\n    return abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;   \n}\n\n\ndouble distanceSP(const L &s,const C p){\n    const C r = projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0]-p),abs(s[1]-p));\n}\n\ndouble distanceSS(const L &s,const L &t){\n    if(intersectSS(s,t))return 0;\n    return min({distanceSP(s,t[0]),distanceSP(s,t[1]),distanceSP(t,s[0]),distanceSP(t,s[1])});\n}\ndouble distanceCC(vector<C> &s,vector<C> &t){\n    double mi = 1e10;\n    int n = s.size();\n    int m = t.size();\n    rep(i,n){\n        L a = L(s[i],s[(i+1)%n]);\n        rep(j,m){\n\n            L b = L(t[j],t[(j+1)%m]);\n            mi = min(mi,distanceSS(a,b));\n        }\n    }\n    return mi;\n}\nint contains(const vector<C>&ps,const C p){\n    bool flag = false;\n    rep(i,ps.size()){\n        C a = ps[i]- p, b = ps[(i+1)%ps.size()]-p;\n        if(imag(a) > imag(b))swap(a,b);\n        if(imag(a) <= 0 && 0 < imag(b)){\n            if(cross(a,b)<0)flag = !flag;\n        }\n        if(cross(a,b)==0&&dot(a,b)<=0) return 1;\n    }\n    return flag ? 2 : 0;\n}\n\ndouble distanceCP(vector<C> &s,C &t){\n    if(contains(s,t)){\n        return 0;\n    }\n    double mi = 1e10;\n    int n = s.size();\n    rep(i,n){\n        L a = L(s[i],s[(i+1)%n]);\n        mi = min(mi,distanceSP(a,t));\n    }\n    return mi;\n}\n\nvector<C> convex_hull(vector<C> ps){\n    int n = (int)ps.size(),k=0;\n    sort(ps.begin(),ps.end());\n    vector<C> ch(2*n);\n    for(int i=0;i<n;ch[k++] = ps[i++]){\n        while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)k--;\n    }\n    for(int i=n-2,t=k+1;i>=0;ch[k++] = ps[i--]){\n        while(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])<=0)k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\n\n\ndouble dist[110][110];\nint main(){\n    int n;\n    while(cin>>n&& n!=0){\n        vector<vector<C> >p;\n        vector<double> h(n);\n        rep(i,n){\n            int m;\n            cin >> m >> h[i];\n            vector<C> a;\n            rep(j,m){\n                int x,y;\n                cin >> x >> y;\n                a.push_back(C(x,y));\n            }\n            p.push_back(a);\n        }\n        double theta ,phi;\n        cin >> theta >> phi;\n        theta += 180;\n        theta *= 2*PI/360.0;\n        phi *= 2*PI/360.0;\n        double hfactor = 1.0/tan(phi);\n        C s,t;\n        int sx,sy,tx,ty;\n        cin >> sx >> sy >> tx >> ty;\n        s = C(sx,sy);\n        t = C(tx,ty);\n        vector<vector<C> > X;\n\n        rep(i,n){\n            vector<C> q;\n            rep(j,p[i].size()){\n                q.push_back(p[i][j]);\n            }\n            double r = h[i]*hfactor;\n            \n            rep(j,p[i].size()){\n                q.push_back(C(q[j].real() + r*cos(theta) , q[j].imag()+r*sin(theta) ));\n            }\n            q = convex_hull(q);\n            X.push_back(q);\n            // for(auto xx:q){\n            //     cerr << xx << endl;\n            // }\n        }\n        rep(i,n){\n            rep(j,i){\n                dist[i][j] = distanceCC(X[i],X[j]);    \n                dist[j][i] = dist[i][j];\n            }\n        }\n        \n        rep(i,n){\n            dist[i][n] = distanceCP(X[i],s);\n            dist[n][i] = dist[i][n];\n            dist[i][n+1] = distanceCP(X[i],t);\n            dist[n+1][i] = dist[i][n+1];\n        }\n        // rep(i,n+2){\n        //     rep(j,n+2){\n        //         cout << dist[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        dist[n][n+1] = abs(s-t);\n        dist[n+1][n] = abs(s-t);\n        rep(k,n+2){\n            rep(i,n+2){\n                rep(j,n+2){\n                    dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n                }\n            }\n        }\n        \n        // rep(i,n+2){\n        //     rep(j,n+2){\n        //         cout << dist[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        cout << fixed << setprecision(20) <<  dist[n][n+1] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\nstruct Point {\n\tdouble x, y;\n\tdouble distance_from(const Point& that) const;\n\tPoint move(const struct Vector& vec) const;\n};\nstruct Vector {\n\tdouble dx, dy;\n\tVector(const Point& to, const Point& from) : dx{ to.x - from.x }, dy{ to.y - from.y }{};\n\tVector(const double _dx, const double _dy) :dx{ _dx }, dy{ _dy }{};\n\tVector rotate(const struct Angle& angle) const;\n\tdouble dot(const Vector& that) const;\n\tdouble cross(const Vector& that) const;\n\tdouble length() const;\n};\nVector operator-(const Point& to, const Point& from);\nPoint operator+(const Point& point, const Vector& vec);\nPoint operator+(const Vector& vec, const Point& point);\nstruct Line {\nprivate:\n\tLine(const double _a, const double _b, const double _c) :a{ _a }, b{ _b }, c{ _c }{};\npublic:\n\tdouble a, b, c;\n\tLine(const Point& p1, const Point& p2) : a{ p2.y - p1.y }, b{ p1.x - p2.x }, c{ p2.x * p1.y - p2.y * p1.x }{};\n\tLine(const Point& point, const Vector& vec) : Line(point, Point{ point.x + vec.dx, point.y + vec.dy }){};\n\tdouble distance_from(const Point& that) const;\n\tLine shift_vertical(const double dx) const;\n\tbool is_cross(const Line& that) const;\n\tPoint crosspoint(const Line& that) const;\n};\nstruct Angle {\n\tdouble sin, cos;\n\tstatic Angle from_sin(const double sin);\n\tstatic Angle from_degree(const double degree);\n\tAngle operator+(const Angle& that) const;\n\tAngle operator-(const Angle& that) const;\n\tAngle operator-() const;\n\tdouble tangent() const;\n};\nstruct Circle {\n\tPoint center;\n\tdouble radius;\n\tbool contains(const Point& point) const;\n};\nstruct Edge {\n\tPoint from, to;\n\tdouble distance_from(const Point& point) const;\n\tdouble distance_from(const Edge& that) const;\n\tbool is_cross(const Edge& that) const;\n\tPoint crosspoint(const Edge& that) const;\n};\nstruct Triangle {\n\tPoint a, b, c;\n\tstd::vector<Edge> edges() const;\n\tbool contains(const Point& point) const;\n\tdouble distance_from(const Point& point) const;\n};\nstruct Convex {\n\tstd::vector<Edge> edges;\n\tConvex(const std::vector<Point>& vertex);//counter clock wise\n\tConvex(const std::vector<Edge>& _edges) : edges(_edges) {};//couter clock wise;\n\tbool has_intersection(const Convex& that) const;\n\tbool contains(const Point& that) const;\n\tdouble min_distance(const Point& point) const;\n\tdouble min_distance(const Convex& that) const;\n};\nConvex make_shadows(const Angle &sun, const Angle sun_height, const std::vector<Point>& vertex, const int height) {\n\tconstexpr double EPS = 1e-9;\n\tconst Vector sun_vec{ sun.cos, sun.sin };\n\tconst Vector shadow_vec{ -sun.cos * height / sun_height.tangent(), -sun.sin * height / sun_height.tangent() };\n\tconst int n = vertex.size();\n\tstd::vector<Point> new_vertex; new_vertex.reserve(vertex.size() + 2);\n\tint i = 0;\n\tfor (; (vertex[(i + 1) % n] - vertex[i % n]).cross(sun_vec) <= EPS; ++i);\n\tfor (; (vertex[(i + 1) % n] - vertex[i % n]).cross(sun_vec) >= -EPS; ++i);\n\tfor (; (vertex[(i + 1) % n] - vertex[i % n]).cross(sun_vec) < -EPS; ++i) {\n\t\tnew_vertex.push_back(vertex[i % n]);\n\t}\n\tnew_vertex.push_back(vertex[i % n]);\n\tfor (; std::abs((vertex[(i + 1) % n] - vertex[i % n]).cross(sun_vec)) < EPS; ++i);\n\tfor (; (vertex[(i + 1) % n] - vertex[i % n]).cross(sun_vec) > EPS; ++i) {\n\t\tnew_vertex.push_back(vertex[i % n] + shadow_vec);\n\t}\n\tnew_vertex.push_back(vertex[i % n] + shadow_vec);\n\treturn Convex(new_vertex);\n}\nint main() {\n\tauto comparator = [](const std::pair<int, double>& a, const std::pair<int, double>& b) {return a.second > b.second; };\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tstd::vector<std::pair<int, std::vector<Point>>> building(n);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tint nv, height; std::cin >> nv >> height;\n\t\t\tstd::vector<Point> point(nv);\n\t\t\tfor (auto& p : point) std::cin >> p.x >> p.y;\n\t\t\tbuilding[i] = std::make_pair(height, std::move(point));\n\t\t}\n\t\tint sun_dir, sun_height; std::cin >> sun_dir >> sun_height;\n\t\tauto sun_dir_angle = Angle::from_degree(sun_dir);\n\t\tauto sun_height_angle = Angle::from_degree(sun_height);\n\t\tPoint start, goal; std::cin >> start.x >> start.y >> goal.x >> goal.y;\n\t\tstd::vector<Convex> shadows; shadows.reserve(n);\n\t\tstd::transform(building.begin(), building.end(), std::back_inserter(shadows), [sun_dir_angle, sun_height_angle](const std::pair<int, std::vector<Point>>& p) {return make_shadows(sun_dir_angle, sun_height_angle, p.second, p.first); });\n\t\tstd::vector<std::vector<double>> min_distance(n + 2, std::vector<double>(n + 2, 0.0));\n\t\tmin_distance[n][n + 1] = min_distance[n + 1][n] = start.distance_from(goal);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tmin_distance[i][n] = min_distance[n][i] = shadows[i].min_distance(start);\n\t\t\tmin_distance[i][n + 1] = min_distance[n + 1][i] = shadows[i].min_distance(goal);\n\t\t\tfor (auto j = 0; j < i; ++j) {\n\t\t\t\tmin_distance[i][j] = min_distance[j][i] = shadows[i].min_distance(shadows[j]);\n\t\t\t}\n\t\t}\n\t\tstd::priority_queue<std::pair<int, double>, std::vector<std::pair<int, double>>, decltype(comparator)> queue(comparator); queue.emplace(n, 0);\n\t\tstd::vector<double> min_walk(n + 2, DBL_MAX); min_walk[n] = 0;\n\t\twhile (!queue.empty()) {\n\t\t\tauto top = queue.top(); queue.pop();\n\t\t\tif (min_walk[top.first] == top.second) {\n\t\t\t\tfor (auto i = 0; i < min_walk.size(); ++i) {\n\t\t\t\t\tif (min_walk[i] > min_distance[top.first][i] + top.second) {\n\t\t\t\t\t\tmin_walk[i] = min_distance[top.first][i] + top.second;\n\t\t\t\t\t\tqueue.emplace(i, min_walk[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << std::setprecision(10) << std::fixed << min_walk[n + 1] << '\\n';\n\t}\n}\n\n\ndouble Line::distance_from(const Point& that) const\n{\n\treturn std::abs(a * that.x + b * that.y + c) / std::sqrt(a * a + b * b);\n}\n\nLine Line::shift_vertical(const double length) const\n{\n\tconst auto len = std::sqrt(a * a + b * b);\n\tconst auto dx = -a / len * length;\n\tconst auto dy = b / len * length;\n\treturn Line(a, b, c + b * dy - a * dx);\n}\n\nbool Line::is_cross(const Line& that) const\n{\n\treturn std::abs(a * that.b - b * that.a) >= 1e-9;\n}\n\nPoint Line::crosspoint(const Line& that) const\n{\n\tassert(is_cross(that));\n\tconst auto d = a * that.b - b * that.a;\n\treturn Point{ (b * that.c - c * that.b) / d, (c * that.a - a * that.c) / d };\n}\n\ndouble Point::distance_from(const Point& that) const\n{\n\treturn Vector(*this, that).length();\n}\n\nPoint Point::move(const Vector& vec) const\n{\n\treturn Point{ x + vec.dx, y + vec.dy };\n}\n\nVector Vector::rotate(const Angle& angle) const\n{\n\treturn Vector{dx * angle.cos - dy * angle.sin, dx * angle.sin + dy * angle.cos};\n}\n\ndouble Vector::dot(const Vector& that) const\n{\n\treturn dx * that.dx + dy * that.dy;\n}\n\ndouble Vector::cross(const Vector& that) const\n{\n\treturn dx * that.dy - dy * that.dx;\n}\n\ndouble Vector::length() const\n{\n\treturn std::sqrt(dx * dx + dy * dy);\n}\n\nAngle Angle::from_sin(const double sin)\n{\n\treturn Angle{ sin, std::sqrt(1 - sin * sin) };\n}\n\nAngle Angle::from_degree(const double degree)\n{\n\tconst auto rad = std::acos(-1) * degree / 180;\n\treturn Angle{std::sin(rad), std::cos(rad)};\n}\n\nAngle Angle::operator+(const Angle& that) const\n{\n\treturn Angle{ sin * that.cos + cos * that.sin, cos * that.cos - sin * that.sin };\n}\n\nAngle Angle::operator-(const Angle& that) const\n{\n\treturn Angle{ sin * that.cos - cos * that.sin, cos * that.cos + sin * that.sin };\n}\n\nAngle Angle::operator-() const\n{\n\treturn Angle{ -sin, cos };\n}\n\ndouble Angle::tangent() const\n{\n\treturn sin / cos;\n}\n\nstd::vector<Edge> Triangle::edges() const\n{\n\tstd::vector<Edge> result{Edge{ a, b }, Edge{ b, c }, Edge{ c, a }};\n\treturn result;\n}\n\nbool Triangle::contains(const Point& point) const\n{\n\tauto ab = Vector(a, b).cross(Vector(point, b));\n\tauto bc = Vector(b, c).cross(Vector(point, c));\n\tauto ca = Vector(c, a).cross(Vector(point, a));\n\treturn (ab >= 0 && bc >= 0 && ca >= 0) || (ab <= 0 && bc <= 0 && ca <= 0);\n}\n\ndouble Triangle::distance_from(const Point& point) const\n{\n\tconst auto edge = edges();\n\tdouble min_distance = DBL_MAX;\n\tfor (const auto& e : edge) min_distance = std::min(min_distance, e.distance_from(point));\n\treturn min_distance;\n}\n\ndouble Edge::distance_from(const Point& point) const\n{\n\tVector vec(to, from);\n\tif (vec.dot(Vector(point, from)) >= 0 && vec.dot(Vector(point, to)) <= 0) return Line(from, to).distance_from(point);\n\telse return std::min(to.distance_from(point), from.distance_from(point));\n}\n\ndouble Edge::distance_from(const Edge& that) const\n{\n\tif (is_cross(that)) return 0.0;\n\treturn std::min({distance_from(that.to), distance_from(that.from), that.distance_from(to), that.distance_from(from)});\n}\n\nbool Edge::is_cross(const Edge& that) const\n{\n\tVector vec(to, from);\n\tVector that_vec(that.to, that.from);\n\tif (vec.cross(that_vec) == 0) return std::abs(vec.cross(that.to - from)) < 1e-9 && std::min(from.x, to.x) <= std::max(that.from.x, that.to.x) && std::min(that.from.x, that.to.x) <= std::max(from.x, to.x) && std::min(from.y, to.y) <= std::max(that.from.y, that.to.y) && std::min(that.from.y, that.to.y) <= std::max(from.y, to.y);\n\treturn vec.cross(that.to - from) * vec.cross(that.from - from) <= 0 && that_vec.cross(to - that.from) * that_vec.cross(from - that.from) <= 0;\n}\n\nPoint Edge::crosspoint(const Edge& that) const\n{\n\tassert(is_cross(that));\n\treturn Line(to, from).crosspoint(Line(that.to, that.to));\n}\n\nbool Circle::contains(const Point& point) const\n{\n\treturn center.distance_from(point) <= radius;\n}\n\n\nVector operator-(const Point& to, const Point& from)\n{\n\treturn Vector{ to.x - from.x, to.y - from.y };\n}\n\nPoint operator+(const Point& point, const Vector& vec)\n{\n\treturn Point{ point.x + vec.dx, point.y + vec.dy };\n}\n\nPoint operator+(const Vector& vec, const Point& point)\n{\n\treturn Point{ point.x + vec.dx, point.y + vec.dy };\n}\n\nConvex::Convex(const std::vector<Point>& vertex)\n{\n\tedges.reserve(vertex.size());\n\tfor (auto i = 0; i < vertex.size(); ++i) {\n\t\tedges.push_back(Edge{ vertex[i], vertex[(i + 1) % vertex.size()] });\n\t}\n}\n\nbool Convex::has_intersection(const Convex& that) const\n{\n\tif (contains(that.edges.front().from) || that.contains(edges.front().from)) return true;\n\tfor (const auto& a : edges) for (const auto& b : that.edges) if (a.is_cross(b)) return true;\n\treturn false;\n}\n\nbool Convex::contains(const Point& that) const\n{\n\tfor (const auto& e : edges) if ((e.to - e.from).cross(that - e.from) < 0) return false;\n\treturn true;\n}\n\ndouble Convex::min_distance(const Point& point) const\n{\n\tif (contains(point)) return 0.0;\n\tdouble min = DBL_MAX;\n\tfor (const auto& e : edges) min = std::min(min, e.distance_from(point));\n\treturn min;\n}\n\ndouble Convex::min_distance(const Convex& that) const\n{\n\tif (has_intersection(that)) return 0.0;\n\tdouble min = DBL_MAX;\n\tfor (const auto& a : edges) for (const auto& b : that.edges) min = std::min(min, a.distance_from(b));\n\treturn min;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nnamespace geo{\n    using real_num = double;\n    constexpr real_num eps = 1e-9;\n    constexpr real_num PI = 3.14159265358979323846264338327950;\n    \n    inline int sgn(real_num x){\n        if(x < -eps) return -1;\n        if(x > eps) return 1;\n        return 0;\n    }\n\n    inline bool eq(real_num x, real_num y){\n        return sgn(x - y) == 0;\n    }\n\n    inline bool ge(real_num x, real_num y){\n        return sgn(x - y) == 1;\n    }\n\n    inline bool le(real_num x, real_num y){\n        return sgn(x - y) == -1;\n    }\n\n    inline bool geq(real_num x, real_num y){\n        return sgn(x - y) >= 0;\n    }\n\n    inline bool leq(real_num x, real_num y){\n        return sgn(x - y) <= 0;\n    }\n\n    struct Point{\n        real_num x, y;\n        Point(real_num x = 0, real_num y = 0): x(x), y(y){}\n\n        Point operator+(const Point &p){\n            return {x + p.x, y + p.y};\n        }\n\n        Point operator-(const Point &p){\n            return {x - p.x, y - p.y};\n        }\n\n        Point operator*(const real_num k){\n            return {x * k, y * k};\n        }\n\n        Point operator/(const real_num k){\n            return {x / k, y / k};\n        }\n\n        real_num operator*(const Point &p){\n            return x * p.x + y * p.y;\n        }\n\n        real_num operator^(const Point &p){\n            return x * p.y - y * p.x;\n        }\n\n        bool operator==(const Point &p){\n            return eq(x, p.x) && eq(y, p.y);\n        }\n\n        bool operator<(const Point &p) const{\n            if(eq(x, p.x)) return le(y, p.y);\n            return le(x, p.x);\n        }\n    };\n\n    using Vec = Point;\n    using Points = vector<Point>;\n    using Polygon = vector<Point>;\n\n    real_num norm(Point p){\n        return p.x * p.x + p.y * p.y;\n    }\n\n    real_num abs(Point p){\n        return sqrt(norm(p));\n    }\n\n    Point rot(Point p, real_num t){\n        return {p.x * cos(t) - p.y * sin(t), p.x * sin(t) + p.y * cos(t)};\n    }\n\n    constexpr int CCW_COUNTER_CLOCKWISE = 1;\n    constexpr int CCW_CLOCKWISE = -1;\n    constexpr int CCW_ONLINE_BACK = -2;\n    constexpr int CCW_ONLINE_FRONT = 2;\n    constexpr int CCW_ON_SEGMENT = 0;\n\n    inline int ccw(Point a, Point b, Point c){\n        Vec v = b - a, w = c - a;\n        if(ge(v ^ w, 0)) return CCW_COUNTER_CLOCKWISE;\n        if(le(v ^ w, 0)) return CCW_CLOCKWISE;\n        if(le(v * w, 0)) return CCW_ONLINE_BACK;\n        if(le((a - b) * (c - b), 0)) return CCW_ONLINE_FRONT;\n        return CCW_ON_SEGMENT;\n    }\n\n    bool has_intersection_ss(Point a, Point b, Point c, Point d){\n        return ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0;\n    }\n\n    real_num distance_lp(Point a, Vec v, Point p){\n        return abs(v ^ (p-a) / abs(v));\n    }\n\n    real_num distance_sp(Point a, Point b, Point p){\n        if(le((b - a) * (p - a), 0)) return abs(p - a);\n        if(le((a - b) * (p - b), 0)) return abs(p - b);\n        return distance_lp(a, b - a, p);\n    }\n\n    real_num distance_ss(Point a, Point b, Point c, Point d){\n        if(has_intersection_ss(a, b, c, d)) return 0;\n        return min({distance_sp(a, b, c), distance_sp(a, b, d), distance_sp(c, d, a), distance_sp(c, d, b)});\n    }\n\n    int point_in_polygon(Point a, Polygon &p){\n        int n = p.size(), wn = 0;\n        rep(i, n){\n            int j = (i + 1) % n;\n            if(eq(distance_sp(p[i], p[j], a), 0)) return 1;\n            else if(leq(p[i].y, a.y) && le(a.y, p[j].y)){\n                wn += (ccw(a, p[i], p[j]) == CCW_COUNTER_CLOCKWISE);\n            }\n            else if(leq(p[j].y, a.y) && le(a.y, p[i].y)){\n                wn -= (ccw(a, p[i], p[j]) == CCW_CLOCKWISE);\n            }\n        }\n        return wn == 0 ? 0 : 2;\n    }\n\n    Polygon convex_hull(Points p){\n        int n = p.size();\n        sort(p.begin(), p.end());\n        Polygon ch(2 * n);\n        int k = 0;\n        rep(i, n){\n            while(k > 1 && le((ch[k - 1] - ch[k - 2]) ^ (p[i] - ch[k - 1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        for(int i = n - 2, t = k; i >= 0; --i){\n            while(k > t && le((ch[k - 1] - ch[k - 2]) ^ (p[i] - ch[k - 1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        ch.resize(k - 1);\n        return ch;\n    }\n}\n\nusing namespace geo;\nint n;\n\nvoid solve(){\n    real_num h[n];\n    Points p[n];\n    rep(i, n){\n        int K;\n        scanf(\"%d%lf\", &K, &h[i]);\n        p[i].resize(K * 2);\n        rep(j, K) scanf(\"%lf%lf\", &p[i][j].x, &p[i][j].y);\n    }\n    real_num theta, phi;\n    scanf(\"%lf%lf\", &theta, &phi);\n    rep(i, n){\n        rep(j, p[i].size() / 2){\n            Point q = p[i][j] + rot({-h[i] / tan(phi * PI / 180), 0}, theta * PI / 180);\n            p[i][j + p[i].size() / 2] = q;\n        }\n        p[i] = convex_hull(p[i]);\n    }\n\n    real_num dist[n + 2][n + 2];\n    rep(i, n){\n        dist[i][i] = 0;\n        For(j, i + 1, n){\n            real_num tmp = INF;\n            rep(k, p[i].size())rep(l, p[j].size()){\n                chmin(tmp, distance_ss(p[i][k], p[i][(k + 1) % p[i].size()], p[j][l], p[j][(l + 1) % p[j].size()]));\n            }\n            dist[i][j] = dist[j][i] = tmp;\n        }\n    }\n    Point sp, tp;\n    scanf(\"%lf%lf%lf%lf\", &sp.x, &sp.y, &tp.x, &tp.y);\n    dist[n][n] = dist[n + 1][n + 1] = 0;\n    rep(i, n){\n        if(point_in_polygon(sp, p[i]) >= 1){\n            dist[i][n] = dist[n][i] = 0;\n            continue;\n        }\n        real_num tmp = INF;\n        rep(j, p[i].size()){\n            chmin(tmp, distance_sp(p[i][j], p[i][(j + 1) % p[i].size()], sp));\n        }\n        dist[i][n] = dist[n][i] = tmp;\n    }\n    rep(i, n){\n        if(point_in_polygon(tp, p[i]) >= 1){\n            dist[i][n + 1] = dist[n + 1][i] = 0;\n            continue;\n        }\n        real_num tmp = INF;\n        rep(j, p[i].size()){\n            chmin(tmp, distance_sp(p[i][j], p[i][(j + 1) % p[i].size()], tp));\n        }\n        dist[i][n + 1] = dist[n + 1][i] = tmp;\n    }\n    dist[n][n + 1] = dist[n + 1][n] = abs(sp - tp);\n\n    rep(k, n + 2)rep(i, n + 2)rep(j, n + 2){\n        chmin(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    printf(\"%.10lf\\n\", dist[n][n + 1]);\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst double EPS = 1e-10;\nconst double PI = 3.141592653589793;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>; // ????§???¢\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\nPoint rotationalTransfer(Point c, double r, double deg) { // c???????????¨????????????r????????¨??????deg??????????????§?¨?\n\tdouble rad = PI * deg / 180.0; return c + Point(cos(rad), sin(rad)) * r;\n}\n// (x, y, z) ???????????????(xy??§?¨???§????§???????theta???, xy?????¢??????z?????????????§???????phi????????????)??????????????????????????±???xy??§?¨?\nPoint Shadow(double x, double y, double z, double theta, double phi) {\n\ttheta = PI * theta / 180.0, phi = PI * phi / 180.0;\n\treturn Point(x - z / tan(phi) * cos(theta), y - z / tan(phi) * sin(theta));\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????§???¢ ***\n// IN := 2, ON := 1, OUT := 0\nvector<Segment> getPolygonSegument(const Polygon& p) { //????§???¢????????????????§???¢??????????±???????\n\tvector<Segment> ret;\n\trep(i, p.size() - 1) ret.push_back(Segment(p[i], p[i + 1]));\n\tret.push_back(Segment(p[p.size() - 1], p[0]));\n\treturn ret;\n}\nint contains(Polygon g, Point p){ // ????§???¢g????????????p????????????????????????\n\tint n = g.size(); bool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif ( abs(cross(a, b)) < EPS && dot(a, b) < EPS ) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) { // ??????(??????????????????????????????)\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end()); // x, y???????????????????????????\n\t// x????°???????????????????2??? u ?????????\n\tu.push_back(s[0]), u.push_back(s[1]);\n\t// x ?????§??????????????????2???1?????????\n\tl.push_back(s[s.size() - 1]), l.push_back(s[s.size() - 2]);\n\t// ??????????????¨?????????\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t// ??????????????¨?????????\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t// ????¨????????????????????????????????????????????????????\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) { // ???????????????????????¨??????????????????????????????????????¨\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(Segment s1, Segment s2) { // ??????s1??¨??????s2?????????\n\tif( intersect(s1, s2) ) return 0.0; //????????£???????????¨???\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\ndouble getDistancePolP(const Polygon& pol, const Point& p) { // ????§???¢pol??¨???p????????¢\n\tif(contains(pol, p) != 0) return 0.0; // ??????????§???¢????????¨?????????????????????\n\tdouble ret = 1e9;\n\tfor(Segment& u : getPolygonSegument(pol)) ret = min(ret, getDistanceSP(u, p));\n\treturn ret;\n}\ndouble getDistancePolPol(const Polygon& p1, const Polygon& p2) { // ????§???¢p1??¨p2????????¢\n\tdouble ret = 1e9;\n\tfor(Segment& u : getPolygonSegument(p1))for(Segment& v : getPolygonSegument(p2)) {\n\t\tret = min(ret, getDistanceSS(u, v));\n\t}\n\treturn ret;\n}\n\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\n\nconst int MAX_N = 210;\nusing TYPE = double; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\n\nint main(void) {\n\t\n\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tint NV[110], H[110];\n\t\tvector<vector<pair<double, double>>> p;\n\t\trep(i, N){\n\t\t\tscanf(\"%d %d\", &NV[i], &H[i]);\n\t\t\tvector<pair<double, double>> tmp;\n\t\t\trep(j, NV[i]){\n\t\t\t\tdouble x, y; scanf(\"%lf %lf\", &x, &y);\n\t\t\t\ttmp.pb(mp(x, y));\n\t\t\t}\n\t\t\tp.pb(tmp);\n\t\t}\n\t\tdouble theta, phi; scanf(\"%lf %lf\", &theta, &phi);\n\t\tdouble Sx, Sy, Tx, Ty; scanf(\"%lf %lf %lf %lf\", &Sx, &Sy, &Tx, &Ty);\n\t\tPoint start(Sx, Sy), goal(Tx, Ty);\n\n\t\tvector<Polygon> v;\n\t\trep(i, N){\n\t\t\tPolygon t;\n\t\t\tfor(auto u : p[i]) t.pb(Shadow(u.fi, u.se, H[i], theta, phi));\n\t\t\tfor(auto u : p[i]) t.pb(Point(u.fi, u.se));\n\t\t\tPolygon tt = andrewScan(t);\n\t\t\tv.pb(tt);\n\t\t}\n\n\t\t/*\n\t\tfor(auto u : v) {\n\t\t\tfor(auto k : u) printf(\"%f %f, \", k.x, k.y);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\t\n\n\t\trep(i, MAX_N) G[i].clear();\n\n\t\trep(i, v.size())rep(j, v.size()){\n\t\t\tif(i == j) continue;\n\t\t\tint s = i + 1, t = j + 1;\n\t\t\tauto dis = getDistancePolPol(v[i], v[j]);\n\t\t\tG[s].pb(mp(t, dis)), G[t].pb(mp(s, dis));\n\t\t}\n\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], start);\n\t\t\tG[0].pb(mp(i + 1, dis)), G[i + 1].pb(mp(0, dis));\n\t\t}\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], goal);\n\t\t\tG[N + 1].pb(mp(i + 1, dis)), G[i + 1].pb(mp(N + 1, dis));\n\t\t}\n\n\t\tauto ret = dijkstra(0);\n\t\tprintf(\"%.9f\\n\", ret[N + 1]);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <queue>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool cmp_y(const P &a, const P &b){\n    return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n  \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\n\nPoly convex_hull(Poly v){\n  int n = v.size(), k = 0;\n  sort(v.begin(), v.end(), cmp_y);\n  Poly r(2*n);\n  for(int i = 0; i < n; i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-2]) < -EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i = n-2, t = k; i >= 0; i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-2]) < -EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\ndouble poly_to_poly_dist(Poly a, Poly b){\n  int n = a.size(), m = b.size();\n  double d = INF;\n  for(int i = 0; i < m; ++i)\n    if(in_poly(b[i],a)) return 0;\n\n  for(int i = 0; i < n; ++i){\n    if(in_poly(a[i],b)) return 0;\n    for(int j = 0; j < m; ++j){\n      L sa = L(a[i],a[(i+1)%n]), sb = L(b[j],b[(j+1)%m]);\n      if(is_cross(sa,sb)) return 0;\n      d = min(d, s_to_s_dist(sa,sb));\n    }\n  }\n  return d;\n}\n\ndouble p_to_poly_dist(P a, Poly p){\n  if(in_poly(a,p)) return 0;\n  int n = p.size();\n  double d = INF;\n  for(int i = 0; i < n; ++i)\n    d = min(d, p_to_s_dist(a,L(p[i],p[(i+1)%n])));\n  return d;\n}\n\ndouble solve(int N, vector<Poly> p, vector<double> H, P s, P t, double theta, double f){\n  vector<Poly> shade;\n  for(int i = 0; i < N; ++i){\n    int n = p[i].size();\n    for(int j = 0; j < n; ++j){\n      p[i].push_back(p[i][j]-polar(H[i]/tan(f),theta));\n    }\n    shade.push_back(convex_hull(p[i]));\n  }\n  vector< vector<double> > dist(N+2, vector<double>(N+2,INF));\n  dist[0][1] = abs(s-t);\n  dist[1][0] = dist[0][1];\n  dist[0][0] = 0;\n  dist[1][1] = 0;\n  for(int i = 0; i < N; ++i){\n    dist[0][i+2] = p_to_poly_dist(s,shade[i]);\n    dist[i+2][0] = dist[0][i+2];\n    dist[1][i+2] = p_to_poly_dist(t,shade[i]);\n    dist[i+2][1] = dist[1][i+2];\n  }\n\n  for(int i = 0; i < N; ++i){\n    dist[i+2][i+2] = 0;\n    for(int j = i+1; j < N; ++j){\n      dist[i+2][j+2] = poly_to_poly_dist(shade[i],shade[j]);\n      dist[j+2][i+2] = dist[i+2][j+2];\n    }\n  }\n  for(int k = 0; k < N+2; ++k){\n    for(int i = 0; i < N+2; ++i){\n      for(int j = 0; j < N+2; ++j){\n\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[0][1];\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    int nv;\n    double x, y;\n    vector<double> H(N);\n    vector<Poly> p(N);\n    for(int i = 0; i < N; ++i){\n      cin >> nv >> H[i];\n      for(int j = 0; j < nv; ++j){\n\tcin >> x >> y;\n\tp[i].push_back(P(x,y));\n      }\n    }\n    double theta, f, pi = acos(-1);\n    cin >> theta >> f;\n    theta = theta/180*pi;\n    f = f/180*pi;\n    P s, t;\n    cin >> x >> y;\n    s = P(x, y);\n    cin >> x >> y;\n    t = P(x, y);\n    printf(\"%.10lf\\n\",solve(N, p, H, s, t, theta, f));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\nusing FLOAT = long double;\nconst FLOAT EPS = 1e-8;\nconst FLOAT INF = 1e12;\nconst FLOAT PI = acos(-1);\ntypedef complex<FLOAT> P;\n\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\nFLOAT cross(const P& a, const P& b) {\n\treturn imag(conj(a) * b);\n}\nFLOAT dot(const P& a, const P& b) {\n\treturn real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)return 1;\n\tif (cross(b, c) < 0)return -1;\n\tif (dot(b, c) < 0)return 2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nP projection(const L& l, const P& p) {\n\tFLOAT t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t * (l[0] - l[1]);\n}\n\nbool intersectSS(const L & s, const L & t) {\n\treturn ccw(s[0], s[1], t[0])* ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const L & s, const P & p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nFLOAT distanceSP(const L & s, const P & p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r))return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nFLOAT distanceSS(const L & s, const L & t) {\n\tif (intersectSS(s, t))return 0;\n\tif (intersectSS(s, t))return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nG convexHull(G ps) {\n\tint n = ps.size(), k = 0;\n\tassert(n >= 3);\n\tsort(ps.begin(), ps.end());\n\tG ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)--k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)--k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nstruct edge {\n\tint to;\n\tFLOAT cost;\n\tedge(int to, FLOAT cost) :to(to), cost(cost) {}\n};\nusing Pair = pair<FLOAT, int>;\nvoid dijkstra(vector<edge>graph[], FLOAT dist[], int n, int s) {\n\tpriority_queue<Pair, vector<Pair>, greater<Pair>>que;\n\tque.push({ 0LL,s });\n\tfill(dist, dist + n, INF);\n\tdist[s] = 0LL;\n\twhile (!que.empty()) {\n\t\tauto q = que.top();\n\t\tque.pop();\n\t\tFLOAT thd = q.first;\n\t\tint thv = q.second;\n\t\tif (thd > dist[thv])\n\t\t\tcontinue;\n\t\tfor (auto ed : graph[thv]) {\n\t\t\tif (dist[ed.to] > ed.cost + thd) {\n\t\t\t\tdist[ed.to] = ed.cost + thd;\n\t\t\t\tque.push({ dist[ed.to] , ed.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum { OUT, ON, IN };\nint contains(const G & poly, const P & point) {\n\tbool in = false;\n\tfor (int i = 0; i < poly.size(); ++i) {\n\t\tP a = poly[i] - point, b = poly[(i + 1) % poly.size()] - point;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//#define int long long\n\nsigned main() {\n\tint N;\n\tcout.precision(15);\n\tcout << fixed;\n\twhile (cin >> N, N) {\n\t\tvector<FLOAT>H;\n\t\tvector<G>poly;\n\t\tvector<edge>graph[123];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint NV;\n\t\t\tcin >> NV;\n\t\t\tFLOAT h; cin >> h;\n\t\t\tH.push_back(h);\n\t\t\tpoly.push_back(G());\n\t\t\tfor (int j = 0; j < NV; ++j) {\n\t\t\t\tFLOAT x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tpoly.back().push_back({ x,y });\n\t\t\t}\n\t\t}\n\t\tFLOAT the, phi;\n\t\tcin >> the >> phi;\n\t\tthe *= (PI / 180);\n\t\tphi *= (PI / 180);\n\t\tthe += PI;\n\t\tN += 2;\n\t\tFLOAT sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tpoly.push_back(G(2, P(sx, sy)));\n\t\tH.push_back(0);\n\t\tpoly.push_back(G(2, P(gx, gy)));\n\t\tH.push_back(0);\n\t\tP kiso(cos(the) / tan(phi), sin(the) / tan(phi));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tG& g = poly[i], tmp;\n\t\t\tfor (auto p : g) {\n\t\t\t\ttmp.push_back(p + kiso * H[i]);\n\t\t\t}\n\t\t\tfor (auto p : tmp) {\n\t\t\t\tg.push_back(p);\n\t\t\t}\n\t\t\tg = convexHull(g);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tFLOAT dist = INF;\n\t\t\t\t//i-j双方向に辺を張る\n\t\t\t\tfor (int vi = 0; vi < poly[i].size(); vi++) {\n\t\t\t\t\tL L1 = { poly[i][vi],poly[i][(vi + 1) % poly[i].size()] };\n\t\t\t\t\tfor (int vj = 0; vj < poly[j].size(); vj++) {\n\t\t\t\t\t\tL L2 = { poly[j][vj],poly[j][(vj + 1) % poly[j].size()] };\n\t\t\t\t\t\tdist = min(dist, distanceSS(L1, L2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == N - 2 || j == N - 1) {\n\t\t\t\t\tif (contains(poly[i], poly[j][0])) {\n\t\t\t\t\t\tdist = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i == N - 2 || i == N - 1) {\n\t\t\t\t\tif (contains(poly[j], poly[i][0])) {\n\t\t\t\t\t\tdist = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgraph[i].push_back({ j,dist });\n\t\t\t\tgraph[j].push_back({ i,dist });\n\t\t\t}\n\t\t}\n\t\tFLOAT dist[123];\n\t\tdijkstra(graph, dist, N, N - 2);\n\t\tcout << dist[N - 1] << endl;\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <queue>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool cmp_y(const P &a, const P &b){\n    return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n  \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\n\nPoly convex_hull(Poly v){\n  int n = v.size(), k = 0;\n  sort(v.begin(), v.end(), cmp_y);\n  Poly r(2*n);\n  for(int i = 0; i < n; i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-2]) < -EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i = n-2, t = k; i >= 0; i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-2]) < -EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\ndouble poly_to_poly_dist(Poly a, Poly b){\n  int n = a.size(), m = b.size();\n  double d = INF;\n  for(int i = 0; i < m; ++i)\n    if(in_poly(b[i],a)) return 0;\n\n  for(int i = 0; i < n; ++i){\n    if(in_poly(a[i],b)) return 0;\n    for(int j = 0; j < m; ++j){\n      L sa = L(a[i],a[(i+1)%n]), sb = L(b[j],b[(j+1)%m]);\n      if(is_cross(sa,sb)) return 0;\n      d = min(d, s_to_s_dist(sa,sb));\n    }\n  }\n  return d;\n}\n\ndouble p_to_poly_dist(P a, Poly p){\n  if(in_poly(a,p)) return 0;\n  int n = p.size();\n  double d = INF;\n  for(int i = 0; i < n; ++i)\n    d = min(d, p_to_s_dist(a,L(p[i],p[(i+1)%n])));\n  return d;\n}\n\ndouble solve(int N, vector<Poly> p, vector<double> H, P s, P t, double theta, double f){\n  vector<Poly> shade;\n  for(int i = 0; i < N; ++i){\n    int n = p[i].size();\n    for(int j = 0; j < n; ++j){\n      p[i].push_back(p[i][j]-polar(H[i]/tan(f),theta));\n    }\n    shade.push_back(convex_hull(p[i]));\n  }\n  vector< vector<double> > dist(N+2, vector<double>(N+2,INF));\n  dist[0][1] = abs(s-t);\n  dist[1][0] = dist[0][1];\n  dist[0][0] = 0;\n  dist[1][1] = 0;\n  for(int i = 0; i < N; ++i){\n    dist[0][i+2] = p_to_poly_dist(s,shade[i]);\n    dist[i+2][0] = dist[0][i+2];\n    dist[1][i+2] = p_to_poly_dist(t,shade[i]);\n    dist[i+2][1] = dist[1][i+2];\n  }\n\n  for(int i = 0; i < N; ++i){\n    dist[i+2][i+2] = 0;\n    for(int j = i+1; j < N; ++j){\n      dist[i+2][j+2] = poly_to_poly_dist(shade[i],shade[j]);\n      dist[j+2][i+2] = dist[i+2][j+2];\n    }\n  }\n  for(int k = 0; k < N+2; ++k){\n    for(int i = 0; i < N+2; ++i){\n      for(int j = 0; j < N+2; ++j){\n\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n  return dist[0][1];\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    int nv;\n    double x, y;\n    vector<double> H(N);\n    vector<Poly> p(N);\n    for(int i = 0; i < N; ++i){\n      cin >> nv >> H[i];\n      for(int j = 0; j < nv; ++j){\n\tcin >> x >> y;\n\tp[i].push_back(P(x,y));\n      }\n    }\n    double theta, f, pi = acos(-1);\n    cin >> theta >> f;\n    theta = theta/180*pi;\n    f = f/180*pi;\n    P s, t;\n    cin >> x >> y;\n    s = P(x, y);\n    cin >> x >> y;\n    t = P(x, y);\n    printf(\"%.10lf\\n\",solve(N, p, H, s, t, theta, f));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return d[n+1];\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  int size1=P2[i].size(),size2=P2[j].size();\n  FOR(k,0,size1)\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  FOR(k,0,size2)\n    if(contains(P2[i],P2[j][k])!=0)return 0.0;\n  FOR(k,0,size1){\n    Segment seg1(P2[i][k],P2[i][(k+1)%size1]);\n    FOR(l,0,size2){\n      Segment seg2(P2[j][l],P2[j][(l+1)%size2]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P2[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b*pi/180.0);\n    Vector v=Point(-cos(a*pi/180.0),-sin(a*pi/180.0))*dis;\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    sort(all(temp));\n    Unique(temp);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double PI = acos(-1);\nconst double EPS = 1e-8; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 頂点の順序（sortやmax_elementに必要）\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\n// !!! 誤差に注意 !!! (掛け算したものとかなり小さいものを比べているので)\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n  return !ccw(a1, a2, b);\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n  Point r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  //= !ccw(a1, a2, r)\n  return min(abs(a1-p), abs(a2-p));\n}\n\ndouble distSS(Point a1, Point a2, Point b1, Point b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n   min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 凸包\n// 入力1個 -> 空\n// 2個以上の全て同じ点 -> 同じもの2つ\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(Point p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\n\nPoint READ_P(){\n    int x,y;\n    cin >>x >>y;\n    return Point(x,y);\n}\n\ndouble ang2rad(double x){\n    return PI*x/180;\n}\n\ndouble distHH(VP ps, VP qs){\n    int n = ps.size(), m = qs.size();\n    double ret = INF;\n    rep(i,n)rep(j,m){\n        ret = min(ret, distSS(ps[i],ps[(i+1)%n],qs[j],qs[(j+1)%m]));\n    }\n    return ret;\n}\n\ndouble distPH(Point p, VP ps){\n    if(inConvex(p,ps)) return 0;\n    int n = ps.size();\n    double ret = INF;\n    rep(i,n){\n        ret = min(ret, distSP(ps[i],ps[(i+1)%n],p));\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<VP> building(n);\n        vector<double> h(n);\n        rep(i,n){\n            int V;\n            cin >>V >>h[i];\n            rep(j,V) building[i].pb(READ_P());\n        }\n\n        double theta,phi;\n        cin >>theta >>phi;\n        theta = ang2rad(theta);\n        phi = ang2rad(phi);\n\n        Point start = READ_P(), goal = READ_P();\n\n        int S = n, T = n+1;\n\n        // make convex hull\n        rep(i,n){\n            VP shadow;\n            for(Point p:building[i]){\n                double L = h[i]/tan(phi);\n                shadow.pb(p + polar(L, theta+PI));\n            }\n\n            for(Point p:shadow) building[i].pb(p);\n\n            building[i] = convexHull(building[i]);\n        }\n\n        // Floyd-Warshall\n        vector<vector<double>> d(n+2, vector<double>(n+2));\n        rep(i,n)rep(j,i){\n            d[i][j] = d[j][i] = distHH(building[i], building[j]);\n        }\n        rep(i,n){\n            d[S][i] = d[i][S] = distPH(start, building[i]);\n            d[T][i] = d[i][T] = distPH(goal, building[i]);\n        }\n        d[S][T] = d[T][S] = abs(start-goal);\n\n        rep(k,n+2)rep(i,n+2)rep(j,n+2) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        printf(\"%.10f\\n\", d[S][T]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; scanf(\"%lf%lf\",&x,&y); return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\n//vector<Line> tangent_cp(Circle c, Point p) {\n//    vector<Line> ret;\n//    Point v = c.p - p;\n//    ld d = abs(v);\n//    ld l = sqrt(norm(v) - c.r * c.r);\n//    if (isnan(l)) { return ret; }\n//    Point v1 = v * Point(l / d, c.r / d);\n//    Point v2 = v * Point(l / d, -c.r / d);\n//    ret.push_back(Line(p, p + v1));\n//    if (l < eps) return ret;\n//    ret.push_back(Line(p, p + v2));\n//    return ret;\n//}\n//// 円と円の接線\n//vector<Line> tangent_cc(Circle c1, Circle c2) {\n//    vector<Line> ret;\n//    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n//        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n//        ret = tangent_cp(c1, center);\n//    }\n//    if (abs(c1.r - c2.r) > eps) {\n//        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n//        vector<Line> nret = tangent_cp(c1, out);\n//        ret.insert(ret.end(), nret.begin(), nret.end());\n//    }\n//    else {\n//        Point v = c2.p - c1.p;\n//        v /= abs(v);\n//        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n//        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n//        ret.push_back(Line(q1, q1 + v));\n//        ret.push_back(Line(q2, q2 + v));\n//    }\n//    return ret;\n//}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nld G[110][110];\nld Hs[110];\nPolygon polys[110];\nld solve(){\n    ld res = 0;\n    for(int i = 0; i < N;i++) polys[i].clear();\n//    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; scanf(\"%d%lf\",&n,&Hs[i]);\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull(polys[i]);\n    }\n    \n    fill(*G,*G+110*110,INF);\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                if(is_in_polygon(polys[j],polys[i][k]) > 0){\n                    D = 0;\n                    break;\n                }\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n             ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    G[N][N+1] = G[N+1][N] = abs(S-T);\n    \n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n//    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return d[n+1];\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  int size1=P2[i].size(),size2=P2[j].size();\n  FOR(k,0,size1)\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  FOR(k,0,size2)\n    if(contains(P2[i],P2[j][k])!=0)return 0.0;\n  FOR(k,0,size1){\n    Segment seg1(P2[i][k],P2[i][(k+1)%size1]);\n    FOR(l,0,size2){\n      Segment seg2(P2[j][l],P2[j][(l+1)%size2]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P2[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\nvector<Point> uni(vector<Point> p){\n  sort(all(p));\n  vector<Point> res;\n  res.pb(p[0]);\n  FOR(i,1,p.size())\n    if(!(res[res.size()-1]==p[i]))\n      res.pb(p[i]);\n  return res;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b*pi/180.0);\n    Vector v=Point(-cos(a*pi/180.0),-sin(a*pi/180.0))*dis;\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(uni(temp));\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf (1e10)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size())\n    if(contains(P2[j],P2[i][k])==2)return 0.0;\n  FOR(k,0,P2[j].size())\n    if(contains(P2[i],P2[j][k])==2)return 0.0;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      Segment seg2(P2[j][l],P2[j][(l+1)%P2[j].size()]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  if(contains(P2[i],p)==2)dis=0.0;\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; scanf(\"%lf%lf\",&x,&y); return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nld G[110][110];\nld Hs[110];\nPolygon polys[110];\nld solve(){\n    ld res = 0;\n    for(int i = 0; i < N;i++) polys[i].clear();\n//    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; scanf(\"%d%lf\",&n,&Hs[i]);\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull(polys[i]);\n    }\n    \n    fill(*G,*G+110*110,INF);\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                if(is_in_polygon(polys[j],polys[i][k]) > 0){\n                    D = 0;\n                    break;\n                }\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n             ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    \n    \n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n//    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,n) for (int i = (a);i<(n);i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nusing namespace std;\ndouble INF = 1e+9;\nint N;\ndouble theta, phi;\n    int V[103], H[103];\n    double x[103][13], y[102][13];\ndouble sx, sy, tx, ty;\ndouble mindist[103][103];\nstruct Point{\n  double x,y;\n  Point operator - (const Point& p) {return Point{x - p.x, y - p.y};}\n};\nstruct Segment{\n  Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x + a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a, Point b){return a.x * b.y - a.y * b.x;}\n\nint ccw(Point p1,Point p2, Point p3){\n  Point a = p2 - p1;\n  Point b = p3 - p1;\n  if(cross(a,b) > EPS)return 1;\n  if(cross(a,b) < -EPS)return -1;\n  if(dot(a,b) < -EPS)return 2;\n  if(norm(a)< norm(b)) return -2;\n     return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n  }\nbool intersect(Segment s1, Segment s2){\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\ndouble getDistSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < EPS) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < EPS) return abs(p - s.p2);\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDist(Segment s1, Segment s2){\n  if(intersect(s1.p1, s1.p2, s2.p1,s2.p2)) return 0.0;\n  return min(min(getDistSP(s1, s2.p1),getDistSP(s1,s2.p2)),\n             min(getDistSP(s2, s1.p1), getDistSP(s2, s1.p2)));\n}\nusing Polygon = vector<Point>;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nbool compare(const Point& a,const Point& b){\n\tif(a.y == b.y)return a.x < b.x;\n\treturn a.y < b.y;\n}\n\nPolygon andrewScan(Polygon g){\n\tPolygon u,l;\n\tif(g.size() < 3) return g;\n  sort(g.begin(),g.end(),compare);//compare????????§x???????????????\n\tu.push_back(g[0]);\n\tu.push_back(g[1]);\n\tl.push_back(g[g.size() - 1]);\n\tl.push_back(g[g.size() - 2]);\n\t// ??????????????¨?????????\n\tfor(int i =2;i < g.size();i++){\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],g[i]) == COUNTER_CLOCKWISE;n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(g[i]);\n\t}\n\t// ??????????????¨?????????\n\tfor(int i = g.size() - 3;i >= 0;i--){\n\t\tfor(int n = l.size();n>=2&&ccw(l[n-2],l[n-1],g[i])==COUNTER_CLOCKWISE;n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(g[i]);\n\t}\n\t\treverse(l.begin(),l.end());\n\tfor(int i = u.size() - 2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n\nint contains(Polygon& g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\tREP(i,n){\n \t\tPoint a = g[i] - p, b = g[(i+1)%n] - p;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n\t}\n\treturn x ? 2 : 0;\n}\n\nvector<Point> buildings[103];// 0 is builidings, 1 is shade\nint main(){\n  while(cin >> N, N){\n    REP(i,N){\n      cin >> V[i] >> H[i];\n      REP(j,V[i]){\n        cin >> x[i][j] >> y[i][j];\n      }\n    }\n    cin >> theta >> phi;\n    cin >> sx >> sy >> tx >> ty;\n    REP(i,N){\n      buildings[i].clear();\n      double xshade = -H[i] / tan(phi / 180.0 * PI) * cos(theta/ 180.0 * PI);\n      double yshade = -H[i] / tan(phi / 180.0 * PI) * sin(theta/ 180.0 * PI);\n      REP(j,V[i]){\n        buildings[i].push_back(Point{x[i][j], y[i][j]});\n        buildings[i].push_back(Point{x[i][j] + xshade, y[i][j] + yshade});\n      }\n      buildings[i] = andrewScan(buildings[i]);\n    }\n    buildings[N].clear();\n    buildings[N + 1].clear();\n    buildings[N].push_back(Point{sx, sy});\n    buildings[N + 1].push_back(Point{tx, ty});\n    N+=2;\n    V[N-2] = V[N-1] = 1;\n    fill(mindist[0], mindist[N], INF);\n    REP(i,N){\n      FOR(j,i + 1,N){\n        for(int a = 0;a < buildings[i].size();a++)\n          for(int b = 0;b < buildings[j].size();b++){\n            int a_n = buildings[i].size();\n            int b_n = buildings[j].size();\n            Segment s1 = Segment{buildings[i][a] ,buildings[i][(a+1)%a_n]};\n            Segment s2 = Segment{buildings[j][b] ,buildings[j][(b+1)%b_n]};\n            mindist[j][i] = mindist[i][j] = min(getDist(s1, s2),mindist[i][j]);\n            if(contains(buildings[i],buildings[j][b]) || contains(buildings[j],buildings[i][a])){\n              mindist[j][i] = mindist[i][j] = 0;\n              break;\n            }\n          }\n      }\n    }\n    REP(k,N){\n      REP(i,N){\n        REP(j,N){\n          mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n        }\n      }\n    }\n    cout << fixed << setprecision(8) << mindist[N-2][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-6)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX)\n    e[i].clear();\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      dis=min(dis,getDistanceSP(seg,P2[j][l]));\n    }\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      double dis=min(getdis(i,j),getdis(j,i));\n      add_edge(i,j,dis);\n      add_edge(j,i,dis);\n    }\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      Segment seg(P2[i][j],P2[i][(j+1)%P2[i].size()]);\n      dis=min(dis,getDistanceSP(seg,s));\n    }\n    if(contains(P2[i],s)!=0)dis=0.0;\n    add_edge(n,i,dis);\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      Segment seg(P2[i][j],P2[i][(j+1)%P2[i].size()]);\n      dis=min(dis,getDistanceSP(seg,t));\n    }\n    if(contains(P2[i],t)!=0)dis=0.0;\n    add_edge(i,n+1,dis);\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ld = long double;\nusing Point = std::complex<ld>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\n// l:line, m:line が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// l:line, s:segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// s:segment, t:segment\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l:line 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// p から l に下ろした足との交点\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// l:line, t:line の交点\nPoint is_ll(Line l, Line m)\n{\n    Point lv = l.b - l.a, mv = m.b - m.a;\n    assert(cross(lv, mv) != 0);\n    return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\n\n// p, l:line の距離\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return std::min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nusing Polygon = std::vector<Point>;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    for (int i = 0; i < n; i++)\n    {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// 0 => out\n// 1 => on\n// 2 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(std::vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nusing namespace std;\n\nld dist_pp(const Polygon &ps, Point p)\n{\n    int sz = ps.size();\n    if (is_in_polygon(ps, p))\n        return 0;\n    ld mi = 1e15;\n    for (int i = 0; i < sz; i++)\n    {\n        Line s(ps[i], ps[(i + 1) % sz]);\n        mi = min(mi, dist_sp(s, p));\n    }\n    return mi;\n}\n\nld dist_pp(const Polygon &p1, const Polygon &p2)\n{\n    int sz1 = p1.size(), sz2 = p2.size();\n    assert(sz1 > 1 && sz2 > 1);\n    ld ret = 1e15;\n    for (int i = 0; i < sz1; i++)\n    {\n        Line s1(p1[i], p1[(i + 1) % sz1]);\n        for (int j = 0; j < sz2; j++)\n        {\n            Line s2(p2[j], p2[(j + 1) % sz2]);\n            ret = min(ret, dist_ss(s1, s2));\n        }\n    }\n    return ret;\n}\n\nPoint from_sun(ld x, ld y, ld h, ld phi, ld shita)\n{\n    ld p = phi / 180.0 * pi, s = shita / 180.0 * pi;\n    return Point(x - h * cos(s) / tan(p), y - h * sin(s) / tan(p));\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        vector<Polygon> polys(n);\n        vector<ld> hs(n);\n        for (int i = 0; i < n; i++)\n        {\n            int nv;\n            cin >> nv >> hs[i];\n            Polygon ps;\n            for (int j = 0; j < nv; j++)\n            {\n                ps.push_back(input_point());\n            }\n            polys[i] = ps;\n        }\n        ld phi, shita;\n        cin >> shita >> phi;\n        Point s = input_point(), t = input_point();\n        for (int i = 0; i < n; i++)\n        {\n            int sz = polys[i].size();\n            for (int j = 0; j < sz; j++)\n            {\n                ld x = polys[i][j].real(), y = polys[i][j].imag();\n                polys[i].push_back(from_sun(x, y, hs[i], phi, shita));\n            }\n            polys[i] = convex_hull(polys[i]);\n        }\n        vector<vector<ld>> dist(n + 2, vector<ld>(n + 2, 1e15));\n        for (int i = 0; i < n + 2; i++)\n            dist[i][i] = 0;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                dist[i][j] = dist[j][i] = dist_pp(polys[i], polys[j]);\n            }\n            dist[i][n] = dist[n][i] = dist_pp(polys[i], s);\n            dist[i][n + 1] = dist[n + 1][i] = dist_pp(polys[i], t);\n        }\n        dist[n][n + 1] = dist[n + 1][n] = abs(s - t);\n        for (int k = 0; k < n + 2; k++)\n        {\n            for (int i = 0; i < n + 2; i++)\n            {\n                for (int j = 0; j < n + 2; j++)\n                {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(10) << dist[n][n + 1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n;++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-9;\nconst R PI = acos(-1.0);\nconst R INF = 1e10;\ninline int sgn(R x){return (x > EPS) - (x < -EPS);}\n\nusing P = complex<R>;\nconst P O = P(0.0);\nusing L = struct{P s,t;};\nusing VP = vector<P>;\nusing VL = vector<L>;\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\n\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\nP proj(L l,P p){ R u = real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\nauto & operator >> (istream &is,P &p){R x,y; is >> x >> y; p=P(x,y); return is;}\n\nbool iss(L a,L b){\n\tint sa = sdet(a.s,a.t,b.s) * sdet(a.s,a.t,b.t);\n\tint sb = sdet(b.s,b.t,a.s) * sdet(b.s,b.t,a.t);\n\treturn max(sa,sb) < 0;\n}\n\nR dsp(L l,P p){\n\tP h = proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h = l.s;\n\tif(sdot(l.t,l.s,p)<=0) h = l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nbool in_polygon(const VL &pol,const P &p){\n\tconst int n = pol.size();\n\tint res = 0;\n\trep(i,n){\n\t\tL l = pol[i];\n\t\tif(sdet(p,l.s,l.t) == 0 and sdot(p,l.s,l.t)<=0) return true;\n\t\tbool f = sgn(imag(p-l.s))>=0,s = sgn(imag(p-l.t))<0;\n\t\tif(sgn(imag(l.t-l.s))*sdet(l.s,l.t,p)==1 and f==s) res += 2*f-1;\n\t}\n\treturn res!=0;\n}\n\nint main(void){\n\tint cnt = 0;\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol[110];\n\t\tR h[110];\n\n\t\trep(i,n){\n\t\t\tint nv;\n\t\t\tcin >> nv >> h[i];\n\t\t\trep(j,nv){\n\t\t\t\tP p;\n\t\t\t\tcin >> p;\n\t\t\t\tpol[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\n\t\tR theta,phi;\n\t\tcin >> theta >> phi;\n\t\t\n\t\ttheta = theta / 180.0 * PI;\n\t\tphi = phi / 180.0 * PI;\n\n\t\tP s,t;\n\t\tcin >> s >> t;\n\n\t\tvector<VL> buildings[110];\n\t\trep(i,n){\n\t\t\tconst int nv = pol[i].size();\n\t\t\tconst R d = h[i]/tan(phi);\n\t\t\trep(j,nv){\n\t\t\t\tVL cur;\n\t\t\t\tVP point;\n\t\t\t\tpoint.push_back(pol[i][j]);\n\t\t\t\tpoint.push_back(pol[i][(j+1)%nv]);\n\t\t\t\tpoint.push_back(pol[i][(j+1)%nv] - polar(d,theta));\n\t\t\t\tpoint.push_back(pol[i][j] - polar(d,theta));\n\n\t\t\t\trep(k,4) cur.push_back(L{point[k],point[(k+1)%4]});\n\t\t\t\tbuildings[i].push_back(cur);\n\t\t\t}\n\t\t}\n\n\t\tR dist[110][110];\n\t\tconst int total = n + 2;\n\t\trep(i,total)rep(j,total) dist[i][j]=(i==j)?0:INF;\n\n\t\trep(i,n)rep(j,i){\n\t\t\tR cur = INF;\n\t\t\tfor(auto &vpi:buildings[i]){\n\t\t\t\tfor(auto &vpj:buildings[j]){\n\t\t\t\t\tfor(auto &si:vpi){\n\t\t\t\t\t\tfor(auto &sj:vpj){\n\t\t\t\t\t\t\tcur = min(cur,dss(si,sj));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tdist[i][j]=dist[j][i]=cur;\n\t\t}\n\n\t\tbool st = true;\n\t\trep(i,n){\n\t\t\tR cur[2] = {INF,INF};\n\t\t\tfor(auto &vpi:buildings[i]){\n\t\t\t\tfor(auto &si:vpi){\n\t\t\t\t\tcur[0] = min(cur[0],dsp(si,s));\t\n\t\t\t\t\tcur[1] = min(cur[1],dsp(si,t));\n\t\t\t\t\tif(iss(si,L{s,t})) st=false;\n\t\t\t\t}\n\t\t\t\tif(in_polygon(vpi,s)) cur[0] = 0.0;\n\t\t\t\tif(in_polygon(vpi,t)) cur[1] = 0.0;\n\t\t\t}\n\n\t\t\tdist[n][i] = dist[i][n] = cur[0];\n\t\t\tdist[n+1][i] = dist[i][n+1] = cur[1];\n\t\t}\n\t\t\t\t\n\t\tif(st) dist[n][n+1] = abs(s-t);\n\n\t\tcout.precision(20);\t\t\n\t\trep(k,total)rep(i,total)rep(j,total) dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\tcout << fixed << dist[n][n+1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon &poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nint N,VN[110];\ndouble Hs[110];\nPolygon polies[110];\nPoint ep[2];\n\nbool check(Segment &seg,int skip1=-1,int skip2=-1) {\n  rep(i,N) {\n    if( i == skip1 || i == skip2 ) continue;\n    rep(j,VN[i]) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%VN[i]]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment &seg1,Segment &seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\nvector<Edge> G[110];\ndouble dijkstra(int V) {\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,double theta,double phi) {\n  double ans = abs(ep[0]-ep[1]);\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,VN[i]) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    VN[i] = (int)polies[i].size();\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  rep(i,N+2) G[i].clear();\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\n\trep(k,VN[j]) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LTE(ans,abs(seg.p1-seg.p2)) ) continue;\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,j) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,VN[j]) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%VN[j]]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%VN[j]],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LTE(ans,abs(seg.p1-seg.p2)) ) continue;\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,j) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\t//if( !equals(mini,1e8) ) {\n\tif( LT(mini,ans) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      \n      rep(k,VN[i]) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%VN[i]]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%VN[j]]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LTE(ans,abs(seg.p1-seg.p2)) ) continue;\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(seg,i,j) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      //if( !equals(mini,1e8) ) {\n      if( LT(mini,ans) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  ans = min(ans,dijkstra(N+2));\n  printf(\"%.10f\\n\",ans);\n  //printf(\"%.10f\\n\",dijkstra(N+2));\n  \n}\n\nint main(){\n  while( cin >> N, N ) {\n    rep(i,N) {\n      cin >> VN[i] >> Hs[i];\n      polies[i].resize(VN[i]);\n      rep(j,VN[i]) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,toRad(theta),toRad(phi));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n \n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometry\n{\n  struct Point\n  {\n    double x, y;\n \n    Point() {};\n \n    Point(double x, double y) : x(x), y(y) {};\n \n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n \n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n \n    Point operator*(const double b) const { return Point(x * b, y * b); }\n \n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n \n    Point operator/(const double b) const { return Point(x / b, y / b); }\n \n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n \n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n \n    double norm() { return x * x + y * y; }\n \n    double arg() { return atan2(x, y); }\n \n    double abs() { return sqrt(norm()); }\n \n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n \n    Point rotate90() { return Point(-y, x); }\n \n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n \n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n \n  struct Line\n  {\n    Point a, b;\n \n    Line() {};\n \n    Line(Point a, Point b) : a(a), b(b) {};\n \n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n \n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n \n  struct Segment\n  {\n    Point a, b;\n \n    Segment() {};\n \n    Segment(Point a, Point b) : a(a), b(b) {};\n \n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n \n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n \n  struct Circle\n  {\n    Point p;\n    double r;\n \n    Circle() {};\n \n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n \n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n \n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n \n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n \n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n \n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n \n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n \n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n \n  double Distance(const Line &l, const Point &p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n \n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n \n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n \n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n \n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n \n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n \n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n \n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n \n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n \n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n \n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n \n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n \n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n \n  double Distance(const Line &l, const Segment &s)\n  { //OK\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n \n  double Distance(const Point &a, const Point &b)\n  { //OK\n    return (a - b).abs();\n  }\n \n  Point Crosspoint(const Segment &l, const Segment &m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n \n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n \n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n \n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  {\n    double d = (c1.p - c2.p).abs();\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = atan2(c2.p.y - c1.p.y, c2.p.x - c1.p.x);\n    Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n    Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n    return (PointPoint(p1, p2));\n  }\n \n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n \n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n \n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n \n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n \n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n \n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n \n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n \n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n};\n \nusing namespace Geometry;\n \nbool solve()\n{\n  int N, H[100];\n  vector< Point > P[100];\n  double theta, phi;\n  Point S, T;\n \n  cin >> N;\n  if(N == 0) return (false);\n  for(int i = 0; i < N; i++) {\n    int sz;\n    cin >> sz >> H[i];\n    while(sz--) {\n      Point s;\n      cin >> s;\n      P[i].emplace_back(s);\n    }\n  }\n  cin >> theta >> phi;\n  theta *= PI / 180;\n  phi *= PI / 180;\n  cin >> S >> T;\n \n  Polygon all[102];\n  for(int i = 0; i < N; i++) {\n    Point ident(-H[i] / tan(phi), 0);\n    ident = ident.rotate(theta);\n    for(auto &p : P[i])all[i].emplace_back(p + ident);\n    for(auto &p : P[i]) all[i].emplace_back(p);\n    all[i] = Convex_Hull(all[i]);\n  }\n \n  double mat[100][100];\n  fill_n(*mat, 100 * 100, 1e18);\n \n  for(int i = 0; i < N; i++) {\n    mat[i][i] = 0.0;\n  }\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      if(i == j) continue;\n      for(int k = 0; k < all[i].size(); k++) {\n        for(int l = 0; l < all[j].size(); l++) {\n          Segment latte = Segment(all[i][k], all[i][(k + 1) % all[i].size()]);\n          Segment malta = Segment(all[j][l], all[j][(l + 1) % all[j].size()]);\n          if(Intersect(latte, malta)) mat[i][j] = 0.0;\n          else mat[i][j] = min(mat[i][j], Distance(latte, malta));\n        }\n      }\n    }\n  }\n \n  for(int k = 0; k < N; k++) {\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n        mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n      }\n    }\n  }\n \n  double latte[100], malta[100];\n  fill_n(latte, 100, 1e18);\n  fill_n(malta, 100, 1e18);\n  for(int i = 0; i < N; i++) {\n    if(Contains(all[i], S)) {\n      latte[i] = 0.0;\n    } else {\n      for(int j = 0; j < all[i].size(); j++) {\n        Segment beet = Segment(all[i][j], all[i][(j + 1) % all[i].size()]);\n        latte[i] = min(latte[i], Distance(beet, S));\n      }\n    }\n    if(Contains(all[i], T)) {\n      malta[i] = 0.0;\n    } else {\n      for(int j = 0; j < all[i].size(); j++) {\n        Segment beet = Segment(all[i][j], all[i][(j + 1) % all[i].size()]);\n        malta[i] = min(malta[i], Distance(beet, T));\n      }\n    }\n  }\n \n  double ret = (S - T).abs();\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      ret = min(ret, mat[i][j] + latte[i] + malta[j]);\n    }\n  }\n  cout << fixed << setprecision(10) << ret << endl;\n \n  return (true);\n}\n \nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\n/* ?????¬????´? */\ntypedef complex<double> Point;  // Point\ntypedef vector<Point> VP;\nconst double EPS = 1e-6;    // ?¨±??????????????????????????£????????????\n\n//?°???????x,y?????¨???????????°x,y??¨??????????????????????????§??§??????\n#define X real()\n#define Y imag()\n\n// ?????????dot(a,b) = |a||b|cos??\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// ?????????cross(a,b) = |a||b|sin??\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// ??????????????????\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ???p?????´???a???????°???±????????????\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n  Point r = proj(a1, a2, p);\n  if (!ccw(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// ??????\nVP convexHull(VP& ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(Point p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nconst double INF = 1e9;\n\n#define cv_edge(CV,i) CV[i],CV[(i+1)%CV.size()]\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<int> NV(N+2),H(N+2);\n        vector<VP> ch(N+2,VP());\n        rep(i,N){\n            cin>>NV[i]>>H[i];\n            ch[i] = VP(2*NV[i]);        \n            rep(j,NV[i]){\n                double x,y;\n                cin>>x>>y;\n                ch[i][j]={x,y};\n            }\n        }\n        \n        double theta,phi,sx,sy,tx,ty;\n        cin>>theta>>phi>>sx>>sy>>tx>>ty;\n        theta *= M_PI/180.0;\n        phi   *= M_PI/180.0;\n\n        rep(i,N){\n            rep(j,NV[i]){\n                ch[i][j+NV[i]] = ch[i][j] - polar(H[i]/tan(phi),theta);\n            }\n            ch[i] = convexHull(ch[i]);\n        }\n\n        N += 2;\n        ch[N-1] = {{sx,sy}};\n        ch[N-2] = {{tx,ty}};\n    \n        vector<vector<double>> d(N,vector<double>(N,INF));\n        rep(i,N)rep(j,ch[i].size()){\n            rep(k,N-2)rep(l,ch[k].size()){\n                //??????i??????j??????????????????s,t?????¨ ??????k??????(l,l+1) ????????¢\n                d[i][k] = d[k][i] = \n                    min(d[i][k],distSP(cv_edge(ch[k],l),ch[i][j]));\n            }\n            rep(k,N-2){\n                //??????i??????j??????????????????s,t?????? ??????k????????¨?????????\n                if(inConvex(ch[i][j], ch[k])){\n                    d[i][k] = d[k][i] = 0;\n                }\n            }\n        }\n\n        rep(k,N)rep(i,N)rep(j,N)\n            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        printf(\"%.9f\\n\",min(d[N-1][N-2],abs(ch[N-1][0]-ch[N-2][0])));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf (1e10)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.5f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      dis=min(dis,getDistanceSP(seg1,P2[j][l]));\n    }\n    if(contains(P2[j],P2[i][k])==2)return 0.0;\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  if(contains(P2[i],p)==2)dis=0.0;\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,min(getdis(i,j),getdis(j,i)));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\ntypedef P point;\n\nvector<point> convex_hull(vector<point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\ntypedef vector<point> polygon;\n\nenum { OUT, ON, IN };\nint convex_contains(const polygon &P, const point &p) {\n    const int n = P.size();\n    point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n        int c = (a + b) / 2;\n        if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n            if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(P[a] - p, P[b] - p) < 0) return 0;\n    if (cross(P[a] - p, P[b] - p) > 0) return 2;\n    return 1;\n}\n\nclass Dijkstra {\n    int n;\n    vector<vector<pair<int, double>>> adj;\n    vector<double> d;\n\npublic:\n    Dijkstra(int n) : n(n), adj(n), d(n, numeric_limits<double>::infinity()) {}\n\n    void add_edge(int a, int b, double w) {\n        assert(0 <= a && a < n && 0 <= b && b < n);\n        // cerr << \"add edge (\" << a << \", \" << b << \", \" << w << \")\" << endl;\n        adj[a].emplace_back(b, w);\n        adj[b].emplace_back(a, w);\n    }\n\n    void add_arc(int a, int b, double w) {\n        assert(0 <= a && a < n && 0 <= b && b < n);\n        adj[a].emplace_back(b, w);\n    }\n\n    void run(int a) {\n        d[a] = 0;\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> que;\n        que.emplace(0, a);\n\n        while (que.size()) {\n            auto top = que.top();\n            que.pop();\n            int u = top.second;\n\n            for (auto& p : adj[u]) {\n                int v = p.first;\n                double w = p.second;\n                if (d[u] + w < d[v]) {\n                    d[v] = d[u] + w;\n                    que.emplace(d[v], v);\n                }\n            }\n        }\n    }\n\n    double dist(int a) {\n        return d[a];\n    }\n};\n\nbool EQ(double a, double b) {\n    return abs(a - b) < EPS;\n}\n\nbool GE(double a, double b) {\n    return a - b > -EPS;\n}\n\ndouble LE(double a, double b) {\n    return a - b < EPS;\n}\n\nbool intersect_1pt(const point& a, const point& b,\n                   const point& c, const point& d, point &r) {\n    double D =  cross(b - a, d - c);\n    if (EQ(D, 0)) return false;\n    double t =  cross(c - a, d - c) / D;\n    double s = -cross(a - c, b - a) / D;\n    r = a + t * (b - a);\n    return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n}\npolygon convex_intersect(const polygon &P, const polygon &Q) {\n    const int n = P.size(), m = Q.size();\n    int a = 0, b = 0, aa = 0, ba = 0;\n    enum { Pin, Qin, Unknown } in = Unknown;\n    polygon R;\n    do {\n        int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n        double C = cross(P[a] - P[a1], Q[b] - Q[b1]);\n        double A = cross(P[a1] - Q[b], P[a] - Q[b]);\n        double B = cross(Q[b1] - P[a], Q[b] - P[a]);\n        point r;\n        if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n            if (in == Unknown) aa = ba = 0;\n            R.push_back( r );\n            in = B > 0 ? Pin : A > 0 ? Qin : in;\n        }\n        if (C == 0 && B == 0 && A == 0) {\n            if (in == Pin) { b = (b + 1) % m; ++ba; }\n            else           { a = (a + 1) % m; ++aa; }\n        } else if (C >= 0) {\n            if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n            else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n        } else {\n            if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n            else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n        }\n    } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n    if (in == Unknown) {\n        if (convex_contains(Q, P[0])) return P;\n        if (convex_contains(P, Q[0])) return Q;\n    }\n    return R;\n}\n\nbool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n           abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n           ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble distance(const polygon &P, const polygon &Q) {\n    polygon isec = convex_intersect(P, Q);\n    if (isec.size()) return 0;\n    double ret = 1e9;\n    for (int i = 0; i < P.size(); i++) {\n        for (int j = 0; j < Q.size(); j++) {\n            L lp = {P[i], P[(i + 1) % P.size()]};\n            L lq = {Q[j], Q[(j + 1) % Q.size()]};\n            ret = min(ret, distanceSS(lp, lq));\n        }\n    }\n    return ret;\n}\n\ndouble distance(const polygon &P, const point &p) {\n    int k = convex_contains(P, p);\n    if (k == IN || k == ON) return 0;\n    double ret = 1e9;\n    for (int i = 0; i < P.size(); i++) {\n        L l = {P[i], P[(i + 1) % P.size()]};\n        ret = min(ret, distanceSP(l, p));\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    int cnt = 0;\n    while (cin >> n) {\n        if (n == 0) break;\n        // cerr << \"Case #\" << ++cnt << endl;\n        vector<polygon> polygons;\n        vector<vector<point>> points;\n        vector<int> ks(n), hs(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ks[i] >> hs[i];\n            // cerr << \"fuga \" << ks[i] << ' ' << hs[i] << endl;\n            vector<point> ps;\n            for (int j = 0; j < ks[i]; j++) {\n                double a, b;\n                cin >> a >> b;\n                ps.push_back(point(a, b));\n            }\n            points.emplace_back(ps);\n        }\n        double theta, phi;\n        cin >> theta >> phi;\n        phi = phi / 180 * acos(-1);\n        theta = theta / 180 * acos(-1);\n        // cerr << \"tan(phi) = \" << tan(phi) << endl;\n        for (int j = 0; j < n; j++) {\n            double dx = hs[j] / tan(phi) * cos(theta), dy = hs[j] / tan(phi) * sin(theta);\n            // cerr << \"dx : \" << dx << \", dy : \" << dy << endl;\n            for (int i = 0; i < ks[j]; i++) {\n                double a = points[j][i].real(), b = points[j][i].imag();\n                points[j].push_back(point(a - dx, b - dy));\n            }\n            polygon poly = convex_hull(points[j]);\n            // cerr << \"polygon \" << j << \": \";\n            for (int i = 0; i < poly.size(); i++) {\n                // cerr << \"(\" << poly[i].real() << \", \" << poly[i].imag() << \"), \";\n            }\n            // cerr << endl;\n            polygons.emplace_back(poly);\n        }\n        // cerr << \"read polygon\" << endl;\n        double sx, sy, tx, ty;\n        cin >> sx >> sy >> tx >> ty;\n        // cerr << \"hoge\" << sx << ' ' << sy << ' ' << tx << ' ' << ty << endl;\n        Dijkstra g(n + 2);\n        g.add_edge(n, n + 1, hypot(sx - tx, sy - ty));\n        for (int i = 0; i < n; i++) {\n            g.add_edge(i, n, distance(polygons[i], point(sx, sy)));\n            g.add_edge(i, n + 1, distance(polygons[i], point(tx, ty)));\n        }\n        // cerr << \"piyo\" << endl;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                g.add_edge(i, j, distance(polygons[i], polygons[j]));\n            }\n        }\n        // cerr << \"added edge\" << endl;\n        g.run(n);\n        printf(\"%.10f\\n\", g.dist(n + 1));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) cerr << #a << \" \" << a << endl\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\nusing ll = long long;\nusing vi = vector<int>;\n\nconst double EPS = 1e-8;\nconst double inf = 1e12;\n\nusing P = complex<double>;\nnamespace std{\n  bool operator < (const P &a, const P &b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool isnan(const P &p){\n    return isnan(real(p)) or isnan(imag(p));\n  }\n}\ndouble cross(const P &p, const P &q){\n  return imag(conj(p)*q);\n}\ndouble dot(const P &p, const P &q){\n  return real(conj(p)*q);\n}\nstruct L : public vector<P>{\n  L(const P &p, const P &q){\n    push_back(p);\n    push_back(q);\n  }\n};\nusing G = vector<P>;\n\nint ccw(P a,P b, P c){\n  b -= a; c -= a;\n  if(cross(b,c)>0) return 1;\n  if(cross(b,c)<0) return -1;\n  if(dot(b,c)<0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n\ndouble intersectSP(const L &s, const P &p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble intersectSS(const L &s, const L &t){\n  if(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n     ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0) return true;\n  if(intersectSP(s,t[0]) or intersectSP(s,t[1]) or\n     intersectSP(t,s[0]) or intersectSP(t,s[1])) return true;\n  return false;\n}\n\nP projection(const L &l, const P &p){\n  double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L&s, const P &p){\n  const P r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s, const L &t){\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n\t     min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\ndouble distanceGP(const G &g, const P &p){\n  int n = g.size();\n  double ans = inf;\n  rep(i,n){\n    L l(g[i],g[(i+1)%n]);\n    ans = min(ans, distanceSP(l,p));\n  }\n  return ans;\n}\ndouble distanceGG(const G &g, const G &h){\n  double ans = inf;\n  int n = g.size(), m = h.size();\n  rep(i,g.size()) rep(j,h.size()){\n    L l1(g[i],g[(i+1)%n]), l2(h[j],h[(j+1)%m]);\n    ans = min(ans, distanceSS(l1,l2));\n  }\n  return ans;\n}\n\nvector<P> convex_hull(vector<P> ps){\n  int n = ps.size(), k = 0;\n  sort(ps.begin(),ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool containGP(const G &g, const P &p){\n  double sum = 0;\n  int n = g.size();\n  rep(i,n){\n    int j = (i+1)%n;\n    if(intersectSP(L(g[i],g[j]-g[i]),p))\n      return true;\n    sum += arg((g[j]-p)/(g[i]-p));\n  }\n  return abs(sum) > 1;\n}\n\nusing Cost = double;\nclass node{\npublic:\n  int v;\n  Cost d;\n  node(int a_, Cost b_):v(a_),d(b_){}\n  bool operator <(const node &n) const { return d > n.d; }\n};\nclass edge{\npublic:\n  int to;\n  Cost d;\n  edge(){}\n  edge(int to_, Cost d_) : to(to_), d(d_) {}\n};\nclass dijkstra{\npublic:\n  vector<vector<edge>> G;\n  vector<Cost> dist;\n  \n  dijkstra(int s, const vector<vector<edge>> &G_):G(G_){\n    dist.resize(G.size(),inf);\n\n    priority_queue<node> que;\n    que.push(node(s,0));\n    dist[s] = 0;\n\n    while(!que.empty()){\n      int v = que.top().v;\n      Cost d = que.top().d;\n      que.pop();\n\n      rep(i,G[v].size()){\n\tCost tmp = d + G[v][i].d;\n\tif(dist[G[v][i].to] > tmp + EPS){\n\t  dist[G[v][i].to] = tmp;\n\t  que.push(node(G[v][i].to, tmp));\n\t}\n      }\n    }\n  }\n};\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vector<G> gs(n);\n    vi hs(n);\n    rep(i,n){\n      int nv; cin >> nv;\n      cin >> hs[i];\n      rep(j,nv){\n\tdouble x, y; cin >> x >> y;\n\tgs[i].push_back(P(x,y));\n      }\n    }\n    int inttheta; cin >> inttheta;\n    double theta = double(inttheta) * M_PI / 180;\n    if(inttheta <= 180){\n      theta -= M_PI;\n    }else{\n      theta -= M_PI;\n    }\n    double phi; cin >> phi;\n    phi *= M_PI / 180;\n    P s, t;\n    double x, y; cin >> x >> y;\n    s = P(x, y);\n    cin >> x >> y;\n    t = P(x, y);\n\n    rep(i,n){\n      P diff = polar(hs[i]/tan(phi),theta);\n      int m = gs[i].size();\n      rep(j,m){\n\tgs[i].push_back(gs[i][j]+diff);\n      }\n      gs[i] = convex_hull(gs[i]);\n    }\n\n    vector<vector<edge>> g(n+2);\n    rep(i,n){\n      double d;\n      if(containGP(gs[i],s)) d = 0;\n      else d = distanceGP(gs[i],s);\n      g[i].emplace_back(n,d);\n      g[n].emplace_back(i,d);\n    }\n    rep(i,n){\n      double d;\n      if(containGP(gs[i],t)) d = 0;\n      else d = distanceGP(gs[i],t);\n      g[i].emplace_back(n+1,d);\n      g[n+1].emplace_back(i,d);\n    }\n    rep(i,n) FOR(j,i+1,n){\n      double d = distanceGG(gs[i],gs[j]);\n      g[i].emplace_back(j,d);\n      g[j].emplace_back(i,d);\n    }\n    double d = abs(s-t);\n    g[n].emplace_back(n+1,d);\n    g[n+1].emplace_back(n,d);\n    dijkstra dijk(n, g);\n    printf(\"%.10lf\\n\", dijk.dist[n+1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\nusing namespace std;\n\n#define repi(i,j,n) for (int i = (j); i < (n); ++i)\n#define rep(i,n) repi(i,0,n)\n#define INF 1e9\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n// Geometry short ver\n\nclass P {\npublic:\n    double x, y;\n    P(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    P operator + (P p) {\n        return P(x + p.x, y + p.y);\n    }\n    P operator - (P p) {\n        return P(x - p.x, y - p.y);\n    }\n    P operator * (double c) {\n        return P(c * x, c * y);\n    }\n    P operator / (double c) {\n        return P(x / c, y / c);\n    }\n    bool operator < (const P &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const P &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n};\n\ntypedef P V;\n\ndouble dot(V a, V b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(V a, V b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(V a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(V a) {\n    return sqrt(norm(a));\n}\n\nclass S {\npublic:\n    P s, e; // start, end\n    S(P s = P(), P e = P()) : s(s), e(e) {}\n};\n\ntypedef S L;\n\ntypedef vector<P> Polygon;\n\ndouble dP(P a, P b) {\n    return (a - b).abs();\n}\n\ndouble dL(L l, P p) {\n    return abs(cross(l.e - l.s, p - l.s) / abs(l.e - l.s));\n}\n\ndouble dS(S s, P p) {\n    if (dot(s.e - s.s, p - s.s) < 0.0) return abs(p - s.s);\n    if (dot(s.s - s.e, p - s.e) < 0.0) return abs(p - s.e);\n    return dL(s, p);\n}\n\nconst int CCW = 1, CW = -1, OB = 2, OF = -2, OS = 0;\n\nint ccw(P x, P y, P z) {\n    V a = y - x, b = z - x;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return OB;\n    if (a.norm() < b.norm()) return OF;\n    return OS;\n}\n\nbool intersect(P a, P b, P c, P d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(S a, S b) {\n    return intersect(a.s, a.e, b.s, b.e);\n}\n\ndouble dSS(S a, S b) {\n    if (intersect(a, b)) return 0.0;\n    return min(min(dS(a, b.s), dS(a, b.e)), min(dS(b, a.s), dS(b, a.e)));\n}\n\nP crossP(S a, S b) {\n    V base = b.e - b.s;\n    double d1 = abs(cross(base, a.s - b.s));\n    double d2 = abs(cross(base, a.e - b.s));\n    double t = d1 / (d1 + d2);\n    return a.s + (a.e - a.s) * t;\n}\n\n/* IN 2, ON 1, OUT 0*/\nint contains(Polygon g, P p) {\n    int n = g.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        P a = g[i] - p, b = g[(i + 1) % n] - p;\n        if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\n\nPolygon andrewScan(Polygon s) {\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    int ssize = s.size();\n\n    // upper\n    for (int i = 2; i < ssize; ++i) {\n        for (int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == CCW; n--) {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    // lower\n    for (int i = ssize - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == CCW; n--) {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) {\n        l.push_back(u[i]);\n    }\n\n    return l;\n}\n\n// building\nclass B {\npublic:\n    int n, h;\n    Polygon p;\n    vector<S> s;\n};\n\nint n;\nint nv, h, sx, sy, tx, ty;\ndouble x, y;\ndouble wf[110][110];\nint th, ps;\ndouble ans;\nPolygon p;\nvector<B> b;\n\ninline void makeConvexHull() {\n    int size_;\n\n    rep(i,n) {\n        size_ = b[i].p.size();\n        rep(j,size_) {\n            b[i].p.push_back(P(b[i].p[j].x + b[i].h * cos(rad(th + 180.0)) / tan(rad(ps)),\n                               b[i].p[j].y + b[i].h * sin(rad(th + 180.0)) / tan(rad(ps))));\n        }\n\n        b[i].p = andrewScan(b[i].p);\n        size_ = b[i].p.size();\n        \n        rep(j,size_) {\n            b[i].s.push_back(S(b[i].p[j], b[i].p[(j + 1) % size_]));\n        }\n    }\n}\n\ninline double solve() {\n    makeConvexHull();\n\n    int sizei, sizej;\n    double mi, tmp;\n\n    rep(i,n) {\n        repi(j,i+1,n) {\n            sizei = b[i].s.size();\n            sizej = b[j].s.size();\n            mi = INF;\n\n            rep(k,sizei) {\n                rep(l,sizej) {\n                    tmp = dSS(b[i].s[k], b[j].s[l]);\n                    mi = min(mi, tmp);\n                    if (mi == 0) break;\n                }\n                if (mi == 0) break;\n            }\n\n            wf[i + 1][j + 1] = wf[j + 1][i + 1] = mi;\n        }\n    }\n\n    // P(sx, sy)\n    rep(i,n) {\n        mi = INF;\n        if (contains(b[i].p, P(sx, sy)) != 0) {\n            wf[0][i + 1] = wf[i + 1][0] = 0.0;\n        }\n        else {\n            sizei = b[i].s.size();\n            rep(j,sizei) {\n                tmp = dS(b[i].s[j], P(sx, sy));\n                mi = min(mi, tmp);\n                if (mi == 0) break;\n            }\n            wf[0][i + 1] = wf[i + 1][0] = mi;\n        }\n    }\n\n    // P(tx, ty)\n    rep(i,n) {\n        mi = INF;\n        if (contains(b[i].p, P(tx, ty)) != 0) {\n            wf[n + 1][i + 1] = wf[i + 1][n + 1] = 0.0;\n        }\n        else {\n            sizei = b[i].s.size();\n            rep(j,sizei) {\n                tmp = dS(b[i].s[j], P(tx, ty));\n                mi = min(mi, tmp);\n                if (mi == 0) break;\n            }\n            wf[n + 1][i + 1] = wf[i + 1][n + 1] = mi;\n        }\n    }\n\n    // wf\n    rep(k,n+2) {\n        rep(i,n+2) {\n            rep(j,n+2) {\n                wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n            }\n        }\n    }\n\n    return wf[0][n+1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        b.resize(n);\n        rep(i,n+2) {\n            rep(j,n+2) {\n                if (i == j) wf[i][j] = 0;\n                else wf[i][j] = INF;\n            }\n        }\n\n        rep(i,n) {\n            cin >> nv >> h;\n\n            p.resize(nv);\n            b[i].n = nv;\n            b[i].h = h;\n\n            rep(j,nv) {\n                cin >> x >> y;\n                p[j] = P(x, y);\n            }\n\n            b[i].p = p;\n            p.clear();\n        }\n        cin >> th >> ps;\n        cin >> sx >> sy >> tx >> ty;\n\n\n        ans = solve();\n\n        cout << fixed << setprecision(10) << ans << endl;\n        b.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst double EPS = 1e-10;\nconst double PI = 3.141592653589793;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) const { return Point(a * x, a * y); }\n\tPoint operator / (double a) const { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>; // ????§???¢\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\nPoint rotationalTransfer(Point c, double r, double deg) { // c???????????¨????????????r????????¨??????deg??????????????§?¨?\n\tdouble rad = PI * deg / 180.0; return c + Point(cos(rad), sin(rad)) * r;\n}\n// (x, y, z) ???????????????(xy??§?¨???§????§???????theta???, xy?????¢??????z?????????????§???????phi????????????)??????????????????????????±???xy??§?¨?\nPoint Shadow(double x, double y, double z, double theta, double phi) {\n\ttheta = PI * theta / 180.0, phi = PI * phi / 180.0;\n\treturn Point(x - z / tan(phi) * cos(theta), y - z / tan(phi) * sin(theta));\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????§???¢ ***\n// IN := 2, ON := 1, OUT := 0\nvector<Segment> getPolygonSegument(const Polygon& p) { //????§???¢????????????????§???¢??????????±???????\n\tvector<Segment> ret;\n\trep(i, p.size() - 1) ret.push_back(Segment(p[i], p[i + 1]));\n\tret.push_back(Segment(p[p.size() - 1], p[0]));\n\treturn ret;\n}\nint contains(const Polygon& g, const Point& p){ // ????§???¢g????????????p????????????????????????\n\tint n = g.size(); bool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif ( abs(cross(a, b)) < EPS && dot(a, b) < EPS ) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) { // ??????(??????????????????????????????)\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end()); // x, y???????????????????????????\n\t// x????°???????????????????2??? u ?????????\n\tu.push_back(s[0]), u.push_back(s[1]);\n\t// x ?????§??????????????????2???1?????????\n\tl.push_back(s[s.size() - 1]), l.push_back(s[s.size() - 2]);\n\t// ??????????????¨?????????\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t// ??????????????¨?????????\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t// ????¨????????????????????????????????????????????????????\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) { // ???????????????????????¨??????????????????????????????????????¨\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(const Segment& s1, const Segment& s2) { // ??????s1??¨??????s2?????????\n\tif( intersect(s1, s2) ) return 0.0; //????????£???????????¨???\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\ndouble getDistancePolP(const Polygon& pol, const Point& p) { // ????§???¢pol??¨???p????????¢\n\tif(contains(pol, p) != 0) return 0.0; // ??????????§???¢????????¨?????????????????????\n\tdouble ret = 1e9;\n\tfor(Segment& u : getPolygonSegument(pol)) ret = min(ret, getDistanceSP(u, p));\n\treturn ret;\n}\ndouble getDistancePolPol(const Polygon& p1, const Polygon& p2) { // ????§???¢p1??¨p2????????¢\n\t//for(const Point& p : p1) if(contains(p2, p) != 0) return 0.0; // p1?????????????§???¢p2???????????????????????????\n\t//for(const Point& p : p2) if(contains(p1, p) != 0) return 0.0; // p2?????????????§???¢p1???????????????????????????\n\tdouble ret = 1e9;\n\tfor(const Segment& u : getPolygonSegument(p1))for(const Segment& v : getPolygonSegument(p2)) {\n\t\tret = min(ret, getDistanceSS(u, v));\n\t}\n\treturn ret;\n}\n\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\n\nconst int MAX_N = 210;\nusing TYPE = double; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\n\nint main(void) {\n\t\n\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tint NV[110], H[110];\n\t\tvector<vector<pair<double, double>>> p;\n\t\trep(i, N){\n\t\t\tscanf(\"%d %d\", &NV[i], &H[i]);\n\t\t\tvector<pair<double, double>> tmp;\n\t\t\trep(j, NV[i]){\n\t\t\t\tdouble x, y; scanf(\"%lf %lf\", &x, &y);\n\t\t\t\ttmp.pb(mp(x, y));\n\t\t\t}\n\t\t\tp.pb(tmp);\n\t\t}\n\t\tdouble theta, phi; scanf(\"%lf %lf\", &theta, &phi);\n\t\tdouble Sx, Sy, Tx, Ty; scanf(\"%lf %lf %lf %lf\", &Sx, &Sy, &Tx, &Ty);\n\t\tPoint start(Sx, Sy), goal(Tx, Ty);\n\n\t\tvector<Polygon> v;\n\t\trep(i, N){\n\t\t\tPolygon t;\n\t\t\tfor(auto u : p[i]) t.pb(Shadow(u.fi, u.se, H[i], theta, phi));\n\t\t\tfor(auto u : p[i]) t.pb(Point(u.fi, u.se));\n\t\t\tPolygon tt = andrewScan(t);\n\t\t\tv.pb(tt);\n\t\t}\n\n\t\t/*\n\t\tfor(auto u : v) {\n\t\t\tfor(auto k : u) printf(\"%f %f, \", k.x, k.y);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\t\n\n\t\trep(i, MAX_N) G[i].clear();\n\n\t\trep(i, v.size())rep(j, v.size()){\n\t\t\tif(i == j) continue;\n\t\t\tint s = i + 1, t = j + 1;\n\t\t\tauto dis = getDistancePolPol(v[i], v[j]);\n\t\t\tG[s].pb(mp(t, dis)), G[t].pb(mp(s, dis));\n\t\t}\n\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], start);\n\t\t\tG[0].pb(mp(i + 1, dis)), G[i + 1].pb(mp(0, dis));\n\t\t}\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], goal);\n\t\t\tG[N + 1].pb(mp(i + 1, dis)), G[i + 1].pb(mp(N + 1, dis));\n\t\t}\n\n\t\tG[0].pb(mp(N + 1, getDistance(start, goal))), G[N + 1].pb(mp(0, getDistance(start, goal)));\n\n\t\tauto ret = dijkstra(0);\n\t\tprintf(\"%.9f\\n\", ret[N + 1]);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon &poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nint N,VN[110];\ndouble Hs[110];\nPolygon polies[110];\nPoint ep[2];\n\nbool check(Segment &seg,int skip1=-1,int skip2=-1) {\n  rep(i,N) {\n    if( i == skip1 || i == skip2 ) continue;\n    rep(j,VN[i]) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%VN[i]]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment &seg1,Segment &seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\nvector<Edge> G[110];\ndouble dijkstra(int V) {\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,double theta,double phi) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,VN[i]) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    VN[i] = (int)polies[i].size();\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  rep(i,N+2) G[i].clear();\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\n\trep(k,VN[j]) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,j) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,VN[j]) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%VN[j]]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%VN[j]],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,j) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      \n      rep(k,VN[i]) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%VN[i]]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%VN[j]]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(seg,i,j) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(N+2));\n  \n}\n\nint main(){\n  while( cin >> N, N ) {\n    rep(i,N) {\n      cin >> VN[i] >> Hs[i];\n      polies[i].resize(VN[i]);\n      rep(j,VN[i]) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,toRad(theta),toRad(phi));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e18\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ndouble distPP(vec2d p, vec2d q){\n\treturn (p-q).norm();\n}\n\ndouble distSP(vec2d p, vec2d q, vec2d x)\n{\n\tif((x-p).dot(q-p) <= 0) return distPP(p, x);\n\tif((x-q).dot(p-q) <= 0) return distPP(q, x);\n\treturn fabs( (x-p).cross(q-p) / distPP(p, q) );\n}\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\ndouble distSS(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif(isCross(p, q, r, s)) return 0;\n\tdouble ret = distSP(p, q, r);\n\tret = min(ret, distSP(p, q, s));\n\tret = min(ret, distSP(r, s, p));\n\tret = min(ret, distSP(r, s, q));\n\treturn ret;\n}\n\nbool isInTriangle(vec2d p, vec2d q, vec2d r, vec2d x)\n{\n\tp = p - r, q = q - r, x = x - r;\n\tdouble s = p.cross(x) / p.cross(q), t = x.cross(q) / p.cross(q);\n\treturn s >= -eps && t >= -eps && s+t <= 1 + eps;\n}\n\ntypedef pair<vec2d, vec2d> Segment;\nstruct Region{\n\tSegment seg[4];\n\tRegion(){};\n\tRegion(Segment a, Segment b, Segment c, Segment d){\n\t\tseg[0] = a, seg[1] = b, seg[2] = c, seg[3] = d;\n\t}\n};\n\nstruct edge{\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int a, double b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint N;\ndouble h[105];\nvector<vec2d> poly[105];\ndouble th, phy;\nvec2d s, t;\n\nint S, T, V;\nvector<Region> vec;\nvector<edge> G[1500];\ndouble dist[1500];\n\ntypedef pair<double, int> P;\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tint v; double d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tint n; vec2d tmp;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> n >> h[i];\n\t\t\tpoly[i].clear();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> tmp.x >> tmp.y;\n\t\t\t\tpoly[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tcin >> th >> phy;\n\t\tth *= M_PI / 180, phy *= M_PI / 180;\n\t\tcin >> s.x >> s.y;\n\t\tcin >> t.x >> t.y;\n\t\t\n\t\tvec.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tvec2d a, b, a2, b2;\n\t\t\tfor(int j = 0; j < poly[i].size(); j++){\n\t\t\t\ta = poly[i][j], b = poly[i][(j+1)%(poly[i].size())];\n\t\t\t\tdouble l = h[i] / tan(phy);\n\t\t\t\ta2 = vec2d(a.x - l*cos(th), a.y - l*sin(th));\n\t\t\t\tb2 = vec2d(b.x - l*cos(th), b.y - l*sin(th));\n\t\t\t\tvec.push_back(Region(make_pair(a, a2), make_pair(a2, b2), make_pair(b2, b), make_pair(b, a)));\n\t\t\t}\n\t\t}\n\t\tV = vec.size();\n\t\t\n\t\tfor(int i = 0; i < V; i++) G[i].clear();\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tdouble dist = inf;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\t\tdist = min(dist, distSS(vec[i].seg[k].first, vec[i].seg[k].second,\n\t\t\t\t\t\t\tvec[j].seg[l].first, vec[j].seg[l].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i].push_back(edge(j, dist));\n\t\t\t\tG[j].push_back(edge(i, dist));\n\t\t\t}\n\t\t}\n\t\t\n\t\tS = V, T = V+1;\n\t\tG[S].clear(), G[T].clear();\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tdouble dist = inf;\n\t\t\tif(isInTriangle(vec[i].seg[0].first, vec[i].seg[1].first, vec[i].seg[2].first, s)\n\t\t\t|| isInTriangle(vec[i].seg[0].first, vec[i].seg[2].first, vec[i].seg[3].first, s)){\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tdist = min(dist, distSP(vec[i].seg[j].first, vec[i].seg[j].second, s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tG[S].push_back(edge(i, dist));\n\t\t\tG[i].push_back(edge(S, dist));\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tdouble dist = inf;\n\t\t\tif(isInTriangle(vec[i].seg[0].first, vec[i].seg[1].first, vec[i].seg[2].first, t)\n\t\t\t|| isInTriangle(vec[i].seg[0].first, vec[i].seg[2].first, vec[i].seg[3].first, t)){\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tdist = min(dist, distSP(vec[i].seg[j].first, vec[i].seg[j].second, t));\n\t\t\t\t}\n\t\t\t}\n\t\t\tG[T].push_back(edge(i, dist));\n\t\t\tG[i].push_back(edge(T, dist));\n\t\t}\n\t\tV += 2;\n\t\t\n\t\tdijkstra();\n\t\t\n\t\t//for(int i = 0; i < V; i++) cout << dist[i] << \" \"; cout << endl;\n\t\tdouble ans = min(dist[T], distPP(s, t));\n\t\tprintf(\"%.11f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct Line {\npublic:\n\tPoint a, b;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn (cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint n;\nld h[100];\nvector<Point> vp[100];\nvector<Point> rvp[100];\nvector<Line> vl[100];\n\nstruct edge {\n\tint to; ld cost;\n};\nvector<edge> G[102];\nld dist[102];\n\ntypedef pair<ld, int> speP;\npriority_queue<speP, vector<speP>, greater<speP>> q;\nvoid solve() {\n\tcout << fixed << setprecision(5);\n\twhile (cin >> n, n) {\n\t\trep(i, n + 2)G[i].clear();\n\t\trep(i, n) {\n\t\t\tvl[i].clear();\n\t\t\tvp[i].clear();\n\t\t\trvp[i].clear();\n\t\t\tint l; cin >> l>>h[i]; \n\t\t\tvp[i].resize(l);\n\t\t\trep(j, l) {\n\t\t\t\tld x, y; cin >> x >> y; vp[i][j] = { x,y };\n\t\t\t}\n\t\t}\n\t\tld theta, phi; cin >> theta >> phi;\n\t\ttheta = theta * pi / 180.0;\n\t\tphi = phi * pi / 180.0;\n\t\ttheta += pi;\n\t\trep(i, n) {\n\t\t\t\n\t\t\trvp[i].resize(vp[i].size());\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tld dx = cos(theta)*rh, dy = sin(theta)*rh;\n\t\t\t\trvp[i][j] = { dx + real(vp[i][j]),dy + imag(vp[i][j]) };\n\t\t\t\tvl[i].push_back({ vp[i][j],rvp[i][j] });\n\t\t\t}\n\t\t\trep(j, vp[i].size()-1) {\n\t\t\t\tvl[i].push_back({ vp[i][j],vp[i][j + 1] });\n\t\t\t}\n\t\t\tvl[i].push_back({ vp[i][0], vp[i][vp[i].size() - 1] });\n\t\t\trep(j, vp[i].size() - 1) {\n\t\t\t\tvl[i].push_back({ rvp[i][j],rvp[i][j + 1] });\n\n\t\t\t}\n\t\t\tvl[i].push_back({ rvp[i][0],rvp[i][rvp[i].size() - 1] });\n\t\t}\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tld d = INF;\n\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\tif (isis_ss(vl[i][k], vl[j][l])) {\n\t\t\t\t\t\t\td = 0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d == 0)break;\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], vp[j][l]));\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], rvp[j][l]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (d > 0) {\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\tRep(k, vp[i].size(), vl[i].size()) {\n\t\t\t\t\t\t\tif (isis_ss(vl[i][k], vl[j][l])) {\n\t\t\t\t\t\t\t\td = 0; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d == 0)break;\n\t\t\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], vp[i][k]));\n\t\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], rvp[i][k]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d>0){\n\t\t\t\t\tRep(k, vp[i].size(), vl[i].size()) {\n\t\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\n\t\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*rep(k, vl[i].size()) {\n\t\t\t\t\trep(l, vl[j].size()) {\n\t\t\t\t\t\tif (k < vp[i].size() && l < vp[j].size())continue;\n\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tG[i].push_back({ j,d });\n\t\t\t\tG[j].push_back({ i, d });\n\t\t\t}\n\t\t}\n\t\tPoint s, g; ld x, y; cin >> x >> y; s = { x,y }; cin >> x >> y; g = { x,y };\n\t\ttheta -= pi;\n\t\tPoint ps, pg;\n\t\trep(i, n) {\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\tps = { real(s) + rh * cos(theta),imag(s) + rh * sin(theta) };\n\t\t\tpg = { real(g) + rh * cos(theta),imag(g) + rh * sin(theta) };\n\t\t\tLine ls = { s,ps };\n\t\t\tLine lg = { g,pg };\n\t\t\tbool fs = false, fg = false;\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tLine vpl = { vp[i][j],vp[i][(j + 1) % vp[i].size()] };\n\t\t\t\tif (isis_ss(ls, vpl)) {\n\t\t\t\t\tfs = true;\n\t\t\t\t}\n\t\t\t\tif (isis_ss(lg, vpl)) {\n\t\t\t\t\tfg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fs) {\n\t\t\t\tG[n].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], s));\n\t\t\t\t}\n\t\t\t\tG[n].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n,d });\n\t\t\t}\n\t\t\tif (fg) {\n\t\t\t\tG[n + 1].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n + 1,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], g));\n\t\t\t\t}\n\t\t\t\tG[n + 1].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n + 1,d });\n\t\t\t}\n\t\t}\n\t\tG[n].push_back({ n + 1,abs(g - s) });\n\t\tG[n + 1].push_back({ n,abs(g - s) });\n\t\tfill(dist, dist + n + 2, INF);\n\t\tdist[n] = 0;\n\t\tq.push({ 0,n });\n\t\twhile (!q.empty()) {\n\t\t\tspeP p = q.top(); q.pop();\n\t\t\tint id = p.second;\n\t\t\tif (p.first > dist[id])continue;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tld nd = G[id][j].cost + p.first;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tq.push({ nd,to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[n + 1] << endl;\n\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX)\n    e[i].clear();\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      dis=min(dis,getDistanceSP(seg,P2[j][l]));\n    }\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      double dis=min(getdis(i,j),getdis(j,i));\n      add_edge(i,j,dis);\n      add_edge(j,i,dis);\n    }\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      Segment seg(P2[i][j],P2[i][(j+1)%P2[i].size()]);\n      dis=min(dis,getDistanceSP(seg,s));\n    }\n    if(contains(P2[i],s)!=0)dis=0.0;\n    add_edge(n,i,dis);\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      Segment seg(P2[i][j],P2[i][(j+1)%P2[i].size()]);\n      dis=min(dis,getDistanceSP(seg,t));\n    }\n    if(contains(P2[i],t)!=0)dis=0.0;\n    add_edge(i,n+1,dis);\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nbool check(vector<Polygon> &polies,Segment &seg,set<int> skip) {\n  rep(i,(int)polies.size()) {\n    if( skip.count(i) ) continue;\n    rep(j,(int)polies[i].size()) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%(int)polies[i].size()]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment seg1,Segment seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\ndouble dijkstra(vector<vector<Edge>> &G) {\n  int V = G.size();\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,vector<double> &Hs,vector<Polygon> &polies,double theta,double phi,vector<Point> &ep) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,(int)polies[i].size()) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  vector<vector<Edge>> G(2+N);\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\trep(k,(int)polies[j].size()) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  set<int> skip;\n\t  skip.insert(j);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,(int)polies[j].size()) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%(int)polies[j].size()]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%(int)polies[j].size()],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  set<int> skip;\n\t  skip.insert(j);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      \n      rep(k,(int)polies[i].size()) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%(int)polies[i].size()]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%(int)polies[j].size()]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    set<int> skip;\n\t    skip.insert(i);\n\t    skip.insert(j);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(G));\n  \n}\n\nint main(){\n  int N;\n  while( cin >> N, N ) {\n    vector<double> Hs(N);\n    vector<Polygon> polies(N);\n    rep(i,N) {\n      int V;\n      cin >> V >> Hs[i];\n      polies[i].resize(V);\n      rep(j,V) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    vector<Point> ep(2);\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,Hs,polies,toRad(theta),toRad(phi),ep);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps=1e-11;\nconst ld pi=acos(-1.0);\nbool eq(ld a,ld b){\n  return (abs(a-b)<eps);\n}\nld dot(Point a,Point b){\n  return real(conj(a)*b);\n}\nld cross(Point a,Point b){\n  return imag(conj(a)*b);\n}\nclass Line{\npublic:\n  Point a,b;\n};\nint ccw(Point a,Point b,Point c){\n  b-=a;c-=a;\n  if(cross(b,c)>eps)return 1;\n  if(cross(b,c)<-eps)return -1;\n  if(dot(b,c)<0)return 2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\nbool isis_ll(Line l,Line m){\n  return !eq(cross(l.b-l.a,m.b-m.a),0);\n}\nbool isis_ls(Line l,Line s){\n  return (cross(l.b-l.a,s.a-l.a)*cross(l.b-l.a,s.b-l.a)<eps);\n}\nbool isis_ss(Line s,Line t){\n  if(!(cross(s.b-s.a,t.a-s.a)*cross(s.b-s.a,t.b-s.a)<eps&&cross(t.b-t.a,s.a-t.a)*cross(t.b-t.a,s.b-t.a)<eps))return false;\n  if(ccw(s.a,s.b,t.a)==ccw(s.a,s.b,t.b)&&ccw(s.a,s.b,t.a)!=1&&ccw(s.a,s.b,t.a)!=-1)return false;\n  return true;\n}\nbool isis_lp(Line l,Point p){\n  return (abs(cross(l.b-p,l.a-p))<eps);\n}\nbool isis_sp(Line s,Point p){\n  return (abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a)<eps);\n}\nPoint proj(Line l,Point p){\n  ld t=dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n  return l.a+t*(l.a-l.b);\n}\nld dist_lp(Line l,Point p){\n  return abs(p-proj(l,p));\n}\nld dist_ll(Line l,Line m){\n  return isis_ll(l,m) ? 0:dist_lp(l,m.a);\n}\nld dist_ls(Line l,Line s){\n  return isis_ls(l,s) ? 0 :min(dist_lp(l,s.a),dist_lp(l,s.b));\n}\nld dist_sp(Line s,Point p){\n  Point r=proj(s,p);\n  return isis_sp(s,r)?abs(r-p):min(abs(s.a-p),abs(s.b-p));\n}\nld dist_ss(Line s,Line t){\n  return min({dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b)});\n}\nstruct edge {int to; ld cost;};\nint V;\nvector<edge> G[200];\nld d[200];\nvoid init(int v){\n  for(int i=0;i<v;i++){\n    G[i].clear();\n  }\n}\ntypedef pair<ld,int> P;\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P>> que;\n  fill(d,d+V,10000);\n  d[s] = 0;\n  que.push(P{0.0,s});\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int v=p.second;\n    if(d[v]<p.first-eps)continue;\n    for(int i=0;i<(int)G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(P{d[e.to],e.to});\n      }\n    }\n  }\n}\nint main(){\n  cout<<fixed<<setprecision(6);\n  int n;int m;\n  while(cin>>n,n){\n    V=n+2;init(V);\n    vector<Point> a[100],a1[100];ld x,y;\n    vector<Line> b[100];\n    ld h;\n    ld hei[100];int num[100];\n    for(int i=0;i<n;i++){\n      cin>>m>>h;\n      num[i]=m;\n      hei[i]=h;\n      for(int j=0;j<m;j++){\n        cin>>x>>y;\n        a[i].push_back((Point){x,y});\n      }\n    }\n    ld arg1,arg2;cin>>arg1>>arg2;\n    arg1*=(pi/(ld)180.0);arg2*=(pi/(ld)180.0);\n    Point s,g;\n    cin>>x>>y;s={x,y};cin>>x>>y;g={x,y};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<num[i];j++){\n        ld nx=real(a[i][j]);\n        ld ny=imag(a[i][j]);\n        nx-=hei[i]*cos(arg1)/tan(arg2);\n        ny-=hei[i]*sin(arg1)/tan(arg2);\n        a1[i].push_back((Point){nx,ny});\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<num[i];j++){\n        Line xyz={a[i][j],a[i][(j+1)%num[i]]};\n        b[i].push_back(xyz);\n        xyz={a1[i][j],a1[i][(j+1)%num[i]]};\n        b[i].push_back(xyz);\n        xyz={a[i][j],a1[i][j]};\n        b[i].push_back(xyz);\n      }\n    }\n    Line lef={s,Point{real(s),-10000}};\n    Line rif={s,Point{real(s),10000}};\n    for(int i=0;i<n;i++){\n      ld mi=10000;\n      int len=b[i].size();\n      bool g1=false;bool g2=false;\n      for(int j=0;j<len;j++){\n        mi=min(mi,dist_sp(b[i][j],s));\n        if(isis_ss(lef,b[i][j]))g1=true;\n        if(isis_ss(rif,b[i][j]))g2=true;\n      }\n      if(g1&&g2)mi=0;\n      G[0].push_back(edge{i+1,mi});\n    }\n    G[0].push_back(edge{n+1,abs(g-s)});\n    lef={g,Point{real(g),-10000}};\n    rif={g,Point{real(g),10000}};\n    for(int i=0;i<n;i++){\n      ld mi=10000;\n      int len=b[i].size();\n      bool g1=false;bool g2=false;\n      for(int j=0;j<len;j++){\n        mi=min(mi,dist_sp(b[i][j],g));\n        if(isis_ss(lef,b[i][j]))g1=true;\n        if(isis_ss(rif,b[i][j]))g2=true;\n      }\n      if(g1&&g2)mi=0;\n      G[i+1].push_back(edge{n+1,mi});\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        int len1=b[i].size();int len2=b[j].size();\n        ld mi=10000;\n        for(int k=0;k<len1;k++){\n          for(int l=0;l<len2;l++){\n            mi=min({mi,dist_ss(b[i][k],b[j][l])});\n          }\n        }\n        G[i+1].push_back({j+1,mi});\n        G[j+1].push_back({i+1,mi});\n      }\n    }\n    dijkstra(0);\n    cout<<d[n+1]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nbool check(vector<Polygon> &polies,Segment &seg,unordered_set<int> &skip) {\n  rep(i,(int)polies.size()) {\n    if( skip.count(i) ) continue;\n    rep(j,(int)polies[i].size()) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%(int)polies[i].size()]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment seg1,Segment seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\ndouble dijkstra(vector<vector<Edge>> &G) {\n  int V = G.size();\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,vector<double> &Hs,vector<Polygon> &polies,double theta,double phi,vector<Point> &ep) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,(int)polies[i].size()) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  vector<vector<Edge>> G(2+N);\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\tunordered_set<int> skip;\n\tskip.insert(j);\n\n\trep(k,(int)polies[j].size()) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,(int)polies[j].size()) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%(int)polies[j].size()]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%(int)polies[j].size()],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      unordered_set<int> skip;\n      skip.insert(i);\n      skip.insert(j);\n      \n      rep(k,(int)polies[i].size()) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%(int)polies[i].size()]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%(int)polies[j].size()]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(G));\n  \n}\n\nint main(){\n  int N;\n  while( cin >> N, N ) {\n    vector<double> Hs(N);\n    vector<Polygon> polies(N);\n    rep(i,N) {\n      int V;\n      cin >> V >> Hs[i];\n      polies[i].resize(V);\n      rep(j,V) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    vector<Point> ep(2);\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,Hs,polies,toRad(theta),toRad(phi),ep);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n \nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n  \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n \nS getS(vecP &t,int id){\n  int n=t.size();\n  return S(t[id%n],t[(id+1)%n]);\n}\n\nint N;\nvecP A[100];\nint H[100];\ndouble dir;\ndouble inr;\ndouble G[100][100];\n\ndouble calc(int from,int to){\n  if( inPolygon(A[from],A[to][0]) )return 0.0;\n  if( inPolygon(A[to], A[from][0]) )return 0.0;\n\n  double res=1e9;\n  for(int i=0;i<(int)A[from].size();i++){\n    S s0=getS(A[from],i);\n    for(int j=0;j<(int)A[to].size();j++){\n      S s1=getS(A[to],j);\n      res=min(res, distSS(s0,s1) );\n    }\n  }\n  return res;\n}\n\ndouble calcDist(vecP &t,P p){\n  if(inPolygon(t,p))return 0.0;\n  double res=1e9;\n  for(int i=0;i<(int)t.size();i++){\n    S s=getS(t,i);\n    res=min(res, distSP(s,p) );\n  }\n  return res;\n}\n\ndouble change(double x){\n  return x/360.0 * 2.0*PI;\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      A[i].clear();\n      int v;\n      cin>>v>>H[i];\n      A[i].resize(v);\n      for(int j=0;j<v;j++){\n        int x,y;\n        cin>>x>>y;\n        A[i][j]=P(x,y);\n      }\n    }\n    cin>>dir>>inr;\n    dir=change(dir);\n    inr=change(inr);\n    \n    P base=P( -cos(dir), -sin(dir) );\n    for(int i=0;i<N;i++){\n      int size=A[i].size();\n      // R*sin(inr)=H\n      double height=H[i];\n      double R=height/sin(inr);\n      double W=Sqrt(R*R-height*height);\n      P v=base*W;\n      for(int j=0;j<size;j++){\n        P np=A[i][j]+v;\n        A[i].push_back(np);\n      }\n      A[i]=convexHull(A[i]);\n    }\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i==j)G[i][j]=0;\n        else G[i][j]=calc(i,j);\n      }\n    }\n\n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n    P si,ti;\n    int x,y;\n    cin>>x>>y;\n    si=P(x,y);\n    \n    cin>>x>>y;\n    ti=P(x,y);\n    double ans= abs(si-ti);\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        ans=min( ans, calcDist(A[i],si) + calcDist(A[j],ti) + G[i][j] );\n\n    printf(\"%.10f\\n\",ans);\n    \n  }\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#define EPS (1e-10)\n#define PI 3.141592653589793238\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n  Point operator+(Point a){return Point(x+a.x,y+a.y);}\n  Point operator-(Point a){return Point(x-a.x,y-a.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  bool operator<(const Point &p)const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment {\n  Point p1, p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;\n}\n\nInt ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4)<= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2)<= 0);\n}\n\nbool intersectSS(Segment s1, Segment s2) {\n  return intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2-s.p1, p-s.p1) < 0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2, p-s.p2) < 0.0) return abs(p-s.p2);\n  return getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n  if(intersectSS(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n             min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size() < 3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  //puts(\"OK\");\n  for(Int i=2;i<(Int)s.size();i++){\n    for(Int n=u.size();n>=2 && ccw(u[n-2],u[n-1],s[i]) != -1;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  // puts(\"OK2\");\n  for(Int i=s.size()-3;i>=0;i--){\n    for(Int n=l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])!= -1; n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  //puts(\"OK3\");\n  reverse(l.begin(),l.end());\n  for(Int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  //puts(\"OK4\");\n  return l;\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x = cos(theta) * v.x - sin(theta) * v.y;\n  res.y = sin(theta) * v.x + cos(theta) * v.y;\n  return res;\n}\n\ndouble getDistancePoP(Polygon p,Point q){\n  double res=abs(p[0]-q);\n  for(Int i=0;i<(Int)p.size();i++){\n    Segment s(p[i],p[(i+1)%p.size()]);\n    res=min(res,getDistanceSP(s,q));\n  }\n  return res;\n}\ndouble getDistancePoPo(Polygon p,Polygon q){\n  double res=abs(p[0]-q[0]);\n  for(Int i=0;i<(Int)p.size();i++){\n    Segment s(p[i],p[(i+1)%p.size()]);\n    for(Int j=0;j<(Int)q.size();j++){\n      Segment t(q[j],q[(j+1)%q.size()]);\n      res=min(res,getDistanceSS(s,t));\n    }\n  }\n  //cout<<res<<endl;\n  return res;\n}\n\n\nInt contains(Polygon g,Point p){\n  Int n=g.size();\n  bool x=0;\n  for(Int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n  }\n  return (x?2:0);\n}\n\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    Polygon p[n];\n    Int nv[n];\n    double h[n];\n    for(Int i=0;i<n;i++){\n      cin>>nv[i]>>h[i];\n      p[i].resize(nv[i]*2);\n      for(Int j=0;j<nv[i];j++) cin>>p[i][j].x>>p[i][j].y;\n    }\n    double th,phi;\n    cin>>th>>phi;\n    for(Int i=0;i<n;i++){\n      Vector dif(h[i]/tan(PI/180*phi),0);\n      dif=translate(dif,PI/180*(th+180));\n      //cout<<nv[i]<<\" \"<<p[i].size()<<endl;\n      for(Int j=0;j<nv[i];j++) p[i][j+nv[i]]=p[i][j]+dif;\n      //cout<<dif.x<<\" \"<<dif.y<<endl;\n      p[i]=andrewScan(p[i]);\n    }\n    Point s,t;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    //cout<<s.x<<\" \"<<s.y<<\" \"<<t.x<<\" \"<<t.y<<endl;\n    double inf=1e9;\n    vector<Int> used(n+2,0);\n    vector<double> dist(n+2,inf);\n\n    vector<vector<double> > e(n+2,vector<double>(n+2,inf));\n    for(Int i=0;i<n;i++){\n      for(Int j=0;j<n;j++){\n        e[i][j]=getDistancePoPo(p[i],p[j]);\n      }\n      e[n][i]=getDistancePoP(p[i],s);\n      if(contains(p[i],s)!=0) e[n][i]=0;\n      e[i][n+1]=getDistancePoP(p[i],t);\n      if(contains(p[i],t)!=0) e[i][n+1]=0;\n    }\n    e[n][n+1]=abs(s-t);\n    dist[n]=0;\n    for(Int i=0;i<n+2;i++){\n      Int v=-1;\n      for(Int j=0;j<n+2;j++){\n        if(dist[j]==inf||used[j]) continue;\n        if(v<0||dist[j]<dist[v]) v=j;\n      }\n      if(v<0) break;\n      //cout<<v<<\" \"<<dist[v]<<endl;\n      used[v]=1;\n      for(Int j=0;j<n+2;j++){\n        if(v==j) continue;\n        dist[j]=min(dist[j],dist[v]+e[v][j]);\n      }\n    }\n    \n    printf(\"%.10f\\n\",dist[n+1]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf (1e10)\n#define linf (1e16)\n#define eps (1e-5)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size())\n    if(contains(P2[j],P2[i][k])==2)return 0.0;\n  FOR(k,0,P2[j].size())\n    if(contains(P2[i],P2[j][k])==2)return 0.0;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      Segment seg2(P2[j][l],P2[j][(l+1)%P2[j].size()]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  if(contains(P2[i],p)==2)dis=0.0;\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; scanf(\"%lf%lf\",&x,&y); return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\n//vector<Line> tangent_cp(Circle c, Point p) {\n//    vector<Line> ret;\n//    Point v = c.p - p;\n//    ld d = abs(v);\n//    ld l = sqrt(norm(v) - c.r * c.r);\n//    if (isnan(l)) { return ret; }\n//    Point v1 = v * Point(l / d, c.r / d);\n//    Point v2 = v * Point(l / d, -c.r / d);\n//    ret.push_back(Line(p, p + v1));\n//    if (l < eps) return ret;\n//    ret.push_back(Line(p, p + v2));\n//    return ret;\n//}\n//// 円と円の接線\n//vector<Line> tangent_cc(Circle c1, Circle c2) {\n//    vector<Line> ret;\n//    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n//        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n//        ret = tangent_cp(c1, center);\n//    }\n//    if (abs(c1.r - c2.r) > eps) {\n//        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n//        vector<Line> nret = tangent_cp(c1, out);\n//        ret.insert(ret.end(), nret.begin(), nret.end());\n//    }\n//    else {\n//        Point v = c2.p - c1.p;\n//        v /= abs(v);\n//        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n//        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n//        ret.push_back(Line(q1, q1 + v));\n//        ret.push_back(Line(q2, q2 + v));\n//    }\n//    return ret;\n//}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nld G[110][110];\nld Hs[110];\nPolygon polys[110];\nld solve(){\n    ld res = 0;\n    for(int i = 0; i < N;i++) polys[i].clear();\n//    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; scanf(\"%d%lf\",&n,&Hs[i]);\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull(polys[i]);\n    }\n    \n    fill(*G,*G+110*110,INF);\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                if(is_in_polygon(polys[j],polys[i][k]) > 0){\n                    D = 0;\n                    break;\n                }\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n             ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = INF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    \n    \n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n//    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct Line {\npublic:\n\tPoint a, b;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn (cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint n;\nld h[100];\nvector<Point> vp[100];\nvector<Point> rvp[100];\nvector<Line> vl[100];\n\nstruct edge {\n\tint to; ld cost;\n};\nvector<edge> G[102];\nld dist[102];\n\ntypedef pair<ld, int> speP;\npriority_queue<speP, vector<speP>, greater<speP>> q;\nvoid solve() {\n\tcout << fixed << setprecision(5);\n\twhile (cin >> n, n) {\n\t\trep(i, n + 2)G[i].clear();\n\t\trep(i, n) {\n\t\t\tvl[i].clear();\n\t\t\tvp[i].clear();\n\t\t\trvp[i].clear();\n\t\t\tint l; cin >> l>>h[i]; \n\t\t\tvp[i].resize(l);\n\t\t\trep(j, l) {\n\t\t\t\tld x, y; cin >> x >> y; vp[i][j] = { x,y };\n\t\t\t}\n\t\t}\n\t\tld theta, phi; cin >> theta >> phi;\n\t\ttheta = theta * pi / 180.0;\n\t\tphi = phi * pi / 180.0;\n\t\ttheta += pi;\n\t\trep(i, n) {\n\t\t\t\n\t\t\trvp[i].resize(vp[i].size());\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tld dx = cos(theta)*rh, dy = sin(theta)*rh;\n\t\t\t\trvp[i][j] = { dx + real(vp[i][j]),dy + imag(vp[i][j]) };\n\t\t\t\tvl[i].push_back({ vp[i][j],rvp[i][j] });\n\t\t\t}\n\t\t\trep(j, vp[i].size()-1) {\n\t\t\t\tvl[i].push_back({ vp[i][j],vp[i][j + 1] });\n\t\t\t}\n\t\t\tvl[i].push_back({ vp[i][0], vp[i][vp[i].size() - 1] });\n\t\t\trep(j, vp[i].size() - 1) {\n\t\t\t\tvl[i].push_back({ rvp[i][j],rvp[i][j + 1] });\n\n\t\t\t}\n\t\t\tvl[i].push_back({ rvp[i][0],rvp[i][rvp[i].size() - 1] });\n\t\t}\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tld d = INF;\n\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\tif (isis_ss(vl[i][k], vl[j][l])) {\n\t\t\t\t\t\t\td = 0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d == 0)break;\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], vp[j][l]));\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], rvp[j][l]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (d > 0) {\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\tRep(k, vp[i].size(), vl[i].size()) {\n\t\t\t\t\t\t\tif (isis_ss(vl[i][k], vl[j][l])) {\n\t\t\t\t\t\t\t\td = 0; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d == 0)break;\n\t\t\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], vp[i][k]));\n\t\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], rvp[i][k]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d>0){\n\t\t\t\t\tRep(k, vp[i].size(), vl[i].size()) {\n\t\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\n\t\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*rep(k, vl[i].size()) {\n\t\t\t\t\trep(l, vl[j].size()) {\n\t\t\t\t\t\tif (k < vp[i].size() && l < vp[j].size())continue;\n\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tG[i].push_back({ j,d });\n\t\t\t\tG[j].push_back({ i, d });\n\t\t\t}\n\t\t}\n\t\tPoint s, g; ld x, y; cin >> x >> y; s = { x,y }; cin >> x >> y; g = { x,y };\n\t\ttheta -= pi;\n\t\tPoint ps, pg;\n\t\trep(i, n) {\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\tps = { real(s) + rh * cos(theta),imag(s) + rh * sin(theta) };\n\t\t\tpg = { real(g) + rh * cos(theta),imag(g) + rh * sin(theta) };\n\t\t\tLine ls = { s,ps };\n\t\t\tLine lg = { g,pg };\n\t\t\tbool fs = false, fg = false;\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tLine vpl = { vp[i][j],vp[i][(j + 1) % vp[i].size()] };\n\t\t\t\tif (isis_ss(ls, vpl)) {\n\t\t\t\t\tfs = true;\n\t\t\t\t}\n\t\t\t\tif (isis_ss(lg, vpl)) {\n\t\t\t\t\tfg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fs) {\n\t\t\t\tG[n].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], s));\n\t\t\t\t}\n\t\t\t\tG[n].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n,d });\n\t\t\t}\n\t\t\tif (fg) {\n\t\t\t\tG[n + 1].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n + 1,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], g));\n\t\t\t\t}\n\t\t\t\tG[n + 1].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n + 1,d });\n\t\t\t}\n\t\t}\n\t\tG[n].push_back({ n + 1,abs(g - s) });\n\t\tG[n + 1].push_back({ n,abs(g - s) });\n\t\tfill(dist, dist + n + 2, INF);\n\t\tdist[n] = 0;\n\t\tq.push({ 0,n });\n\t\twhile (!q.empty()) {\n\t\t\tspeP p = q.top(); q.pop();\n\t\t\tint id = p.second;\n\t\t\tif (p.first > dist[id])continue;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tld nd = G[id][j].cost + p.first;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tq.push({ nd,to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[n + 1] << endl;\n\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\ntypedef P point;\n\nvector<point> convex_hull(vector<point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\ntypedef vector<point> polygon;\n\nenum { OUT, ON, IN };\nint convex_contains(const polygon &P, const point &p) {\n    const int n = P.size();\n    point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n        int c = (a + b) / 2;\n        if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n            if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(P[a] - p, P[b] - p) < 0) return 0;\n    if (cross(P[a] - p, P[b] - p) > 0) return 2;\n    return 1;\n}\n\nclass Dijkstra {\n    int n;\n    vector<vector<pair<int, double>>> adj;\n    vector<double> d;\n\npublic:\n    Dijkstra(int n) : n(n), adj(n), d(n, numeric_limits<double>::infinity()) {}\n\n    void add_edge(int a, int b, double w) {\n        assert(0 <= a && a < n && 0 <= b && b < n);\n        // cerr << \"add edge (\" << a << \", \" << b << \", \" << w << \")\" << endl;\n        adj[a].emplace_back(b, w);\n        adj[b].emplace_back(a, w);\n    }\n\n    void add_arc(int a, int b, double w) {\n        assert(0 <= a && a < n && 0 <= b && b < n);\n        adj[a].emplace_back(b, w);\n    }\n\n    void run(int a) {\n        d[a] = 0;\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> que;\n        que.emplace(0, a);\n\n        while (que.size()) {\n            auto top = que.top();\n            que.pop();\n            int u = top.second;\n\n            for (auto& p : adj[u]) {\n                int v = p.first;\n                double w = p.second;\n                if (d[u] + w < d[v]) {\n                    d[v] = d[u] + w;\n                    que.emplace(d[v], v);\n                }\n            }\n        }\n    }\n\n    double dist(int a) {\n        return d[a];\n    }\n};\n\nbool EQ(double a, double b) {\n    return abs(a - b) < EPS;\n}\n\nbool GE(double a, double b) {\n    return a - b > -EPS;\n}\n\ndouble LE(double a, double b) {\n    return a - b < EPS;\n}\n\nbool intersect_1pt(const point& a, const point& b,\n                   const point& c, const point& d, point &r) {\n    double D =  cross(b - a, d - c);\n    if (EQ(D, 0)) return false;\n    double t =  cross(c - a, d - c) / D;\n    double s = -cross(a - c, b - a) / D;\n    r = a + t * (b - a);\n    return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n}\npolygon convex_intersect(const polygon &P, const polygon &Q) {\n    const int n = P.size(), m = Q.size();\n    int a = 0, b = 0, aa = 0, ba = 0;\n    enum { Pin, Qin, Unknown } in = Unknown;\n    polygon R;\n    do {\n        int a1 = (a+n-1) % n, b1 = (b+m-1) % m;\n        double C = cross(P[a] - P[a1], Q[b] - Q[b1]);\n        double A = cross(P[a1] - Q[b], P[a] - Q[b]);\n        double B = cross(Q[b1] - P[a], Q[b] - P[a]);\n        point r;\n        if (intersect_1pt(P[a1], P[a], Q[b1], Q[b], r)) {\n            if (in == Unknown) aa = ba = 0;\n            R.push_back( r );\n            in = B > 0 ? Pin : A > 0 ? Qin : in;\n        }\n        if (C == 0 && B == 0 && A == 0) {\n            if (in == Pin) { b = (b + 1) % m; ++ba; }\n            else           { a = (a + 1) % m; ++aa; }\n        } else if (C >= 0) {\n            if (A > 0) { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n            else       { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n        } else {\n            if (B > 0) { if (in == Qin) R.push_back(Q[b]); b = (b+1)%m; ++ba; }\n            else       { if (in == Pin) R.push_back(P[a]); a = (a+1)%n; ++aa; }\n        }\n    } while ( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n    if (in == Unknown) {\n        if (convex_contains(Q, P[0])) return P;\n        if (convex_contains(P, Q[0])) return Q;\n    }\n    return R;\n}\n\nbool intersectLL(const L &l, const L &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n           abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n           ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n    return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble distance(const polygon &P, const polygon &Q) {\n    polygon isec = convex_intersect(P, Q);\n    if (isec.size()) return 0;\n    double ret = 1e9;\n    for (int i = 0; i < P.size(); i++) {\n        for (int j = 0; j < Q.size(); j++) {\n            L lp = {P[i], P[(i + 1) % P.size()]};\n            L lq = {Q[j], Q[(j + 1) % Q.size()]};\n            ret = min(ret, distanceSS(lp, lq));\n        }\n    }\n    return ret;\n}\n\ndouble distance(const polygon &P, const point &p) {\n    int k = convex_contains(P, p);\n    if (k == IN || k == ON) return 0;\n    double ret = 1e9;\n    for (int i = 0; i < P.size(); i++) {\n        L l = {P[i], P[(i + 1) % P.size()]};\n        ret = min(ret, distanceSP(l, p));\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    int cnt = 0;\n    while (cin >> n) {\n        if (n == 0) break;\n        // cerr << \"Case #\" << ++cnt << endl;\n        vector<polygon> polygons;\n        vector<vector<point>> points;\n        vector<int> ks(n), hs(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ks[i] >> hs[i];\n            // cerr << \"fuga \" << ks[i] << ' ' << hs[i] << endl;\n            vector<point> ps;\n            for (int j = 0; j < ks[i]; j++) {\n                double a, b;\n                cin >> a >> b;\n                ps.push_back(point(a, b));\n            }\n            points.emplace_back(ps);\n        }\n        double theta, phi;\n        cin >> theta >> phi;\n        phi = phi / 180 * acos(-1);\n        theta = theta / 180 * acos(-1);\n        // cerr << \"tan(phi) = \" << tan(phi) << endl;\n        for (int j = 0; j < n; j++) {\n            double dx = hs[j] / tan(phi) * cos(theta), dy = hs[j] / tan(phi) * sin(theta);\n            // cerr << \"dx : \" << dx << \", dy : \" << dy << endl;\n            for (int i = 0; i < ks[j]; i++) {\n                double a = points[j][i].real(), b = points[j][i].imag();\n                points[j].push_back(point(a - dx, b - dy));\n            }\n            polygon poly = convex_hull(points[j]);\n            // cerr << \"polygon \" << j << \": \";\n            for (int i = 0; i < poly.size(); i++) {\n                // cerr << \"(\" << poly[i].real() << \", \" << poly[i].imag() << \"), \";\n            }\n            // cerr << endl;\n            polygons.emplace_back(poly);\n        }\n        // cerr << \"read polygon\" << endl;\n        double sx, sy, tx, ty;\n        cin >> sx >> sy >> tx >> ty;\n        // cerr << \"hoge\" << sx << ' ' << sy << ' ' << tx << ' ' << ty << endl;\n        Dijkstra g(n + 2);\n        g.add_edge(n, n + 1, hypot(sx - tx, sy - ty));\n        for (int i = 0; i < n; i++) {\n            g.add_edge(i, n, distance(polygons[i], point(sx, sy)));\n            g.add_edge(i, n + 1, distance(polygons[i], point(tx, ty)));\n        }\n        // cerr << \"piyo\" << endl;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                g.add_edge(i, j, distance(polygons[i], polygons[j]));\n            }\n        }\n        // cerr << \"added edge\" << endl;\n        g.run(n);\n        printf(\"%.10f\\n\", g.dist(n + 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nP unit(const P &p){\n    return p/abs(p);\n}\nP rotate(const P &p, double rad){\n    return p *P(cos(rad), sin(rad));\n}\n\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\ndouble distanceLP(const L &l, const P &p) {\n    return abs(cross(l[1]-l[0], p-l[0])) /abs(l[1]-l[0]);\n}\ndouble distanceSP(const L &s, const P &p) {\n    if(dot(s[1]-s[0], p-s[0]) < EPS) return abs(p-s[0]);\n    if(dot(s[0]-s[1], p-s[1]) < EPS) return abs(p-s[1]);\n    return distanceLP(s, p);\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = -ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    int n = v.size();\n    sort(v.begin(), v.end());\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<VP> poly(n);\n        vector<double> h(n);\n        for(int i=0; i<n; i++){\n            int nv;\n            cin >> nv >> h[i];\n            poly[i].resize(2*nv);\n            for(int j=0; j<nv; j++){\n                double x,y;\n                cin >> x >> y;\n                poly[i][j] = P(x, y);\n            }\n        }\n\n        double theta, phi;\n        cin >> theta >> phi;\n        P dir = rotate(P(-1, 0), theta/180 *PI) /tan(phi/180 *PI);\n        vector<VP> con(n);\n        for(int i=0; i<n; i++){\n            int nv = poly[i].size()/2;\n            for(int j=0; j<nv; j++){\n                poly[i][nv +j] = poly[i][j] +h[i]*dir;\n            }\n            con[i] = convex(poly[i]);\n        }\n        \n        double sx,sy,gx,gy;\n        cin >> sx >> sy >> gx >> gy;\n        P s(sx, sy), g(gx, gy);\n        vector<vector<double> > adj(n+2, vector<double>(n+2, INF));\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                double dist = INF;\n                int ni = con[i].size();\n                int nj = con[j].size();\n                for(int k=0; k<ni; k++){\n                    for(int l=0; l<nj; l++){\n                        dist = min(dist, distanceSS(L(con[i][k], con[i][(k+1)%ni]), L(con[j][l], con[j][(l+1)%nj])));\n                    }\n                }\n                adj[i][j] = adj[j][i] = dist;\n            }\n            double sdist = INF, gdist = INF;\n            int ni = con[i].size();\n            for(int j=0; j<ni; j++){\n                sdist = min(sdist, distanceSP(L(con[i][j], con[i][(j+1)%ni]), s));\n                gdist = min(gdist, distanceSP(L(con[i][j], con[i][(j+1)%ni]), g));\n            }\n            if(in_poly(s, con[i]) >= 0) sdist = 0;\n            if(in_poly(g, con[i]) >= 0) gdist = 0;\n            adj[n][i] = adj[i][n] = sdist;\n            adj[n+1][i] = adj[i][n+1] = gdist;\n        }\n        adj[n][n+1] = min(adj[n][n+1], abs(s-g));\n        adj[n+1][n] = min(adj[n+1][n], abs(s-g));\n\n        for(int k=0; k<n+2; k++){\n            for(int i=0; i<n+2; i++){\n                for(int j=0; j<n+2; j++){\n                    adj[i][j] = min(adj[i][j], adj[i][k] +adj[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(10);\n        cout << adj[n][n+1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define REP(i, m, n) for (int i = (int)m; i < (int)n; i++)\n#define rep(i, n) REP(i, 0, n)\n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing Real = double;\nusing Point = complex<Real>;\nconstexpr Real EPS = 1e-8;\nconstexpr Real PI = acos(-1.0);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d)\n{\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p)\n{\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n  return os << fixed << setprecision(20) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\ninline Point rotate(Real theta, const Point &p)\n{\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r)\n{\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d)\n{\n  return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c)\n{\n  const Point v(a - b), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta)\n    swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std\n{\n  bool operator<(const Point &a, const Point &b)\n  {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n} // namespace std\n\nstruct Line\n{\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if (eq(A, 0))\n      a = Point(0, C / B), b = Point(1, C / B);\n    else if (eq(B, 0))\n      b = Point(C / A, 0), b = Point(C / A, 1);\n    else\n      a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p)\n  {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a)\n  {\n    return is >> a.a >> a.b;\n  }\n};\n\nvoid parameter(const Line &l, Real &A, Real &B, Real &C) // Ax + By = C\n{\n  A = imag(l.b) - imag(l.a);\n  B = real(l.a) - real(l.b);\n  C = real(l.a) * A + imag(l.a) * B;\n}\n\nstruct Segment : Line\n{\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle\n{\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\ninline Real cross(const Point &a, const Point &b)\n{\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ninline Real dot(const Point &a, const Point &b)\n{\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// 直線がx軸となす角 [0, π)\n// to do: verify\ninline Real get_angle(const Line &l)\n{\n  Real A, B, C;\n  parameter(l, A, B, C);\n  if (fabs(A) < EPS)\n    return PI / 2.0;\n  Real theta = atan(B / A);\n  return theta < 0 ? theta + PI : theta;\n}\n\n// 2直線がなす角 [0, π/2]\n// to do: verify\ninline Real get_angle(const Line &l1, const Line &l2)\n{\n  Real theta = get_angle(l1) - get_angle(l2);\n  if (theta < 0)\n    theta += PI;\n  return theta >= PI / 2.0 ? theta - PI / 2.0 : theta;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const Point &a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS)\n    return +1; // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS)\n    return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0)\n    return +2; // \"ONLINE_BACK\"\n  if (norm(b) < norm(c))\n    return -2; // \"ONLINE_FRONT\"\n  return 0;    // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行判定\ninline bool parallel(const Line &a, const Line &b)\n{\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 垂直判定\ninline bool orthogonal(const Line &a, const Line &b)\n{\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\n// 射影\n// 直線 l に p から垂線を引いた交点を求める\ninline Point projection(const Line &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\ninline Point projection(const Segment &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\n// 反射\n// 直線 l を対称軸として点 p  と線対称にある点を求める\ninline Point reflection(const Line &l, const Point &p)\n{\n  return p + (projection(l, p) - p) * 2.0;\n}\n\n// pを通りlに垂直な直線\ninline Line verticalline(const Line &l, const Point &p)\n{\n  Real a = imag(l.b) - imag(l.a);\n  Real b = real(l.a) - real(l.b);\n  return Line(b, -a, a * imag(p) - b * real(p));\n}\n\ninline bool intersect(const Line &l, const Point &p)\n{\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\ninline bool intersect(const Line &l, const Line &m)\n{\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const Segment &s, const Point &p)\n{\n  return ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const Line &l, const Segment &s)\n{\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline Real distance(const Line &l, const Point &p);\n\ninline bool intersect(const Circle &c, const Line &l)\n{\n  return distance(l, c.p) <= c.r + EPS;\n}\n\ninline bool intersect(const Circle &c, const Point &p)\n{\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t)\n{\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l)\n{\n  if (norm(projection(l, c.p) - c.p) - c.r * c.r > EPS)\n    return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS)\n    return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS)\n    return 1;\n  const Point h = projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0)\n    return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2)\n{\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if (c1.r + c2.r < d)\n    return 4;\n  if (eq(c1.r + c2.r, d))\n    return 3;\n  if (c1.r - c2.r < d)\n    return 2;\n  if (eq(c1.r - c2.r, d))\n    return 1;\n  return 0;\n}\n\ninline Real distance(const Point &a, const Point &b)\n{\n  return abs(a - b);\n}\n\ninline Real distance(const Line &l, const Point &p)\n{\n  return abs(p - projection(l, p));\n}\n\ninline Real distance(const Line &l, const Line &m)\n{\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ninline Real distance(const Segment &s, const Point &p)\n{\n  Point r = projection(s, p);\n  if (intersect(s, r))\n    return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b)\n{\n  if (intersect(a, b))\n    return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s)\n{\n  if (intersect(l, s))\n    return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if (eq(abs(A), 0.0) && eq(abs(B), 0.0))\n    return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair<Point, Point> crosspoint(const Circle &c, const Line l)\n{\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if (eq(distance(l, c.p), c.r))\n    return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair<Point, Point> crosspoint(const Circle &c, const Segment &l)\n{\n  Line aa = Line(l.a, l.b);\n  if (intersect(c, l) == 2)\n    return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2)\n{\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\n// 点 p を通る円 c の接線\npair<Point, Point> tangent(const Circle &c1, const Point &p2)\n{\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\n// 円 c1, c2 の共通接線\nLines tangent(Circle c1, Circle c2)\n{\n  Lines ret;\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if (eq(g, 0))\n    return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for (int s : {-1, 1})\n  {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if (eq(1 - h * h, 0))\n    {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    }\n    else if (1 - h * h > 0)\n    {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\n// 凸性判定\nbool is_convex(const Polygon &p)\n{\n  int n = (int)p.size();\n  for (int i = 0; i < n; i++)\n  {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1)\n      return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\n// 凸包\nPolygon convex_hull(Polygon &p)\n{\n  int n = (int)p.size(), k = 0;\n  if (n <= 2)\n    return p;\n  sort(p.begin(), p.end());\n  vector<Point> ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = p[i++])\n  {\n    while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS)\n      --k;\n  }\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--])\n  {\n    while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS)\n      --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n// 多角形と点の包含判定\nenum\n{\n  OUT,\n  ON,\n  IN\n};\n\nint contains(const Polygon &Q, const Point &p)\n{\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++)\n  {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag())\n      swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0)\n      in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0)\n      return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble theta;\nvoid update(Polygon &p, double k)\n{\n  int sz = p.size();\n  rep(i, sz)\n  {\n    Point q = p[i] - Point(cos(theta) * k, sin(theta) * k);\n    p.push_back(q);\n  }\n  p = convex_hull(p);\n}\n\nReal distance(const Polygon &p, const Point &a)\n{\n  if (contains(p, a) != OUT)\n    return 0;\n  Real Min = 4e18;\n  int sz = p.size();\n  rep(i, sz)\n  {\n    Segment sg(p[i], p[(i + 1) % sz]);\n    Min = min(Min, distance(sg, a));\n  }\n  return Min;\n}\n\nReal distance(const Polygon &p1, const Polygon &p2)\n{\n  int sz1 = p1.size(), sz2 = p2.size();\n  Real Min = 4e18;\n  rep(i, sz1)\n  {\n    if (contains(p2, p1[i]) != OUT)\n      return 0;\n  }\n  rep(i, sz2)\n  {\n    if (contains(p1, p2[i]) != OUT)\n      return 0;\n  }\n  rep(i, sz1) rep(j, sz2)\n  {\n    Segment sg1(p1[i], p1[(i + 1) % sz1]), sg2(p2[j], p2[(j + 1) % sz2]);\n    Min = min(Min, distance(sg1, sg2));\n  }\n  return Min;\n}\n\ntemplate <typename T>\nstruct dijkstra\n{\n  int V;\n  T INF_d;\n  struct edge\n  {\n    int to;\n    T cost;\n  };\n  vector<vector<edge>> E;\n  vector<T> d;\n  using pt = pair<T, int>;\n  dijkstra(int V_) : V(V_)\n  {\n    E.resize(V);\n    d.resize(V);\n    INF_d = 4e18;\n  }\n\n  void add_E(int a, int b, T c = 1, bool directed = true)\n  {\n    E[a].emplace_back(edge{b, c});\n    if (!directed)\n      E[b].emplace_back(edge{a, c});\n  }\n\n  void calc(int s)\n  {\n    priority_queue<pt, vector<pt>, greater<pt>> que;\n    fill(d.begin(), d.end(), INF_d);\n    que.emplace(T(0), s);\n    d[s] = 0;\n    while (!que.empty())\n    {\n      pt p = que.top();\n      que.pop();\n      int v = p.second;\n      if (d[v] < p.first)\n        continue;\n      for (auto &&e : E[v])\n      {\n        if (d[e.to] > d[v] + e.cost)\n        {\n          d[e.to] = d[v] + e.cost;\n          que.emplace(d[e.to], e.to);\n        }\n      }\n    }\n  }\n};\n\nvoid solve(int n)\n{\n  vector<Polygon> v(n);\n  vector<double> h(n);\n  rep(i, n)\n  {\n    int p;\n    cin >> p;\n    cin >> h[i];\n    rep(pi, p)\n    {\n      Real x, y;\n      cin >> x >> y;\n      v[i].push_back(Point(x, y));\n    }\n  }\n  double phi;\n  cin >> theta >> phi;\n  theta = theta * PI / 180.0;\n  phi = phi * PI / 180.0;\n  vector<double> k(n);\n  rep(i, n) k[i] = h[i] / tan(phi);\n  rep(i, n) update(v[i], k[i]);\n  dijkstra<double> ds(n + 2);\n  double sx, sy, gx, gy;\n  cin >> sx >> sy >> gx >> gy;\n  Point start(sx, sy), goal(gx, gy);\n  rep(i, n) REP(j, i + 1, n)\n  {\n    double d = distance(v[i], v[j]);\n    ds.add_E(i, j, d, false);\n  }\n  rep(i, n)\n  {\n    double d = distance(v[i], start);\n    ds.add_E(i, n, d, false);\n  }\n  rep(i, n)\n  {\n    double d = distance(v[i], goal);\n    ds.add_E(i, n + 1, d, false);\n  }\n  ds.add_E(n, n + 1, distance(start, goal), false);\n\n  ds.calc(n);\n  cout << ds.d[n + 1] << \"\\n\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n  while (1)\n  {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct Line {\npublic:\n\tPoint a, b;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n\n\n\t//if (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn (cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint n;\nld h[100];\nvector<Point> vp[100];\nvector<Point> rvp[100];\nvector<Line> vl[100];\n\nstruct edge {\n\tint to; ld cost;\n};\nvector<edge> G[102];\nld dist[102];\n\ntypedef pair<ld, int> speP;\npriority_queue<speP, vector<speP>, greater<speP>> q;\nvoid solve() {\n\tcout << fixed << setprecision(5);\n\twhile (cin >> n, n) {\n\t\trep(i, n + 2)G[i].clear();\n\t\trep(i, n) {\n\t\t\tvl[i].clear();\n\t\t\tvp[i].clear();\n\t\t\trvp[i].clear();\n\t\t\tint l; cin >> l>>h[i]; \n\t\t\tvp[i].resize(l);\n\t\t\trep(j, l) {\n\t\t\t\tld x, y; cin >> x >> y; vp[i][j] = { x,y };\n\t\t\t}\n\t\t}\n\t\tld theta, phi; cin >> theta >> phi;\n\t\ttheta = theta * pi / 180.0;\n\t\tphi = phi * pi / 180.0;\n\t\ttheta += pi;\n\t\trep(i, n) {\n\t\t\t\n\t\t\trvp[i].resize(vp[i].size());\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tld dx = cos(theta)*rh, dy = sin(theta)*rh;\n\t\t\t\trvp[i][j] = { dx + real(vp[i][j]),dy + imag(vp[i][j]) };\n\t\t\t\tvl[i].push_back({ vp[i][j],rvp[i][j] });\n\t\t\t}\n\t\t\trep(j, vp[i].size()-1) {\n\t\t\t\tvl[i].push_back({ vp[i][j],vp[i][j + 1] });\n\t\t\t}\n\t\t\tvl[i].push_back({ vp[i][0], vp[i][vp[i].size() - 1] });\n\t\t\trep(j, vp[i].size() - 1) {\n\t\t\t\tvl[i].push_back({ rvp[i][j],rvp[i][j + 1] });\n\n\t\t\t}\n\t\t\tvl[i].push_back({ rvp[i][0],rvp[i][rvp[i].size() - 1] });\n\t\t}\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tld d = INF;\n\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\tif (isis_ss(vl[i][k], vl[j][l])) {\n\t\t\t\t\t\t\td = 0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d == 0)break;\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], vp[j][l]));\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], rvp[j][l]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (d > 0) {\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\tRep(k, vp[i].size(), vl[i].size()) {\n\t\t\t\t\t\t\tif (isis_ss(vl[i][k], vl[j][l])) {\n\t\t\t\t\t\t\t\td = 0; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d == 0)break;\n\t\t\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], vp[i][k]));\n\t\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], rvp[i][k]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(d>0){\n\t\t\t\t\tRep(k, vp[i].size(), vl[i].size()) {\n\t\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\n\t\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*rep(k, vl[i].size()) {\n\t\t\t\t\trep(l, vl[j].size()) {\n\t\t\t\t\t\tif (k < vp[i].size() && l < vp[j].size())continue;\n\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tG[i].push_back({ j,d });\n\t\t\t\tG[j].push_back({ i, d });\n\t\t\t}\n\t\t}\n\t\tPoint s, g; ld x, y; cin >> x >> y; s = { x,y }; cin >> x >> y; g = { x,y };\n\t\ttheta -= pi;\n\t\tPoint ps, pg;\n\t\trep(i, n) {\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\tps = { real(s) + rh * cos(theta),imag(s) + rh * sin(theta) };\n\t\t\tpg = { real(g) + rh * cos(theta),imag(g) + rh * sin(theta) };\n\t\t\tLine ls = { s,ps };\n\t\t\tLine lg = { g,pg };\n\t\t\tbool fs = false, fg = false;\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tLine vpl = { vp[i][j],vp[i][(j + 1) % vp[i].size()] };\n\t\t\t\tif (isis_ss(ls, vpl)) {\n\t\t\t\t\tfs = true;\n\t\t\t\t}\n\t\t\t\tif (isis_ss(lg, vpl)) {\n\t\t\t\t\tfg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fs) {\n\t\t\t\tG[n].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], s));\n\t\t\t\t}\n\t\t\t\tG[n].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n,d });\n\t\t\t}\n\t\t\tif (fg) {\n\t\t\t\tG[n + 1].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n + 1,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], g));\n\t\t\t\t}\n\t\t\t\tG[n + 1].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n + 1,d });\n\t\t\t}\n\t\t}\n\t\tG[n].push_back({ n + 1,abs(g - s) });\n\t\tG[n + 1].push_back({ n,abs(g - s) });\n\t\tfill(dist, dist + n + 2, INF);\n\t\tdist[n] = 0;\n\t\tq.push({ 0,n });\n\t\twhile (!q.empty()) {\n\t\t\tspeP p = q.top(); q.pop();\n\t\t\tint id = p.second;\n\t\t\tif (p.first > dist[id])continue;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tld nd = G[id][j].cost + p.first;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tq.push({ nd,to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[n + 1] << endl;\n\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon &poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nint N,VN[110];\ndouble Hs[110];\nPolygon polies[110];\nPoint ep[2];\n\nbool check(Segment &seg,unordered_set<int> &skip) {\n  rep(i,N) {\n    if( skip.count(i) ) continue;\n    rep(j,VN[i]) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%VN[i]]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment &seg1,Segment &seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\ndouble dijkstra(vector<vector<Edge>> &G) {\n  int V = G.size();\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,double theta,double phi) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,VN[i]) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    VN[i] = (int)polies[i].size();\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  vector<vector<Edge>> G(2+N);\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\tunordered_set<int> skip;\n\tskip.insert(j);\n\n\trep(k,VN[j]) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,VN[j]) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%VN[j]]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%VN[j]],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      unordered_set<int> skip;\n      skip.insert(i);\n      skip.insert(j);\n      \n      rep(k,VN[i]) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%VN[i]]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%VN[j]]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(G));\n  \n}\n\nint main(){\n  while( cin >> N, N ) {\n    rep(i,N) {\n      cin >> VN[i] >> Hs[i];\n      polies[i].resize(VN[i]);\n      rep(j,VN[i]) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,toRad(theta),toRad(phi));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return -1;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size())\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  FOR(k,0,P2[j].size())\n    if(contains(P2[i],P2[j][k])!=0)return 0.0;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      Segment seg2(P2[j][l],P2[j][(l+1)%P2[j].size()]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P2[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(0,0),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,0,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-10)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return d[n+1];\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  int size1=P2[i].size(),size2=P2[j].size();\n  FOR(k,0,size1)\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  FOR(k,0,size2)\n    if(contains(P2[i],P2[j][k])!=0)return 0.0;\n  FOR(k,0,size1){\n    Segment seg1(P2[i][k],P2[i][(k+1)%size1]);\n    FOR(l,0,size2){\n      Segment seg2(P2[j][l],P2[j][(l+1)%size2]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P2[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\nvector<Point> uni(vector<Point> p){\n  sort(all(p));\n  vector<Point> res;\n  res.pb(p[0]);\n  FOR(i,1,p.size())\n    if(!(res[res.size()-1]==p[i]))\n      res.pb(p[i]);\n  return res;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b*pi/180.0);\n    Vector v=Point(-cos(a*pi/180.0),-sin(a*pi/180.0))*dis;\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(uni(temp));\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep2(i, a, n) for(int i = a; i <= n; ++i)\n#define rep(i, n) rep2(i, 0, n - 1)\n\nusing Real = double;\nusing Point = complex<Real>;\nistream &operator>>(istream &is, Point &p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n#define x real()\n#define y imag()\nostream &operator<<(ostream &os, Point &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nconst Real EPS = 1e-8, PI = acos(-1);\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\nnamespace std {\nbool operator<(const Point &a, const Point &b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\n} // namespace std\nPoint operator*(const Point &p, const Real &d) { return Point(p.x * d, p.y * d); }\nstruct Segment {\n    Point a, b;\n    Segment() = default;\n    Segment(Point a, Point b) : a(a), b(b) {}\n};\nReal dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\nReal cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\nPoint proj(const Segment &l, const Point &p) {\n    Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\nbool intersect(const Segment &s, const Segment &t) { return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; }\nReal Dist(const Point &p, const Segment &s) {\n    Point r = proj(s, p);\n    if(intersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\nReal Dist(const Segment &s, const Point &p) { return Dist(p, s); }\nReal Dist(const Segment a, const Segment b) {\n    if(intersect(a, b)) return 0;\n    return min({Dist(a, b.a), Dist(a, b.b), Dist(b, a.a), Dist(b, a.b)});\n}\n\nusing Polygon = vector<Point>;\nostream &operator<<(ostream &os, Polygon p) {\n    rep(i, p.size()) os << p[i] << \" \";\n    return os;\n}\nPolygon convexHull(Polygon &p) {\n    int n = p.size(), k = 0;\n    if(n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 and cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n    }\n    for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t and cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\nint contains(const Polygon &Q, const Point &p) {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if(a.y > b.y) swap(a, b);\n        if(a.y <= 0 and 0 < b.y and cross(a, b) < 0) in = !in;\n        if(cross(a, b) == 0 and dot(a, b) <= 0) return 1;\n    }\n    return in;\n}\nReal D(Polygon a, Polygon b) {\n    int n = a.size(), m = b.size();\n    double d = 1e18;\n    rep(i, n) if(contains(b, a[i])) return (Real)0;\n    rep(i, m) if(contains(a, b[i])) return (Real)0;\n    rep(i, n) {\n        rep(j, m) { d = min(d, Dist(Segment(a[i], a[(i + 1) % n]), Segment(b[j], b[(j + 1) % m]))); }\n    }\n    rep(i, n) rep(j, m) d = min(d, Dist(Segment(a[i], a[(i + 1) % n]), b[j])), d = min(d, Dist(Segment(b[j], b[(j + 1) % m]), a[i]));\n    rep(i, n) rep(j, m) d = min(d, abs(a[i] - b[j]));\n    return d;\n}\nmain() {\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    int n;\n    while(1) {\n        cin >> n;\n        if(!n) return 0;\n        vector<Polygon> P(n), Q(n);\n        vector<double> H(n);\n        rep(i, n) {\n            int v;\n            cin >> v;\n            cin >> H[i];\n            P[i].resize(v);\n            rep(j, v) cin >> P[i][j];\n        }\n        double theta, phi;\n        cin >> theta >> phi;\n        theta *= PI * 2, phi *= PI * 2;\n        theta /= 360, phi /= 360;\n        rep(i, n) {\n            int v = P[i].size();\n            double r = H[i] / tan(phi);\n            Point p(r * cos(theta + PI), r * sin(theta + PI));\n            rep(j, v) { P[i].emplace_back(P[i][j] + p); }\n            P[i] = convexHull(P[i]);\n        }\n        vector<vector<Real>> d(n + 2, vector<Real>(n + 2, 1e18));\n        Point s, t;\n        cin >> s >> t;\n        P.emplace_back(Polygon{s}), P.emplace_back(Polygon{t});\n        rep(i, n + 2) rep(j, n + 2) {\n            if(i <= j) continue;\n            d[i][j] = d[j][i] = D(P[i], P[j]);\n        }\n        rep(k, n + 2) rep(i, n + 2) rep(j, n + 2) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); }\n        cout << d[n][n + 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-6)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      Segment seg2(P2[j][l],P2[j][(l+1)%P2[j].size()]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      double dis=min(getdis(i,j),getdis(j,i));\n      add_edge(i,j,dis);\n      add_edge(j,i,dis);\n    }\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      Segment seg(P2[i][j],P2[i][(j+1)%P2[i].size()]);\n      dis=min(dis,getDistanceSP(seg,s));\n    }\n    if(contains(P2[i],s)!=0)dis=0.0;\n    add_edge(n,i,dis);\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      Segment seg(P2[i][j],P2[i][(j+1)%P2[i].size()]);\n      dis=min(dis,getDistanceSP(seg,t));\n    }\n    if(contains(P2[i],t)!=0)dis=0.0;\n    add_edge(i,n+1,dis);\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return d[n+1];\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  int size1=P[i].size();\n  int size2=P[j].size();\n  FOR(k,0,size1)\n    if(contains(P[j],P[i][k])!=0)return 0.0;\n  FOR(l,0,size2)\n    if(contains(P[i],P[j][l])!=0)return 0.0;\n  FOR(k,0,size1){\n    Segment seg1(P[i][k],P[i][(k+1)%size1]);\n    FOR(l,0,size2){\n      Segment seg2(P[j][l],P[j][(l+1)%size2]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P[i].size();\n  FOR(j,0,m){\n    Segment seg(P[i][j],P[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b*pi/180.0);\n    Vector v=Point(-cos(a*pi/180.0),-sin(a*pi/180.0));\n    v=v*dis;\n    Polygon temp=P[i];\n    FOR(j,0,P[i].size())temp.pb(P[i][j]+v);\n    P[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i+1,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  add_edge(n,n+1,abs(s-t));\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst double EPS = 1e-10;\nconst double PI = 3.141592653589793;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) const { return Point(a * x, a * y); }\n\tPoint operator / (double a) const { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>; // ????§???¢\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\nPoint rotationalTransfer(Point c, double r, double deg) { // c???????????¨????????????r????????¨??????deg??????????????§?¨?\n\tdouble rad = PI * deg / 180.0; return c + Point(cos(rad), sin(rad)) * r;\n}\n// (x, y, z) ???????????????(xy??§?¨???§????§???????theta???, xy?????¢??????z?????????????§???????phi????????????)??????????????????????????±???xy??§?¨?\nPoint Shadow(double x, double y, double z, double theta, double phi) {\n\ttheta = PI * theta / 180.0, phi = PI * phi / 180.0;\n\treturn Point(x - z / tan(phi) * cos(theta), y - z / tan(phi) * sin(theta));\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????§???¢ ***\n// IN := 2, ON := 1, OUT := 0\nvector<Segment> getPolygonSegument(const Polygon& p) { //????§???¢????????????????§???¢??????????±???????\n\tvector<Segment> ret;\n\trep(i, p.size() - 1) ret.push_back(Segment(p[i], p[i + 1]));\n\tret.push_back(Segment(p[p.size() - 1], p[0]));\n\treturn ret;\n}\nint contains(const Polygon& g, const Point& p){ // ????§???¢g????????????p????????????????????????\n\tint n = g.size(); bool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif ( abs(cross(a, b)) < EPS && dot(a, b) < EPS ) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) { // ??????(??????????????????????????????)\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end()); // x, y???????????????????????????\n\t// x????°???????????????????2??? u ?????????\n\tu.push_back(s[0]), u.push_back(s[1]);\n\t// x ?????§??????????????????2???1?????????\n\tl.push_back(s[s.size() - 1]), l.push_back(s[s.size() - 2]);\n\t// ??????????????¨?????????\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t// ??????????????¨?????????\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t// ????¨????????????????????????????????????????????????????\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) { // ???????????????????????¨??????????????????????????????????????¨\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(const Segment& s1, const Segment& s2) { // ??????s1??¨??????s2?????????\n\tif( intersect(s1, s2) ) return 0.0; //????????£???????????¨???\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\ndouble getDistancePolP(const Polygon& pol, const Point& p) { // ????§???¢pol??¨???p????????¢\n\tif(contains(pol, p) != 0) return 0.0; // ??????????§???¢????????¨?????????????????????\n\tdouble ret = 1e9;\n\tfor(Segment& u : getPolygonSegument(pol)) ret = min(ret, getDistanceSP(u, p));\n\treturn ret;\n}\ndouble getDistancePolPol(const Polygon& p1, const Polygon& p2) { // ????§???¢p1??¨p2????????¢\n\tfor(const Point& p : p1) if(contains(p2, p) != 0) return 0.0; // p1?????????????§???¢p2???????????????????????????\n\tfor(const Point& p : p2) if(contains(p1, p) != 0) return 0.0; // p2?????????????§???¢p1???????????????????????????\n\tdouble ret = 1e9;\n\tfor(const Segment& u : getPolygonSegument(p1))for(const Segment& v : getPolygonSegument(p2)) {\n\t\tret = min(ret, getDistanceSS(u, v));\n\t}\n\treturn ret;\n}\n\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\n\nconst int MAX_N = 210;\nusing TYPE = double; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\n\nint main(void) {\n\t\n\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tint NV[110], H[110];\n\t\tvector<vector<pair<double, double>>> p;\n\t\trep(i, N){\n\t\t\tscanf(\"%d %d\", &NV[i], &H[i]);\n\t\t\tvector<pair<double, double>> tmp;\n\t\t\trep(j, NV[i]){\n\t\t\t\tdouble x, y; scanf(\"%lf %lf\", &x, &y);\n\t\t\t\ttmp.pb(mp(x, y));\n\t\t\t}\n\t\t\tp.pb(tmp);\n\t\t}\n\t\tdouble theta, phi; scanf(\"%lf %lf\", &theta, &phi);\n\t\tdouble Sx, Sy, Tx, Ty; scanf(\"%lf %lf %lf %lf\", &Sx, &Sy, &Tx, &Ty);\n\t\tPoint start(Sx, Sy), goal(Tx, Ty);\n\n\t\tvector<Polygon> v;\n\t\trep(i, N){\n\t\t\tPolygon t;\n\t\t\tfor(auto u : p[i]) t.pb(Shadow(u.fi, u.se, H[i], theta, phi));\n\t\t\tfor(auto u : p[i]) t.pb(Point(u.fi, u.se));\n\t\t\tPolygon tt = andrewScan(t);\n\t\t\tv.pb(tt);\n\t\t}\n\n\t\t/*\n\t\tfor(auto u : v) {\n\t\t\tfor(auto k : u) printf(\"%f %f, \", k.x, k.y);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\t\n\n\t\trep(i, MAX_N) G[i].clear();\n\n\t\trep(i, v.size())rep(j, v.size()){\n\t\t\tif(i == j) continue;\n\t\t\tint s = i + 1, t = j + 1;\n\t\t\tauto dis = getDistancePolPol(v[i], v[j]);\n\t\t\tG[s].pb(mp(t, dis)), G[t].pb(mp(s, dis));\n\t\t}\n\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], start);\n\t\t\tG[0].pb(mp(i + 1, dis)), G[i + 1].pb(mp(0, dis));\n\t\t}\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], goal);\n\t\t\tG[N + 1].pb(mp(i + 1, dis)), G[i + 1].pb(mp(N + 1, dis));\n\t\t}\n\n\t\tauto ret = dijkstra(0);\n\t\tprintf(\"%.9f\\n\", ret[N + 1]);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-8; //??´??°???????????????\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\n//???????¨???????\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > P_eps) return 1; //COUNTER_CLOCKWISE\n  if(cross(b-a,c-a) < -P_eps) return -1; //CLOCKWISE\n  if(dot(b-a,c-a) < P_eps) return -2; //c -> a -> b\n  if(dot(a-b,c-b) < P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n/* ??????ab??¨???c????????¢ */\ndouble distanceSP(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nbool iscontained(vector<P> &g, P p){\n  int n = g.size();\n  bool f = false;\n  for(int i=0;i<n;i++){\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(abs(cross(a,b)) < P_eps && dot(a,b) < P_eps) return true;\n    if(a.imag() > b.imag()) swap(a,b);\n    if(a.imag() < P_eps && P_eps < b.imag() && cross(a,b) > P_eps) f = !f;\n  }\n  return f;\n}\n\n/* ConvexHull(??????) */\n\nvector<P> ConvexHull(vector<P> s){\n  vector<P> g;\n  int n = (int)s.size();\n  \n  if(n<3) return s;\n  \n  sort(s.begin(),s.end());\n  \n  for(int i=0;i<n;i++){\n    for(int m = (int)g.size();m>=2 && ccw(g[m-2],g[m-1],s[i]) != -1; m--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  \n  int t = (int)g.size();\n  \n  for(int i=n-2;i>=0;i--){\n    for(int m = (int)g.size();m>t && ccw(g[m-2],g[m-1],s[i]) != -1; m--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  \n  reverse(g.begin(),g.end());\n  g.pop_back();\n  \n  return g;\n}\n\n\nbool solve(){  \n  int n;\n  int h[SIZE];\n  int theta, phi;\n  int sx,sy,gx,gy;\n  vector<P> shade[1000];\n  vector<P> points[1000];\n  \n  scanf(\"%d\",&n);\n  \n  if(n == 0) return false;\n  \n  for(int i=0;i<n;i++){\n    int nv;\n    scanf(\"%d%d\",&nv,h+i);\n    \n    for(int j=0;j<nv;j++){\n      int x,y;\n      scanf(\"%d%d\",&x,&y);\n      points[i].push_back(P(x,y));\n    }\n  }\n\n  scanf(\"%d%d\",&theta, &phi);\n  scanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\n  P start(sx,sy), goal(gx,gy);\n  \n  for(int i=0;i<n;i++){\n\n    double dist_sa = h[i] / tan(phi / 180.0 * M_PI); \n    P sa = P(cos((theta + 180) / 180.0 * M_PI), sin((theta + 180) / 180.0 * M_PI));\n    sa *= dist_sa;\n    \n    int m = points[i].size();\n    \n    for(int j=0;j<m;j++){\n\n      P sp = sa + points[i][j];\n      \n      points[i].push_back(sp);\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    shade[i] = ConvexHull(points[i]);\n  }\n  shade[n].push_back(start);\n  shade[n+1].push_back(goal);\n  \n  double dist[SIZE][SIZE];\n\n  for(int i=0;i<n+2;i++){\n    for(int j=0;j<n+2;j++){\n      dist[i][j] = 1e18;\n    }\n  }\n  \n  for(int i=0;i<n+2;i++){\n    int m = shade[i].size();\n\n    for(int j=0;j<n+2;j++){\n      for(int k=0;k<shade[i].size();k++){\n        for(int l=0;l<shade[j].size();l++){\n          double res = distanceSP(shade[i][k],shade[i][(k+1)%m],shade[j][l]);\n          dist[i][j] = dist[j][i] = min(dist[j][i],res);\n        }\n      } \n    }\n  }\n\n  for(int i=0;i<n+2;i++){\n    for(int j=0;j<n+2;j++){\n      for(int k=0;k<shade[j].size();k++){\n        if(iscontained(shade[i],shade[j][k])){\n          dist[j][i] = dist[i][j] = 0;\n        }\n      }\n    }\n  }\n\n  for(int k=0;k<n+2;k++){\n    for(int i=0;i<n+2;i++){\n      for(int j=0;j<n+2;j++){\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n    }\n  }\n\n  printf(\"%.10lf\\n\",dist[n][n+1]);\n  \n  return true;\n}\n\nint main(){\n  \n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst double EPS = 1e-10;\nconst double PI = 3.141592653589793;\ntemplate<class T> bool eq(T a, T b){ return abs(a - b) < EPS; }\n\nclass Point { // ???\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0):x(x), y(y){}\n\tPoint operator + (Point p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) const { return Point(a * x, a * y); }\n\tPoint operator / (double a) const { return Point(x / a, y / a); }\n\tdouble abs() const { return sqrt(norm()); }\n\tdouble norm() const { return x * x + y * y; }\n\t// bool operator < (const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator < (const Point &p) const { // ??????????¨±???????????????\n\t\treturn x + EPS < p.x || (eq<double>(x, p.x) && y + EPS < p.y);\n\t}\n\tbool operator == (const Point &p) const { return (eq<double>(x, p.x) && eq<double>(y, p.y)); }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>; // ????§???¢\n\ndouble dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; } // ????????????a??¨b?????????\ndouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; } // ????????????a??¨b?????????\ndouble length2(const Point& a) { return a.norm(); } // ??????????????????2???\ndouble length(const Point& a) { return a.abs(); } // ???????????????\nPoint rotationalTransfer(Point c, double r, double deg) { // c???????????¨????????????r????????¨??????deg??????????????§?¨?\n\tdouble rad = PI * deg / 180.0; return c + Point(cos(rad), sin(rad)) * r;\n}\n// (x, y, z) ???????????????(xy??§?¨???§????§???????theta???, xy?????¢??????z?????????????§???????phi????????????)??????????????????????????±???xy??§?¨?\nPoint Shadow(double x, double y, double z, double theta, double phi) {\n\ttheta = PI * theta / 180.0, phi = PI * phi / 180.0;\n\treturn Point(x - z / tan(phi) * cos(theta), y - z / tan(phi) * sin(theta));\n}\n\nenum ccw_t {\n\tCOUNTER_CLOCKWISE = 1, // p0->p1 ???????¨???????????????????p2\n\tCLOCKWISE = -1, // p0->p1 ????¨???????????????????p2\n\tONLINE_BACK = 2, // p2->p0->p1 ????????§??´????????§p2\n\tONLINE_FRONT = -2, // p0->p1->p2 ????????§??´??????p2\n\tON_SEGMENT = 0, // p0->p2->p1 ????????§??????p0p1??????p2\n};\nccw_t ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif ( cross(a, b) > EPS  )  return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS )  return CLOCKWISE;\n\tif ( dot(a, b) < -EPS )    return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nclass Segment { //??????\npublic:\n\tPoint p1, p2;\n\tSegment(){}\n\tSegment(Point p1, Point p2):p1(p1), p2(p2){}\n};\nusing Line = Segment;\n\n// *** ????§???¢ ***\n// IN := 2, ON := 1, OUT := 0\nvector<Segment> getPolygonSegument(const Polygon& p) { //????§???¢????????????????§???¢??????????±???????\n\tvector<Segment> ret;\n\trep(i, p.size() - 1) ret.push_back(Segment(p[i], p[i + 1]));\n\tret.push_back(Segment(p[p.size() - 1], p[0]));\n\treturn ret;\n}\nint contains(const Polygon& g, const Point& p){ // ????§???¢g????????????p????????????????????????\n\tint n = g.size(); bool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif ( abs(cross(a, b)) < EPS && dot(a, b) < EPS ) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS ) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\nPolygon andrewScan(Polygon s) { // ??????(??????????????????????????????)\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end()); // x, y???????????????????????????\n\t// x????°???????????????????2??? u ?????????\n\tu.push_back(s[0]), u.push_back(s[1]);\n\t// x ?????§??????????????????2???1?????????\n\tl.push_back(s[s.size() - 1]), l.push_back(s[s.size() - 2]);\n\t// ??????????????¨?????????\n\tfor (int i = 2; i < s.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t// ??????????????¨?????????\n\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t// ????¨????????????????????????????????????????????????????\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n\n// *** ????????????????????? ***\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && \n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\nbool intersect(const Segment& s1, const Segment& s2) { // ?????????????????????true\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n//*** ??????????????? ***\nPoint getCrossPoint(Segment s1, Segment s2) { // ???????????????????????¨??????????????????????????????????????¨\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1)), d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t  = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n// *** ?????¢ ***\ndouble getDistance(Point& a, Point& b) { // ???a??¨???b????????¢\n\treturn length(a - b);\n}\ndouble getDistanceLP(Line& l, Point& p) { // ??´???s??¨???p????????¢\n\treturn length(cross(l.p2 - l.p1, p - l.p1) / length(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) { // ??????s??¨???p????????¢\n\tif( dot(s.p2 - s.p1, p - s.p1) < EPS ) return length(p - s.p1);\n\tif( dot(s.p1 - s.p2, p - s.p2) < EPS ) return length(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\ndouble getDistanceSS(const Segment& s1, const Segment& s2) { // ??????s1??¨??????s2?????????\n\tif( intersect(s1, s2) ) return 0.0; //????????£???????????¨???\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t\t\t   min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\ndouble getDistancePolP(const Polygon& pol, const Point& p) { // ????§???¢pol??¨???p????????¢\n\tif(contains(pol, p) != 0) return 0.0; // ??????????§???¢????????¨?????????????????????\n\tdouble ret = 1e9;\n\tfor(Segment& u : getPolygonSegument(pol)) ret = min(ret, getDistanceSP(u, p));\n\treturn ret;\n}\ndouble getDistancePolPol(const Polygon& p1, const Polygon& p2) { // ????§???¢p1??¨p2????????¢\n\tfor(const Point& p : p1) if(contains(p2, p) != 0) return 0.0; // p1?????????????§???¢p2???????????????????????????\n\tfor(const Point& p : p2) if(contains(p1, p) != 0) return 0.0; // p2?????????????§???¢p1???????????????????????????\n\tdouble ret = 1e9;\n\tfor(const Segment& u : getPolygonSegument(p1))for(const Segment& v : getPolygonSegument(p2)) {\n\t\tret = min(ret, getDistanceSS(u, v));\n\t}\n\treturn ret;\n}\n\n\nclass Rectangle { // ????????¢\npublic:\n\t// 3 2\n\t// 0 1 (???????¨??????????????????¢??????????????????????????¨)\n\tvector<Point> p; // ?????????????????????????????¨\n\tRectangle(vector<Point>&p):p(p) {\n\t\trep(i, 3) reps(j, i + 1, 4) { //????????????????????????????????§???????????????????\n\t\t\tint cnt = 0;\n\t\t\trep(k, 4) if(k != i && k != j) {\n\t\t\t\tcnt += ccw(p[i], p[j], p[k]) == COUNTER_CLOCKWISE;\n\t\t\t}\n\t\t\tif(cnt == 2) {\n\t\t\t\tswap(p[i + 1], p[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbool intersect(const Segment& s) { // ??????s??¨????????¢????°?????????¨???1??????????????????????????°true\n\t\tbool flag = false;\n\t\trep(i, 4) flag |= ::intersect(s, Segment(p[i], p[(i + 1) % 4]));\n\t\treturn flag;\n\t}\n\tbool contain(const Point& pp) { // ???pp???????????¢????????????????????°(??????????????????)true\n\t\tbool flag = true;\n\t\trep(i, 4) flag &= ccw(p[i], p[(i + 1) % 4], pp) == COUNTER_CLOCKWISE;\n\t\treturn flag;\n\t}\n\tbool contain(const Segment& s) { // ??????s???????????¢????????????????????°(??????????????????)true\n\t\treturn contain(s.p1) && contain(s.p2);\n\t}\n};\n\n\n\n\nconst int MAX_N = 210;\nusing TYPE = double; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\n\nint main(void) {\n\t\n\n\twhile(1) {\n\t\tint N; scanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tint NV[110], H[110];\n\t\tvector<vector<pair<double, double>>> p;\n\t\trep(i, N){\n\t\t\tscanf(\"%d %d\", &NV[i], &H[i]);\n\t\t\tvector<pair<double, double>> tmp;\n\t\t\trep(j, NV[i]){\n\t\t\t\tdouble x, y; scanf(\"%lf %lf\", &x, &y);\n\t\t\t\ttmp.pb(mp(x, y));\n\t\t\t}\n\t\t\tp.pb(tmp);\n\t\t}\n\t\tdouble theta, phi; scanf(\"%lf %lf\", &theta, &phi);\n\t\tdouble Sx, Sy, Tx, Ty; scanf(\"%lf %lf %lf %lf\", &Sx, &Sy, &Tx, &Ty);\n\t\tPoint start(Sx, Sy), goal(Tx, Ty);\n\n\t\tvector<Polygon> v;\n\t\trep(i, N){\n\t\t\tPolygon t;\n\t\t\tfor(auto u : p[i]) t.pb(Shadow(u.fi, u.se, H[i], theta, phi));\n\t\t\tfor(auto u : p[i]) t.pb(Point(u.fi, u.se));\n\t\t\tPolygon tt = andrewScan(t);\n\t\t\tv.pb(tt);\n\t\t}\n\n\t\t/*\n\t\tfor(auto u : v) {\n\t\t\tfor(auto k : u) printf(\"%f %f, \", k.x, k.y);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\t\n\n\t\trep(i, MAX_N) G[i].clear();\n\n\t\trep(i, v.size())rep(j, v.size()){\n\t\t\tif(i == j) continue;\n\t\t\tint s = i + 1, t = j + 1;\n\t\t\tauto dis = getDistancePolPol(v[i], v[j]);\n\t\t\tG[s].pb(mp(t, dis)), G[t].pb(mp(s, dis));\n\t\t}\n\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], start);\n\t\t\tG[0].pb(mp(i + 1, dis)), G[i + 1].pb(mp(0, dis));\n\t\t}\n\t\trep(i, v.size()){\n\t\t\tauto dis = getDistancePolP(v[i], goal);\n\t\t\tG[N + 1].pb(mp(i + 1, dis)), G[i + 1].pb(mp(N + 1, dis));\n\t\t}\n\n\t\tG[0].pb(mp(N + 1, getDistance(start, goal))), G[N + 1].pb(mp(0, getDistance(start, goal)));\n\n\t\tauto ret = dijkstra(0);\n\t\tprintf(\"%.9f\\n\", ret[N + 1]);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon &poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nint N;\ndouble Hs[110];\nPolygon polies[110];\n\nbool check(Segment &seg,unordered_set<int> &skip) {\n  rep(i,N) {\n    if( skip.count(i) ) continue;\n    rep(j,(int)polies[i].size()) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%(int)polies[i].size()]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment &seg1,Segment &seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\ndouble dijkstra(vector<vector<Edge>> &G) {\n  int V = G.size();\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,double theta,double phi,vector<Point> &ep) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,(int)polies[i].size()) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  vector<vector<Edge>> G(2+N);\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\tunordered_set<int> skip;\n\tskip.insert(j);\n\n\trep(k,(int)polies[j].size()) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,(int)polies[j].size()) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%(int)polies[j].size()]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%(int)polies[j].size()],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      unordered_set<int> skip;\n      skip.insert(i);\n      skip.insert(j);\n      \n      rep(k,(int)polies[i].size()) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%(int)polies[i].size()]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%(int)polies[j].size()]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(G));\n  \n}\n\nint main(){\n  while( cin >> N, N ) {\n    rep(i,N) {\n      int V;\n      cin >> V >> Hs[i];\n      polies[i].resize(V);\n      rep(j,V) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    vector<Point> ep(2);\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,toRad(theta),toRad(phi),ep);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep2(i, a, n) for(int i = a; i <= n; ++i)\n#define rep(i, n) rep2(i, 0, n - 1)\n\nusing Real = double;\nusing Point = complex<Real>;\nistream &operator>>(istream &is, Point &p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n#define x real()\n#define y imag()\nostream &operator<<(ostream &os, Point &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nconst Real EPS = 1e-8, PI = acos(-1);\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\nnamespace std {\nbool operator<(const Point &a, const Point &b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\n} // namespace std\nPoint operator*(const Point &p, const Real &d) { return Point(p.x * d, p.y * d); }\nstruct Segment {\n    Point a, b;\n    Segment() = default;\n    Segment(Point a, Point b) : a(a), b(b) {}\n};\nReal dot(const Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\nReal cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\nPoint proj(const Segment &l, const Point &p) {\n    Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\nbool intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\nbool intersect(const Segment &s, const Segment &t) { return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 and ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; }\nReal Dist(const Point &p, const Segment &s) {\n    Point r = proj(s, p);\n    if(intersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\nReal Dist(const Segment &s, const Point &p) { return Dist(p, s); }\nReal Dist(const Segment a, const Segment b) {\n    if(intersect(a, b)) return 0;\n    return min({Dist(a, b.a), Dist(a, b.b), Dist(b, a.a), Dist(b, a.b)});\n}\n\nusing Polygon = vector<Point>;\nostream &operator<<(ostream &os, Polygon p) {\n    rep(i, p.size()) os << p[i] << \" \";\n    return os;\n}\nPolygon convexHull(Polygon &p) {\n    int n = p.size(), k = 0;\n    if(n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 and cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n    }\n    for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t and cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < EPS) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\nint contains(const Polygon &Q, const Point &p) {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if(a.y > b.y) swap(a, b);\n        if(a.y <= 0 and 0 < b.y and cross(a, b) < 0) in = !in;\n        if(cross(a, b) == 0 and dot(a, b) <= 0) return 1;\n    }\n    return in;\n}\nReal D(Polygon a, Polygon b) {\n    int n = a.size(), m = b.size();\n    double d = 1e18;\n    rep(i, n) if(contains(b, a[i])) return (Real)0;\n    rep(i, m) if(contains(a, b[i])) return (Real)0;\n    rep(i, n) {\n        rep(j, m) { d = min(d, Dist(Segment(a[i], a[(i + 1) % n]), Segment(b[j], b[(j + 1) % m]))); }\n    }\n    rep(i, n) rep(j, m) d = min(d, Dist(Segment(a[i], a[(i + 1) % n]), b[j])), d = min(d, Dist(Segment(b[j], b[(j + 1) % m]), a[i]));\n    rep(i, n) rep(j, m) d = min(d, abs(a[i] - b[j]));\n    return d;\n}\nmain() {\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(15);\n    int n;\n    while(1) {\n        cin >> n;\n        if(!n) return 0;\n        vector<Polygon> P(n), Q(n);\n        vector<double> H(n);\n        rep(i, n) {\n            int v;\n            cin >> v;\n            cin >> H[i];\n            P[i].resize(v);\n            rep(j, v) cin >> P[i][j];\n        }\n        double theta, phi;\n        cin >> theta >> phi;\n        theta *= PI * 2, phi *= PI * 2;\n        theta /= 360, phi /= 360;\n        rep(i, n) {\n            int v = P[i].size();\n            double r = H[i] / tan(phi);\n            Point p(r * cos(theta + PI), r * sin(theta + PI));\n            rep(j, v) { P[i].emplace_back(P[i][j] + p); }\n            P[i] = convexHull(P[i]);\n        }\n        vector<vector<Real>> d(n + 2, vector<Real>(n + 2, 1e18));\n        Point s, t;\n        cin >> s >> t;\n        P.emplace_back(Polygon{s}), P.emplace_back(Polygon{t});\n        rep(i, n + 2) rep(j, n + 2) {\n            if(i <= j) continue;\n            d[i][j] = d[j][i] = D(P[i], P[j]);\n        }\n        rep(k, n + 2) rep(i, n + 2) rep(j, n + 2) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); }\n        cout << d[n][n + 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180.0)*pi)-b.y*sin((r/180.0)*pi);\n  a.y=b.x*sin((r/180.0)*pi)+b.y*cos((r/180.0)*pi);\n  a=a+base;\n  return a;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX)\n    e[i].clear();\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return inf;\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size()){\n    Segment seg(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      dis=min(dis,getDistanceSP(seg,P2[j][l]));\n    }\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v = rotate(Point(),Point(-dis,0),a);\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n){\n    FOR(j,i+1,n){\n      double dis=min(getdis(i,j),getdis(j,i));\n      add_edge(i,j,dis);\n      add_edge(j,i,dis);\n    }\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size()){\n      dis=min(dis,abs(s-P2[i][j]));\n    }\n    if(contains(P2[i],s)!=0)dis=0.0;\n    add_edge(n,i,dis);\n  }\n  FOR(i,0,n){\n    double dis=inf;\n    FOR(j,0,P2[i].size())\n      dis=min(dis,abs(t-P2[i][j]));\n    if(contains(P2[i],t)!=0)dis=0.0;\n    add_edge(i,n+1,dis);\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<complex>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i<(n); ++i)\n#define reps(i,a,n) for(int i = (a); i<(n); ++i)\n\n\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\nenum {TRUE = 1, FALSE = 0, BORDER = -1};\ntypedef int BOOL;\ntypedef double R;\nconst R INF = 1e8;\nR EPS = 1e-12;\nconst R PI = 3.1415926535897932384626;\ninline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\ntypedef complex<R> P;\ninline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\ninline R inp(const P& a, const P& b){return (conj(a)*b).X;}\ninline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\ninline P unit(const P& p){return p/abs(p);}\ninline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\ninline int ccw(const P &s, const P &t, const P &p, int adv=0){\nint res = sig(outp(t-s, p-s));\nif(res || !adv) return res;\nif(sig(inp(t-s, p-s)) < 0) return -2; // p-s-t\nif(sig(inp(s-t, p-t)) < 0) return 2; // s-t-p\nreturn 0; // s-p-t\n}\nstruct L : public vector<P>{ // line\nL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\nL(){}\nP dir()const {return at(1) - at(0);}\nBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n};\nstruct S : public L{ // segment\nS(const P &p1, const P &p2):L(p1, p2){}\nS(){}\nBOOL online(const P &p)const {\nif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n// 座標の二乗とEPS の差が大きすぎないように注意\nreturn !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),\n-dir()) > -EPS;\n//return !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n}\n};\n// 射影と反射 (s を t に)\ninline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\ninline P reflect(const P &s, const L &t){return (R)2.*proj(s, t) - s;}\ninline S reflect(const S &s, const L &t){return S(reflect(s[0], t), reflect(s[1], t\n));}\n// 交差判定\nBOOL intersect(const S &s, const S &t){\nconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\nconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\nreturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n}\nBOOL intersect(const S &s, const L &l){\nif(l.online(s[0]) || l.online(s[1])) return BORDER;\nreturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n}\n// dist2: 距離の二乗, dist: 距離\nR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\nR dist2(const S &s, const P &p){\nif(inp(p-s[0], s.dir()) < EPS) return norm(p - s[0]);\nif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\nreturn dist2((const L &)s, p);\n}\nR dist2(const S &s, const L &l){\nreturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n}\nR dist2(const S &s, const S &t){\nreturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])),\nmin(dist2(s, t[1]), dist2(t, s[1])));\n}\ntemplate<class S, class T> R dist(const S& s, const T& t){return sqrtl(dist2(s, t));}\ninline P crosspoint(const L &l, const L &m){\nR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\nif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\nif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\nreturn m[0] + B / A * (m[1] - m[0]);\n}\n\n\n\nusing pi = pair<int, R>;\n\nint H[102];\nvector<P> XY[102];\nint beg[102];\n\nvector<S> pt[102];\nR D[128][128];\n\n\nint main(){\n    int n;\n    while(cin >> n){\n        if(n == 0)return 0;\n        int su = 0;\n        rep(i, n){\n            int v;\n            cin >> v >> H[i];\n            XY[i].clear();\n            rep(j, v){\n                int x,y;\n                cin >> x >> y;\n                XY[i].push_back(P(x,y));\n            }\n            su += v*2;\n        }\n        rep(i,128)rep(j,128) D[i][j] = (i==j ? 0.0 : INF);\n\n\n        int sita, phi;\n        cin >> sita >> phi;\n        R SITA = (R)sita*3.14159265358979323 /180;\n        R PHI  =  (R)phi*3.14159265358979323 /180;\n        P S, T;\n        {\n            int x,y;\n            cin >> x >> y;\n            S = P(x,y);\n            cin >> x >> y;\n            T = P(x,y);\n        }\n        rep(i, n){\n            pt[i].clear();\n            int v = XY[i].size();\n\n            R r = H[i] / tan(PHI);\n            //P d = -P(r*cos(SITA), r*sin(SITA));\n            P d = -polar(r, SITA);\n            rep(j, v){\n                pt[i].emplace_back(XY[i][j], XY[i][(j+1)%v]);\n            }\n            rep(j, v){\n                pt[i].emplace_back(XY[i][j] + d, XY[i][(j+1)%v] + d);\n            }\n            rep(j, v){\n                pt[i].emplace_back(XY[i][j], XY[i][j] + d);\n            }\n            \n            rep(a,v*2) reps(b,a+1, v*2) reps(c, b+1, v*2){\n                int A = ccw(pt[i][a][0], pt[i][b][0], S);\n                int B = ccw(pt[i][b][0], pt[i][c][0], S);\n                int C = ccw(pt[i][c][0], pt[i][a][0], S);\n                if(A != 0 && A == B && B == C) D[n][i] = D[i][n] = 0;\n            }\n            rep(a,v*2) reps(b,a+1, v*2) reps(c, b+1, v*2){\n                int A = ccw(pt[i][a][0], pt[i][b][0], T);\n                int B = ccw(pt[i][b][0], pt[i][c][0], T);\n                int C = ccw(pt[i][c][0], pt[i][a][0], T);\n                if(A != 0 && A == B && B == C) D[n+1][i] = D[i+1][n] = 0;\n            }\n            \n            for(auto&S:pt[i]){\n                //cout << \"line(\" << S[0].X<<\", \"<< S[0].Y<<\", \"<< S[1].X<<\", \"<< S[1].Y<<\")\"<<endl;\n            }\n        }\n        //cout << \"circle(\" << S.X << \", \" << S.Y << \", 1)\" << endl;\n        //cout << \"circle(\" << T.X << \", \" << T.Y << \", 1)\" << endl;\n\n\n\n        rep(i, n)reps(j, i+1, n){\n            R d = INF;\n            for(auto&A : pt[i]) for(auto&B : pt[j]) {\n                d = min(d, dist2(A,B));\n            }\n            D[i][j] = D[j][i] = sqrt(d);\n        }\n        rep(i, n){\n            R d = D[n][i];\n            for(auto&A : pt[i]){\n                d = min(d, dist2(A, S));\n            }\n            D[i][n] = D[n][i] = sqrt(d);\n        }\n        rep(i, n){\n            R d = D[n+1][i];\n            for(auto&A : pt[i]){\n                d = min(d, dist2(A, T));\n            }\n            D[i][n+1] = D[n+1][i] = sqrt(d);\n        }\n        D[n][n+1] = D[n+1][n] = abs(S-T);\n        /*\n        rep(i, n+2){\n            rep(j, n+2){\n                printf(\"%9.5lf\", (double)D[i][j]);\n            }\n            puts(\"\");\n        }\n        */\n        rep(k, n+2)rep(i, n+2) rep(j, n+2){\n            D[i][j] = D[j][i] = min(D[i][j] , D[i][k] + D[k][j]);\n        }\n        printf(\"%.9lf\", (double)D[n][n+1]);\n        puts(\"\");\n\n    }\n}\n/*\n */\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 105\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Line{\n\tPoint p[2];\n\tLine(Point p1,Point p2){\n\t\tp[0] = p1;\n\t\tp[1] = p2;\n\t}\n\tLine(){\n\n\t}\n};\n\nstruct Info{\n\n\tint num_points;\n\tdouble height;\n\tPolygon polygon;\n};\n\nint N;\nInfo info[SIZE];\ndouble THETA,FAI;\ndouble min_dist[SIZE][SIZE];\nPoint start,goal;\n\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -1;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0,Point p1,Point p2){\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n\nPolygon ConvexHull(Polygon V){\n\n\tsort(V.begin(),V.end());\n\n\tvector<Point> UP,DOWN;\n\n\tUP.push_back(V[0]);\n\tDOWN.push_back(V[0]);\n\n\tfor(int i = 1; i < V.size(); i++){\n\n\t\twhile(UP.size() > 1 && ccw(UP[UP.size()-2],UP[UP.size()-1],V[i]) == COUNTER_CLOCKWISE){\n\n\t\t\tUP.pop_back();\n\t\t}\n\n\t\twhile(DOWN.size() > 1 && ccw(DOWN[DOWN.size()-2],DOWN[DOWN.size()-1],V[i]) ==  CLOCKWISE){\n\n\t\t\tDOWN.pop_back();\n\t\t}\n\n\t\tUP.push_back(V[i]);\n\t\tDOWN.push_back(V[i]);\n\t}\n\n\tPolygon ret;\n\n\tfor(int i = 0; i < UP.size(); i++){\n\n\t\tret.push_back(UP[i]);\n\t}\n\n\tfor(int i = DOWN.size()-1; i >= 0; i--){\n\n\t\tret.push_back(DOWN[i]);\n\t}\n\n\treturn ret;\n}\n\n\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble calc_slope(Line A){\n\n\tif(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n\t\treturn DBL_MAX;\n\n\t}else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n\t\treturn 0;\n\n\t}else{\n\n\t\treturn (A.p[0].y-A.p[1].y)/(A.p[0].x-A.p[1].x);\n\t}\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\n//★★直線ではなく、線分の交差判定★★\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//★★線分ではなく直線と点の距離★★\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\n//★★点と線分の距離★★\ndouble getDistanceSP(Line l,Point p){\n\tif(dot(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0])) < 0.0)return calc_len(calc_minus(p,l.p[0]));\n\tif(dot(calc_minus(l.p[0],l.p[1]),calc_minus(p,l.p[1])) < 0.0)return calc_len(calc_minus(p,l.p[1]));\n\treturn getDistanceLP(l,p);\n}\n\n//★★線分と線分の距離★★\ndouble getDistance(Line A,Line B){\n\tif(is_Cross(A,B))return 0.0;\n\treturn min(min(getDistanceSP(A,B.p[0]),getDistanceSP(A,B.p[1])),\n\t\t\tmin(getDistanceSP(B,A.p[0]),getDistanceSP(B,A.p[1])));\n}\n\n/*\n * IN 2\n * ON 1\n * OUT 0\n *\n */\nint contains(Polygon g,Point p){\n\tint n = g.size();\n\tbool x = false;\n\tfor(int i = 0; i < n; i++){\n\t\tPoint a = g[i]-p,b = g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n\t\tif(a.y > b.y)swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n\t}\n\treturn (x ? 2:0);\n}\n\ndouble calc_dist(Polygon A,Polygon B){\n\n\tdouble ret = HUGE_NUM;\n\n\tfor(int i = 0; i < A.size(); i++){\n\t\tLine a = Line(A[i],A[(i+1)%A.size()]);\n\t\tfor(int k = 0; k < B.size(); k++){\n\t\t\tLine b = Line(B[k],B[(k+1)%B.size()]);\n\t\t\tret = min(ret,getDistance(a,b));\n\t\t}\n\t}\n\treturn ret;\n}\n\ndouble calc_dist(Polygon polygon,Point point){\n\n\tif(contains(polygon,point) == 2)return 0;\n\n\tdouble ret = HUGE_NUM;\n\tfor(int i = 0; i < polygon.size(); i++){\n\n\t\tLine tmp_line = Line(polygon[i],polygon[(i+1)%polygon.size()]);\n\t\tret = min(ret,getDistanceSP(tmp_line,point));\n\t}\n\n\treturn ret;\n}\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tinfo[i].polygon.clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d %lf\",&info[i].num_points,&info[i].height);\n\n\t\tfor(int loop = 0; loop < info[i].num_points; loop++){\n\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf %lf\",&x,&y);\n\n\t\t\tinfo[i].polygon.push_back(Point(x,y));\n\t\t}\n\t}\n\n\tscanf(\"%lf %lf\",&THETA,&FAI);\n\tdouble theta = THETA*M_PI/180; //ラジアンにする\n\tdouble fai = FAI*M_PI/180;\n\n\tscanf(\"%lf %lf %lf %lf\",&start.x,&start.y,&goal.x,&goal.y);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tPolygon tmp;\n\n\t\tfor(int k = 0; k < info[i].polygon.size(); k++){\n\n\t\t\tdouble L = info[i].height/tan(fai);\n\t\t\ttmp.push_back(Point(info[i].polygon[k].x-L*cos(theta),info[i].polygon[k].y-L*sin(theta)));\n\n\t\t}\n\n\t\tfor(int k = 0; k < tmp.size(); k++){\n\n\t\t\tinfo[i].polygon.push_back(tmp[k]);\n\t\t}\n\n\t\tinfo[i].polygon = ConvexHull(info[i].polygon);\n\t}\n\n\tint START = N,GOAL = N+1;\n\n\tfor(int i = 0; i <= N+1; i++){\n\t\tfor(int k = 0; k <= N+1; k++){\n\t\t\tif(k == i){\n\n\t\t\t\tmin_dist[i][k] = 0;\n\n\t\t\t}else{\n\n\t\t\t\tmin_dist[i][k] = HUGE_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\t//スタートとゴールの距離\n\tmin_dist[START][GOAL] = calc_dist(start,goal);\n\tmin_dist[GOAL][START] = calc_dist(start,goal);\n\n\t//スタートと各建物の距離\n\tfor(int i = 0; i < N; i++){\n\n\t\tmin_dist[START][i] = calc_dist(info[i].polygon,start);\n\t\tmin_dist[i][START] = min_dist[START][i];\n\t}\n\n\t//ゴールと各建物の距離\n\tfor(int i = 0; i < N; i++){\n\n\t\tmin_dist[GOAL][i] = calc_dist(info[i].polygon,goal);\n\t\tmin_dist[i][GOAL] = min_dist[GOAL][i];\n\t}\n\n\t//建物同士の距離\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tmin_dist[i][k] = calc_dist(info[i].polygon,info[k].polygon);\n\t\t\tmin_dist[k][i] = min_dist[i][k];\n\t\t}\n\t}\n\n\tfor(int mid = 0; mid <= N+1; mid++){\n\t\tfor(int st = 0; st <= N+1; st++){\n\t\t\tif(fabs(min_dist[st][mid]-HUGE_NUM) < EPS)continue;\n\t\t\tfor(int gl = 0; gl <= N+1; gl++){\n\t\t\t\tif(fabs(min_dist[mid][gl]-HUGE_NUM) < EPS)continue;\n\n\t\t\t\tmin_dist[st][gl] = min(min_dist[st][gl],min_dist[st][mid]+min_dist[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.10lf\\n\",min_dist[START][GOAL]);\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\nstatic const double pi = 3.141592653589793;\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-6;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nP rotateP(P a, P o ,D arg) { //点aを点oを中心に反時計周りにまわした複素数を返す。\n\ta -= o;\n\ta *= P(cos(arg / 180 * pi), sin(arg / 180 * pi));\n\ta += o;\n\treturn a;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nVP convexHull(VP ps) {  \n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nD hyou[101][101];\n\nint main() {\n\tcout << setprecision(20) << fixed;\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<VP> ps(N);\n\t\tvector<D> hs;\n\t\tvector<int> ms;\n\t\tint m;\n\t\tD h;\n\t\trep(i, 101) rep(j, 101) hyou[i][j] = 1e20;\n\t\trep(n, N) {\n\t\t\tcin >> m >> h;\n\t\t\tms.push_back(m);\n\t\t\ths.push_back(h);\n\t\t\tD x, y;\n\t\t\trep(i, m) {\n\t\t\t\tcin >> x >> y;\n\t\t\t\tP p = P(x, y);\n\t\t\t\tps[n].push_back(p);\n\t\t\t}\n\t\t}\n\t\tD s,f;\n\t\tcin >> s >> f;\n\t\tD sx, sy, tx, ty;\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\trep(n, N) {\n\t\t\trep(i, ms[n]) {\n\t\t\t\tP p2 = ps[n][i] + rotateP(P(- hs[n] / tan(f / 180 * pi), 0), P(0,0), s);\n\t\t\t\t//cout <<-hs[n] / tan(f) << \" \" <<p2 << endl;\n\t\t\t\tps[n].push_back(p2);\n\t\t\t}\n\t\t\tps[n] = convexHull(ps[n]);\n\t\t\tms[n] = (int)ps[n].size();\n\t\t}\n\t\trep(n, N) {\n\t\t\trep(n2, N) {\n\t\t\t\tD d = 1e10;\n\t\t\t\trep(i, ps[n].size()) {\n\t\t\t\t\trep(i2, ps[n2].size()) {\n\t\t\t\t\t\td = min(d, distSS(ps[n][i], ps[n][(i + 1) % ms[n]], ps[n2][i2], ps[n2][(i2 + 1) % ms[n2]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thyou[n][n2] = min(hyou[n][n2], d);\n\t\t\t\thyou[n2][n] = min(hyou[n2][n], d);\n\t\t\t\t//cout << d << endl;\n\t\t\t}\n\t\t}\n\t\trep(k, N){\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\thyou[i][j] = min(hyou[i][j], hyou[i][k] + hyou[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tD ans = abs(P(sx,sy) - P(tx, ty));\n\t\t\n\t\trep(st, N){\n\t\t\tD sd = 1e10;\n\t\t\tif(inConvex(P(sx, sy), ps[st]) > 0) sd = 0;\n\t\t\telse {\n\t\t\t\trep(i, ps[st].size()){\n\t\t\t\t\tsd = min(sd, distSP(ps[st][i], ps[st][(i + 1) % (int)ps[st].size()], P(sx, sy) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(go, N) {\n\t\t\t\tD td = 1e10;\n\t\t\t\tif(inConvex(P(tx, ty), ps[go]) > 0) td = 0;\n\t\t\t\telse {\n\t\t\t\t\trep(i, ps[go].size()){\n\t\t\t\t\t\ttd = min(td, distSP(ps[go][i], ps[go][(i + 1) % (int)ps[go].size()], P(tx, ty) ));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = min(ans, hyou[st][go] + sd + td);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\t\t\t\n\t\t\t\t\t\n\t}\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct Line {\npublic:\n\tPoint a, b;\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn (cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint n;\nld h[100];\nvector<Point> vp[100];\nvector<Point> rvp[100];\nvector<Line> vl[100];\n\nstruct edge {\n\tint to; ld cost;\n};\nvector<edge> G[102];\nld dist[102];\n\ntypedef pair<ld, int> speP;\npriority_queue<speP, vector<speP>, greater<speP>> q;\nvoid solve() {\n\tcout << fixed << setprecision(5);\n\twhile (cin >> n, n) {\n\t\trep(i, n + 2)G[i].clear();\n\t\trep(i, n) {\n\t\t\tvl[i].clear();\n\t\t\tvp[i].clear();\n\t\t\trvp[i].clear();\n\t\t\tint l; cin >> l>>h[i]; \n\t\t\tvp[i].resize(l);\n\t\t\trep(j, l) {\n\t\t\t\tld x, y; cin >> x >> y; vp[i][j] = { x,y };\n\t\t\t}\n\t\t}\n\t\tld theta, phi; cin >> theta >> phi;\n\t\ttheta = theta * pi / 180.0;\n\t\tphi = phi * pi / 180.0;\n\t\ttheta += pi;\n\t\trep(i, n) {\n\t\t\t\n\t\t\trvp[i].resize(vp[i].size());\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tld dx = cos(theta)*rh, dy = sin(theta)*rh;\n\t\t\t\trvp[i][j] = { dx + real(vp[i][j]),dy + imag(vp[i][j]) };\n\t\t\t\tvl[i].push_back({ vp[i][j],rvp[i][j] });\n\t\t\t}\n\t\t\trep(j, vp[i].size()-1) {\n\t\t\t\tvl[i].push_back({ vp[i][j],vp[i][j + 1] });\n\t\t\t\tvl[i].push_back({ rvp[i][j],rvp[i][j + 1] });\n\t\t\t}\n\t\t\tvl[i].push_back({ vp[i][0], vp[i][vp[i].size() - 1] });\n\t\t\tvl[i].push_back({ rvp[i][0],rvp[i][rvp[i].size() - 1] });\n\t\t}\n\t\trep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tld d = INF;\n\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], vp[j][l]));\n\t\t\t\t\t\td = min(d, dist_sp(vl[i][k], rvp[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(l, vp[j].size()) {\n\t\t\t\t\trep(k, vp[i].size()) {\n\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], vp[i][k]));\n\t\t\t\t\t\td = min(d, dist_sp(vl[j][l], rvp[i][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRep(k, vp[i].size(),vl[i].size()) {\n\t\t\t\t\tRep(l, vp[j].size(), vl[j].size()) {\n\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\n\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*rep(k, vl[i].size()) {\n\t\t\t\t\trep(l, vl[j].size()) {\n\t\t\t\t\t\tif (k < vp[i].size() && l < vp[j].size())continue;\n\t\t\t\t\t\tif (k >= 2 * vp[i].size() && l >= 2 * vp[j].size())continue;\n\t\t\t\t\t\td = min(d, dist_ss(vl[i][k], vl[j][l]));\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tG[i].push_back({ j,d });\n\t\t\t\tG[j].push_back({ i, d });\n\t\t\t}\n\t\t}\n\t\tPoint s, g; ld x, y; cin >> x >> y; s = { x,y }; cin >> x >> y; g = { x,y };\n\t\ttheta -= pi;\n\t\tPoint ps, pg;\n\t\trep(i, n) {\n\t\t\tld rh = h[i] / tan(phi);\n\t\t\tps = { real(s) + rh * cos(theta),imag(s) + rh * sin(theta) };\n\t\t\tpg = { real(g) + rh * cos(theta),imag(g) + rh * sin(theta) };\n\t\t\tLine ls = { s,ps };\n\t\t\tLine lg = { g,pg };\n\t\t\tbool fs = false, fg = false;\n\t\t\trep(j, vp[i].size()) {\n\t\t\t\tLine vpl = { vp[i][j],vp[i][(j + 1) % vp[i].size()] };\n\t\t\t\tif (isis_ss(ls, vpl)) {\n\t\t\t\t\tfs = true;\n\t\t\t\t}\n\t\t\t\tif (isis_ss(lg, vpl)) {\n\t\t\t\t\tfg = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fs) {\n\t\t\t\tG[n].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], s));\n\t\t\t\t}\n\t\t\t\tG[n].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n,d });\n\t\t\t}\n\t\t\tif (fg) {\n\t\t\t\tG[n + 1].push_back({ i,0 });\n\t\t\t\tG[i].push_back({ n + 1,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld d = INF;\n\t\t\t\trep(j, vl[i].size()) {\n\t\t\t\t\td = min(d, dist_sp(vl[i][j], g));\n\t\t\t\t}\n\t\t\t\tG[n + 1].push_back({ i,d });\n\t\t\t\tG[i].push_back({ n + 1,d });\n\t\t\t}\n\t\t}\n\t\tG[n].push_back({ n + 1,abs(g - s) });\n\t\tG[n + 1].push_back({ n,abs(g - s) });\n\t\tfill(dist, dist + n + 2, INF);\n\t\tdist[n] = 0;\n\t\tq.push({ 0,n });\n\t\twhile (!q.empty()) {\n\t\t\tspeP p = q.top(); q.pop();\n\t\t\tint id = p.second;\n\t\t\tif (p.first > dist[id])continue;\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tld nd = G[id][j].cost + p.first;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tq.push({ nd,to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[n + 1] << endl;\n\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; scanf(\"%Lf%Lf\",&x,&y); return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nvector<vector<ld>> G;\nld solve(){\n    ld res = 0;\n    \n    vector<double> Hs(N);\n    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; cin >> n >> Hs[i];\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull(polys[i]);\n    }\n    \n    G.clear();\n    G.assign(N+2,vector<ld>(N+2,LINF));\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                if(is_in_polygon(polys[j],polys[i][k]) > 0){\n                    D = 0;\n                    break;\n                }\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n             ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n//    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\nconstexpr ld pi = acos(-1);\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return abs(sum) < pi / 2 ? 2 : 1;\n}\n\npolygon convex_hull(vector<point> ps) {\n    sort(ps.begin(), ps.end(), [&](point const& p1, point const& p2) {\n        if(real(p1) == real(p2)) {\n            return imag(p1) < imag(p2);\n        }\n        return real(p1) < real(p2);\n    });\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2*n);\n    for(int i=0; i<n; ++i) {\n        while(k > 1 && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i=n-2, t = k; i>=0; --i) {\n        while(k > t && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nld dist_pp(polygon const& p1, polygon const& p2) {\n    ld res = 1e18;\n    const int n = p1.size();\n    const int m = p2.size();\n    for(int i = 0; i < n; ++i) {\n        segment seg1(p1[i], p1[(i + 1) % n]);\n        for(int j = 0; j < m; ++j) {\n            segment seg2(p2[j], p2[(j + 1) % m]);\n            res = min(res, dist_ss(seg1, seg2));\n        }\n    }\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<polygon> poly(N);\n        vector<ld> h(N);\n        for(int i = 0; i < N; ++i) {\n            int Nv;\n            cin >> Nv >> h[i];\n            for(int j = 0; j < Nv; ++j) {\n                ld x, y;\n                cin >> x >> y;\n                poly[i].emplace_back(x, y);\n            }\n        }\n        ld theta, phi;\n        point p[2];\n        cin >> theta >> phi;\n        for(int i = 0; i < 2; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n\n        theta = theta / 180 * pi + pi;\n        phi = phi / 180 * pi;\n        point vec(cos(theta), sin(theta));\n        for(int i = 0; i < N; ++i) {\n            point v = vec * h[i] / tan(phi);\n            const int m = poly[i].size();\n            for(int j = 0; j < m; ++j) {\n                poly[i].push_back(poly[i][j] + v);\n            }\n            poly[i] = convex_hull(poly[i]);\n        }\n\n        vector<vector<ld>> d(N+2, vector<ld>(N+2, 1e18));\n        for(int i = 0; i < N + 2; ++i) {\n            d[i][i] = 0;\n        }\n        d[N][N+1] = d[N+1][N] = abs(p[0] - p[1]);\n        for(int i = 0; i < N; ++i) {\n            for(int j = i + 1; j < N; ++j) {\n                d[i][j] = d[j][i] = dist_pp(poly[i], poly[j]);\n            }\n            \n            for(int j = 0; j < 2; ++j) {\n                ld dist = 1e18;\n                if(is_in_polygon(poly[i], p[j]) != 2) {\n                    dist = 0;\n                } else {\n                    const int m = poly[i].size();\n                    for(int k = 0; k < m; ++k) {\n                        segment seg(poly[i][k], poly[i][(k + 1) % m]);\n                        dist = min(dist, dist_sp(seg, p[j]));\n                    }\n                }\n                d[i][N + j] = d[N + j][i] = dist;\n            }\n        }\n\n        for(int k = 0; k < N + 2; ++k) {\n            for(int i = 0; i < N + 2; ++i) {\n                for(int j = 0; j < N + 2; ++j) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(10) << d[N+1][N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double INF = 100000000;\nstruct point{\n  double x, y;\n  point(){\n    x = 0;\n    y = 0;\n  }\n  point(double x, double y): x(x), y(y){\n  }\n  point operator +(point P){\n    return point(x + P.x, y + P.y);\n  }\n  point operator -(point P){\n    return point(x - P.x, y - P.y);\n  }\n  point operator /(double k){\n    return point(x / k, y / k);\n  }\n};\ndouble abs(point P){\n  return sqrt(pow(P.x, 2) + pow(P.y, 2));\n}\ndouble dot(point P, point Q){\n  return P.x * Q.x + P.y * Q.y;\n}\ndouble cross(point P, point Q){\n  return P.x * Q.y - P.y * Q.x;\n}\ndouble point_distance(point P, point Q){\n  return abs(Q - P);\n}\nstruct line{\n  point A, B;\n  line(){\n  }\n  line(point A, point B): A(A), B(B){\n  }\n  \n};\npoint vec(line L){\n  return L.B - L.A;\n}\ndouble point_line_distance(point P, line L){\n  return abs(cross(L.B - L.A, P - L.A)) / abs(vec(L));\n}\ndouble point_segment_distance(point P, line L){\n  if (dot(L.B - L.A, P - L.A) < 0){\n    return point_distance(P, L.A);\n  } else if (dot(L.A - L.B, P - L.B) < 0){\n    return point_distance(P, L.B);\n  } else {\n    return point_line_distance(P, L);\n  }\n}\nvector<point> sort_polygon(vector<point> &P){\n  int sz = P.size();\n  point G;\n  for (int i = 0; i < sz; i++){\n    G = G + P[i];\n  }\n  G = G / sz;\n  vector<pair<double, int>> P2(sz);\n  for (int i = 0; i < sz; i++){\n    P2[i] = make_pair(atan2(P[i].y - G.y, P[i].x - G.x), i);\n  }\n  sort(P2.begin(), P2.end());\n  vector<point> ans(sz);\n  for (int i = 0; i < sz; i++){\n    ans[i] = P[P2[i].second];\n  }\n  return ans;\n}\nbool point_in_triangle(point X, point A, point B, point C){\n  vector<point> P = {A, B, C};\n  sort_polygon(P);\n  point tmp = P[0];\n  P.push_back(tmp);\n  for (int i = 0; i < 3; i++){\n    if (cross(P[i + 1] - P[i], X - P[i]) < 0){\n      return false;\n    }\n  }\n  return true;\n}\nvector<point> convex_hull(vector<point> P){\n  int sz = P.size();\n  point G;\n  for (int i = 0; i < sz; i++){\n    G = G + P[i];\n  }\n  G = G / sz;\n  while (1){\n    sz = P.size();\n    bool upd = false;\n    point tmp = P[0];\n    point tmp2 = P[1];\n    P.push_back(tmp);\n    P.push_back(tmp2);\n    vector<point> Q;\n    for (int i = 1; i <= sz; i++){\n      if (!point_in_triangle(P[i], G, P[i - 1], P[i + 1])){\n        Q.push_back(P[i]);\n      } else {\n        upd = true;\n      }\n    }\n    if (upd){\n      swap(P, Q);\n    } else {\n      return Q;\n    }\n  }\n}\nbool point_in_polygon(point X, vector<point> P){\n  int sz = P.size();\n  point tmp = P[0];\n  P.push_back(tmp);\n  for (int i = 0; i < sz; i++){\n    if (cross(P[i + 1] - P[i], X - P[i]) < 0){\n      return false;\n    }\n  }\n  return true;\n}\ndouble point_polygon_distance(point X, vector<point> P){\n  int sz = P.size();\n  if (point_in_polygon(X, P)){\n    return 0;\n  }\n  point tmp = P[0];\n  P.push_back(tmp);\n  double ans = INF;\n  for (int i = 0; i < sz; i++){\n    ans = min(ans, point_segment_distance(X, line(P[i], P[i + 1])));\n  }\n  return ans;\n}\ndouble polygon_distance(vector<point> P, vector<point> Q){\n  int szP = P.size();\n  int szQ = Q.size();\n  for (int i = 0; i < szP; i++){\n    if (point_in_polygon(P[i], Q)){\n      return 0;\n    }\n  }\n  for (int i = 0; i < szQ; i++){\n    if (point_in_polygon(Q[i], P)){\n      return 0;\n    }\n  }\n  point tmpP = P[0];\n  P.push_back(tmpP);\n  point tmpQ = Q[0];\n  Q.push_back(tmpQ);\n  double ans = INF;\n  for (int i = 0; i < szP; i++){\n    for (int j = 0; j < szQ; j++){\n      ans = min(ans, point_segment_distance(P[i], line(Q[j], Q[j + 1])));\n    }\n  }\n  for (int i = 0; i < szQ; i++){\n    for (int j = 0; j < szP; j++){\n      ans = min(ans, point_segment_distance(Q[i], line(P[j], P[j + 1])));\n    }\n  }\n  return ans;\n}\nint main(){\n  cout << fixed << setprecision(5);\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    vector<double> H(N);\n    vector<vector<point>> V(N);\n    for (int i = 0; i < N; i++){\n      int NV;\n      cin >> NV;\n      cin >> H[i];\n      V[i] = vector<point>(NV);\n      for (int j = 0; j < NV; j++){\n        cin >> V[i][j].x >> V[i][j].y;\n      }\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    theta = theta / 180 * PI;\n    phi = phi / 180 * PI;\n    point S;\n    cin >> S.x >> S.y;\n    point T;\n    cin >> T.x >> T.y;\n    vector<vector<point>> V2(N + 2);\n    for (int i = 0; i < N; i++){\n      int NV = V[i].size();\n      point d;\n      d.x = H[i] / tan(phi) * cos(theta) * -1;\n      d.y = H[i] / tan(phi) * sin(theta) * -1;\n      for (int j = 0; j < NV; j++){\n        V2[i].push_back(V[i][j]);\n        V2[i].push_back(V[i][j] + d);\n      }\n      V2[i] = sort_polygon(V2[i]);\n      V2[i] = convex_hull(V2[i]);\n    }\n    V2[N].push_back(S);\n    V2[N + 1].push_back(T);\n    vector<vector<double>> d(N + 2, vector<double>(N + 2, INF));\n    for (int i = 0; i < N + 2; i++){\n      d[i][i] = 0;\n      for (int j = i + 1; j < N + 2; j++){\n        if (i < N){\n          if (j < N){\n            d[i][j] = polygon_distance(V2[i], V2[j]);\n          } else {\n            d[i][j] = point_polygon_distance(V2[j][0], V2[i]);\n          }\n        } else {\n          d[i][j] = point_distance(V2[i][0], V2[j][0]);\n        }\n        d[j][i] = d[i][j];\n      }\n    }\n    for (int i = 0; i < N + 2; i++){\n      for (int j = 0; j < N + 2; j++){\n        for (int k = 0; k < N + 2; k++){\n          d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        }\n      }\n    }\n    cout << d[N][N + 1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e18\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ndouble distPP(vec2d p, vec2d q){\n\treturn (p-q).norm();\n}\n\ndouble distSP(vec2d p, vec2d q, vec2d x)\n{\n\tif((x-p).dot(q-p) <= 0) return distPP(p, x);\n\tif((x-q).dot(p-q) <= 0) return distPP(q, x);\n\treturn fabs( (x-p).cross(q-p) / distPP(p, q) );\n}\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\ndouble distSS(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif(isCross(p, q, r, s)) return 0;\n\tdouble ret = distSP(p, q, r);\n\tret = min(ret, distSP(p, q, s));\n\tret = min(ret, distSP(r, s, p));\n\tret = min(ret, distSP(r, s, q));\n\treturn ret;\n}\n\nbool isInTriangle(vec2d p, vec2d q, vec2d r, vec2d x)\n{\n\tp = p - r, q = q - r, x = x - r;\n\tdouble s = p.cross(x) / p.cross(q), t = x.cross(q) / p.cross(q);\n\treturn s >= -eps && t >= -eps && s+t <= 1 + eps;\n}\n\ntypedef pair<vec2d, vec2d> Segment;\nstruct Region{\n\tSegment seg[4];\n\tRegion(){};\n\tRegion(Segment a, Segment b, Segment c, Segment d){\n\t\tseg[0] = a, seg[1] = b, seg[2] = c, seg[3] = d;\n\t}\n};\n\nstruct edge{\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int a, double b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint N;\ndouble h[105];\nvector<vec2d> poly[105];\ndouble th, phy;\nvec2d s, t;\n\nint S, T, V;\nvector<Region> vec;\nvector<edge> G[1500];\ndouble dist[1500];\n\ntypedef pair<double, int> P;\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tint v; double d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tint n; vec2d tmp;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> n >> h[i];\n\t\t\tpoly[i].clear();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> tmp.x >> tmp.y;\n\t\t\t\tpoly[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tcin >> th >> phy;\n\t\tth *= M_PI / 180, phy *= M_PI / 180;\n\t\tcin >> s.x >> s.y;\n\t\tcin >> t.x >> t.y;\n\t\t\n\t\tvec.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tvec2d a, b, a2, b2;\n\t\t\tfor(int j = 0; j < poly[i].size(); j++){\n\t\t\t\ta = poly[i][j], b = poly[i][(j+1)%(poly[i].size())];\n\t\t\t\tdouble l = h[i] / tan(phy);\n\t\t\t\ta2 = vec2d(a.x - l*cos(th), a.y - l*sin(th));\n\t\t\t\tb2 = vec2d(b.x - l*cos(th), b.y - l*sin(th));\n\t\t\t\tvec.push_back(Region(make_pair(a, a2), make_pair(a2, b2), make_pair(b2, b), make_pair(b, a)));\n\t\t\t}\n\t\t}\n\t\tV = vec.size();\n\t\t\n\t\tfor(int i = 0; i < V; i++) G[i].clear();\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tdouble dist = inf;\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\t\tdist = min(dist, distSS(vec[i].seg[k].first, vec[i].seg[k].second,\n\t\t\t\t\t\t\tvec[j].seg[l].first, vec[j].seg[l].second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG[i].push_back(edge(j, dist));\n\t\t\t\tG[j].push_back(edge(i, dist));\n\t\t\t}\n\t\t}\n\t\t\n\t\tS = V, T = V+1;\n\t\tG[S].clear(), G[T].clear();\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tdouble dist = inf;\n\t\t\tif(isInTriangle(vec[i].seg[0].first, vec[i].seg[1].first, vec[i].seg[2].first, s)\n\t\t\t|| isInTriangle(vec[i].seg[0].first, vec[i].seg[2].first, vec[i].seg[3].first, s)){\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tdist = min(dist, distSP(vec[i].seg[j].first, vec[i].seg[j].second, s));\n\t\t\t\t}\n\t\t\t}\n\t\t\tG[S].push_back(edge(i, dist));\n\t\t\tG[i].push_back(edge(S, dist));\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tdouble dist = inf;\n\t\t\tif(isInTriangle(vec[i].seg[0].first, vec[i].seg[1].first, vec[i].seg[2].first, t)\n\t\t\t|| isInTriangle(vec[i].seg[0].first, vec[i].seg[2].first, vec[i].seg[3].first, t)){\n\t\t\t\tdist = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tdist = min(dist, distSP(vec[i].seg[j].first, vec[i].seg[j].second, t));\n\t\t\t\t}\n\t\t\t}\n\t\t\tG[T].push_back(edge(i, dist));\n\t\t\tG[i].push_back(edge(T, dist));\n\t\t}\n\t\tV += 2;\n\t\t\n\t\tdijkstra();\n\t\t\n\t\t//for(int i = 0; i < V; i++) cout << dist[i] << \" \"; cout << endl;\n\t\tprintf(\"%.11f\\n\", dist[T]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nbool check(vector<Polygon> &polies,Segment &seg,set<int> skip) {\n  rep(i,(int)polies.size()) {\n    if( skip.count(i) ) continue;\n    rep(j,(int)polies[i].size()) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%(int)polies[i].size()]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment seg1,Segment seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\ndouble dijkstra(vector<vector<Edge>> &G) {\n  int V = G.size();\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,vector<double> &Hs,vector<Polygon> &polies,double theta,double phi,vector<Point> &ep) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,(int)polies[i].size()) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  vector<vector<Edge>> G(2+N);\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\trep(k,(int)polies[j].size()) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  set<int> skip;\n\t  skip.insert(j);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,(int)polies[j].size()) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%(int)polies[j].size()]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%(int)polies[j].size()],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  set<int> skip;\n\t  skip.insert(j);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      \n      rep(k,(int)polies[i].size()) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%(int)polies[i].size()]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%(int)polies[j].size()]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    set<int> skip;\n\t    skip.insert(i);\n\t    skip.insert(j);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(G));\n  \n}\n\nint main(){\n  int N;\n  while( cin >> N, N ) {\n    vector<double> Hs(N);\n    vector<Polygon> polies(N);\n    rep(i,N) {\n      int V;\n      cin >> V >> Hs[i];\n      polies[i].resize(V);\n      rep(j,V) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    vector<Point> ep(2);\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,Hs,polies,toRad(theta),toRad(phi),ep);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nP unit(const P &p){\n    return p/abs(p);\n}\nP rotate(const P &p, double rad){\n    return p *P(cos(rad), sin(rad));\n}\n\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\ndouble distanceLP(const L &l, const P &p) {\n    return abs(cross(l[1]-l[0], p-l[0])) /abs(l[1]-l[0]);\n}\ndouble distanceSP(const L &s, const P &p) {\n    if(dot(s[1]-s[0], p-s[0]) < EPS) return abs(p-s[0]);\n    if(dot(s[0]-s[1], p-s[1]) < EPS) return abs(p-s[1]);\n    return distanceLP(s, p);\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = -ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    int n = v.size();\n    sort(v.begin(), v.end());\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<VP> poly(n);\n        vector<double> h(n);\n        for(int i=0; i<n; i++){\n            int nv;\n            cin >> nv >> h[i];\n            poly[i].resize(2*nv);\n            for(int j=0; j<nv; j++){\n                double x,y;\n                cin >> x >> y;\n                poly[i][j] = P(x, y);\n            }\n        }\n\n        double theta, phi;\n        cin >> theta >> phi;\n        P dir = rotate(P(-1, 0), theta/180 *PI) /tan(phi/180 *PI);\n        vector<VP> con(n);\n        for(int i=0; i<n; i++){\n            int nv = poly[i].size()/2;\n            for(int j=0; j<nv; j++){\n                poly[i][nv +j] = poly[i][j] +h[i]*dir;\n            }\n            con[i] = convex(poly[i]);\n        }\n        \n        double sx,sy,gx,gy;\n        cin >> sx >> sy >> gx >> gy;\n        P s(sx, sy), g(gx, gy);\n        vector<vector<double> > adj(n+2, vector<double>(n+2, INF));\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                double dist = INF;\n                int ni = con[i].size();\n                int nj = con[j].size();\n                for(int k=0; k<ni; k++){\n                    for(int l=0; l<nj; l++){\n                        dist = min(dist, distanceSS(L(con[i][k], con[i][(k+1)%ni]), L(con[j][l], con[j][(l+1)%nj])));\n                    }\n                }\n                adj[i][j] = adj[j][i] = dist;\n            }\n            double sdist = INF, gdist = INF;\n            int ni = con[i].size();\n            for(int j=0; j<ni; j++){\n                sdist = min(sdist, distanceSP(L(con[i][j], con[i][(j+1)%ni]), s));\n                gdist = min(gdist, distanceSP(L(con[i][j], con[i][(j+1)%ni]), g));\n            }\n            if(in_poly(s, con[i]) >= 0) sdist = 0;\n            if(in_poly(g, con[i]) >= 0) gdist = 0;\n            adj[n][i] = adj[i][n] = sdist;\n            adj[n+1][i] = adj[i][n+1] = gdist;\n        }\n\n        for(int k=0; k<n+2; k++){\n            for(int i=0; i<n+2; i++){\n                for(int j=0; j<n+2; j++){\n                    adj[i][j] = min(adj[i][j], adj[i][k] +adj[k][j]);\n                }\n            }\n        }\n        cout << fixed << setprecision(10);\n        cout << adj[n][n+1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n;++i)\nusing namespace std;\n\nusing R = long double;\nconst R EPS = 1e-9;\nconst R PI = acos(-1.0);\nconst R INF = 1e10;\ninline int sgn(R x){return (x > EPS) - (x < -EPS);}\n\nusing P = complex<R>;\nconst P O = P(0.0);\nusing L = struct{P s,t;};\nusing VP = vector<P>;\nusing VL = vector<L>;\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\n\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\nP proj(L l,P p){ R u = real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\nauto & operator >> (istream &is,P &p){R x,y; is >> x >> y; p=P(x,y); return is;}\n\nbool iss(L a,L b){\n\tint sa = sdet(a.s,a.t,b.s) * sdet(a.s,a.t,b.t);\n\tint sb = sdet(b.s,b.t,a.s) * sdet(b.s,b.t,a.t);\n\treturn max(sa,sb) < 0;\n}\n\nR dsp(L l,P p){\n\tP h = proj(l,p);\n\tif(sdot(l.s,l.t,p)<=0) h = l.s;\n\tif(sdot(l.t,l.s,p)<=0) h = l.t;\n\treturn abs(p-h);\n}\n\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nbool in_polygon(const VL &pol,const P &p){\n\tconst int n = pol.size();\n\tint res = 0;\n\trep(i,n){\n\t\tL l = pol[i];\n\t\tif(sdet(p,l.s,l.t) == 0 and sdot(p,l.s,l.t)<=0) return true;\n\t\tbool f = sgn(imag(p-l.s))>=0,s = sgn(imag(p-l.t))<0;\n\t\tif(sgn(imag(l.t-l.s))*sdet(l.s,l.t,p)==1 and f==s) res += 2*f-1;\n\t}\n\treturn res!=0;\n}\n\nint main(void){\n\tint cnt = 0;\n\tint n;\n\twhile(cin >> n,n){\n\t\tcerr << cnt++ << endl;\n\t\tVP pol[110];\n\t\tR h[110];\n\n\t\trep(i,n){\n\t\t\tint nv;\n\t\t\tcin >> nv >> h[i];\n\t\t\trep(j,nv){\n\t\t\t\tP p;\n\t\t\t\tcin >> p;\n\t\t\t\tpol[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\n\t\tR theta,phi;\n\t\tcin >> theta >> phi;\n\t\t\n\t\ttheta = theta / 180.0 * PI;\n\t\tphi = phi / 180.0 * PI;\n\n\t\tP s,t;\n\t\tcin >> s >> t;\n\n\t\tvector<VL> buildings[110];\n\t\trep(i,n){\n\t\t\tconst int nv = pol[i].size();\n\t\t\tconst R d = h[i]/tan(phi);\n\t\t\trep(j,nv){\n\t\t\t\tVL cur;\n\t\t\t\tVP point;\n\t\t\t\tpoint.push_back(pol[i][j]);\n\t\t\t\tpoint.push_back(pol[i][(j+1)%nv]);\n\t\t\t\tpoint.push_back(pol[i][(j+1)%nv] - polar(d,theta));\n\t\t\t\tpoint.push_back(pol[i][j] - polar(d,theta));\n\n\t\t\t\trep(k,4) cur.push_back(L{point[k],point[(k+1)%4]});\n\t\t\t\tbuildings[i].push_back(cur);\n\t\t\t}\n\t\t}\n\n\t\tR dist[110][110];\n\t\tconst int total = n + 2;\n\t\trep(i,total)rep(j,total) dist[i][j]=(i==j)?0:INF;\n\n\t\trep(i,n)rep(j,i){\n\t\t\tR cur = INF;\n\t\t\tfor(auto &vpi:buildings[i]){\n\t\t\t\tfor(auto &vpj:buildings[j]){\n\t\t\t\t\tfor(auto &si:vpi){\n\t\t\t\t\t\tfor(auto &sj:vpj){\n\t\t\t\t\t\t\tcur = min(cur,dss(si,sj));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tdist[i][j]=dist[j][i]=cur;\n\t\t}\n\n\t\tbool st = true;\n\t\trep(i,n){\n\t\t\tR cur[2] = {INF,INF};\n\t\t\tfor(auto &vpi:buildings[i]){\n\t\t\t\tfor(auto &si:vpi){\n\t\t\t\t\tcur[0] = min(cur[0],dsp(si,s));\t\n\t\t\t\t\tcur[1] = min(cur[1],dsp(si,t));\n\t\t\t\t\tif(iss(si,L{s,t})) st=false;\n\t\t\t\t}\n\t\t\t\tif(in_polygon(vpi,s)) cur[0] = 0.0;\n\t\t\t\tif(in_polygon(vpi,t)) cur[1] = 0.0;\n\t\t\t}\n\n\t\t\tdist[n][i] = dist[i][n] = cur[0];\n\t\t\tdist[n+1][i] = dist[i][n+1] = cur[1];\n\t\t}\n\t\t\t\t\n\t\tif(st) dist[n][n+1] = abs(s-t);\n\n\t\tcout.precision(20);\t\t\n\t\trep(k,total)rep(i,total)rep(j,total) dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\tcout << fixed << dist[n][n+1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon &poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nint N,VN[110];\ndouble Hs[110];\nPolygon polies[110];\nPoint ep[2];\n\nbool check(Segment &seg,unordered_set<int> &skip) {\n  rep(i,N) {\n    if( skip.count(i) ) continue;\n    rep(j,VN[i]) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%VN[i]]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment &seg1,Segment &seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\nvector<Edge> G[110];\ndouble dijkstra(int V) {\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,double theta,double phi) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,VN[i]) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    VN[i] = (int)polies[i].size();\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  rep(i,N+2) G[i].clear();\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\tunordered_set<int> skip;\n\tskip.insert(j);\n\n\trep(k,VN[j]) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,VN[j]) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%VN[j]]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%VN[j]],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      unordered_set<int> skip;\n      skip.insert(i);\n      skip.insert(j);\n      \n      rep(k,VN[i]) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%VN[i]]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%VN[j]]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(N+2));\n  \n}\n\nint main(){\n  while( cin >> N, N ) {\n    rep(i,N) {\n      cin >> VN[i] >> Hs[i];\n      polies[i].resize(VN[i]);\n      rep(j,VN[i]) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,toRad(theta),toRad(phi));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n \nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n  \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n \nS getS(vecP &t,int id){\n  int n=t.size();\n  return S(t[id%n],t[(id+1)%n]);\n}\n\nint N;\nvecP A[100];\nint H[100];\ndouble dir;\ndouble inr;\ndouble G[100][100];\n\ndouble calc(int from,int to){\n  if( inPolygon(A[from],A[to][0]) )return 0.0;\n  if( inPolygon(A[to], A[from][0]) )return 0.0;\n\n  double res=1e9;\n  for(int i=0;i<(int)A[from].size();i++){\n    S s0=getS(A[from],i);\n    for(int j=0;j<(int)A[to].size();j++){\n      S s1=getS(A[to],j);\n      res=min(res, distSS(s0,s1) );\n    }\n  }\n  return res;\n}\n\ndouble calcDist(vecP &t,P p){\n  if(inPolygon(t,p))return 0.0;\n  double res=1e9;\n  for(int i=0;i<(int)t.size();i++){\n    S s=getS(t,i);\n    res=min(res, distSP(s,p) );\n  }\n  return res;\n}\n\ndouble change(double x){\n  return x/360.0 * 2.0*PI;\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      A[i].clear();\n      int v;\n      cin>>v>>H[i];\n      A[i].resize(v);\n      for(int j=0;j<v;j++){\n        int x,y;\n        cin>>x>>y;\n        A[i][j]=P(x,y);\n      }\n    }\n    cin>>dir>>inr;\n    dir=change(dir);\n    inr=change(inr);\n    \n    P base=P( -cos(dir), -sin(dir) );\n    for(int i=0;i<N;i++){\n      int size=A[i].size();\n      // R*sin(inr)=H\n      double height=H[i];\n      double R=height/sin(inr);\n      double W=Sqrt(R*R-height*height);\n      P v=base*W;\n      for(int j=0;j<size;j++){\n        P np=A[i][j]+v;\n        A[i].push_back(np);\n      }\n      A[i]=convexHull(A[i]);\n    }\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n        if(i==j)G[i][j]=0;\n        else G[i][j]=calc(i,j);\n      }\n    }\n\n    for(int k=0;k<N;k++)\n      for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n          G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n    P si,ti;\n    int x,y;\n    cin>>x>>y;\n    si=P(x,y);\n    \n    cin>>x>>y;\n    ti=P(x,y);\n    double ans=1e9;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        ans=min( ans, calcDist(A[i],si) + calcDist(A[j],ti) + G[i][j] );\n\n    printf(\"%.10f\\n\",ans);\n    \n  }\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// cos a\nlong double costh(long double a, long double b,\n                  long double c) {\n  return (b * b + c * c - a * a) / (2.0L * b * c);\n}\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : a-> b ,counter clockwise? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP projection(CP s, CP t, CP p) {\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\n\nCP reflection(CP s, CP t, CP p) {\n  CP tmp = (projection(s, t, p) - p);\n  tmp *= 2;\n  return p + tmp;\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP s, CP t, CP p) {\n  // if not use end point, dot(s - p, t - p) < 0\n  return abs(cross(s - p, t - p)) <= 1e-10 &&\n         dot(s - p, t - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP s, CP t, CP p) {\n  return abs(cross(t - s, p - s) / abs(t - s));\n}\n\n// segmentver.\nlong double distSP(CP s, CP t, CP p) {\n  if(dot(t - s, p - s) < 0) return abs(p - s);\n  if(dot(s - t, p - t) < 0) return abs(p - t);\n  return distLP(s, t, p);\n}\n\n// segment and segment\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  if(iscross(a, b, c, d)) return 0.0L;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\n// counter clockwise\nbool is_convex(const vector<CP> &v) {\n  int n = v.size();\n  for(int i = 0; i < n; ++i)\n    if(cross(v[(i + 1) % n] - v[i],\n             v[(i + 2) % n] - v[(i + 1) % n]) < -EPS)\n      return 0;\n  return 1;\n}\n\nvector<CP> convex_hull(vector<CP> &ps) {\n  auto lmd = [&](const CP &l, const CP &r) {\n    if(l.X != r.X) return l.X < r.X;\n    return l.Y < r.Y;\n  };\n  vector<CP> qs;\n  int psize = ps.size();\n  sort(ps.begin(), ps.end(), lmd);\n  int k = 0;\n  qs.resize(psize * 2);\n  for(int i = 0; i < psize; ++i) {\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  for(int i = psize - 2, t = k; i >= 0; --i) {\n    while(k > t && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\nlong double convex_diameter(vector<CP> &newv) {\n  vector<CP> v = convex_hull(newv);\n  int n = v.size(), i = 0, j = 0;\n  if(n == 2) return abs(v[0] - v[1]);\n  for(int k = 0; k < n; ++k) {\n    if(v[k].X < v[i].X) i = k;\n    if(v[k].X > v[j].X) j = k;\n  }\n  long double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(v[i] - v[j]));\n    if(cross(v[(i + 1) % n] - v[i], v[(j + 1) % n] - v[j]) <\n       0)\n      (++i) %= n;\n    else\n      (++j) %= n;\n  }\n  return res;\n}\n\nvector<CP> convex_cut(const vector<CP> &v, const CP &s,\n                      const CP &t) {\n  vector<CP> res;\n  int n = v.size();\n  for(int i = 0; i < n; ++i) {\n    CP nows = v[i], nowt = v[(i + 1) % n];\n    if(cross(t - s, nows - s) >= -EPS) res.push_back(nows);\n    if(cross(t - s, nows - s) * cross(t - s, nowt - s) < 0)\n      res.push_back(intersectionLL(s, t, nows, nowt));\n  }\n  return res;\n}\n\nstruct Circle {\n  CP o;\n  long double r;\n  Circle(long double _x = 0.0L, long double _y = 0.0L,\n         long double _r = 0.0L)\n      : o(CP(_x, _y)), r(_r) {}\n  Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n};\n\nvoid intersectionCC(Circle c1, Circle c2, CP &res1,\n                    CP &res2) {\n  long double d = abs(c1.o - c2.o);\n  long double arg = acos(costh(c2.r, c1.r, d));\n  res1 = (c2.o - c1.o) * CP(cos(arg), sin(arg));\n  res1 *= c1.r / abs(res1);\n  res1 += c1.o;\n  res2 = reflection(c1.o, c2.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid intersectionCL(Circle ci, CP s, CP t, CP &res1,\n                    CP &res2) {\n  res1 = res2 = projection(s, t, ci.o);\n  long double r = sqrtl(ci.r * ci.r - norm(res1 - ci.o));\n  t -= s;\n  t *= r / abs(t);\n  res1 += t;\n  res2 -= t;\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid contactCP(Circle ci, CP p, CP &res1, CP &res2) {\n  long double d = abs(ci.o - p);\n  if(abs(d - ci.r) <= EPS) {\n    res1 = res2 = p;\n    return;\n  }\n  else if(d < ci.r) {\n    res1 = res2 = CP(-1e18, -1e18);\n    return;\n  }\n  long double arg = asin(ci.r / d);\n  res1 = (ci.o - p) * CP(cos(arg), sin(arg));\n  res1 *= (d * cos(arg)) / abs(res1);\n  res1 += p;\n  res2 = reflection(p, ci.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nlong double polygonarea(const vector<CP> &v) {\n  int n = v.size();\n  long double res = 0;\n  for(int i = 0; i < n; ++i)\n    res +=\n        (v[(i - 1 + n) % n].X - v[(i + 1) % n].X) * v[i].Y;\n  return res / 2.0L;\n}\n\nlong long calc_clockwise(CP s, CP t, CP p) {\n  t -= s;\n  p -= s;\n  if(cross(t, p) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(t, p) < -EPS) return -1; //\"CLOCK_WISE\"\n  if(dot(t, p) < 0) return 2;       // ONLINE_BACK\n  if(norm(t) < norm(p)) return -2;  // ONLINE_FRONT\n  return 0;                         // ON_SEGMENT\n}\n\nstruct buil {\n  int n, h;\n  vector<CP> v;\n};\n\nlong long n;\nlong double theta, phi;\nvector<buil> buildings;\nvector<vector<long double>> dist;\n\nlong double solve();\nbool iscontain(CP p, vector<CP> &v);\n\nint main() {\n  cout << fixed << setprecision(10);\n  while(1) {\n    int x, y;\n    cin >> n;\n    if(n == 0) break;\n    buildings.clear();\n    buildings.resize(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> buildings[i].n >> buildings[i].h;\n      buildings[i].v.resize(buildings[i].n);\n      for(int j = 0; j < buildings[i].n; ++j) {\n        cin >> x >> y;\n        buildings[i].v[j] = CP(x, y);\n      }\n    }\n    cin >> theta >> phi;\n    theta *= PI / 180.0L;\n    phi *= PI / 180.0L;\n    theta += PI;\n    cin >> x >> y;\n    buildings.push_back({1, 0, {CP(x, y)}});\n    cin >> x >> y;\n    buildings.push_back({1, 0, {CP(x, y)}});\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong double solve() {\n  CP e = CP(cos(theta), sin(theta));\n  e /= abs(e);\n  for(int i = 0; i < n; ++i) {\n    vector<CP> tmp = buildings[i].v;\n    int vsize = buildings[i].n, h = buildings[i].h;\n    for(int j = 0; j < vsize; ++j)\n      tmp.push_back(tmp[j] +\n                    e * (h / (long double)tan(phi)));\n    buildings[i].v = convex_hull(tmp);\n    buildings[i].n = buildings[i].v.size();\n  }\n  n += 2;\n  dist.assign(n, vector<long double>(n, 1e18));\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j)\n      for(int k = 0; k < buildings[i].n; ++k) {\n        if(iscontain(buildings[i].v[k], buildings[j].v)) {\n          dist[i][j] = dist[j][i] = 0;\n          break;\n        }\n        for(int l = 0; l < buildings[j].n; ++l) {\n          CP sk = buildings[i].v[k],\n             tk = buildings[i].v[(k + 1) % buildings[i].n],\n             sl = buildings[j].v[l],\n             tl = buildings[j].v[(l + 1) % buildings[j].n];\n          if(i < (n - 2))\n            dist[i][j] =\n                min(dist[i][j], distSP(sk, tk, sl));\n          if(j < (n - 2))\n            dist[i][j] =\n                min(dist[i][j], distSP(sl, tl, sk));\n          dist[i][j] = min(dist[i][j], abs(sk - sl));\n        }\n      }\n  for(int k = 0; k < n; ++k)\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        dist[i][j] =\n            min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist[n - 2][n - 1];\n}\n\nbool iscontain(CP p, vector<CP> &v) {\n  bool ch = 0, onseg = 0;\n  int vsize = v.size();\n  for(int i = 0; i < vsize; ++i) {\n    onseg |= on_seg(v[i], v[(i + 1) % vsize], p);\n    CP s = v[i] - p, t = v[(i + 1) % vsize] - p;\n    if(s.Y > t.Y) swap(s, t);\n    if(s.Y * t.Y <= 0 && t.Y > 0 && cross(s, t) < 0)\n      ch = !ch;\n  }\n  return ch || onseg;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,n) for (int i = (a);i<(n);i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nusing namespace std;\ndouble INF = 1e+9;\nint N;\ndouble theta, phi;\nint V[103], H[103];\ndouble x[103][13], y[102][13];\ndouble sx, sy, tx, ty;\ndouble mindist[103][103];\nstruct Point{\n  double x,y;\n  Point operator - (const Point& p) {return Point{x - p.x, y - p.y};}\n};\nstruct Segment{\n  Point p1,p2;\n};\n\ndouble norm(Point a){return a.x*a.x + a.y*a.y;}\ndouble abs(Point a){return sqrt(norm(a));}\ndouble dot(Point a, Point b){return a.x * b.x + a.y * b.y;}\ndouble cross(Point a, Point b){return a.x * b.y - a.y * b.x;}\n\nint ccw(Point p1,Point p2, Point p3){\n  Point a = p2 - p1;\n  Point b = p3 - p1;\n  if(cross(a,b) > EPS)return 1;\n  if(cross(a,b) < -EPS)return -1;\n  if(dot(a,b) < -EPS)return 2;\n  if(norm(a)< norm(b)) return -2;\n  return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n  return ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0;\n}\n\nbool intersect_strict(Point p1, Point p2, Point p3, Point p4){\n  return ccw(p1,p2,p3) * ccw(p1,p2,p4) < 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) < 0;\n}\n\n\nbool intersect(Segment s1, Segment s2){\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersect_strict(Segment s1, Segment s2){\n  return intersect_strict(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistSP(Segment s, Point p){\n  if(dot(s.p2 - s.p1, p - s.p1) < EPS) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < EPS) return abs(p - s.p2);\n  return abs(cross(s.p2 - s.p1, p - s.p1) / abs(s.p2 - s.p1));\n}\n\ndouble getDist(Segment s1, Segment s2){\n  if(intersect(s1.p1, s1.p2, s2.p1,s2.p2)) return 0.0;\n  return min(min(getDistSP(s1, s2.p1),getDistSP(s1,s2.p2)),\n             min(getDistSP(s2, s1.p1), getDistSP(s2, s1.p2)));\n}\nusing Polygon = vector<Point>;\n\nint contains(Polygon& g, Point p){\n  int n = g.size();\n  bool x = false;\n  REP(i,n){\n    Point a = g[i] - p, b = g[(i+1)%n] - p;\n    if(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y > b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n  }\n  return x ? 2 : 0;\n}\n\nvector<Point> buildings[103][2];// 0 is builidings, 1 is shade\nint main(){\n  while(cin >> N, N){\n    REP(i,N){\n      cin >> V[i] >> H[i];\n      REP(j,V[i]){\n        cin >> x[i][j] >> y[i][j];\n      }\n    }\n    cin >> theta >> phi;\n    cin >> sx >> sy >> tx >> ty;\n    REP(i,N){\n      buildings[i][0].clear();\n      buildings[i][1].clear();\n      REP(j,V[i]){\n        buildings[i][0].push_back(Point{x[i][j], y[i][j]});\n      }\n      bool cross[15];\n      int crossct = 0;\n      fill(cross,cross + V[i], false);\n      double xshade = -H[i] / tan(phi / 180.0 * PI) * cos(theta/ 180.0 * PI);\n      double yshade = -H[i] / tan(phi / 180.0 * PI) * sin(theta/ 180.0 * PI);\n      REP(j,V[i]){\n        REP(k,V[i]){\n          Segment s2 = Segment{Point{x[i][k],y[i][k]}, Point{x[i][(k + 1) % V[i]], y[i][(k + 1) % V[i]]}};\n          if(intersect_strict(Segment{Point{x[i][j], y[i][j]}, Point{x[i][j] + xshade, y[i][j] + yshade}}, s2) || contains(buildings[i][0], Point{x[i][j] + xshade, y[i][j] + yshade})){\n            cross[j] = true;\n            crossct++;\n            break;\n          }\n        }\n      }\n      if(crossct == 0){\n        \n        double rxshade = H[i] / tan(phi / 180.0 * PI) * cos(theta / 180.0 * PI);\n        double ryshade = H[i] / tan(phi / 180.0 * PI) * sin(theta/ 180.0 * PI);\n        REP(j,V[i]){\n          REP(k,V[i]){\n            Segment s2 = Segment{Point{x[i][k],y[i][k]}, Point{x[i][(k + 1) % V[i]], y[i][(k + 1) % V[i]]}};\n            if(intersect_strict(Segment{Point{x[i][j], y[i][j]}, Point{x[i][j] + rxshade, y[i][j] + ryshade}}, s2) || contains(buildings[i][0], Point{x[i][j] + rxshade, y[i][j] + ryshade})){\n              cross[j] = true;\n              break;\n            }\n          }\n        }\n        REP(j,V[i]){\n          if(!cross[j] && crossct > 0){\n            buildings[i][1].push_back(Point{x[i][j] , y[i][j]});\n          }\n          buildings[i][1].push_back(Point{x[i][j] + xshade, y[i][j] + yshade});\n          if(!cross[j] && crossct == 0){\n            buildings[i][1].push_back(Point{x[i][j] , y[i][j]});\n          }\n        }\n\n      }else{\n        REP(j,V[i]){\n          if(!cross[j]){\n            if(cross[(j+V[i]-1)%V[i]]){\n              buildings[i][1].push_back(Point{x[i][j] , y[i][j]});\n            }\n            buildings[i][1].push_back(Point{x[i][j] + xshade, y[i][j] + yshade});\n            if(cross[(j+1)%V[i]]){\n              buildings[i][1].push_back(Point{x[i][j] , y[i][j]});\n            }\n          }else{\n            buildings[i][1].push_back(Point{x[i][j] , y[i][j]});\n          }\n        }\n      }\n    }\n    buildings[N][1].clear();\n    buildings[N + 1][1].clear();\n    buildings[N][1].push_back(Point{sx, sy});\n    buildings[N + 1][1].push_back(Point{tx, ty});\n    N+=2;\n    V[N-1] = V[N-2] = 1;\n    fill(mindist[0], mindist[N], INF);\n    REP(i,N){\n      FOR(j,i + 1,N){\n        REP(p_i,2){\n          REP(p_j,2){\n            for(int a = 0;a <buildings[i][p_i].size();a++)\n              if(j >= N-2 && contains(buildings[i][p_i],buildings[j][1][0])){\n                mindist[j][i] = mindist[i][j] = min(0.0,mindist[j][i]);\n              }else{\n                for(int b = 0;b < buildings[j][p_j].size();b++){\n                  int i_p_i_a_N = buildings[i][p_i].size();\n                  int j_p_j_b_N = buildings[j][p_j].size();\n                  Segment s1 = Segment{buildings[i][p_i][a], buildings[i][p_i][(a+1)%i_p_i_a_N]};\n                  Segment s2 = Segment{buildings[j][p_j][b], buildings[j][p_j][(b+1)%j_p_j_b_N]};\n                  mindist[j][i] = mindist[i][j]\n                    = min(getDist(s1,s2),mindist[i][j]);\n                }\n              }\n          }\n        }\n      }\n    }\n    REP(k,N){\n      REP(i,N){\n        REP(j,N){\n          mindist[i][j] = min(mindist[i][j], mindist[i][k] + mindist[k][j]);\n        }\n      }\n    }\n    cout << fixed << setprecision(8) << mindist[N-2][N-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; scanf(\"%lf%lf\",&x,&y); return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nld G[110][110];\nld Hs[110];\nPolygon polys[110];\nld solve(){\n    ld res = 0;\n    for(int i = 0; i < N;i++) polys[i].clear();\n//    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; scanf(\"%d%lf\",&n,&Hs[i]);\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull(polys[i]);\n    }\n    \n    fill(*G,*G+110*110,LINF);\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                if(is_in_polygon(polys[j],polys[i][k]) > 0){\n                    D = 0;\n                    break;\n                }\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n             ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    \n    \n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n//    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf (1e9)\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ \n    return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ \n    return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nint n;\nPolygon P1[MAX];\nPolygon P2[MAX];\ndouble h[MAX];\ndouble a,b;\nPoint s,t;\nvector<pid> e[MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    e[i].clear();\n    P1[i].clear();\n    P2[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,double cost){\n  e[from].pb(mp(to,cost));\n  e[to].pb(mp(from,cost));\n}\n\ndouble dijkstra(){\n  priority_queue<pdi,vector<pdi>,greater<pdi> > pq;\n  double d[MAX];\n  fill(d,d+MAX,inf);\n  d[n]=0;\n  pq.push(mp(0,n));\n\n  while(pq.size()){\n    pdi u=pq.top();\n    pq.pop();\n\n    if(d[u.s]-u.f<-eps)continue;\n//    if(u.s==n+1)return d[u.s];\n\n    FOR(i,0,e[u.s].size()){\n      int next=e[u.s][i].f;\n      double cost=d[u.s]+e[u.s][i].s;\n      if(cost-d[next]<-eps){\n        d[next]=cost;\n        pq.push(mp(cost,next));\n      }\n    }\n  }\n  return d[n+1];\n}\n\ndouble getdis(int i,int j){\n  double dis=inf;\n  FOR(k,0,P2[i].size())\n    if(contains(P2[j],P2[i][k])!=0)return 0.0;\n  FOR(k,0,P2[j].size())\n    if(contains(P2[i],P2[j][k])!=0)return 0.0;\n  FOR(k,0,P2[i].size()){\n    Segment seg1(P2[i][k],P2[i][(k+1)%P2[i].size()]);\n    FOR(l,0,P2[j].size()){\n      Segment seg2(P2[j][l],P2[j][(l+1)%P2[j].size()]);\n      dis=min(dis,getDistance(seg1,seg2));\n    }\n  }\n  return dis;\n}\n\ndouble getdis(int i,Point p){\n  if(contains(P2[i],p)!=0)return 0.0;\n  double dis=inf;\n  int m=P2[i].size();\n  FOR(j,0,m){\n    Segment seg(P2[i][j],P2[i][(j+1)%m]);\n    dis=min(dis,getDistanceSP(seg,p));\n  }\n  return dis;\n}\n\ndouble solve(){\n  FOR(i,0,n){\n    double dis=h[i]/tan(b/180.0*pi);\n    Vector v=Point(-cos(a/180.0*pi),-sin(a/180.0*pi))*dis;\n    Polygon temp=P1[i];\n    FOR(j,0,P1[i].size())temp.pb(P1[i][j]+v);\n    P2[i]=convex_hull(temp);\n  }\n  FOR(i,0,n)\n    FOR(j,i,n)\n      add_edge(i,j,getdis(i,j));\n\n  FOR(i,0,n){\n    add_edge(n,i,getdis(i,s));\n    add_edge(n+1,i,getdis(i,t));\n  }\n  return dijkstra();\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      Polygon p;\n      int N;\n      cin>>N>>h[i];\n      FOR(j,0,N){\n        int x,y;\n        cin>>x>>y;\n        p.pb(Point(x,y));\n      }\n      P1[i]=p;\n    }\n    cin>>a>>b;\n    cin>>s.x>>s.y>>t.x>>t.y;\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) cerr << #a << \" \" << a << endl\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\nusing ll = long long;\nusing vi = vector<int>;\n\nconst double EPS = 1e-8;\nconst double inf = 1e12;\n\nusing P = complex<double>;\nnamespace std{\n  bool operator < (const P &a, const P &b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool isnan(const P &p){\n    return isnan(real(p)) or isnan(imag(p));\n  }\n}\ndouble cross(const P &p, const P &q){\n  return imag(conj(p)*q);\n}\ndouble dot(const P &p, const P &q){\n  return real(conj(p)*q);\n}\nstruct L : public vector<P>{\n  L(const P &p, const P &q){\n    push_back(p);\n    push_back(q);\n  }\n};\nusing G = vector<P>;\n\nint ccw(P a,P b, P c){\n  b -= a; c -= a;\n  if(cross(b,c)>0) return 1;\n  if(cross(b,c)<0) return -1;\n  if(dot(b,c)<0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n\ndouble intersectSP(const L &s, const P &p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ndouble intersectSS(const L &s, const L &t){\n  if(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n     ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0) return true;\n  if(intersectSP(s,t[0]) or intersectSP(s,t[1]) or\n     intersectSP(t,s[0]) or intersectSP(t,s[1])) return true;\n  return false;\n}\n\nP projection(const L &l, const P &p){\n  double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L&s, const P &p){\n  const P r = projection(s,p);\n  if(intersectSP(s,r)) return abs(r-p);\n  return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s, const L &t){\n  if(intersectSS(s,t)) return 0;\n  return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n\t     min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\ndouble distanceGP(const G &g, const P &p){\n  int n = g.size();\n  double ans = inf;\n  rep(i,n){\n    L l(g[i],g[(i+1)%n]);\n    ans = min(ans, distanceSP(l,p));\n  }\n  return ans;\n}\ndouble distanceGG(const G &g, const G &h){\n  double ans = inf;\n  int n = g.size(), m = h.size();\n  rep(i,g.size()) rep(j,h.size()){\n    L l1(g[i],g[(i+1)%n]), l2(h[j],h[(j+1)%m]);\n    ans = min(ans, distanceSS(l1,l2));\n  }\n  return ans;\n}\n\nvector<P> convex_hull(vector<P> ps){\n  int n = ps.size(), k = 0;\n  sort(ps.begin(),ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool containGP(const G &g, const P &p){\n  double sum = 0;\n  int n = g.size();\n  rep(i,n){\n    int j = (i+1)%n;\n    if(intersectSP(L(g[i],g[j]-g[i]),p))\n      return true;\n    sum += arg((g[j]-p)/(g[i]-p));\n  }\n  return abs(sum) > 1;\n}\n\nusing Cost = double;\nclass node{\npublic:\n  int v;\n  Cost d;\n  node(int a_, Cost b_):v(a_),d(b_){}\n  bool operator <(const node &n) const { return d > n.d; }\n};\nclass edge{\npublic:\n  int to;\n  Cost d;\n  edge(){}\n  edge(int to_, Cost d_) : to(to_), d(d_) {}\n};\nclass dijkstra{\npublic:\n  vector<vector<edge>> G;\n  vector<Cost> dist;\n  \n  dijkstra(int s, const vector<vector<edge>> &G_):G(G_){\n    dist.resize(G.size(),inf);\n\n    priority_queue<node> que;\n    que.push(node(s,0));\n    dist[s] = 0;\n\n    while(!que.empty()){\n      int v = que.top().v;\n      Cost d = que.top().d;\n      que.pop();\n\n      rep(i,G[v].size()){\n\tCost tmp = d + G[v][i].d;\n\tif(dist[G[v][i].to] > tmp + EPS){\n\t  dist[G[v][i].to] = tmp;\n\t  que.push(node(G[v][i].to, tmp));\n\t}\n      }\n    }\n  }\n};\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vector<G> gs(n);\n    vi hs(n);\n    rep(i,n){\n      int nv; cin >> nv;\n      cin >> hs[i];\n      rep(j,nv){\n\tdouble x, y; cin >> x >> y;\n\tgs[i].push_back(P(x,y));\n      }\n    }\n    int inttheta; cin >> inttheta;\n    double theta = double(inttheta) * M_PI / 180;\n    if(inttheta <= 180){\n      theta -= M_PI;\n    }else{\n      theta -= M_PI;\n    }\n    double phi; cin >> phi;\n    phi *= M_PI / 180;\n    P s, t;\n    double x, y; cin >> x >> y;\n    s = P(x, y);\n    cin >> x >> y;\n    t = P(x, y);\n\n    rep(i,n){\n      P diff = polar(hs[i]/tan(phi),theta);\n      int m = gs[i].size();\n      rep(j,m){\n\tgs[i].push_back(gs[i][j]+diff);\n      }\n      gs[i] = convex_hull(gs[i]);\n    }\n\n    vector<vector<edge>> g(n+2);\n    rep(i,n){\n      double d;\n      if(containGP(gs[i],s)) d = 0;\n      else d = distanceGP(gs[i],s);\n      g[i].emplace_back(n,d);\n      g[n].emplace_back(i,d);\n    }\n    rep(i,n){\n      double d;\n      if(containGP(gs[i],t)) d = 0;\n      else d = distanceGP(gs[i],t);\n      g[i].emplace_back(n+1,d);\n      g[n+1].emplace_back(i,d);\n    }\n    rep(i,n) FOR(j,i+1,n){\n      double d = distanceGG(gs[i],gs[j]);\n      g[i].emplace_back(j,d);\n      g[j].emplace_back(i,d);\n    }\n    double d = abs(s-t);\n    g[n].emplace_back(n+1,d);\n    g[n+1].emplace_back(n,d);\n    dijkstra dijk(n, g);\n    printf(\"%.10lf\\n\", dijk.dist[n+1]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<deque>\n#include<cstring>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<queue>\n#include<set>\n#include<unordered_set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// -- BEGIN --\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if((int)s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++) {\n    for(int n=(int)u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--) u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i=(int)s.size()-3; i>=0 ; i--) {\n    for(int n=(int)l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--) l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = (int)u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//????§???¢poly?????????????????????????????????p????????¨??????????????????????????????  \nbool inPolygon(Polygon &poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ????????????????????¨angle???nan?????????sum???nan??????????????¬\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // ?????????????????????????????????????????¨?????????????????§??\\????????????????????? \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n\n\n// -- END -- \n\nconst bool debug = false;\n\nstruct Edge {\n  int dst;\n  double cost;\n};\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\n\nbool check(vector<Polygon> &polies,Segment &seg,unordered_set<int> &skip) {\n  rep(i,(int)polies.size()) {\n    if( skip.count(i) ) continue;\n    rep(j,(int)polies[i].size()) {\n      Segment ururu_beam = Segment(polies[i][j],polies[i][(j+1)%(int)polies[i].size()]);\n      if( equals(cross(seg.p1-seg.p2,ururu_beam.p1-ururu_beam.p2),0) ) continue;\n      if( intersectSS(seg,ururu_beam) ) return false;\n    }\n  }\n  return true;\n}\n\nSegment nearestSS(Segment &seg1,Segment &seg2) {\n  Segment seg = Segment(seg1.p1,seg2.p1);\n  double mini = abs(seg1.p1-seg2.p1);\n  /*\n  if( LT(abs(seg1.p1-seg2.p2),mini) ) {\n    mini = abs(seg1.p1-seg2.p2);\n    seg = Segment(seg1.p1,seg2.p2);\n  }\n  if( LT(abs(seg1.p2-seg2.p1),mini) ) {\n    mini = abs(seg1.p2-seg2.p1);\n    seg = Segment(seg1.p2,seg2.p1);\n  }\n  if( LT(abs(seg1.p2-seg2.p2),mini) ) {\n    mini = abs(seg1.p2-seg2.p2);\n    seg = Segment(seg1.p2,seg2.p2);\n  }\n  */\n  Point proj = projection(seg2,seg1.p1);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p1-proj),mini) ) {\n    mini = abs(seg1.p1-proj);\n    seg = Segment(seg1.p1,proj);\n  }\n  proj = projection(seg2,seg1.p2);\n  if( onSegment(seg2.p1,seg2.p2,proj) && LT(abs(seg1.p2-proj),mini) ) {\n    mini = abs(seg1.p2-proj);\n    seg = Segment(seg1.p2,proj);\n  }\n  proj = projection(seg1,seg2.p1);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p1-proj),mini) ) {\n    mini = abs(seg2.p1-proj);\n    seg = Segment(seg2.p1,proj);\n  }\n  proj = projection(seg1,seg2.p2);\n  if( onSegment(seg1.p1,seg1.p2,proj) && LT(abs(seg2.p2-proj),mini) ) {\n    mini = abs(seg2.p2-proj);\n    seg = Segment(seg2.p2,proj);\n  }\n  return seg;\n}\n\nstruct Data {\n  int cur;\n  double w;\n  bool operator < ( const Data &data ) const {\n    if( !equals(w,data.w) ) return LT(data.w,w);\n    return cur > data.cur;\n  }\n};\n\ndouble dijkstra(vector<vector<Edge>> &G) {\n  int V = G.size();\n  vector<double> mini(V,1e8);\n  mini[0] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){0,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    if( data.cur == 1 ) return data.w;\n    rep(i,(int)G[data.cur].size()) {\n      Edge &e = G[data.cur][i];\n      if( LT(data.w+e.cost,mini[e.dst]) ) {\n\tmini[e.dst] = data.w+e.cost;\n\tQ.push((Data){e.dst,mini[e.dst]});\n      }\n    }\n  }\n  return mini[1];\n}\n\nvoid compute(int N,vector<double> &Hs,vector<Polygon> &polies,double theta,double phi,vector<Point> &ep) {\n  // ??±?????????????????´????????????\n  rep(i,N) {\n    vector<Point> ps;\n    Vector v = Vector(cos(theta),sin(theta));\n    rep(j,(int)polies[i].size()) {\n      ps.push_back(polies[i][j]);\n      ps.push_back(polies[i][j]-v*Hs[i]/tan(phi));\n    }\n    polies[i] = andrewScan(ps);\n    \n    if( debug ) {\n      puts(\"\");\n      cout << i << \"-th polygon\" << endl;\n      rep(j,(int)polies[i].size()) {\n\tcout << polies[i][j] << endl;\n      }\n    }\n\n  }\n  \n  // ?§??????????+??±?????????????????´?????????????????§?§??????§??????????????§??????????????±??????????????¢????±??????°?????????\n  vector<vector<Edge>> G(2+N);\n  rep(i,2) { //?§??????????????????±??????????????´??????????????¢\n    rep(j,N) {\n      if( inPolygon(polies[j],ep[i]) ) {\n\tG[i].push_back((Edge){2+j,0});\n\tG[2+j].push_back((Edge){i,0});\n      } else {\n\tdouble mini = 1e8;\n\tunordered_set<int> skip;\n\tskip.insert(j);\n\n\trep(k,(int)polies[j].size()) {\n\t  Segment seg = Segment(ep[i],polies[j][k]);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\trep(k,(int)polies[j].size()) {\n\t  Point p = projection(Line(polies[j][k],polies[j][(k+1)%(int)polies[j].size()]),ep[i]);\n\t  if( !onSegment(polies[j][k],polies[j][(k+1)%(int)polies[j].size()],p) ) continue;\n\t  Segment seg = Segment(ep[i],p);\n\t  if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t    mini = abs(seg.p1-seg.p2);\n\t  }\n\t}\n\tif( !equals(mini,1e8) ) {\n\t  G[i].push_back((Edge){2+j,mini});\n\t  G[2+j].push_back((Edge){i,mini});\n\t}\n      }\n    }\n  }\n  rep(i,N) { //??±??????????????´???i????????±??????????????´???j???????????¢\n    REP(j,i+1,N) {\n      double mini = 1e8;\n      unordered_set<int> skip;\n      skip.insert(i);\n      skip.insert(j);\n      \n      rep(k,(int)polies[i].size()) {\n\tSegment seg1 = Segment(polies[i][k],polies[i][(k+1)%(int)polies[i].size()]);\n\trep(l,(int)polies[j].size()) {\n\t  Segment seg2 = Segment(polies[j][l],polies[j][(l+1)%(int)polies[j].size()]);\n\t  \n\t  if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && ( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) )  ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else if( !equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) && intersectSS(seg1,seg2) ) {\n\t    mini = 0;\n\t    goto Skip;\n\t  } else {\n\t    Segment seg = nearestSS(seg1,seg2);\n\t    if( LT(abs(seg.p1-seg.p2),mini) && check(polies,seg,skip) ) {\n\t      mini = abs(seg.p1-seg.p2);\n\t    }\n\t  }\n\t}\n      }\n    Skip:;\n      if( !equals(mini,1e8) ) {\n\tG[2+i].push_back((Edge){2+j,mini});\n\tG[2+j].push_back((Edge){2+i,mini});\n      }\n    }\n  }\n  \n  if( debug ) {\n    rep(i,2+N) {\n      puts(\"\");\n      if( i < 2 ) cout << \"(\" << i << \")\" << \" From : \" << ep[i] << endl;\n      else        cout << \"(\" << i << \")\" << \" From : \" << \"polygon \" << i-2 << \" (\" << polies[i-2][0] << \")\" << endl;\n      rep(j,(int)G[i].size()) {\n\tcout << \"  To : \" << G[i][j].dst << \", Weight : \" << G[i][j].cost << endl;\n      }\n    } \n  }\n\n  // dijkstra\n  printf(\"%.10f\\n\",dijkstra(G));\n  \n}\n\nint main(){\n  int N;\n  while( cin >> N, N ) {\n    vector<double> Hs(N);\n    vector<Polygon> polies(N);\n    rep(i,N) {\n      int V;\n      cin >> V >> Hs[i];\n      polies[i].resize(V);\n      rep(j,V) cin >> polies[i][j].x >> polies[i][j].y;\n    }\n    double theta, phi;\n    cin >> theta >> phi;\n    vector<Point> ep(2);\n    rep(i,2) cin >> ep[i].x >> ep[i].y;\n    compute(N,Hs,polies,toRad(theta),toRad(phi),ep);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\nusing namespace std;\n\n#define repi(i,j,n) for (int i = (j); i < (n); ++i)\n#define rep(i,n) repi(i,0,n)\n#define INF 1e9\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n// Geometry short ver\n\nclass P {\npublic:\n    double x, y;\n    P(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n    P operator + (P p) {\n        return P(x + p.x, y + p.y);\n    }\n    P operator - (P p) {\n        return P(x - p.x, y - p.y);\n    }\n    P operator * (double c) {\n        return P(c * x, c * y);\n    }\n    P operator / (double c) {\n        return P(x / c, y / c);\n    }\n    bool operator < (const P &p) const {\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n    bool operator == (const P &p) const {\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n\n    double norm() {\n        return (x * x + y * y);\n    }\n\n    double abs() {\n        return sqrt(norm());\n    }\n};\n\ntypedef P V;\n\ndouble dot(V a, V b) {\n    return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(V a, V b) {\n    return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(V a) {\n    return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(V a) {\n    return sqrt(norm(a));\n}\n\nclass S {\npublic:\n    P s, e; // start, end\n    S(P s = P(), P e = P()) : s(s), e(e) {}\n};\n\ntypedef S L;\n\ntypedef vector<P> Polygon;\n\ndouble dP(P a, P b) {\n    return (a - b).abs();\n}\n\ndouble dL(L l, P p) {\n    return abs(cross(l.e - l.s, p - l.s) / abs(l.e - l.s));\n}\n\ndouble dS(S s, P p) {\n    if (dot(s.e - s.s, p - s.s) < 0.0) return abs(p - s.s);\n    if (dot(s.s - s.e, p - s.e) < 0.0) return abs(p - s.e);\n    return dL(s, p);\n}\n\nconst int CCW = 1, CW = -1, OB = 2, OF = -2, OS = 0;\n\nint ccw(P x, P y, P z) {\n    V a = y - x, b = z - x;\n\n    if (cross(a, b) > EPS) return CCW;\n    if (cross(a, b) < -EPS) return CW;\n    if (dot(a, b) < -EPS) return OB;\n    if (a.norm() < b.norm()) return OF;\n    return OS;\n}\n\nbool intersect(P a, P b, P c, P d) {\n    return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(S a, S b) {\n    return intersect(a.s, a.e, b.s, b.e);\n}\n\ndouble dSS(S a, S b) {\n    if (intersect(a, b)) return 0.0;\n    return min(min(dS(a, b.s), dS(a, b.e)), min(dS(b, a.s), dS(b, a.e)));\n}\n\nP crossP(S a, S b) {\n    V base = b.e - b.s;\n    double d1 = abs(cross(base, a.s - b.s));\n    double d2 = abs(cross(base, a.e - b.s));\n    double t = d1 / (d1 + d2);\n    return a.s + (a.e - a.s) * t;\n}\n\n/* IN 2, ON 1, OUT 0*/\nint contains(Polygon g, P p) {\n    int n = g.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        P a = g[i] - p, b = g[(i + 1) % n] - p;\n        if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\n\nPolygon andrewScan(Polygon s) {\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n\n    int ssize = s.size();\n\n    // upper\n    for (int i = 2; i < ssize; ++i) {\n        for (int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == CCW; n--) {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    // lower\n    for (int i = ssize - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == CCW; n--) {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) {\n        l.push_back(u[i]);\n    }\n\n    return l;\n}\n\n// building\nclass B {\npublic:\n    int n, h;\n    Polygon p;\n    vector<S> s;\n};\n\nint n;\nint nv, h, sx, sy, tx, ty;\ndouble x, y;\ndouble wf[110][110];\nint th, ps;\ndouble ans;\nPolygon p;\nvector<B> b;\n\ninline void makeConvexHull() {\n    int size_;\n\n    rep(i,n) {\n        size_ = b[i].p.size();\n        rep(j,size_) {\n            b[i].p.push_back(P(b[i].p[j].x + b[i].h * cos(rad(th + 180.0)) / tan(rad(ps)),\n                               b[i].p[j].y + b[i].h * sin(rad(th + 180.0)) / tan(rad(ps))));\n        }\n\n        b[i].p = andrewScan(b[i].p);\n        size_ = b[i].p.size();\n\n        rep(j,size_) {\n            b[i].s.push_back(S(b[i].p[j], b[i].p[(j + 1) % size_]));\n        }\n    }\n}\n\ninline double solve() {\n    makeConvexHull();\n\n    int sizei, sizej;\n    double mi, tmp;\n\n    rep(i,n) {\n        repi(j,i+1,n) {\n            sizei = b[i].s.size();\n            sizej = b[j].s.size();\n            mi = INF;\n\n            rep(k,sizei) {\n                rep(l,sizej) {\n                    tmp = dSS(b[i].s[k], b[j].s[l]);\n                    mi = min(mi, tmp);\n                    if (mi == 0) break;\n                }\n                if (mi == 0) break;\n            }\n\n            wf[i + 1][j + 1] = wf[j + 1][i + 1] = mi;\n        }\n    }\n\n    // P(sx, sy)\n    rep(i,n) {\n        mi = INF;\n        if (contains(b[i].p, P(sx, sy)) != 0) {\n            wf[0][i + 1] = wf[i + 1][0] = 0.0;\n        }\n        else {\n            sizei = b[i].s.size();\n            rep(j,sizei) {\n                tmp = dS(b[i].s[j], P(sx, sy));\n                mi = min(mi, tmp);\n                if (mi == 0) break;\n            }\n            wf[0][i + 1] = wf[i + 1][0] = mi;\n        }\n    }\n\n    // P(tx, ty)\n    rep(i,n) {\n        mi = INF;\n        if (contains(b[i].p, P(tx, ty)) != 0) {\n            wf[n + 1][i + 1] = wf[i + 1][n + 1] = 0.0;\n        }\n        else {\n            sizei = b[i].s.size();\n            rep(j,sizei) {\n                tmp = dS(b[i].s[j], P(tx, ty));\n                mi = min(mi, tmp);\n                if (mi == 0) break;\n            }\n            wf[n + 1][i + 1] = wf[i + 1][n + 1] = mi;\n        }\n    }\n\n    // distance from P(sx, xy) to P(tx, ty)\n    wf[0][n + 1] = wf[n + 1][0] = dP(P(sx, sy), P(tx, ty));\n\n    // wf\n    rep(k,n+2) {\n        rep(i,n+2) {\n            rep(j,n+2) {\n                wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n            }\n        }\n    }\n\n    return wf[0][n+1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        b.resize(n);\n        rep(i,n+2) {\n            rep(j,n+2) {\n                if (i == j) wf[i][j] = 0;\n                else wf[i][j] = INF;\n            }\n        }\n\n        rep(i,n) {\n            cin >> nv >> h;\n\n            p.resize(nv);\n            b[i].n = nv;\n            b[i].h = h;\n\n            rep(j,nv) {\n                cin >> x >> y;\n                p[j] = P(x, y);\n            }\n\n            b[i].p = p;\n            p.clear();\n        }\n        cin >> th >> ps;\n        cin >> sx >> sy >> tx >> ty;\n\n\n        ans = solve();\n\n        cout << fixed << setprecision(10) << ans << endl;\n        b.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\nint N;\nld solve(){\n    ld res = 0;\n    \n    vector<double> Hs(N);\n    vector<Polygon> polys(N);\n    for(int i = 0; i < N;i++){\n        int n; cin >> n >> Hs[i];\n        for(int j = 0; j < n;j++){\n            polys[i].push_back(input_point());\n        }\n    }\n    double theta,phi; cin >> theta >> phi;\n    theta = theta*pi/180; phi = phi*pi/180;\n    Point S = input_point(), T = input_point();\n    for(int i = 0; i < N;i++){\n        int sz = (int)polys[i].size();\n        ld L = Hs[i]/tan(phi);\n        for(int j = 0; j < sz;j++){\n            ld x = polys[i][j].real(), y = polys[i][j].imag();\n            polys[i].push_back(Point(x - L*cos(theta),y - L*sin(theta)));\n        }\n        polys[i] = convex_hull2(polys[i]);\n    }\n    \n    \n    vector<vector<ld>> G(N+2,vector<ld>(N+2,LINF));\n    for(int i = 0; i < N+2;i++) G[i][i] = 0;\n    \n    for(int i = 0; i < N;i++){\n        for(int j = i+1; j < N;j++){\n            if(i == j) continue;\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                for(int l = 0; l < polys[j].size();l++){\n                    Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                    Line l2(polys[j][l],polys[j][(l+1)%polys[j].size()]);\n                    D = min(D,dist_ss(l1,l2));\n                }\n            }\n            \n            G[i][j] = G[j][i] = D;\n        }\n    }\n    for(int i = 0; i < N;i++){\n        if(is_in_polygon(polys[i],S) > 0){\n            G[N][i] = G[i][N] = 0;\n        }else{\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,S));\n            }\n            G[N][i] = G[i][N] = D;\n        }\n        \n        if(is_in_polygon(polys[i], T) > 0){\n            G[N+1][i] = G[i][N+1] = 0;\n        }else{\n            ld D = LINF;\n            for(int k = 0; k < polys[i].size(); k++){\n                Line l1(polys[i][k],polys[i][(k+1)%polys[i].size()]);\n                D = min(D,dist_sp(l1,T));\n            }\n            G[N+1][i] = G[i][N+1] = D;\n        }\n    }\n    G[N][N+1] = G[N+1][N] = abs(S-T);\n    for(int i = 0; i < N+2;i++){\n        for(int j = 0; j < N+2;j++){\n            for(int k = 0; k < N+2;k++){\n                G[j][k] = min(G[j][k],G[j][i] + G[i][k]);\n            }\n        }\n    }\n    res = G[N][N+1];\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        cout << fixed << setprecision(12) << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2827 Industrial Convex Pillar City\n// 2018.3.19 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n\n// 高速数値入出力\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()   // 整数の入力（負数対応）\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\n\t\tc = gc();\n\t\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n\n// 平面幾何関連\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\ntypedef struct { int n; PP p[50]; } POLY;   // 多角形に含まれる最大頂点 50\n\n#define INF\t\t\t1e16\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vset(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vmul(PP p1, PP p2) {\n\tPP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r;\n}\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) { return hypot(p1.x - p2.x, p1.y - p2.y); }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\n\n// 点が線分上にあるか\nint isPonSeg(PP p, SEG s)\n{\n\tdouble d, x = p.x, y = p.y;\n\tdouble x1 = s.s.x, y1 = s.s.y, x2 = s.e.x, y2 = s.e.y;\n\n\tif (x1 > x2) d = x1, x1 = x2, x2 = d;\n\tif (y1 > y2) d = y1, y1 = y2, y2 = d;\n\treturn (EQ(x1, x) || x1 <= x) && (EQ(x, x2) || x <= x2) &&\n\t\t   (EQ(y1, y) || y1 <= y) && (EQ(y, y2) || y <= y2) &&\n\t\t    EQ((y - y1)*(x2 - x1), (y2 - y1)*(x - x1));\n}\n\n// 点とライン間の距離\ndouble disP2Ln(PP p, SEG s, int *on)\n{\n\tdouble us, ub;\n\tdouble xx, yy;\n\tdouble x = p.x, y = p.y;\n\tdouble sx = s.s.x, sy = s.s.y, ex = s.e.x, ey = s.e.y;\n\n\tif (isPonSeg(p, s)) return 0;\n\n\tus = (x - sx) * (ex - sx) + (y - sy) * (ey - sy);\n\tub = (ex - sx) * (ex - sx) + (ey - sy) * (ey - sy);\n\n\t/* closest point falls within the line segment */\n\t*on = (EQ(us, 0) || us >= 0) && (EQ(us, ub) || us <= ub);\n\n\tif (EQ(us, 0))  xx = sx, yy = sy;\n\telse if (EQ(us, ub)) xx = ex, yy = ey;\n\telse {\n\t\txx = sx + (ex - sx) * us / ub;\n\t\tyy = sy + (ey - sy) * us / ub;\n\t}\n\treturn hypot(x - xx, y - yy);\n}\n\n// 点と線分間の距離\ndouble disP2Seg(PP p, SEG s)\n{\n\tint on;\n\tdouble d, t;\n\n\td = INF;\n\tif (isPonSeg(p, s)) return 0;\n\tt = disP2Ln(p, s, &on); if (on && t < d) d = t;\n\tif ((t = dist(p, s.s)) < d) d = t;\n\tif ((t = dist(p, s.e)) < d) d = t;\n\treturn d;\n}\n\n// 線分が交差しているか\nint isCrossSeg(SEG s1, SEG s2)\n{\n\tdouble x11 = s1.s.x, y11 = s1.s.y, x12 = s1.e.x, y12 = s1.e.y;\n\tdouble x21 = s2.s.x, y21 = s2.s.y, x22 = s2.e.x, y22 = s2.e.y;\n\tdouble s11, s12, s21, s22;\n\tint r = 0;\n\n\ts11 = (x22 - x21) * (y11 - y21) + (y22 - y21) * (x21 - x11);\n\ts12 = (x22 - x21) * (y12 - y21) + (y22 - y21) * (x21 - x12);\n\ts21 = (x12 - x11) * (y21 - y11) + (y12 - y11) * (x11 - x21);\n\ts22 = (x12 - x11) * (y22 - y11) + (y12 - y11) * (x11 - x22);\n\tif (EQ(s11,0)) { if (r == 0) r = isPonSeg(s1.s, s2); }\n\telse if (EQ(s12,0)) { if (r == 0) r = isPonSeg(s1.e, s2); }\n\telse if (EQ(s21,0)) { if (r == 0) r = isPonSeg(s2.s, s1); }\n\telse if (EQ(s22,0)) { if (r == 0) r = isPonSeg(s2.e, s1); }\n\telse {\n\t\tr = ((s11 <= 0 && s12 >= 0) || (s11 >= 0 && s12 <= 0)) &&\n\t\t\t((s21 <= 0 && s22 >= 0) || (s21 >= 0 && s22 <= 0));\n\t}\n\treturn r;\n}\n\n// 線分間の距離\ndouble disSeg2Seg(SEG s1, SEG s2)\n{\n\tint on;\n\tdouble t, d = INF;\n\n\tif (isCrossSeg(s1, s2)) return 0;\n\n\tt = disP2Ln(s1.s, s2, &on); if (on && t < d) d = t;\n\tt = disP2Ln(s1.e, s2, &on); if (on && t < d) d = t;\n\tt = disP2Ln(s2.s, s1, &on); if (on && t < d) d = t;\n\tt = disP2Ln(s2.e, s1, &on); if (on && t < d) d = t;\n\tt = dist(s1.s, s2.s); if (t < d) d = t;\n\tt = dist(s1.s, s2.e); if (t < d) d = t;\n\tt = dist(s1.e, s2.s); if (t < d) d = t;\n\tt = dist(s1.e, s2.e); if (t < d) d = t;\n\treturn d;\n}\n\n// 点の内包　　内部:2, 線分上:1, 外 0\nint contains(PP p, POLY poly)\n{\n\tint i, f;\n\tPP a, b, t;\n\n\tf = 0;\n\tfor (i = 0; i < poly.n; i++) {\n\t\ta = vsub(poly.p[i], p), b = vsub(poly.p[i + 1], p);\n\t\tif (EQ(cross(a, b), 0) && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) t = a, a = b, b = t;\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) f = !f;\n\t}\n\treturn f ? 2 : 0;\n}\n\n// 点と多角形間の距離\ndouble disP2Poly(PP p, POLY poly)\n{\n\tint i;\n\tdouble d, t;\n\tSEG s;\n\n\t// 点が多角形に含まれているか。\n\tif (contains(p, poly) > 0) return 0;\n\td = INF;\n\tfor (i = 0; i < poly.n; i++) {\n\t\ts.s = poly.p[i], s.e = poly.p[i+1];\n\t\tif ((t = disP2Seg(p, s)) < d) d = t;\n\t}\n\treturn d;\n}\n\n// 多角形間の距離\ndouble disPoly2Poly(POLY po1, POLY po2)\n{\n\tint i, j;\n\tdouble t, d = INF;\n\tSEG s1, s2;\n\n\tfor (i = 0; i < po1.n; i++) {\n\t\ts1.s = po1.p[i], s1.e = po1.p[i + 1];\n\t\tfor (j = 0; j < po2.n; j++) {\n\t\t\ts2.s = po2.p[j], s2.e = po2.p[j + 1];\n\t\t\tt = disSeg2Seg(s1, s2); if (t < d) d = t;\n\t\t}\n\t}\n\treturn d;\n}\n\nint cmp(const void *a, const void *b) {\n\tif (((PP *)a)->y - ((PP *)b)->y) return dcmp(((PP *)a)->y - ((PP *)b)->y);\n\treturn dcmp(((PP *)a)->x - ((PP *)b)->x);\n}\n\n// 凸包の作成\nint convexHull(int n, PP *ps, PP *po)\n{\n\tint i, k, j = 0;\n\n\tqsort(ps, n, sizeof(PP), cmp);\n\tfor (i = 0; i < n; i++) {\n\t\twhile (j > 1 && cross(vsub(po[j - 1], po[j - 2]), vsub(ps[i], po[j - 1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\tk = j;\n\tfor (i = n - 2; i >= 0; i--) {\n\t\twhile (j > k && cross(vsub(po[j - 1], po[j - 2]), vsub(ps[i], po[j - 1])) <= 0) j--;\n\t\tpo[j++] = ps[i];\n\t}\n\treturn j - 1;\n}\n\n\n// 優先度付きキュー（ダイクストラ法に使用）\n#define MAX 30000\ntypedef struct { int id; double t; } QUE;\nQUE que[MAX]; int qsize;\nint qmax;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\n// id は多角形識別番号、t はその間の最短距離\nvoid enq(int id, double t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;  if (qsize > qmax) qmax = qsize;\n\tque[i].id = id, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define DEG2RAD 0.01745329251994329576923690768489\t\t// pi/180\nint THETA, PHI;   // 太陽の向きと高さ\nPP S, T;          // スタート、ゴール位置\nint N;            // 多角形の数\nPOLY data[105]; int high[105];     // 元の入力データ\nPOLY poly[105];   // 日陰を含めた多角形（凸包）\ndouble dis[105][105];    // 多角形間の距離\nchar vis[205];     // ダイクストラ内部作業用\n\ndouble dijkstra(int start, int goal)\n{\n\tint i, s;\n\tdouble d;\n\n\tqsize = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].id; d = que[0].t, deq();\n\t\tif (s == goal) return d;\n\t\tif (vis[s]) continue;\n\t\tvis[s] = 1;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tif (i == s || vis[i]) continue;\n\t\t\tenq(i, d + dis[s][i]);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, j, k;\n\tdouble len, _cos, _sin;\n\n\twhile (N = in()) {\n\t\t// データ入力\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tdata[i].n = in();\n\t\t\thigh[i] = in();\n\t\t\tfor (j = 0; j < data[i].n; j++) data[i].p[j].x = in(), data[i].p[j].y = in();\n\t\t}\n\t\tTHETA = in(), PHI = in();\n\t\t_cos = cos((THETA+180)*DEG2RAD);\n\t\t_sin = sin((THETA+180)*DEG2RAD);\n\t\tS.x = in(), S.y = in();\n\t\tT.x = in(), T.y = in();\n\n\t\t// 多角形に対し、それぞれの頂点に対応する日陰の頂点をもとめ、凸包でひとつにまとめる\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tk = data[i].n;\n\t\t\tlen = high[i] / tan(PHI*DEG2RAD);\n\t\t\tfor (j = 0; j < data[i].n; j++) {\n\t\t\t\tdata[i].p[k++] = vadd(data[i].p[j], vset(len*_cos, len*_sin));  // 日陰の頂点を追加\n\t\t\t}\n\t\t\tdata[i].n = k;\n\t\t\tdata[i].p[k] = data[i].p[0];    // 凸包作成に必要\n\n\t\t\tpoly[i].n = convexHull(k, data[i].p, poly[i].p);   // 凸包の作成\n\t\t\tpoly[i].p[poly[i].n] = poly[i].p[0];\n#if 0\n\t\t\tprintf(\"Poly[%d] n=%d: \", i, poly[i].n);\n\t\t\tfor (j = 0; j <= poly[i].n; j++) printf(\" (%lf,%lf)\", poly[i].p[j].x, poly[i].p[j].y);\n\t\t\tprintf(\"\\n\");\n#endif\n\t\t}\n\n\t\t// 多角形間の距離\n\t\tfor (i = 1; i <= N; i++) for (j = i + 1; j <= N; j++)\n\t\t\tdis[i][j] = dis[j][i] = disPoly2Poly(poly[i], poly[j]);\n\n\t\t// 点と多角形間の距離\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tdis[0][i] = dis[i][0] = disP2Poly(S, poly[i]);\n\t\t\tdis[N + 1][i] = dis[i][N + 1] = disP2Poly(T, poly[i]);\n\t\t}\n\t\tdis[0][N + 1] = dis[N + 1][0] = dist(S, T);\n\t\tN += 2;\n#if 0\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tprintf(\"dis [%d] -> \", i);\n\t\t\tfor (j = 0; j < N; j++) printf(\" [%d]%lf,\", j, dis[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n#endif\n\t\tprintf(\"%.20lf\\n\", dijkstra(0, N - 1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-4;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double x = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x < x) {\n        x = p.x;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n        double theta = Math.acos(cos);\n        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n        if (ccw + EPS > 0) {\n          theta = 2 * Math.PI - theta;\n        }\n        theta += EPS;\n        theta %= 2 * Math.PI;\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = new P(dx, dy);\n        }\n      }\n      if (next == siten) {\n        break;\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-6;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  P kaiten(double theta, P p) {\n    return new P(p.x * Math.cos(theta) - p.y * Math.sin(theta),\n        p.x * Math.sin(theta) + p.y * Math.cos(theta));\n  }\n\n  double getKakudo(P v, P w) {\n    double atom = Math.atan2(v.y, v.x);\n    if (atom < 0) {\n      atom = 2 * Math.PI + atom;\n    }\n    P next = kaiten(-atom, w);\n    double theta = Math.atan2(next.y, next.x);\n    if (theta <= 0) {\n      return -theta;\n    } else {\n      return 2 * Math.PI - theta;\n    }\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double x = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x < x) {\n        x = p.x;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        P w = new P(dx, dy);\n        double theta = getKakudo(vec, w);\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = w;\n        }\n//        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n//            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n//        double theta = Math.acos(cos);\n//        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n//        if (ccw + EPS > 0) {\n//          theta = 2 * Math.PI - theta;\n//        }\n//        theta += EPS;\n//        theta %= 2 * Math.PI;\n//        if (theta < min) {\n//          min = theta;\n//          next = p;\n//          wec = new P(dx, dy);\n//        }\n      }\n      if (next == siten) {\n        break;\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-6;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  P kaiten(double theta, P p) {\n    return new P(p.x * Math.cos(theta) - p.y * Math.sin(theta),\n        p.x * Math.sin(theta) + p.y * Math.cos(theta));\n  }\n\n  double getKakudo(P v, P w) {\n    double atom = Math.atan2(v.y, v.x);\n    if (atom < 0) {\n      atom = 2 * Math.PI + atom;\n    }\n    P next = kaiten(-atom, w);\n    double theta = Math.atan2(next.y, next.x);\n    if (theta <= 0) {\n      return -theta;\n    } else {\n      return 2 * Math.PI - theta;\n    }\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double value = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x * 100000 - p.y < value) {\n        value = p.x * 100000 - p.y;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        P w = new P(dx, dy);\n        double theta = getKakudo(vec, w);\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = w;\n        }\n//        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n//            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n//        double theta = Math.acos(cos);\n//        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n//        if (ccw + EPS > 0) {\n//          theta = 2 * Math.PI - theta;\n//        }\n//        theta += EPS;\n//        theta %= 2 * Math.PI;\n//        if (theta < min) {\n//          min = theta;\n//          next = p;\n//          wec = new P(dx, dy);\n//        }\n      }\n      if (next == siten) {\n        break;\n      }\n      if (ite != siten) {\n        double dx = siten.x - ite.x;\n        double dy = siten.y - ite.y;\n        P w = new P(dx, dy);\n        double theta = getKakudo(vec, w);\n        if (Math.abs(min - theta) < EPS) {\n          break;\n        }\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-13;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double x = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x < x) {\n        x = p.x;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n        double theta = Math.acos(cos);\n        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n        if (ccw + EPS > 0) {\n          theta = 2 * Math.PI - theta;\n        }\n        theta += EPS;\n        theta %= 2 * Math.PI;\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = new P(dx, dy);\n        }\n      }\n      if (next == siten) {\n        break;\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b, boolean debugFlag) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr, node.index == 2 && i == 5);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-13;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double x = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x < x) {\n        x = p.x;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n        double theta = Math.acos(cos);\n        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n        if (ccw + EPS > 0) {\n          theta = 2 * Math.PI - theta;\n        }\n        theta += EPS;\n        theta %= 2 * Math.PI;\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = new P(dx, dy);\n        }\n      }\n      if (next == siten) {\n        break;\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b, boolean debugFlag) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr, node.index == 2 && i == 5);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double x = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x < x) {\n        x = p.x;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n        double theta = Math.acos(cos);\n        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n        if (ccw + EPS > 0) {\n          theta = 2 * Math.PI - theta;\n        }\n        theta += EPS;\n        theta %= 2 * Math.PI;\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = new P(dx, dy);\n        }\n      }\n      if (next == siten) {\n        break;\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-6;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class P {\n    double x;\n    double y;\n\n    P(double a, double b) {\n      x = a;\n      y = b;\n    }\n  }\n\n  class Node {\n    double dist;\n    int index;\n  }\n\n  ArrayList<LineSegment> totuho(ArrayList<P> arr) {\n    ArrayList<P> sub = new ArrayList<>();\n    double x = Double.MAX_VALUE;\n    P siten = null;\n    for (P p : arr) {\n      if (p.x < x) {\n        x = p.x;\n        siten = p;\n      }\n    }\n    sub.add(siten);\n    P vec = new P(0, 1);\n    P ite = siten;\n    for (; ; ) {\n      double min = Double.MAX_VALUE;\n      P next = null;\n      P wec = null;\n      for (P p : arr) {\n        if (p == ite) {\n          continue;\n        }\n        double dx = p.x - ite.x;\n        double dy = p.y - ite.y;\n        double cos = GeomUtils.dot(vec.x, vec.y, dx, dy)\n            / (GeomUtils.abs(vec.x, vec.y) * GeomUtils.abs(dx, dy));\n        double theta = Math.acos(cos);\n        double ccw = GeomUtils.ccw(ite.x, ite.y, ite.x + vec.x, ite.y + vec.y, p.x, p.y);\n        if (ccw + EPS > 0) {\n          theta = 2 * Math.PI - theta;\n        }\n        theta += EPS;\n        theta %= 2 * Math.PI;\n        if (theta < min) {\n          min = theta;\n          next = p;\n          wec = new P(dx, dy);\n        }\n      }\n      if (next == siten) {\n        break;\n      }\n      sub.add(next);\n      ite = next;\n      vec = wec;\n    }\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    int n = sub.size();\n    for (int i = 0; i < n; ++i) {\n      P p = sub.get(i);\n      P q = sub.get((i + 1) % n);\n      LineSegment l = new LineSegment(p.x, p.y, q.x, q.y);\n      ans.add(l);\n    }\n    return ans;\n  }\n\n  ArrayList<LineSegment> p2ls(double x, double y) {\n    ArrayList<LineSegment> ans = new ArrayList<>();\n    ans.add(new LineSegment(x, y, x, y));\n    return ans;\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    if (list.size() == 1) {\n      return false;\n    }\n    boolean flag = true;\n    for (LineSegment l : list) {\n      double ccw = GeomUtils.ccw(l.x1, l.y1, l.x2, l.y2, x, y);\n      flag &= ccw - EPS <= 0;\n    }\n    return flag;\n  }\n\n  double dist(ArrayList<LineSegment> a, ArrayList<LineSegment> b) {\n    double min = Double.MAX_VALUE;\n    for (LineSegment ite : a) {\n      if (isIn(b, ite.x1, ite.y1)\n          || isIn(b, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      if (isIn(a, ite.x1, ite.y1)\n          || isIn(a, ite.x2, ite.y2)) {\n        return 0;\n      }\n    }\n    for (LineSegment ite : b) {\n      for (LineSegment jte : a) {\n        double d = ite.distance(jte);\n        min = Math.min(min, d);\n      }\n    }\n    return min;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<ArrayList<P>> list = new ArrayList<>();\n      int[] hs = new int[n];\n      for (int i = 0; i < n; ++i) {\n        int m = ni();\n        hs[i] = ni();\n        ArrayList<P> arr = new ArrayList<>();\n        for (int j = 0; j < m; ++j) {\n          int x = ni();\n          int y = ni();\n          arr.add(new P(x, y));\n        }\n        list.add(arr);\n      }\n      double theta = ni() * Math.PI / 180;\n      double gyokaku = ni() * Math.PI / 180;\n//      debug(\"kage::\");\n      for (int i = 0; i < n; ++i) {\n//        debug(\"\\t\", i);\n        ArrayList<P> kage = new ArrayList<>();\n        ArrayList<P> arr = list.get(i);\n        double nagasa = hs[i] / Math.tan(gyokaku);\n        for (P p : arr) {\n          double x = p.x + nagasa * Math.cos(theta + Math.PI);\n          double y = p.y + nagasa * Math.sin(theta + Math.PI);\n//          debug(\"\\t\\t\", x, y);\n          kage.add(new P(x, y));\n        }\n        arr.addAll(kage);\n      }\n      ArrayList<ArrayList<LineSegment>> takakukeis = new ArrayList<>();\n//      debug(\"takakukei::\");\n      for (ArrayList<P> arr : list) {\n//        debug(\"\\t\", takakukeis.size());\n        takakukeis.add(totuho(arr));\n        for (LineSegment l : takakukeis.get(takakukeis.size() - 1)) {\n//          debug(\"\\t\\t\", l.x1, l.y1);\n        }\n      }\n      double sx = ni();\n      double sy = ni();\n      double tx = ni();\n      double ty = ni();\n      takakukeis.add(p2ls(sx, sy));\n      takakukeis.add(p2ls(tx, ty));\n      PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingDouble(a -> a.dist));\n      Node atom = new Node();\n      atom.dist = 0;\n      atom.index = n;\n      queue.add(atom);\n      boolean[] done = new boolean[n + 2];\n      double[] ans = new double[n + 2];\n//      debug(\"daikusutora\");\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (done[node.index]) {\n          continue;\n        }\n//        debug(\"\\t\", node.index, node.dist);\n        done[node.index] = true;\n        ans[node.index] = node.dist;\n        for (int i = 0; i < n + 2; ++i) {\n          if (i == node.index) {\n            continue;\n          }\n          ArrayList<LineSegment> arr = takakukeis.get(i);\n          double dist = dist(takakukeis.get(node.index), arr);\n          Node next = new Node();\n          next.index = i;\n          next.dist = dist + node.dist;\n//          debug(\"\\t\\t\", next.index, dist, next.dist);\n          queue.add(next);\n        }\n      }\n      System.out.printf(\"%.5f\\n\", ans[n + 1]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  long nl() {\n    return sc.nextLong();\n  }\n\n  double nd() {\n    return Double.parseDouble(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    static boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n}"
  },
  {
    "language": "Python",
    "code": "from math import sin, cos, tan, radians\nfrom heapq import heappush, heappop\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef dot3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)\ndef cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef dist2(A, B):\n    ax, ay = A; bx, by = B\n    return (ax - bx) ** 2 + (ay - by) ** 2\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    if C0 == C1 == 0:\n        E0 = dot3(P0, P1, Q0)\n        E1 = dot3(P0, P1, Q1)\n        if not E0 < E1:\n            E0, E1 = E1, E0\n        return E0 <= dist2(P0, P1) and 0 <= E1\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef convex_hull(ps):\n    qs = []\n    n = len(ps)\n    for p in ps:\n        while len(qs) > 1 and cross3(qs[-1], qs[-2], p) >= 0:\n            qs.pop()\n        qs.append(p)\n    t = len(qs)\n    for i in range(n-2, -1, -1):\n        p = ps[i]\n        while len(qs) > t and cross3(qs[-1], qs[-2], p) >= 0:\n            qs.pop()\n        qs.append(p)\n    return qs\ndef cross2(p, q):\n    return p[0]*q[1] - p[1]*q[0]\ndef dot2(p, q):\n    return p[0]*q[0] + p[1]*q[1]\ndef dist1(p):\n    return p[0]**2 + p[1]**2\ndef segment_line_dist_d(x, p0, p1):\n    z0 = (p1[0] - p0[0], p1[1] - p0[1])\n    z1 = (x[0] - p0[0], x[1] - p0[1])\n    if 0 <= dot2(z0, z1) <= dist1(z0):\n        return cross2(z0, z1)**2 / dist1(z0)\n    z2 = (x[0] - p1[0], x[1] - p1[1])\n    return min(dist1(z1), dist1(z2))\n\ndef polygon_contain(x, ps):\n    if len(ps) == 1:\n        return 0\n    pl = len(ps)\n    return (\n        all(cross3(ps[i-1], ps[i], x) > 0 for i in range(pl)) or\n        all(cross3(ps[i-1], ps[i], x) < 0 for i in range(pl))\n    )\n\ndef convex_polygon_contain(p0, qs):\n    L = len(qs)\n    if L < 3:\n        return False\n    left = 1; right = L\n    x0, y0 = q0 = qs[0]\n    while left+1 < right:\n        mid = (left + right) >> 1\n        if cross3(q0, p0, qs[mid]) <= 0:\n            left = mid\n        else:\n            right = mid\n    if left == L-1:\n        left -= 1\n    qi = qs[left]; qj = qs[left+1]\n    v0 = cross3(q0, qi, qj)\n    v1 = cross3(q0, p0, qj)\n    v2 = cross3(q0, qi, p0)\n    if v0 < 0:\n        v1 = -v1; v2 = -v2\n    return 0 <= v1 and 0 <= v2 and v1 + v2 <= v0\n\ndef convex_polygons_intersection(ps, qs):\n    pl = len(ps); ql = len(qs)\n    if pl == 1 or ql == 1:\n        return 0\n    i = j = 0\n    while (i < pl or j < ql) and (i < 2*pl) and (j < 2*ql):\n        px0, py0 = ps0 = ps[(i-1)%pl]; px1, py1 = ps1 = ps[i%pl]\n        qx0, qy0 = qs0 = qs[(j-1)%ql]; qx1, qy1 = qs1 = qs[j%ql]\n\n        if is_intersection(ps0, ps1, qs0, qs1):\n            return 1\n\n        ax = px1 - px0; ay = py1 - py0\n        bx = qx1 - qx0; by = qy1 - qy0\n\n        v = (ax*by - bx*ay)\n        va = cross3(qs0, qs1, ps1)\n        vb = cross3(ps0, ps1, qs1)\n\n        if v == 0 and va < 0 and vb < 0:\n            return 0\n        if v == 0 and va == 0 and vb == 0:\n            i += 1\n        elif v >= 0:\n            if vb > 0:\n                i += 1\n            else:\n                j += 1\n        else:\n            if va > 0:\n                j += 1\n            else:\n                i += 1\n    return 0\n\ndef find_tangent(p0, qs):\n    L = len(qs)\n    d = L//3\n    gx = (qs[0][0] + qs[d][0] + qs[2*d][0]) / 3\n    gy = (qs[0][1] + qs[d][1] + qs[2*d][1]) / 3\n    g = (gx, gy)\n    ma = -1; mi = 2; k0 = 0; k1 = 0\n    for i in range(L):\n        v = cross3(p0, qs[i], g) / (dist2(p0, g) * dist2(p0, qs[i]))**.5\n        if v > ma:\n            k1 = i\n            ma = v\n        if v < mi:\n            k0 = i\n            mi = v\n    return k0, k1\n\ndef tangent_polygon_dist(ps, qs):\n    Lp = len(ps); Lq = len(qs)\n    pi, qi = find_tangent(qs[0], ps)\n    pj, qj = find_tangent(ps[0], qs)\n    if qi < pi:\n        qi += Lp\n    if qj < pj:\n        qj += Lq\n    res = dist2(ps[pi], qs[pj])\n    if pj < qj:\n        for i in range(pi, qi+1):\n            x = ps[i-Lp]\n            for j in range(pj, qj+1):\n                res = min(res, segment_line_dist_d(x, qs[(j-1)%Lq], qs[j-Lq]))\n    if pi < qi:\n        for j in range(pj, qj+1):\n            x = qs[j-Lq]\n            for i in range(pi, qi+1):\n                res = min(res, segment_line_dist_d(x, ps[(i-1)%Lp], ps[i-Lp]))\n    return res**.5\n\ndef polygons_dist(ps, qs):\n    if (convex_polygons_intersection(ps, qs)\n            or convex_polygon_contain(ps[0], qs)\n            or convex_polygon_contain(qs[0], ps)):\n        return 0\n    return tangent_polygon_dist(ps, qs)\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    P = [[] for i in range(N)]\n    H = [0]*N\n    for i in range(N):\n        k, h, *ps = map(int, readline().split())\n        H[i] = h\n        Pi = P[i]\n        for j in range(k):\n            x, y = ps[2*j:2*j+2]\n            Pi.append((x, y))\n    theta, phi = map(int, readline().split())\n    r_theta = radians(theta)\n    r_phi = radians(90 - phi)\n    dx = -cos(r_theta)*tan(r_phi)\n    dy = -sin(r_theta)*tan(r_phi)\n    sx, sy, tx, ty = map(int, readline().split())\n\n    for i in range(N):\n        Pi = P[i]\n        hi = H[i]\n        for j in range(len(Pi)):\n            x, y = Pi[j]\n            Pi.append((x + hi*dx, y + hi*dy))\n        Pi.sort()\n        P[i] = convex_hull(Pi)[:-1]\n        #print(P[i])\n    P.append([(sx, sy)])\n    P.append([(tx, ty)])\n\n    E = [[0]*(N+2) for i in range(N+2)]\n    dist = [10**18]*(N+2)\n    for i in range(N+2):\n        for j in range(i+1, N+2):\n            E[i][j] = E[j][i] = polygons_dist(P[i], P[j])\n    que = [(0, N)]\n    dist[N] = 0\n    while que:\n        cost, v = heappop(que)\n        if dist[v] < cost:\n            continue\n        for w in range(N+2):\n            n_cost = cost + E[v][w]\n            if n_cost < dist[w]:\n                dist[w] = n_cost\n                heappush(que, (n_cost, w))\n    print(\"%.16f\" % dist[N+1])\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::cmp::max;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    loop {\n        let n: usize = sc.read();\n        if n == 0 {\n            return;\n        }\n\n        let mut buildings = vec![];\n        for _ in 0..n {\n            let v: usize = sc.read();\n            let h: f64 = sc.read();\n            let v: Vec<(f64, f64)> = (0..v).map(|_| (sc.read(), sc.read())).collect();\n            buildings.push((h, v));\n        }\n\n        let theta: f64 = sc.read::<f64>().to_radians();\n        let phi: f64 = sc.read::<f64>().to_radians();\n        let mut points = vec![];\n        for (h, mut v) in buildings.into_iter() {\n            let r = h / phi.tan();\n            let n = v.len();\n            for i in 0..n {\n                let (x, y) = v[i];\n                let dy = -theta.sin() * r;\n                let dx = -theta.cos() * r;\n                let nx = x + dx;\n                let ny = y + dy;\n                v.push((nx, ny));\n            }\n\n            let p = v\n                .into_iter()\n                .map(|(x, y)| Point { x, y })\n                .collect::<Vec<_>>();\n            let i = extract_convex_hull(&p, false);\n            let p = i.into_iter().map(|i| p[i]).collect::<Vec<_>>();\n            points.push(p);\n        }\n\n        let sx: f64 = sc.read();\n        let sy: f64 = sc.read();\n        let tx: f64 = sc.read();\n        let ty: f64 = sc.read();\n\n        points.push(vec![Point { x: sx, y: sy }]);\n        points.push(vec![Point { x: tx, y: ty }]);\n\n        let n = points.len();\n        let mut dist = vec![vec![1e18; n]; n];\n        for i in 0..n {\n            dist[i][i] = 0.0;\n            for j in 0..i {\n                dist[i][j] = b2b_d2(&points[i], &points[j]).sqrt();\n                dist[j][i] = dist[i][j];\n            }\n        }\n\n        for k in 0..n {\n            for i in 0..n {\n                for j in 0..n {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        println!(\"{}\", dist[n - 2][n - 1]);\n    }\n}\n\nfn min<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b {\n        b\n    } else {\n        a\n    }\n}\n\nfn b2b_d2(b1: &[Point], b2: &[Point]) -> f64 {\n    let mut min_d = 1e18;\n\n    for b1i in 0..b1.len() {\n        let p0 = b1[b1i];\n        for b2i in 0..b2.len() {\n            let p1 = b2[b2i];\n            let p2 = b2[(b2i + 1) % b2.len()];\n            min_d = min(min_d, min_d2(&p0, &p1, &p2));\n        }\n\n        if is_included(&p0, b2) {\n            return 0.0;\n        }\n    }\n    for b2i in 0..b2.len() {\n        let p0 = b2[b2i];\n        for b1i in 0..b1.len() {\n            let p1 = b1[b1i];\n            let p2 = b1[(b1i + 1) % b1.len()];\n            min_d = min(min_d, min_d2(&p0, &p1, &p2));\n        }\n\n        if is_included(&p0, b1) {\n            return 0.0;\n        }\n    }\n\n    for i in 0..b1.len() {\n        for j in 0..b2.len() {\n            let dx = b1[i].x - b2[j].x;\n            let dy = b1[i].y - b2[j].y;\n            min_d = min(min_d, dx * dx + dy * dy);\n        }\n    }\n    min_d\n}\n\nfn is_included(p: &Point, convex: &[Point]) -> bool {\n    let mut convex = convex.to_vec();\n    convex.push(p.clone());\n    let c = extract_convex_hull(&convex, false);\n    if c.contains(&(convex.len() - 1)) {\n        false\n    } else {\n        true\n    }\n}\n\nfn min_d2(p0: &Point, p1: &Point, p2: &Point) -> f64 {\n    let x0 = p0.x;\n    let y0 = p0.y;\n    let x1 = p1.x;\n    let y1 = p1.y;\n    let x2 = p2.x;\n    let y2 = p2.y;\n    let a = x2 - x1;\n    let b = y2 - y1;\n    let a2 = a * a;\n    let b2 = b * b;\n    let r2 = a2 + b2;\n    let tt = -(a * (x1 - x0) + b * (y1 - y0));\n    if tt < 0.0 {\n        return (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n    }\n    if tt > r2 {\n        return (x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0);\n    }\n    let f1 = a * (y1 - y0) - b * (x1 - x0);\n    return (f1 * f1) / r2;\n}\n\npub fn extract_convex_hull(points: &[Point], contain_on_segment: bool) -> Vec<usize> {\n    let n = points.len();\n    if n <= 1 {\n        return vec![0];\n    }\n\n    let mut ps: Vec<usize> = (0..n).collect();\n    ps.sort_by(|&a, &b| {\n        if (points[a].x - points[b].x).abs() < std::f64::EPSILON {\n            points[a].y.partial_cmp(&points[b].y).unwrap()\n        } else {\n            points[a].x.partial_cmp(&points[b].x).unwrap()\n        }\n    });\n\n    let mut qs: Vec<usize> = Vec::new();\n    for &i in &ps {\n        while qs.len() > 1 {\n            let k = qs.len();\n            let det = (points[qs[k - 1]] - points[qs[k - 2]]).det(&(points[i] - points[qs[k - 1]]));\n            if det < 0.0 || (det <= 0.0 && !contain_on_segment) {\n                qs.pop();\n            } else {\n                break;\n            }\n        }\n        qs.push(i);\n    }\n\n    let t = qs.len();\n    for i in (0..(n - 1)).rev() {\n        let i = ps[i];\n        while qs.len() > t {\n            let k = qs.len();\n            let det = (points[qs[k - 1]] - points[qs[k - 2]]).det(&(points[i] - points[qs[k - 1]]));\n            if det < 0.0 || (det <= 0.0 && !contain_on_segment) {\n                qs.pop();\n            } else {\n                break;\n            }\n        }\n        qs.push(i);\n    }\n\n    qs.pop();\n    qs\n}\n\n#[derive(Debug, Copy, Clone)]\npub struct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl std::ops::Sub for Point {\n    type Output = Point;\n    fn sub(self, other: Point) -> Point {\n        Point {\n            x: self.x - other.x,\n            y: self.y - other.y,\n        }\n    }\n}\n\nimpl Point {\n    pub fn det(&self, other: &Point) -> f64 {\n        self.x * other.y - self.y * other.x\n    }\n}\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write_all(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]