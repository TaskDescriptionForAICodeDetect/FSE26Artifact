[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\nint main() {\n\tlong long int N, W, H;\n\tcin >> N >> W >> H;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\n\tvector<pair<long long int, long long int>>D( N );\n\tlong long int Wsum = 0, Hsum = 0;\n\tmap<long long int, long long int>xmemo, ymemo;\n\tbool kabef = false;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i].first >> D[i].second;\n\t\tif( !xmemo.count( D[i].first ) ) {\n\t\t\txmemo[D[i].first] = i;\n\t\t} else {\n\t\t\tuf.merge( xmemo[D[i].first], i );\n\t\t}\n\t\tif( !ymemo.count( D[i].second ) ) {\n\t\t\tymemo[D[i].second] = i;\n\t\t} else {\n\t\t\tuf.merge( ymemo[D[i].second], i );\n\t\t}\n\t\tif( D[i].first == 1 ) {\n\t\t\tkabef = true;\n\t\t}\n\t\tif( D[i].first == W ) {\n\t\t\tkabef = true;\n\t\t}\n\t\tif( D[i].second == 1 ) {\n\t\t\tkabef = true;\n\t\t}\n\t\tif( D[i].second == H ) {\n\t\t\tkabef = true;\n\t\t}\n\t}\n\tlong long int ans = N - 1;\n\tif( uf.group() != 1 ) {\n\t\tif( kabef ) {\n\t\t\tans += uf.group() - 1;\n\t\t} else {\n\t\t\tans += (uf.group()-1)+1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UFT {\npublic:\n  vector<int> parent;\n  vector<int> rank;\n  vector<int> size;\n  UFT(int n){\n    parent = vector<int>(n);\n    rank = vector<int>(n,0);\n    size = vector<int>(n,1);\n    for(int i = 0; i < n; i++)\n      parent[i] = i;\n  }\n  int find_root(int x){\n    if ( parent[x] == x ) return x;\n    return parent[x] = find_root( parent[x] );\n  }\n  void unite(int x, int y){\n    int u = find_root(x);\n    int v = find_root(y);\n    if ( u == v ) return;\n    if ( rank[u] < rank[v] ){\n      parent[u] = v;\n      size[v] += size[u];\n    }else{\n      parent[v] = u;\n      size[u] += size[v];\n      if ( rank[u] == rank[v] ) rank[x]++;\n    }\n  }\n  bool is_same ( int x, int y ){\n    return find_root(x) == find_root(y);\n  }\n  int size_of ( int x ){\n    return size[ find_root(x) ];\n  }\n};\n\ntypedef long long Cost;\nclass edge{\npublic:\n  int u,v;;\n  Cost cost;\n  edge(int u, int v, Cost c) : u(u), v(v), cost(c) { ; }\n  bool operator< (const edge &e) const {\n    return cost < e.cost;\n  }\n};\nclass SpanningTree{\npublic:\n  int V;\n  vector< edge > edges;\n  SpanningTree(int n) : V(n) {; }\n  void add_edge(int v, int u, Cost c){\n    edges.push_back( edge(v,u,c) );\n  }\n  Cost kruskal(){\n    sort( edges.begin(), edges.end() );\n    UFT uft(V);\n    Cost ret = 0;\n    for(int i = 0; i < edges.size(); i++){\n      edge &e = edges[i];\n      if( !uft.is_same(e.u, e.v) ){\n\tuft.unite(e.u, e.v);\n\tret += e.cost;\n      }\n    }\n    return ret;\n  }\n};\n\nint N, W, H;\nvector<tuple<long long, long long, int>> p;\nvector<tuple<long long, long long, int>> q;\nvector<tuple<long long, long long>> s;\nint M[40000];\nint main(){\n  cin >> N >> W >> H;\n  for(int i = 0; i < N; i++){\n    long long x, y;\n    cin >> x >> y;\n    p.emplace_back(x,y,i);\n    q.emplace_back(y,x,i);\n    s.emplace_back(y,x);\n  }\n  UFT uft(N);\n  SpanningTree st(N);\n  sort(p.begin(), p.end());\n  sort(q.begin(), q.end());\n\n  for(int i = 1; i < N; i++){\n    if( get<0>(p[i-1]) == get<0>(p[i]) ){\n      uft.unite( get<2>(p[i-1]), get<2>(p[i]) );\n      st.add_edge( get<2>(p[i-1]), get<2>(p[i]), 1 );\n    }\n    if( get<0>(q[i-1]) == get<0>(q[i]) ){\n      uft.unite( get<2>(q[i-1]), get<2>(q[i]) );\n      st.add_edge( get<2>(q[i-1]), get<2>(q[i]), 1 );\n    }\n  }\n  long long sum_of_componentwise = st.kruskal();\n  //cout << sum_of_componentwise << endl;\n  int C = 0;\n  for(int i = 0; i < N; i++){\n    if( uft.parent[i] == i ){\n      M[i] = C;\n      C++;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    if( uft.parent[i] != i ){\n      M[i] = M[uft.find_root(i)];\n    }\n  }\n  long long w0 = 0, wW = 0, h0 = 0, hH = 0;\n  for(int i = 0; i < N; i++){\n    long long x, y;\n    tie(x,y) = s[i];\n    if( x == 1 ){\n      w0++;\n    }else if( x == W ){\n      wW++;\n    }\n    if( y == 1 ){\n      h0++;\n    }else if( y == H ){\n      hH++;\n    }\n  }\n\n  long long ans = 1e18;\n  if( C == 1 ){\n    ans = 0;\n  }else{\n    ans = min( ans, (C-w0) + C-1);\n    ans = min( ans, (C-wW) + C-1);\n    ans = min( ans, (C-h0) + C-1);\n    ans = min( ans, (C-hH) + C-1);\n  }\n  cout << ans + sum_of_componentwise << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,h,w;\nvvi a,b;\nmap<int,int> mx,my;\n\nint main(){\n\tcin>>n>>w>>h;\n\tUnion_Find_Tree uft(n);\n\tint cx=0,cy=0;\n\ta=b=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(mx.find(x)==mx.end()){\n\t\t\tmx[x]=cx;\n\t\t\tcx++;\n\t\t}\n\t\tif(my.find(y)==my.end()){\n\t\t\tmy[y]=cy;\n\t\t\tcy++;\n\t\t}\n\t\ta[mx[x]].push_back(i);\n\t\tb[my[y]].push_back(i);\n\t}\n\tfor(int i=0;i<n;i++) for(int j=1;j<a[i].size();j++) uft.Unite(a[i][j],a[i][j-1]);\n\tfor(int i=0;i<n;i++) for(int j=1;j<b[i].size();j++) uft.Unite(b[i][j],b[i][j-1]);\n\tvi used(n);\n\tint res=n-3;\n\tfor(int i=0;i<n;i++){\n\t\tint p=uft.Find_Par(i);\n\t\tif(!used[p]){\n\t\t\tused[p]=1;\n\t\t\tres+=2;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 40010\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint p[MAX];\nint n,h,w,ans=0;\nint x[MAX],y[MAX];\nbool l[MAX]={},r[MAX]={},u[MAX]={},d[MAX]={};\n\nint find(int a){\n  if(p[a]==a)return a;\n  int pa=find(p[a]);\n  p[a]=pa;\n  return pa;\n}\n\nvoid unite(int a,int b){\n  int pa=find(a),pb=find(b);\n  p[pa]=pb;\n}\n\nbool same(int a,int b){\n  return find(a)==find(b);\n}\n\nvoid check(int a,int b){\n  u[a]|=u[b];\n  u[b]|=u[a];\n  l[a]|=l[b];\n  l[b]|=l[a];\n  d[a]|=d[b];\n  d[b]|=d[a];\n  r[a]|=r[b];\n  r[b]|=r[a];\n}\n\nint main()\n{\n\n  vector<pii> a,b;\n\n  cin>>n>>w>>h;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    a.push_back(mp(x[i],i));\n    b.push_back(mp(y[i],i));\n    if(y[i]==1)d[i]=true;\n    if(x[i]==1)l[i]=true;\n    if(y[i]==h)u[i]=true;\n    if(x[i]==w)r[i]=true;\n  }\n\n  for(int i=0;i<MAX;i++)p[i]=i;\n\n  sort(a.begin(),a.end());\n  sort(b.begin(),b.end());\n\n  for(int i=1;i<n;i++){\n    if(a[i-1].f==a[i].f && !same(a[i-1].s,a[i].s)){\n      unite(a[i-1].s,a[i].s);\n      ans++;\n      check(i-1,i);\n    }\n    if(b[i-1].f==b[i].f && !same(b[i-1].s,b[i].s)){\n      unite(b[i-1].s,b[i].s);\n      ans++;\n      check(i-1,i);\n    }\n  }\n\n  if(ans!=n-1){\n    int sum1=0,sum2=0,sum3=0,sum4=0;\n    for(int i=0;i<n;i++)if(p[i]==i)sum1++;\n    sum1=(sum1*2-1);\n    sum2=sum3=sum4=sum1;\n    for(int i=0;i<n;i++){\n      if(p[i]==i && l[i])sum1--;\n      if(p[i]==i && u[i])sum2--;\n      if(p[i]==i && r[i])sum3--;\n      if(p[i]==i && d[i])sum4--;\n    }\n    ans+=min(min(sum1,sum2),min(sum3,sum4));\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 40010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nint x[40010], y[40010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, h, w;\n  cin >> n >> h >> w;\n  bool flag=false;\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n    x[i]--, y[i]--;\n    if(x[i]==0 || x[i]==w-1 || y[i]==0 || y[i]==h-1) flag = true;\n  }\n\n  REP(i, n) FOR(j, i+1, n) {\n    if(x[i] == x[j] || y[i] == y[j]) {\n      uf.unite(i, j);\n    }\n  }\n\n  int ret = 0, cnt = 0;\n  REP(i, n) {\n    if(i == uf.find(i)) {\n      ret += uf.s[uf.find(i)] - 1;\n      cnt++;\n    }\n  }\n  // cout << ret << \" \" << cnt << endl;\n  if(cnt >= 2) ret += cnt + cnt - 1 - (flag?1:0);\n\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UFT {\npublic:\n  vector<int> parent;\n  vector<int> rank;\n  vector<int> size;\n  UFT(int n){\n    parent = vector<int>(n);\n    rank = vector<int>(n,0);\n    size = vector<int>(n,1);\n    for(int i = 0; i < n; i++)\n      parent[i] = i;\n  }\n  int find_root(int x){\n    if ( parent[x] == x ) return x;\n    return parent[x] = find_root( parent[x] );\n  }\n  void unite(int x, int y){\n    int u = find_root(x);\n    int v = find_root(y);\n    if ( u == v ) return;\n    if ( rank[u] < rank[v] ){\n      parent[u] = v;\n      size[v] += size[u];\n    }else{\n      parent[v] = u;\n      size[u] += size[v];\n      if ( rank[u] == rank[v] ) rank[x]++;\n    }\n  }\n  bool is_same ( int x, int y ){\n    return find_root(x) == find_root(y);\n  }\n  int size_of ( int x ){\n    return size[ find_root(x) ];\n  }\n};\n\ntypedef long long Cost;\nclass edge{\npublic:\n  int u,v;;\n  Cost cost;\n  edge(int u, int v, Cost c) : u(u), v(v), cost(c) { ; }\n  bool operator< (const edge &e) const {\n    return cost < e.cost;\n  }\n};\nclass SpanningTree{\npublic:\n  int V;\n  vector< edge > edges;\n  SpanningTree(int n) : V(n) {; }\n  void add_edge(int v, int u, Cost c){\n    edges.push_back( edge(v,u,c) );\n  }\n  Cost kruskal(){\n    sort( edges.begin(), edges.end() );\n    UFT uft(V);\n    Cost ret = 0;\n    for(int i = 0; i < edges.size(); i++){\n      edge &e = edges[i];\n      if( !uft.is_same(e.u, e.v) ){\n\tuft.unite(e.u, e.v);\n\tret += e.cost;\n      }\n    }\n    return ret;\n  }\n};\n\nint N, W, H;\nvector<tuple<long long, long long, int>> p;\nvector<tuple<long long, long long, int>> q;\nvector<tuple<long long, long long>> s;\nint M[40000];\nint main(){\n  cin >> N >> W >> H;\n  for(int i = 0; i < N; i++){\n    long long x, y;\n    cin >> x >> y;\n    p.emplace_back(x,y,i);\n    q.emplace_back(y,x,i);\n    s.emplace_back(y,x);\n  }\n  UFT uft(N);\n  SpanningTree st(N);\n  sort(p.begin(), p.end());\n  sort(q.begin(), q.end());\n\n  for(int i = 1; i < N; i++){\n    if( get<0>(p[i-1]) == get<0>(p[i]) ){\n      uft.unite( get<2>(p[i-1]), get<2>(p[i]) );\n      st.add_edge( get<2>(p[i-1]), get<2>(p[i]), 1 );\n    }\n    if( get<0>(q[i-1]) == get<0>(q[i]) ){\n      uft.unite( get<2>(q[i-1]), get<2>(q[i]) );\n      st.add_edge( get<2>(q[i-1]), get<2>(q[i]), 1 );\n    }\n  }\n  long long sum_of_componentwise = st.kruskal();\n  //cout << sum_of_componentwise << endl;\n  int C = 0;\n  for(int i = 0; i < N; i++){\n    if( uft.parent[i] == i ){\n      M[i] = C;\n      C++;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    if( uft.parent[i] != i ){\n      M[i] = M[uft.find_root(i)];\n    }\n  }\n  long long w0 = 0, wW = 0, h0 = 0, hH = 0;\n  for(int i = 0; i < N; i++){\n    long long x, y;\n    tie(x,y) = s[i];\n    if( x == 1 ){\n      w0++;\n    }else if( x == W ){\n      wW++;\n    }\n    if( y == 1 ){\n      h0++;\n    }else if( y == H ){\n      hH++;\n    }\n  }\n\n  long long ans = 1e18;\n  if( C == 1 ){\n    ans = 0;\n  }else{\n    ans = min( ans, (C-w0) + C-1);\n    ans = min( ans, (C-wW) + C-1);\n    ans = min( ans, (C-h0) + C-1);\n    ans = min( ans, (C-hH) + C-1);\n  }\n  cout << ans + sum_of_componentwise << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\n\nint main(){\n  int n, h, w;\n  cin >> n >> w >> h;\n  int x, y;\n  vector<int> X(n), Y(n);\n  map<int,int> M_x, M_y;\n  UnionFind uf(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n    if(M_x[x] > 0){\n      uf.unite(i,M_x[x]-1);\n    }else{\n      M_x[x] = i + 1;\n    }\n    if(M_y[y] > 0){\n      uf.unite(i,M_y[y]-1);\n    }else{\n      M_y[y] = i + 1;\n    }\n  }\n  set<int> p;\n  int l = 0, r = 0, t = 0, b = 0;\n  for(int i = 0; i < n; ++i){\n    p.insert(uf.find(i));\n    if(X[i] == 1 && l == 0) ++l;\n    if(X[i] == w && r == 0) ++r;\n    if(Y[i] == 1 && b == 0) ++b;\n    if(Y[i] == h && t == 0) ++t;\n  }\n  int k = p.size(), s = l|r|b|t;\n  if(k == 1) cout << n - 1 << endl;\n  else cout << n + k - 1 - s << endl; \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 40005;\n\nint x[MAX_N],y[MAX_N];\nint n,w,h;\nbool flag[MAX_N];\nvector<int> X[100002],Y[100002];\nvector<int> G[MAX_N];\n\nvoid dfs(int u,bool& hoge)\n{\n    flag[u] = true;\n    if(x[u] == 0 || x[u] == h-1 || y[u] == 0 || y[u] == w-1){\n        hoge = true;\n    }\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],hoge);\n        }\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n        x[i]--,y[i]--;\n        X[x[i]].push_back(i);\n        Y[y[i]].push_back(i);\n\t}\n    rep(i,w){\n        rep(j,Y[i].size()){\n            rep(k,Y[i].size()){\n                if(k != j){\n                    G[Y[i][j]].push_back(Y[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,X[i].size()){\n            rep(k,X[i].size()){\n                if(k != j){\n                    G[X[i][j]].push_back(X[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    int cnt = 0;\n    int pl = 0;\n    bool wall = false;\n    rep(i,n){\n        if(!flag[i]){\n            cnt++;\n            dfs(i,wall);\n        }\n    }\n    if(wall){\n        pl += 2*(cnt-1);\n    }else{\n        pl += 3*(cnt-1);\n    }\n    printf(\"%d\\n\",n-cnt+pl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nll N, H, W;\nint x[40000], y[40000];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> W >> H;\n    UnionFind uni(N);\n    for(int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = i + 1; j < N; j++) {\n            if(x[i] == x[j] or y[i] == y[j]) uni.merge(i, j);\n        }\n    }\n    int rest = 0;\n    for(int i = 0; i < N; i++) {\n        if(uni.root(i) == i) rest++;\n    }\n    if(rest == 1) {\n        cout << N - 1 << endl;\n        return 0;\n    }\n    int ans = N - rest;\n    bool edge = false;\n    for(int i = 0; i < N; i++) {\n        if(x[i] == 1 or x[i] == W or y[i] == 1 or y[i] == H) edge = true;\n    }\n    if(!edge) ans++;\n    ans += 2 * (rest - 1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> p;\n    UnionFind(int n) : p(n, -1) {}\n    void merge(int a, int b) {\n        a = root(a), b = root(b);\n        if (a == b) return;\n        if (p[a] < p[b]) swap(a, b);\n        p[b] += p[a];\n        p[a] = b;\n    }\n    int root(int x) {\n        if (p[x] < 0) return x;\n        return p[x] = root(p[x]);\n    }\n    int size(int x) {\n        return -p[root(x)];\n    }\n};\n\nsigned main() {\n    int N, W, H;\n    cin >> N >> W >> H;\n    vector<bitset<4>> flag(N);\n    vector<vector<pair<int, int>>> row(H), col(W);\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        flag[i][0] = (x == 0);\n        flag[i][1] = (x == W - 1);\n        flag[i][2] = (y == 0);\n        flag[i][3] = (y == H - 1);\n        row[y].push_back({x, i});\n        col[x].push_back({y, i});\n    }\n\n    UnionFind uf(N);\n    for (int i = 0; i < H; i++) {\n        sort(begin(row[i]), end(row[i]));\n        for (int j = 0; j < (int)row[i].size() - 1; j++)\n            uf.merge(row[i][j].second, row[i][j + 1].second);\n    }\n    for (int i = 0; i < W; i++) {\n        sort(begin(col[i]), end(col[i]));\n        for (int j = 0; j < (int)col[i].size() - 1; j++)\n            uf.merge(col[i][j].second, col[i][j + 1].second);\n    }\n    \n    int ans = 0;\n    set<int> s;\n    for (int i = 0; i < N; i++) {\n        int r = uf.root(i);\n        s.insert(r);\n        flag[r] |= flag[i];\n    }\n    for (int r : s) {\n        ans += uf.size(r) - 1;\n    }\n    if (s.size() > 1) {\n        int mx = 0;\n        for (int dir = 0; dir < 4; dir++) {\n            int cnt = 0;\n            for (int r : s) {\n                cnt += flag[r][dir];\n            }\n            mx = max(mx, cnt);\n        }\n        ans += s.size() - mx;\n        ans += s.size() - 1;\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nclass UnionFindTree{\npublic:\n    vector<int> v;\n    vector<int> rank;\n \n    UnionFindTree(int n){\n        v = vector<int>(n);\n        rank = vector<int>(n, 0);\n        for(int i=0; i<n; i++) v[i]=i;\n    }\n    int Find(int x){\n        if(v[x] != x){\n            v[x] = Find(v[x]);\n        }\n        return v[x];\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]){\n            v[a] = b;\n        }else{\n            v[b] = a;\n            if(rank[a] == rank[b]){\n                rank[a]++;\n            }\n        }\n    }\n};\n\nint main(){\n    int n,w,h;\n    cin >> n >> w >> h;\n    vector<pair<int,int> > x(n), y(n);\n    int wallside = 0;\n    for(int i=0; i<n; i++){\n        int tx,ty;\n        cin >> tx >> ty;\n        x[i] = make_pair(tx, i);\n        y[i] = make_pair(ty, i);\n        if(tx==1 || tx==w || ty==1 || ty==h) wallside = 1;\n    }\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n\n    UnionFindTree uft(n);\n    for(int i=0; i<n-1; i++){\n        if(x[i].first == x[i+1].first){\n            uft.Union(x[i].second, x[i+1].second);\n        }\n        if(y[i].first == y[i+1].first){\n            uft.Union(y[i].second, y[i+1].second);\n        }\n    }\n    set<int> group;\n    for(int i=0; i<n; i++){\n        group.insert(uft.Find(i));\n    }\n    int ans = n-1;\n    if((int)group.size() != 1) ans += group.size() -wallside;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\ntypedef pair<int,int> P;\nint n,h,w;\n\nstruct unionFind{\n  unionFind(int n){\n    init(n);\n  }\n  vector<int> par,size;\n  int grup;\n  void init(int n){\n    grup=n;\n    par.resize(n);\n    size.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x]=find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n    if(size[x]<size[y]) swap(x,y);\n    par[y] = x;\n    size[x]+=size[y];\n    grup--;\n  }\n  bool same(int x,int y){return find(x) == find(y);}\n  int getg(){return grup;}\n};\n\nP mp[100000];\nmap<int,vector<int> > xx;\nmap<int,vector<int> > yy;\nint main(){\n  cin>>n>>w>>h;\n  bool f;\n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    mp[i]=P(x,y);\n    if(x==1 || y==1 || x==w || y==h) f=1;\n    xx[x].push_back(i);\n    yy[y].push_back(i);\n  }\n  unionFind u(n);\n  \n  map<int,vector<int> >::iterator it;\n  for(it=xx.begin();it!=xx.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  for(it=yy.begin();it!=yy.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  int cnt=u.getg();\n  if(cnt==1) cout<<n-cnt<<endl;\n  else cout<<n+cnt-1-f<<endl;     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint dp[1001][1001];\nint main() {\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tunionfind uf(w + h);\n\tvpii s(n);\n\trep(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ts[i] = { a - 1,b - 1 };\n\t\tuf.unite(a - 1, w + b - 1);\n\t}\n\tuset<int> t,e[4];\n\trep(i, n) {\n\t\tint a = uf.find(s[i].first);\n\t\tt.insert(a);\n\t\tif (s[i].first == 1)e[0].insert(a);\n\t\tif (s[i].first == w)e[1].insert(a);\n\t\tif (s[i].second == 1)e[2].insert(a);\n\t\tif(s[i].second == h)e[3].insert(a);\n\t}\n\tint k = t.size();\n\tint m = 0;\n\trep(i, 4)cmax(m, e[i].size());\n\tif (k > 1)k = k * 2 -m - 1 + n - k;\n\telse k = n - 1;\n\tcout << k << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,w,h;\nvi a,b;\n\nint main(){\n\tcin>>n>>w>>h;\n\ta=b=vi(n);\n\tmap<int,int> X,Y;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tX[a[i]]++;\n\t\tY[b[i]]++;\n\t}\n\tfor(int i=0;i<n;i++) if(X[a[i]]+Y[b[i]]==n+1){\n\t\tcout<<n-1<<endl;\n\t\treturn 0;\n\t}\n\tint A=0,B=0,C=0,D=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(a[i]==1) A++;\n\t\tif(a[i]==w) B++;\n\t\tif(b[i]==1) C++;\n\t\tif(b[i]==h) D++;\n\t}\n\tcout<<min(X.size()-max(A,B),Y.size()-max(C,D))+n-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<pair<int, int> > place;\nvector<vector<int> > x(100010), y(100010);\nvector<int> groupnum(40010, -1);\nvector<int> groupsize;\nvector<vector<bool> > isclosetowall;\nvector<bool> ischecked_x(100010, false), ischecked_y(100010, false);\n\nint main()\n{\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\t// cout << __LINE__ <<endl;\n\tfor(int i = 0; i < n; i++){\n\t\tint tmpx, tmpy;\n\t\tcin >> tmpx >> tmpy;\n\t\tplace.push_back(make_pair(tmpx, tmpy));\n\t\tx[tmpx].push_back(i);\n\t\t// cout << y.size() << \" \" << tmpy << endl;\n\t\ty[tmpy].push_back(i);\n\t\t// cout << __LINE__ << endl;\n\t\t// cout << i << endl;\n\t}\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(groupnum[i] < 0){\n\t\t\t// cout << i << endl;\n\t\t\tqueue<int> qu;\n\t\t\tqu.push(i);\n\t\t\tgroupnum[i] = cnt;\n\t\t\tisclosetowall.push_back(vector<bool>(4, false));\n\t\t\tgroupsize.push_back(1);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint now = qu.front();\n\t\t\t\tint nowx = place[now].first;\n\t\t\t\tint nowy = place[now].second;\n\t\t\t\tqu.pop();\n\t\t\t\t// cout << now << \" \" << \" \" << nowx << \" \" << nowy << \" \" << ischecked_x[nowx] << \" \" << ischecked_y[nowy] << endl;\n\t\t\t\tif(nowx == 1) isclosetowall[cnt][0] = true;\n\t\t\t\tif(nowx == h) isclosetowall[cnt][1] = true;\n\t\t\t\tif(nowy == 1) isclosetowall[cnt][2] = true;\n\t\t\t\tif(nowy == w) isclosetowall[cnt][3] = true;\n\t\t\t\tif(!ischecked_x[nowx]){\n\t\t\t\t\tischecked_x[nowx] = true;\n\t\t\t\t\tfor(int j = 0; j < x[nowx].size(); j++){\n\t\t\t\t\t\tint nowindex = x[nowx][j];\n\t\t\t\t\t\tint tmpy = place[nowindex].second;\n\t\t\t\t\t\tif(nowindex == now || ischecked_y[tmpy]) continue;\n\t\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// x.erase(x.begin() + nowx);\n\t\t\t\tif(!ischecked_y[nowy]){\n\t\t\t\t\tischecked_y[nowy] = true;\n\t\t\t\t\tfor(int j = 0; j < y[nowy].size(); j++){\n\t\t\t\t\t\tint nowindex = y[nowy][j];\n\t\t\t\t\t\tint tmpx = place[nowindex].first;\n\t\t\t\t\t\tif(nowindex == now || ischecked_x[tmpx]) continue;\n\t\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// y.erase(y.begin() + nowy);\n\t\t\t\t// cout << now << \" \" << groupsize[cnt] << endl;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t// cout << i << \" \" << groupnum[i] << groupsize[groupnum[i]] << endl;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < cnt; i++){\n\t\tsum += groupsize[i] - 1;\n\t}\n\tif(cnt == 1){\n\t\tcout << sum << endl;\n\t\treturn 0;\n\t}\n\tint ans = mod;\n\tfor(int i = 0; i < 4; i++){\n\t\tint needtomove = 0;\n\t\tfor(int j = 0; j < cnt; j++){\n\t\t\tif(!isclosetowall[j][i]) needtomove++;\n\t\t}\n\t\tans = min(ans, sum + needtomove + cnt - 1);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,w,h;\n    cin >> n >> w >> h;\n\n    map<int,vector<int>> mp;\n    vector<set<int>> vs(h);\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        --x;\n        --y;\n        mp[x].emplace_back(y);\n        vs[y].insert(x);\n    }\n\n    int ans=0,cnt=0;\n    for(auto it=mp.begin(); it!=mp.end(); ++it){\n        const int x=it->first;\n        if(x==w-1) continue;\n        ans+=mp[x].size();\n        if(!cnt and x==mp.rbegin()->first){\n            --ans;\n            continue;\n        }\n        bool f=false;\n        for(const int y:mp[x]){\n            while(!vs[y].empty() and *vs[y].begin()<=x) vs[y].erase(vs[y].begin());\n            if(vs[y].empty()) continue;\n            f=true;\n            break;\n        }\n        if(!f) ++cnt;\n    }\n    if(cnt+mp[w-1].size()) ans+=cnt+mp[w-1].size()-1;\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint uni[100000],r[100000];\nint find(int a){\n  if(a!=uni[a])a=find(uni[a]);\n  return a;\n}\nbool same(int a,int b){\n  return find(a)==find(b);\n}\nvoid unit(int a,int b){\n  int c=find(a),d=find(b);\n  if(r[c]>r[d])uni[d]=c;\n  else{uni[c]=d;\n    if(r[c]==r[d])r[c]++;\n  }\n}\nint ans,n,w,h,sum,c,y[100000],x[100000];\nbool used[100000];\nint main(){\n  cin>>n>>w>>h;\n  r(i,n)uni[i]=i,r[i]=0;\n  r(i,n)cin>>x[i]>>y[i];\n  r(i,n)r(j,n)if(x[i]==x[j]||y[i]==y[j])unit(i,j);\n  r(i,n)if(!used[i]){\n    int f=0;\n    used[i]=1;\n    for(int j=i;j<n;j++){\n      if(same(i,j)){\n        used[j]=1;\n        if(x[j]==0)sum++;\n        if(x[j]==w)sum++;\n        if(y[j]==0)sum++;\n        if(y[j]==h)sum++;\n      }\n    }\n    c++;\n  }\n  //if(c==1)cout<<n-1<<endl;\n cout<<n+c-1-sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nclass union_find {\npublic:\n    union_find(int N)\n        : par(N, -1)\n    {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) {\n            return false;\n        }\n        if(par[x] < par[y]) {\n            par[x] += par[y];\n            par[y] = x;\n        } else {\n            par[y] += par[x];\n            par[x] = y;\n        }\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\nprivate:\n    vector<int> par;\n};\n\nint main() {\n    int N, W, H;\n    cin >> N >> W >> H;\n    vector<vector<int>> sx(W), sy(H);\n    union_find uf(N);\n    bool f = false;\n    for(int i=0; i<N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        sx[x].push_back(i);\n        sy[y].push_back(i);\n        f |= x == 0 || x == W-1 || y == 0 || y == H-1;\n    }\n    for(int i=0; i<W; ++i) {\n        for(int j=0; j<(int)sx[i].size()-1; ++j) {\n            uf.unite(sx[i][j], sx[i][j+1]);\n        }\n    }\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<(int)sy[i].size()-1; ++j) {\n            uf.unite(sy[i][j], sy[i][j+1]);\n        }\n    }\n    int res = 0;\n    int cnt = 0;\n    for(int i=0; i<N; ++i) {\n        if(uf.root(i) == i) {\n            res += uf.size(i) - 1;\n            cnt++;\n        }\n    }\n    if(cnt != 1) {\n        res += cnt * 2 - 1 - f;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct UnionFind {\n    vector<int> par;\n    int n, cnt;\n    UnionFind(const int& x = 0) {init(x);}\n    void init(const int& x) {par.assign(cnt=n=x, -1);}\n    inline int find(const int& x) {return par[x] < 0 ? x : par[x] = find(par[x]);}\n    inline bool same(const int& x, const int& y) {return find(x) == find(y);}\n    inline bool unite(int x, int y) {\n        if ((x = find(x)) == (y = find(y))) return false;\n        --cnt;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    inline int count() const {return cnt;}\n    inline int count(int x) {return -par[find(x)];}\n};\n\nconst int MAXN = 100100;\nint X[MAXN], Y[MAXN];\nvi Xp[MAXN], Yp[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, H, W;\n    cin >> N >> W >> H;\n    int flag = 0;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n        Xp[X[i]].push_back(i);\n        Yp[Y[i]].push_back(i);\n        if (X[i] == 1 || Y[i] == 1 || X[i] == W || Y[i] == H) flag = 1;\n    }\n    UnionFind uf(N);\n    for (int i = 0; i < MAXN; i++) {\n        for (int j = 1; j < Xp[i].size(); j++)\n            uf.unite(Xp[i][j], Xp[i][0]);\n        for (int j = 1; j < Yp[i].size(); j++)\n            uf.unite(Yp[i][j], Yp[i][0]);\n    }\n    int ans = 0;\n    int sz = 0;\n    for (int i = 0; i < N; i++) {\n        int p = uf.find(i);\n        if (!done[p]) {\n            done[p] = true;\n            sz++;\n            ans += uf.count(p)-1;\n        }\n    }\n    if (sz > 1) {\n        if (flag) ans += 2*(sz-1);\n        else ans += 2*sz-1;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100001\n#define rank dfasodfhdasoif\nusing namespace std;\nvector<int> G[2][100001];\n \n/*Union_Find_Tree\n  O(a(n))<O(log(n))\n*/\n \nint par[MAX_N];\nint rank[MAX_N];\n \nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n \nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n \nbool same(int x,int y){return find(x)==find(y);}\n \n \nint main(){\n  int n,w,h,flg=0;\n  cin>>n>>w>>h;\n  init(n);\n   \n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    if(x==1||y==1||x==w||y==h)flg=1;\n    G[0][x].push_back(i);\n    G[1][y].push_back(i);\n  }\n   \n  for(int i=1;i<=h;i++)\n    for(int j=1;j<G[1][i].size();j++)unite(G[1][i][j],G[1][i][j-1]);\n   \n  for(int i=1;i<=w;i++)\n    for(int j=1;j<G[0][i].size();j++)unite(G[0][i][j],G[0][i][j-1]);\n \n  int cnt=0,used[100001]={};\n  for(int i=0;i<n;i++){\n    par[i]=find(i);\n    cnt+=!used[find(i)];\n    used[find(i)]=1;\n  }\n  if(cnt==1)cout <<n-cnt<<endl;\n  else cout <<n+(cnt-1)-flg<<endl;  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1)\n    {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) {\n            return false;\n        }\n        if(par[x] < par[y]) {\n            par[x] += par[y];\n            par[y] = x;\n        } else {\n            par[y] += par[x];\n            par[x] = y;\n        }\n        return true;\n    }\n\n    int size(int x) {\n        x = root(x);\n        return -par[x];\n    }\n\nprivate:\n    vector<int> par;\n};\n\n\nint main() {\n    int N, W, H;\n    cin >> N >> W >> H;\n    vector<vector<int>> sx(W), sy(H);\n    bool f = false;\n    for(int i=0; i<N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        sx[x].push_back(i);\n        sy[y].push_back(i);\n        f |= x == 0 || x == W-1 || y == 0 || y == H-1;\n    }\n    union_find uf(N);\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<(int)sy[i].size()-1; ++j) {\n            uf.unite(sy[i][j], sy[i][j+1]);\n        }\n    }\n    for(int i=0; i<W; ++i) {\n        for(int j=0; j<(int)sx[i].size()-1; ++j) {\n            uf.unite(sx[i][j], sx[i][j+1]);\n        }\n    }\n    int cnt = 0;\n    int res = 0;\n    for(int i=0; i<N; ++i) {\n        if(uf.root(i) == i) {\n            res += uf.size(i) - 1;\n            cnt++;\n        }\n    }\n    if(cnt != 1) {\n        res += 2*cnt - 1 - f;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nclass union_find {\npublic:\n    union_find(int N)\n        : par(N, -1)\n    {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) {\n            return false;\n        }\n        if(par[x] < par[y]) {\n            par[x] += par[y];\n            par[y] = x;\n        } else {\n            par[y] += par[x];\n            par[x] = y;\n        }\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\nprivate:\n    vector<int> par;\n};\n\nint main() {\n    int N, W, H;\n    cin >> N >> W >> H;\n    vector<vector<int>> sx(W), sy(H);\n    union_find uf(N);\n    bool f = false;\n    for(int i=0; i<N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        sx[x].push_back(i);\n        sy[y].push_back(i);\n        f |= x == 0 || x == W-1 || y == 0 || y == H-1;\n    }\n    for(int i=0; i<W; ++i) {\n        for(int j=0; j<(int)sx[i].size()-1; ++j) {\n            uf.unite(sx[i][j], sx[i][j+1]);\n        }\n    }\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<(int)sy[i].size()-1; ++j) {\n            uf.unite(sy[i][j], sy[i][j+1]);\n        }\n    }\n    int res = 0;\n    int cnt = 0;\n    for(int i=0; i<N; ++i) {\n        if(uf.root(i) == i) {\n            res += uf.size(i) - 1;\n            cnt++;\n        }\n    }\n    res += cnt * 2 - 1 - f;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int x, int y) : x(x), y(y) {}\n};\nbool operator<(const Point& a, const Point& b) {\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nistream& operator>>(istream& is, Point& p) {\n    return is >> p.x >> p.y;\n}\nostream& operator<<(ostream& os, const Point& p) {\n    return os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs) {\n    if (xs.empty()) return os << \"[]\";\n    os << \"[\" << xs[0];\n    for (int i = 1; i < xs.size(); i++) os << \" \" << xs[i];\n    return os << \"]\";\n}\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nstruct UnionFind {\n    int N;\n    vector<int> P;\n    UnionFind(int N) : N(N) {\n        P.clear(); P.resize(N, -1);\n    }\n    int root(int x) {\n        if (P[x] == -1) return x;\n        return P[x] = root(P[x]);\n    }\n    int query(int x, int y) {\n        return root(x) == root(y);\n    }\n    void merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return;\n        P[x] = y;\n    }\n    int count() {\n        vector<bool> u(N, false);\n        int ret = 0;\n        for (int i = 0; i < N; i++) {\n            if (u[root(i)]) continue;\n            u[root(i)] = true;\n            ret++;\n        }\n        return ret;\n    }\n};\n\nint N, W, H;\nvector<Point> P;\nint main() {\n    cin >> N >> W >> H;\n    P.clear(); P.resize(N);\n    for (int i = 0; i < N; i++) cin >> P[i];\n\n    UnionFind uf(N);\n\n    int ans = 0;\n\n    vector<bool> T(N, false);\n\n    map<int, int> M;\n    for (int i = 0; i < N; i++) {\n        const Point& p = P[i];\n        if (M.count(p.x)) {\n            uf.merge(i, M[p.x]);\n            ans++;\n        } else {\n            M[p.x] = i;\n        }\n        if (p.x == 1 || p.x == W) T[uf.root(i)] = true;\n    }\n    M.clear();\n    for (int i = 0; i < N; i++) {\n        const Point& p = P[i];\n        if (M.count(p.y)) {\n            if (uf.query(i, M[p.y])) continue;\n            uf.merge(i, M[p.y]);\n            ans++;\n        } else {\n            M[p.y] = uf.root(i);\n        }\n        if (p.y == 1 || p.y == H) T[uf.root(i)] = true;\n    }\n\n    if (uf.count() == 1) {\n        cout << ans << endl;\n    } else {\n        ans--;\n        bool f = true;\n        vector<bool> u(N, false);\n        for (int i = 0; i < N; i++) {\n            if (u[uf.root(i)]) continue;\n            u[uf.root(i)] = true;\n            if (f && T[uf.root(i)]) {\n                ans--;\n                f = false;\n            }\n            ans += 2;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 50010\n \nclass Union_Find{\npublic:\n    int par[MAX],rank[MAX],size[MAX],gnum;\n    Union_Find(int N){\n\tgnum = N;\n\tfor(int i = 0 ; i < MAX ; i++){\n\t    par[i] = i;\n\t    rank[i] = 0;\n\t    size[i] = 0;\n\t}\n    }\n    int find(int x){\n\tif(par[x] == x){\n\t    return x;\n\t}\n\treturn par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rank[x] < rank[y]){\n\t    par[x] = y;\n\t    size[y] += size[x];\n\t}else{\n\t    par[y] = x;\n\t    size[x] += size[y];\n\t    if(rank[x] == rank[y]){\n\t\trank[x]++;\n\t    }\n\t}\n\tgnum--;\n    }\n    bool same(int x,int y){\n\treturn find(x) == find(y);\n    }\n    int getSize(int x){\n\treturn size[find(x)];\n    }\n    int groups(){\n\treturn gnum;\n    }\n};\n \nint N,W,H;\nint X[2*MAX],Y[2*MAX],x[MAX],y[MAX];\n \nbool isWall(int x,int y){\n    if(x == 1 || y == 1 || x == W || y == H){\n\treturn true;\n    }\n    return false;\n}\n \nint main(){\n    cin >> N >> W >> H;\n    Union_Find uf(N);\n    for(int i = 0 ; i < 2*MAX ; i++){\n\tX[i] = Y[i] = -1;\n    }\n    bool wall = false;\n    for(int i = 0 ; i < N ; i++){\n\tcin >> x[i] >> y[i];\n\tuf.size[i] = 1;\n\tif(X[x[i]] == -1){\n\t    X[x[i]] = i;\n\t}else{\n\t    uf.unite(X[x[i]],i);\n\t}\n\tif(Y[y[i]] == -1){\n\t    Y[y[i]] = i;\n\t}else{\n\t    uf.unite(Y[y[i]],i);\n\t}\n\twall |= isWall(x[i],y[i]);\n    }\n    if(uf.groups() == 1){\n\tcout << uf.getSize(0)-1 << endl;\n    }else{\n\tint sum = 0;\n\tset<int> visited;\n\tfor(int i = 0 ; i < N ; i++){\n\t    int f = uf.find(i);\n\t    if(!visited.count(f)){\n\t\tvisited.insert(f);\n\t\tsum += uf.getSize(i)-1;\n\t    }\n\t}\n\tcout << sum+(uf.groups()-1)*2+1-wall << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N, W, H;\n  vector< int > xs[100000], ys[100000];\n\n  scanf(\"%d %d %d\", &N, &W, &H);\n  bool ei = false;\n  for(int i = 0; i < N; i++) {\n    int X, Y;\n    scanf(\"%d %d\", &X, &Y);\n    xs[--X].push_back(i);\n    ys[--Y].push_back(i);\n    ei |= X == 0 || Y == 0 || X == W - 1 || Y == H - 1;\n  }\n\n  UnionFind tree(N);\n  for(int i = 0; i < 100000; i++) {\n    for(int j = 1; j < xs[i].size(); j++) tree.unite(xs[i][j - 1], xs[i][j]);\n    for(int j = 1; j < ys[i].size(); j++) tree.unite(ys[i][j - 1], ys[i][j]);\n  }\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) ret += tree.find(i) == i;\n  if(ret > 1) ret -= ret + 1 - ei;\n  printf(\"%d\\n\", N - ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint N;\nint W,H;\nvector<int> Y[100005];\nvector<int> T[100005];\n\n\nstruct uni {\n  int d[ 50000 ];\n  void init(){ memset( d,-1,sizeof( d ) ); }\n  int find( int a ) { return d[a]<0?a:(d[a] = find( d[a] )); }\n  void merge( int a,int b ){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap( a, b );\n    d[a] += d[b]; d[b] = a;\n  }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\nbool used[ 50000 ];\nint main(){\n  cin >> N >> W >> H;\n  int hj = 0;\n  for(int i=0;i<N;i++){\n    int x,y; cin >> x >> y;\n    if( x == 1 || x == W || y == 1 || y == H ) hj=1;\n    Y[ y ].push_back( i );\n    T[ x ].push_back( i );\n  }\n  \n  U.init();\n  for(int i=1;i<=W;i++) {\n    for(int j=1;j<(int)T[i].size();j++)\n      U.merge( T[i][j-1], T[i][j] );\n  }\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<(int)Y[i].size();i++)\n      U.merge( Y[i][j-1], Y[i][j] );\n\n\n  int cnt = 0;\n  int res = 0;\n  for(int i=0;i<N;i++){\n    int a = U.find( i );\n    if( used[ a ] ) continue;\n    used[ a ] = true;\n    res += U.size( a )-1;\n    cnt++;\n  }\n  if( cnt == 1 ) cout << res << endl;\n  else cout << res + cnt + cnt-1 - hj << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[i] < 0) memoX[i] = x;//???????????????????????????????????\\??£????????¨???????????°???????????¢??£?????????\n\t\telse ds.unite(i, memoX[i]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[i] < 0) memoY[i] = y;\n\t\telse ds.unite(i, memoY[i]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\n\tprintf(\"%d\\n\", m);\n\tif(m > 1){\n\t\tif(cornerw == true || cornerh == true){\n\t\t\tprintf(\"%d\\n\", n + m - 2);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\", n + m - 1);\n\t\t}\n\t}else{\n\t\tprintf(\"%d\\n\", n - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct UnionFind{\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\ntypedef pair<int,int> P;\n#define MAX 114514\nvector<int> vx[MAX],vy[MAX];\nsigned main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  int x[n],y[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n  bool f=0;\n  map<P,int> m;\n  for(int i=0;i<n;i++){\n    m[P(x[i],y[i])]=i;\n    vx[x[i]].push_back(y[i]);\n    vy[y[i]].push_back(x[i]);\n    f|=x[i]==1||x[i]==w;\n    f|=y[i]==1||y[i]==h;\n  }\n  int ans=0;\n  UnionFind uf(n);\n  for(int i=0;i<MAX;i++){\n    for(int j=0;j<(int)vx[i].size();j++)\n      uf.unite(m[P(i,vx[i][0])],m[P(i,vx[i][j])]);\n    for(int j=0;j<(int)vy[i].size();j++)\n      uf.unite(m[P(vy[i][0],i)],m[P(vy[i][j],i)]);\n  }\n  for(int i=0;i<n;i++){\n    if(uf.find(i)!=i) continue;\n    ans+=uf.r[i]+1;\n  }\n  cout<<ans-1-f<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\n\nstruct UnionFind {\n    int data[40000];\n    UnionFind() {\n        memset(data, -1, sizeof(data));\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\nint can_unite[2][100000];\nint slime[40000][2];\nint main() {\n    int N, W, H;\n    scanf(\"%d%d%d\", &N, &W, &H);\n    int x_, y_;\n    bool edge = false;\n    rep(i, N){\n        scanf(\"%d%d\", &x_, &y_); --x_; --y_;\n        slime[i][0] = x_; slime[i][1] = y_;\n        if(x_ == 0 || x_ == W - 1 || y_ == 0 || y_ == H - 1)\n          edge = true;\n    }\n    \n    memset(can_unite, -1, sizeof(can_unite));\n    UnionFind uf;\n    int ans = 0;\n    rep(i, N) rep(j, 2) {\n        int& a = can_unite[j][slime[i][j]];\n        if(a == -1) a = i;\n        else if(!uf.same(a, i)) {\n            uf.unite(a, i);\n            ans++;\n        }\n    }\n    \n    bitset<40000> roots(0);\n    rep(i, N) roots[uf.root(i)] = 1;\n    int temp = roots.count();\n    if(temp == 1) printf(\"%d\\n\", ans);\n    else {\n        ans += temp * 2 - 1;\n        if(edge) --ans;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\ntypedef pair<pair<int,int>,int> P;\n\nconst int gmax_n = 40005;\n\nint par[gmax_n]; //???\nint depth[gmax_n];//??¨?????±???\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\tdepth[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(depth[x] < depth[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(depth[x] == depth[y]) depth[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint main(){\n\tint n, h, w;\n\tcin >> n >> w >> h;\n\n\tvector<pair<int, int>> in(n);\n\t//vector<P> x(n), y(n);\n\trep(i,n){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tin[i] = make_pair(a,b);\n\t\t//x[i] = make_pair(make_pair(a,b),i);\n\t\t//y[i] = make_pair(make_pair(b,a),i);\n\t}\n\t//sort(all(x));\n\t//sort(all(y));\n\n\tinit(n);\n\trep(i,n){\n\t\t//auto xs = lower_bound(all(x), make_pair(make_pair(in[i].first, - 1),-1));\n\t\t//for(; xs != x.end() && xs->first.first == in[i].first; xs++){\n\t\t//\tunite(i, xs->second);\n\t\t//}\n\t\t//auto ys = lower_bound(all(y), make_pair(make_pair(in[i].second, - 1),-1));\n\t\t//for(; ys != y.end() && ys->first.second == in[i].second; ys++){\n\t\t//\tunite(i, ys->second);\n\t\t//}\n\t\trep(j,n){\n\t\t\tif(in[i].first == in[j].first || in[i].second == in[j].second){\n\t\t\t\tunite(i,j);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tmap<int,int> m;\n\tvector<bool> isEdge(n,0);\n\trep(i,n){\n\t\tif(in[i].first == 1 || in[i].first == w || in[i].second == 1 || in[i].second == h){\n\t\t\tisEdge[find(i)] = true;\n\t\t}\n\t\tm[find(i)]++;\n\t}\n\tauto f = [&](){\n\t\tif(m.size() == 1) return 0;\n\t\trep(i,n){\n\t\t\tif(isEdge[find(i)]) return 0;\n\t\t}\n\t\treturn 1;\n\t};\n\n\tfor(auto i : m){\n\t\tans += i.second - 1;\n\t}\n\tans += (m.size() - 1) * 2;\n\tcout << ans + f() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct dsu {\n  int cc;\n  vector<int> p, sz;\n  dsu(int n = 0) : cc(n), p(n, -1), sz(n, 1) {}\n  int root(int v) const {\n    while (p[v] != -1) v = p[v];\n    return v;\n  }\n  bool unite(int u, int v) {\n    u = root(u), v = root(v);\n    if (u == v) return false;\n    --cc;\n    if (sz[u] < sz[v]) swap(u, v);\n    p[v] = u;\n    sz[u] += sz[v];\n    return true;\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return sz[root(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, h, w;\n  cin >> n >> h >> w;\n  vector<int> x(n), y(n);\n  vector<vector<int>> row(h), col(w);\n  for (int v = 0; v < n; ++v) {\n    cin >> x[v] >> y[v];\n    --x[v], --y[v];\n    row[x[v]].push_back(v);\n    col[y[v]].push_back(v);\n  }\n  dsu d(n);\n  for (auto&& e : row) {\n    sort(begin(e), end(e), [&](int u, int v) {\n      return y[u] < y[v];\n    });\n    for (int i = 0; i < (int)e.size() - 1; ++i) {\n      d.unite(e[i], e[i + 1]);\n    }\n  }\n  for (auto&& e : col) {\n    sort(begin(e), end(e), [&](int u, int v) {\n      return x[u] < x[v];\n    });\n    for (int i = 0; i < (int)e.size() - 1; ++i) {\n      d.unite(e[i], e[i + 1]);\n    }\n  }\n  int res = n - 1;\n  res += d.cc - 1;\n  bool ex = false;\n  ex |= *min_element(begin(x), end(x)) == 0;\n  ex |= *max_element(begin(x), end(x)) == h - 1;\n  ex |= *min_element(begin(y), end(y)) == 0;\n  ex |= *max_element(begin(y), end(y)) == w - 1;\n  res += d.cc >= 2 and not ex;\n  cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UniFi {\n    vector<int> par;\n\n    UniFi(int n):par(n) {\n        for (int i = 0; i < n; i++) par[i] = i;\n    }\n\n    int is_par(int x) {\n        if (x == par[x]) return x;\n        else return par[x] = is_par(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = is_par(x);\n        y = is_par(y);\n\n        if (x < y) par[y] = x;\n        else par[x] = y;\n    }\n\n    int count() {\n        int ret = 0;\n        for (int i = 0; i < par.size(); i++) {\n            if (i == par[i]) ret++;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    int N, H, W;\n    cin >> N >> H >> W;\n\n    UniFi uf(N);\n    vector<vector<pair<int,int> > > x(H), y(W);\n    vector<vector<int> > v(4);\n    for (int i = 0; i < N; i++) {\n        int _x, _y;\n        cin >> _x >> _y;\n        _x--, _y--;\n        x[_x].push_back(make_pair(_y, i));\n        y[_y].push_back(make_pair(_x, i));\n        if (_x == 0) v[0].push_back(i);\n        if (_x == H-1) v[1].push_back(i);\n        if (_y == 0) v[2].push_back(i);\n        if (_y == W-1) v[3].push_back(i);\n    }\n\n    for (int i = 0; i < H; i++) {\n        int point;\n        if (x[i].size()) point = x[i][0].second;\n        else continue;\n        for (auto p : x[i]) {\n            uf.unite(point, p.second);\n        }\n    }\n    for (int i = 0; i < W; i++) {\n        int point;\n        if (y[i].size()) point = y[i][0].second;\n        else continue;\n        for (auto p : y[i]) {\n            uf.unite(point, p.second);\n        }\n    }\n    int count = uf.count();\n    int ans = 1 << 28;\n    if (count > 1) {\n        for (int i = 0; i < 4; i++) {\n            set<int> s;\n            for (auto j : v[i]) s.insert(uf.is_par(i));\n            ans = min(ans, count - (int)s.size());\n        }\n    } else {\n        ans = 0;\n    }\n    cout << ans + N - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-12;\n\nclass Point{\npublic:\n  int x;\n  int y;\n  Point(int _x,int _y) : x(_x),y(_y){}\n  bool operator<(const Point& p) const{\n    if(x==p.x) return y < p.y;\n    else return x < p.x;\n  }\n  bool operator>(const Point& p) const{\n    if(x==p.x) return y > p.y;\n    else return x > p.x;\n  }\n  bool operator==(const Point& p) const{\n    return (x == p.x && y == p.y);\n  }\n};\n\nint dfs(int x,int y,\n\tmap<int,vector<int> >& x2y,\n\tmap<int,vector<int> >& y2x,\n\tmap<Point,bool>& visited){\n  \n  map<Point,bool>::iterator it;\n  if((it = visited.find(Point(x,y))) != visited.end()){\n    return 0;\n  }\n\n  visited[Point(x,y)] = true;\n  int res = 1;\n\n  for(int i=0;i<x2y[x].size();i++){\n    int next_y = x2y[x][i];\n    res += dfs(x,next_y,x2y,y2x,visited);\n  }\n  \n  for(int i=0;i<y2x[y].size();i++){\n    int next_x = y2x[y][i];\n    res += dfs(next_x,y,x2y,y2x,visited);\n  }\n  return res;\n}\n\nint main(){\n  int total_slimes;\n  int W,H;\n  while(~scanf(\"%d %d %d\",&total_slimes,&W,&H)){\n    vector<Point> points;\n    map<int,vector<int> >x2y;\n    map<int,vector<int> >y2x;\n    map<Point,bool> visited;\n    bool has_corner = false;\n    \n    for(int slime_idx=0; slime_idx < total_slimes; slime_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      x--;\n      y--;\n      x2y[x].push_back(y);\n      y2x[y].push_back(x);\n      if(x == 0 || y == 0 || x == W-1 || y == H-1){\n\thas_corner = true;\n      }\n    }\n\n    int group_count = 0;\n    for(map<int,vector<int> >::iterator it = x2y.begin();\n\tit != x2y.end();\n\tit++){\n      int x = it->first;\n      for(int i=0; i < it->second.size(); i++){\n\tint y = it->second[i];\n\tmap<Point,bool>::iterator it;\n\tif((it = visited.find(Point(x,y))) != visited.end()) continue;\n\tdfs(x,y,x2y,y2x,visited);\n\tgroup_count++;\n      }\n    }\n\n    //(cost for initial grouping)\n    //+ (cost for moving to the corner) + (cost for grouping remainings)\n\n    int init_grouping_cost = total_slimes - group_count;\n    printf(\"%d\\n\",init_grouping_cost\n\t   + (group_count > 1 ?\n\t      (group_count + (has_corner ? -1 : 0)) + (group_count - 1)\n\t      : 0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int N, W, H;\n  cin >> N >> W >> H;\n  vector<int> x(N), y(N);\n  for (int i = 0; i < N; i++){\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n  }\n  vector<vector<int>> id1(H);\n  vector<vector<int>> id2(W);\n  for (int i = 0; i < N; i++){\n    id1[y[i]].push_back(i);\n    id2[x[i]].push_back(i);\n  }\n  vector<vector<int>> E(N);\n  for (int i = 0; i < H; i++){\n    if (id1[i].size() > 1){\n      for (int j = 1; j < id1[i].size(); j++){\n        E[id1[i][0]].push_back(id1[i][j]);\n        E[id1[i][j]].push_back(id1[i][0]);\n      }\n    }\n  }\n  for (int i = 0; i < W; i++){\n    if (id2[i].size() > 1){\n      for (int j = 1; j < id2[i].size(); j++){\n        E[id2[i][0]].push_back(id2[i][j]);\n        E[id2[i][j]].push_back(id2[i][0]);\n      }\n    }\n  }\n  vector<bool> used(N, false);\n  vector<int> cc(4, 0);\n  int cnt = 0;\n  for (int i = 0; i < N; i++){\n    if (!used[i]){\n      used[i] = true;\n      cnt++;\n      queue<int> Q;\n      Q.push(i);\n      vector<bool> ok(4, false);\n      while (!Q.empty()){\n        int v = Q.front();\n        Q.pop();\n        if (y[v] == 0){\n          ok[0] = true;\n        }\n        if (y[v] == H - 1){\n          ok[1] = true;\n        }\n        if (x[v] == 0){\n          ok[2] = true;\n        }\n        if (x[v] == W - 1){\n          ok[3] = true;\n        }\n        for (int w : E[v]){\n          if (!used[w]){\n            used[w] = true;\n            Q.push(w);\n          }\n        }\n      }\n      for (int j = 0; j < 4; j++){\n        if (ok[j]){\n          cc[j]++;\n        }\n      }\n    }\n  }\n  if (cnt == 1){\n    cout << N - 1 << endl;\n  } else {\n    cout << N - 1 + cnt - *max_element(cc.begin(), cc.end()) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct input{input(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\nnamespace _UF{\n    #define SZ 500000\n    int mem[2][SZ];\n}\nclass UnionFind{\nprivate:\n    int *par,*rank;\n    int find(int x){\n\tif(par[x]==x)return x;\n\telse return par[x]=find(par[x]);\n    }\npublic:\n    UnionFind(int n):par(_UF::mem[0]),rank(_UF::mem[1]){\n\trep(i,n)par[i]=i,rank[i]=0;\n    }\n    bool unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return false;\n\tif(rank[x]<rank[y])par[x]=y;\n\telse{\n\t    par[y]=x;\n\t    if(rank[x]==rank[y])rank[x]++;\n\t}\n\treturn true;\n    }\n    bool same(int x,int y){\n\treturn find(x)==find(y);\n    }\n};\n\nint main(){\n    int N,C,R;\n    cin>>N>>C>>R;\n    map<int,int> rs,cs;\n    int bottom=1;\n    int res=0;\n    UnionFind uf(N);\n    rep(i,N){\n\tint r,c;\n\tcin>>c>>r;\n\tif(rs.count(r))\n\t    res+=uf.unite(rs[r],i);\n\telse rs[r]=i;\n\tif(cs.count(c))\n\t    res+=uf.unite(cs[c],i);\n\telse cs[c]=i;\n\tbottom=min({bottom,r-1,c-1,R-r,C-r});\n    }\n    if(res==N-1)cout<<res<<endl;\n    else{\n\tres+=(bottom>0);\n\trep(i,N)\n\t    if(!uf.same(0,i)){\n\t\tres+=2;\n\t\tuf.unite(0,i);\n\t    }\n\tcout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    int getSize(int x) {\n        return -uni[root(x)];\n    }\n    int numOfGroups() {\n        int ret = 0;\n        rep(i, n) {\n            if (uni[i] < 0) ret++;\n        }\n        return ret;\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nstruct Range {\n    int l, r; // [l, r]\n    Range(){}\n    Range(int _l, int _r) : l(_l), r(_r) {}\n    bool operator<( const Range& o ) const {\n        if (l != o.l) return l < o.l;\n        return r < o.r;\n    }\n    void print() {\n        cout << \"l = \" << l << \", r = \" << r << endl;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<Pii> vp;\n    map<Pii, int> mp;\n    rep(i, N) {\n        int r, c;\n        cin >> r >> c;\n        r--; c--;\n        vp.emplace_back(r, c);\n        mp[Pii(r, c)] = i;\n    }\n\n    UnionFind uf(N);\n    sort(all(vp));\n    rep(i, N) {\n        if (vp[i].first == vp[i + 1].first) {\n            uf.unite(mp[vp[i]], mp[vp[i + 1]]);\n        }\n    }\n\n    sort(all(vp), [](const Pii& p, const Pii& q) {\n        if (p.second != q.second) return p.second < q.second;\n        return p.first < q.first;\n    });\n    rep(i, N) {\n        if (vp[i].second == vp[i + 1].second) {\n            uf.unite(mp[vp[i]], mp[vp[i + 1]]);\n        }\n    }\n\n    int m = uf.numOfGroups();\n\n    if (m == 1) {\n        cout << N - 1 << endl;\n        return 0;\n    }\n\n    vector<set<int>> st(4);\n    rep(i, N) {\n        if (vp[i].first == 0)       st[0].insert(uf.root(mp[vp[i]]));\n        if (vp[i].first == H - 1)   st[1].insert(uf.root(mp[vp[i]]));\n        if (vp[i].second == 0)      st[2].insert(uf.root(mp[vp[i]]));\n        if (vp[i].second == W - 1)  st[3].insert(uf.root(mp[vp[i]]));\n    }\n\n    int ma = 0;\n    rep(i, 4) chmax(ma, (int)st[i].size());\n\n    cout << N + m - 1 - ma << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nstruct UnionFind {\n  int n,num;\n  vector<int> r,p;\n  UnionFind() {}\n  UnionFind(int n):n(n),num(n),r(n,1),p(n,0){iota(p.begin(),p.end(),0);}\n  int find(int x) {\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y) {\n    return find(x)==find(y);\n  }\n  void unite(int x,int y) {\n    x=find(x);y=find(y);\n    if (x==y) return;\n    if (r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  int size(int x) {\n    return r[find(x)];\n  }\n  int count() {\n    return num;\n  }\n};\n\nint N,W,H;\nint x[40010],y[40010];\nvector<int> vx[100010],vy[100010];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> N >> W >> H;\n  int flag = 0;\n  REP(i,N) {\n    cin >> x[i] >> y[i];\n    x[i]--; y[i]--;\n    vx[x[i]].push_back(i);\n    vy[y[i]].push_back(i);\n    if (x[i] == 0 || x[i] == W-1 || y[i] == 0 || y[i] == H-1) flag = 1;\n  }\n  UnionFind uf(N);\n  REP(i,100010) {\n    for (int j = 0; j+1 < vx[i].size(); j++) {\n      uf.unite(vx[i][j],vx[i][j+1]);\n    }\n    for (int j = 0; j+1 < vy[i].size(); j++) {\n      uf.unite(vy[i][j],vy[i][j+1]);\n    }\n  }\n  set<pii> st;\n  REP(i,N) st.insert(pii(uf.find(i),uf.size(i)));\n  int ans = 0;\n  for (auto p : st) ans += p.second-1;\n  if (uf.count() > 1) ans += 2*uf.count()-1-flag;\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n\nclass unionfind {\nprivate:\n\tint size_;\n\tstd::vector<int> parent;\n\tstd::vector<int> rank;\npublic:\n\tunionfind() : size_(0), parent(std::vector<int>()), rank(std::vector<int>()) {};\n\tunionfind(int size__) : size_(size__), parent(std::vector<int>(size_)), rank(std::vector<int>(size_, 0)) {\n\t\tstd::iota(parent.begin(), parent.end(), 0);\n\t}\n\tint size() { return size_; }\n\tint root(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) parent[x] = y;\n\t\telse if (rank[x] > rank[y]) parent[y] = x;\n\t\telse parent[y] = x, rank[x]++;\n\t}\n};\n\nint W, H, N, x[40009], y[40009], tx[100009], ty[100009], cnt[40009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &W, &H);\n\tfill(tx, tx + W, -1);\n\tfill(ty, ty + H, -1);\n\tbool flag = false;\n\tunionfind uf(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--, y[i]--;\n\t\tif (x[i] == 0 || y[i] == 0 || x[i] == W - 1 || y[i] == H - 1) flag = true;\n\t\tif (tx[x[i]] != -1) uf.unite(tx[x[i]], i); tx[x[i]] = i;\n\t\tif (ty[y[i]] != -1) uf.unite(ty[y[i]], i); ty[y[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++) cnt[uf.root(i)]++;\n\tint comp = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (cnt[i]) comp++;\n\t}\n\tint ret = N + comp - 1;\n\tif (comp == 1 || flag) ret--;\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i < 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<map>\n#include<iterator>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\nconst int MAX = 100'000;\n\n//変数\nint N, H, W;\nvector<pair<int, int>> xy;\nvector<bool> use;\nmap<int, vector<int>> x2i, y2i;\n\nvector<int> udlr = vector<int>(4, 0);\n\n\n\n//サブ関数\n//入力\nvoid input()\n{\n\tcin >> N >> H >> W;\n\tH--; W--;\n\tuse.resize(N, false);\n\tREP(i, N) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\txy.push_back({ a,b });\n\t}\n}\n\n\nvoid make_xy_join()\n{\n\t//x,y軸で、座標毎の含有点作成\n\tREP(i,N){\n\t\tint x = xy[i].first;\n\t\tint y = xy[i].second;\n\n\n\t\tif (x2i.find(x) == x2i.end()) x2i[x] = vector<int>();\n\t\tx2i[x].push_back(i);\n\n\n\t\tif (y2i.find(y) == y2i.end()) y2i[y] = vector<int>();\n\t\ty2i[y].push_back(i);\n\t}\n}\n\n\nvoid make_connected_graph(int route)\n{\n\tqueue<int> q;\n\tvector<bool> mudlr = vector<bool>(4, false);\n\tq.push(route);\n\tuse[route] = true;\n\n\twhile (!q.empty()) {\n\t\tint node = q.front(); q.pop();\n\t\tint x = xy[node].first;\n\t\tint y = xy[node].second;\n\n\t\tif (y == 0)mudlr[0] = true;\n\t\tif (y == H - 1)mudlr[1] = true;\n\t\tif (x == 0)mudlr[2] = true;\n\t\tif (x == W - 1)mudlr[3] = true;\n\n\n\t\tfor (int next : x2i[x]) if (!use[next]) {\n\t\t\tuse[next] = true;\n\t\t\tq.push(next);\n\t\t}\n\t\tfor (int next : y2i[y]) if (!use[next]) {\n\t\t\tuse[next] = true;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) if (mudlr[i]) {\n\t\tudlr[i]++;\n\t}\n}\n\n\n//計算\nvoid calc()\n{\n\tint tree = 0;\n\n\tmake_xy_join();\n\tREP(i, N) if (!use[i]) {\n\t\ttree++;\n\t\tmake_connected_graph(i);\n\t}\n\n\n\tif (tree == 1) {\n\t\tcout << N - 1 << endl;\n\t}\n\telse {\n\t\tcout << N + tree - 1 - *max_element(udlr.begin(), udlr.end()) << endl;\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tinput();\n\tcalc();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n\nclass unionfind {\nprivate:\n\tint size_;\n\tstd::vector<int> parent;\n\tstd::vector<int> rank;\npublic:\n\tunionfind() : size_(0), parent(std::vector<int>()), rank(std::vector<int>()) {};\n\tunionfind(int size__) : size_(size__), parent(std::vector<int>(size_)), rank(std::vector<int>(size_, 0)) {\n\t\tstd::iota(parent.begin(), parent.end(), 0);\n\t}\n\tint size() { return size_; }\n\tint root(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) parent[x] = y;\n\t\telse if (rank[x] > rank[y]) parent[y] = x;\n\t\telse parent[y] = x, rank[x]++;\n\t}\n};\n\nint W, H, N, x[40009], y[40009], tx[100009], ty[100009], cnt[40009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &W, &H);\n\tfill(tx, tx + W, -1);\n\tfill(ty, ty + H, -1);\n\tbool flag = false;\n\tunionfind uf(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--, y[i]--;\n\t\tif (x[i] == 0 || y[i] == 0 || x[i] == W - 1 && y[i] == H - 1) flag = true;\n\t\tif (tx[x[i]] != -1) uf.unite(tx[x[i]], i); tx[x[i]] = i;\n\t\tif (ty[y[i]] != -1) uf.unite(ty[y[i]], i); ty[y[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++) cnt[uf.root(i)]++;\n\tint comp = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (cnt[i]) comp++;\n\t}\n\tint ret = N + comp - 1;\n\tif (flag && comp >= 2) ret--;\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nstruct UnionFind{\n\tvector<int> par, sz;\n\tUnionFind(int n){\n\t\tpar = sz = vector<int>(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, sz[i] = 1;\n\t}\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x){\n\t\treturn sz[find(x)];\n\t}\n};\n\nbool cmp(const tuple<int, int, int> &a, const tuple<int, int, int> &b){\n\treturn get<1>(a) < get<1>(b);\n}\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\n\tvector<tuple<int, int, int>> v(n);\n\n\tbool edge = false;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv[i] = MT(x, y, i);\n\t\tif (x == w || y == h) edge = true;\n\t}\n\n\tUnionFind uf(n);\n\n\tsort(ALL(v));\n\trep(i, n - 1) if (get<0>(v[i]) == get<0>(v[i + 1])) uf.unite(get<2>(v[i]), get<2>(v[i + 1]));\n\tsort(ALL(v), cmp);\n\trep(i, n - 1) if (get<1>(v[i]) == get<1>(v[i + 1])) uf.unite(get<2>(v[i]), get<2>(v[i + 1]));\n\n\tset<int> st;\n\trep(i, n) st.insert(uf.find(i));\n\n\tint mv = st.size();\n\tif (mv == 1 || edge) --mv;\n\n\tcout << n + mv - 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll calc(vector<vector<ll>>& G,ll x){\n    ll ret = 0;\n    ll cnt = 0;\n    \n    for(int i = 0; i < G.size();i++){\n        if(G[i].empty()) continue;\n        cnt++;\n    }\n    if(cnt == 1){\n        for(int i = 0; i < G.size();i++){\n            if(G[i].empty()) continue;\n            return ret = G[i].size()-1;\n        }\n    }\n    \n    cnt = 0;\n    for(int i = 0; i < G.size(); i++){\n        if(G[i].empty()) continue;\n        cnt++;\n        if(G[i][0] == x){\n            ret += G[i].size() - 1;\n        }else{\n            ret += G[i].size();\n        }\n    }\n//    cout << ret << \" \" << cnt << endl;\n    ret += (cnt-1);\n    return ret;\n}\nll solve(){\n    ll res = LINF;\n    ll N,W,H; cin >> N >> W >> H;\n    vector<ll> x(N),y(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i];\n    \n    vector<vector<ll>> wG(W+2),hG(H+2);\n    for(int i = 0; i < N;i++){\n        wG[x[i]].push_back(y[i]);\n        hG[y[i]].push_back(x[i]);\n    }\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end());\n    res = min({res,calc(wG,1),calc(hG,1)});\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end(),greater<ll>());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end(),greater<ll>());\n    res = min({res,calc(wG,H),calc(hG,W)});\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> Ws[100001], Hs[100001];\nint par[40000];\n\nint find(int x)\n{\n    return (par[x] >= 0 ? par[x] = find(par[x]) : x);\n}\n\nvoid merge(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (-par[x] < -par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n\nint main()\n{\n    int n, w, h;\n    int cw = 0, ch = 0;\n    \n    scanf(\"%d %d %d\", &n, &w, &h);\n    \n    for (int i = 0; i < n; i++){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        \n        if (a == 1 || a == w) cw = 1;\n        if (b == 1 || b == h) ch = 1;\n        \n        Ws[a].push_back(i);\n        Hs[b].push_back(i);\n    }\n    \n    memset(par, -1, sizeof(par));\n    for (int i = 1; i <= w; i++){\n        for (int j = 1; j < Ws[i].size(); j++){\n            merge(Ws[i][j - 1], Ws[i][j]);\n        }\n    }\n    for (int i = 1; i <= h; i++){\n        for (int j = 1; j < Hs[i].size(); j++){\n            merge(Hs[i][j - 1], Hs[i][j]);\n        }\n    }\n    \n    set<int> s;\n    for (int i = 0; i < n; i++) s.insert(find(i));\n    \n    printf(\"%d\\n\", s.size() == 1 ? n - 1 : (n - 1 + s.size() - (cw | ch)));\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[i] < 0) memoX[i] = x;//???????????????????????????????????\\??£????????¨???????????°???????????¢??£?????????\n\t\telse ds.unite(x, memoX[i]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[i] < 0) memoY[i] = y;\n\t\telse ds.unite(y, memoY[i]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\t//printf(\"%d %d\\n\", n, m);\n\tif(cornerw == true || cornerh == true){\n\t\tprintf(\"%d\\n\", n + m - 2);\n\t}else{\n\t\tprintf(\"%d\\n\", n + m - 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<map>\n#include<iterator>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\nconst int MAX = 100'000;\n\n//変数\nint N, H, W;\nvector<pair<int, int>> xy;\nvector<bool> use;\nmap<int, vector<int>> x2i, y2i;\n\nvector<int> udlr = vector<int>(4, 0);\n\n\n\n//サブ関数\n//入力\nvoid input()\n{\n\tcin >> N >> H >> W;\n\tuse.resize(N, false);\n\tREP(i, N) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\txy.push_back({ a,b });\n\t}\n}\n\n\nvoid make_xy_join()\n{\n\t//x,y軸で、座標毎の含有点作成\n\tREP(i,N){\n\t\tint x = xy[i].first;\n\t\tint y = xy[i].second;\n\n\n\t\tif (x2i.find(x) == x2i.end()) x2i[x] = vector<int>();\n\t\tx2i[x].push_back(i);\n\n\n\t\tif (y2i.find(y) == y2i.end()) y2i[y] = vector<int>();\n\t\ty2i[y].push_back(i);\n\t}\n}\n\n\nvoid make_connected_graph(int route)\n{\n\tqueue<int> q;\n\tvector<bool> mudlr = vector<bool>(4, false);\n\tq.push(route);\n\tuse[route] = true;\n\n\twhile (!q.empty()) {\n\t\tint node = q.front(); q.pop();\n\t\tint x = xy[node].first;\n\t\tint y = xy[node].second;\n\n\t\tif (y == 0)mudlr[0] = true;\n\t\tif (y == H - 1)mudlr[1] = true;\n\t\tif (x == 0)mudlr[2] = true;\n\t\tif (x == W - 1)mudlr[3] = true;\n\n\n\t\tfor (int next : x2i[x]) if (!use[next]) {\n\t\t\tuse[next] = true;\n\t\t\tq.push(next);\n\t\t}\n\t\tfor (int next : y2i[y]) if (!use[next]) {\n\t\t\tuse[next] = true;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) if (mudlr[i]) {\n\t\tudlr[i]++;\n\t}\n}\n\n\n//計算\nvoid calc()\n{\n\tint tree = 0;\n\n\tmake_xy_join();\n\tREP(i, N) if (!use[i]) {\n\t\ttree++;\n\t\tmake_connected_graph(i);\n\t}\n\n\n\tif (tree == 1) {\n\t\tcout << N - 1 << endl;\n\t}\n\telse {\n\t\tcout << N + tree - 1 - *max_element(udlr.begin(), udlr.end()) << endl;\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tinput();\n\tcalc();\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    vector<int>f;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        f.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n            f[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        f[x]|=f[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H,W;\nint x[44444],y[44444];\nint px[111111],py[111111];\n\nint solve(int T){\n    UF uf;uf.init(N);\n    memset(px,-1,sizeof(px));\n    memset(py,-1,sizeof(py));\n    rep(i,N){\n        if(px[x[i]]>=0)uf.unite(px[x[i]],i);\n        if(py[y[i]]>=0)uf.unite(py[y[i]],i);\n        if(y[i]==T)uf.f[uf.find(i)]=1;\n        px[x[i]]=i;py[y[i]]=i;\n    }\n\n    int cnt1=0,cnt2=0;\n    rep(i,N)if(uf.find(i)==i){\n        cnt1++;\n        if(uf.f[i])cnt2++;\n    }\n\n    if(cnt1==1)return N-1;\n    return N-cnt1+cnt1-cnt2+cnt1-1;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&N,&H,&W);\n    rep(i,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n\n    int ans=1001001001;\n    rep(i,2){\n        chmin(ans,solve(1));\n        chmin(ans,solve(H));\n        swap(H,W);\n        rep(j,N)swap(x[j],y[j]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint main(){\n  int n,w,h,x,y;\n  cin >> n >> w >> h;\n  UF uf(h+w+n);\n  int nearWall = 0;\n  rep(i,n){\n    cin >> x >> y;\n    uf.unite(n+x-1,i);\n    uf.unite(n+w+y-1,i);\n    if(x==1 || y==1 || x==w || y==h)nearWall = 1;\n  }\n  \n  set<int> group;\n  rep(i,n)group.insert(uf.find(i));\n  int k = group.size();\n  if(k==1){\n    cout << n-1 << endl;\n  }else{\n    cout << n-k + 2*k-1 - nearWall << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n,h,w;\nvector<P> ah[100001],aw[100001];\nset<int> ps,hs[4];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>w>>h;\n  UnionFind uf(n);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x--; y--;\n    ah[y].push_back(P(x,i)); \n    aw[x].push_back(P(y,i));\n  }\n  rep(i,h){\n    rep(j,ah[i].size()-1){\n      uf.unite(ah[i][j].se,ah[i][j+1].se);\n    }\n  }\n  rep(i,w){\n    rep(j,aw[i].size()-1){\n      uf.unite(aw[i][j].se,aw[i][j+1].se);\n    }\n  }\n  if(uf.size(0)==n){\n    cout<<n-1<<endl;\n    return 0;\n  }\n  rep(i,h){\n    rep(j,ah[i].size()){\n      ps.insert(uf.find(ah[i][j].se));\n      if(ah[i][j].fi==0)hs[0].insert(uf.find(ah[i][j].se));\n      if(ah[i][j].fi==h-1)hs[1].insert(uf.find(ah[i][j].se));\n    }\n  }\n\n  rep(i,w){\n    rep(j,aw[i].size()){\n      ps.insert(uf.find(aw[i][j].se));\n      if(aw[i][j].fi==0)hs[2].insert(uf.find(aw[i][j].se));\n      if(aw[i][j].fi==w-1)hs[3].insert(uf.find(aw[i][j].se));\n    }\n  }\n  int res=INF;\n  int sum=0;\n  each(it,ps){\n    sum+=uf.size(it)-1;\n  }\n  rep(k,4){\n    minch(res,sum+ps.size()*2-1-hs[k].size());\n  }\n  cout<<res<<endl;\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<bool> visited;\nvector<vector<int>> g;\nvector<pair<int,int>> pi;\nvector<pair<pair<int,int>,int>> px;\nvector<pair<pair<int,int>,int>> py;\nint ans=0;\nint n,w,h;\nint wall;\nint wallcnt[]={0,0,0,0};\nint colsize;\n\nbool dfsended(){\n    for (auto i:visited)if(!i)return false;\n    return true;\n}\n\nint dfs(int sid){\n    visited[sid]=true;\n    ++colsize;\n    if(pi[sid].first==1)wall=0;\n    if(pi[sid].second==1)wall=1;\n    if(pi[sid].first==w)wall=2;\n    if(pi[sid].second==h)wall=3;\n\n    for(auto i:g[sid]){\n        if(!visited[i])dfs(i);\n    }\n\n}\n\nint main() {\n    cin>>n>>w>>h;\n    for (int i = 0; i < n; ++i) {\n        int x,y;\n        cin>>x>>y;\n        pi.emplace_back(x,y);\n        px.emplace_back(make_pair(make_pair(x,y),i));\n        py.emplace_back(make_pair(make_pair(y,x),i));\n    }\n    sort(px.begin(),px.end());\n    sort(py.begin(),py.end());\n\n    g=vector<vector<int>>(n);\n    for (int i = 0; i < n-1; ++i) {\n        if(px[i].first.first==px[i+1].first.first){\n            g[px[i].second].emplace_back(px[i+1].second);\n            g[px[i+1].second].emplace_back(px[i].second);\n        }\n    }\n    for (int i = 0; i < n-1; ++i) {\n        if(py[i].first.first==py[i+1].first.first){\n            g[py[i].second].emplace_back(py[i+1].second);\n            g[py[i+1].second].emplace_back(py[i].second);\n        }\n    }\n\n    visited=vector<bool>(n,false);\n\n    int colcnt=0;\n    while(!dfsended()){\n        int sid;\n        for (int i = 0; i < n; ++i) {\n            if(!visited[i]){\n                sid=i;\n                break;\n            }\n        }\n        wall=-1;\n        colsize=0;\n        dfs(sid);\n        ans+=colsize-1;\n        if(wall!=-1)++wallcnt[wall];\n        ++colcnt;\n    }\n    if (colcnt == 1) {\n        if(wall!=-1)++ans;\n    }\n    else {\n        ans += colcnt + (colcnt - 1);\n    }\n    int t=0;\n    for (int i = 0; i < 4; ++i) {\n        t=max(t,wallcnt[i]);\n    }\n    ans-=t;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vp = vector<Pii>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N, H, W;\n    cin >> N >> H >> W;\n    vi row(H);\n    vi col(W);\n    int num_row_exist = 0;\n    int num_col_exist = 0;\n    rep(i, N) {\n        int r, c;\n        cin >> r >> c;\n        r--; c--;\n        if (row[r] == 0) num_row_exist++;\n        row[r]++;\n        if (col[c] == 0) num_col_exist++;\n        col[c]++;\n    }\n\n    int ans = inf;\n    rep(r, H) {\n        if (row[r] == num_col_exist) chmin(ans, N - 1);\n    }\n    rep(c, W) {\n        if (col[c] == num_row_exist) chmin(ans, N - 1);\n    }\n    chmin(ans, N - row[0] + num_col_exist - 1);\n    chmin(ans, N - row.back() + num_col_exist - 1);\n    chmin(ans, N - col[0] + num_row_exist - 1);\n    chmin(ans, N - col.back() + num_row_exist - 1);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\nint N,H,W;\nint y,x;\nvector<int> G[2][MAX];\nbool visited[2][MAX];\nint flg[4],cnt[4];\n\nvoid dfs(int f,int p){\n  visited[f][p]=true;\n  if(p==0)flg[f]=true;\n  if(p==(f==0?H:W))flg[2+f]=true;\n  \n  int r=1-f;\n  for(int i=0;i<(int)G[f][p].size();i++){\n    int w=G[f][p][i];\n    if(visited[r][w])continue;\n    dfs(r,w);\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&H,&W);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d\",&y,&x);\n    G[0][y].push_back(x);\n    G[1][x].push_back(y);\n  }\n  \n  int ans=0;\n  for(int i=0;i<MAX;i++){\n    if(G[0][i].size()==0)continue;\n    if(visited[0][i])continue;\n    for(int j=0;j<4;j++)flg[j]=0;\n    dfs(0,i);\n    ans++;\n    for(int j=0;j<4;j++)cnt[j]+=flg[j];\n  }\n  for(int i=1;i<4;i++)cnt[i]=max(cnt[i],cnt[i-1]);\n  if(ans==1){\n    cout<<N-1<<endl;\n  }else{\n    cout<<N+ans-1-cnt[3]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    int n,w,h;\n    cin >> n >> w >> h;\n\n    union_find uf(n);\n    vector<array<bool,4>> flags;\n    map<int,vector<pii>> mp1,mp2;\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        --x;\n        --y;\n        mp1[x].emplace_back(make_pair(y,i));\n        mp2[y].emplace_back(make_pair(x,i));\n        flags.emplace_back(array<bool,4>{x==0,y==0,x==w-1,y==h-1});\n    }\n\n    auto update=[](array<bool,4> &a,array<bool,4> &b){\n        rep(i,0,4) a[i]|=b[i];\n    };\n    int cnt_move=0;\n    for(auto it=mp1.begin(); it!=mp1.end(); ++it) for(const auto &p:it->second){\n        if(uf.is_same(it->second.front().second,p.second)) continue;\n        const int x=uf.find(it->second.front().second),y=uf.find(p.second);\n        uf.unite(x,y);\n        update(flags[uf.find(p.second)],flags[x]);\n        update(flags[uf.find(p.second)],flags[y]);\n        ++cnt_move;\n    }\n    for(auto it=mp2.begin(); it!=mp2.end(); ++it) for(const auto &p:it->second){\n        if(uf.is_same(it->second.front().second,p.second)) continue;\n        const int x=uf.find(it->second.front().second),y=uf.find(p.second);\n        uf.unite(x,y);\n        update(flags[uf.find(p.second)],flags[x]);\n        update(flags[uf.find(p.second)],flags[y]);\n        ++cnt_move;\n    }\n\n    if(uf.cnt==1){\n        cout << cnt_move << endl;\n        return;\n    }\n\n    int ans=inf;\n    set<int> reps;\n    rep(i,0,n) reps.insert(uf.find(i));\n    rep(i,0,4){\n        int cnt=0;\n        for(int idx:reps) if(!flags[idx][i]) ++cnt;\n        ans=min(ans,cnt_move+cnt);\n    }\n    ans+=uf.cnt-1;\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n\n//21:43\n//21:52 compiled\n//21:54 passed sample\n\nstruct unifo{\n\tint n;\n\tint uni[100005];\n\tvoid init(int in){\n\t\tn=in;\n\t\trep(i,n)uni[i]=i;\n\t}\n\tint find(int p){\n\t\tif(uni[p]==p)return p;\n\t\telse return (uni[p]=find(uni[p]));\n\t}\n\tvoid mer(int p,int q){\n\t\tif(!same(p,q))uni[find(p)]=find(q);\n\t}\n\tbool same(int p,int q){\n\t\treturn find(p)==find(q);\n\t}\n\tvoid out(){\n\t\tvector<mp> ps;\n\t\t//printf(\"%d %d\\n\",i,find(i));\n\t\trep(i,n)ps.push_back(mp(find(i),i));\n\t\tsort(ps.begin(),ps.end());\n\t\tprintf(\"uni .. %d elem\\n{ \",n);\n\t\trep(i,n){\n\t\t\tif(i!=0 && ps[i-1].fir!=ps[i].fir)printf(\"}\\n{ \");\n\t\t\tprintf(\"%d \",ps[i].sec);\n\t\t}\n\t\tprintf(\"}\\n\\n\");\n\t}\n} uni;\n\n\nint n,w,h;\n\ntypedef pair<mp,int> mmp;\nmp xs[40005];\nmp ys[40005];\n\nint gone[40005]={};\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\tuni.init(n+10);\n\t\n\tbool isw=false;\n\trep(i,n){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\txs[i]=mp(x,i);\n\t\tys[i]=mp(y,i);\n\t\tif(x==1 || x==w)isw=true;\n\t\tif(y==1 || y==h)isw=true;\n\t}\n\tsort(xs,xs+n);\n\tsort(ys,ys+n);\n\t\n\trep(i,n-1){\n\t\tif(xs[i].fir==xs[i+1].fir)uni.mer(xs[i].sec,xs[i+1].sec);\n\t\tif(ys[i].fir==ys[i+1].fir)uni.mer(ys[i].sec,ys[i+1].sec);\n\t}\n\t\n\tint gn=0;\n\trep(i,n){\n\t\tint p = uni.find(i);\n\t\tif(gone[p])continue;\n\t\tgone[p]=1; gn++;\n\t}\n\t\n\tint ans=n-1+gn;\n\tif(gn==1 || isw)ans--;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n,h,w;\nvector<P> ah[100010],aw[100010];\nset<int> ps,hs[4];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>w>>h;\n  UnionFind uf(n);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x--; y--;\n    ah[y].push_back(P(x,i)); \n    aw[x].push_back(P(y,i));\n  }\n  rep(i,100001){\n    sort(all(ah[i]));\n    sort(all(aw[i]));\n  }\n  rep(i,h){\n    rep(j,ah[i].size()-1){\n      uf.unite(ah[i][j].se,ah[i][j+1].se);\n    }\n  }\n  rep(i,w){\n    rep(j,aw[i].size()-1){\n      uf.unite(aw[i][j].se,aw[i][j+1].se);\n    }\n  }\n  if(uf.size(0)==n){\n    cout<<n-1<<endl;\n    return 0;\n  }\n  rep(i,h){\n    rep(j,ah[i].size()){\n      ps.insert(uf.find(ah[i][j].se));\n      if(ah[i][j].fi==0)hs[0].insert(uf.find(ah[i][j].se));\n      if(ah[i][j].fi==w-1)hs[1].insert(uf.find(ah[i][j].se));\n    }\n  }\n\n  rep(i,w){\n    rep(j,aw[i].size()){\n      ps.insert(uf.find(aw[i][j].se));\n      if(aw[i][j].fi==0)hs[2].insert(uf.find(aw[i][j].se));\n      if(aw[i][j].fi==h-1)hs[3].insert(uf.find(aw[i][j].se));\n    }\n  }\n  int res=INF;\n  int sum=0;\n  each(it,ps){\n    sum+=uf.size(it)-1;\n  }\n  rep(k,4){\n    minch(res,sum+ps.size()*2-1-hs[k].size());\n  }\n  cout<<res<<endl;\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int N) : data(N, -1) {}\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\nint can_unite[2][100000];\nint slime[40000][2];\nint main() {\n    int N, W, H;\n    scanf(\"%d%d%d\", &N, &W, &H);\n    int x_, y_;\n    bool edge = false;\n    rep(i, N){\n        scanf(\"%d%d\", &x_, &y_); --x_; --y_;\n        slime[i][0] = x_; slime[i][1] = y_;\n        if(x_ == 0 || x_ == W - 1 || y_ == 0 || y_ == H - 1)\n          edge = true;\n    }\n    \n    memset(can_unite, -1, sizeof(can_unite));\n    UnionFind uf(N);\n    int ans = 0;\n    rep(i, N) rep(j, 2) {\n        int& a = can_unite[j][slime[i][j]];\n        if(a == -1) a = i;\n        else if(!uf.same(a, i)) {\n            uf.unite(a, i);\n            ans++;\n        }\n    }\n    \n    bitset<40000> roots(0);\n    rep(i, N) roots[uf.root(i)] = 1;\n    int temp = roots.count();\n    if(temp == 1) cout << ans << endl;\n    else {\n        ans += temp * 2 - 1;\n        if(edge) --ans;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    // x, y????????????\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    // x, y?????????????????????1\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // x??????????????????????????§???????????????\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // ?????¢??????????????????????????°?????????\n    int setNum(void) {\n        map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n    void print(void) {\n        auto c = getUnionList();\n        for (auto x : c) {\n            for (auto y : x) \n                cout << y << \" \";\n            cout << endl;\n        }\n    }\n};\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, nx, ny; cin >> n >> nx >> ny;\n    vector<P> s(n);\n    \n    vll rx(nx, -1), ry(ny, -1);\n    bool is_wall = 0;\n    rep(i, n) {\n        cin >> s[i].fi >> s[i].se; s[i].fi--; s[i].se--;\n        rx[s[i].fi] = ry[s[i].se] = i;\n        is_wall |= (s[i].fi == 0 || s[i].fi == nx-1 || s[i].se == 0 || s[i].se == ny-1);\n    }\n\n    UnionFind uf(n);\n    rep(i, n) {\n        uf.unite(i, rx[s[i].fi]);\n        uf.unite(i, ry[s[i].se]);\n    }\n\n    auto list = uf.getUnionList();\n    if (list.size() == 1) {\n        cout << (*list.begin()).size() - 1 << endl;\n        return 0;\n    }\n\n    ll ret = 0;\n    for (auto x : list) \n        ret += x.size() - 1;\n    cout << ret + 2 * list.size() - is_wall - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  rep(i,N) { \n    cin >> x[i] >> y[i]; \n    uf[i] = i, masks[i] = sz[i] = 0;\n    if( y[i] == 0 ) masks[i] |= (1<<0);\n    if( x[i] == 0 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  map<int,int> bitmask;\n  set<int> S;\n  vector<int> group;\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n  if( S.size() == 1 ) {\n    cout << sz[find(0)] - 1 << endl;\n    return 0;\n  }\n\n  rep(i,N) bitmask[find(i)] |= masks[i];\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[find(group[j])];\n      if( (bitmask[find(j)]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  masks[uf[x]] |= masks[x];\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  masks[y] |= masks[x];\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  rep(i,N) { \n    cin >> x[i] >> y[i]; \n    uf[i] = i, masks[i] = sz[i] = 0;\n    if( y[i] == 0 ) masks[i] |= (1<<0);\n    if( x[i] == 0 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  set<int> S;\n  vector<int> group;\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n  if( S.size() == 1 ) {\n    cout << sz[find(0)] - 1 << endl;\n    return 0;\n  }\n\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[find(group[j])];\n      if( (masks[find(j)]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\ntypedef pair<pair<int,int>,int> P;\n\nconst int gmax_n = 40005;\n\nint par[gmax_n]; //???\nint depth[gmax_n];//??¨?????±???\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\tdepth[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(depth[x] < depth[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(depth[x] == depth[y]) depth[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint main(){\n\tint n, h, w;\n\tcin >> n >> w >> h;\n\n\tvector<pair<int, int>> in(n);\n\t//vector<P> x(n), y(n);\n\trep(i,n){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tin[i] = make_pair(a,b);\n\t\t//x[i] = make_pair(make_pair(a,b),i);\n\t\t//y[i] = make_pair(make_pair(b,a),i);\n\t}\n\t//sort(all(x));\n\t//sort(all(y));\n\n\tinit(n);\n\trep(i,n){\n\t\t//auto xs = lower_bound(all(x), make_pair(make_pair(in[i].first, - 1),-1));\n\t\t//for(; xs != x.end() && xs->first.first == in[i].first; xs++){\n\t\t//\tunite(i, xs->second);\n\t\t//}\n\t\t//auto ys = lower_bound(all(y), make_pair(make_pair(in[i].second, - 1),-1));\n\t\t//for(; ys != y.end() && ys->first.second == in[i].second; ys++){\n\t\t//\tunite(i, ys->second);\n\t\t//}\n\t\trep(j,n){\n\t\t\tif(in[i].first == in[j].first || in[i].second == in[j].second){\n\t\t\t\tunite(i,j);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tmap<int,int> m;\n\tvector<bool> isEdge(n,0);\n\trep(i,n){\n\t\tif(in[i].first == 1 || in[i].first == w || in[i].second == 1 || in[i].second == h){\n\t\t\tisEdge[i] = true;\n\t\t}\n\t\tm[find(i)]++;\n\t}\n\tauto f = [&](){\n\t\tif(m.size() == 1) return 0;\n\t\trep(i,n){\n\t\t\tif(isEdge[find(i)]) return 0;\n\t\t}\n\t\treturn 1;\n\t};\n\n\tfor(auto i : m){\n\t\tans += i.second - 1;\n\t}\n\tans += (m.size() - 1) * 2;\n\tcout << ans + f() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint UF[50000];\nint p[50000];\nint q[50000];\nvector<int>h[110000];\nvector<int>v[110000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;\n\tUF[a]+=UF[b];UF[b]=a;\n}\nint t[50000];\nint d[4];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",p+i,q+i);\n\t\tp[i]--;q[i]--;\n\t\th[p[i]].push_back(i);\n\t\tv[q[i]].push_back(i);\n\t}\n\tfor(int i=0;i<a;i++)UF[i]=-1;\n\tfor(int i=0;i<110000;i++){\n\t\tfor(int j=1;j<h[i].size();j++)UNION(h[i][j-1],h[i][j]);\n\t\tfor(int j=1;j<v[i].size();j++)UNION(v[i][j-1],v[i][j]);\n\t}\n\tint ret=0;\n\tfor(int i=0;i<a;i++)if(UF[i]>=0)ret++;\n\tif(ret==a-1){\n\t\tprintf(\"%d\\n\",ret);return 0;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tif(p[i]==0)t[FIND(i)]|=1;\n\t\tif(q[i]==0)t[FIND(i)]|=2;\n\t\tif(p[i]==b-1)t[FIND(i)]|=4;\n\t\tif(q[i]==c-1)t[FIND(i)]|=8;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<4;j++)if(t[i]&(1<<j))d[j]++;\n\t}\n\tint tmp=0;\n\tfor(int i=0;i<4;i++)tmp=max(tmp,d[i]);\n\tint rem=a-ret;\n\tprintf(\"%d\\n\",a-1+rem-tmp);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n  vector<int> data;\n  int siz;\n  UnionFind(int size){\n    siz=size;\n    data=vi(size,-1);\n  }\n  bool Union(int x,int y){\n    x=root(x);y=root(y);\n    if(x==y)return 0;\n    siz--;\n    if(data[y]<data[x])swap(x,y);\n    data[x]+=data[y],data[y]=x;\n    return 1;\n  }\n  bool Find(int x,int y){\n    return root(x)==root(y);\n  }\n  int root(int x){\n    return data[x]<0 ? x : data[x]=root(data[x]);\n  }\n  int size(int x){\n    return -data[root(x)];\n  }\n};\nint main(){\n  int n,x,y;\n  cin>>n>>x>>y;\n  vp A(n),B(n);\n  int h=0;\n  rep(i,n){\n    int a,b;\n    cin>>a>>b;\n    if(a==1||b==1||a==x||b==y)h=1;\n    A[i]={a,i};\n    B[i]={b,i};\n  }\n  UnionFind uf(n);\n  sort(all(A));sort(all(B));\n  rep(i,n-1)if(A[i].first==A[i+1].first)uf.Union(A[i].second,A[i+1].second);\n  rep(i,n-1)if(B[i].first==B[i+1].first)uf.Union(B[i].second,B[i+1].second);\n  if(uf.siz==1)h=1;\n  int out=n+uf.siz-1-h;\n  cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\n\n\ntemplate<typename T>\nclass UF {\npublic:\n\tUF() {\n\t\tsize = 0;\n\t}\n\n\t//???????????\\??????\n\tvoid push( T a ) {\n\t\tM[a] = size;\n\t\tV.push_back( size );\n\t\trank.push_back( 0 );\n\t\tC.push_back( 1 );\n\t\tsize++;\n\t}\n\n\t//????????°??????????????????\n\tvoid unite( T a, T b ) {\n\t\tlong long int x = find( M[a] );\n\t\tlong long int y = find( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] ) {\n\t\t\tV[x] = y;\n\t\t\tC[y] += C[x];\n\t\t} else {\n\t\t\tV[y] = x;\n\t\t\tC[x] += C[y];\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\n\tvoid merge( T a, T b ) {\n\t\tunite( a, b );\n\t}\n\n\t//????????°??????????????????????????????????????????\n\tbool same( T a, T b ) {\n\t\treturn find( M[a] ) == find( M[b] );\n\t}\n\n\t//????????°????????????????????°?????????\n\tlong long int group() {\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size(); i++ ) {\n\t\t\tS.insert( find( V[i] ) );\n\t\t}\n\t\treturn S.size();\n\t}\n\n\t//??°?????????????±???????????????°?????????\n\tlong long int count( T a ) {\n\t\treturn C[find( M[a] )];\n\t}\n\n\t//????±???????????????°????????????ID?????????\n\tlong long int groupID( T a ) {\n\t\treturn find( M[a] );\n\t}\n\n\t//????????°?????????????????????????????????\n\tvector<T>friendList( T a ) {\n\t\tlong long int inputID = find( M[a] );\n\t\tvector<T>ret;\n\t\tfor( auto now : M ) {\n\t\t\tif( find( now.second ) == inputID ) {\n\t\t\t\tret.emplace_back( now.first );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\nprivate:\n\tvector<long long int>C, V, rank;\n\tmap < T, long long int>M;\n\tlong long int size;\n\n\t//?\\?????????§?????????\n\tlong long int find( long long int x ) {\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find( V[x] );\n\t}\n};\n\n\nint main() {\n\tlong long int N, W, H;\n\tcin >> N >> W >> H;\n\tUF<long long int>uf;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tuf.push( i );\n\t}\n\n\tvector<pair<long long int, long long int>>D( N );\n\tlong long int Wsum = 0, Hsum = 0;\n\tmap<long long int, long long int>xmemo, ymemo;\n\tbool kabef = false;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i].first >> D[i].second;\n\t\tif( !xmemo.count( D[i].first ) ) {\n\t\t\txmemo[D[i].first] = i;\n\t\t} else {\n\t\t\tuf.merge( xmemo[D[i].first], i );\n\t\t}\n\t\tif( !ymemo.count( D[i].second ) ) {\n\t\t\tymemo[D[i].second] = i;\n\t\t} else {\n\t\t\tuf.merge( ymemo[D[i].second], i );\n\t\t}\n\t\tif( D[i].first == 1 ) {\n\t\t\tkabef = true;\n\t\t}\n\t\tif( D[i].first == W ) {\n\t\t\tkabef = true;\n\t\t}\n\t\tif( D[i].second == 1 ) {\n\t\t\tkabef = true;\n\t\t}\n\t\tif( D[i].second == H ) {\n\t\t\tkabef = true;\n\t\t}\n\t}\n\tlong long int ans = N - 1;\n\tif( uf.group() != 1 ) {\n\t\tif( kabef ) {\n\t\t\tans += uf.group() - 1;\n\t\t} else {\n\t\t\tans += (uf.group()-1) * 2;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(int sz):data(sz, -1){}\n  int find(int x)\n  {\n    return (data[x] < 0 ? x : data[x] = find(data[x]));\n  }\n  bool same(int x, int y)\n  {\n    return (find(x) == find(y));\n  }\n  int unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] < data[y]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return -data[x];\n  }\n  int size(int x)\n  {\n    return -data[find(x)];\n  }\n};\n\nint main()\n{\n  int N, W, H;\n  cin >> N >> W >> H;\n  UnionFind uf(N);\n  vector<int> xx(W, -1), yy(H, -1);\n  int hashi = 0;\n  rep(i, N) {\n    int x, y; cin >> x >> y;\n    x--, y--;\n    if(x == 0 || x == W-1 || y == 0 || y == H-1) hashi = 1;\n    if(~xx[x]) uf.unite(i, xx[x]);\n    else xx[x] = i;\n    if(~yy[y]) uf.unite(i, yy[y]);\n    else yy[y] = i;\n  }\n  set<int> st;\n  rep(i, N) st.insert(uf.find(i));\n  if((int)st.size() == 1) cout << N-1 << endl;\n  else cout << N+(int)st.size()-1-hashi << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(ll size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nll solve(){\n    ll res = LINF;\n    ll N,W,H; cin >> N >> W >> H;\n    vector<ll> x(N),y(N);\n    bool f = false;\n    for(int i = 0; i < N;i++){\n        cin >> x[i] >> y[i];\n        f |= (x[i]==1|x[i]==W|y[i]==1|y[i]==H);\n    }\n    \n    vector<vector<pll>> wG(W+2),hG(H+2);\n    for(int i = 0; i < N;i++){\n        wG[x[i]].push_back({y[i],i});\n        hG[y[i]].push_back({x[i],i});\n    }\n    \n    UnionFind uf(N);\n    for(int i = 0; i < W+2;i++){\n        if(wG[i].size() < 2) continue;\n        for(int j = 0; j < wG[i].size()-1;j++){\n            int idx1 = wG[i][j].second, idx2 = wG[i][j+1].second;\n            uf.unionSet(idx1, idx2);\n        }\n    }\n    for(int i = 0; i < H+2;i++){\n        if(hG[i].size() < 2) continue;\n        for(int j = 0; j < hG[i].size()-1;j++){\n            int idx1 = hG[i][j].second, idx2 = hG[i][j+1].second;\n            uf.unionSet(idx1, idx2);\n        }\n    }\n    set<int> s;\n    for(int i = 0; i < N;i++) s.insert(uf.root(i));\n    if(s.size() == 1){\n        res = N-1;\n    }else{\n        res = N-1+s.size()-f;\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 40010\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint p[MAX];\nint n,h,w,ans=0;\nint x[MAX],y[MAX];\nvector<pii> a,b;\nbool l[MAX]={},r[MAX]={},u[MAX]={},d[MAX]={};\n\nint find(int a){\n  if(p[a]==a)return a;\n  int pa=find(p[a]);\n  p[a]=pa;\n  return pa;\n}\n\nvoid unite(int a,int b){\n  int pa=find(a),pb=find(b);\n  p[pa]=pb;\n}\n\nbool same(int a,int b){\n  return find(a)==find(b);\n}\n\nvoid check(int a,int b){\n  u[a]|=u[b];\n  u[b]|=u[a];\n  l[a]|=l[b];\n  l[b]|=l[a];\n  d[a]|=d[b];\n  d[b]|=d[a];\n  r[a]|=r[b];\n  r[b]|=r[a];\n}\n\nint main()\n{\n  cin>>n>>w>>h;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    a.push_back(mp(x[i],i));\n    b.push_back(mp(y[i],i));\n    if(y[i]==1)d[i]=true;\n    if(x[i]==1)l[i]=true;\n    if(y[i]==h)u[i]=true;\n    if(x[i]==w)r[i]=true;\n  }\n\n  for(int i=0;i<MAX;i++)p[i]=i;\n\n  sort(a.begin(),a.end());\n  sort(b.begin(),b.end());\n\n  for(int i=1;i<n;i++){\n    if(a[i-1].f==a[i].f && !same(a[i-1].s,a[i].s)){\n      unite(a[i-1].s,a[i].s);\n      ans++;\n      check(i-1,i);\n    }\n    if(b[i-1].f==b[i].f && !same(b[i-1].s,b[i].s)){\n      unite(b[i-1].s,b[i].s);\n      ans++;\n      check(i-1,i);\n    }\n  }\n\n  if(ans!=n-1){\n    int sum1=0,sum2=0,sum3=0,sum4=0;\n    for(int i=0;i<n;i++)if(p[i]==i)sum1++;\n    sum1=(sum1*2-1);\n    sum2=sum3=sum4=sum1;\n    for(int i=0;i<n;i++)if(p[i]==i && l[i])sum1--;\n    for(int i=0;i<n;i++)if(p[i]==i && u[i])sum2--;\n    for(int i=0;i<n;i++)if(p[i]==i && r[i])sum3--;\n    for(int i=0;i<n;i++)if(p[i]==i && d[i])sum4--;\n    ans=min(min(ans+sum1,ans+sum2),min(ans+sum3,ans+sum4));\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=123456789;\nconst int N=100000;\nset<int> X[N+1],Y[N+1];\n\nvector<int> G[N];\nvector<vector<int>> connected;\n\nint main()\n{\n    int n,w,h;\n    scanf(\" %d %d %d\", &n, &w, &h);\n\n    // point\n    vector<pi> p(n);\n    // point -> id\n    map<pi,int> f;\n    rep(i,n)\n    {\n        int x,y;\n        scanf(\" %d %d\", &x, &y);\n        X[x].insert(y);\n        Y[y].insert(x);\n\n        p[i] = pi(x,y);\n        f[p[i]] = i;\n    }\n\n    // ??£??\\?????????????????????????????????\n    rep(i,n)\n    {\n        int x=p[i].fi, y=p[i].se;\n\n        // ???\n        auto itrx = X[x].lower_bound(y);\n        if(itrx != X[x].begin())\n        {\n            auto up = itrx;\n            --up;\n            int idx = f[pi(x,*up)];\n            G[i].pb(idx);\n        }\n\n        // ???\n        ++itrx;\n        if(itrx != X[x].end())\n        {\n            int idx = f[pi(x,*itrx)];\n            G[i].pb(idx);\n        }\n\n        // ???\n        auto itry = Y[y].lower_bound(x);\n        if(itry != Y[y].begin())\n        {\n            auto lf = itry;\n            --lf;\n            int idx = f[pi(*lf,y)];\n            G[i].pb(idx);\n        }\n\n        // ???\n        ++itry;\n        if(itry != Y[y].end())\n        {\n            int idx = f[pi(*itry,y)];\n            G[i].pb(idx);\n        }\n\n    }\n\n    // ??£???????´??????¢???\n    vector<bool> vis(n,false);\n    rep(i,n)\n    {\n        if(vis[i]) continue;\n\n        vector<int> con;\n        queue<int> que;\n\n        que.push(i);\n        con.pb(i);\n        vis[i]=true;\n        while(!que.empty())\n        {\n            int v=que.front();\n            que.pop();\n            rep(j,G[v].size())\n            {\n                int nx=G[v][j];\n                if(!vis[nx])\n                {\n                    vis[nx]=true;\n                    con.pb(nx);\n                    que.push(nx);\n                }\n            }\n        }\n\n        connected.pb(con);\n    }\n\n    int ans=INF;\n\n    if(connected.size()==1) ans=n-1;\n    else\n    {\n        // ??????????????????????????´????????????\n        vector<int> W({1,w}), H({1,h});\n        for(auto &x:W)\n        {\n            int tmp=0;\n            rep(i,connected.size())\n            {\n                int add=connected[i].size()+2;\n                rep(j,connected[i].size())\n                {\n                    int idx = connected[i][j];\n                    if(p[idx].fi==x)\n                    {\n                        --add;\n                        break;\n                    }\n                }\n                tmp+=add-1;\n            }\n            ans=min(ans,tmp-1);\n        }\n        for(auto &y:H)\n        {\n            int tmp=0;\n            rep(i,connected.size())\n            {\n                int add=connected[i].size()+2;\n                rep(j,connected[i].size())\n                {\n                    int idx = connected[i][j];\n                    if(p[idx].se==y)\n                    {\n                        --add;\n                        break;\n                    }\n                }\n                tmp+=add-1;\n            }\n            ans=min(ans,tmp-1);\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint ans;\nmap<int, vector<int> > x,y;\nset<PII> visit;\nint n,w,h;\n\nvoid DFS(int fx, int fy){\n\tif(EXIST(visit, MP(fx,fy)))return;\n\tvisit.insert(MP(fx,fy));\n\tREP(i,x[fx].size()){\n\t\tif(x[fx][i]!=fy)DFS(fx, x[fx][i]);\n\t}\n\tREP(i,y[fy].size()){\n\t\tif(y[fy][i]!=fx)DFS(y[fy][i], fy);\n\t}\n}\n\nint main(){\n\tcin>>n>>w>>h;\n\tans = n-1;\n\tint flag = 0,cnt=0;\n\tREP(i,n){\n\t\tint tx, ty;\n\t\tscanf(\"%d%d\", &tx,&ty);\n\t\tx[tx].PB(ty);\n\t\ty[ty].PB(tx);\n\t\tif(tx==1||ty==1||tx==w||ty==h)flag=1;\n\t}\n\tfor(map<int, vector<int> >::iterator it=x.begin(); it!=x.end(); it++){\n\t\tif(!EXIST(visit, MP(it->first, it->second[0]))){\n\t\t\tDFS(it->first, it->second[0]);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt!=1){\n\t\tif(flag==0){\n\t\t\tans+=cnt;\n\t\t}else{\n\t\t\tans+=cnt-1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <numeric>\n#include <math.h>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <vector>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <complex>\n#define full(c) c.begin(), c.end()\n#define vector2d(name,type,h,w,init) vector<vector<type>> name(h,vector<type>(w,init)) \nconst int PRIME = 1000000007;\nconst int INT_INF = 2147483647;\nconst long long int LL_INF = 9223372036854775807;\nconst double PI = acos(-1);\nconst double EPS = 0.000000001;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\nusing namespace std;\n\nint main() {\n\tint k, i, w, h, n, gr = 0, cnt = 0;\n\tcin >> n >> w >> h;\n\tvector<pair<int, int>> s(n);\n\tvector<int> g(n, -1);\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> s[i].first >> s[i].second;\n\t}\n\tfor (k = 0; k < n; k++) {\n\t\tif (g[k] == -1) {\n\t\t\tqueue<pair<int, int>> bfs;\n\t\t\tg[k] = gr;\n\t\t\tbfs.push(s[k]);\n\t\t\twhile (!bfs.empty()) {\n\t\t\t\tpair<int, int> p = bfs.front(); bfs.pop();\n\t\t\t\tfor (i = k; i < n; i++) {\n\t\t\t\t\tif ((p.first == s[i].first || p.second == s[i].second) && g[i] == -1) {\n\t\t\t\t\t\tbfs.push(s[i]);\n\t\t\t\t\t\tg[i] = gr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgr++;\n\t\t}\n\t}\n\tcnt += n - gr;\n\tcnt += (gr - 1) * 2;\n\tif (gr > 1) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (s[i].first == 1 || s[i].first == w\n\t\t\t\t|| s[i].second == 1 || s[i].second == h) break;\n\t\t}\n\t\tif (i == n) cnt++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tif(n == 2 && w != 3&& res == 2)exit(100);\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint* parent, *height;\nint unite_count;\n\nstruct Info{\n\tint x,y;\n};\n\n\nint find_parent(int id){\n\tif(parent[id] == id){\n\t\treturn id;\n\t}else{\n\t\treturn parent[id] == find_parent(parent[id]);\n\t}\n}\n\n\nvoid unite(int left,int right){\n\n\tint left_parent = find_parent(left);\n\tint right_parent = find_parent(right);\n\n\tif(left_parent == right_parent)return;\n\n\tif(height[left_parent] >= height[right_parent]){\n\t\tif(height[left_parent] == height[right_parent]){\n\t\t\theight[left_parent]++;\n\t\t}\n\t\tparent[right_parent] = left_parent;\n\n\t}else{\n\t\tparent[left_parent] = right_parent;\n\t}\n\n\tunite_count++;\n}\n\n\nint main(){\n\n\tint N,W,H;\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tunite_count = 0;\n\n\tparent = new int[N+1];\n\theight = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\tvector<int> X[W+1],Y[H+1];\n\n\tfor(int id = 1; id <= N; id++){\n\t\tscanf(\"%d %d\",&info[id].x,&info[id].y);\n\t\tX[info[id].x].push_back(id);\n\t\tY[info[id].y].push_back(id);\n\t}\n\n\tfor(int i = 1; i <= W;i++){\n\n\t\tif(X[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < X[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < X[i].size();p++){\n\t\t\t\tunite(X[i][k],X[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= H; i++){\n\n\t\tif(Y[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < Y[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < Y[i].size();p++){\n\t\t\t\tunite(Y[i][k],Y[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstack<int> GroupID;\n\n\tint group_num = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(parent[i] == i){\n\t\t\tgroup_num++;\n\t\t\tGroupID.push(i);\n\t\t}\n\t}\n\n\tint Loc_num[4],id;\n\tfor(int i = 0; i < 4; i++)Loc_num[i] = 0;\n \tbool check[4];\n\n\twhile(!GroupID.empty()){\n\t\tid = GroupID.top();\n\t\tGroupID.pop();\n\n\t\tfor(int i = 0; i < 4; i++)check[i] = false;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(parent[i] == id){\n\t\t\t\tif(info[i].x == 1){\n\t\t\t\t\tcheck[0] = true;\n\t\t\t\t}else if(info[i].x == W){\n\t\t\t\t\tcheck[1] = true;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].y == 1){\n\t\t\t\t\tcheck[2] = true;\n\t\t\t\t}else if(info[i].y == H){\n\t\t\t\t\tcheck[3] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(check[i] == true){\n\t\t\t\tLoc_num[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_kabe = 0,tmp;\n\n\tfor(int i = 0; i < 4; i++)max_kabe = max(max_kabe,Loc_num[i]);\n\n\tint ans = unite_count;\n\n\tif(group_num != 1){\n\t\ttmp = group_num-max_kabe;\n\n\t\tans += tmp + group_num-1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint* parent, *height;\nint unite_count;\n\nstruct Info{\n\tint x,y;\n};\n\n\nint find_parent(int id){\n\tif(parent[id] == id){\n\t\treturn id;\n\t}else{\n\t\treturn parent[id] == find_parent(parent[id]);\n\t}\n}\n\n\nvoid unite(int left,int right){\n\n\tint left_parent = find_parent(left);\n\tint right_parent = find_parent(right);\n\n\tif(left_parent == right_parent)return;\n\n\tif(height[left_parent] >= height[right_parent]){\n\t\tif(height[left_parent] == height[right_parent]){\n\t\t\theight[left_parent]++;\n\t\t}\n\t\tparent[right_parent] = left_parent;\n\n\t}else{\n\t\tparent[left_parent] = right_parent;\n\t}\n\n\tunite_count++;\n}\n\n\nint main(){\n\n\tint N,W,H;\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tunite_count = 0;\n\n\tparent = new int[N+1];\n\theight = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\tvector<int> X[W+1],Y[H+1];\n\n\tfor(int id = 1; id <= N; id++){\n\t\tscanf(\"%d %d\",&info[id].x,&info[id].y);\n\t\tX[info[id].x].push_back(id);\n\t\tY[info[id].y].push_back(id);\n\t}\n\n\tfor(int i = 1; i <= W;i++){\n\n\t\tif(X[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < X[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < X[i].size();p++){\n\t\t\t\tunite(X[i][k],X[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= H; i++){\n\n\t\tif(Y[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < Y[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < Y[i].size();p++){\n\t\t\t\tunite(Y[i][k],Y[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstack<int> GroupID;\n\n\tint group_num = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(parent[i] == i){\n\t\t\tgroup_num++;\n\t\t\tGroupID.push(i);\n\t\t}\n\t}\n\n\tint Loc_num[4],id;\n\tfor(int i = 0; i < 4; i++)Loc_num[i] = 0;\n \tbool check[4];\n\n\twhile(!GroupID.empty()){\n\t\tid = GroupID.top();\n\t\tGroupID.pop();\n\n\t\tfor(int i = 0; i < 4; i++)check[i] = false;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(parent[i] == id){\n\t\t\t\tif(info[i].x == 1){\n\t\t\t\t\tcheck[0] = true;\n\t\t\t\t}else if(info[i].x == W){\n\t\t\t\t\tcheck[1] = true;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].y == 1){\n\t\t\t\t\tcheck[2] = true;\n\t\t\t\t}else if(info[i].y == H){\n\t\t\t\t\tcheck[3] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(check[i] == true){\n\t\t\t\tLoc_num[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_kabe = 0,tmp;\n\n\tfor(int i = 0; i < 4; i++)max_kabe = max(max_kabe,Loc_num[i]);\n\n\tint ans = unite_count;\n\n\tif(group_num != 1){\n\t\ttmp = group_num-max_kabe;\n\n\t\tans += tmp + group_num-1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<pair<int, int> > place;\nvector<vector<int> > x(100010), y(100010);\nvector<int> groupnum(40010, -1);\nvector<int> groupsize;\nvector<vector<bool> > isclosetowall;\nvector<bool> ischecked_x(100010, false), ischecked_y(100010, false);\n\nint main()\n{\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\t// cout << __LINE__ <<endl;\n\tfor(int i = 0; i < n; i++){\n\t\tint tmpx, tmpy;\n\t\tcin >> tmpx >> tmpy;\n\t\tplace.push_back(make_pair(tmpx, tmpy));\n\t\tx[tmpx].push_back(i);\n\t\t// cout << y.size() << \" \" << tmpy << endl;\n\t\ty[tmpy].push_back(i);\n\t\t// cout << __LINE__ << endl;\n\t\t// cout << i << endl;\n\t}\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(groupnum[i] < 0){\n\t\t\t// cout << i << endl;\n\t\t\tqueue<int> qu;\n\t\t\tqu.push(i);\n\t\t\tgroupnum[i] = cnt;\n\t\t\tisclosetowall.push_back(vector<bool>(4, false));\n\t\t\tgroupsize.push_back(1);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint now = qu.front();\n\t\t\t\tint nowx = place[now].first;\n\t\t\t\tint nowy = place[now].second;\n\t\t\t\tqu.pop();\n\t\t\t\t// cout << now << \" \" << \" \" << nowx << \" \" << nowy << \" \" << ischecked_x[nowx] << \" \" << ischecked_y[nowy] << endl;\n\t\t\t\tif(nowx == 1) isclosetowall[cnt][0] = true;\n\t\t\t\tif(nowx == w) isclosetowall[cnt][1] = true;\n\t\t\t\tif(nowy == 1) isclosetowall[cnt][2] = true;\n\t\t\t\tif(nowy == h) isclosetowall[cnt][3] = true;\n\t\t\t\tif(!ischecked_x[nowx]){\n\t\t\t\t\tischecked_x[nowx] = true;\n\t\t\t\t\tfor(int j = 0; j < x[nowx].size(); j++){\n\t\t\t\t\t\tint nowindex = x[nowx][j];\n\t\t\t\t\t\tint tmpy = place[nowindex].second;\n\t\t\t\t\t\tif(nowindex == now || ischecked_y[tmpy]) continue;\n\t\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// x.erase(x.begin() + nowx);\n\t\t\t\tif(!ischecked_y[nowy]){\n\t\t\t\t\tischecked_y[nowy] = true;\n\t\t\t\t\tfor(int j = 0; j < y[nowy].size(); j++){\n\t\t\t\t\t\tint nowindex = y[nowy][j];\n\t\t\t\t\t\tint tmpx = place[nowindex].first;\n\t\t\t\t\t\tif(nowindex == now || ischecked_x[tmpx]) continue;\n\t\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// y.erase(y.begin() + nowy);\n\t\t\t\t// cout << now << \" \" << groupsize[cnt] << endl;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t// cout << i << \" \" << groupnum[i] << \" \" << groupsize[groupnum[i]] << endl;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < cnt; i++){\n\t\tsum += groupsize[i] - 1;\n\t}\n\tif(cnt == 1){\n\t\tcout << sum << endl;\n\t\treturn 0;\n\t}\n\tint ans = mod;\n\tfor(int i = 0; i < 4; i++){\n\t\tint needtomove = 0;\n\t\tfor(int j = 0; j < cnt; j++){\n\t\t\tif(!isclosetowall[j][i]) needtomove++;\n\t\t}\n\t\t// cout << sum + needtomove + cnt - 1 << endl;\n\t\tans = min(ans, sum + needtomove + cnt - 1);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "aasvfsadgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdgasdg\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, h, w;\nconst int mn = 100000;\nvector<P> cx[mn], cy[mn];\nuf u;\nint x[40000], y[40000];\nbool used[40000];\nint main() {\n\tcin >> n >> h >> w; u.init(n);\n\tbool exi = false;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i]; x[i]--; y[i]--;\n\t\tif (x[i] == 0 || y[i] == 0 || x[i] == h - 1 || y[i] == w - 1)exi = true;\n\t\tcx[x[i]].push_back({ y[i],i });\n\t\tcy[y[i]].push_back({ x[i],i });\n\t}\n\trep(i, h)sort(cx[i].begin(), cx[i].end());\n\trep(i, w)sort(cy[i].begin(), cy[i].end());\n\trep(i, n) {\n\t\tint id = upper_bound(cx[x[i]].begin(), cx[x[i]].end(), P{ y[i],i }) - cx[x[i]].begin();\n\t\tif (id < cx[x[i]].size()) {\n\t\t\tint to = cx[x[i]][id].second;\n\t\t\tu.unite(i, to);\n\t\t}\n\t\tid -= 2;\n\t\tif (id >=0) {\n\t\t\tint to = cx[x[i]][id].second;\n\t\t\tu.unite(i, to);\n\t\t}\n\t\tid = upper_bound(cy[y[i]].begin(), cy[y[i]].end(), P{ x[i],i }) - cy[y[i]].begin();\n\t\tif (id < cy[y[i]].size()) {\n\t\t\tint to = cy[y[i]][id].second;\n\t\t\tu.unite(i, to);\n\t\t}\n\t\tid -= 2;\n\t\tif (id >= 0) {\n\t\t\tint to = cy[y[i]][id].second;\n\t\t\tu.unite(i, to);\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i, n) {\n\t\tint p = u.find(i);\n\t\tif (used[p])continue;\n\t\tused[p] = true; cnt++;\n\t}\n\tint ans = n - cnt;\n\tif (cnt > 1) {\n\t\tans += 2 * cnt - 1;\n\t\tif (exi)ans--;\n\t}\n\tcout << ans << endl;\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\n\nint main(){\n  int n, h, w;\n  cin >> n >> h >> w;\n  int x, y;\n  vector<int> X(n), Y(n);\n  map<int,int> M_x, M_y;\n  UnionFind uf(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n    if(M_x[x] > 0){\n      uf.unite(i,M_x[x]-1);\n    }else{\n      M_x[x] = i + 1;\n    }\n    if(M_y[y] > 0){\n      uf.unite(i,M_y[y]-1);\n    }else{\n      M_y[y] = i + 1;\n    }\n  }\n  set<int> p;\n  int l = 0, r = 0, t = 0, b = 0;\n  for(int i = 0; i < n; ++i){\n    p.insert(uf.find(i));\n    if(X[i] == 1 && l == 0) ++l;\n    if(X[i] == w && r == 0) ++r;\n    if(Y[i] == 1 && b == 0) ++b;\n    if(Y[i] == h && t == 0) ++t;\n  }\n  int k = p.size(), s = l|r|b|t;\n  if(k == 1) cout << n - 1 << endl;\n  else cout << n + k - 1 - s << endl; \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50010\n\nclass Union_Find{\npublic:\n  int par[MAX],rank[MAX],size[MAX],gnum;\n  Union_Find(int N){\n    gnum = N;\n    for(int i = 0 ; i < MAX ; i++){\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 0;\n    }\n  }\n  int find(int x){\n    if(par[x] == x){\n      return x;\n    }\n    return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y){ return; }\n    if(rank[x] < rank[y]){\n      par[x] = y;\n      size[y] += size[x];\n    }else{\n      par[y] = x;\n      size[x] += size[y];\n      if(rank[x] == rank[y]){\n        rank[x]++;\n      }\n    }\n    gnum--;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n  int getSize(int x){\n    return size[find(x)];\n  }\n  int groups(){\n    return gnum;\n  }\n};\n\nint N,W,H;\nint X[2*MAX],Y[2*MAX],x[MAX],y[MAX];\n\nbool isWall(int x,int y){\n  if(x == 1 || y == 1 || x == W || y == H){\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  Union_Find uf(N);\n  for(int i = 0 ; i < MAX ; i++){\n    X[i] = Y[i] = -1;\n  }\n  bool wall = false;\n  for(int i = 0 ; i < N ; i++){\n    cin >> x[i] >> y[i];\n    uf.size[i] = 1;\n    if(X[x[i]] == -1){\n      X[x[i]] = i;\n    }else{\n      uf.unite(X[x[i]],i);\n    }\n    if(Y[y[i]] == -1){\n      Y[y[i]] = i;\n    }else{\n      uf.unite(Y[y[i]],i);\n    }\n    wall |= isWall(x[i],y[i]);\n  }\n  if(uf.groups() == 1){\n    cout << uf.getSize(0)-1 << endl;\n  }else{\n    cout << (uf.groups()-1)*2+1-wall << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n//\nint par_uf[100010],rank_uf[100010];\n\nvoid init(int n){for(int i=0;i<n;i++){par_uf[i]=i;rank_uf[i]=0;}}\nint find(int x){if(par_uf[x]==x)return x;else return par_uf[x]=find(par_uf[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank_uf[x]<rank_uf[y])par_uf[x]=y;else{par_uf[y]=x;if(rank_uf[x]==rank_uf[y])rank_uf[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n//\n\nint N,H,W;\nvi row[100010],col[100010];\nint p[40010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>W>>H;\n\tint border = 0;\n\trep(i,N){\n\t\tint y,x;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\trow[y].pb(i);\n\t\tcol[x].pb(i);\n\t\tif(y==0 || y==H-1 || x==0 || x==W-1)border = 1;\n\t}\n\n\tinit(N);\n\trep(i,H){\n\t\trep(j,sz(row[i])-1){\n\t\t\tunite(row[i][j],row[i][sz(row[i])-1]);\n\t\t}\n\t}\n\trep(j,W){\n\t\trep(i,sz(col[j])-1){\n\t\t\tunite(col[j][i],col[j][sz(col[j])-1]);\n\t\t}\n\t}\n\trep(i,N){\n\t\tp[find(i)]=1;\n\t}\n\tint C = 0;\n\trep(i,N){\n\t\tC += p[i];\n\t}\n\tif(C == 1) cout << N-1 << endl;\n\telse if(border) cout << N-1 + C-1 << endl;\n\telse cout << N-1 + C << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nclass DisjointSet{\n    public:\n        vector<int> rank, p;//rank:??¨????????? p:??????????????????\n        DisjointSet(){}\n        DisjointSet(int size){//???????????°\n            rank.resize(size, 0);\n            p.resize(size, 0);\n            rep(i, size) makeSet(i);\n        }\n        void makeSet(int x){\n            p[x] = x;\n            rank[x] = 0;\n        }\n        //????????¨??????????????????????????????????????????\n        bool same(int x, int y){\n            return findSet(x) == findSet(y);\n        }\n        // ??¨?????????????????£?????????\n        void unite(int x, int y){\n            link(findSet(x), findSet(y));\n        }\n        //??¨??????????????????????????¨?????????????????£?????????\n        void link(int x, int y){\n            if(rank[x] > rank[y]){\n                p[y] = x;\n            }else{\n                p[x] = y;\n                if(rank[x] == rank[y]) rank[y]++;\n            }\n        }\n        //????????¢????????????????????§???\n        int findSet(int x){\n            if(x != p[x]){\n                p[x] = findSet(p[x]);\n            }\n            return p[x];\n        }\n};\n\nint main(void){\n    int n, w, h;\n    bool cornerw = false, cornerh = false;//?£??????????????????????????????????????¨???¶????????????????????°\n    cin >> n >> w >> h;\n    //?????????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n    vector<int> memoX(w, -1);//???\n    vector<int> memoY(h, -1);//???\n    DisjointSet ds = DisjointSet(n);\n\n    rep(i, n){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--;//0origin\n        if(x == 0 || x == w - 1) cornerw = true;\n        if(y == 0 || y == h - 1) cornerh = true;\n        //?????¨?¨??????§?????????????????????\n        //????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n        if(memoX[x] < 0) memoX[x] = i;//???????????????????????????????????\\??£????????¨???????????°X[???]=????????????????????\\??????\n        else ds.unite(i, memoX[x]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n        if(memoY[y] < 0) memoY[y] = i;\n        else ds.unite(i, memoY[y]);\n    }\n\n    set<int> sum;\n    rep(i, w){\n        if(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));//??????????¨±??????????????????set????????¨\n    }\n\n    int m = sum.size();//??£??????????????????????????°???????????????????????°\n\n    if(m > 1){\n        if(cornerw == true || cornerh == true){\n            printf(\"%d\\n\", n + m - 2);//?£?????????£?????????????????£????????????1?????\\?????????????????§????????????-1\n        }else{\n            printf(\"%d\\n\", n + m - 1);\n        }\n    }else{//??????????????°?????????????????????????????????\n        printf(\"%d\\n\", n - 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\nint N,H,W;\nint y,x;\nvector<int> G[2][MAX];\nbool visited[2][MAX];\nint flg[4],cnt[4];\n\nvoid dfs(int f,int p){\n  visited[f][p]=true;\n  if(p==0)flg[f]=true;\n  if(p==(f?H:W))flg[2+f]=true;\n  \n  int r=1-f;\n  for(int i=0;i<(int)G[f][p].size();i++){\n    int w=G[f][p][i];\n    if(visited[r][w])continue;\n    dfs(r,w);\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&H,&W);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d\",&y,&x);\n    G[0][y].push_back(x);\n    G[1][x].push_back(y);\n  }\n  \n  int ans=0;\n  for(int i=0;i<MAX;i++){\n    if(G[0][i].size()==0)continue;\n    if(visited[0][i])continue;\n    for(int j=0;j<4;j++)flg[j]=0;\n    dfs(0,i);\n    ans++;\n    for(int j=0;j<4;j++)cnt[j]+=flg[j];\n  }\n  for(int i=1;i<4;i++)cnt[i]=max(cnt[i],cnt[i-1]);\n  if(ans==1){\n    cout<<N-1<<endl;\n  }else{\n    cout<<N+ans-1-cnt[3]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> Ws[100001], Hs[100001];\nint par[40000];\n\nint find(int x)\n{\n    return (par[x] >= 0 ? par[x] = find(par[x]) : x);\n}\n\nvoid merge(int x, int y)\n{\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (-par[x] < -par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n\nint main()\n{\n    int n, w, h;\n    int cw = 0, ch = 0;\n    \n    scanf(\"%d %d %d\", &n, &w, &h);\n    \n    for (int i = 0; i < n; i++){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        \n        if (a == 1 || a == w) cw = 1;\n        if (b == 1 || b == h) ch = 1;\n        \n        Ws[a].push_back(i);\n        Hs[b].push_back(i);\n    }\n    \n    memset(par, -1, sizeof(par));\n    for (int i = 1; i <= w; i++){\n        for (int j = 1; j < Ws[i].size(); j++){\n            merge(Ws[i][j - 1], Ws[i][j]);\n        }\n    }\n    for (int i = 1; i <= h; i++){\n        for (int j = 1; j < Hs[i].size(); j++){\n            merge(Hs[i][j - 1], Hs[i][j]);\n        }\n    }\n    \n    set<int> s;\n    for (int i = 0; i < n; i++) s.insert(find(i));\n    \n    printf(\"%d\\n\", s.size() == 1 ? 1 : (n - 1 + s.size() - (cw | ch)));\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100001\n#define rank dfasodfhdasoif\nusing namespace std;\nvector<int> G[2][100001];\n\n/*Union_Find_Tree\n  O(a(n))<O(log(n))\n*/\n\nint par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\n\nint main(){\n  int n,w,h,flg=0;\n  cin>>n>>w>>h;\n  init(n);\n  \n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    if(x==1||y==1||x==w||y==h)flg=1;\n    G[0][x].push_back(i);\n    G[1][y].push_back(i);\n  }\n  \n  for(int i=1;i<=h;i++)\n    for(int j=1;j<G[1][i].size();j++)unite(G[1][i][j],G[1][i][j-1]);\n  \n  for(int i=1;i<=w;i++)\n    for(int j=1;j<G[0][i].size();j++)unite(G[0][i][j],G[0][i][j-1]);\n\n  int cnt=0,used[100001]={};\n  for(int i=0;i<n;i++){\n    par[i]=find(i);\n    cnt+=!used[find(i)];\n    used[find(i)]=1;\n  }\n  if(cnt==1)cout <<n-cnt<<endl;\n  else cout <<n+(cnt-1)-flg<<endl;  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[i] < 0) memoX[i] = x;//???????????????????????????????????\\??£????????¨???????????°???????????¢??£?????????\n\t\telse ds.unite(x, memoX[i]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[i] < 0) memoY[i] = y;\n\t\telse ds.unite(y, memoY[i]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\tprintf(\"%d %d\\n\", n, m);\n\tif(cornerw == true || cornerh == true){\n\t\tprintf(\"%d\\n\", n + m - 2);\n\t}else{\n\t\tprintf(\"%d\\n\", n + m - 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct UnionFind{\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\ntypedef pair<int,int> P;\n#define MAX 114514\nvector<int> vx[MAX],vy[MAX];\nsigned main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  int x[n],y[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n  bool f=0;\n  map<P,int> m;\n  for(int i=0;i<n;i++){\n    m[P(x[i],y[i])]=i;\n    vx[x[i]].push_back(y[i]);\n    vy[y[i]].push_back(x[i]);\n    f|=x[i]==1||x[i]==w;\n    f|=y[i]==1||y[i]==h;\n  }\n  int ans=0;\n  UnionFind uf(n);\n  for(int i=0;i<MAX;i++){\n    for(int j=0;j<(int)vx[i].size();j++)\n      uf.unite(m[P(i,vx[i][0])],m[P(i,vx[i][j])]);\n    for(int j=0;j<(int)vy[i].size();j++)\n      uf.unite(m[P(vy[i][0],i)],m[P(vy[i][j],i)]);\n  }\n  if(uf.r[uf.find(0)]==n){\n    cout<<n-1<<endl;\n    return 0;\n  }\n  for(int i=0;i<n;i++){\n    if(uf.find(i)!=i) continue;\n    ans+=uf.r[i]+1;\n  }\n  cout<<ans-1-f<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,h,w,d[4];\nvi x,y,c;\nvvp a,b;\nvvi g;\n\nvoid add(int u,int v){\n\tg[u].push_back(v);\n\tg[v].push_back(u);\n}\n\nvoid dfs(int v,vi e){\n\tc[v]=1;\n\tint X=x[v],Y=y[v];\n\tif(X==0&&!e[0]) e[0]++,d[0]++;\n\tif(X==h-1&&!e[1]) e[1]++,d[1]++;\n\tif(Y==0&&!e[2]) e[2]++,d[2]++;\n\tif(Y==w-1&&!e[3]) e[3]++,d[3]++;\n\tfor(auto u:g[v]) if(!c[u]) dfs(u,e);\n}\n\nint main(){\n\tcin>>n>>h>>w;\n\ta=vvp(h);\n\tb=vvp(w);\n\tx=y=c=vi(n);\n\tg=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tx[i]--;y[i]--;\n\t\ta[x[i]].push_back({y[i],i});\n\t\tb[y[i]].push_back({x[i],i});\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tsort(a[i].begin(),a[i].end());\n\t\tfor(int j=1;j<a[i].size();j++){\n\t\t\tint u=a[i][j-1].second,v=a[i][j].second;\n\t\t\tadd(u,v);\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tsort(b[i].begin(),b[i].end());\n\t\tfor(int j=1;j<b[i].size();j++){\n\t\t\tint u=b[i][j-1].second,v=b[i][j].second;\n\t\t\tadd(u,v);\n\t\t}\n\t}\n\tint t=0,M=0;\n\tfor(int i=0;i<n;i++) if(!c[i]){\n\t\tvi e(4);\n\t\tdfs(i,e);\n\t\tt++;\n\t}\n\tfor(int i=0;i<4;i++) M=max(M,d[i]);\n\tcout<<n-1+(t==1?0:t-M)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nclass UF {\npublic:\n    int sz; vector<int> par,nrank;\n    UF(int node_size){\n        sz = node_size; par.resize(sz),nrank.resize(sz,0);\n        rep(i,sz) par[i] = i;\n    }\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(nrank[x] < nrank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(nrank[x] == nrank[y]) nrank[x]++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nconst int MAX_N = 100005;\n\nvector<int> x[MAX_N],y[MAX_N];\nmap<int,bool> mp;\n\nint main()\n{\n    int n,w,h;\n    cin >> n >> h >> w;\n    UF uf(n);\n    vector<P> vec(n);\n    bool hasi = true;\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        if(a == 1 || a == h || b == 1 || b == w){\n            hasi = false;\n        }\n        vec[i] = P(a-1,b-1);\n        x[a-1].push_back(i), y[b-1].push_back(i);\n    }\n    rep(i,h){\n        rep(j,len(x[i])-1){\n            uf.unite(x[i][j],x[i][j+1]);\n        }\n    }\n    rep(i,w){\n        rep(j,len(y[i])-1){\n            uf.unite(y[i][j],y[i][j]+1);\n        }\n    }\n    set<int> st;\n    rep(i,n){\n        st.insert(uf.find(i));\n    }\n    if(len(st) == 1){\n        cout << n-1 << \"\\n\";\n    }else{\n        cout << n+len(st)-2+hasi << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, h, w; cin >> n >> h >> w;\n\tvector<vi> hor(h), ver(w);\n\tUnionFind uf(n);\n\tint edge = 0;\n\tREP(i, n)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tif (a == 0 || b == 0 || a == h - 1 || b == w - 1) edge = 1;\n\t\thor[a].push_back(i);\n\t\tver[b].push_back(i);\n\t}\n\tfor (auto v : hor)\n\t{\n\t\tREP(i, v.size() - 1)\n\t\t{\n\t\t\tuf.unite(v[i], v[i + 1]);\n\t\t}\n\t}\n\tfor (auto v : ver)\n\t{\n\t\tREP(i, v.size() - 1)\n\t\t{\n\t\t\tuf.unite(v[i], v[i + 1]);\n\t\t}\n\t}\n\tint cnt = 0;\n\tREP(i, n)\n\t{\n\t\tif (uf.par[i] >= 0) cnt++;\n\t}\n\tif (uf.count() == 1) cout << cnt << endl;\n\telse cout << cnt + uf.count() + (uf.count() - 1) - edge << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tif(n == 2 && res > 3)exit(100);\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[i] < 0) memoX[i] = x;//???????????????????????????????????\\??£????????¨???????????°???????????¢??£?????????\n\t\telse ds.unite(x, memoX[i]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[i] < 0) memoY[i] = y;\n\t\telse ds.unite(y, memoY[i]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\n\tif(m > 1){\n\t\tif(cornerw == true || cornerh == true){\n\t\t\tprintf(\"%d\\n\", n + m - 2);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\", n + m - 1);\n\t\t}\n\t}else{\n\t\tprintf(\"%d\\n\", n - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint cnth[N],cntw[N],x,y;\nint f1[N],f2[N];\nset<int> s;\n\nint main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    x--,y--;\n    s.insert(y);\n    if(!x)f1[y]=1;\n    if(x==w-1)f2[y]=1;\n    cnth[y]++;\n    cntw[x]++;\n  }\n  int f=0;\n  for(int i=0;i<w;i++)\n    if(cntw[i]==s.size())f=1;\n  if(f==1)cout<<n-1<<endl;\n  else{\n    int ans1=s.size()-1,ans2=s.size()-1;\n    for(int i=0;i<h;i++){\n      ans1+=cnth[i];\n      ans2+=cnth[i];\n      if(f1[i])ans1--;\n      if(f2[i])ans2--;\n    }\n    cout<<min(ans1,ans2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9+7);\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(10000) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nUnionFindTree g;\n\nint main() {\n    int n, h, w, ans;\n    cin >> n >> w >> h;\n    g.init(n+w+h);\n    for(int i=n;i<n+w+h;i++){\n        g.siz[i] = 0;\n    }\n    for(int i=0;i<n;i++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        g.unite(i, n+x);\n        g.unite(i, n+w+y);\n    }\n    ans = n-1;\n    set<int> st;\n    for(int i=0;i<n;i++){\n        st.insert(g.find(i));\n    }\n    int wall = 0;  // 壁に隣接しているスライムがあるか\n    wall = g.size(n)>0 || g.size(n+w-1)>0 || g.size(n+w)>0 || g.size(n+w+h-1)>0;\n    if(st.size()>1) ans += max(0, int(st.size())-wall);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct UnionFind{\n\tvector<int> rnk,par;\n\n\tUnionFind(int sz) : rnk(sz,0),par(sz){\n\t\tfor(int i = 0;i < sz;i++) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rnk[x] < rnk[y]) swap(x,y);\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n\t\n\tbool same(int x,int y){\n\t\treturn (find(x) == find(y));\n\t}\n};\n\nsigned main(){\n\tint n,w,h,x[40010],y[40010];\n\tbool hasEdge = false;\n\tcin >> n >> w >> h;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> y[i] >> x[i];\n\t\ty[i]--;x[i]--;\n\t\tif(x[i] == 0 || y[i] == 0 || x[i] == h - 1 || y[i] == w - 1) hasEdge = true;\n\t}\n\tvector<int> xs[100010],ys[100010];\n\tfor(int i = 0;i < n;i++){\n\t\txs[x[i]].push_back(i);\n\t\tys[y[i]].push_back(i);\n\t}\n\tUnionFind uf(n);\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j + 1 < xs[i].size();j++) uf.unite(xs[i][j],xs[i][j + 1]);\n\t}\n\tfor(int i = 0;i < w;i++){\n\t\tfor(int j = 0;j + 1 < ys[i].size();j++) uf.unite(ys[i][j],ys[i][j + 1]);\n\t}\n\tset<int> st;\n\tfor(int i = 0;i < n;i++) st.insert(uf.find(i));\n\tif(st.size() == 1) cout << n - 1 << endl;\n\telse cout << n - st.size() + (st.size() - 1) * 2 + !hasEdge << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nvector<int> vh[110000];\nvector<int> vw[110000];\n\n\nclass UnionFind{\n  vector<int> par;\npublic:\n  UnionFind(int n):par(n){\n    for(int i = 0; i < n; ++i)\n      par[i] = i;\n  };\n\t\t\n  int find(int x){\n    if(par[x]==x) return x;\n    return par[x] = find(par[x]);\n  }\n\t\t\n  bool unit(int a,int b){\n    int ap = find(a);\n    int bp = find(b);\n\t\t\t\n    if(ap == bp)\n      return false;\n    par[ap] = bp;\n    return true;\n  }\n};\n\nint xx[40000];\nint yy[40000];\n\nint main(int argc, char *argv[])\n{\n  int n,w,h;\n  cin >> n >> w >> h;\n  for(int i = 0; i < n; ++i){\n    int x,y;\n    cin >> x >> y;\n    xx[i] = x;\n    yy[i] = y;\n    vh[x].push_back(i);\n    vw[y].push_back(i);\n  }\n\n  UnionFind uf(n);\n\n  for(int i = 1; i <= w; ++i)\n    for(int j = 0; j+1 < (int)vh[i].size(); ++j)\n      uf.unit(vh[i][j], vh[i][j+1]);\n\n  for(int i = 1; i <= h; ++i)\n    for(int j = 0; j+1 < (int)vw[i].size(); ++j)\n      uf.unit(vw[i][j], vw[i][j+1]);\n\n  \n  set<int> co;\n  for(int i = 0; i < n; ++i)\n    co.insert(uf.find(i));\n\n  if(co.size() == 1){\n    cout << n-1 << endl;\n    return 0;\n  }\n  \n  int tans = n - co.size();\n  tans += co.size()*2 - 1;\n\n  if(!vw[1].empty() || !vh[1].empty() ||\n     !vw[h].empty() || !vh[w].empty())\n    --tans;\n  \n  cout << tans << endl;\n\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct union_find {\n\tvector<int> uf;\n\n\tunion_find(int n):uf(n, -1) {}\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif(x == y) return;\n\n\t\tif(uf[x] > uf[y]) swap(x, y);\n\t\telse if(uf[x] == uf[y]) --uf[x];\n\n\t\tuf[y] = x;\n\t}\n\n\tint number_of_sets() const {\n\t\treturn count_if(begin(uf), end(uf), [](int x) { return x < 0; });\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\n\tbool edge = false;\n\tvector<vector<int>> hor(h + 1), ver(w + 1);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\thor[y].emplace_back(i);\n\t\tver[x].emplace_back(i);\n\t\tif(x == 1 || y == 1 || x == w || y == h) edge = true;\n\t}\n\n\tunion_find uf(n);\n\tfor(const auto &vec : hor) {\n\t\tREP(i, 1, vec.size()) {\n\t\t\tuf.unite(vec[i], vec[i - 1]);\n\t\t}\n\t}\n\n\tfor(const auto &vec : ver) {\n\t\tREP(i, 1, vec.size()) {\n\t\t\tuf.unite(vec[i], vec[i - 1]);\n\t\t}\n\t}\n\n\tconst int S = uf.number_of_sets();\n\tconst int ans = (S == 1 ? n - 1 : n + S - 1 - edge);\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\nint N,H,W;\nint y,x;\nvector<int> G[2][MAX];\nbool visited[2][MAX];\nint flg[4],cnt[4];\n\nvoid dfs(int f,int p){\n  visited[f][p]=true;\n  if(p==1)flg[f]=true;\n  if(p==(f==0?H:W))flg[2+f]=true;\n  \n  int r=1-f;\n  for(int i=0;i<(int)G[f][p].size();i++){\n    int w=G[f][p][i];\n    if(visited[r][w])continue;\n    dfs(r,w);\n  }\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&H,&W);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d\",&y,&x);\n    G[0][y].push_back(x);\n    G[1][x].push_back(y);\n  }\n  \n  int ans=0;\n  for(int i=0;i<MAX;i++){\n    if(G[0][i].size()==0)continue;\n    if(visited[0][i])continue;\n    for(int j=0;j<4;j++)flg[j]=0;\n    dfs(0,i);\n    ans++;\n    for(int j=0;j<4;j++)cnt[j]+=flg[j];\n  }\n  for(int i=1;i<4;i++)cnt[i]=max(cnt[i],cnt[i-1]);\n  if(ans==1){\n    cout<<N-1<<endl;\n  }else{\n    cout<<N+ans-1-cnt[3]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=6105,INF=1<<30;\n\nstruct UF{\n    int n;\n    vector<int> par,size,edge;\n    \n    void init(int n_){\n        n=n_;\n        par.assign(n,-1);\n        size.assign(n,1);\n        edge.assign(n,0);\n        \n        for(int i=0;i<n;i++){\n            par[i]=i;\n        }\n    }\n    \n    int root(int a){\n        if(par[a]==a) return a;\n        else return par[a]=root(par[a]);\n    }\n    \n    void unite(int a,int b){\n        if(root(a)!=root(b)){\n            size[root(a)]+=size[root(b)];\n            edge[root(a)]|=edge[root(b)];\n            par[root(b)]=root(a);\n        }\n    }\n    \n    bool check(int a,int b){\n        return root(a)==root(b);\n    }\n};\n\nint H,W;\n\nbool check(int h,int w){\n    if(h==0||h==H-1) return 1;\n    if(w==0||w==W-1) return 1;\n    return 0;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N>>H>>W;\n    vector<vector<int>> hid(H),wid(W);\n    UF uf;\n    uf.init(N);\n    for(int i=0;i<N;i++){\n        int h,w;cin>>h>>w;\n        h--;w--;\n        hid[h].push_back(i);\n        wid[w].push_back(i);\n        \n        if(check(h,w)) uf.edge[i]=1;\n    }\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j+1<si(hid[i]);j++){\n            uf.unite(hid[i][j],hid[i][j+1]);\n        }\n    }\n    \n    for(int j=0;j<W;j++){\n        for(int i=0;i+1<si(wid[j]);i++){\n            uf.unite(wid[j][i],wid[j][i+1]);\n        }\n    }\n    \n    set<int> SE;\n    for(int i=0;i<N;i++){\n        SE.insert(uf.root(i));\n    }\n    \n    int ans=0,cnt=0;\n    \n    for(int a:SE){\n        ans+=uf.size[a]-1;\n        if(uf.edge[a]) cnt++;\n    }\n    \n    if(si(SE)==1) ans+=0;\n    else if(cnt==0){\n        ans+=si(SE)+si(SE)-1;\n    }else{\n        ans+=si(SE)-1+si(SE)-1;\n    }\n    \n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nint sgn(const double&r){return (r>EPS)-(r<-EPS);} // a>0  : sgn(a)>0\nint sgn(const double&a,const double&b){return sgn(a-b);} // b<=c : sgn(b,c)<=0\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\nstruct UnionFind{\n    vl par,dist;\n    UnionFind(int x){par.assign(x,-1); dist.assign(x,0);}\n    ll find(ll x){return par[x]<0?x:find(par[x]);}\n    ll depth(ll x){return par[x]<0?0:depth(par[x])+dist[x];}\n    bool same(ll x,ll y){return find(x)==find(y);}\n    ll size(ll x){return -par[find(x)];}\n    ll diff(ll x,ll y){return same(x,y)?depth(x)-depth(y):LINF;}\n    void unite(ll x,ll y,ll k=0){\n        k+=depth(y); k-=depth(x); k=-k;\n        x=find(x); y=find(y);\n        if(x==y)return;\n        if(size(x)<size(y)){swap(x,y);k=-k;}\n        par[x]+=par[y]; par[y]=x; dist[y]=k;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,w,h;\n    cin>>n>>w>>h;\n    bool isnear = false;\n    vvl y(h+1),x(w+1);\n    rep(i,n){\n        ll a,b;cin>>a>>b;\n        if(a==1 or b==1 or a==w or b==h) isnear = true;\n        x[a].push_back(i);\n        y[b].push_back(i);\n    }\n    ll ans=0, cnt=n;\n    UnionFind uf(n);\n    rep(i,h+1){\n        rep(j,(int)y[i].size()-1){\n            if(!uf.same(y[i][j], y[i][j+1])){\n                uf.unite(y[i][j], y[i][j+1]);\n                ans++;\n                cnt--;\n            }\n        }\n    }\n    rep(i,w+1){\n        rep(j,(int)x[i].size()-1){\n            if(!uf.same(x[i][j], x[i][j+1])){\n                uf.unite(x[i][j], x[i][j+1]);\n                ans++;\n                cnt--;\n            }\n        }\n    }\n    if(cnt==1){\n        puta(ans);\n    }else{\n        if(isnear){\n            puta(ans + cnt-1 + cnt-1);\n        }else{\n            puta(ans + cnt + cnt-1);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    // x, y????????????\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    // x, y?????????????????????1\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // x??????????????????????????§???????????????\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // ?????¢??????????????????????????°?????????\n    int setNum(void) {\n        map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n    void print(void) {\n        auto c = getUnionList();\n        for (auto x : c) {\n            for (auto y : x) \n                cout << y << \" \";\n            cout << endl;\n        }\n    }\n};\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, nx, ny; cin >> n >> nx >> ny;\n    vector<P> s(n);\n    \n    vll vx(nx), vy(ny);\n    vll rx(nx, -1), ry(ny, -1);\n    vvll wall(n, vll(4));\n    bool is_wall = 0;\n    rep(i, n) {\n        cin >> s[i].fi >> s[i].se; s[i].fi--; s[i].se--;\n        rx[s[i].fi] = i;\n        ry[s[i].se] = i;\n        wall[i][0] = s[i].fi == 0;\n        wall[i][1] = s[i].fi == nx-1;\n        wall[i][2] = s[i].se == 0;\n        wall[i][3] = s[i].se == ny-1;\n        is_wall = (s[i].fi == 0 || s[i].fi == nx-1 || s[i].se == 0 || s[i].se == ny-1);\n    }\n\n    UnionFind uf(n);\n    rep(i, n) {\n        uf.unite(i, rx[s[i].fi]);\n        uf.unite(i, ry[s[i].se]);\n    }\n    /*\n    cout << \"####\" << endl;\n    uf.print();\n    cout << \"####\" << endl;\n    */\n\n    auto list = uf.getUnionList();\n//    cout << list << endl;\n//    cout << list << endl;\n    if (list.size() == 1) {\n        cout << (*list.begin()).size() - 1 << endl;\n        return 0;\n    }\n\n    /*\n    map<ll, vll> wall_list;\n//    vll wall(4);\n    for (auto x : list) {\n        auto tmp = vll(4);\n        rep(i, x.size()) {\n            rep(j, 4) {\n                tmp[j] |= wall[x[i]][j];\n            }\n        }\n        wall_list[x] = tmp;\n    }\n//    cout << wall_list << endl;\n    */\n\n    ll ret = 0;\n    for (auto x : list) {\n        ret += x.size() - 1;\n    }\n    cout << ret + 2 * list.size() - is_wall - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,h,w;\nvvi a,b;\nmap<int,int> mx,my;\n\nint main(){\n\tcin>>n>>w>>h;\n\tUnion_Find_Tree uft(n);\n\tint cx=0,cy=0;\n\ta=b=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(mx.find(x)==mx.end()){\n\t\t\tmx[x]=cx;\n\t\t\tcx++;\n\t\t}\n\t\tif(my.find(y)==my.end()){\n\t\t\tmy[y]=cy;\n\t\t\tcy++;\n\t\t}\n\t\ta[mx[x]].push_back(i);\n\t\tb[my[y]].push_back(i);\n\t}\n\tfor(int i=0;i<n;i++) for(int j=1;j<a[i].size();j++) uft.Unite(a[i][j],a[i][j-1]);\n\tfor(int i=0;i<n;i++) for(int j=1;j<b[i].size();j++) uft.Unite(b[i][j],b[i][j-1]);\n\tvi used(n);\n\tint res=n-3;\n\tfor(int i=0;i<n;i++){\n\t\tint p=uft.Find_Par(i);\n\t\tif(!used[p]){\n\t\t\tused[p]=1;\n\t\t\tres+=2;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, h, w; cin >> n >> h >> w;\n    vector<ll> X(n), Y(n);\n    rep(i, n) {\n\t\tcin >> X[i] >> Y[i];\n\t\t--X[i], --Y[i];\n\t}\n\tvector<vector<ll>> g1(h), g2(w);\n\trep(i, n) {\n\t\tg1[Y[i]].pb(i);\n\t\tg2[X[i]].pb(i);\n\t}\n\tUnionFind uf(n);\n\trep(i, h) {\n\t\trep(j, ll(g1[i].size())-1) {\n\t\t\tuf.unite(g1[i][j], g1[i][j+1]);\n\t\t}\n\t}\n\trep(i, w) {\n\t\trep(j, ll(g2[i].size())-1) {\n\t\t\tuf.unite(g2[i][j], g2[i][j+1]);\n\t\t}\n\t}\n\tset<ll> s;\n\trep(i, n) s.insert(uf.root(i));\n\tll ans = linf;\n\tif (s.size() == 1) {\n\t\tans = n-1;\n\t}\n\telse {\n\t\tans = n + s.size() - 1;\n\t\tset<ll> sl, sr, su, sd;\n\t\trep(i, n) {\n\t\t\tll id = uf.root(i);\n\t\t\tif (X[i] == 0) sl.insert(id);\n\t\t\tif (X[i] == w-1) sr.insert(id);\n\t\t\tif (Y[i] == 0) su.insert(id);\n\t\t\tif (Y[i] == h-1) sd.insert(id);\n\t\t}\n\t\tans -= max(max(sl.size(), sr.size()), (su.size(), sd.size()));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define len(v) (int)(v).size()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nclass UF {\npublic:\n    int sz; vector<int> par,nrank;\n    UF(int node_size){\n        sz = node_size; par.resize(sz),nrank.resize(sz,0);\n        rep(i,sz) par[i] = i;\n    }\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(nrank[x] < nrank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(nrank[x] == nrank[y]) nrank[x]++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nconst int MAX_N = 100005;\n\nvector<int> x[MAX_N],y[MAX_N];\n\nint main()\n{\n    int n,w,h;\n    cin >> n >> h >> w;\n    UF uf(n);\n    bool hasi = true;\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        if(a == 1 || a == h || b == 1 || b == w){\n            hasi = false;\n        }\n        x[a-1].push_back(i), y[b-1].push_back(i);\n    }\n    rep(i,h){\n        rep(j,len(x[i])-1){\n            uf.unite(x[i][j],x[i][j+1]);\n        }\n    }\n    rep(i,w){\n        rep(j,len(y[i])-1){\n            uf.unite(y[i][j],y[i][j+1]);\n        }\n    }\n    set<int> st;\n    rep(i,n){\n        st.insert(uf.find(i));\n    }\n    if(len(st) == 1){\n        cout << n-1 << \"\\n\";\n    }else{\n        cout << n+len(st)-2+hasi << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 24;\n\nconstexpr int kMaxXY = 1e5 + 1;\nconstexpr int kN = 1e5 * 4;\n\nint memox[kMaxXY];\nint memoy[kMaxXY];\nint p[kN];\n\nint root(int idx){\n    if(p[idx] == idx) return idx;\n\n    return p[idx] = root(p[idx]);\n}\n\nint main(void){\n    for(int n, w, h; cin >> n >> w >> h;){\n        int numIdx = 0;\n        vi cnt(n);\n\n        // x = 0, x = w - 1, y = 0, y = h - 1\n        vvi cntSumi(n, vi(4));\n\n        fill(memox, memox + kMaxXY, -1);\n        fill(memoy, memoy + kMaxXY, -1);\n\n        rep(loop, n){\n            int x, y; cin >> x >> y; x--, y--;\n            int idx; //root\n            \n            if(memox[x] != -1 && memoy[y] != -1){\n                idx = root(memox[x]);\n\n                if(root(memox[x]) != root(memoy[y])){\n                    //union r2 -> r1(new root)\n                    int r1 = idx, r2 = root(memoy[y]);\n\n                    cnt[r1] += cnt[r2]; cnt[r2] = 0;\n                    rep(i, 4) cntSumi[r1][i] += cntSumi[r2][i], cntSumi[r2][i] = 0;\n\n                    p[r2] = root(memoy[y]);\n                }\n            }\n            else if(memox[x] != -1){\n                idx = memoy[y] = root(memox[x]);\n            }\n            else if(memoy[y] != -1){\n                idx = memox[x] = root(memoy[y]);\n            }\n            else {\n                p[numIdx] = numIdx;\n                idx = memox[x] = memoy[y] = numIdx++;\n            }\n\n            if(x ==   0) cntSumi[idx][0]++;\n            if(x == w-1) cntSumi[idx][1]++;\n            if(y ==   0) cntSumi[idx][2]++;\n            if(y == h-1) cntSumi[idx][3]++;\n\n            cnt[idx]++;\n        }\n\n        int res = 0, numS = 0;\n        vi numSumi(4);\n        rep(i, numIdx){\n            if(cnt[i] != 0) res += cnt[i] - 1, numS++;\n\n            rep(j, 4){\n                if(cntSumi[i][j] != 0){\n                    numSumi[j]++;\n                }\n            }\n        }\n        if(numS != 1) res += (numS - *max_element(all(numSumi))) + numS - 1;\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,h,w;\nvvi a,b;\nmap<int,int> mx,my;\n\nint main(){\n\tcin>>n>>w>>h;\n\tUnion_Find_Tree uft(n);\n\tint cx=0,cy=0;\n\ta=b=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(mx.find(x)==mx.end()) mx[x]=cx++;\n\t\tif(my.find(y)==my.end()) my[y]=cy++;\n\t\ta[mx[x]].push_back(i);\n\t\tb[my[y]].push_back(i);\n\t}\n\tfor(int i=0;i<n;i++) for(int j=1;j<a[i].size();j++) uft.Unite(a[i][j],a[i][j-1]);\n\tfor(int i=0;i<n;i++) for(int j=1;j<b[i].size();j++) uft.Unite(b[i][j],b[i][j-1]);\n\tvi used(n);\n\tint res=n-3;\n\tfor(int i=0;i<n;i++){\n\t\tint p=uft.Find_Par(i);\n\t\tif(!used[p]){\n\t\t\tused[p]=1;\n\t\t\tres+=2;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int n,w,h;cin>>n>>w>>h && n|w|h;){\n\t\tvi xs(n),ys(n);\n\t\trep(i,n) cin>>xs[i]>>ys[i];\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tUnionFind uf(n);\n\t\tsort(all(is),[&](int i,int j){return xs[i]<xs[j];});\n\t\trep(i,n-1) if(xs[is[i]]==xs[is[i+1]]) uf.Unite(is[i],is[i+1]);\n\t\tsort(all(is),[&](int i,int j){return ys[i]<ys[j];});\n\t\trep(i,n-1) if(ys[is[i]]==ys[is[i+1]]) uf.Unite(is[i],is[i+1]);\n\t\t\n\t\tint cnt=count_if(all(uf.data),[](int x){return x<0;});\n\t\tint res=n-cnt;\n\t\tif(cnt>1){\n\t\t\tres+=2*cnt-1;\n\t\t\trep(i,n) if(xs[i]==1 || xs[i]==w || ys[i]==1 || ys[i]==h){\n\t\t\t\tres--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nvector<int> x[100005];\nvector<int> y[100005];\n\nint main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  rep(i,n){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    x[p].pb(i);\n    y[q].pb(i);\n  }\n\n  UnionFind uf(n);\n\n  rep(i,100005){\n    rep(j,x[i].size()-1) uf.unite(x[i][j], x[i][j+1]);\n  }\n  rep(i,100005){\n    rep(j,y[i].size()-1) uf.unite(y[i][j], y[i][j+1]);\n  }\n\n  if(uf.size(0)==n){ cout << n-1 << endl; }\n  else {\n    int mx = max({x[0].size(), x[w-1].size(), y[0].size() ,y[h-1].size()});\n    cout << n + n-1 -mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N, W, H;\n  vector< int > xs[100000], ys[100000];\n\n  scanf(\"%d %d %d\", &N, &W, &H);\n  bool ei = false;\n  for(int i = 0; i < N; i++) {\n    int X, Y;\n    scanf(\"%d %d\", &X, &Y);\n    xs[--X].push_back(i);\n    ys[--Y].push_back(i);\n    ei |= X == 0 || Y == 0 || X == W - 1 || Y == H - 1;\n  }\n\n  UnionFind tree(N);\n  for(int i = 0; i < 100000; i++) {\n    for(int j = 1; j < xs[i].size(); j++) tree.unite(xs[i][j - 1], xs[i][j]);\n    for(int j = 1; j < ys[i].size(); j++) tree.unite(ys[i][j - 1], ys[i][j]);\n  }\n\n  int cnt = 0;\n  for(int i = 0; i < N; i++) cnt += tree.find(i) == i;\n  int ret = N - cnt;\n  if(cnt > 1) ret += cnt * 2 - 1 - ei;\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  vector<int> ix(w+1,-1);\n  vector<int> ixx(w+1,-1);\n  vector<int> ixn(w+1,-1);\n  vector<int> iy(h+1,-1);\n  vector<int> iyx(h+1,-1);\n  vector<int> iyn(h+1,-1);\n  Edges ve;\n  REP(i,n) {\n    int x,y;\n    cin>>x>>y;\n    if (ix[x] == -1) {\n      ix[x] = i;\n      ixx[x] = y;\n      ixn[x] = y;\n    } else {\n      ixx[x] = max(ixx[x], y);\n      ixn[x] = min(ixn[x], y);\n      ve.push_back((Edge){i, ix[x], 1});\n    }\n    if (iy[y] == -1) {\n      iy[y] = i;\n      iyx[y] = x;\n      iyn[y] = x;\n    } else {\n      iyx[y] = max(iyx[y], x);\n      iyn[y] = min(iyn[y], x);\n      ve.push_back((Edge){i, iy[y], 1});\n    }\n  }\n  int res = INF;\n  auto rve = kruskal(n,ve);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n-1) res = min(res, sum);\n  auto tmp = ve;\n  int cnt = 0;\n  FOR(x,1,w+1) {\n    if (ix[x] >= 0) {\n      tmp.push_back((Edge){ix[x], n+cnt, (ixn[x]>1)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(x,1,w+1) {\n    if (ix[x] >= 0) {\n      tmp.push_back((Edge){ix[x], n+cnt, (ixx[x]<h)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(y,1,h+1) {\n    if (iy[y] >= 0) {\n      tmp.push_back((Edge){iy[y], n+cnt, (iyn[y]>1)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt, tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(y,1,h+1) {\n    if (iy[y] >= 0) {\n      tmp.push_back((Edge){iy[y], n+cnt, (iyx[y]<w)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  cerr << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ntypedef struct UnionFind {\n    vector<int> vertex;\n    UnionFind(int size) : vertex(size,-1) { }\n    bool Union(int x, int y){\n        x = root(x); y = root(y);\n        if( x != y ) {\n            if(vertex[y] < vertex[x]) swap(x,y);\n            vertex[x] += vertex[y]; vertex[y] = x;\n        }\n        return x != y;\n    }\n\n    bool Find(int x, int y){\n        return root(x) == root(y);\n    }\n\n    int root(int x){\n        return vertex[x] < 0 ? x : vertex[x] = root(vertex[x]);\n    }\n    int size(int x){\n        return -vertex[root(x)];\n    }\n} UnionFind;\n\n\nint main() {\n    int N,W,H;\n    cin >> N >> W >> H;\n    vector<int> vectx(W,-1),vecty(H,-1);;\n    UnionFind uf(N);\n    bool wall=false;\n    int num = N;\n    int x,y;\n    for(int i=0 ; i<N ; i++){\n        cin >> x >> y;\n        if( x==1 || x==W || y==1 || y==H) wall = true;\n        x--;y--;\n        if(vectx[x]==-1){\n            vectx[x]=i;\n        }else{\n            if(!uf.Find(i,vectx[x])){\n                uf.Union(i,vectx[x]);\n                num--;\n            }\n        }\n        if(vecty[y]== -1){\n            vecty[y]=i;\n        }else{\n            if(!uf.Find(i,vecty[y])){\n                uf.Union(i,vecty[y]);\n                num--;\n            }\n        }\n    }\n\n    if(num==1){\n        cout << N-1 << endl;\n    }else if(wall){\n        cout << N-2+num << endl;\n    }else {\n        cout << N-1+num << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v) : parent(v), rank(v, 0) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : parent[a] = find(parent[a]); }\n    void unite(int a, int b)\n    {\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (rank[a] < rank[b]) { swap(a, b); }\n        if (rank[a] == rank[b]) { rank[a]++; }\n        parent[b] = a;\n    }\n\nprivate:\n    vector<int> parent, rank;\n};\nint main()\n{\n    int N, W, H;\n    cin >> N >> W >> H;\n    vector<vector<int>> h(H), v(W);\n    bool w = false;\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        if (x == 1 or x == W or y == 1 or y == H) { w = true; }\n        h[y - 1].push_back(i), v[x - 1].push_back(i);\n    }\n    DisjointSets uf(N);\n    for (int y = 0; y < H; y++) {\n        for (int i = 1; i < h[y].size(); i++) { uf.unite(h[y][0], h[y][i]); }\n    }\n    for (int x = 0; x < W; x++) {\n        for (int i = 1; i < v[x].size(); i++) { uf.unite(v[x][0], v[x][i]); }\n    }\n    vector<bool> used(N, false);\n    int c = 0;\n    for (int i = 0; i < N; i++) {\n        if (used[uf.find(i)]) { continue; }\n        used[uf.find(i)] = true, c++;\n    }\n    cout << (c == 1 ? N - 1 : w ? N + c - 2 : N + c - 1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int,int> PII;\n#define MP make_pair\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n \n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n \n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n \n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n \n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n\n};\n\n\nint main(){\n  int N, W, H; cin >> N >> W >> H;\n  vector<PII> xs(N), ys(N);\n  for(int i=0;i<N;++i){\n\tint x, y; cin >> x >> y;\n\txs[i] = MP(x,i), ys[i] = MP(y,i);\n  }\n  sort(xs.begin(), xs.end());\n  sort(ys.begin(), ys.end());\n\n  UnionFind uf(N);\n  for(int i=0;i+1<N;++i){\n\tif(xs[i].first == xs[i+1].first)\n\t  uf.unite(xs[i].second, xs[i+1].second);\n\tif(ys[i].first == ys[i+1].first)\n\t  uf.unite(ys[i].second, ys[i+1].second);\n  }\n\n  vector<int> cnt(N, 0);\n  for(int i=0;i<N;++i)\n\tcnt[uf.find(i)]++;\n\n  int ans = 0, tot = 0;\n  for(int i=0;i<N;++i)\n\tif(cnt[i] != 0)\n\t  ++tot, ans += cnt[i] - 1;\n\n  //cout << \"(\" << tot << \", \" << ans << \")\" << endl;\n  if(tot > 1){\n\tif(xs[0].first == 1 || xs.back().first == W || ys[0].first == 1 || ys.back().first == H)\n\t  ans += 2*tot - 2;\n\telse\n\t  ans += 2 * tot - 1;\n  }\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  rep(i,N) { \n    cin >> x[i] >> y[i];\n    uf[i] = i, masks[i] = sz[i] = 0;\n\n    if( y[i] == 1 ) masks[i] |= (1<<0);\n    if( x[i] == 1 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  map<int,int> bitmask;\n  set<int> S;\n  vector<int> group;\n  rep(i,N) find(i);\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n\n  if( S.size() == 1 ) {\n    cout << sz[find(0)] - 1 << endl;\n    return 0;\n  }\n\n  rep(i,N) bitmask[find(i)] |= masks[i];\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[group[j]];\n      if( (bitmask[group[j]]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Loc{\n\tLeft,\n\tRight,\n\tTop,\n\tBottom,\n};\n\nint* parent, *height;\nint unite_count = 0;\n\nstruct Info{\n\tint x,y;\n};\n\n\nint find_parent(int id){\n\tif(parent[id] == id){\n\t\treturn id;\n\t}else{\n\t\treturn parent[id] == find_parent(parent[id]);\n\t}\n}\n\nbool isSame(int left,int right){\n\treturn find_parent(left) == find_parent(right);\n}\n\nvoid unite(int left,int right){\n\n\tint left_parent = find_parent(left);\n\tint right_parent = find_parent(right);\n\n\tif(left_parent == right_parent)return;\n\n\tif(height[left_parent] >= height[right_parent]){\n\t\tif(height[left_parent] == height[right_parent]){\n\t\t\theight[left_parent]++;\n\t\t}\n\t\tparent[right_parent] = left_parent;\n\n\t}else{\n\t\tparent[left_parent] = right_parent;\n\t}\n\n\tunite_count++;\n}\n\n\nint main(){\n\n\tint N,W,H;\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tparent = new int[N+1];\n\theight = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\tvector<int> X[W+1],Y[H+1];\n\n\tfor(int id = 1; id <= N; id++){\n\t\tscanf(\"%d %d\",&info[id].x,&info[id].y);\n\t\tX[info[id].x].push_back(id);\n\t\tY[info[id].y].push_back(id);\n\t}\n\n\tfor(int i = 1; i <= W;i++){\n\n\t\tif(X[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < X[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < X[i].size();p++){\n\t\t\t\tunite(X[i][k],X[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= H; i++){\n\n\t\tif(Y[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < Y[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < Y[i].size();p++){\n\t\t\t\tunite(Y[i][k],Y[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstack<int> GroupID;\n\n\tint group_num = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(parent[i] == i){\n\t\t\tgroup_num++;\n\t\t\tGroupID.push(i);\n\t\t}\n\t}\n\n\tint Loc_num[4] = {0,0,0,0},id;\n\tbool check[4];\n\n\twhile(!GroupID.empty()){\n\t\tid = GroupID.top();\n\t\tGroupID.pop();\n\n\t\tfor(int i = 0; i < 4; i++)check[i] = false;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(parent[i] == id){\n\t\t\t\tif(info[i].x == 1){\n\t\t\t\t\tcheck[Left] = true;\n\t\t\t\t}else if(info[i].x == W){\n\t\t\t\t\tcheck[Right] = true;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].y == 1){\n\t\t\t\t\tcheck[Top] = true;\n\t\t\t\t}else if(info[i].y == H){\n\t\t\t\t\tcheck[Bottom] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(check[i]){\n\t\t\t\tLoc_num[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_kabe = 0,tmp;\n\n\tfor(int i = 0; i < 4; i++)max_kabe = max(max_kabe,Loc_num[i]);\n\n\tint ans = unite_count;\n\n\tif(group_num != 1){\n\t\ttmp = group_num-max_kabe;\n\n\t\tans += tmp + group_num-1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    vector<int>f;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        f.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n            f[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        f[x]|=f[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H,W;\nint x[44444],y[44444];\nint px[111111],py[111111];\n\nint solve(int T){\n    UF uf;uf.init(N);\n    memset(px,-1,sizeof(px));\n    memset(py,-1,sizeof(py));\n    rep(i,N){\n        if(px[x[i]]>=0)uf.unite(px[x[i]],i);\n        if(py[y[i]]>=0)uf.unite(py[y[i]],i);\n        if(y[i]==T)uf.f[uf.find(i)]=1;\n        px[x[i]]=i;py[y[i]]=i;\n    }\n\n    int cnt1=0,cnt2=0;\n    rep(i,N)if(uf.find(i)==i){\n        cnt1++;\n        if(uf.f[i])cnt2++;\n    }\n\n    if(cnt1==1)return N-1;\n    return N-cnt1+cnt1-cnt2+N-1;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&N,&H,&W);\n    rep(i,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n\n    int ans=1001001001;\n    rep(i,2){\n        chmin(ans,solve(1));\n        chmin(ans,solve(H));\n        swap(H,W);\n        rep(j,N)swap(x[j],y[j]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 40005;\n\nint x[MAX_N],y[MAX_N];\nint n,w,h;\nbool flag[MAX_N];\nvector<int> X[100002],Y[100002];\nvector<int> G[MAX_N];\n\nvoid dfs(int u,bool& hoge)\n{\n    flag[u] = true;\n    if(x[u] == 0 || x[u] == h-1 || y[u] == 0 || y[u] == w-1){\n        hoge = true;\n    }\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],hoge);\n        }\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n        x[i]--,y[i]--;\n        X[x[i]].push_back(i);\n        Y[y[i]].push_back(i);\n\t}\n    rep(i,w){\n        rep(j,Y[i].size()){\n            rep(k,Y[i].size()){\n                if(k != j){\n                    G[Y[i][j]].push_back(Y[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,X[i].size()){\n            rep(k,X[i].size()){\n                if(k != j){\n                    G[X[i][j]].push_back(X[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    int cnt = 0;\n    int pl = 0;\n    bool wall = false;\n    rep(i,n){\n        if(!flag[i]){\n            cnt++;\n            dfs(i,wall);\n        }\n    }\n    if(wall){\n        pl += 2*(cnt-1);\n    }else{\n        pl += 3*(cnt-1);\n    }\n    printf(\"%d\\n\",n-cnt+pl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) lps(i,0,n)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define FDST int hogehogehoge;cin>>hogehogehoge\n#define   int long long\n\nint x[110000],y[110000];\nint change[50000];\n\nsigned  main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  int c=0,ans=0;\n  int stat=0;\n  int am=1;\n  lp(i,n){\n    int xx,yy;\n    cin>>xx>>yy;\n    while(change[x[xx]]!=0) x[xx]=change[x[xx]];\n    while(change[y[yy]]!=0) y[yy]=change[y[yy]];\n    if(xx==1||yy==1||xx==w||yy==h) stat=1;\n    if(x[xx]==0&&y[yy]==0){\n      c++;\n      x[xx]=am;\n      y[yy]=am;\n      am++;\n    }\n    else{\n      ans++;\n      if(x[xx]==0&&y[yy]!=0) x[xx]=y[yy];\n      else if(y[yy]==0&&x[xx]!=0) y[yy]=x[xx];\n      else if(x[xx]==y[yy]) continue;\n      else{\n\tint a=x[xx],b=y[yy];\n\tif(a>b) swap(a,b);\n\tif(change[a]==b)1;\n\telse{\n\t  c--;\n\t  change[a]=b;\n\t  ans++;\n\t}\n      }\n    }/*\n    cout<<\" \";\n    lp(i,5){\n      cout<<x[i+1];\n    }\n    cout<<endl;\n    lp(j,5){\n      cout<<y[j+1]<<endl;\n      }*/\n    // cout<<c<<\" \"<<ans<<\" \"<<stat<<endl;\n  }\n  /*cout<<\" \";\n  lp(i,5){\n    cout<<x[i+1];\n  }\n  cout<<endl;\n  lp(j,5){\n    cout<<y[j+1]<<endl;\n    }*/\n  if(c==1) 1;\n  else{\n    ans+=c*2-1-stat;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nstruct UnionFind {\n    int node[40010], sz;\n    UnionFind(int N) {\n        memset(node, -1, sizeof(node));\n        sz = N;\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if(u == v) return;\n\n        sz--;\n        node[v] += node[u];\n        node[u] = v;\n    }\n    int get_size() {\n        return sz;\n    }\n};\n\nint N, H, W;\nmap< int, vector<int> > vec_row, vec_col;\n\nvoid unite_slimes(UnionFind &uf, map< int, vector<int> > &vecs) {\n    for(auto e : vecs) {\n        const vector<int> &vec = e.second;\n        int S = vec.size();\n        for(int i=0; i<S-1; i++) {\n            int u = vec[i], v = vec[i+1];\n            uf.unite(u, v);\n        }\n    }\n}\n\nint main() {\n    cin >> N >> W >> H;\n    UnionFind uf(N);\n    \n    bool find_edge = false;\n    for(int i=0; i<N; i++) {\n        int col, row; cin >> col >> row;\n        if(vec_col.count(col)) {\n            vec_col[col].push_back(i);\n        }\n        else {\n            vec_col[col] = vector<int>{i};\n        }\n\n        if(vec_row.count(row)) {\n            vec_row[row].push_back(i);\n        }\n        else {\n            vec_row[row] = vector<int>{i};\n        }\n\n        find_edge |= (col == 1 || col == W);\n        find_edge |= (row == 1 || row == H);\n    }\n\n    unite_slimes(uf, vec_row);\n    unite_slimes(uf, vec_col);\n\n    int rest_slimes = uf.get_size();\n    if(rest_slimes == 1) {\n        cout << N - rest_slimes << endl;\n    }\n    else {\n        cout << N + rest_slimes - 1 - find_edge << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntemplate<int um> class UF { // from kmjp\npublic:\n\tvector<int> par;\n\tUF() { par = vector<int>(um, 0); rep(i, 0, um) par[i] = i; }\n\tint operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n\tvoid operator()(int x, int y)\n\t{\n\t\tx = operator[](x); y = operator[](y);\n\t\tif (x != y) par[x] = y;\n\t}\n};\n//-----------------------------------------------------------------\nint N, W, H;\nint X[40101], Y[40101];\nUF<40101> uf;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> W >> H;\n\trep(i, 0, N) cin >> X[i] >> Y[i];\n\n\trep(i, 0, N) rep(j, i + 1, N) if (X[i] == X[j] || Y[i] == Y[j]) uf(i, j);\n\n\tbool isWall = false;\n\trep(i, 0, N) if ((X[i] == 1 || X[i] == W) || (Y[i] == 1 || Y[i] == H)) isWall = true;\n\n\tint ans = 0;\n\trep(i, 0, N) if (uf[i] == i) ans++;\n\n\tif (ans == 1)\n\t\tans = N - 1;\n\telse {\n\t\tif (isWall) ans--;\n\t\tans += N - 1;\n\t}\t\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50010\n\nclass Union_Find{\npublic:\n  int par[MAX],rank[MAX],size[MAX],gnum;\n  Union_Find(int N){\n    gnum = N;\n    for(int i = 0 ; i < MAX ; i++){\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 0;\n    }\n  }\n  int find(int x){\n    if(par[x] == x){\n      return x;\n    }\n    return par[x] = find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y){ return; }\n    if(rank[x] < rank[y]){\n      par[x] = y;\n      size[y] += size[x];\n    }else{\n      par[y] = x;\n      size[x] += size[y];\n      if(rank[x] == rank[y]){\n        rank[x]++;\n      }\n    }\n    gnum--;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n  int getSize(int x){\n    return size[find(x)];\n  }\n  int groups(){\n    return gnum;\n  }\n};\n\nint N,W,H;\nint X[2*MAX],Y[2*MAX],x[MAX],y[MAX];\n\nbool isWall(int x,int y){\n  if(x == 1 || y == 1 || x == W || y == H){\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  Union_Find uf(N);\n  for(int i = 0 ; i < 2*MAX ; i++){\n    X[i] = Y[i] = -1;\n  }\n  bool wall = false;\n  for(int i = 0 ; i < N ; i++){\n    cin >> x[i] >> y[i];\n    uf.size[i] = 1;\n    if(X[x[i]] == -1){\n      X[x[i]] = i;\n    }else{\n      uf.unite(X[x[i]],i);\n    }\n    if(Y[y[i]] == -1){\n      Y[y[i]] = i;\n    }else{\n      uf.unite(Y[y[i]],i);\n    }\n    wall |= isWall(x[i],y[i]);\n  }\n  if(uf.groups() == 1){\n    cout << uf.getSize(0)-1 << endl;\n  }else{\n    int sum = 0;\n    set<int> visited;\n    for(int i = 0 ; i < N ; i++){\n      int f = uf.find(i);\n      if(!visited.count(f)){\n        visited.insert(f);\n        sum += uf.getSize(i)-1;\n      }\n    }\n    cout << sum+(uf.groups()-1)*2+1-wall << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint check(const Edges& ve, const vector<int>& id, int len, const vector<bool> &cond, int n) {\n  auto tmp = ve;\n  int cnt = 0;\n  FOR(i,1,len+1) {\n    if (id[i] >= 0) {\n      tmp.push_back((Edge){id[i], n+cnt, cond[i]});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  auto rve = kruskal(n+cnt,tmp);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) return sum;\n  else return INF;\n}\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  vector<int> ix(w+1,-1);\n  vector<bool> ixx(w+1);\n  vector<bool> ixn(w+1);\n  vector<int> iy(h+1,-1);\n  vector<bool> iyx(h+1);\n  vector<bool> iyn(h+1);\n  Edges ve;\n  REP(i,n) {\n    int x,y;\n    cin>>x>>y;\n    if (ix[x] == -1) {\n      ix[x] = i;\n      ixx[x] = y == h;\n      ixn[x] = y == 0;\n    } else {\n      ixx[x] = ixx[x] || y == h;\n      ixn[x] = ixn[x] || y == 0;\n      ve.push_back((Edge){i, ix[x], 1});\n    }\n    if (iy[y] == -1) {\n      iy[y] = i;\n      iyx[y] = x == w;\n      iyn[y] = x == 0;\n    } else {\n      iyx[y] = iyx[y] || x == w;\n      iyn[y] = iyn[y] || x == 0;\n      ve.push_back((Edge){i, iy[y], 1});\n    }\n  }\n  int res = INF;\n  auto rve = kruskal(n,ve);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n-1) res = min(res, sum);\n  res = min(res, check(ve, ix, w, ixn, n));\n  res = min(res, check(ve, ix, w, ixx, n));\n  res = min(res, check(ve, iy, h, iyn, n));\n  res = min(res, check(ve, iy, h, iyx, n));\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,h,w;\n\nstruct unionFind{\n  unionFind(int n){\n    init(n);\n  }\n  vector<int> par,size;\n  int grup;\n  void init(int n){\n    grup=n;\n    par.resize(n);\n    size.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x]=find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n    if(size[x]<size[y]) swap(x,y);\n    par[y] = x;\n    size[x]+=size[y];\n    grup--;\n  }\n  bool same(int x,int y){return find(x) == find(y);}\n  int getg(){return grup;}\n};\n\nmap<int,vector<int> > xx;\nmap<int,vector<int> > yy;\nint main(){\n  cin>>n>>w>>h;\n  bool f=0;\n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    if(x==1 || y==1 || x==w || y==h) f=1;\n    xx[x].push_back(i);\n    yy[y].push_back(i);\n  }\n  unionFind u(n);\n  \n  map<int,vector<int> >::iterator it;\n  for(it=xx.begin();it!=xx.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  for(it=yy.begin();it!=yy.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  int cnt=u.getg();\n  if(cnt==1) cout<<n-cnt<<endl;\n  else cout<<n+cnt-1-f<<endl;     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,h,w;\nvvi a,b;\nmap<int,int> mx,my;\n\nint main(){\n\tcin>>n>>w>>h;\n\tUnion_Find_Tree uft(n);\n\tint cx=0,cy=0;\n\ta=b=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(mx.find(x)==mx.end()){\n\t\t\tmx[x]=cx;\n\t\t\tcx++;\n\t\t}\n\t\tif(my.find(y)==my.end()){\n\t\t\tmy[y]=cy;\n\t\t\tcy++;\n\t\t}\n\t\ta[mx[x]].push_back(i);\n\t\tb[my[y]].push_back(i);\n\t}\n\tfor(int i=0;i<n;i++) for(int j=1;j<a[i].size();j++) uft.Unite(a[i][j],a[i][j-1]);\n\tfor(int i=0;i<n;i++) for(int j=1;j<b[i].size();j++) uft.Unite(b[i][j],b[i][j-1]);\n\tvi used(n);\n\tint res=n-3;\n\tfor(int i=0;i<n;i++){\n\t\tint p=uft.Find_Par(i);\n\t\tif(!used[p]){\n\t\t\tused[p]=1;\n\t\t\tres+=2;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint check(const Edges& ve, const vector<int>& id, int len, const vector<bool> &cond, int n) {\n  auto tmp = ve;\n  int cnt = 0;\n  FOR(i,1,len+1) {\n    if (id[i] >= 0) {\n      tmp.push_back((Edge){id[i], n+cnt, cond[i]});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  auto rve = kruskal(n+cnt,tmp);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) return sum;\n  else return INF;\n}\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  vector<int> ix(w+1,-1);\n  vector<bool> ixx(w+1);\n  vector<bool> ixn(w+1);\n  vector<int> iy(h+1,-1);\n  vector<bool> iyx(h+1);\n  vector<bool> iyn(h+1);\n  Edges ve;\n  REP(i,n) {\n    int x,y;\n    cin>>x>>y;\n    if (ix[x] == -1) {\n      ix[x] = i;\n      ixx[x] = y == h;\n      ixn[x] = y == 0;\n    } else {\n      ixx[x] = ixx[x] || y == h;\n      ixn[x] = ixn[x] || y == 0;\n      ve.push_back((Edge){i, ix[x], 1});\n    }\n    if (iy[y] == -1) {\n      iy[y] = i;\n      iyx[y] = x == w;\n      iyn[y] = x == 0;\n    } else {\n      iyx[y] = iyx[y] || x == w;\n      iyn[y] = iyn[y] || x == 0;\n      ve.push_back((Edge){i, iy[y], 1});\n    }\n  }\n  int res = INF;\n  auto rve = kruskal(n,ve);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n-1) res = min(res, sum);\n  res = min(res, check(ve, ix, w, ixn, n));\n  res = min(res, check(ve, ix, w, ixx, n));\n  res = min(res, check(ve, iy, h, iyn, n));\n  res = min(res, check(ve, iy, h, iyx, n));\n  /*\n  auto tmp = ve;\n  int cnt = 0;\n  FOR(x,1,w+1) {\n    if (ix[x] >= 0) {\n      tmp.push_back((Edge){ix[x], n+cnt, (ixn[x]>1)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(x,1,w+1) {\n    if (ix[x] >= 0) {\n      tmp.push_back((Edge){ix[x], n+cnt, (ixx[x]<h)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(y,1,h+1) {\n    if (iy[y] >= 0) {\n      tmp.push_back((Edge){iy[y], n+cnt, (iyn[y]>1)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt, tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(y,1,h+1) {\n    if (iy[y] >= 0) {\n      tmp.push_back((Edge){iy[y], n+cnt, (iyx[y]<w)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  */\n  cerr << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll calc(vector<vector<ll>>& G,ll x){\n    ll ret = 0;\n    ll cnt = 0;\n    for(int i = 0; i < G.size(); i++){\n        if(G[i].empty()) continue;\n        cnt++;\n        if(G[i][0] == x){\n            ret += G[i].size() - 1;\n        }else{\n            ret += G[i].size();\n        }\n    }\n    cnt--;\n    ret += (cnt==0?-1:cnt);\n    return ret;\n}\nll solve(){\n    ll res = LINF;\n    ll N,W,H; cin >> N >> W >> H;\n    vector<ll> x(N),y(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i];\n    \n    vector<vector<ll>> wG(W+2),hG(H+2);\n    for(int i = 0; i < N;i++){\n        wG[x[i]].push_back(y[i]);\n        hG[y[i]].push_back(x[i]);\n    }\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end());\n    res = min({res,calc(wG,1),calc(hG,1)});\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end(),greater<ll>());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end(),greater<ll>());\n    res = min({res,calc(wG,H),calc(hG,W)});\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res * 100 << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntemplate<int um> class UF { // from kmjp\npublic:\n\tvector<int> par;\n\tUF() { par = vector<int>(um, 0); rep(i, 0, um) par[i] = i; }\n\tint operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n\tvoid operator()(int x, int y)\n\t{\n\t\tx = operator[](x); y = operator[](y);\n\t\tif (x != y) par[x] = y;\n\t}\n};\n//-----------------------------------------------------------------\nint N, W, H;\nint X[40101], Y[40101];\nUF<40101> uf;\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> W >> H;\n\trep(i, 0, N) cin >> X[i] >> Y[i];\n\n\trep(i, 0, N) rep(j, i + 1, N) if (X[i] == X[j] || Y[i] == Y[j]) {\n\t\tif ((X[i] == 1 || X[i] == W) || (Y[i] == 1 || Y[i] == H))\n\t\t\tuf(j, i);\n\t\telse\n\t\t\tuf(i, j);\n\t}\n\n\tbool isWall = false;\n\tint ans = 0;\n\trep(i, 0, N) if (uf[i] == i) {\n\t\tans++;\n\t\tif ((X[i] == 1 || X[i] == W) || (Y[i] == 1 || Y[i] == H)) isWall = true;\n\t}\n\n\tif (ans == 1)\n\t\tans = N - 1;\n\telse {\n\t\tif (isWall) ans--;\n\t\tans += N - 1;\n\t}\t\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nint uf[40001];\n\nint find(int n){\n  if(uf[n]==n) return n;\n  else return uf[n]=find(uf[n]);\n}\n\nvoid uni(int m,int n){\n  uf[find(m)]=find(n);\n  return;\n}\n\nint main(){\n  int n,w,h;\n  cin >> n >> w >> h;\n  map<int,int> xset,yset;\n  bool kabeflag=false;\n  for(int i=0;i<=n;i++){\n    uf[i]=i;\n  }\n  int x,y;\n  for(int i=1;i<=n;i++){\n    cin >> x >> y;\n    if(x==1||x==w||y==1||y==h){\n      kabeflag=true;\n    }\n    if(xset[x]){\n      uni(i,xset[x]);\n    }else{\n      xset[x]=i;\n    }\n    if(yset[y]){\n      uni(i,yset[y]);\n    }else{\n      yset[y]=i;\n    }\n  }\n  vector<int> isroot(n+1,0);\n  for(int i=1;i<=n;i++){\n    isroot[find(i)]=1;\n  }\n  int count=0;\n  vector<int> hasi(4,0);\n  for(int i=1;i<=n;i++){\n    count+=isroot[i];\n  }\n  if(count==1){\n    cout << n-1 << endl;\n  }else{\n    if(kabeflag){\n      cout << n-1+count-1 << endl;\n    }else{\n      cout << n-1+count << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n\nclass unionfind {\nprivate:\n\tint size_;\n\tstd::vector<int> parent;\n\tstd::vector<int> rank;\npublic:\n\tunionfind() : size_(0), parent(std::vector<int>()), rank(std::vector<int>()) {};\n\tunionfind(int size__) : size_(size__), parent(std::vector<int>(size_)), rank(std::vector<int>(size_, 0)) {\n\t\tstd::iota(parent.begin(), parent.end(), 0);\n\t}\n\tint size() { return size_; }\n\tint root(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = root(parent[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) parent[x] = y;\n\t\telse if (rank[x] > rank[y]) parent[y] = x;\n\t\telse parent[y] = x, rank[x]++;\n\t}\n};\n\nint W, H, N, x[40009], y[40009], tx[100009], ty[100009], cnt[40009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &W, &H);\n\tfill(tx, tx + W, -1);\n\tfill(ty, ty + H, -1);\n\tbool flag = false;\n\tunionfind uf(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]); x[i]--, y[i]--;\n\t\tif (x[i] == 0 || y[i] == 0 || x[i] == W - 1 && y[i] == H - 1) flag = true;\n\t\tif (tx[x[i]] != -1) uf.unite(tx[x[i]], i); tx[x[i]] = i;\n\t\tif (ty[y[i]] != -1) uf.unite(ty[y[i]], i); ty[y[i]] = i;\n\t}\n\tfor (int i = 0; i < N; i++) cnt[uf.root(i)]++;\n\tint comp = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (cnt[i]) comp++;\n\t}\n\tint ret = N + comp - 1;\n\tif (comp == 1 || flag) ret--;\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint a, b, H, W, N, used[100009], c, d; vector<int>x[50009];\nvector<pair<int, int>>X[100009], Y[100009];\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < N; i++) { cin >> a >> b; if (a == 1 || b == 1 || a == H || b == W)d = 1; X[a].push_back(make_pair(b, i)); X[b].push_back(make_pair(a, i)); }\n\tfor (int i = 0; i < 100009; i++) {\n\t\tsort(X[i].begin(), X[i].end()); sort(Y[i].begin(), Y[i].end());\n\t\tfor (int j = 0; j < (int)X[i].size() - 1; j++) { x[X[i][j].second].push_back(X[i][j + 1].second); x[X[i][j + 1].second].push_back(X[i][j].second); }\n\t\tfor (int j = 0; j < (int)Y[i].size() - 1; j++) { x[Y[i][j].second].push_back(Y[i][j + 1].second); x[Y[i][j + 1].second].push_back(Y[i][j].second); }\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (used[i] == true)continue;\n\t\tqueue<int>Q; Q.push(i); used[i] = true;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tfor (int j : x[a1]) { if (used[j] == false) { used[j] = true; Q.push(j); } }\n\t\t}\n\t\tc++;\n\t}\n\tif (c == 1)d = 1;\n\tcout << (N - 1) + (c - d) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nstruct UnionFind{\n\tvector<int> par, sz;\n\tUnionFind(int n){\n\t\tpar = sz = vector<int>(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, sz[i] = 1;\n\t}\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x){\n\t\treturn sz[find(x)];\n\t}\n};\n\nbool cmp(const tuple<int, int, int> &a, const tuple<int, int, int> &b){\n\treturn get<1>(a) < get<1>(b);\n}\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\n\tvector<tuple<int, int, int>> v(n);\n\n\tbool edge = false;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv[i] = MT(x, y, i);\n\t\tif (x == w || y == h) edge = true;\n\t}\n\n\tUnionFind uf(n);\n\n\tsort(ALL(v));\n\trep(i, n - 1) if (get<0>(v[i]) == get<0>(v[i + 1])) uf.unite(get<2>(v[i]), get<2>(v[i]) + 1);\n\tsort(ALL(v), cmp);\n\trep(i, n - 1) if (get<1>(v[i]) == get<1>(v[i + 1])) uf.unite(get<2>(v[i]), get<2>(v[i]) + 1);\n\n\tset<int> st;\n\trep(i, n) st.insert(uf.find(i));\n\n\tint mv = st.size();\n\tif (mv == 1 || edge) --mv;\n\n\tcout << n + mv - 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Rank_Union_Find\n#define ___Rank_Union_Find\n\n#include <vector>\n\n// ------ Class ------ //\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, H, W, x, y, c[40009]; vector<int> tx[100009], ty[100009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &W, &H);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttx[x].push_back(i);\n\t\tty[y].push_back(i);\n\t}\n\tUnionFind Q(N);\n\tfor (int i = 1; i <= W; i++) {\n\t\tfor (int j = 1; j < tx[i].size(); j++) Q.unite(tx[i][0], tx[i][j]);\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j < ty[i].size(); j++) Q.unite(ty[i][0], ty[i][j]);\n\t}\n\tfor (int i = 0; i < N; i++) c[Q.root(i)]++;\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) if (c[i] >= 1) cnt++;\n\tprintf(\"%d\\n\", N + cnt - 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint par[40000];\nint bit[40000];\nint xx[100001],yy[100001];\nbool bx[100001],by[100001];\n\nint find(int x){\n  return (x==par[x])?x:par[x]=find(par[x]);\n}\n\nvoid unite(int a,int b){\n  int r=find(a);\n  bit[r]|=bit[find(b)];\n  par[find(b)]=r;\n}\n\nint main(){\n  int N,W,H;\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    par[i]=i;\n    int x,y;\n    cin>>x>>y;\n    bit[i]=(x==1)|(x==W)<<1|(y==1)<<2|(y==H)<<3;\n    if(!bx[x]++){\n      xx[x]=i;\n    }else{\n      unite(xx[x],i);\n    }\n    if(!by[y]++){\n      yy[y]=i;\n    }else{\n      unite(yy[y],i);\n    }\n  }\n  int ans=N*2;\n  for(int i=0;i<4;i++){\n    int p=0,c=0;\n    for(int j=0;j<N;j++){\n      if(find(j)==j){\n\tp++;\n\tc+=bit[j]>>i&1^1;\n      }\n    }\n    ans=min(ans,(p==1)?N-1:c+N-1);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool uni(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x == y) return false;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n  int root(int x){\n    if(data[x] < 0) return x;\n    return data[x] = root(data[x]);\n  }\n};\n\nint main(){\n  int N, W, H;\n  while(cin >> N >> W >> H){\n    int id_x[100001];\n    int id_y[100001];\n    memset(id_x, -1, sizeof id_x);\n    memset(id_y, -1, sizeof id_y);\n    UnionFind uf(N);\n    bool wall = false;\n    int cnt = N;\n    REP(i, N){\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      if(x == 1 || x == W) wall = true;\n      if(y == 1 || y == H) wall = true;\n      if(id_x[x] == -1) id_x[x] = i;\n      if(id_y[y] == -1) id_y[y] = i;\n      if(uf.uni(i, id_x[x])) cnt--;\n      if(uf.uni(i, id_y[y])) cnt--;\n    }\n    int ans = N - cnt;\n    if(cnt > 1){\n      if(!wall) ans++;\n      ans += 2 * (cnt - 1);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\nclass UnionFind {\n    vector<int> p;//p[i]はiの属する組織\n    vector<int> sz;\n\npublic:\n    vector<int> wall; //壁の上下左右どこにくっついているか\n    UnionFind(int n) {\n        p.resize(n);\n        sz.resize(n);\n        wall.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n/* xの属する集合を返す */\n    int find(int x) {\n        if (p[x] == x) return x;\n        return p[x] = find(p[x]);\n    }\n\n/* yにxを統合する */\n    void unite(int x, int y) {\n        sz[find(y)] += sz[find(x)];\n        sz[find(x)] = 0;\n        wall[find(y)] |= wall[find(x)];\n        p[find(x)] = p[find(y)];\n    }\n\n/* xとyが属する集合が同じかを判定する */\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n/* xに属する集合のサイズを求める */\n    int size(int x) {\n        return sz[find(x)];\n    }\n};\n\n\nvoid solve() {\n    ll N, W, H;\n    cin >> N >> W >> H;\n    UnionFind uf(N);\n    struct slime {\n        ll id, x, y;\n    };\n    vector<slime> sl(N);\n\n    REP(i, N) {\n        cin >> sl[i].x >> sl[i].y;\n        sl[i].id = i;\n        if (sl[i].x == 1) {\n            uf.wall[i] |= 1;\n        }\n\n        if (sl[i].x == W) {\n            uf.wall[i] |= 1 << 1;\n        }\n\n        if (sl[i].y == 1) {\n            uf.wall[i] |= 1 << 2;\n        }\n\n        if (sl[i].y == H) {\n            uf.wall[i] |= 1 << 3;\n        }\n    }\n\n    sort(all(sl), [](auto l, auto r) {\n        return l.x < r.x;\n    });\n\n    REP(i, N - 1) {\n        if (sl[i].x == sl[i + 1].x) {\n            if (!uf.same(sl[i].id, sl[i + 1].id)) {\n                uf.unite(sl[i].id, sl[i + 1].id);\n            }\n        }\n    }\n\n    sort(all(sl), [](auto l, auto r) {\n        return l.y < r.y;\n    });\n\n    REP(i, N - 1) {\n        if (sl[i].y == sl[i + 1].y) {\n            if (!uf.same(sl[i].id, sl[i + 1].id)) {\n                uf.unite(sl[i].id, sl[i + 1].id);\n            }\n        }\n    }\n\n\n    ll ans = LINF;\n    vector<ll> dec(4, 0);\n    REP(i, N) {\n        if (i == uf.find(i)) {\n            REP(k, 4) {\n                dec[k]++;\n                if (uf.wall[uf.find(i)] >> k & 1) {\n                    dec[k]--;\n                }\n            }\n        }\n\n\n    }\n    REP(k, 4) {\n        chmin(ans, N - 1 + dec[k]);\n    }\n    if (uf.size(0) == N) {\n        chmin(ans, N - 1);\n    }\n    cout << ans << endl;\n\n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tint n;\n\tvector<int> a;\npublic:\n\tunion_find(int N):a(N,-1),n(N){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; n--; }\n\t}\n\tint size(){ return n; }\n};\n\nstruct slime{ int x,y,id; };\n\nint main(){\n\tint n,w,h; scanf(\"%d%d%d\",&n,&w,&h);\n\tstatic slime s[40000];\n\trep(i,n) scanf(\"%d%d\",&s[i].x,&s[i].y), s[i].x--, s[i].y--, s[i].id=i;\n\n\tstatic vector<slime> X[100000],Y[100000];\n\trep(i,n){\n\t\tX[s[i].x].push_back(s[i]);\n\t\tY[s[i].y].push_back(s[i]);\n\t}\n\n\tunion_find U(n);\n\trep(j,w) rep(k,(int)X[j].size()-1) U.unite(X[j][k].id,X[j][k+1].id);\n\trep(i,h) rep(k,(int)Y[i].size()-1) U.unite(Y[i][k].id,Y[i][k+1].id);\n\n\tbool corner=false;\n\trep(i,n) if(s[i].x==0 || s[i].x==w-1 || s[i].y==0 || s[i].y==h-1) corner=true;\n\n\tint ans=0;\n\tans+=n-U.size(); // 1 回の移動で合体できるスライムたちをまとめる\n\tif(U.size()>=2){\n\t\tans+=2*U.size()-1; // どこかの外壁に並べる\n\t\tif(corner) ans--;\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 40005;\n\nint x[MAX_N],y[MAX_N];\nint n,w,h;\nbool flag[MAX_N];\nvector<int> X[100002],Y[100002];\nvector<int> G[MAX_N];\n\nvoid dfs(int u,bool& hoge)\n{\n    flag[u] = true;\n    if(x[u] == 0 || x[u] == h-1 || y[u] == 0 || y[u] == w-1){\n        hoge = true;\n    }\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],hoge);\n        }\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n        x[i]--,y[i]--;\n        X[x[i]].push_back(i);\n        Y[y[i]].push_back(i);\n\t}\n    rep(i,w){\n        rep(j,Y[i].size()){\n            rep(k,Y[i].size()){\n                if(k != j){\n                    G[Y[i][j]].push_back(Y[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,X[i].size()){\n            rep(k,X[i].size()){\n                if(k != j){\n                    G[X[i][j]].push_back(X[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    int cnt = 0;\n    int pl = 0;\n    bool wall = false;\n    rep(i,n){\n        if(!flag[i]){\n            cnt++;\n            dfs(i,wall);\n        }\n    }\n    if(wall){\n        pl = 1;\n    }\n    printf(\"%d\\n\",n-cnt+2*cnt-1+pl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, w, h;\nvector<int> xIndex[100010];\nvector<int> yIndex[100010];\nint xs[100010];\nint ys[100010];\nbool visit[100010];\n\nint main() {\n  while (scanf(\"%d %d %d\", &n, &w, &h) > 0) {\n    MEMSET(visit, false);\n    REP(i, 100010) { xIndex[i].clear(); yIndex[i].clear(); }\n    int edge = 0;\n    int ans = n - 2;\n    REP(i, n) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      if (x == 1 || x == w || y == 1 || y == h) { edge = 1; }\n      x--; y--;\n      xs[i] = x; ys[i] = y;\n      xIndex[x].push_back(i);\n      yIndex[y].push_back(i);\n    }\n    REP(i, n) {\n      if (visit[i]) { continue; }\n      visit[i] = true;\n      ans++;\n      queue<int> que;\n      que.push(i);\n      while (!que.empty()) {\n        int index = que.front();\n        que.pop();\n        FORIT(it, xIndex[xs[index]]) {\n          if (visit[*it]) { continue; }\n          visit[*it] = true;\n          que.push(*it);\n        }\n        FORIT(it, yIndex[ys[index]]) {\n          if (visit[*it]) { continue; }\n          visit[*it] = true;\n          que.push(*it);\n        }\n      }\n    }\n    if (ans != n - 1 && !edge) { ans++; }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct input{input(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\nnamespace _UF{\n    #define SZ 500000\n    int mem[2][SZ];\n}\nclass UnionFind{\nprivate:\n    int *par,*rank;\n    int find(int x){\n\tif(par[x]==x)return x;\n\telse return par[x]=find(par[x]);\n    }\npublic:\n    UnionFind(int n):par(_UF::mem[0]),rank(_UF::mem[1]){\n\trep(i,n)par[i]=i,rank[i]=0;\n    }\n    bool unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return false;\n\tif(rank[x]<rank[y])par[x]=y;\n\telse{\n\t    par[y]=x;\n\t    if(rank[x]==rank[y])rank[x]++;\n\t}\n\treturn true;\n    }\n    bool same(int x,int y){\n\treturn find(x)==find(y);\n    }\n};\n\nint main(){\n    int N,C,R;\n    cin>>N>>C>>R;\n    map<int,int> rs,cs;\n    int bottom=1;\n    int res=0;\n    UnionFind uf(N);\n    rep(i,N){\n\tint r,c;\n\tcin>>c>>r;\n\tif(rs.count(r))\n\t    res+=uf.unite(rs[r],i);\n\telse rs[r]=i;\n\tif(cs.count(c))\n\t    res+=uf.unite(cs[c],i);\n\telse cs[c]=i;\n\tbottom=min({bottom,r-1,c-1,R-r,C-c});\n    }\n    if(res==N-1)cout<<res<<endl;\n    else{\n\tres+=(bottom>0);\n\trep(i,N)\n\t    if(!uf.same(0,i)){\n\t\tres+=2;\n\t\tuf.unite(0,i);\n\t    }\n\tcout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int x, int y) : x(x), y(y) {}\n};\nbool operator<(const Point& a, const Point& b) {\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nistream& operator>>(istream& is, Point& p) {\n    return is >> p.x >> p.y;\n}\nostream& operator<<(ostream& os, const Point& p) {\n    return os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs) {\n    if (xs.empty()) return os << \"[]\";\n    os << \"[\" << xs[0];\n    for (int i = 1; i < xs.size(); i++) os << \" \" << xs[i];\n    return os << \"]\";\n}\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nstruct UnionFind {\n    int N;\n    vector<int> P;\n    UnionFind(int N) : N(N) {\n        P.clear(); P.resize(N, -1);\n    }\n    int root(int x) {\n        if (P[x] == -1) return x;\n        return P[x] = root(P[x]);\n    }\n    int query(int x, int y) {\n        return root(x) == root(y);\n    }\n    void merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return;\n        P[x] = y;\n    }\n    int count() {\n        vector<bool> u(N, false);\n        int ret = 0;\n        for (int i = 0; i < N; i++) {\n            if (u[root(i)]) continue;\n            u[root(i)] = true;\n            ret++;\n        }\n        return ret;\n    }\n};\n\nint N, W, H;\nvector<Point> P;\nint main() {\n    cin >> N >> W >> H;\n    P.clear(); P.resize(N);\n    for (int i = 0; i < N; i++) cin >> P[i];\n\n    UnionFind uf(N);\n    int ans = 0;\n\n    bool f = false;\n    map<int, int> M;\n    for (int i = 0; i < N; i++) {\n        const Point& p = P[i];\n        if (M.count(p.x)) {\n            uf.merge(i, M[p.x]);\n            ans++;\n        } else {\n            M[p.x] = i;\n        }\n        if (p.x == 1 || p.x == W) f = true;\n    }\n    M.clear();\n    for (int i = 0; i < N; i++) {\n        const Point& p = P[i];\n        if (M.count(p.y)) {\n            if (uf.query(i, M[p.y])) continue;\n            uf.merge(i, M[p.y]);\n            ans++;\n        } else {\n            M[p.y] = uf.root(i);\n        }\n        if (p.y == 1 || p.y == H) f = true;\n    }\n\n    if (uf.count() == 1) {\n        cout << ans << endl;\n    } else {\n        ans--;\n        if (f) ans--;\n        vector<bool> u(N, false);\n        for (int i = 0; i < N; i++) {\n            if (u[uf.root(i)]) continue;\n            u[uf.root(i)] = true;\n            ans += 2;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\ntypedef pair<int,int> P;\nint n,h,w;\n\nstruct unionFind{\n  unionFind(int n){\n    init(n);\n  }\n  vector<int> par,size;\n  int grup;\n  void init(int n){\n    grup=n;\n    par.resize(n);\n    size.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x]=find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n    if(size[x]<size[y]) swap(x,y);\n    par[y] = x;\n    size[x]+=size[y];\n    grup--;\n  }\n  bool same(int x,int y){return find(x) == find(y);}\n  int getg(){return grup;}\n};\n\nP mp[100000];\nmap<int,vector<int> > xx;\nmap<int,vector<int> > yy;\nint main(){\n  cin>>n>>w>>h;\n  bool f;\n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    mp[i]=P(x,y);\n    if(x==1 || y==1 || x==w || y==h) f=1;\n    xx[x].push_back(i);\n    yy[y].push_back(i);\n  }\n  unionFind u(n);\n  \n  map<int,vector<int> >::iterator it;\n  for(it=xx.begin();it!=xx.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  for(it=yy.begin();it!=yy.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  int cnt=u.getg();\n  if(cnt==1) cout<<n-cnt<<endl;\n  else cout<<n+cnt-1-f<<endl;     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 40001;\nconst int INF = 1<<28;\nint N;\nint X[MAXN], Y[MAXN];\nbool vis[MAXN];\nvector<pair<pair<int,int>,int> > xy, yx;\n\nint dfs(int v) {\n  const int &x = X[v];\n  const int &y = Y[v];\n  vis[v] = true;\n  int res = 1;\n  int begin, end;\n  begin =\n    lower_bound(xy.begin(), xy.end(), make_pair(make_pair(x,-INF),-INF))\n    - xy.begin();\n  end =\n    upper_bound(xy.begin(), xy.end(), make_pair(make_pair(x, INF), INF))\n    - xy.begin();\n  for(int i = begin; i < end; ++i) {\n    int nv = xy[i].second;\n    if(!vis[nv]) {\n      res += dfs(nv);\n    }\n  }\n\n  begin =\n    lower_bound(yx.begin(), yx.end(), make_pair(make_pair(y,-INF),-INF))\n    - yx.begin();\n  end =\n    upper_bound(yx.begin(), yx.end(), make_pair(make_pair(y, INF), INF))\n    - yx.begin();\n  for(int i = begin; i < end; ++i) {\n    int nv = yx[i].second;\n    if(!vis[nv]) {\n      res += dfs(nv);\n    }\n  }\n\n  return res;\n}\n\nint main() {\n  int h, w;\n  cin >> N >> h >> w;\n  bool kabegiwa = false;\n  for(int i = 0; i < N; ++i) {\n    int &x = X[i];\n    int &y = Y[i];\n    cin >> x >> y;\n    xy.push_back(make_pair(make_pair(x,y),i));\n    yx.push_back(make_pair(make_pair(y,x),i));\n    if(x == 1 || x == w || y == 1 || y == h) {\n      kabegiwa = true;\n    }\n  }\n  sort(xy.begin(), xy.end());\n  sort(yx.begin(), yx.end());\n  fill(vis, vis+N, false);\n  int num = 0;\n  int ans = 0;\n  for(int i = 0; i < N; ++i) {\n    if(!vis[i]) {\n      ++num;\n      ans += dfs(i) - 1;\n    }\n  }\n  if(num != 1) {\n    ans += (num-1) * 2 + !kabegiwa;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll calc(vector<vector<ll>>& G,ll x){\n    ll ret = 0;\n    ll cnt = 0;\n    \n    for(int i = 0; i < G.size();i++){\n        if(G[i].empty()) continue;\n        cnt++;\n    }\n    if(cnt == 1){\n        for(int i = 0; i < G.size();i++){\n            if(G[i].empty()) continue;\n            return ret = G[i].size()-1;\n        }\n    }\n    for(int i = 0; i < G.size(); i++){\n        if(G[i].empty()) continue;\n        cnt++;\n        if(G[i][0] == x){\n            ret += G[i].size() - 1;\n        }else{\n            ret += G[i].size();\n        }\n    }\n  //  cout << ret << \" \" << cnt << endl;\n    ret += (cnt-1);\n    return ret;\n}\nll solve(){\n    ll res = LINF;\n    ll N,W,H; cin >> N >> W >> H;\n    vector<ll> x(N),y(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i];\n    \n    vector<vector<ll>> wG(W+2),hG(H+2);\n    for(int i = 0; i < N;i++){\n        wG[x[i]].push_back(y[i]);\n        hG[y[i]].push_back(x[i]);\n    }\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end());\n    res = min({res,calc(wG,1),calc(hG,1)});\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end(),greater<ll>());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end(),greater<ll>());\n    res = min({res,calc(wG,H),calc(hG,W)});\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n,h,w;\nvector<P> ah[100001],aw[100001];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>w>>h;\n  UnionFind uf(n);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x--; y--;\n    ah[y].push_back(P(x,i)); \n    aw[x].push_back(P(y,i));\n  }\n  rep(i,h){\n    rep(j,ah[i].size()-1){\n      uf.unite(ah[i][j].se,ah[i][j+1].se);\n    }\n  }\n  rep(i,w){\n    rep(j,aw[i].size()-1){\n      uf.unite(aw[i][j].se,aw[i][j+1].se);\n    }\n  }\n  if(uf.size(0)==n){\n    cout<<n-1<<endl;\n    return 0;\n  }\n  int res=INF;\n  {\n    int cnt=0,cnt1=0,cnt2=0,sum=0;\n    rep(i,h){\n      if(ah[i].size()==0)continue;\n      if(ah[i][0].fi==0)cnt1++;\n      if(ah[i][ah[i].size()-1].fi==w-1)cnt2++;\n      cnt++;\n      sum+=ah[i].size();\n    }\n    minch(res,min(sum+cnt-1-cnt1,sum+cnt-1-cnt2));\n  }\n  {\n    int cnt=0,cnt1=0,cnt2=0,sum=0;\n    rep(i,w){\n      if(aw[i].size()==0)continue;\n      if(aw[i][0].fi==0)cnt1++;\n      if(aw[i][aw[i].size()-1].fi==h-1)cnt2++;\n      cnt++;\n      sum+=aw[i].size();\n    }\n    minch(res,min(sum+cnt-1-cnt1,sum+cnt-1-cnt2));\n  }\n  cout<<res<<endl;\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i < 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct UF {\n\tvector<int> data;\n\tUF(int size) : data(size, -1) { }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,h,w;cin>>n>>h>>w;\n    vector<P> pos(n);\n    int wall=0;\n    for(int i=0;i<n;i++){\n        int x,y;cin>>x>>y;\n        pos[i]=P(x,y);\n        if(x==1 || x==h || y==1 || y==w) wall=1;\n    }\n    UF uf(n);\n    for(int i=0;i<n;i++){\n        for(int j=1;j<n;j++){\n            if(pos[i].first==pos[j].first || pos[i].second==pos[j].second) uf.unite(i,j);\n        }\n    }\n    set<int> st;\n    for(int i=0;i<n;i++){\n        int r=uf.root(i);\n        st.insert(r);\n    }\n    int sz=st.size();\n    if(sz==1) cout<<n-1<<endl;\n    else{\n        cout<<n-1+sz-wall<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint n,h,w;\nvector<P> ah[100001],aw[100001];\nset<int> ps,hs[4];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>w>>h;\n  UnionFind uf(n);\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    x--; y--;\n    ah[y].push_back(P(x,i)); \n    aw[x].push_back(P(y,i));\n  }\n  rep(i,h){\n    rep(j,ah[i].size()-1){\n      uf.unite(ah[i][j].se,ah[i][j+1].se);\n    }\n  }\n  rep(i,w){\n    rep(j,aw[i].size()-1){\n      uf.unite(aw[i][j].se,aw[i][j+1].se);\n    }\n  }\n  if(uf.size(0)==n){\n    cout<<n-1<<endl;\n    return 0;\n  }\n  rep(i,h){\n    rep(j,ah[i].size()){\n      ps.insert(uf.find(ah[i][j].se));\n      if(ah[i][j].fi==0)hs[0].insert(uf.find(ah[i][j].se));\n      if(ah[i][j].fi==h-1)hs[1].insert(uf.find(ah[i][j].se));\n    }\n  }\n\n  rep(i,w){\n    rep(j,aw[i].size()){\n      ps.insert(uf.find(aw[i][j].se));\n      if(aw[i][j].fi==0)hs[2].insert(uf.find(aw[i][j].se));\n      if(aw[i][j].fi==w-1)hs[3].insert(uf.find(aw[i][j].se));\n    }\n  }\n  int res=INF;\n  int sum=0;\n  each(it,ps){\n    sum+=uf.size(it)-1;\n  }\n  rep(k,4){\n    minch(res,sum+ps.size()*2-1-hs[k].size());\n  }\n  cout<<res<<endl;\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\n\nint calc(const vector<P>& ps, int L){\n  map<int, vector<P> > m;\n  REP(i, ps.size()) m[ps[i].first].push_back(ps[i]);\n  int res = m.size() - 1;\n  FORIT(it, m){\n    vector<P>& pv = it->second;\n    if(binary_search(pv.begin(), pv.end(), P(it->first, L)) || m.size() == 1){\n      res += pv.size() - 1;\n    }else{\n      res += pv.size();\n    }\n    \n  }\n  return res;\n}\n\nint main(){\n  int N, W, H;\n  while(cin >> N >> W >> H){\n    vector<P> ps(N);\n    REP(i, N) cin >> ps[i].first >> ps[i].second;\n    int ans = INF;\n    ans = min(ans, calc(ps, 1));\n    ans = min(ans, calc(ps, H));\n    REP(i, N) swap(ps[i].first, ps[i].second);\n    ans = min(ans, calc(ps, 1));\n    ans = min(ans, calc(ps, W));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 同じ十字上にあるk個のスライムはk-1手でk個のうち任意のスライムの位置にまとめられる\n// unionfindで同一直線上にあるスライムをuniteしていって a) Σ(グループのサイズ-1) に\n// b) 各グループ(をまとめた点)を全て4辺どれかに寄せてからまとめるのにかかるコスト を足したものが答え\n// bはグループがp(>=2)個あったとして、点n個のうち1個でも4辺に接してる点があれば2p-2 なければ2p-1\n\nstruct UF {\n\tvector<int> p;\n\tUF(int n) : p(n, -1) {};\n\tbool unite(int u, int v) {\n\t\tu = find(u), v = find(v);\n\t\tif (u==v) return false;\n\t\tif (p[u] > p[v]) swap(u,v);\n\t\tp[u] += p[v]; p[v] = u;\n\t\treturn true;\n\t}\n\tbool same(int u, int v) { return find(u) == find(v); }\n\tint find(int u) { return p[u] < 0 ? u : p[u] = find(p[u]); }\n\tint usize(int u) { return -p[find(u)]; }\n};\n\nint n, h, w, x[40040], y[40040], ok;\nvi xx[100100], yy[100100], r;\nUF uf(40040);\n\nsigned main() {\n\tcin >> n >> h >> w;\n\trep(i,n) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--, y[i]--;\n\t\tif (x[i]==0 || x[i]==h-1 || y[i]==0 || y[i]==w-1) ok = 1;\n\t\txx[x[i]].pb(i), yy[y[i]].pb(i);\n\t}\n\trep(i,100000) {\n\t\trep(j,(int)xx[i].size()-1) uf.unite(xx[i][j], xx[i][j+1]);\n\t\trep(j,(int)yy[i].size()-1) uf.unite(yy[i][j], yy[i][j+1]);\n\t}\n\trep(i,n) r.pb(uf.find(i));\n\tunq(r);\n\tint res = (r.size()==1 ? 0 : r.size()*2-1-ok);\n\trep(i,r.size()) res += uf.usize(r[i]) - 1;\n\tcout << res << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint N;\nint W,H;\nvector<int> Y[100005];\nvector<int> T[100005];\n\n\nstruct uni {\n  int d[ 50000 ];\n  void init(){ memset( d,-1,sizeof( d ) ); }\n  int find( int a ) { return d[a]<0?a:(d[a] = find( d[a] )); }\n  void merge( int a,int b ){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap( a, b );\n    d[a] += d[b]; d[b] = a;\n  }\n  int size(int a){ return -d[find(a)]; }\n};\n\nuni U;\nbool used[ 50000 ];\nint main(){\n  cin >> N >> W >> H;\n  int hj = 0;\n  for(int i=0;i<N;i++){\n    int x,y; cin >> x >> y;\n    if( x == 1 || x == W || y == 1 || y == H ) hj=1;\n    Y[ y ].push_back( i );\n    T[ x ].push_back( i );\n  }\n  \n  U.init();\n  for(int i=1;i<=W;i++) {\n    for(int j=1;j<(int)T[i].size();j++)\n      U.merge( T[i][j-1], T[i][j] );\n  }\n  for(int i=1;i<=H;i++)\n    for(int j=1;j<(int)Y[i].size();j++)\n      U.merge( Y[i][j-1], Y[i][j] );\n\n\n  int cnt = 0;\n  int res = 0;\n  for(int i=0;i<N;i++){\n    int a = U.find( i );\n    if( used[ a ] ) continue;\n    used[ a ] = true;\n    res += U.size( a )-1;\n    cnt++;\n  }\n  if( cnt == 1 ) cout << res << endl;\n  else cout << res + cnt + cnt-1 - hj << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint uni[100000],r[100000];\nint find(int a){\n  if(a!=uni[a])a=find(uni[a]);\n  return a;\n}\nbool same(int a,int b){\n  return find(a)==find(b);\n}\nvoid unit(int a,int b){\n  int c=find(a),d=find(b);\n  if(r[c]>r[d])uni[d]=c;\n  else{uni[c]=d;\n    if(r[c]==r[d])r[c]++;\n  }\n}\nint ans,n,w,h,sum,c,y[100000],x[100000];\nbool used[100000];\nint main(){\n  cin>>n>>w>>h;\n  r(i,n)uni[i]=i,r[i]=0;\n  r(i,n)cin>>x[i]>>y[i];\n  r(i,n)r(j,n)if(x[i]==x[j]||y[i]==y[j])unit(i,j);\n  r(i,n)if(!used[i]){\n    int f=0;\n    used[i]=1;\n    for(int j=i;j<n;j++){\n      if(same(i,j)){//cout<<w<<h<<endl;\n        used[j]=1;\n        if(x[j]==1)f++;\n        else if(x[j]==w)f++;\n        else if(y[j]==1)f++;\n        else if(y[j]==h)f++;\n      }\n    }\n    if(f)sum=1;\n    c++;\n  }\n  if(c==1)cout<<n-1<<endl;\n  else cout<<n+c-1-sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    // x, y????????????\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    // x, y?????????????????????1\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // x??????????????????????????§???????????????\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // ?????¢??????????????????????????°?????????\n    int setNum(void) {\n        map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n    void print(void) {\n        auto c = getUnionList();\n        for (auto x : c) {\n            for (auto y : x) \n                cout << y << \" \";\n            cout << endl;\n        }\n    }\n};\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, nx, ny; cin >> n >> nx >> ny;\n    vector<P> s(n);\n    \n    vll rx(nx, -1), ry(ny, -1);\n    bool is_wall = 0;\n    rep(i, n) {\n        cin >> s[i].fi >> s[i].se; s[i].fi--; s[i].se--;\n        rx[s[i].fi] = ry[s[i].se] = i;\n        is_wall |= (s[i].fi == 0 || s[i].fi == nx-1 || s[i].se == 0 || s[i].se == ny-1);\n    }\n\n    UnionFind uf(n);\n    rep(i, n) {\n        uf.unite(i, rx[s[i].fi]);\n        uf.unite(i, ry[s[i].se]);\n    }\n\n    auto list = uf.getUnionList();\n    if (list.size() == 1) {\n        cout << (*list.begin()).size() - 1 << endl;\n        return 0;\n    }\n\n    ll ret = 0;\n    for (auto x : list) \n        ret += x.size() - 1;\n    cout << ret + 2 * list.size() - is_wall - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cstring>\n#include<set>\nusing namespace std;\nvoid init(int n);\nvoid unite(int x,int y);\nint find(int x);\nbool same(int x,int y);\n\nint par[200010]; // ???\nint rnk[200010]; // ??±???\n\n/* Union Find ????????? */\nvoid init(int n){\n  for(int i=0;i<=n;i++){\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n\n/* x???????????¨y?????????????????? */\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]){\n\t  par[x] = y;\n\t}\n\telse {\n\t  par[y] = x;\n\t}\n\tif(rnk[x] == rnk[y]) rnk[x]++;\n}\n\n/* x????????????????????¢?´¢ */\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  else {\n    return par[x] = find(par[x]);\n  }\n}\n\n/* x??¨y????????????????????????????????? */\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n\tint n,w,h;\n\tcin >> n >> w >> h;\n\tinit(n);\n\tint X[200000],Y[200000],wall = 0;\n\tmemset(X,-1,sizeof(X)); memset(Y,-1,sizeof(Y));\n\tfor(int i=0;i<n;i++){\n\t\tint x,y; cin >> x >> y;\n\t\twall |= (x==w) | (x==1) | (y==h) | (y==1);\n\t\tif(X[x] < 0) X[x] = i;\n\t\telse unite(i,X[x]);\n\t\tif(Y[y] < 0) Y[y] = i;\n\t\telse unite(i,Y[y]);\n\t}\n\tset<int> cnt;\n\tfor(int i=0;i<w+1;i++) if(X[i] >= 0) cnt.insert(find(X[i]));\n\tif(cnt.size() == 1) cout << n-1 << endl;\n\telse cout << n-1+(cnt.size()-wall) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge = false;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,w,h;\nint par[40001],rank[40001];\nint x[40001],y[40001];\nvector<int> xid[100001],yid[100001];\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(rank[x]>rank[y]){\n\t\tpar[y]=x;\n\t}else{\n\t\tif(rank[x]==rank[y]){\n\t\t\trank[y]++;\n\t\t}\n\t\tpar[x]=y;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(void){\n\tscanf(\"%d %d %d\",&n,&w,&h);\n\tbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\txid[x[i]].push_back(i);\n\t\tyid[y[i]].push_back(i);\n\t\tif(x[i]==w || x[i]==1 || y[i]==1 || y[i]==h)flag=true;\n\t}\n\tinit();\n\tint cnt=0;\n\tfor(int i=1;i<=w;i++){\n\t\tfor(int j=0;j<(int)xid[i].size()-1;j++){\n\t\t\tif(same(xid[i][j],xid[i][j+1]))continue;\n\t\t\tcnt++;\n\t\t\tunite(xid[i][j],xid[i][j+1]);\n\t\t}\n\t\tfor(int j=0;j<(int)yid[i].size()-1;j++){\n\t\t\tif(same(yid[i][j],yid[i][j+1]))continue;\n\t\t\tcnt++;\n\t\t\tunite(yid[i][j],yid[i][j+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(!same(0,i)){\n\t\t\tif(flag){\n\t\t\t\tcnt+=2;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcnt+=3;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nvector<ll> N;\n\nll parent(ll a){\n  if(N[a]==a){return a;}\n  return N[a]=parent(N[a]);\n}\n\nll merge(ll a,ll b){\n  ll pa=parent(a);\n  ll pb=parent(b);\n  if(pa==pb){return 0;}\n  N[pb]=pa;\n  return 1;\n}\n\n\nint main(){\n  ll n,h,w;\n  cin>>n>>w>>h;\n  vector<pll> x(n);\n  vector<pll> y(n);\n  N.resize(n);\n  bool j=false;\n  for(int i=0;i<n;i++){\n    N[i]=i;\n    ll X,Y;\n    cin>>X>>Y;\n    X--; Y--;\n    x[i]={X,i};\n    y[i]={Y,i};\n    if(X==0){j=true;}\n    if(X==w-1){j=true;}\n    if(Y==0){j=true;}\n    if(Y==h-1){j=true;}\n  }\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  ll C=n;\n  for(int i=1;i<n;i++){\n    if(x[i].first==x[i-1].first){\n      C-=merge(x[i].second,x[i-1].second);\n    }\n    if(y[i].first==y[i-1].first){\n      C-=merge(y[i].second,y[i-1].second);\n    }\n  }\n  if(C==1){cout<<n-1<<endl;}\n  else{\n    ll ans=n-1;\n    ans+=C;\n    if(j){ans--;}\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/04/20  Problem: AOJ 2382 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\nLL N, W, H;\n\nLL ans = 0LL;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tcin >> N >> H >> W;\n\n\tVI x(N), y(N);\n\tint Wall = 0;\n\tFOR(i, 0, N) {\n\t\tcin >> x[i] >> y[i];\n\t\tif (x[i] == 1 || y[i] == 1 || x[i] == W || y[i] == H)Wall = 1;\n\t}\n\tUnionFind uf(N);\n\n\tVI Xs(W + 1, -1);\n\tVI Ys(H + 1, -1);\n\tFOR(i, 0, N) { // mergeを\n\t\tif (Xs[x[i]] >= 0)uf.unionSet(Xs[x[i]], i);\n\t\tXs[x[i]] = i;\n\t\tif (Ys[y[i]] >= 0)uf.unionSet(Ys[y[i]], i);\n\t\tYs[y[i]] = i;\n\t}\n\n\n\tset<int>se;\n\tFOR(i, 0, N) {\n\t\tse.insert(uf.root(i));\n\t}\n\tint sz = SZ(se);\n\tif (sz != 1) {\n\t\tans = N - 1 + sz-Wall;\n\t}\n\telse {\n\t\tans = N - 1;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint dp[1001][1001];\nint main() {\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tunionfind uf(w + h);\n\tvpii s(n);\n\trep(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ts[i] = { a - 1,b - 1 };\n\t\tuf.unite(a - 1, w + b - 1);\n\t}\n\tuset<int> t,e[2];\n\trep(i, n) {\n\t\tint a = uf.find(s[i].first);\n\t\tt.insert(a);\n\t\tif (s[i].first == 0 || s[i].first == w - 1)e[0].insert(a);\n\t\tif (s[i].second == 0 || s[i].second == h - 1)e[0].insert(a);\n\t}\n\tint k = t.size();\n\tif (k > 1)k = k * 2 - max(e[0].size(), e[1].size()) - 1 + n - k;\n\telse k = n - 1;\n\tcout << k << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, h, w; cin >> n >> h >> w;\n    vector<ll> X(n), Y(n);\n    rep(i, n) {\n\t\tcin >> X[i] >> Y[i];\n\t\t--X[i], --Y[i];\n\t}\n\tvector<vector<ll>> g1(h), g2(w);\n\trep(i, n) {\n\t\tg1[Y[i]].pb(i);\n\t\tg2[X[i]].pb(i);\n\t}\n\tUnionFind uf(n);\n\trep(i, h) {\n\t\trep(j, 1, g1[i].size()) {\n\t\t\tuf.unite(g1[i][j-1], g1[i][j]);\n\t\t}\n\t}\n\trep(i, w) {\n\t\trep(j, 1, g2[i].size()) {\n\t\t\tuf.unite(g2[i][j-1], g2[i][j]);\n\t\t}\n\t}\n\tset<ll> s;\n\trep(i, n) s.insert(uf.root(i));\n\tll ans = linf;\n\tif (s.size() == 1) {\n\t\tans = n-1;\n\t}\n\telse {\n\t\tans = n + s.size() - 1;\n\t\tset<ll> sl, sr, su, sd;\n\t\trep(i, n) {\n\t\t\tll id = uf.root(i);\n\t\t\tif (X[i] == 0) sl.insert(id);\n\t\t\tif (X[i] == w-1) sr.insert(id);\n\t\t\tif (Y[i] == 0) su.insert(id);\n\t\t\tif (Y[i] == h-1) sd.insert(id);\n\t\t}\n\t\tans -= max(max(sl.size(), sr.size()), max(su.size(), sd.size()));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\n\nint N;\nint W, H;\nvector<tuple<int, int, int> > tupX, tupY;\n\nint parent[40005];\n\nvoid init(){\n\tfor(int i = 0; i < N; i++) parent[i] = i;\n}\n\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = (i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nint main(void)\n{\n\tcin >> N >> W >> H;\n\t\n\tbool flag = false;\n\tint x, y;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x >> y;\n\t\tif(x == 1 || x == W || y == 1 || y == H) flag = true;\n\t\ttupX.push_back( make_tuple(x, y, i) );\n\t\ttupY.push_back( make_tuple(y, x, i) );\n\t}\n\tsort(tupX.begin(), tupX.end());\n\tsort(tupY.begin(), tupY.end());\n\t\n\tinit();\n\tfor(int i = 1; i < tupX.size(); i++){\n\t\tif(get<0>(tupX[i]) == get<0>(tupX[i-1])){\n\t\t\tunite( get<2>(tupX[i]), get<2>(tupX[i-1]) );\n\t\t}\n\t}\n\tfor(int i = 1; i < tupY.size(); i++){\n\t\tif(get<0>(tupY[i]) == get<0>(tupY[i-1])){\n\t\t\tunite( get<2>(tupY[i]), get<2>(tupY[i-1]) );\n\t\t}\n\t}\n\t\n\tint cnt = 0;\n\tfor(int i = 0; i < N; i++) if(parent[i] == i) cnt++;\n\t\n\tint ans = (N-1);\n\tif(cnt > 1){\n\t\tans += cnt;\n\t\tif(flag) ans--;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n};\nvector<pair<int,int> >A;\nint N,H,W;\nlong f()\n{\n\tlong ret=0;\n\tvector<vector<int> >G(H);\n\tvector<bool>ap(W,false);\n\tfor(pair<int,int>p:A)\n\t{\n\t\tG[p.first].push_back(p.second);\n\t\tap[p.second]=true;\n\t}\n\tUF uf(W);\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tfor(int j=1;j<G[i].size();j++)uf.unite(G[i][j-1],G[i][j]);\n\t}\n\tvector<int>B;\n\tint cnt=0;\n\tfor(int i=0;i<W;i++)\n\t{\n\t\tif(!ap[i])continue;\n\t\tcnt++;\n\t\tB.push_back(uf.find(i));\n\t}\n\tsort(B.begin(),B.end());\n\tB.erase(unique(B.begin(),B.end()),B.end());\n\tret+=N-cnt;\n\tret+=cnt-B.size();\n\tif(B.size()<=1)return ret;\n\tset<int>L,R;\n\tfor(int g:G[0])L.insert(uf.find(g));\n\tfor(int g:G[H-1])R.insert(uf.find(g));\n\tcnt=0;\n\tfor(int b:B)cnt+=L.find(b)!=L.end();\n\tlong get=2*(long)B.size()-cnt-1;\n\tcnt=0;\n\tfor(int b:B)cnt+=R.find(b)!=R.end();\n\tget=min(get,2*(long)B.size()-cnt-1);\n\treturn ret+get;\n}\nmain()\n{\n\tcin>>N>>H>>W;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tx--,y--;\n\t\tA.push_back(make_pair(x,y));\n\t}\n\tlong ans=f();\n\tfor(pair<int,int>&p:A)\n\t{\n\t\tswap(p.first,p.second);\n\t}\n\tswap(H,W);\n\tans=min(ans,f());\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N, W, H;\n  int xs[100000], ys[100000];\n  memset(xs, -1, sizeof(xs));\n  memset(ys, -1, sizeof(ys));\n\n  scanf(\"%d %d %d\", &N, &W, &H);\n  bool ei = false;\n  UnionFind tree(N);\n  for(int i = 0; i < N; i++) {\n    int X, Y;\n    scanf(\"%d %d\", &X, &Y);\n    --X, --Y;\n    if(~xs[X]) tree.unite(xs[X], i);\n    else xs[X] = i;\n    if(~ys[Y]) tree.unite(ys[Y], i);\n    else ys[Y] = i;\n    ei |= X == 0 || Y == 0 || X == W - 1 || Y == H - 1;\n  }\n  int cnt = 0;\n  for(int i = 0; i < N; i++) cnt += tree.find(i) == i;\n  int ret = N - cnt;\n  if(cnt > 1) ret += cnt * 2 - 1 - ei;\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pair<int, int> > place;\n\tvector<vector<int> > x(40001), y(40001);\n\tfor(int i = 0; i < n; i++){\n\t\tint tmpx, tmpy;\n\t\tcin >> tmpx >> tmpy;\n\t\tplace.push_back(make_pair(tmpx, tmpy));\n\t\tx[tmpx].push_back(i);\n\t\ty[tmpy].push_back(i);\n\t}\n\tvector<int> groupnum(40000, -1);\n\tvector<int> groupsize;\n\tvector<vector<bool> > isclosetowall;\n\tvector<bool> ischecked_x(100000, false), ischecked_y(100000, false);\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(groupnum[i] < 0){\n\t\t\t// cout << i << endl;\n\t\t\tqueue<int> qu;\n\t\t\tqu.push(i);\n\t\t\tgroupnum[i] = cnt;\n\t\t\tisclosetowall.push_back(vector<bool>(4, false));\n\t\t\tgroupsize.push_back(1);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint now = qu.front();\n\t\t\t\tint nowx = place[now].first;\n\t\t\t\tint nowy = place[now].second;\n\t\t\t\tqu.pop();\n\t\t\t\t// cout << now << \" \" << \" \" << nowx << \" \" << nowy << \" \" << ischecked_x[nowx] << \" \" << ischecked_y[nowy] << endl;\n\t\t\t\tif(nowx == 1) isclosetowall[cnt][0] = true;\n\t\t\t\tif(nowx == h) isclosetowall[cnt][1] = true;\n\t\t\t\tif(nowy == 1) isclosetowall[cnt][2] = true;\n\t\t\t\tif(nowy == w) isclosetowall[cnt][3] = true;\n\t\t\t\tif(!ischecked_x[nowx]){\n\t\t\t\t\tischecked_x[nowx] = true;\n\t\t\t\t\tfor(int j = 0; j < x[nowx].size(); j++){\n\t\t\t\t\t\tint nowindex = x[nowx][j];\n\t\t\t\t\t\tint tmpy = place[nowindex].second;\n\t\t\t\t\t\tif(nowindex == now || ischecked_y[tmpy]) continue;\n\t\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// x.erase(x.begin() + nowx);\n\t\t\t\tif(!ischecked_y[nowy]){\n\t\t\t\t\tischecked_y[nowy] = true;\n\t\t\t\t\tfor(int j = 0; j < y[nowy].size(); j++){\n\t\t\t\t\t\tint nowindex = y[nowy][j];\n\t\t\t\t\t\tint tmpx = place[nowindex].first;\n\t\t\t\t\t\tif(nowindex == now || ischecked_x[tmpx]) continue;\n\t\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// y.erase(y.begin() + nowy);\n\t\t\t\t// cout << now << \" \" << groupsize[cnt] << endl;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t// cout << i << \" \" << groupnum[i] << groupsize[groupnum[i]] << endl;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < cnt; i++){\n\t\tsum += groupsize[i] - 1;\n\t}\n\tif(cnt == 1){\n\t\tcout << sum << endl;\n\t\treturn 0;\n\t}\n\tint ans = mod;\n\tfor(int i = 0; i < 4; i++){\n\t\tint needtomove = 0;\n\t\tfor(int j = 0; j < cnt; j++){\n\t\t\tif(!isclosetowall[j][i]) needtomove++;\n\t\t}\n\t\tans = min(ans, sum + needtomove + cnt - 1);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 40010\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint p[MAX];\nint n,h,w,ans=0;\nint x[MAX],y[MAX];\nbool l[MAX]={},r[MAX]={},u[MAX]={},d[MAX]={};\n\nvoid check(int a,int b){\n  u[a]|=u[b];\n  u[b]|=u[a];\n  l[a]|=l[b];\n  l[b]|=l[a];\n  d[a]|=d[b];\n  d[b]|=d[a];\n  r[a]|=r[b];\n  r[b]|=r[a];\n}\n\nint find(int a){\n  if(p[a]==a)return a;\n  int pa=find(p[a]);\n  p[a]=pa;\n  return pa;\n}\n\nvoid unite(int a,int b){\n  int pa=find(a),pb=find(b);\n  p[pa]=pb;\n}\n\nbool same(int a,int b){\n  return find(a)==find(b);\n}\n\nint main()\n{\n\n  vector<pii> a,b;\n\n  cin>>n>>w>>h;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    a.push_back(mp(x[i],i));\n    b.push_back(mp(y[i],i));\n    if(y[i]==1)d[i]=true;\n    if(x[i]==1)l[i]=true;\n    if(y[i]==h)u[i]=true;\n    if(x[i]==w)r[i]=true;\n  }\n\n  for(int i=0;i<MAX;i++)p[i]=i;\n\n  sort(a.begin(),a.end());\n  sort(b.begin(),b.end());\n\n  for(int i=1;i<n;i++){\n    if(a[i-1].f==a[i].f && !same(a[i-1].s,a[i].s)){\n      unite(a[i-1].s,a[i].s);\n      ans++;\n    }\n    if(b[i-1].f==b[i].f && !same(b[i-1].s,b[i].s)){\n      unite(b[i-1].s,b[i].s);\n      ans++;\n    }\n  }\n\n  if(ans!=n-1){\n    for(int i=0;i<n;i++)check(find(i),i);\n    int sum1=0,sum2=0,sum3=0,sum4=0;\n    for(int i=0;i<n;i++)if(p[i]==i)sum1++;\n    sum1=(sum1*2-1);\n    sum2=sum3=sum4=sum1;\n    for(int i=0;i<n;i++){\n      if(p[i]==i && l[i])sum1--;\n      if(p[i]==i && u[i])sum2--;\n      if(p[i]==i && r[i])sum3--;\n      if(p[i]==i && d[i])sum4--;\n    }\n    ans+=min(min(sum1,sum2),min(sum3,sum4));\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll calc(vector<vector<ll>>& G,ll x){\n    ll ret = 0;\n    for(int i = 0; i < G.size(); i++){\n        if(G[i].empty()) continue;\n        ret++;\n        if(G[i][0] == x){\n            ret += G[i].size() - 1;\n        }else{\n            ret += G[i].size();\n        }\n    }\n    ret--;\n    return ret;\n}\nll solve(){\n    ll res = LINF;\n    ll N,W,H; cin >> N >> W >> H;\n    vector<ll> x(N),y(N);\n    for(int i = 0; i < N;i++) cin >> x[i] >> y[i];\n    \n    vector<vector<ll>> wG(W+2),hG(H+2);\n    for(int i = 0; i < N;i++){\n        wG[x[i]].push_back(y[i]);\n        hG[y[i]].push_back(x[i]);\n    }\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end());\n    res = min({res,calc(wG,1),calc(hG,1)});\n    for(int i = 0; i < W+2;i++) sort(wG[i].begin(),wG[i].end(),greater<ll>());\n    for(int j = 0; j < H+2;j++) sort(hG[j].begin(),hG[j].end(),greater<ll>());\n    res = min({res,calc(wG,H),calc(hG,W)});\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int N, W, H;\n    cin >> N >> W >> H;\n\n    vector<int> x(N), y(N);\n    map<int,vector<int>> xidx, yidx;\n\n    bool hasEdge = false;\n\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i];\n        if (x[i] == 1 || x[i] == W ||\n            y[i] == 1 || y[i] == H) {\n            hasEdge = true;\n        }\n        xidx[x[i]].emplace_back(i);\n        yidx[y[i]].emplace_back(i);\n    }\n\n    UnionFind uf(N);\n    for (auto tp : xidx) {\n        for (int i = 1; i < tp.second.size(); ++i) {\n            uf.merge(tp.second[0], tp.second[i]);\n        }\n    }\n    for (auto tp : yidx) {\n        for (int i = 1; i < tp.second.size(); ++i) {\n            uf.merge(tp.second[0], tp.second[i]);\n        }\n    }\n\n    map<int,int> Size;\n    for (int i = 0; i < N; ++i) {\n        Size[uf.root(i)] = uf.size(i);\n    }\n\n    int ans = 0;\n    for (auto tp : Size) {\n        ans += tp.second - 1;\n    }\n\n    if (Size.size() > 1) {\n        ans += 2 * Size.size() - 1;\n\n        if (hasEdge) {\n            --ans;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, h, w; cin >> n >> h >> w;\n    vector<ll> X(n), Y(n);\n    rep(i, n) {\n\t\tcin >> X[i] >> Y[i];\n\t\t--X[i], --Y[i];\n\t}\n\tvector<vector<ll>> g1(h), g2(w);\n\trep(i, n) {\n\t\tg1[Y[i]].pb(i);\n\t\tg2[X[i]].pb(i);\n\t}\n\tUnionFind uf(n);\n\trep(i, h) {\n\t\trep(j, ll(g1[i].size())-1) {\n\t\t\tuf.unite(g1[i][j], g1[i][j+1]);\n\t\t}\n\t}\n\trep(i, w) {\n\t\trep(j, ll(g2[i].size())-1) {\n\t\t\tuf.unite(g2[i][j], g2[i][j+1]);\n\t\t}\n\t}\n\tset<ll> s;\n\trep(i, n) s.insert(uf.root(i));\n\tll ans = linf;\n\tif (s.size() == 1) {\n\t\tans = n-1;\n\t}\n\telse {\n\t\tans = n + s.size() - 1;\n\t\tset<ll> sl, sr, su, sd;\n\t\trep(i, n) {\n\t\t\tll id = uf.root(i);\n\t\t\tif (X[i] == 0) sl.insert(id);\n\t\t\tif (X[i] == w-1) sr.insert(id);\n\t\t\tif (Y[i] == 0) su.insert(id);\n\t\t\tif (Y[i] == h-1) sd.insert(id);\n\t\t}\n\t\tans -= max(max(sl.size(), sr.size()), (su.size(), sd.size()));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  vector<int> ix(w+1,-1);\n  vector<int> ixx(w+1,-1);\n  vector<int> ixn(w+1,-1);\n  vector<int> iy(h+1,-1);\n  vector<int> iyx(h+1,-1);\n  vector<int> iyn(h+1,-1);\n  Edges ve;\n  REP(i,n) {\n    int x,y;\n    cin>>x>>y;\n    if (ix[x] == -1) {\n      ix[x] = i;\n      ixx[x] = y;\n      ixn[x] = y;\n    } else {\n      ixx[x] = max(ixx[x], y);\n      ixn[x] = min(ixn[x], y);\n      ve.push_back((Edge){i, ix[x], 1});\n    }\n    if (iy[y] == -1) {\n      iy[y] = i;\n      iyx[y] = x;\n      iyn[y] = x;\n    } else {\n      iyx[y] = max(iyx[y], x);\n      iyn[y] = min(iyn[y], x);\n      ve.push_back((Edge){i, iy[y], 1});\n    }\n  }\n  int res = INF;\n  auto rve = kruskal(n,ve);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n-1) res = min(res, sum);\n  auto tmp = ve;\n  int cnt = 0;\n  FOR(x,1,w+1) {\n    if (ix[x] >= 0) {\n      tmp.push_back((Edge){ix[x], n+cnt, (ixn[x]>1)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(x,1,w+1) {\n    if (ix[x] >= 0) {\n      tmp.push_back((Edge){ix[x], n+cnt, (ixx[x]<h)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(y,1,h+1) {\n    if (iy[y] >= 0) {\n      tmp.push_back((Edge){iy[y], n+cnt, (iyn[y]>1)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt, tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  tmp = ve;\n  cnt = 0;\n  FOR(y,1,h+1) {\n    if (iy[y] >= 0) {\n      tmp.push_back((Edge){iy[y], n+cnt, (iyx[y]<w)});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  rve = kruskal(n+cnt,tmp);\n  sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) res = min(res, sum);\n  cerr << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<numeric>\n\n\nusing namespace std;\n\nint par[40000];\nint bit[40000];\nint xx[100001],yy[100001];\nbool bx[100001],by[100001];\n\nint find(int x){\n  return (x==par[x])?x:par[x]=find(par[x]);\n}\n\nvoid unite(int a,int b){\n  int r=find(a);\n  bit[r]|=bit[b];\n  par[find(b)]=r;\n}\n\nint main(){\n  iota(begin(par),end(par),0);\n  int N,W,H;\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin>>x>>y;\n    bit[i]=(x==1)|(x==W)<<1|(y==1)<<2|(y==H)<<3;\n    if(!bx[x]++){\n      xx[x]=i;\n    }else{\n      unite(xx[x],i);\n    }\n    if(!by[y]++){\n      yy[y]=i;\n    }else{\n      unite(yy[y],i);\n    }\n  }\n  int ans=1<<29;\n  for(int i=0;i<4;i++){\n    int p=0,c=0;\n    for(int j=0;j<N;j++){\n      p+=find(j)==j;\n      c+=find(j)==j&&!(bit[j]>>i&1);\n    }\n    ans=min(ans,(p==1)?N-1:c+N-1);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef pair<int, int> P;\n\nint H, W;\nvector<int> X, Y;\nvector<vector<int> > G;\nvector<bool> used;\n\nvoid make_edge(const map<int, vector<int> > &same){\n  FOREACH(it, same){\n    vector<int> vi = it->second;\n    REP(i, vi.size() - 1){\n      int u = vi[i], v = vi[i+1];\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n  }  \n}\n\nint dfs(int v, vector<bool> &E){\n  used[v] = true;\n  if(X[v] == 1) E[0] = true;\n  if(X[v] == W) E[1] = true;\n  if(Y[v] == 1) E[2] = true;\n  if(Y[v] == H) E[3] = true;\n\n  int res = 1;\n  REP(i, G[v].size()){\n    int to = G[v][i];\n    if(!used[to]){\n      res += dfs(to, E);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N >> W >> H;\n  G.resize(N);\n  \n  map<int, vector<int> > samex, samey;\n  \n  REP(i, N){\n    int x, y;\n    cin >> x >> y;\n    X.push_back(x);\n    Y.push_back(y);\n    samex[X[i]].push_back(i);\n    samey[Y[i]].push_back(i);\n  }\n  \n  make_edge(samex);\n  make_edge(samey);\n  \n  int res = 0;\n  int con = 0;\n  vector<int>  C(4, 0);  \n  used.resize(N, false);\n  \n  REP(i, N)if(!used[i]){\n    vector<bool> E(4, false);\n    res += dfs(i, E) - 1;\n    REP(j, E.size()){\n      C[j] += E[j];\n    }\n    con++;\n  }\n  \n  if(con > 1){\n    res += 2 * con - *max_element(ALL(C)) - 1;\n  }\n  \n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint ans;\nmap<int, vector<int>> x,y;\nset<PII> visit;\nint n,w,h;\n\nvoid DFS(int fx, int fy){\n\tif(EXIST(visit, MP(fx,fy)))return;\n\tvisit.insert(MP(fx,fy));\n\tREP(i,x[fx].size()){\n\t\tif(x[fx][i]!=fy)DFS(fx, x[fx][i]);\n\t}\n\tREP(i,y[fy].size()){\n\t\tif(y[fy][i]!=fx)DFS(y[fy][i], fy);\n\t}\n}\n\nint main(){\n\tcin>>n>>w>>h;\n\tans = n-1;\n\tint flag = 0,cnt=0;\n\tREP(i,n){\n\t\tint tx, ty;\n\t\tscanf(\"%d%d\", &tx,&ty);\n\t\tx[tx].PB(ty);\n\t\ty[ty].PB(tx);\n\t\tif(tx==1||ty==1||tx==w||ty==h)flag=1;\n\t}\n\tfor(map<int, vector<int>>::iterator it=x.begin(); it!=x.end(); it++){\n\t\tif(!EXIST(visit, MP(it->first, it->second[0]))){\n\t\t\tDFS(it->first, it->second[0]);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt!=1){\n\t\tif(flag==0){\n\t\t\tans+=cnt;\n\t\t}else{\n\t\t\tans+=cnt-1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (1e9);\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n,-1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n    return x != y;\n  }\n  bool same(int x, int y){return find(x) == find(y);}\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  int size(int x){ return -data[find(x)];}\n};\n\nint main(){\n  int N, H, W;\n  cin >> N >> W >> H;\n  vector<int> X(W+1,-1), Y(H+1,-1);\n  vector< pair<int,int> > V;\n  UnionFind uf(N);\n  for(int i = 0; i < N; ++i){\n    int x, y;\n    cin >> x >> y;\n    V.emplace_back(x,y);\n    if(X[x] > -1) uf.unite(i,X[x]);\n    else X[x] = i;\n    if(Y[y] > -1) uf.unite(i,Y[y]);\n    else Y[y] = i;\n  }\n  if(uf.size(0) == N){\n    cout << N-1 << endl;\n    return 0;\n  }\n  bool t = false, b = false, l = false, r = false;\n  set<int> P;\n  for(int i = 0; i < N; ++i){\n    int x = V[i].first, y = V[i].second;\n    int p = uf.find(i);\n    P.insert(p);\n    l |= (x == 1);\n    r |= (x == W);\n    b |= (y == 1);\n    t |= (y == H);\n  }\n  int ps = P.size();\n  int ans = INF;\n  ans = min(ans, N + ps - 1 - (l or r or b or t));\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint ans;\nmap<int, vector<int>> x,y;\nset<PII> visit;\nint n,w,h;\n\nvoid DFS(int fx, int fy){\n\tif(EXIST(visit, MP(fx,fy)))return;\n\tvisit.insert(MP(fx,fy));\n\tREP(i,x[fx].size()){\n\t\tif(x[fx][i]!=fy)DFS(fx, x[fx][i]);\n\t}\n\tREP(i,y[fy].size()){\n\t\tif(y[fy][i]!=fx)DFS(y[fy][i], fy);\n\t}\n}\n\nvoid main(){\n\tcin>>n>>w>>h;\n\tans = n-1;\n\tint flag = 0,cnt=0;\n\tREP(i,n){\n\t\tint tx, ty;\n\t\tscanf(\"%d%d\", &tx,&ty);\n\t\tx[tx].PB(ty);\n\t\ty[ty].PB(tx);\n\t\tif(tx==1||ty==1||tx==w||ty==h)flag=1;\n\t}\n\tfor(auto it=x.begin(); it!=x.end(); it++){\n\t\tif(!EXIST(visit, MP(it->first, it->second[0]))){\n\t\t\tDFS(it->first, it->second[0]);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt!=1){\n\t\tif(flag==0){\n\t\t\tans+=cnt;\n\t\t}else{\n\t\t\tans+=cnt-1;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UFT {\npublic:\n  vector<int> parent;\n  vector<int> rank;\n  vector<int> size;\n  UFT(int n){\n    parent = vector<int>(n);\n    rank = vector<int>(n,0);\n    size = vector<int>(n,1);\n    for(int i = 0; i < n; i++)\n      parent[i] = i;\n  }\n  int find_root(int x){\n    if ( parent[x] == x ) return x;\n    return parent[x] = find_root( parent[x] );\n  }\n  void unite(int x, int y){\n    int u = find_root(x);\n    int v = find_root(y);\n    if ( u == v ) return;\n    if ( rank[u] < rank[v] ){\n      parent[u] = v;\n      size[v] += size[u];\n    }else{\n      parent[v] = u;\n      size[u] += size[v];\n      if ( rank[u] == rank[v] ) rank[x]++;\n    }\n  }\n  bool is_same ( int x, int y ){\n    return find_root(x) == find_root(y);\n  }\n  int size_of ( int x ){\n    return size[ find_root(x) ];\n  }\n};\n\ntypedef long long Cost;\nclass edge{\npublic:\n  int u,v;;\n  Cost cost;\n  edge(int u, int v, Cost c) : u(u), v(v), cost(c) { ; }\n  bool operator< (const edge &e) const {\n    return cost < e.cost;\n  }\n};\nclass SpanningTree{\npublic:\n  int V;\n  vector< edge > edges;\n  SpanningTree(int n) : V(n) {; }\n  void add_edge(int v, int u, Cost c){\n    edges.push_back( edge(v,u,c) );\n  }\n  Cost kruskal(){\n    sort( edges.begin(), edges.end() );\n    UFT uft(V);\n    Cost ret = 0;\n    for(int i = 0; i < edges.size(); i++){\n      edge &e = edges[i];\n      if( !uft.is_same(e.u, e.v) ){\n\tuft.unite(e.u, e.v);\n\tret += e.cost;\n      }\n    }\n    return ret;\n  }\n};\n\nint N, W, H;\nvector<tuple<long long, long long, int>> p;\nvector<tuple<long long, long long, int>> q;\nvector<tuple<long long, long long>> s;\nint M[40000];\nint main(){\n  cin >> N >> W >> H;\n  for(int i = 0; i < N; i++){\n    long long x, y;\n    cin >> x >> y;\n    p.emplace_back(x,y,i);\n    q.emplace_back(y,x,i);\n    s.emplace_back(y,x);\n  }\n  UFT uft(N);\n  SpanningTree st(N);\n  sort(p.begin(), p.end());\n  sort(q.begin(), q.end());\n\n  for(int i = 1; i < N; i++){\n    if( get<0>(p[i-1]) == get<0>(p[i]) ){\n      uft.unite( get<2>(p[i-1]), get<2>(p[i]) );\n      st.add_edge( get<2>(p[i-1]), get<2>(p[i]), 1 );\n    }\n    if( get<0>(q[i-1]) == get<0>(q[i]) ){\n      uft.unite( get<2>(q[i-1]), get<2>(q[i]) );\n      st.add_edge( get<2>(q[i-1]), get<2>(q[i]), 1 );\n    }\n  }\n  long long sum_of_componentwise = st.kruskal();\n  //cout << sum_of_componentwise << endl;\n  int C = 0;\n  for(int i = 0; i < N; i++){\n    if( uft.parent[i] == i ){\n      M[i] = C;\n      C++;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    if( uft.parent[i] != i ){\n      M[i] = M[uft.find_root(i)];\n    }\n  }\n  long long w0 = 0, wW = 0, h0 = 0, hH = 0;\n  for(int i = 0; i < N; i++){\n    long long x, y;\n    tie(x,y) = s[i];\n    if( x == 1 ){\n      w0++;\n    }else if( x == W ){\n      wW++;\n    }\n    if( y == 1 ){\n      h0++;\n    }else if( y == H ){\n      hH++;\n    }\n  }\n\n  long long ans = 1e18;\n  if( C == 1 ){\n    ans = 0;\n  }else{\n    ans = min( ans, (C-w0) + C-1);\n    ans = min( ans, (C-wW) + C-1);\n    ans = min( ans, (C-h0) + C-1);\n    ans = min( ans, (C-hH) + C-1);\n  }\n  cout << ans + sum_of_componentwise << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint p[400002],p2[400002];\nint r[400002],r2[400002];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tinit(400000);\n\tbool flag = 0;\n\tvector<int>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tif(x[i]==1||x[i]==h||y[i]==1||y[i]==w){\n\t\t\tflag = 1;\n\t\t}\n\t}\n\trep(i,n){\n\t\tunion_set(i,x[i]+100010);\n\t\tunion_set(i,y[i]+200020);\n\t}\n\tset<int> st;\n\trep(i,n){\n\t\tif(st.count(find(i))==0){\n\t\t\tst.insert(find(i));\n\t\t}\n\t}\n\tint ans = n-1 + st.size();\n\tif(flag)ans--;\n\tif(st.size()==1){\n\t\tans = n-1;\t\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint p[200002],p2[200002];\nint r[200002],r2[200002];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\nint main(){\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tinit(200000);\n\tbool flag = 0;\n\tvector<int>x(n),y(n);\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tif(x[i]==1||x[i]==h||y[i]==1||y[i]==w){\n\t\t\tflag = 1;\n\t\t}\n\t}\n\trep(i,n){\n\t\tunion_set(i,x[i]+40010);\n\t\tunion_set(i,y[i]+80020);\n\t}\n\tset<int> st;\n\trep(i,n){\n\t\tif(st.count(find(i))==0){\n\t\t\tst.insert(find(i));\n\t\t}\n\t}\n\tint ans = n-1 + st.size();\n\tif(flag)ans--;\n\tif(st.size()==1){\n\t\tans = n-1;\t\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,w,h;\nint par[40001],rank[40001];\nint x[40001],y[40001];\nvector<int> xid[100001],yid[100001];\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(rank[x]>rank[y]){\n\t\tpar[y]=x;\n\t}else{\n\t\tif(rank[x]==rank[y]){\n\t\t\trank[y]++;\n\t\t}\n\t\tpar[x]=y;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(void){\n\tscanf(\"%d %d %d\",&n,&w,&h);\n\tbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\txid[x[i]].push_back(i);\n\t\tyid[y[i]].push_back(i);\n\t\tif(x[i]==w || x[i]==1 || y[i]==1 || y[i]==h)flag=true;\n\t}\n\tinit();\n\tint cnt=0;\n\tfor(int i=1;i<=w;i++){\n\t\tfor(int j=0;j<(int)xid[i].size()-1;j++){\n\t\t\tif(same(xid[i][j],xid[i][j+1]))continue;\n\t\t\tcnt++;\n\t\t\tunite(xid[i][j],xid[i][j+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=0;j<(int)yid[i].size()-1;j++){\n\t\t\tif(same(yid[i][j],yid[i][j+1]))continue;\n\t\t\tcnt++;\n\t\t\tunite(yid[i][j],yid[i][j+1]);\n\t\t}\n\t}\n\n\tfor(int i=1;i<n;i++){\n\t\tif(!same(0,i)){\n\t\t\tif(flag){\n\t\t\t\tcnt+=2;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcnt+=3;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass UnionFind {\n    vector<int> par, h;\npublic:\n    UnionFind(int size) {\n        par.assign(size, 0);\n        h.assign(size, 0);\n        REP(i, size) par[i] = i;\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v) return;\n        if (h[u] > h[v]) {\n            par[v] = u;\n        }\n        else if (h[u] < h[v]) {\n            par[u] = v;\n        }\n        else {\n            ++h[u];\n            par[v] = u;\n        }\n    }\n    bool isUnited(int u, int v) {\n        return root(u) == root(v);\n    }\n    int root(int v) {\n        if (par[v] == v) return v;\n        return par[v] = root(par[v]);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, h, w; cin >> n >> w >> h;\n    vector<ll> X(n), Y(n);\n    rep(i, n) {\n\t\tcin >> X[i] >> Y[i];\n\t\t--X[i], --Y[i];\n\t}\n\tvector<vector<ll>> g1(h), g2(w);\n\trep(i, n) {\n\t\tg1[Y[i]].pb(i);\n\t\tg2[X[i]].pb(i);\n\t}\n\tUnionFind uf(n);\n\trep(i, h) {\n\t\trep(j, 1, g1[i].size()) {\n\t\t\tuf.unite(g1[i][j-1], g1[i][j]);\n\t\t}\n\t}\n\trep(i, w) {\n\t\trep(j, 1, g2[i].size()) {\n\t\t\tuf.unite(g2[i][j-1], g2[i][j]);\n\t\t}\n\t}\n\tset<ll> s;\n\trep(i, n) s.insert(uf.root(i));\n\tll ans = linf;\n\tif (s.size() == 1) {\n\t\tans = n-1;\n\t}\n\telse {\n\t\tans = n + s.size() - 1;\n\t\tset<ll> sl, sr, su, sd;\n\t\trep(i, n) {\n\t\t\tll id = uf.root(i);\n\t\t\tif (X[i] == 0) sl.insert(id);\n\t\t\tif (X[i] == w-1) sr.insert(id);\n\t\t\tif (Y[i] == 0) su.insert(id);\n\t\t\tif (Y[i] == h-1) sd.insert(id);\n\t\t}\n\t\tans -= max(max(sl.size(), sr.size()), max(su.size(), sd.size()));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\n\nint main(){\n  int n, h, w;\n  cin >> n >> h >> w;\n  int x, y;\n  vector<int> X(n), Y(n);\n  map<int,int> M_x, M_y;\n  UnionFind uf(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n    if(M_x[x] > 0){\n      uf.unite(i,M_x[x]-1);\n    }else{\n      M_x[x] = i + 1;\n    }\n    if(M_y[y] > 0){\n      uf.unite(i,M_y[y]-1);\n    }else{\n      M_y[y] = i + 1;\n    }\n  }\n  set<int> p, l, r, t, b;\n  for(int i = 0; i < n; ++i){\n    p.insert(uf.find(i));\n    if(X[i] == 1) l.insert(uf.find(i));\n    if(X[i] == w) r.insert(uf.find(i));\n    if(Y[i] == 1) b.insert(uf.find(i));\n    if(Y[i] == h) t.insert(uf.find(i));\n  }\n  int k = p.size(), s = max({l.size(),r.size(),t.size(),b.size()});\n  if(k == 1) cout << n - 1 << endl;\n  else cout << n + k - 1 - s << endl; \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tif(n == 2 && w != 3&& cnt == 2)exit(100);\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    vector<int>f;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        f.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n            f[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        f[x]|=f[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H,W;\nint x[44444],y[44444];\nint px[111111],py[111111];\n\nint solve(int T){\n    UF uf;uf.init(N);\n    memset(px,-1,sizeof(px));\n    memset(py,-1,sizeof(py));\n    rep(i,N){\n        if(px[x[i]]>=0)uf.unite(px[x[i]],i);\n        if(py[y[i]]>=0)uf.unite(py[y[i]],i);\n        if(y[i]==T)uf.f[uf.find(i)]=1;\n        px[x[i]]=i;py[y[i]]=i;\n    }\n\n    int cnt1=0,cnt2=0;\n    rep(i,N)if(uf.find(i)==i){\n        cnt1++;\n        if(uf.f[i])cnt2++;\n    }\n\n    if(cnt1==1)return N-1;\n    return N-cnt1+cnt1-cnt2+cnt1-1;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&N,&W,&H);\n    rep(i,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n\n    int ans=1001001001;\n    rep(i,2){\n        chmin(ans,solve(1));\n        chmin(ans,solve(H));\n        swap(H,W);\n        rep(j,N)swap(x[j],y[j]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  rep(i,N) { \n    cin >> x[i] >> y[i];\n    uf[i] = i, masks[i] = sz[i] = 0;\n\n    if( y[i] == 1 ) masks[i] |= (1<<0);\n    if( x[i] == 1 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  map<int,int> bitmask;\n  set<int> S;\n  vector<int> group;\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n\n  if( S.size() == 1 ) {\n    cout << sz[find(0)] - 1 << endl;\n    return 0;\n  }\n\n  rep(i,N) bitmask[find(i)] |= masks[i];\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[group[j]];\n      if( (bitmask[group[j]]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\nprivate:\n  vector<ll> data;\n\npublic:\n  UnionFind(ll n): data(n, -1) {}\n\n  ll size(ll i) { return -data[find(i)]; }\n  bool root(ll i) { return data[i] < 0; }\n  bool same(ll i, ll j) { return find(i) == find(j); }\n\n  ll find(ll i) { return root(i) ? i : (data[i] = find(data[i])); }\n\n  bool unite(ll i, ll j) {\n    if(same(i, j)) return false;\n    data[find(i)] += data[find(j)];\n    data[find(j)] = find(i);\n    return true;\n  }\n};\n\nint main(void) {\n  ll N, H, W;\n  cin >> N >> H >> W;\n  vector<ll> X(N), Y(N);\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  UnionFind uf(N);\n  REP(i, 0, N) REP(j, i + 1, N) {\n    if(X[i] == X[j] || Y[i] == Y[j]) {\n      uf.unite(i, j);\n    }\n  }\n\n  set<ll> uniq;\n  REP(i, 0, N) uniq.insert(uf.find(i));\n\n  ll s = 0;\n  for(ll i : uniq) s += uf.size(i) - 1;\n\n  vector<bool> b1(N), b2(N), b3(N), b4(N);\n  REP(i, 0, N) {\n    ll r = uf.find(i);\n    b1[r] = b1[r] || X[i] == 1;\n    b2[r] = b2[r] || X[i] == H;\n    b3[r] = b3[r] || Y[i] == 1;\n    b4[r] = b4[r] || Y[i] == W;\n  }\n  ll t1 = 0, t2 = 0, t3 = 0, t4 = 0;\n  for(ll i : uniq) {\n    if(b1[i]) t1++;\n    if(b2[i]) t2++;\n    if(b3[i]) t3++;\n    if(b4[i]) t4++;\n  }\n\n  if(uniq.size() == 1) {\n    cout << s << endl;\n  } else {\n    cout << s + uniq.size() - max({ t1, t2, t3, t4 }) + ((ll) uniq.size() - 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  scanf(\"%d %d %d\",&N,&W,&H);\n  rep(i,N) { \n    scanf(\"%d %d\",x+i,y+i);\n    uf[i] = i, masks[i] = sz[i] = 0;\n\n    if( y[i] == 1 ) masks[i] |= (1<<0);\n    if( x[i] == 1 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  map<int,int> bitmask;\n  set<int> S;\n  vector<int> group;\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n\n  if( S.size() == 1 ) {\n    printf(\"%d\\n\",sz[find(0)]-1);\n    return 0;\n  }\n\n  rep(i,N) bitmask[find(i)] |= masks[i];\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[group[j]];\n      if( (bitmask[group[j]]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  rep(i,N) { \n    cin >> x[i] >> y[i]; \n    uf[i] = i, masks[i] = sz[i] = 0;\n    if( y[i] == 0 ) masks[i] |= (1<<0);\n    if( x[i] == 0 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  map<int,int> bitmask;\n  set<int> S;\n  vector<int> group;\n  rep(i,N) find(i);\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n\n  if( S.size() == 1 ) {\n    cout << sz[find(0)] - 1 << endl;\n    return 0;\n  }\n\n  rep(i,N) bitmask[find(i)] |= masks[i];\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[group[j]];\n      if( (bitmask[group[j]]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 40005;\n\nint x[MAX_N],y[MAX_N];\nint n,w,h;\nbool flag[MAX_N];\nvector<int> X[100002],Y[100002];\nvector<int> G[MAX_N];\n\nvoid dfs(int u,bool& hoge)\n{\n    flag[u] = true;\n    if(x[u] == 0 || x[u] == h-1 || y[u] == 0 || y[u] == w-1){\n        hoge = true;\n    }\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],hoge);\n        }\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n        x[i]--,y[i]--;\n        X[x[i]].push_back(i);\n        Y[y[i]].push_back(i);\n\t}\n    rep(i,w){\n        rep(j,Y[i].size()){\n            rep(k,Y[i].size()){\n                if(k != j){\n                    G[Y[i][j]].push_back(Y[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,X[i].size()){\n            rep(k,X[i].size()){\n                if(k != j){\n                    G[X[i][j]].push_back(X[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    int cnt = 0;\n    int pl = 0;\n    bool wall = false;\n    rep(i,n){\n        if(!flag[i]){\n            cnt++;\n            dfs(i,wall);\n        }\n    }\n    if(wall){\n        pl = 1;\n    }\n    printf(\"%d\\n\",n-cnt+2*cnt-1-pl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n\tint si[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, w, h;\nint x[40000], y[40000];\nmap<int,vector<int> > xx, yy;\nmap<int,vector<int> >::iterator it;\nbool edge;\nUF uf;\n\nint main(){\n    cin >> n >> w >> h;\n    uf.init(n);\n    rep(i,n){\n        cin >> x[i] >> y[i];\n        xx[x[i]].push_back(i);\n        yy[y[i]].push_back(i);\n        if(x[i] == 1 || x[i] == w || y[i] == 1 || y[i] == h) edge = true;\n    }\n    for(it = xx.begin(); it != xx.end(); it++){\n        vector<int> hoge = (*it).second;\n        for(int i = 1; i < hoge.size(); i++){\n            uf.unite(hoge[0],hoge[i]);\n        }\n    }\n    for(it = yy.begin(); it != yy.end(); it++){\n        vector<int> hoge = (*it).second;\n        for(int i = 1; i < hoge.size(); i++){\n            uf.unite(hoge[0],hoge[i]);\n        }\n    }\n    int ans = n-1;\n    int cnt = 0;\n    rep(i,n){\n        if(i == uf.par[i]) cnt++;\n    }\n    if(cnt != 1){\n        ans += cnt;\n        if(edge) ans--;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n    vector<int> par;\n    int cnt;\npublic:\n    UnionFind(int size_) : par(size_, -1), cnt(size_) { }\n    void unite(int x, int y){\n        if ((x = find(x)) != (y = find(y))) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y]; par[y] = x; cnt--;\n        }\n    }\n    bool same(int x, int y){ return find(x) == find(y); }\n    int find(int x){ return par[x] < 0 ? x : par[x] = find(par[x]); }\n    int size(int x){ return -par[find(x)]; }\n    int size(){ return cnt; }\n};\n\nint N, W, H;\nmap<int, vector<int>> Xs, Ys;\n\nint main(){\n    cin >> N >> W >> H;\n    for(int i=0; i<N; i++){\n        int x, y; cin >> x >> y;\n        if(Xs.find(x) == Xs.end()) Xs[x] = vector<int>();\n        if(Ys.find(y) == Ys.end()) Ys[y] = vector<int>();\n        Xs[x].push_back(i);\n        Ys[y].push_back(i);\n    }\n    \n    UnionFind uf = UnionFind(N);\n    auto l = {Xs, Ys};\n    for(auto X: l){\n        for(auto u: X){\n            for(int i=0; i<u.second.size()-1; i++){\n                uf.unite(u.second[i], u.second[i+1]);\n            }\n        }\n    }\n    \n    map<int, int> sizes;\n    for(int i=0; i<N; i++){\n        sizes[uf.find(i)] = uf.size(i);\n    }\n    \n    int ans = 0;\n    for(auto v: sizes){\n        ans += v.second-1;\n    }\n    \n    if(uf.size() != 1){\n       ans += 2*uf.size() - 1;\n        if(Xs.count(1) || Xs.count(W) || Ys.count(1) || Ys.count(H))\n            ans--;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 24;\n\nconstexpr int kMaxXY = 1e5 + 1;\nconstexpr int kN = 1e5 * 4;\n\nint memox[kMaxXY];\nint memoy[kMaxXY];\nint p[kN];\n\nint root(int idx){\n    if(p[idx] == idx) return idx;\n\n    return p[idx] = root(p[idx]);\n}\n\nint main(void){\n    for(int n, w, h; cin >> n >> w >> h;){\n        int numIdx = 0;\n        vi cnt(n);\n\n        // x = 0, x = w - 1, y = 0, y = h - 1\n        vvi cntSumi(n, vi(4));\n\n        fill(memox, memox + kMaxXY, -1);\n        fill(memoy, memoy + kMaxXY, -1);\n\n        rep(loop, n){\n            int x, y; cin >> x >> y; x--, y--;\n            int idx; //root\n            \n            if(memox[x] != -1 && memoy[y] != -1){\n                idx = root(memox[x]);\n\n                if(root(memox[x]) != root(memoy[y])){\n                    //union r2 -> r1(new root)\n                    int r1 = idx, r2 = root(memoy[y]);\n\n                    cnt[r1] += cnt[r2]; cnt[r2] = 0;\n                    rep(i, 4) cntSumi[r1][i] += cntSumi[r2][i], cntSumi[r2][i] = 0;\n\n                    p[r2] = idx;\n                }\n            }\n            else if(memox[x] != -1){\n                idx = memoy[y] = root(memox[x]);\n            }\n            else if(memoy[y] != -1){\n                idx = memox[x] = root(memoy[y]);\n            }\n            else {\n                p[numIdx] = numIdx;\n                idx = memox[x] = memoy[y] = numIdx++;\n            }\n\n            if(x ==   0) cntSumi[idx][0]++;\n            if(x == w-1) cntSumi[idx][1]++;\n            if(y ==   0) cntSumi[idx][2]++;\n            if(y == h-1) cntSumi[idx][3]++;\n\n            cnt[idx]++;\n        }\n\n        int res = 0, numS = 0;\n        vi numSumi(4);\n        rep(i, numIdx){\n            if(cnt[i] != 0) res += cnt[i] - 1, numS++;\n\n            rep(j, 4){\n                if(cntSumi[i][j] != 0){\n                    numSumi[j]++;\n                }\n            }\n        }\n        if(numS != 1) res += (numS - *max_element(all(numSumi))) + numS - 1;\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct UnionFind {\n    vector<int> par;\n    int n, cnt;\n    UnionFind(const int& x = 0) {init(x);}\n    void init(const int& x) {par.assign(cnt=n=x, -1);}\n    inline int find(const int& x) {return par[x] < 0 ? x : par[x] = find(par[x]);}\n    inline bool same(const int& x, const int& y) {return find(x) == find(y);}\n    inline bool unite(int x, int y) {\n        if ((x = find(x)) == (y = find(y))) return false;\n        --cnt;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    inline int count() const {return cnt;}\n    inline int count(int x) {return -par[find(x)];}\n};\n\nconst int MAXN = 100100;\nint X[MAXN], Y[MAXN];\nvi Xp[MAXN], Yp[MAXN];\nint flag[MAXN];\nbool done[MAXN];\nint cnt[4];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, H, W;\n    cin >> N >> H >> W;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i];\n        Xp[X[i]].push_back(i);\n        Yp[Y[i]].push_back(i);\n    }\n    UnionFind uf(N);\n    for (int i = 0; i < MAXN; i++) {\n        for (int j = 1; j < Xp[i].size(); j++)\n            uf.unite(Xp[i][j], Xp[i][0]);\n        for (int j = 1; j < Yp[i].size(); j++)\n            uf.unite(Yp[i][j], Yp[i][0]);\n    }\n    for (int i = 0; i < N; i++) {\n        int p = uf.find(i);\n        if (X[i] == 1) flag[p] |= 1;\n        if (X[i] == W) flag[p] |= 2;\n        if (Y[i] == 1) flag[p] |= 4;\n        if (Y[i] == H) flag[p] |= 8;\n    }\n    int ans = 0;\n    int sz = 0;\n    for (int i = 0; i < N; i++) {\n        int p = uf.find(i);\n        if (!done[p]) {\n            done[p] = true;\n            sz++;\n            ans += uf.count(p)-1;\n            for (int j = 0; j < 4; j++) {\n                if ((flag[p]>>j)&1) {\n                    cnt[j]++;\n                }\n            }\n        }\n    }\n    if (uf.count() > 1) {\n        int plus = MAXN;\n        for (int j = 0; j < 4; j++) {\n            plus = min(plus, sz-cnt[j] + sz-1);\n        }\n        ans += plus;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    // x, y????????????\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    // x, y?????????????????????1\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // x??????????????????????????§???????????????\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // ?????¢??????????????????????????°?????????\n    int setNum(void) {\n        map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n    void print(void) {\n        auto c = getUnionList();\n        for (auto x : c) {\n            for (auto y : x) \n                cout << y << \" \";\n            cout << endl;\n        }\n    }\n};\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, nx, ny; cin >> n >> nx >> ny;\n    vector<P> s(n);\n    \n    vll vx(nx), vy(ny);\n    vll rx(nx, -1), ry(ny, -1);\n    vvll wall(n, vll(4));\n    bool is_wall = 0;\n    rep(i, n) {\n        cin >> s[i].fi >> s[i].se; s[i].fi--; s[i].se--;\n        rx[s[i].fi] = i;\n        ry[s[i].se] = i;\n        wall[i][0] = s[i].fi == 0;\n        wall[i][1] = s[i].fi == nx-1;\n        wall[i][2] = s[i].se == 0;\n        wall[i][3] = s[i].se == ny-1;\n        is_wall = (s[i].fi == 0 || s[i].fi == nx-1 || s[i].se == 0 || s[i].se == ny-1);\n    }\n\n    UnionFind uf(n);\n    rep(i, n) {\n        uf.unite(i, rx[s[i].fi]);\n        uf.unite(i, rx[s[i].se]);\n    }\n    /*\n    cout << \"####\" << endl;\n    uf.print();\n    cout << \"####\" << endl;\n    */\n\n    auto list = uf.getUnionList();\n//    cout << list << endl;\n    if (list.size() == 1) {\n        cout << (*list.begin()).size() - 1 << endl;\n        return 0;\n    }\n\n    /*\n    map<ll, vll> wall_list;\n//    vll wall(4);\n    for (auto x : list) {\n        auto tmp = vll(4);\n        rep(i, x.size()) {\n            rep(j, 4) {\n                tmp[j] |= wall[x[i]][j];\n            }\n        }\n        wall_list[x] = tmp;\n    }\n//    cout << wall_list << endl;\n    */\n\n    ll ret = 0;\n    for (auto x : list) {\n        ret += x.size() - 1;\n    }\n    cout << ret + 3 - is_wall << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nvector<int> x[100005];\nvector<int> y[100005];\n\nint main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  rep(i,n){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    x[p].pb(i);\n    y[q].pb(i);\n  }\n\n  UnionFind uf(n);\n\n  rep(i,100005){\n    rep(j,x[i].size()-1) uf.unite(x[i][j], x[i][j+1]);\n  }\n  rep(i,100005){\n    rep(j,y[i].size()-1) uf.unite(y[i][j], y[i][j+1]);\n  }\n\n  if(uf.size(0)==n){ cout << n-1 << endl; }\n  else {\n    int uniqx = 0, uniqy = 0;\n    rep(i,100005) if(x[i].size()>0) uniqx++;\n    rep(i,100005) if(y[i].size()>0) uniqy++;\n\n    int ans = min({\n      n - x[0].size() + uniqy - 1,\n      n - x[w-1].size() + uniqy - 1,\n      n - y[0].size() + uniqx - 1,\n      n - y[h-1].size() + uniqx - 1\n    });\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n\n#define int long long\nint union_tree[100000];\nint union_find(int now) {\n    if (union_tree[now] == now) return now;\n    return union_tree[now] = union_find(union_tree[now]);\n}\nint union_merge(int a, int b) {\n    a = union_find(a);\n    b = union_find(b);\n    union_tree[a] = b;\n    return 1;\n}\nvector<int> yoko[200000];\nvector<int> tate[200000];\nvoid solve() {\n    int n, h, w;\n    cin >> n >> h >> w;\n    REP(i, n) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        yoko[a].push_back(i);\n        tate[b].push_back(i);\n        union_tree[i] = i;\n    }\n    REP(i, h) {\n        for (int q = 1; q < yoko[i].size(); ++q) {\n            union_merge(yoko[i][q - 1], yoko[i][q]);\n        }\n    }\n    REP(i, w) {\n        for (int q = 1; q < tate[i].size(); ++q) {\n            union_merge(tate[i][q - 1], tate[i][q]);\n        }\n    }\n    int ans = 0;\n    int cnt = 0;\n    REP(i, n) {\n        if (union_find(i) != i) {\n            ans++;\n            continue;\n        }\n        cnt++;\n    }\n    if (cnt > 1) {\n        int hoge = cnt + (cnt - 1);\n        if (yoko[0].size() != 0 || yoko[h - 1].size() != 0 || tate[0].size() != 0 || tate[w - 1].size() != 0) {\n            hoge--;\n        }\n        ans += hoge;\n    }\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[i] < 0) memoX[x] = i;//???????????????????????????????????\\??£????????¨???????????°X[???]=????????????????????\\??????\n\t\telse ds.unite(i, memoX[x]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[i] < 0) memoY[y] = i;\n\t\telse ds.unite(i, memoY[y]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\n\t//printf(\"%d\\n\", m);\n\tif(m > 1){\n\t\tif(cornerw == true || cornerh == true){\n\t\t\tprintf(\"%d\\n\", n + m - 2);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\", n + m - 1);\n\t\t}\n\t}else{\n\t\tprintf(\"%d\\n\", n - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nint n,w,h;\n\nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\nint ne[200002]={0};\n\n   signed main(){\ncin>>n>>w>>h;\n   \t\n   \tshoki(200002);\n   \tfor(int i=0;i<n;i++){\n   \t\tint y,x;\n   \t\tcin>>y>>x;\n   \t\tunite(y,h+x);\n   \t}\n   \tint cnt=0;\n   \tbool bo=false;\n   \tfor(int i=0;i<=h+w+1;i++)if(i==root(i)){\n   \t\tne[i]=1;\n   \t\t\n   \t\tif(kosuu[i]>1){\n   \t\t\tcnt++;\n   \t\t\t\n   \t\t}\n   \t}\n   \t\n   \t\tif(kosuu[root(1)]>1)bo=1;\n   \t\tif(kosuu[root(h)]>1)bo=1;\n   \t\tif(kosuu[root(h+1)]>1)bo=1;\n   \t\tif(kosuu[root(h+w)]>1)bo=1;\n   \tif(cnt==1){\n   \tcout<<n-1<<endl;\n   \treturn 0;\n   \t}\n   \t\tint mae=n-cnt;\n   \t\tmae+=(cnt-1)*2;\n   \t\tif(!bo)mae++;\n   \t\tcout<<mae<<endl;\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint par[40005],ran[40005];\nvoid init(){ for(int i=0;i<40005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\nvector<int>X[100005],Y[100005];\nbool peri;\nint main(){\n\tint n,w,h; scanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tX[a].pb(i);\n\t\tY[b].pb(i);\n\t\tif(a == 1 || a == w || b == 1 || b == h) peri = 1;\n\t}\n\tinit();\n\trep(i,100005){\n\t\trep(j,X[i].size()){\n\t\t\tif(j) unite(X[i][j-1],X[i][j]);\n\t\t}\n\t\trep(j,Y[i].size()){\n\t\t\tif(j) unite(Y[i][j-1],Y[i][j]);\n\t\t}\n\t\t\n\t}\n\tint cmp = 0;\n\trep(i,n) if(find(i) == i) cmp++;\n\tint ans = n+cmp-1;\n\tif(cmp == 1 || peri) ans--;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\n\n// Kruskal\n// N, operator <\nEdges kruskal(int V, Edges &es) {\n  sort(es.rbegin(), es.rend());\n  UnionFind uf(V);\n  Edges res;\n  REP(i, es.size()) {\n    Edge e = es[i];\n    if(uf.root(e.src) != uf.root(e.dest)) {\n      uf.merge(e.src, e.dest);\n      res.push_back(e);\n    }\n  }\n  return res;\n}\n\nint check(const Edges& ve, const vector<int>& id, int len, const vector<bool> &cond, int n) {\n  auto tmp = ve;\n  int cnt = 0;\n  FOR(i,1,len+1) {\n    if (id[i] >= 0) {\n      tmp.push_back((Edge){id[i], n+cnt, !cond[i]});\n      if(cnt) tmp.push_back((Edge){n+cnt, n, 1});\n      ++cnt;\n    }\n  }\n  auto rve = kruskal(n+cnt,tmp);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n+cnt-1) return sum;\n  else return INF;\n}\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  vector<int> ix(w+1,-1);\n  vector<bool> ixx(w+1);\n  vector<bool> ixn(w+1);\n  vector<int> iy(h+1,-1);\n  vector<bool> iyx(h+1);\n  vector<bool> iyn(h+1);\n  Edges ve;\n  REP(i,n) {\n    int x,y;\n    cin>>x>>y;\n    if (ix[x] == -1) {\n      ix[x] = i;\n      ixx[x] = y == h;\n      ixn[x] = y == 1;\n    } else {\n      ixx[x] = ixx[x] || y == h;\n      ixn[x] = ixn[x] || y == 1;\n      ve.push_back((Edge){i, ix[x], 1});\n    }\n    if (iy[y] == -1) {\n      iy[y] = i;\n      iyx[y] = x == w;\n      iyn[y] = x == 1;\n    } else {\n      iyx[y] = iyx[y] || x == w;\n      iyn[y] = iyn[y] || x == 1;\n      ve.push_back((Edge){i, iy[y], 1});\n    }\n  }\n  int res = INF;\n  auto rve = kruskal(n,ve);\n  int sum = 0;\n  for (auto e:rve) sum += e.weight;\n  if ((int)rve.size() == n-1) res = min(res, sum);\n  res = min(res, check(ve, ix, w, ixn, n));\n  res = min(res, check(ve, ix, w, ixx, n));\n  res = min(res, check(ve, iy, h, iyn, n));\n  res = min(res, check(ve, iy, h, iyx, n));\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<numeric>\n\n\nusing namespace std;\n\nint par[40000];\nint bit[40000];\nint xx[100001],yy[100001];\nbool bx[100001],by[100001];\n\nint find(int x){\n  return (x==par[x])?x:(par[x]=find(par[x]));\n}\n\nvoid unite(int a,int b){\n  int r=find(a);\n  bit[r]|=bit[b];\n  par[find(b)]=r;\n}\n\nint main(){\n  iota(begin(par),end(par),0);\n  int N,W,H;\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin>>x>>y;\n    bit[i]=(x==1)|(x==W)<<1|(y==1)<<2|(y==H)<<3;\n    if(!bx[x]++){\n      xx[x]=i;\n    }else{\n      unite(xx[x],i);\n    }\n    if(!by[y]++){\n      yy[y]=i;\n    }else{\n      unite(yy[y],i);\n    }\n  }\n  int ans=1<<29;\n  for(int i=0;i<4;i++){\n    int p=0,c=0;\n    for(int j=0;j<N;j++){\n      p+=find(j)==j;\n      c+=find(j)==j&&!(bit[j]>>i&1);\n    }\n    ans=min(ans,(p==1)?N-1:c+N-1);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i < 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint par[240000];\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tpar[find(x)]=find(y);\n}\nint main(){\n\tint N,W,H;\n\tcin>>N>>W>>H;\n\trep(i,N+W+H) par[i]=i;\n\trep(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tunite(i,N+x);\n\t\tunite(i,N+W+y);\n\t}\n\tset<int> st;\n\trep(i,N) st.insert(find(i));\n\tint x=st.size();\n\tif(x==1){\n\t\tcout<<N-1<<endl;\n\t\treturn 0;\n\t}\n\tint a=0;\n\trep(i,N){\n\t\tif(same(i,N)||same(i,N+W-1)||same(i,N+W)||same(i,N+W+H-1)) a=1;\n\t}\n\tcout<<N-1-a+x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 40010\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint p[MAX];\nint n,h,w,ans=0;\nint x[MAX],y[MAX];\nvector<pii> a,b;\nbool lr[MAX]={},ud[MAX]={};\n\nint find(int a){\n  if(p[a]==a)return a;\n  int pa=find(p[a]);\n  p[a]=pa;\n  return pa;\n}\n\nvoid unite(int a,int b){\n  int pa=find(a),pb=find(b);\n  p[pa]=pb;\n}\n\nbool same(int a,int b){\n  return find(a)==find(b);\n}\n\nint main()\n{\n  cin>>n>>w>>h;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    a.push_back(mp(x[i],i));\n    b.push_back(mp(y[i],i));\n    if(y[i]==1 || y[i]==h)ud[i]=true;\n    if(x[i]==1 || x[i]==w)lr[i]=true;\n  }\n\n  for(int i=0;i<MAX;i++)p[i]=i;\n\n  sort(a.begin(),a.end());\n  sort(b.begin(),b.end());\n\n  for(int i=1;i<n;i++){\n    if(a[i-1].f==a[i].f && !same(a[i-1].s,a[i].s)){\n      unite(a[i-1].s,a[i].s);\n      ans++;\n      ud[i]|=ud[i-1];\n      ud[i-1]|=ud[i];\n      lr[i]|=lr[i-1];\n      lr[i-1]|=lr[i];\n    }\n    if(b[i-1].f==b[i].f && !same(b[i-1].s,b[i].s)){\n      unite(b[i-1].s,b[i].s);\n      ans++;\n      ud[i]|=ud[i-1];\n      ud[i-1]|=ud[i];\n      lr[i]|=lr[i-1];\n      lr[i-1]|=lr[i];\n    }\n  }\n\n  if(ans!=n-1){\n    int sum1=0,sum2=0;\n    for(int i=0;i<n;i++)if(p[i]==i)sum1++;\n    sum1=(sum1*2-1);\n    sum2=sum1;\n    for(int i=0;i<n;i++)if(p[i]==i && lr[i])sum1--;\n    for(int i=0;i<n;i++)if(p[i]==i && ud[i])sum2--;\n    ans=min(ans+sum1,ans+sum2);\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\n\nint calc(vector<P> ps, int L){\n  map<int, vector<P> > m;\n  REP(i, ps.size()) m[ps[i].first].push_back(ps[i]);\n  int res = m.size() - 1;\n  FORIT(it, m){\n    vector<P>& pv = it->second;\n    if(binary_search(pv.begin(), pv.end(), P(it->first, L)) || m.size() == 1){\n      res += pv.size() - 1;\n    }else{\n      res += pv.size();\n    }\n    \n  }\n  return res;\n}\n\nint main(){\n  int N, W, H;\n  while(cin >> N >> W >> H){\n    vector<P> ps(N);\n    REP(i, N) cin >> ps[i].first >> ps[i].second;\n    int ans = INF;\n    ans = min(ans, calc(ps, 1));\n    ans = min(ans, calc(ps, H));\n    REP(i, N) swap(ps[i].first, ps[i].second);\n    ans = min(ans, calc(ps, 1));\n    ans = min(ans, calc(ps, W));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\n\nint N;\nint W, H;\nvector<tuple<int, int, int> > tupX, tupY;\n\nint parent[40005];\n\nvoid init(){\n\tfor(int i = 0; i < N; i++) parent[i] = i;\n}\n\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nint main(void)\n{\n\tcin >> N >> W >> H;\n\t\n\tbool flag = false;\n\tint x, y;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x >> y;\n\t\tif(x == 1 || x == W || y == 1 || y == H) flag = true;\n\t\ttupX.push_back( make_tuple(x, y, i) );\n\t\ttupY.push_back( make_tuple(y, x, i) );\n\t}\n\tsort(tupX.begin(), tupX.end());\n\tsort(tupY.begin(), tupY.end());\n\t\n\tinit();\n\tfor(int i = 1; i < tupX.size(); i++){\n\t\tif(get<0>(tupX[i]) == get<0>(tupX[i-1])){\n\t\t\tunite( get<2>(tupX[i]), get<2>(tupX[i-1]) );\n\t\t}\n\t}\n\tfor(int i = 1; i < tupY.size(); i++){\n\t\tif(get<0>(tupY[i]) == get<0>(tupY[i-1])){\n\t\t\tunite( get<2>(tupY[i]), get<2>(tupY[i-1]) );\n\t\t}\n\t}\n\t\n\tint cnt = 0;\n\tfor(int i = 0; i < N; i++) if(parent[i] == i) cnt++;\n\t\n\tint ans = (N-1);\n\tif(cnt > 1){\n\t\tans += cnt;\n\t\tif(flag) ans--;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nint n,w,h;\n\nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\nint ne[200002]={0};\n\n   signed main(){\ncin>>n>>w>>h;\n   \t\n   \tshoki(200002);\n   \tfor(int i=0;i<n;i++){\n   \t\tint y,x;\n   \t\tcin>>y>>x;\n   \t\tunite(x,h+y);\n   \t}\n   \tint cnt=0;\n   \tbool bo=false;\n   \tfor(int i=0;i<=h+w+1;i++)if(i==root(i)){\n   \t\tne[i]=1;\n   \t\t\n   \t\tif(kosuu[i]>1){\n   \t\t\tcnt++;\n   \t\t\t\n   \t\t}\n   \t}\n   \t\n   \t\tif(kosuu[root(1)]>1)bo=1;\n   \t\tif(kosuu[root(h)]>1)bo=1;\n   \t\tif(kosuu[root(h+1)]>1)bo=1;\n   \t\tif(kosuu[root(h+w)]>1)bo=1;\n   \tif(cnt==1){\n   \tcout<<n-1<<endl;\n   \t//\tcout<<\"r\"<<endl;\n   \treturn 0;\n   \t}\n   \t\tint mae=n-cnt;\n   \t\tmae+=(cnt-1)*2;\n   \t\tif(!bo)mae++;\n   \t\tcout<<mae<<endl;\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\ntypedef int Weight;\nWeight INF = 1000000000;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) : parent(n, -1) {}\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  vector<int> ix(w+1,-1);\n  vector<int> iy(h+1,-1);\n  bool edge = false;\n  UnionFind uf(n);\n  REP(i,n) {\n    int x,y;\n    cin>>x>>y;\n    if(x==1||x==w||y==1||y==h) edge = true;\n    if (ix[x] == -1) {\n      ix[x] = i;\n    } else {\n      uf.merge(i, ix[x]);\n    }\n    if (iy[y] == -1) {\n      iy[y] = i;\n    } else {\n      uf.merge(i, iy[y]);\n    }\n  }\n  set<int> rt;\n  REP(i,n) rt.insert(uf.root(i));\n  if (rt.size() == 1) {\n    cout << (n-1) << endl;\n  } else {\n    int cnt = n-1+rt.size();\n    cout << (cnt-(edge?1:0)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n,w,h;\nint par[40001],rank[40001];\nint x[40001],y[40001];\nint ux[2][40001],uy[2][40001];\nvector<int> xid[100001],yid[100001];\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(rank[x]>rank[y]){\n\t\tpar[y]=x;\n\t}else{\n\t\tif(rank[x]==rank[y]){\n\t\t\trank[y]++;\n\t\t}\n\t\tpar[x]=y;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(void){\n\tscanf(\"%d %d %d\",&n,&w,&h);\n\tbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\txid[x[i]].push_back(i);\n\t\tyid[y[i]].push_back(i);\n\t\tif(x[i]==w || x[i]==1 || y[i]==1 || y[i]==h)flag=true;\n\t}\n\tinit();\n\tint cnt=0;\n\tfor(int i=1;i<=w;i++){\n\t\tfor(int j=0;j<(int)xid[i].size()-1;j++){\n\t\t\tif(same(xid[i][j],xid[i][j+1]))continue;\n\t\t\tcnt++;\n\t\t\tunite(xid[i][j],xid[i][j+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=0;j<(int)yid[i].size()-1;j++){\n\t\t\tif(same(yid[i][j],yid[i][j+1]))continue;\n\t\t\tcnt++;\n\t\t\tunite(yid[i][j],yid[i][j+1]);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(!same(0,i)){\n\t\t\tif(flag){\n\t\t\t\tcnt+=2;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcnt+=3;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tunite(0,i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,h,w;\nvvi a,b;\nmap<int,int> mx,my;\n\nint main(){\n\tcin>>n>>w>>h;\n\tUnion_Find_Tree uft(n);\n\tint cx=0,cy=0;\n\ta=b=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(mx.find(x)==mx.end()) mx[x]=cx++;\n\t\tif(my.find(y)==my.end()) my[y]=cy++;\n\t\ta[mx[x]].push_back(i);\n\t\tb[my[y]].push_back(i);\n\t}\n\tfor(int i=0;i<n;i++) for(int j=1;j<a[i].size();j++) uft.Unite(a[i][j],a[i][j-1]);\n\tfor(int i=0;i<n;i++) for(int j=1;j<b[i].size();j++) uft.Unite(b[i][j],b[i][j-1]);\n\tvi used(n);\n\tint res=n-3;\n\tfor(int i=0;i<n;i++){\n\t\tint p=uft.Find_Par(i);\n\t\tif(!used[p]){\n\t\t\tused[p]=1;\n\t\t\tres+=2;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 40001;\nconst int INF = 1<<28;\nint N;\nint X[MAXN], Y[MAXN];\nbool vis[MAXN];\nvector<pair<pair<int,int>,int> > xy, yx;\n\nint dfs(int v) {\n  const int &x = X[v];\n  const int &y = Y[v];\n  vis[v] = true;\n  int res = 1;\n\n  int begin, end;\n\n  begin =\n    lower_bound(xy.begin(), xy.end(), make_pair(make_pair(x,-INF),-INF))\n    - xy.begin();\n  end =\n    upper_bound(xy.begin(), xy.end(), make_pair(make_pair(x, INF), INF))\n    - xy.begin();\n  for(int i = begin; i < end; ++i) {\n    int nv = xy[i].second;\n    if(!vis[nv]) {\n      res += dfs(nv);\n    }\n  }\n\n  begin =\n    lower_bound(yx.begin(), yx.end(), make_pair(make_pair(y,-INF),-INF))\n    - yx.begin();\n  end =\n    upper_bound(yx.begin(), yx.end(), make_pair(make_pair(y, INF), INF))\n    - yx.begin();\n  for(int i = begin; i < end; ++i) {\n    int nv = yx[i].second;\n    if(!vis[nv]) {\n      res += dfs(nv);\n    }\n  }\n\n  return res;\n}\n\nint main() {\n  int h, w;\n  cin >> N >> w >> h;\n  bool kabegiwa = false;\n  for(int i = 0; i < N; ++i) {\n    int &x = X[i];\n    int &y = Y[i];\n    cin >> x >> y;\n    xy.push_back(make_pair(make_pair(x,y),i));\n    yx.push_back(make_pair(make_pair(y,x),i));\n    if(x == 1 || x == w || y == 1 || y == h) {\n      kabegiwa = true;\n    }\n  }\n  sort(xy.begin(), xy.end());\n  sort(yx.begin(), yx.end());\n  fill(vis, vis+N, false);\n  int num = 0;\n  int ans = 0;\n  for(int i = 0; i < N; ++i) {\n    if(!vis[i]) {\n      ++num;\n      ans += dfs(i) - 1;\n    }\n  }\n  if(num != 1 && !kabegiwa) {\n    ans += 1;\n  }\n  ans += (num-1) * 2;\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct UnionFind {\npublic:\n  int n;\n  std::vector<int> par;\n  UnionFind(int n): n(n) {\n    par.resize(n, -1);\n  }\n  int root(int x) {\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = root(x), ry = root(y);\n    if(rx == ry) return;\n    if(par[rx] < par[ry]) {\n      std::swap(x, y);\n      rx = root(x), ry = root(y);\n    }\n    par[rx] += par[ry];\n    par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return -par[root(x)];\n  }\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, w, h; cin >> n >> w >> h;\n  vi tmp = {0, h-1, 0, w-1};\n  vi x(n), y(n);\n  map<int, vi> mpx, mpy;\n  for(int i=0;i<n;++i) {\n    cin >> x[i] >> y[i];\n    x[i]--;\n    y[i]--;\n    mpx[x[i]].push_back(i);\n    mpy[y[i]].push_back(i);\n  }\n  UnionFind uf(n);\n  for(auto &e: mpx) {\n    for(int i=0;i<(int)(e.second.size())-1;++i) {\n      uf.unite(e.second[i], e.second[i+1]);\n    }\n  }\n  for(auto &e: mpy) {\n    for(int i=0;i<(int)(e.second.size())-1;++i) {\n      uf.unite(e.second[i], e.second[i+1]);\n    }\n  }\n  set<int> st;\n  for(int i=0;i<n;++i) {\n    st.insert(uf.root(i));\n  }\n  int ans = 0;\n  for(auto &e: st) {\n    ans += uf.size(e) - 1;\n  }\n  map<int, vi> mp;\n  for(int i=0;i<n;++i) {\n    mp[uf.root(i)].push_back(i);\n  }\n  map<int, int> mp2;\n  for(auto &e1: mp) {\n    for(int i=0;i<4;++i) {\n      int mi = 1;\n      for(auto &e2: e1.second) {\n        if(i < 2) mi = min(mi, (int)(y[e2] != tmp[i]));\n        else mi = min(mi, (int)(x[e2] != tmp[i]));\n      }\n      mp2[i] += mi;\n    }\n  }\n  int mi = INF;\n  for(int i=0;i<4;++i) {\n    mi = min(mi, mp2[i]);\n  }\n  cout << ans + (int)(st.size()) - 1 + ((int)(st.size()) > 1) * mi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint* parent, *height;\nint unite_count;\n\nstruct Info{\n\tint x,y;\n};\n\n\nint find_parent(int id){\n\tif(parent[id] == id){\n\t\treturn id;\n\t}else{\n\t\treturn parent[id] == find_parent(parent[id]);\n\t}\n}\n\nbool isSame(int left,int right){\n\treturn find_parent(left) == find_parent(right);\n}\n\nvoid unite(int left,int right){\n\n\tint left_parent = find_parent(left);\n\tint right_parent = find_parent(right);\n\n\tif(left_parent == right_parent)return;\n\n\tif(height[left_parent] >= height[right_parent]){\n\t\tif(height[left_parent] == height[right_parent]){\n\t\t\theight[left_parent]++;\n\t\t}\n\t\tparent[right_parent] = left_parent;\n\n\t}else{\n\t\tparent[left_parent] = right_parent;\n\t}\n\n\tunite_count++;\n}\n\n\nint main(){\n\n\tint N,W,H;\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tunite_count = 0;\n\n\tparent = new int[N+1];\n\theight = new int[N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N+1));\n\tvector<int> X[W+1],Y[H+1];\n\n\tfor(int id = 1; id <= N; id++){\n\t\tscanf(\"%d %d\",&info[id].x,&info[id].y);\n\t\tX[info[id].x].push_back(id);\n\t\tY[info[id].y].push_back(id);\n\t}\n\n\tfor(int i = 1; i <= W;i++){\n\n\t\tif(X[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < X[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < X[i].size();p++){\n\t\t\t\tunite(X[i][k],X[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= H; i++){\n\n\t\tif(Y[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < Y[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < Y[i].size();p++){\n\t\t\t\tunite(Y[i][k],Y[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstack<int> GroupID;\n\n\tint group_num = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(parent[i] == i){\n\t\t\tgroup_num++;\n\t\t\tGroupID.push(i);\n\t\t}\n\t}\n\n\tint Loc_num[4],id;\n\tfor(int i = 0; i < 4; i++)Loc_num[i] = 0;\n \tbool check[4];\n\n\twhile(!GroupID.empty()){\n\t\tid = GroupID.top();\n\t\tGroupID.pop();\n\n\t\tfor(int i = 0; i < 4; i++)check[i] = false;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(parent[i] == id){\n\t\t\t\tif(info[i].x == 1){\n\t\t\t\t\tcheck[0] = true;\n\t\t\t\t}else if(info[i].x == W){\n\t\t\t\t\tcheck[1] = true;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].y == 1){\n\t\t\t\t\tcheck[2] = true;\n\t\t\t\t}else if(info[i].y == H){\n\t\t\t\t\tcheck[3] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(check[i]){\n\t\t\t\tLoc_num[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_kabe = 0,tmp;\n\n\tfor(int i = 0; i < 4; i++)max_kabe = max(max_kabe,Loc_num[i]);\n\n\tint ans = unite_count;\n\n\tif(group_num != 1){\n\t\ttmp = group_num-max_kabe;\n\n\t\tans += tmp + group_num-1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Loc{\n\tLeft,\n\tRight,\n\tTop,\n\tBottom,\n};\n\nstruct Info{\n\tint x,y;\n};\n\nint N,unite_count;\nint* boss,*height;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint isSame(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tx = get_boss(x);\n\ty = get_boss(y);\n\n\tif(x == y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[y] = x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[x] = y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[y] = x;\n\t\theight[x]++;\n\t}\n\n\tunite_count++;\n}\n\nint main(){\n\n\tint N,W,H;\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tboss = new int[N];\n\theight = new int[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N));\n\tvector<int> X[W+1],Y[H+1];\n\n\tint min_x = BIG_NUM,min_y=BIG_NUM,max_x=0,max_y=0;\n\n\tfor(int id = 0; id < N; id++){\n\t\tscanf(\"%d %d\",&info[id].x,&info[id].y);\n\t\tX[info[id].x].push_back(id);\n\t\tY[info[id].y].push_back(id);\n\t\tmin_x = min(min_x,info[id].x);\n\t\tmin_y = min(min_y,info[id].y);\n\t\tmax_x = max(max_x,info[id].x);\n\t\tmax_y = max(max_y,info[id].y);\n\t}\n\n\tfor(int i = 1; i <= W;i++){\n\n\t\tif(X[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < X[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < X[i].size();p++){\n\t\t\t\tunite(X[i][k],X[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= H; i++){\n\n\t\tif(Y[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < Y[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < Y[i].size();p++){\n\t\t\t\tunite(Y[i][k],Y[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint group_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] == i){\n\t\t\tgroup_num++;\n\t\t}\n\t}\n\n\tint kabe_num = 0,tmp;\n\tif(min_x == 1 || max_x == W || min_y == 1 || max_y == H){\n\t\tkabe_num = 1;\n\t}\n\n\tint ans = unite_count;\n\n\tif(group_num != 1){\n\t\ttmp = group_num-kabe_num;\n\n\t\tans += tmp + group_num-1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,h,w;\n\nstruct unionFind{\n  unionFind(int n){\n    init(n);\n  }\n  vector<int> par,size;\n  int grup;\n  void init(int n){\n    grup=n;\n    par.resize(n);\n    size.resize(n);\n    for(int i=0;i<n;i++){\n      par[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x]=find(par[x]);\n  }\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n    if(size[x]<size[y]) swap(x,y);\n    par[y] = x;\n    size[x]+=size[y];\n    grup--;\n  }\n  bool same(int x,int y){return find(x) == find(y);}\n  int getg(){return grup;}\n};\n\nmap<int,vector<int> > xx;\nmap<int,vector<int> > yy;\nint main(){\n  cin>>n>>w>>h;\n  bool f;\n  for(int i=0;i<n;i++){\n    int x,y;\n    cin>>x>>y;\n    if(x==1 || y==1 || x==w || y==h) f=1;\n    xx[x].push_back(i);\n    yy[y].push_back(i);\n  }\n  unionFind u(n);\n  \n  map<int,vector<int> >::iterator it;\n  for(it=xx.begin();it!=xx.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  for(it=yy.begin();it!=yy.end();it++){\n    vector<int> &vec = it->second;\n    for(int i=0;i<(int)vec.size()-1;i++){\n      u.unite(vec[i],vec[i+1]);\n    }\n  }\n  int cnt=u.getg();\n  if(cnt==1) cout<<n-cnt<<endl;\n  else cout<<n+cnt-1-f<<endl;     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n/* union_find.cpp {{{ */\nclass UnionFind {\npublic:\n  UnionFind(int n = 0): cnt(n), data(n, -1){}\n  int root(int x) const { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n  bool same(int x, int y) const { return root(x) == root(y); }\n  bool unite(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return false;\n    if (data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    cnt--;\n    return true;\n  }\n  int count() const { return cnt; }\n  int size(int x) const { return -data[root(x)]; }\nprivate:\n  int cnt;\n  mutable vector<int> data;\n};\n/* }}} */\n\nint n, w, h;\nint x[40000], y[40000];\nvector<tuple<int, int, int>> v, u;\nbool f[40000][4];\n\nint main(){\n  cin >> n >> w >> h;\n  rep(i, n) cin >> x[i] >> y[i];\n  rep(i, n){\n    if (x[i] == 1) f[i][0] = true;\n    if (x[i] == w) f[i][1] = true;\n    if (y[i] == 1) f[i][2] = true;\n    if (y[i] == h) f[i][3] = true;\n  }\n  rep(i, n) v.emplace_back(x[i], y[i], i);\n  rep(i, n) u.emplace_back(y[i], x[i], i);\n  sort(all(v)), sort(all(u));\n  UnionFind tr(n);\n  rep(i, n - 1){\n    int ax, ay, ai, bx, by, bi;\n    tie(ax, ay, ai) = v[i];\n    tie(bx, by, bi) = v[i + 1];\n    if (ax == bx){\n      rep(i, 4) f[tr.root(bi)][i] |= f[tr.root(ai)][i];\n      rep(i, 4) f[tr.root(ai)][i] |= f[tr.root(bi)][i];\n      tr.unite(ai, bi);\n    }\n  }\n  rep(i, n - 1){\n    int ay, ax, ai, by, bx, bi;\n    tie(ay, ax, ai) = u[i];\n    tie(by, bx, bi) = u[i + 1];\n    if (ay == by){\n      rep(i, 4) f[tr.root(bi)][i] |= f[tr.root(ai)][i];\n      rep(i, 4) f[tr.root(ai)][i] |= f[tr.root(bi)][i];\n      tr.unite(ai, bi);\n    }\n  }\n  int mn = inf;\n  rep(i, 4){\n    int res = n + tr.count() - 1;\n    rep(j, n) if (tr.root(j) == j && f[j][i]) res--;\n    chmin(mn, res);\n  }\n  if (tr.count() == 1) chmin(mn, n - 1);\n  cout << mn << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint par[40000];\nint bit[40000];\nint xx[100001],yy[100001];\nbool bx[100001],by[100001];\n\nint find(int x){\n  return (x==par[x])?x:par[x]=find(par[x]);\n}\n\nvoid unite(int a,int b){\n  int r=find(a);\n  bit[r]|=bit[b];\n  par[find(b)]=r;\n}\n\nint main(){\n  int N,W,H;\n  cin>>N>>W>>H;\n  for(int i=0;i<N;i++){\n    par[i]=i;\n    int x,y;\n    cin>>x>>y;\n    bit[i]=(x==1)|(x==W)<<1|(y==1)<<2|(y==H)<<3;\n    if(!bx[x]++){\n      xx[x]=i;\n    }else{\n      unite(xx[x],i);\n    }\n    if(!by[y]++){\n      yy[y]=i;\n    }else{\n      unite(yy[y],i);\n    }\n  }\n  int ans=N*2;\n  for(int i=0;i<4;i++){\n    int p=0,c=0;\n    for(int j=0;j<N;j++){\n      if(find(j)==j){\n\tp++;\n\tc+=bit[j]>>i&1^1;\n      }\n    }\n    ans=min(ans,(p==1)?N-1:c+N-1);\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> v[2][100000];\nint n, w, h, x, y, p[40000], r[40000], f, ans;\n\nint find(int x){\n  if(p[x] == x) return x;\n  else return p[x] = find(p[x]);\n}\n\nbool unite(int x, int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return false;\n  if(r[x] < r[y]) p[x] = y;\n  else{\n    p[y] = x;\n    if(r[x] == r[y]) r[x]++;\n  }\n  return true;\n}\n\nmain(){\n  cin >> n >> w >> h;\n  for(int i=0;i<n;i++){\n    cin >> x >> y;\n    x--; y--;\n    if(min(x, y) == 0 || x == w - 1 || y == h - 1) f = 1;\n    v[0][y].push_back(i);\n    v[1][x].push_back(i);\n  }\n  for(int i=0;i<n;i++){\n    p[i] = i;\n    r[i] = 0;\n  }\n  for(int i=0;i<h;i++) for(int j=1;j<v[0][i].size();j++) if(unite(v[0][i][j-1], v[0][i][j])) ans++;\n  for(int i=0;i<w;i++) for(int j=1;j<v[1][i].size();j++) if(unite(v[1][i][j-1], v[1][i][j])) ans++;\n  if(n - ans != 1) ans += (n - ans) * 2 - 1 - f;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (auto i = (c).begin(); i != (c).end(); ++i)\n\nstruct Point {\n  int y, x, index;\n  Point(): y(0), x(0), index(0) {}\n  Point(int y, int x, int index): y(y), x(x), index(index) {}\n};\n\nstruct LessY {\n  bool operator()(const Point& lhs, const Point& rhs) const { return lhs.y < rhs.y; }\n};\n\nstruct LessX {\n  bool operator()(const Point& lhs, const Point& rhs) const { return lhs.x < rhs.x; }\n};\n\nvector<Point> slimes, ysorted, xsorted;\nvector<bool> visit;\n\nint dfs(int i) {\n  if (visit[i]) { return 0; }\n  visit[i] = true;\n\n  int ret = 1;\n  auto range1 = equal_range(ALL(ysorted), Point(slimes[i].y, 0, 0), LessY());\n  for (auto it = range1.first; it != range1.second; ++it) { ret += dfs(it->index); }\n  auto range2 = equal_range(ALL(xsorted), Point(0, slimes[i].x, 0), LessX());\n  for (auto it = range2.first; it != range2.second; ++it) { ret += dfs(it->index); }\n  return ret;\n}\n\nint main() {\n  int N, W, H;\n  while (scanf(\"%d%d%d\", &N, &W, &H) != EOF) {\n    slimes.resize(N);\n    ysorted.resize(N);\n    xsorted.resize(N);\n    visit.assign(N, false);\n\n    int wallside = 0;\n    REP(i, N) {\n      int y, x; scanf(\"%d%d\", &x, &y);\n      slimes[i] = Point(y, x, i);\n      ysorted[i] = xsorted[i] = slimes[i];\n      if (y == 1 || y == H || x == 1 || x == W) { wallside = 1; }\n    }\n    sort(ALL(ysorted), LessY());\n    sort(ALL(xsorted), LessX());\n\n    int ans = 0, n_cc = 0;\n    REP(i, N) {\n      if (!visit[i]) {\n        ans += dfs(i)-1;\n        n_cc += 1;\n      }\n    }\n    if (n_cc > 1) { ans += 2*n_cc - wallside - 1; }\n\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nusing Graph=map<ll,vector<ll>>;\nint main(){\n    ll n,w,h;\n    cin>>n>>w>>h;\n    bool sumi=false;\n    Graph g;\n    for(int i=0;i<n;i++){\n        ll x,y;\n        cin>>x>>y;\n        if(x==1 || x==w || y==1 || y==h) sumi=true;\n        x--,y--;\n        ll from=x*h+y;\n        ll to0=h*w+x;\n        ll to1=h*w+w+y;\n        g[from].push_back(to0);\n        g[from].push_back(to1);\n        g[to0].push_back(from);\n        g[to1].push_back(from);\n    }\n    set<ll> s;\n    int cnt=0;\n\n    function<void(ll)> dfs=[&](ll v){\n        if(s.count(v)) return;\n        s.insert(v);\n        for(auto &to:g[v]) dfs(to);\n    };\n    for(auto &vertex:g){\n        ll v=vertex.first;\n        if(!s.count(v)){\n            cnt++;\n            dfs(v);\n        }\n    }\n    if(cnt==1){\n        cout<<n-1<<endl;\n    }\n    else{\n        if(sumi) cout<<n-1+cnt-1<<endl;\n        else cout<<n-1+cnt<<endl;\n    }\n    return 0;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 40005;\n\nint x[MAX_N],y[MAX_N];\nint n,w,h;\nbool flag[MAX_N];\nvector<int> X[100002],Y[100002];\nvector<int> G[MAX_N];\n\nvoid dfs(int u,bool& hoge)\n{\n    flag[u] = true;\n    if(x[u] == 0 || x[u] == h-1 || y[u] == 0 || y[u] == w-1){\n        hoge = true;\n    }\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],hoge);\n        }\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n        x[i]--,y[i]--;\n        X[x[i]].push_back(i);\n        Y[y[i]].push_back(i);\n\t}\n    rep(i,w){\n        rep(j,Y[i].size()){\n            rep(k,Y[i].size()){\n                if(k != j){\n                    G[Y[i][j]].push_back(Y[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,X[i].size()){\n            rep(k,X[i].size()){\n                if(k != j){\n                    G[X[i][j]].push_back(X[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    int cnt = 0;\n    int pl = 0;\n    bool wall = false;\n    rep(i,n){\n        if(!flag[i]){\n            cnt++;\n            dfs(i,wall);\n        }\n    }\n    if(wall){\n        pl = 1;\n    }\n    if(cnt==1){\n        printf(\"%d\\n\",n-1);\n    }else{\n        printf(\"%d\\n\",n-cnt+2*cnt-1-pl);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nint p[100001],r[100001];\nvoid init(){for(int i=0; i<100001; i++)p[i]=i,r[i]=0;}\nint find(int x){return (p[x]==x)?x:(p[x]=find(p[x]));}\nvoid unite(int x,int y) {\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(r[x]<r[y])p[x]=y;\n  else{p[y]=x;if(r[x]==r[y])r[x]++;}\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nint main() {\n  init();\n  int n,w,h;\n  cin >> n >> w >> h;\n  P a[n];\n  for(int i=0; i<n; i++) cin >> a[i].F >> a[i].S;\n  for(int i=0; i<n; i++) {\n    for(int j=i+1; j<n; j++) {\n      if(a[i].F==a[j].F||a[i].S==a[j].S) unite(i,j);\n    }\n  }\n  set<int> s;\n  for(int i=0; i<n; i++) s.insert(find(i));\n  vector<int> v;\n  for(set<int>::iterator it=s.begin(); it!=s.end(); it++) v.push_back(*it);\n  int sum=n-s.size(),ans=1<<30;\n  map<int,int> m[4];\n  for(int i=0; i<v.size(); i++)for(int j=0; j<4; j++) m[j][v[i]]=1<<30;\n  for(int i=0; i<n; i++) {\n    m[0][find(i)]=min(m[0][find(i)],a[i].F-1);\n    m[1][find(i)]=min(m[1][find(i)],a[i].S-1);\n    m[2][find(i)]=min(m[2][find(i)],w-a[i].F);\n    m[3][find(i)]=min(m[3][find(i)],h-a[i].S);\n  }\n  for(int i=0; i<4; i++) {\n    int cnt=0;\n    for(int j=0; j<v.size(); j++) {\n      if(m[i][v[j]]) cnt++;\n    }\n    ans=min(ans,sum+cnt+(int)v.size()-1);\n  }\n  if(v.size()==1) ans=sum;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint uni[100000],r[100000];\nint find(int a){\n  if(a!=uni[a])a=find(uni[a]);\n  return a;\n}\nbool same(int a,int b){\n  return find(a)==find(b);\n}\nvoid unit(int a,int b){\n  int c=find(a),d=find(b);\n  if(r[c]>r[d])uni[d]=c;\n  else{uni[c]=d;\n    if(r[c]==r[d])r[c]++;\n  }\n}\nint ans,n,w,h,sum,c,y[100000],x[100000];\nbool used[100000];\nint main(){\n  cin>>n>>w>>h;\n  r(i,n)uni[i]=i,r[i]=0;\n  r(i,n)cin>>x[i]>>y[i];\n  r(i,n)r(j,n)if(x[i]==x[j]||y[i]==y[j])unit(i,j);\n  r(i,n)if(!used[i]){\n    int f=0;\n    used[i]=1;\n    for(int j=i;j<n;j++){\n      if(same(i,j)){//cout<<w<<h<<endl;\n        used[j]=1;\n        if(x[j]==0)sum++;\n        else if(x[j]==w)sum++;\n        else if(y[j]==0)sum++;\n        else if(y[j]==h)sum++;\n      }\n    }\n    c++;\n  }\n  if(c==1)cout<<n-1<<endl;\n  else cout<<n+c-1-sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nvector<int> x[100005];\nvector<int> y[100005];\n\nint main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  rep(i,n){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    x[p].pb(i);\n    y[q].pb(i);\n  }\n\n  UnionFind uf(n);\n\n  rep(i,100005){\n    rep(j,x[i].size()-1) uf.unite(x[i][j], x[i][j+1]);\n  }\n  rep(i,100005){\n    rep(j,y[i].size()-1) uf.unite(y[i][j], y[i][j+1]);\n  }\n\n  if(uf.size(0)==n){ cout << n-1 << endl; }\n  else {\n    vector<bool> checked(n, false);\n    int cnt = 0;\n    rep(i,n){\n      int p = uf.find(i);\n      if(!checked[p]){\n        checked[p] = true;\n        cnt++;\n      }\n    }\n    int hoge = 0;\n    if(x[0].size()>0 || x[w-1].size()>0 || y[0].size()>0 || y[h-1].size()>0) hoge++;\n\n    cout << (n-cnt) + cnt + cnt-1-hoge << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint tate[100000];\nint yoko[100000];\n\nint main() {\n  int n,w,h;\n  cin>>n>>w>>h;\n  UnionFind uf(n);\n  REP(i,100000)tate[i]=yoko[i]=-1;\n\n  bool corner = 0;\n  \n  REP(i,n) {\n    int x,y;\n    cin >> x >> y;\n    if (x==1||y==1||x==w||y==h) corner = 1;\n    x--;y--;\n    if (tate[x] >= 0) uf.unionSet(tate[x],i);\n    tate[x] = i;\n    if (yoko[y] >= 0) uf.unionSet(yoko[y],i);\n    yoko[y] = i;\n  }\n  int ans = 0;\n  set<int> seen;\n  REP(i,n) {\n    int r = uf.root(i);\n    if (seen.count(r)) continue;\n    seen.insert(r);\n    ans += uf.size(i)-1;\n  }\n  if (seen.size() > 1) {\n    ans += seen.size();\n    ans += seen.size()-1;\n    if (corner) ans--;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  VI par, s;\n  UnionFind(int n=1e5) { init(n); }\n  void init(int n=1e5) { par.resize(n); s.assign(n, 1); REP(i, n) par[i] = i; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\n\nint x[40010], y[40010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, h, w;\n  cin >> n >> w >> h;\n  bool flag=false;\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n    x[i]--, y[i]--;\n    if(x[i]==0 || x[i]==w-1 || y[i]==0 || y[i]==h-1) flag = true;\n  }\n\n  UnionFind uf(n);\n  REP(i, n) FOR(j, i+1, n) {\n    if(x[i] == x[j] || y[i] == y[j]) {\n      uf.unite(i, j);\n    }\n  }\n\n  int ret = 0, cnt = 0;\n  REP(i, n) {\n    if(i == uf.find(i)) {\n      ret += uf.s[uf.find(i)] - 1;\n      cnt++;\n    }\n  }\n  // cout << ret << \" \" << cnt << endl;\n  if(cnt >= 2) ret += cnt + cnt - 1 - (flag?1:0);\n\n  cout << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\n\nstruct UnionFind {\n    int data[40000];\n    UnionFind() {\n        memset(data, -1, sizeof(data));\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\nint can_unite[2][100000];\nint slime[40000][2];\nint main() {\n    int N, W, H;\n    scanf(\"%d%d%d\", &N, &W, &H);\n    int x_, y_;\n    bool edge = false;\n    rep(i, N){\n        scanf(\"%d%d\", &x_, &y_); --x_; --y_;\n        slime[i][0] = x_; slime[i][1] = y_;\n        if(x_ == 0 || x_ == W - 1 || y_ == 0 || y_ == H - 1)\n          edge = true;\n    }\n    \n    memset(can_unite, -1, sizeof(can_unite));\n    UnionFind uf;\n    int ans = 0;\n    rep(i, N) rep(j, 2) {\n        int& a = can_unite[j][slime[i][j]];\n        if(a == -1) a = i;\n        else if(!uf.same(a, i)) {\n            uf.unite(a, i);\n            ans++;\n        }\n    }\n    \n    bitset<40000> roots(0);\n    rep(i, N) roots[uf.root(i)] = 1;\n    int temp = roots.count();\n    if(temp == 1) cout << ans << endl;\n    else {\n        ans += temp * 2 - 1;\n        if(edge) --ans;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=40010;\nint par[nmax];\nvoid init(){rep(i,nmax) par[i]=i;}\nint find(int x){return (x==par[x])?x:par[x]=find(par[x]);}\nvoid unite(int a,int b){a=find(a),b=find(b);par[a]=b;}\nbool same(int a,int b){return find(a)==find(b);}\n\nvector<int> width[100010];\nvector<int> height[100010];\nint x[40010],y[40010];\n\nint main(void){\n\tint n,w,h;\n\tcin >> n >> w >> h;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--,y[i]--;\n\t\twidth[x[i]].push_back(i);\n\t\theight[y[i]].push_back(i);\n\t}\n\tinit();\n\trep(i,w)for(auto &j:width[i]) unite(width[i][0],j);\n\trep(i,h)for(auto &j:height[i]) unite(height[i][0],j);\n\n\tint ans=n-2,comp=0;\n\tbool ok=false;\n\trep(i,n){\n\t\tif(x[i]==0||x[i]==w-1) ok=true;\n\t\tif(y[i]==0||y[i]==h-1) ok=true;\n\t}\n\trep(i,n) if(i==find(i)) ans++,comp++;\n\tif(comp==1) ok=true;\n\tif(ok==false) ans++;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nstruct UnionFind{\n\tvector<int> par, sz;\n\tUnionFind(int n){\n\t\tpar = sz = vector<int>(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, sz[i] = 1;\n\t}\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x){\n\t\treturn sz[find(x)];\n\t}\n};\n\nbool cmp(const tuple<int, int, int> &a, const tuple<int, int, int> &b){\n\treturn get<1>(a) < get<1>(b);\n}\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\n\tvector<tuple<int, int, int>> v(n);\n\n\tbool edge = false;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv[i] = MT(x, y, i);\n\t\tif (x == w || y == h) edge = true;\n\t\tif (x == 1 || y == 1) edge = true;\n\t}\n\n\tUnionFind uf(n);\n\n\tsort(ALL(v));\n\trep(i, n - 1) if (get<0>(v[i]) == get<0>(v[i + 1])) uf.unite(get<2>(v[i]), get<2>(v[i + 1]));\n\tsort(ALL(v), cmp);\n\trep(i, n - 1) if (get<1>(v[i]) == get<1>(v[i + 1])) uf.unite(get<2>(v[i]), get<2>(v[i + 1]));\n\n\tset<int> st;\n\trep(i, n) st.insert(uf.find(i));\n\n\tint mv = st.size();\n\tif (mv == 1 || edge) --mv;\n\n\tcout << n - 1 + mv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint a, b, H, W, N, used[100009], c, d; vector<int>x[50009];\nvector<pair<int, int>>X[100009], Y[100009];\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < N; i++) { cin >> a >> b; if (a == 1 || b == 1 || a == H || b == W)d = 1; X[a].push_back(make_pair(b, i)); Y[b].push_back(make_pair(a, i)); }\n\tfor (int i = 0; i < 100009; i++) {\n\t\tsort(X[i].begin(), X[i].end()); sort(Y[i].begin(), Y[i].end());\n\t\tfor (int j = 0; j < (int)X[i].size() - 1; j++) { x[X[i][j].second].push_back(X[i][j + 1].second); x[X[i][j + 1].second].push_back(X[i][j].second); }\n\t\tfor (int j = 0; j < (int)Y[i].size() - 1; j++) { x[Y[i][j].second].push_back(Y[i][j + 1].second); x[Y[i][j + 1].second].push_back(Y[i][j].second); }\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (used[i] == true)continue;\n\t\tqueue<int>Q; Q.push(i); used[i] = true;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tfor (int j : x[a1]) { if (used[j] == false) { used[j] = true; Q.push(j); } }\n\t\t}\n\t\tc++;\n\t}\n\tif (c == 1)d = 1;\n\tcout << (N - 1) + (c - d) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct slime {\n\tint y;\n\tint x;\n\tbool wall;\n};\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\tint N, W, H; cin >> N >> W >> H;\n\tvector<vector<int>>ws(W);\n\tvector<vector<int>>hs(H);\n\tbool hasi = false;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tif (x == 0 || x == W - 1 || y == 0 || y == H - 1) {\n\t\t\thasi = true;\n\t\t}\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\tUnionFind uf(N);\n\n\tfor (int i = 0; i < ws.size(); ++i) {\n\t\tfor (int j = 1; j < ws[i].size(); ++j) {\n\t\t\tuf.unionSet(ws[i][j], ws[i][j - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tfor (int j = 1; j < hs[i].size(); ++j) {\n\t\t\tuf.unionSet(hs[i][j], hs[i][j - 1]);\n\t\t}\n\t}\n\tvector<bool>beroot(N, false);\n\tfor (int i = 0; i < N; ++i) {\n\t\tberoot[uf.root(i)] = true;\n\t}\n\tint bunkai = count(beroot.begin(), beroot.end(), true);\n\tint ans;\n\tif (bunkai == 1) {\n\t\tans = N - 1;\n\t}\n\telse {\n\t\tans = N  + bunkai - 1 - hasi;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<int> par;\n\tunion_find(int n) \n\t{\n\t\tREP(i, n) par.push_back(i);\n\t}\n\tint find(int x) { return par[x] == x ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] == i) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main()\n{\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<vi> x(h), y(w);\n\tunion_find uf(n);\n\tREP(i, n)\n\t{\n\t\tint a, b; cin >> b >> a;\n\t\ta--; b--;\n\t\tx[a].push_back(i), y[b].push_back(i);\n\t}\n\tREP(i, h)REP(j, x[i].size() - 1) uf.unite(x[i][j], x[i][j + 1]);\n\tREP(i, w)REP(j, y[i].size() - 1) uf.unite(y[i][j], y[i][j + 1]);\n\tll cnt = uf.count();\n\tll ans = n - cnt;\n\tif (cnt > 1)\n\t{\n\t\tans += cnt;\n\t\tans += cnt - 1;\n\t\tif (x[0].size() || x[h - 1].size() || y[0].size() || y[w - 1].size()) ans--;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\nint N,H,W;\nint y,x;\nvector<int> G[2][MAX];\nbool visited[2][MAX];\nint flg[4],cnt[4];\n \nvoid dfs(int f,int p){\n  visited[f][p]=true;\n  if(p==1)flg[f]=true;\n  if(p==(f==0?H:W))flg[2+f]=true;\n   \n  int r=1-f;\n  for(int i=0;i<(int)G[f][p].size();i++){\n    int w=G[f][p][i];\n    if(visited[r][w])continue;\n    dfs(r,w);\n  }\n}\n \nint main(){\n  scanf(\"%d %d %d\",&N,&H,&W);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d\",&y,&x);\n    G[0][y].push_back(x);\n    G[1][x].push_back(y);\n  }\n   \n  int ans=0;\n  for(int i=0;i<MAX;i++){\n    if(G[0][i].size()==0)continue;\n    if(visited[0][i])continue;\n    for(int j=0;j<4;j++)flg[j]=0;\n    dfs(0,i);\n    ans++;\n    for(int j=0;j<4;j++)cnt[j]+=flg[j];\n  }\n  for(int i=1;i<4;i++)cnt[i]=max(cnt[i],cnt[i-1]);\n  if(ans==1){\n    cout<<N-1<<endl;\n  }else{\n    cout<<N+ans-1-cnt[3]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct union_find\n{\n\tvector<int> par;\n\tunion_find(int n) \n\t{\n\t\tREP(i, n) par.push_back(i);\n\t}\n\tint find(int x) { return par[x] == x ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] == i) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main()\n{\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<vi> x(h), y(w);\n\tunion_find uf(n);\n\tREP(i, n)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tx[a].push_back(i), y[b].push_back(i);\n\t}\n\tREP(i, h)REP(j, x[i].size() - 1) \n\t\tuf.unite(x[i][j], x[i][j + 1]);\n\tREP(i, w)REP(j, y[i].size() - 1) uf.unite(y[i][j], y[i][j + 1]);\n\tll cnt = uf.count();\n\tll ans = n - cnt;\n\tif (cnt > 1)\n\t{\n\t\tans += cnt;\n\t\tans += cnt - 1;\n\t\tif (x[0].size() || x[h - 1].size() || y[0].size() || y[w - 1].size()) ans--;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int INF=123456789;\nconst int N=100000;\nset<int> X[N+1],Y[N+1];\n\nvector<int> G[N];\nvector<vector<int>> connected;\n\nint main()\n{\n    int n,w,h;\n    scanf(\" %d %d %d\", &n, &w, &h);\n\n    // point\n    vector<pi> p(n);\n    // point -> id\n    map<pi,int> f;\n    rep(i,n)\n    {\n        int x,y;\n        scanf(\" %d %d\", &x, &y);\n        X[x].insert(y);\n        Y[y].insert(x);\n\n        p[i] = pi(x,y);\n        f[p[i]] = i;\n    }\n\n    // ??£??\\?????????????????????????????????\n    rep(i,n)\n    {\n        int x=p[i].fi, y=p[i].se;\n\n        // ???\n        auto itrx = X[x].lower_bound(y);\n        if(itrx != X[x].begin())\n        {\n            auto up = itrx;\n            --up;\n            int idx = f[pi(x,*up)];\n            G[i].pb(idx);\n        }\n\n        // ???\n        ++itrx;\n        if(itrx != X[x].end())\n        {\n            int idx = f[pi(x,*itrx)];\n            G[i].pb(idx);\n        }\n\n        // ???\n        auto itry = Y[y].lower_bound(x);\n        if(itry != Y[y].begin())\n        {\n            auto lf = itry;\n            --lf;\n            int idx = f[pi(*itry,y)];\n            G[i].pb(idx);\n        }\n\n        // ???\n        ++itry;\n        if(itry != Y[y].end())\n        {\n            int idx = f[pi(*itry,y)];\n            G[i].pb(idx);\n        }\n    }\n\n    // ??£???????´??????¢???\n    vector<bool> vis(n,false);\n    rep(i,n)\n    {\n        if(vis[i]) continue;\n\n        vector<int> con;\n        queue<int> que;\n\n        que.push(i);\n        con.pb(i);\n        vis[i]=true;\n        while(!que.empty())\n        {\n            int v=que.front();\n            que.pop();\n            rep(j,G[v].size())\n            {\n                int nx=G[v][j];\n                if(!vis[nx])\n                {\n                    vis[nx]=true;\n                    con.pb(nx);\n                    que.push(nx);\n                }\n            }\n        }\n\n        connected.pb(con);\n    }\n\n    int ans=INF;\n\n    if(connected.size()==1) ans=n-1;\n    else\n    {\n        // ??????????????????????????´????????????\n        vector<int> W({1,w}), H({1,h});\n        for(auto &x:W)\n        {\n            int tmp=0;\n            rep(i,connected.size())\n            {\n                int add=connected[i].size()+2;\n                rep(j,connected[i].size())\n                {\n                    int idx = connected[i][j];\n                    if(p[idx].fi==x)\n                    {\n                        --add;\n                        break;\n                    }\n                }\n                tmp+=add-1;\n            }\n            ans=min(ans,tmp-1);\n        }\n        for(auto &y:H)\n        {\n            int tmp=0;\n            rep(i,connected.size())\n            {\n                int add=connected[i].size()+2;\n                rep(j,connected[i].size())\n                {\n                    int idx = connected[i][j];\n                    if(p[idx].se==y)\n                    {\n                        --add;\n                        break;\n                    }\n                }\n                tmp+=add-1;\n            }\n            ans=min(ans,tmp-1);\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint uni[100000],r[100000];\nint find(int a){\n  if(a!=uni[a])a=find(uni[a]);\n  return a;\n}\nbool same(int a,int b){\n  return find(a)==find(b);\n}\nvoid unit(int a,int b){\n  int c=find(a),d=find(b);\n  if(r[c]>r[d])uni[d]=c;\n  else{uni[c]=d;\n    if(r[c]==r[d])r[c]++;\n  }\n}\nint ans,n,w,h,sum,c,y[100000],x[100000];\nbool used[100000];\nint main(){\n  cin>>n>>w>>h;\n  r(i,n)uni[i]=i,r[i]=0;\n  r(i,n)cin>>x[i]>>y[i];\n  r(i,n)r(j,n)if(x[i]==x[j]||y[i]==y[j])unit(i,j);\n  r(i,n)if(!used[i]){\n    int f=0;\n    used[i]=1;\n    for(int j=i;j<n;j++){\n      if(same(i,j)){\n        used[j]=1;\n        if(x[j]==0)sum++;\n        if(x[j]==w)sum++;\n        if(y[j]==0)sum++;\n        if(y[j]==h)sum++;\n      }\n    }\n    c++;\n  }\n  if(c==1)cout<<n-1<<endl;\n else cout<<n+c-1-sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n\nusing namespace std;\n\nint N;\nint W, H;\nvector<tuple<int, int, int> > tupX, tupY;\n\nint parent[40005];\n\nvoid init(){\n\tfor(int i = 0; i < N; i++) parent[i] = i;\n}\n\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = (i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nint main(void)\n{\n\tcin >> N >> W >> H;\n\t\n\tbool flag = false;\n\tint x, y;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x >> y;\n\t\tif(x == 1 || x == W || y == 1 || y == H) flag = true;\n\t\ttupX.push_back( make_tuple(x, y, i) );\n\t\ttupY.push_back( make_tuple(y, x, i) );\n\t}\n\tsort(tupX.begin(), tupX.end());\n\tsort(tupY.begin(), tupY.end());\n\t\n\tinit();\n\tfor(int i = 1; i < tupX.size(); i++){\n\t\tif(get<0>(tupX[i]) == get<0>(tupX[i-1])){\n\t\t\tunite( get<2>(tupX[i]), get<2>(tupX[i-1]) );\n\t\t}\n\t}\n\tfor(int i = 1; i < tupY.size(); i++){\n\t\tif(get<0>(tupY[i]) == get<0>(tupY[i-1])){\n\t\t\tunite( get<2>(tupY[i]), get<2>(tupY[i-1]) );\n\t\t}\n\t}\n\t\n\tint cnt = 0;\n\tfor(int i = 0; i < N; i++) if(parent[i] == i) cnt++;\n\t\n\tint ans = (N-1);\n\tif(cnt > 1){\n\t\tans += cnt;\n\t\tif(flag) ans--;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum Loc{\n\tLeft,\n\tRight,\n\tTop,\n\tBottom,\n};\n\nstruct Info{\n\tint x,y;\n};\n\nint N,unite_count;\nint* boss,*height;\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint isSame(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tx = get_boss(x);\n\ty = get_boss(y);\n\n\tif(x == y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[y] = x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[x] = y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[y] = x;\n\t\theight[x]++;\n\t}\n\n\tunite_count++;\n}\n\nint main(){\n\n\tint N,W,H;\n\tscanf(\"%d %d %d\",&N,&W,&H);\n\n\tboss = new int[N];\n\theight = new int[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N));\n\tvector<int> X[W+1],Y[H+1];\n\n\tfor(int id = 0; id < N; id++){\n\t\tscanf(\"%d %d\",&info[id].x,&info[id].y);\n\t\tX[info[id].x].push_back(id);\n\t\tY[info[id].y].push_back(id);\n\t}\n\n\tfor(int i = 1; i <= W;i++){\n\n\t\tif(X[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < X[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < X[i].size();p++){\n\t\t\t\tunite(X[i][k],X[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= H; i++){\n\n\t\tif(Y[i].size() <= 1)continue;\n\t\tfor(int k = 0; k < Y[i].size()-1;k++){\n\t\t\tfor(int p = k+1; p < Y[i].size();p++){\n\t\t\t\tunite(Y[i][k],Y[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tstack<int> GroupID;\n\n\tint group_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(boss[i] == i){\n\t\t\tgroup_num++;\n\t\t\tGroupID.push(i);\n\t\t}\n\t}\n\n\tint Loc_num[4] = {0,0,0,0},id;\n\tbool check[4];\n\n\twhile(!GroupID.empty()){\n\t\tid = GroupID.top();\n\t\tGroupID.pop();\n\n\t\tfor(int i = 0; i < 4; i++)check[i] = false;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(boss[i] == id){\n\t\t\t\tif(info[i].x == 1){\n\t\t\t\t\tcheck[Left] = true;\n\t\t\t\t}else if(info[i].x == W){\n\t\t\t\t\tcheck[Right] = true;\n\t\t\t\t}\n\n\t\t\t\tif(info[i].y == 1){\n\t\t\t\t\tcheck[Top] = true;\n\t\t\t\t}else if(info[i].y == H){\n\t\t\t\t\tcheck[Bottom] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(check[i]){\n\t\t\t\tLoc_num[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_kabe = 0,tmp;\n\n\tfor(int i = 0; i < 4; i++)max_kabe = max(max_kabe,Loc_num[i]);\n\n\tint ans = unite_count;\n\n\tif(group_num != 1){\n\t\ttmp = group_num-max_kabe;\n\n\t\tans += tmp + group_num-1;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[x] < 0) memoX[x] = i;//???????????????????????????????????\\??£????????¨???????????°X[???]=????????????????????\\??????\n\t\telse ds.unite(i, memoX[x]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[y] < 0) memoY[y] = i;\n\t\telse ds.unite(i, memoY[y]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\n\t//printf(\"%d\\n\", m);\n\tif(m > 1){\n\t\tif(cornerw == true || cornerh == true){\n\t\t\tprintf(\"%d\\n\", n + m - 2);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\", n + m - 1);\n\t\t}\n\t}else{\n\t\tprintf(\"%d\\n\", n - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int MAX_N = 50000;\nint N,W,H,x[MAX_N],y[MAX_N],uf[MAX_N],masks[MAX_N],sz[MAX_N];\n// ↑←↓→\n\nint find(int x) {\n  if( x == uf[x] ) return x;\n  return uf[x] = find(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) uf[x] = y;\n}\n\nint main(){\n  cin >> N >> W >> H;\n  rep(i,N) { \n    cin >> x[i] >> y[i]; \n    uf[i] = i, masks[i] = sz[i] = 0;\n    if( y[i] == 0 ) masks[i] |= (1<<0);\n    if( x[i] == 0 ) masks[i] |= (1<<1);\n    if( y[i] == H ) masks[i] |= (1<<2);\n    if( x[i] == W ) masks[i] |= (1<<3);\n  }\n  map<int,int> mp;\n  rep(i,N){\n    if( mp.count(x[i]) ) unit(find(mp[x[i]]),find(i));\n    else                 mp[x[i]] = i;\n  }\n  mp.clear();\n  rep(i,N){\n    if( mp.count(y[i]) ) unit(find(mp[y[i]]),find(i));\n    else                 mp[y[i]] = i;\n  }\n\n  map<int,int> bitmask;\n  set<int> S;\n  vector<int> group;\n  rep(i,N) S.insert(find(i));\n  rep(i,N) ++sz[find(i)];\n\n  if( S.size() == 1 ) {\n    cout << sz[find(0)] - 1 << endl;\n    return 0;\n  }\n\n  rep(i,N) bitmask[find(i)] |= masks[i];\n  for(set<int>::iterator it = S.begin(); it != S.end(); it++) group.push_back(*it);\n\n  int ans = IINF;\n  rep(i,4){\n    int cost = (int)S.size()-1;\n    rep(j,(int)group.size()){\n      cost += sz[find(group[j])];\n      if( (bitmask[find(group[j])]>>i) & 1 ) --cost; \n    }\n    ans = min(ans,cost);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\n\nint main(){\n  int n, h, w;\n  cin >> n >> h >> w;\n  int x, y;\n  vector<int> X(n), Y(n);\n  map<int,int> M_x, M_y;\n  UnionFind uf(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n    if(M_x[x] > 0){\n      uf.unite(i,M_x[x]-1);\n    }else{\n      M_x[x] = i + 1;\n    }\n    if(M_y[y] > 0){\n      uf.unite(i,M_y[y]-1);\n    }else{\n      M_y[y] = i + 1;\n    }\n  }\n  set<int> p, l, r, t, b;\n  for(int i = 0; i < n; ++i){\n    p.insert(uf.find(i));\n    if(X[i] == 1) l.insert(uf.find(i));\n    if(X[i] == w) r.insert(uf.find(i));\n    if(Y[i] == 1) b.insert(uf.find(i));\n    if(Y[i] == h) t.insert(uf.find(i));\n  }\n  int k = p.size(), s = max({l.size(),r.size(),t.size(),b.size()});\n  if(k == 1) cout << n - 1 << endl;\n  else cout << n + k - 1 - s << endl; \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<map>\n#include<iterator>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\nconst int MAX = 100'000;\n\n//変数\nint N, H, W;\nvector<pair<int, int>> xy;\nvector<bool> use;\nmap<int, vector<int>> x2i, y2i;\n\nvector<int> udlr = vector<int>(4, 0);\n\n\n\n//サブ関数\n//入力\nvoid input()\n{\n\tcin >> N >> W >> H;\n\tuse.resize(N, false);\n\tREP(i, N) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\txy.push_back({ a,b });\n\t}\n}\n\n\nvoid make_xy_join()\n{\n\t//x,y軸で、座標毎の含有点作成\n\tREP(i,N){\n\t\tint x = xy[i].first;\n\t\tint y = xy[i].second;\n\n\n\t\tif (x2i.find(x) == x2i.end()) x2i[x] = vector<int>();\n\t\tx2i[x].push_back(i);\n\n\n\t\tif (y2i.find(y) == y2i.end()) y2i[y] = vector<int>();\n\t\ty2i[y].push_back(i);\n\t}\n}\n\n\nvoid make_connected_graph(int route)\n{\n\tqueue<int> q;\n\tvector<bool> mudlr = vector<bool>(4, false);\n\tq.push(route);\n\tuse[route] = true;\n\n\twhile (!q.empty()) {\n\t\tint node = q.front(); q.pop();\n\t\tint x = xy[node].first;\n\t\tint y = xy[node].second;\n\n\t\tif (y == 0)mudlr[0] = true;\n\t\tif (y == H - 1)mudlr[1] = true;\n\t\tif (x == 0)mudlr[2] = true;\n\t\tif (x == W - 1)mudlr[3] = true;\n\n\n\t\tfor (int next : x2i[x]) if (!use[next]) {\n\t\t\tuse[next] = true;\n\t\t\tq.push(next);\n\t\t}\n\t\tfor (int next : y2i[y]) if (!use[next]) {\n\t\t\tuse[next] = true;\n\t\t\tq.push(next);\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) if (mudlr[i]) {\n\t\tudlr[i]++;\n\t}\n}\n\n\n//計算\nvoid calc()\n{\n\tint tree = 0;\n\n\tmake_xy_join();\n\tREP(i, N) if (!use[i]) {\n\t\ttree++;\n\t\tmake_connected_graph(i);\n\t}\n\n\n\tif (tree == 1) {\n\t\tcout << N - 1 << endl;\n\t}\n\telse {\n\t\tcout << N + tree - 1 - *max_element(udlr.begin(), udlr.end()) << endl;\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tinput();\n\tcalc();\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/04/20  Problem: AOJ 2382 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\nLL N, W, H;\n\nLL ans = 0LL;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tcin >> N >> H >> W;\n\n\tVI x(N), y(N);\n\tint Wall = 0;\n\tFOR(i, 0, N) {\n\t\tcin >> x[i] >> y[i];\n\t\tif (x[i] == 1 || y[i] == 1 || x[i] == W || y[i] == H)Wall = 1;\n\t}\n\tUnionFind uf(N);\n\n\tmap<int, int>Xs;\n\tmap<int, int>Ys;\n\tvector<bool> usex(1000000, 0);\n\tvector<bool> usey(1000000, 0);\n\tFOR(i, 0, N) { // mergeを\n\t\tif (usex[x[i]])\n\t\t\tuf.unionSet(Xs[x[i]], i);\n\t\tXs[x[i]] = i;\n\t\tif (usey[y[i]])\n\t\t\tuf.unionSet(Ys[y[i]], i);\n\t\tYs[y[i]] = i;\n\t\tusex[x[i]] = 1;\n\t\tusey[y[i]] = 1;\n\t}\n\n\n\tset<int>se;\n\tFOR(i, 0, N) {\n\t\tse.insert(uf.root(i));\n\t\tdebug(uf.root(i));\n\t}\n\tint sz = SZ(se);\n\tif (sz != 1) {\n\t\tans = N - 1 + sz - Wall;\n\t}\n\telse {\n\t\tans = N - 1;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 40005;\n\nint x[MAX_N],y[MAX_N];\nint n,w,h;\nbool flag[MAX_N];\nvector<int> X[100002],Y[100002];\nvector<int> G[MAX_N];\n\nvoid dfs(int u,bool& hoge)\n{\n    flag[u] = true;\n    if(x[u] == 0 || x[u] == h-1 || y[u] == 0 || y[u] == w-1){\n        hoge = true;\n    }\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],hoge);\n        }\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&w,&h);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n        x[i]--,y[i]--;\n        X[x[i]].push_back(i);\n        Y[y[i]].push_back(i);\n\t}\n    rep(i,w){\n        rep(j,Y[i].size()){\n            rep(k,Y[i].size()){\n                if(k != j){\n                    G[Y[i][j]].push_back(Y[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,X[i].size()){\n            rep(k,X[i].size()){\n                if(k != j){\n                    G[X[i][j]].push_back(X[i][k]);\n                }\n            }\n        }\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    int cnt = 0;\n    int pl = 0;\n    bool wall = false;\n    rep(i,n){\n        if(!flag[i]){\n            cnt++;\n            dfs(i,wall);\n        }\n    }\n    if(wall){\n        pl += 2*(cnt-1);\n    }else{\n        pl += 3*(cnt-1);\n    }\n    cout << n << \" \" << cnt << \" \" << pl << \"\\n\";\n    printf(\"%d\\n\",n-cnt+pl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define MAX 40010\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint p[MAX];\nint n,h,w,ans=0;\nint x[MAX],y[MAX];\nbool l[MAX]={},r[MAX]={},u[MAX]={},d[MAX]={};\n\nint find(int a){\n  if(p[a]==a)return a;\n  int pa=find(p[a]);\n  p[a]=pa;\n  return pa;\n}\n\nvoid unite(int a,int b){\n  int pa=find(a),pb=find(b);\n  p[pa]=pb;\n}\n\nbool same(int a,int b){\n  return find(a)==find(b);\n}\n\nvoid check(int a,int b){\n  u[a]|=u[b];\n  u[b]|=u[a];\n  l[a]|=l[b];\n  l[b]|=l[a];\n  d[a]|=d[b];\n  d[b]|=d[a];\n  r[a]|=r[b];\n  r[b]|=r[a];\n}\n\nint main()\n{\n\n  vector<pii> a,b;\n\n  cin>>n>>w>>h;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    a.push_back(mp(x[i],i));\n    b.push_back(mp(y[i],i));\n    if(y[i]==1)d[i]=true;\n    if(x[i]==1)l[i]=true;\n    if(y[i]==h)u[i]=true;\n    if(x[i]==w)r[i]=true;\n  }\n\n  for(int i=0;i<MAX;i++)p[i]=i;\n\n  sort(a.begin(),a.end());\n  sort(b.begin(),b.end());\n\n  for(int i=1;i<n;i++){\n    if(a[i-1].f==a[i].f && !same(a[i-1].s,a[i].s)){\n      unite(a[i-1].s,a[i].s);\n      ans++;\n      check(i-1,i);\n    }\n    if(b[i-1].f==b[i].f && !same(b[i-1].s,b[i].s)){\n      unite(b[i-1].s,b[i].s);\n      ans++;\n      check(i-1,i);\n    }\n  }\n\n  if(ans<=n-1){\n    int sum1=0,sum2=0,sum3=0,sum4=0;\n    for(int i=0;i<n;i++)if(p[i]==i)sum1++;\n    sum1=(sum1*2-1);\n    sum2=sum3=sum4=sum1;\n    for(int i=0;i<n;i++){\n      if(p[i]==i && l[i])sum1--;\n      if(p[i]==i && u[i])sum2--;\n      if(p[i]==i && r[i])sum3--;\n      if(p[i]==i && d[i])sum4--;\n    }\n    ans+=min(min(sum1,sum2),min(sum3,sum4));\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 24;\n\nconstexpr int kMaxXY = 1e5 + 1;\nconstexpr int kN = 1e5 * 4;\n\nint memox[kMaxXY];\nint memoy[kMaxXY];\nint p[kN];\n\nint root(int idx){\n    if(p[idx] == idx) return idx;\n\n    return p[idx] = root(p[idx]);\n}\n\nint main(void){\n    for(int n, w, h; cin >> n >> w >> h;){\n        int numIdx = 0;\n        vi cnt(n);\n\n        // x = 0, x = w - 1, y = 0, y = h - 1\n        vvi cntSumi(n, vi(4));\n\n        fill(memox, memox + kMaxXY, -1);\n        fill(memoy, memoy + kMaxXY, -1);\n\n        rep(loop, n){\n            int x, y; cin >> x >> y; x--, y--;\n            int idx; //root\n            \n            if(memox[x] != -1 && memoy[y] != -1){\n                idx = root(memox[x]);\n\n                if(root(memox[x]) != root(memoy[y])){\n                    //union r1 -> r2(new root)\n                    int r1 = idx, r2 = root(memoy[y]);\n\n                    cnt[r2] += cnt[r1]; cnt[r1] = 0;\n                    rep(i, 4) cntSumi[r2][i] += cntSumi[r1][i], cntSumi[r1][i] = 0;\n\n                    p[r1] = root(memoy[y]);\n                }\n            }\n            else if(memox[x] != -1){\n                idx = memoy[y] = root(memox[x]);\n            }\n            else if(memoy[y] != -1){\n                idx = memox[x] = root(memoy[y]);\n            }\n            else {\n                p[numIdx] = numIdx;\n                idx = memox[x] = memoy[y] = numIdx++;\n            }\n\n            if(x ==   0) cntSumi[idx][0]++;\n            if(x == w-1) cntSumi[idx][1]++;\n            if(y ==   0) cntSumi[idx][2]++;\n            if(y == h-1) cntSumi[idx][3]++;\n\n            cnt[idx]++;\n        }\n\n        int res = 0, numS = 0;\n        vi numSumi(4);\n        rep(i, numIdx){\n            if(cnt[i] != 0) res += cnt[i] - 1, numS++;\n\n            rep(j, 4){\n                if(cntSumi[i][j] != 0){\n                    numSumi[j]++;\n                }\n            }\n        }\n        if(numS != 1) res += (numS - *max_element(all(numSumi))) + numS - 1;\n\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\n\nstruct UnionFind {\n    int N;\n    vector<int> siz, par, Rank;\n    UnionFind(int n) : siz(n, 1), par(n), Rank(n, 0) {\n        N = n;\n        REP(i, N) par[i] = i;\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else\n            return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (Rank[x] < Rank[y]) {\n            par[x] = y;\n            siz[x] += siz[y];\n            siz[y] = siz[x];\n        } else {\n            siz[y] += siz[x];\n            siz[x] = siz[y];\n            par[y] = x;\n            if (Rank[x] == Rank[y]) Rank[x]++;\n        }\n    }\n    bool same(int x, int y) { return find(x) == find(y); };\n};\n\nvector<int> X[100010], Y[100010];\nvoid solve() {\n    int N, W, H;\n    cin >> N >> W >> H;\n    int cnt = 0;\n    int valid = 0;\n    UnionFind uf(N);\n    REP(i, N) {\n        int x, y;\n        cin >> x >> y;\n        if (x == W || y == H || x == 1 || y == 1) {\n            valid++;\n        }\n        x--, y--;\n        X[x].push_back(i);\n        Y[y].push_back(i);\n    }\n    REP(i, W) {\n        REP(j, (int)X[i].size() - 1) { uf.unite(X[i][j], X[i][j + 1]); }\n    }\n    REP(i, H) {\n        REP(j, (int)Y[i].size() - 1) { uf.unite(Y[i][j], Y[i][j + 1]); }\n    }\n    vector<bool> done(N + 1);\n    int ans = -2;\n\n    REP(i, N) {\n        if (done[uf.find(i)])\n            continue;\n        else {\n            cnt++;\n            ans += 2;\n            ans += uf.siz[uf.find(i)] - 1;\n            done[uf.find(i)] = true;\n        }\n    }\n    if (cnt >= 2 && valid == 0) {\n        ans++;\n        // cerr << \"invalid\" << endl;\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    // while (solve())\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\n\nint main(){\n  int n, h, w;\n  cin >> n >> h >> w;\n  int x, y;\n  vector<int> X(n), Y(n);\n  map<int,int> M_x, M_y;\n  UnionFind uf(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X[i] = x;\n    Y[i] = y;\n    if(M_x[x] > 0){\n      uf.unite(i,M_x[x]-1);\n    }else{\n      M_x[x] = i + 1;\n    }\n    if(M_y[y] > 0){\n      uf.unite(i,M_y[y]-1);\n    }else{\n      M_y[y] = i + 1;\n    }\n  }\n  set<int> p, l, r, t, b;\n  for(int i = 0; i < n; ++i){\n    p.insert(uf.find(i));\n    if(X[i] == 1) l.insert(uf.find(i));\n    if(X[i] == w) r.insert(uf.find(i));\n    if(Y[i] == 1) b.insert(uf.find(i));\n    if(Y[i] == h) t.insert(uf.find(i));\n  }\n  int k = p.size(), s = max({l.size(),r.size(),t.size(),b.size()});\n  if(k == 1) cout << n - 1 << endl;\n  else cout << n + k - 1 - s << endl; \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) lps(i,0,n)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define FDST int hogehogehoge;cin>>hogehogehoge\n#define   int long long\n\nint x[110000],y[110000];\nint change[50000];\n\nsigned  main(){\n  int n,w,h;\n  cin>>n>>w>>h;\n  int c=0,ans=0;\n  int stat=0;\n  int am=1;\n  lp(i,n){\n    int xx,yy;\n    cin>>xx>>yy;\n    while(change[x[xx]]!=0) x[xx]=change[x[xx]];\n    while(change[y[yy]]!=0) y[yy]=change[y[yy]];\n    if(xx==1||yy==1||xx==w||yy==h) stat=1;\n    if(x[xx]==0&&y[yy]==0){\n      c++;\n      x[xx]=am;\n      y[yy]=am;\n      am++;\n    }\n    else{\n      ans++;\n      if(x[xx]==0&&y[yy]!=0) x[xx]=y[yy];\n      else if(y[yy]==0&&x[xx]!=0) y[yy]=x[xx];\n      else if(x[xx]==y[yy]) continue;\n      else{\n\tint a=x[xx],b=y[yy];\n\tif(a>b) swap(a,b);\n\tif(change[a]==b)1;\n\telse{\n\t  c--;\n\t  change[a]=b;\n\t  ans++;\n\t}\n      }\n    }/*\n    cout<<\" \";\n    lp(i,5){\n      cout<<x[i+1];\n    }\n    cout<<endl;\n    lp(j,5){\n      cout<<y[j+1]<<endl;\n      }*/\n    // cout<<c<<\" \"<<ans<<\" \"<<stat<<endl;\n  }\n  /*cout<<\" \";\n  lp(i,5){\n    cout<<x[i+1];\n  }\n  cout<<endl;\n  lp(j,5){\n    cout<<y[j+1]<<endl;\n    }*/\n  if(c==1) 1;\n  else{\n    ans+=c*2-1-stat;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    // x, y????????????\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    // x, y?????????????????????1\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x???????????¢??????????????????????????????????????°???\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // x??????????????????????????§???????????????\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // ?????¢??????????????????????????°?????????\n    int setNum(void) {\n        map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n    void print(void) {\n        auto c = getUnionList();\n        for (auto x : c) {\n            for (auto y : x) \n                cout << y << \" \";\n            cout << endl;\n        }\n    }\n};\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, nx, ny; cin >> n >> nx >> ny;\n    vector<P> s(n);\n    \n    vll vx(nx), vy(ny);\n    vll rx(nx, -1), ry(ny, -1);\n    vvll wall(n, vll(4));\n    bool is_wall = 0;\n    rep(i, n) {\n        cin >> s[i].fi >> s[i].se; s[i].fi--; s[i].se--;\n        rx[s[i].fi] = i;\n        ry[s[i].se] = i;\n        wall[i][0] = s[i].fi == 0;\n        wall[i][1] = s[i].fi == nx-1;\n        wall[i][2] = s[i].se == 0;\n        wall[i][3] = s[i].se == ny-1;\n        is_wall |= (s[i].fi == 0 || s[i].fi == nx-1 || s[i].se == 0 || s[i].se == ny-1);\n    }\n\n    UnionFind uf(n);\n    rep(i, n) {\n        uf.unite(i, rx[s[i].fi]);\n        uf.unite(i, ry[s[i].se]);\n    }\n    /*\n    cout << \"####\" << endl;\n    uf.print();\n    cout << \"####\" << endl;\n    */\n\n    auto list = uf.getUnionList();\n//    cout << list << endl;\n//    cout << list << endl;\n    if (list.size() == 1) {\n        cout << (*list.begin()).size() - 1 << endl;\n        return 0;\n    }\n\n    /*\n    map<ll, vll> wall_list;\n//    vll wall(4);\n    for (auto x : list) {\n        auto tmp = vll(4);\n        rep(i, x.size()) {\n            rep(j, 4) {\n                tmp[j] |= wall[x[i]][j];\n            }\n        }\n        wall_list[x] = tmp;\n    }\n//    cout << wall_list << endl;\n    */\n\n    ll ret = 0;\n    for (auto x : list) {\n        ret += x.size() - 1;\n    }\n//    cout << is_wall << endl;\n    cout << ret + 2 * list.size() - is_wall - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Union-Find??¨\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\n//class DisjointSet\nclass DisjointSet{\n\tpublic:\n\t\tvector<int> rank, p;//rank:??¨????????? p:??????????????????\n\t\tDisjointSet(){}\n\t\tDisjointSet(int size){//???????????°\n\t\t\trank.resize(size, 0);\n\t\t\tp.resize(size, 0);\n\t\t\trep(i, size) makeSet(i);\n\t\t}\n\t\tvoid makeSet(int x){\n\t\t\tp[x] = x;\n\t\t\trank[x] = 0;\n\t\t}\n\t\t//????????¨??????????????????????????????????????????\n\t\tbool same(int x, int y){\n\t\t\treturn findSet(x) == findSet(y);\n\t\t}\n\t\t// ??¨?????????????????£?????????\n\t\tvoid unite(int x, int y){\n\t\t\tlink(findSet(x), findSet(y));\n\t\t}\n\t\t//??¨??????????????????????????¨?????????????????£?????????\n\t\tvoid link(int x, int y){\n\t\t\tif(rank[x] > rank[y]){\n\t\t\t\tp[y] = x;\n\t\t\t}else{\n\t\t\t\tp[x] = y;\n\t\t\t\tif(rank[x] == rank[y]) rank[y]++;\n\t\t\t}\n\t\t}\n\t\t//????????¢???\n\t\tint findSet(int x){\n\t\t\tif(x != p[x]){\n\t\t\t\tp[x] = findSet(p[x]);\n\t\t\t}\n\t\t\treturn p[x];\n\t\t}\n};\n\nstatic const int MAX_W = 100001, MAX_H = 100001;\n\nint main(void){\n\tint n, w, h;\n\tbool cornerw = false, cornerh = false;\n\tcin >> n >> w >> h;\n\t//??????????????????????????\\???????????¨?????¨????????????????????????????????¨???????????§????????????????????\\??£?????????????????????????¢????????????????\n\tvector<int> memoX(w, -1);//???\n\tvector<int> memoY(h, -1);//???\n\tDisjointSet ds = DisjointSet(n);\n\n\trep(i, n){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--; y--;//0origin\n\t\tif(x == 0 || x == w - 1) cornerw = true;\n\t\tif(y == 0 || y == h - 1) cornerh = true;\n\t\t//?????¨?¨??????§?????????????????????\n\t\t//????????????????????????????????????x??§?¨???¨y??§?¨??????±???????????????????????£?????????????????¨?????§??????\n\t\tif(memoX[i] < 0) memoX[i] = x;//???????????????????????????????????\\??£????????¨???????????°???????????¢??£?????????\n\t\telse ds.unite(i, memoX[i]);//?????§????????????????????????????????\\??£???????????°???????????????????????¨?????£?????????\n\t\tif(memoY[i] < 0) memoY[i] = y;\n\t\telse ds.unite(i, memoY[i]);\n\t}\n\t/*\n\trep(i, w){\n\t\tif(memoX[i] != -1) m++;\n\t}\n\t???????????¨?????????????????????????????£??????\n\t*/\n\tset<int> sum;\n\trep(i, w){\n\t\tif(memoX[i] != -1) sum.insert(ds.findSet(memoX[i]));\n\t}\n\n\tint m = sum.size();//??£?????????????????°\n\n\t//printf(\"%d\\n\", m);\n\tif(m > 1){\n\t\tif(cornerw == true || cornerh == true){\n\t\t\tprintf(\"%d\\n\", n + m - 2);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\", n + m - 1);\n\t\t}\n\t}else{\n\t\tprintf(\"%d\\n\", n - 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint dp[1001][1001];\nint main() {\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tunionfind uf(w + h);\n\tvpii s(n);\n\trep(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ts[i] = { a,b };\n\t\tuf.unite(a - 1, w + b - 1);\n\t}\n\tuset<int> t,e[4];\n\trep(i, n) {\n\t\tint a = uf.find(s[i].first - 1);\n\t\tt.insert(a);\n\t\tif (s[i].first == 1)e[0].insert(a);\n\t\tif (s[i].first == w)e[1].insert(a);\n\t\tif (s[i].second == 1)e[2].insert(a);\n\t\tif(s[i].second == h)e[3].insert(a);\n\t}\n\tint k = t.size();\n\tint m = 0;\n\trep(i, 4)cmax(m, e[i].size());\n\tif (k > 1)k = k * 2 -m - 1 + n - k;\n\telse k = n - 1;\n\tcout << k << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, h, w, x[40000], y[40000];\nint p[40000], flag[40000], c;\nint root(int x){\n\tif(x == p[x]) return x;\n\treturn p[x] = root(p[x]);\n}\nbool use[40000];\nvi tate[100000], yoko[100000];\n\nvoid merge(int a, int b){\n\ta = root(a); b = root(b);\n\tif(a == b) return;\n\tc--;\n\tp[a] = b;\n\tflag[b] |= flag[a];\n}\nint main(){\n\tcin >> n >> w >> h;\n\trep(i, n){\n\t\tcin >> x[i] >> y[i];\n\t\tif(x[i] == 1) flag[i] |= 1 << 0;\n\t\tif(x[i] == w) flag[i] |= 1 << 1;\n\t\tif(y[i] == 1) flag[i] |= 1 << 2;\n\t\tif(y[i] == h) flag[i] |= 1 << 3;\n\t\tp[i] = i;\n\t\t\n\t\ttate[x[i] - 1].pb(i);\n\t\tyoko[y[i] - 1].pb(i);\n\t}\n\tc = n;\n\trep(i, 100000){\n\t\tif(tate[i].size() > 1) rep(j, tate[i].size() - 1) merge(tate[i][j], tate[i][j + 1]);\n\t\tif(yoko[i].size() > 1) rep(j, yoko[i].size() - 1) merge(yoko[i][j], yoko[i][j + 1]);\n\t}\n\tint ans = inf, cnt[4] = {};\n\trep(i, n){\n\t\tint r = root(i);\n\t\tif(use[r]) continue;\n\t\tuse[r] = 1;\n\t\trep(j, 4) if(flag[r] & 1 << j) cnt[j]++;\n\t}\n\trep(i, 4) ans = min(ans, n - 1 + c - cnt[i]);\n\tif(c == 1) ans = n - 1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 40005\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\n\nint par[MAX_N];\nint cnt[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=0;\n    cnt[i]=1;\n  }\n}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n    cnt[y]+=cnt[x];\n  }\n  else{\n    par[y]=x;\n    cnt[x]+=cnt[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvector<int> W[N],H[N];\nbool used[MAX_N];\n\nint main(){\n  int n,w,h,x,y,f=0;\n  cin>>n>>w>>h;\n  init(n);\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    x--,y--;\n    if(!x||x==w-1||!y||y==h-1)f=1;\n    W[x].push_back(i);\n    H[y].push_back(i);\n  }\n  for(int i=0;i<h;i++)\n    for(int j=1;j<H[i].size();j++)\n      unite(H[i][0],H[i][j]);\n  for(int i=0;i<w;i++)\n    for(int j=1;j<W[i].size();j++)\n      unite(W[i][0],W[i][j]);\n  int ans=1,gcnt=0;\n  for(int i=0;i<n;i++){\n    int pa=find(i);\n    if(used[pa])continue;\n    used[pa]=true;\n    gcnt++;\n    ans+=cnt[pa]-1;\n  }\n  if(gcnt==1)cout<<ans-1<<endl;\n  else{\n    gcnt--;\n    ans+=gcnt*2;\n    ans-=f;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ws ____ws\nint u[108000];\nint r(int x){\n\tif(x == u[x])return x;\n\treturn u[x] = r(u[x]);\n}\n\nvoid unite(int a, int b){\n\ta = r(a);\n\tb = r(b);\n\tif(a != b)\n\tu[a] = b;\n}               \n\nvector<int> ws[108000], hs[108000];\n\nint main(){\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tint cnt = n, res, x, y;\n\tbool edge;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x >> y ;\n\t\tif(x == w || y == h || x == 1 || y == 1)edge=true;\n\t\tws[x].push_back(i);\n\t\ths[y].push_back(i);\n\t}\n\t\n\tfor(int i = 0;i < n;i++)u[i] = i;\n\tfor(int i = 0;i <= 100000;i++){\n\t\tfor(int j = 0;j < ws[i].size();j++){\n\t\t\tif(r(ws[i][j]) != r(ws[i][0]))cnt--;\n\t\t\tunite(ws[i][j], ws[i][0]);\n\t\t}\n\t\tfor(int j = 0;j < hs[i].size();j++){    \n\t\t\tif(r(hs[i][j]) != r(hs[i][0]))cnt--;\n\t\t\tunite(hs[i][j], hs[i][0]);\n\t\t}\n\t}\n\t\n\tres = n - cnt;\n\tif(cnt > 1)res += cnt * 2 - 1 - edge;\n\tif(n == 2 && res == 3)exit(100);\n\tcout << res << endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n, w, h;\n\tcin >> n >> w >> h;\n\tvector<pair<int, int> > place;\n\tvector<vector<int> > x(40001), y(40001);\n\tfor(int i = 0; i < n; i++){\n\t\tint tmpx, tmpy;\n\t\tcin >> tmpx >> tmpy;\n\t\tplace.push_back(make_pair(tmpx, tmpy));\n\t\tx[tmpx].push_back(i);\n\t\ty[tmpy].push_back(i);\n\t}\n\tvector<int> groupnum(40000, -1);\n\tvector<int> groupsize;\n\tvector<vector<bool> > isclosetowall;\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(groupnum[i] < 0){\n\t\t\t// cout << i << endl;\n\t\t\tqueue<int> qu;\n\t\t\tqu.push(i);\n\t\t\tgroupnum[i] = cnt;\n\t\t\tisclosetowall.push_back(vector<bool>(4, false));\n\t\t\tgroupsize.push_back(1);\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint now = qu.front();\n\t\t\t\tint nowx = place[now].first;\n\t\t\t\tint nowy = place[now].second;\n\t\t\t\tqu.pop();\n\t\t\t\tif(nowx == 1) isclosetowall[cnt][0] = true;\n\t\t\t\tif(nowx == h) isclosetowall[cnt][1] = true;\n\t\t\t\tif(nowy == 1) isclosetowall[cnt][2] = true;\n\t\t\t\tif(nowy == w) isclosetowall[cnt][3] = true;\n\t\t\t\tfor(int j = 0; j < x[nowx].size(); j++){\n\t\t\t\t\tint nowindex = x[nowx][j];\n\t\t\t\t\tif(nowindex == now) continue;\n\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t}\n\t\t\t\tx.erase(x.begin() + nowx);\n\t\t\t\tfor(int j = 0; j < y[nowy].size(); j++){\n\t\t\t\t\tint nowindex = y[nowy][j];\n\t\t\t\t\tif(nowindex == now) continue;\n\t\t\t\t\tgroupnum[nowindex] = cnt;\n\t\t\t\t\tgroupsize[cnt]++;\n\t\t\t\t\tqu.push(nowindex);\n\t\t\t\t}\n\t\t\t\ty.erase(y.begin() + nowy);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t// cout << i << \" \" << groupnum[i] << endl;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < cnt; i++){\n\t\tsum += groupsize[i] - 1;\n\t}\n\tif(cnt == 1){\n\t\tcout << sum << endl;\n\t\treturn 0;\n\t}\n\tint ans = mod;\n\tfor(int i = 0; i < 4; i++){\n\t\tint needtomove = 0;\n\t\tfor(int j = 0; j < cnt; j++){\n\t\t\tif(!isclosetowall[j][i]) needtomove++;\n\t\t}\n\t\tans = min(ans, sum + needtomove + cnt - 1);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2382: King Slime\n// 2018.1.22 bal4u@uu\n\n#include <stdio.h>\n\n#define MAX 40002\n\n/* UNION-FIND library */\nint id[MAX], size[MAX];\n\nvoid init(int n)\n{\n\tint i;\n\tfor (i = 1; i <= n; i++) id[i] = i, size[i] = 1;\n}\n\nint root(int i)\n{\n\twhile (i != id[i]) id[i] = id[id[i]], i = id[i];\n\treturn i;\n}\n\nint connected(int p, int q) { return root(p) == root(q); }\n\nvoid unite(int p, int q)\n{\n    int i = root(p), j = root(q);\n\tif (i == j) return;\n    if (size[i] < size[j]) id[i] = j, size[j] += size[i];\n    else                   id[j] = i, size[i] += size[j];\n}\n/* UNION-FIND library */\n\n\nint xx[100002], yy[100002];\nchar tbl[40002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, w, h, i, x, y, f, ans;\n\n\tn = in(), w = in(), h = in();\n\tinit(n);\n\n\tf = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tx = in(), y = in();\n\t\tif (x == 1 || x == w || y == 1 || y == h) f = 1;\n\t\tif (!xx[x]) xx[x] = i; else unite(xx[x], i);\n\t\tif (!yy[y]) yy[y] = i; else unite(yy[y], i);\n\t}\n\n\tans = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tx = root(i);\n\t\tif (!tbl[x]) ans++, tbl[x] = 1;\n\t}\n\tif (ans == 1) f = 1;\n\tans += n - (f + 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint h = io.nextInt();\n\t\tint w = io.nextInt();\n\t\tPair[] p = new Pair[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = io.nextInt() - 1;\n\t\t\tint y = io.nextInt() - 1;\n\t\t\tp[i] = new Pair(i, y, x);\n\t\t}\n\t\tint[] attr = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (p[i].i == 0)   attr[i] |= 1;\n\t\t\tif (p[i].i == h-1) attr[i] |= 2;\n\t\t\tif (p[i].j == 0)   attr[i] |= 4;\n\t\t\tif (p[i].j == w-1) attr[i] |= 8;\n\t\t}\n\t\tUnionFind uf = new UnionFind(attr);\n\t\tArrays.sort(p, (p1,p2)->Integer.compare(p1.i, p2.i));\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif (p[i].i == p[i+1].i) {\n\t\t\t\tuf.union(p[i].id, p[i+1].id);\n\t\t\t}\n\t\t}\n\t\tArrays.sort(p, (p1,p2)->Integer.compare(p1.j, p2.j));\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif (p[i].j == p[i+1].j) {\n\t\t\t\tuf.union(p[i].id, p[i+1].id);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> attrs = uf.attrs();\n\t\tif (attrs.size() == 1) {\n\t\t\tSystem.out.println(n - 1);\n\t\t}else{\n\t\t\tint[] count = new int[4];\n\t\t\tfor(int a: attrs) {\n\t\t\t\tfor(int j=0;j<4;j++) {\n\t\t\t\t\tif ((a >> j & 1) == 1) {\n\t\t\t\t\t\tcount[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tmax = Math.max(max, count[i]);\n\t\t\t}\n\t\t\tint m = attrs.size();\n\t\t\tSystem.out.println(m - max + m - 1 + n - m);\n\t\t}\n\t}\n\n}\nclass Pair {\n\tint id,i,j;\n\n\tpublic Pair(int id, int i, int j) {\n\t\tsuper();\n\t\tthis.id = id;\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t}\n\t\n}\nclass UnionFind {\n\tint[] parent;\n\tint[] attr;\n\tpublic UnionFind(int[] attr) {\n\t\tthis.attr = attr;\n\t\tint n = attr.length;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\tattr[x] |= attr[y];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic int attr(int x) {\n\t\treturn attr[root(x)];\n\t}\n\tpublic ArrayList<Integer> attrs() {\n\t\tArrayList<Integer> ret = new ArrayList<>();\n\t\tfor(int i=0;i<parent.length;i++) {\n\t\t\tif (parent[i] < 0) {\n\t\t\t\tret.add(attr[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(parent);\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0 && x0 == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1 && xw == 0)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0 && y0 == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1 && yh == 0)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif (ds.count() == 1) {\n\t\t\tSystem.out.println(sum);\n\t\t} else {\n\t\t\tsum +=2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif(ds.count()==1){\n\t\t\tSystem.out.println(sum);\n\t\t}else{\n\t\t\tsum= + 2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif(ds.count()==1){\n\t\t\tSystem.out.println(sum);\n\t\t}else{\n\t\t\tsum= + 2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0 && x0 == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1 && xw == 0)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0 && y0 == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1 && yh == 0)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif (ds.count() == 1) {\n\t\t\tSystem.out.println(sum);\n\t\t} else {\n\t\t\tsum +=2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0 && x0 == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1 && xw == 0)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0 && y0 == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1 && yh == 0)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif (ds.count() == 1) {\n\t\t\tSystem.out.println(sum);\n\t\t} else {\n\t\t\tsum +=2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif(ds.count()==1){\n\t\t\tSystem.out.println(sum);\n\t\t}else{\n\t\t\tsum= + 2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0 && x0 == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1 && xw == 0)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0 && y0 == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1 && yh == 0)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif (ds.count() == 1) {\n\t\t\tSystem.out.println(sum);\n\t\t} else {\n\t\t\tsum +=2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint h = io.nextInt();\n\t\tint w = io.nextInt();\n\t\tPair[] p = new Pair[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = io.nextInt() - 1;\n\t\t\tint y = io.nextInt() - 1;\n\t\t\tp[i] = new Pair(i, y, x);\n\t\t}\n\t\tint[] attr = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (p[i].i == 0)   attr[i] |= 1;\n\t\t\tif (p[i].i == h-1) attr[i] |= 2;\n\t\t\tif (p[i].j == 0)   attr[i] |= 4;\n\t\t\tif (p[i].j == w-1) attr[i] |= 8;\n\t\t}\n\t\tUnionFind uf = new UnionFind(attr);\n\t\tArrays.sort(p, (p1,p2)->Integer.compare(p1.i, p2.i));\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif (p[i].i == p[i+1].i) {\n\t\t\t\tuf.union(p[i].id, p[i+1].id);\n\t\t\t}\n\t\t}\n\t\tArrays.sort(p, (p1,p2)->Integer.compare(p1.j, p2.j));\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif (p[i].j == p[i+1].j) {\n\t\t\t\tuf.union(p[i].id, p[i+1].id);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> attrs = uf.attrs();\n\t\tif (attrs.size() == 1) {\n\t\t\tSystem.out.println(n - 1);\n\t\t}else{\n\t\t\tint[] count = new int[4];\n\t\t\tfor(int a: attrs) {\n\t\t\t\tfor(int j=0;j<4;j++) {\n\t\t\t\t\tif ((a >> j & 1) == 1) {\n\t\t\t\t\t\tcount[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tmax = Math.max(max, count[i]);\n\t\t\t}\n\t\t\tSystem.out.println(n - max + n - 1 + n - attrs.size());\n\t\t}\n\t}\n\n}\nclass Pair {\n\tint id,i,j;\n\n\tpublic Pair(int id, int i, int j) {\n\t\tsuper();\n\t\tthis.id = id;\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t}\n\t\n}\nclass UnionFind {\n\tint[] parent;\n\tint[] attr;\n\tpublic UnionFind(int[] attr) {\n\t\tthis.attr = attr;\n\t\tint n = attr.length;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\tattr[x] |= attr[y];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic int attr(int x) {\n\t\treturn attr[root(x)];\n\t}\n\tpublic ArrayList<Integer> attrs() {\n\t\tArrayList<Integer> ret = new ArrayList<>();\n\t\tfor(int i=0;i<parent.length;i++) {\n\t\t\tif (parent[i] < 0) {\n\t\t\t\tret.add(attr[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(parent);\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tsolver();\n\t}\n\n\tstatic void solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tArrayList<Integer>[] x_ord = new ArrayList[w];\n\t\tArrayList<Integer>[] y_ord = new ArrayList[h];\n\t\tfor (int i = 0; i < w; i++)\n\t\t\tx_ord[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++)\n\t\t\ty_ord[i] = new ArrayList<>();\n\t\tint x0 = 0, xw = 0, y0 = 0, yh = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt() - 1;\n\t\t\ty[i] = sc.nextInt() - 1;\n\t\t\tif (x[i] == 0)\n\t\t\t\tx0++;\n\t\t\telse if (x[i] == w - 1)\n\t\t\t\txw++;\n\t\t\tif (y[i] == 0)\n\t\t\t\ty0++;\n\t\t\telse if (y[i] == h - 1)\n\t\t\t\tyh++;\n\t\t\tx_ord[x[i]].add(i);\n\t\t\ty_ord[y[i]].add(i);\n\t\t}\n\t\tint d = Math.max(Math.max(x0, xw), Math.max(y0, yh));\n\n\t\tDJSet ds = new DJSet(n);\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\twhile (!x_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < x_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(x_ord[i].get(0), x_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\tx_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\twhile (!y_ord[i].isEmpty()) {\n\t\t\t\tfor (int j = 0; j < y_ord[i].size(); j++) {\n\t\t\t\t\tds.setUnion(y_ord[i].get(0), y_ord[i].get(j));\n\t\t\t\t}\n\t\t\t\ty_ord[i].clear();\n\t\t\t}\n\t\t}\n\t\tint sum = n - ds.count();\n\t\tif(ds.count()==1){\n\t\t\tSystem.out.println(sum);\n\t\t}else{\n\t\t\tsum= + 2 * ds.count() - 1 - d;\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static class DJSet {\n\t\tint n;// the number of vertices\n\t\tint[] d;\n\n\t\tDJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn d[x] < 0 ? x : root(d[x]);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (x < y) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\t// x>y\n\t\t\t\td[y] += d[x];\n\t\t\t\td[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\t// the number of nodes of which graph contains x\n\t\tint size(int x) {\n\t\t\treturn d[root(x)] * (-1);\n\t\t}\n\n\t\t// the number of connected graphs\n\t\tint count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : d) {\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t\treturn ct;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint w = io.nextInt();\n\t\tint h = io.nextInt();\n\t\tPair[] p = new Pair[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint x = io.nextInt() - 1;\n\t\t\tint y = io.nextInt() - 1;\n\t\t\tp[i] = new Pair(i, y, x);\n\t\t}\n\t\tint[] attr = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (p[i].i == 0)   attr[i] |= 1;\n\t\t\tif (p[i].i == h-1) attr[i] |= 2;\n\t\t\tif (p[i].j == 0)   attr[i] |= 4;\n\t\t\tif (p[i].j == w-1) attr[i] |= 8;\n\t\t}\n\t\tUnionFind uf = new UnionFind(attr);\n\t\tArrays.sort(p, (p1,p2)->Integer.compare(p1.i, p2.i));\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif (p[i].i == p[i+1].i) {\n\t\t\t\tuf.union(p[i].id, p[i+1].id);\n\t\t\t}\n\t\t}\n\t\tArrays.sort(p, (p1,p2)->Integer.compare(p1.j, p2.j));\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tif (p[i].j == p[i+1].j) {\n\t\t\t\tuf.union(p[i].id, p[i+1].id);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> attrs = uf.attrs();\n//\t\tSystem.out.println(attrs);\n\t\tif (attrs.size() == 1) {\n\t\t\tSystem.out.println(n - 1);\n\t\t}else{\n\t\t\tint[] count = new int[4];\n\t\t\tfor(int a: attrs) {\n\t\t\t\tfor(int j=0;j<4;j++) {\n\t\t\t\t\tif ((a >> j & 1) == 1) {\n\t\t\t\t\t\tcount[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tmax = Math.max(max, count[i]);\n\t\t\t}\n\t\t\tint m = attrs.size();\n\t\t\tSystem.out.println(m - max + m - 1 + n - m);\n\t\t}\n\t}\n\n}\nclass Pair {\n\tint id,i,j;\n\n\tpublic Pair(int id, int i, int j) {\n\t\tsuper();\n\t\tthis.id = id;\n\t\tthis.i = i;\n\t\tthis.j = j;\n\t}\n\t\n}\nclass UnionFind {\n\tint[] parent;\n\tint[] attr;\n\tpublic UnionFind(int[] attr) {\n\t\tthis.attr = attr;\n\t\tint n = attr.length;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\tattr[x] |= attr[y];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic int attr(int x) {\n\t\treturn attr[root(x)];\n\t}\n\tpublic ArrayList<Integer> attrs() {\n\t\tArrayList<Integer> ret = new ArrayList<>();\n\t\tfor(int i=0;i<parent.length;i++) {\n\t\t\tif (parent[i] < 0) {\n\t\t\t\tret.add(attr[i]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(parent);\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing P = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var h = ri; var w = ri;\n            var A = Enumerate(h, x => new List<int>());\n            var B = Enumerate(w, x => new List<int>());\n            for (int i = 0; i < n; i++)\n            {\n                var x = ri - 1; var y = ri - 1;\n                A[x].Add(i); B[y].Add(i);\n            }\n            par = Enumerate(n, x => x);\n            var ans = 0;\n            foreach (var x in A.Concat(B))\n                for (int i = 0; i < x.Count - 1; i++)\n                    if (unite(x[i], x[i + 1])) ans++;\n            var cnt = Enumerate(n, x => x).Count(x => find(x) == x);\n            if (cnt > 1)\n            {\n                ans += cnt - 1;\n                if (A[0].Count == 0 && A[h - 1].Count == 0 && B[0].Count == 0 && B[w - 1].Count == 0) ans += cnt;\n                else ans += cnt - 1;\n            }\n            Console.WriteLine(ans);\n        }\n        int[] par;\n        bool unite(int i, int j) {\n            i = find(i);\n            j = find(j);\n            if (i == j) return false;\n            par[j] = i;\n            return true;\n        }\n        int find(int i) {\n            Debug.WriteLine(i);\n            if (par[i] == i) return i;\n            else return par[i] = find(par[i]);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tdef root(obj)\n\t\t(@obj_to_node[obj] ||= Node.new(obj)).root.obj\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\t\tattr_reader :obj\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\nend\n\nn, w, h = gets.split.map(&:to_i)\nrow_rep = {}\ncol_rep = {}\nu = UnionFind.new\n\non_wall = false\nn.times do |i|\n\tx, y = gets.split.map(&:to_i)\n\tif x == 1 || x == w || y == 1 || y == h\n\t\ton_wall = true\n\tend\n\tif j = col_rep[x]\t\t\n\t\tu.union(i, j)\n\telse\n\t\tcol_rep[x] = i\n\tend\t\n\tif j = row_rep[y]\t\t\n\t\tu.union(i, j)\n\telse\n\t\trow_rep[y] = i\n\tend\t\nend\n\nroots = (0..n-1).map {|i| u.root(i)}.uniq\nk = roots.map{|r| u.size(r) - 1}.inject(:+)\nif roots.size > 1\n\tk += roots.size * 2 - 1\n\tk -= 1 if on_wall\nend\nputs k"
  },
  {
    "language": "Python",
    "code": "\nN, W, H = map(int, raw_input().split())\n\nE = [[] for i in range(N)]\nlst = []\nflag = True\n\nfor i in range(N):\n    x, y = map(int, raw_input().split())\n    if x == 1 or y == 1 or x == W or y == H:\n        flag = False\n    lst.append((x, y, i))\n\nlst.sort()\nfor i in range(N):\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nlst2 = []\n\nfor i in range(N):\n    x, y, index = lst[i]\n    lst2.append((y, x, index))\n\nlst = lst2\nlst.sort()\nfor i in range(N):\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nused = [False for i in range(N)]\n\ndef func(num, pre):\n    if used[num]:\n        return\n    used[num] = True\n    for to in E[num]:\n        if to != pre:\n            func(to, num)\n\ncnt = 0\n\nfor i in range(N):\n    if not used[i]:\n        func(i, -1)\n        cnt += 1\n\nif cnt > 1 and flag:\n    cnt += 1\nprint N - 2 + cnt\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nN, H, W = map(int, raw_input().split())\n\nE = [[] for i in range(N)]\nlst = []\nflag = True\n\nfor i in range(N):\n    x, y = map(int, raw_input().split())\n    if x == 1 or y == 1 or x == W or y == H:\n        flag = False\n    lst.append((x, y, i))\n\nlst.sort()\n\nfor i in range(N):\n    if i + 1 != N and lst[i][0] == lst[i + 1][0]:\n        E[lst[i][2]].append(lst[i + 1][2])\n        E[lst[i + 1][2]].append(lst[i][2])\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nlst2 = []\n\nfor i in range(N):\n    x, y, index = lst[i]\n    lst2.append((y, x, index))\n\nlst = lst2\nlst.sort()\n\nfor i in range(N):\n    if i + 1 != N and lst[i][0] == lst[i + 1][0]:\n        E[lst[i][2]].append(lst[i + 1][2])\n        E[lst[i + 1][2]].append(lst[i][2])\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nused = [False for i in range(N)]\n\ndef func(num, pre):\n    if used[num]:\n        return\n    used[num] = True\n    for to in E[num]:\n        if to != pre:\n            func(to, num)\n\n#print E\n\ncnt = 0\n\nfor i in range(N):\n    if not used[i]:\n        func(i, -1)\n        cnt += 1\n\nif cnt > 1 and flag:\n    cnt += 1\nprint N - 2 + cnt\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.data=[-1 for i in range(n)]\n\n    def root(self,x):\n        if self.data[x]<0:\n            return x\n        else:\n            self.data[x]=self.root(self.data[x])\n            return self.data[x]\n\n    def uni(self,x,y):\n        x=self.root(x)\n        y=self.root(y)\n        if(x==y):\n            return\n        if self.data[y]<self.data[x]:\n            x,y=y,x\n        self.data[x]+= self.data[y]\n        self.data[y] = x\n\n    def same(self,x,y):\n        return self.root(x)==self.root(y)\n\n    def size(self,x):\n        return -self.data[self.root(x)]\n\nn,w,h=map(int,input().split())\nslime_w = [[]for i in range(w)]\nslime_h = [[]for i in range(h)]\nuf=UnionFind(n)\nf=False\nfor i in range(n):\n    x,y=map(int,input().split())\n    if x==1 or y==1 or x==w or y==h:\n        f=True\n    x,y=x-1,y-1\n    slime_w[x].append(i)\n    slime_h[y].append(i)\nfor i in range(h):\n    if len(slime_h[i])>1:\n        p=slime_h[i][0]\n    for j in range(1,len(slime_h[i])):\n        uf.uni(p,slime_h[i][j])\nfor i in range(w):\n    if len(slime_w[i])>1:\n        p=slime_w[i][0]\n    for j in range(1,len(slime_w[i])):\n        uf.uni(p,slime_w[i][j])\ncount=[-e-1 for e in uf.data if e<0]\nif f:\n    print(sum(count)+(len(count)-1+len(count)-1 if len(count)!=1 else 0))\nelse:\n    print(sum(count)+(len(count)+len(count)-1 if len(count)!=1 else 0))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN, W, H = map(int, input().split())\n\n*p, = range(N)\ndef root(x):\n    if x == p[x]:\n        return x\n    p[x] = y = root(p[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\n\nX = defaultdict(list)\nY = defaultdict(list)\nfor i in range(N):\n    x, y = map(int, input().split())\n    X[x].append(i)\n    Y[y].append(i)\n\nfor x, vs in X.items():\n    prv = vs[0]\n    for v in vs[1:]:\n        unite(prv, v)\n        prv = v\nfor y, vs in Y.items():\n    prv = vs[0]\n    for v in vs[1:]:\n        unite(prv, v)\n        prv = v\n\ncnt = 0\nfor i in range(N):\n    pt = root(i)\n    if pt == i:\n        cnt += 1\nans = N-cnt + 2*(cnt-1)\nif cnt > 1 and 1 not in X and W not in X and 1 not in Y and H not in Y:\n    ans += 1\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nN, W, H = map(int, raw_input().split())\n\nE = [[] for i in range(N)]\nlst = []\nflag = True\n\nfor i in range(N):\n    x, y = map(int, raw_input().split())\n    if x == 1 or y == 1 or x == W or y == H:\n        flag = False\n    lst.append((x, y, i))\n\nlst.sort()\nfor i in range(N):\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nlst2 = []\n\nfor i in range(N):\n    x, y, index = lst[i]\n    lst2.append((y, x, index))\n\nlst = lst2\nlst.sort()\nfor i in range(N):\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nused = [False for i in range(N)]\n\ndef func(num, pre):\n    if used[num]:\n        return\n    used[num] = True\n    for to in E[num]:\n        if to != pre:\n            func(to, num)\n\ncnt = 0\n\nfor i in range(N):\n    if not used[i]:\n        func(i, -1)\n        cnt += 1\n\nif cnt > 1 and flag:\n    cnt += 1\nprint N - 2 + cnt\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass UnionFind:\n    def __init__(self,sz):\n        self.__ranks = [1] * sz\n        self.__parents = [ i for i in range(sz) ]\n    def find_parent(self, x):\n        if x == self.__parents[x]:\n            return x\n        else:\n            self.__parents[x] = self.find_parent(self.__parents[x])\n            return self.__parents[x]\n    def same(self, x, y):\n        return self.find_parent(x) == self.find_parent(y)\n    def unite(self, x, y):\n        px = self.find_parent(x)\n        py = self.find_parent(y)\n        if px == py:\n            return\n        if self.__ranks[px] > self.__ranks[py]:\n            self.__parents[py] = px\n        else:\n            self.__parents[px] = py\n            if self.__ranks[px] == self.__ranks[py]:\n                self.__ranks[py] += 1\n\ndef main():\n    n,w,h = map(int, input().split())\n\n    uf = UnionFind(n)\n    xd = {}\n    yd = {}\n    is_edges_slime = False\n    for i in range(n):\n        x,y = map(int, sys.stdin.readline().split())\n\n        if x == 1 or x == w:\n            is_edges_slime = True\n        if y == 1 or y == h:\n            is_edges_slime = True\n\n        if x in xd:\n            uf.unite(xd[x], i)\n        else:\n            xd[x] = i\n        \n        if y in yd:\n            uf.unite(yd[y], i)\n        else:\n            yd[y] = i\n\n    root = set()\n    for i in range(n):\n        root.add( uf.find_parent(i) )\n\n    if len(root) == 1:\n        print(n - 1)\n    else:\n        ans = n - len(root) # ????´?????????¨??????\n        ans += len(root) - (1 if is_edges_slime else 0) # ???????????????\n        ans += len(root) - 1 # ????????°???????????????\n        print(ans)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    rr = []\n\n    def f(n,w,h):\n        wd = {}\n        hd = {}\n        kf = 0\n        uf = UnionFind(n+1)\n        uc = 0\n        for i in range(n):\n            x,y = LI()\n            if x in wd:\n                if uf.union(wd[x], i):\n                    uc += 1\n            else:\n                wd[x] = i\n            if y in hd:\n                if uf.union(hd[y], i):\n                    uc += 1\n            else:\n                hd[y] = i\n            if x == 1 or y == 1 or x == w or y == h:\n                kf = 1\n        r = uc\n        nk = n - uc\n        if nk == 1:\n            return r\n        r += nk - kf + nk - 1\n\n        return r\n\n    while 1:\n        n,w,h = LI()\n        if n == 0:\n            break\n        rr.append(f(n,w,h))\n        # print(n, rr[-1])\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nN, W, H = map(int, raw_input().split())\n\nE = [[] for i in range(N)]\nlst = []\nflag = True\n\nfor i in range(N):\n    x, y = map(int, raw_input().split())\n    if x == 1 or y == 1 or x == W or y == H:\n        flag = False\n    lst.append((x, y, i))\n\nlst.sort()\nfor i in range(N):\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nlst2 = []\n\nfor i in range(N):\n    x, y, index = lst[i]\n    lst2.append((y, x, index))\n\nlst = lst2\nlst.sort()\nfor i in range(N):\n    if lst[i][0] == lst[i - 1][0]:\n        E[lst[i][2]].append(lst[i - 1][2])\n        E[lst[i - 1][2]].append(lst[i][2])\n\nused = [False for i in range(N)]\n\ndef func(num, pre):\n    if used[num]:\n        return\n    used[num] = True\n    for to in E[num]:\n        if to != pre:\n            func(to, num)\n\n#print E\n\ncnt = 0\n\nfor i in range(N):\n    if not used[i]:\n        func(i, -1)\n        cnt += 1\n\nif cnt > 1 and flag:\n    cnt += 1\nprint N - 2 + cnt\n"
  }
]