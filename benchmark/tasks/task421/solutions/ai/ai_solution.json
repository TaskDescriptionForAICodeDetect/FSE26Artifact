[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint W, H, N;\nPoint slimes[100];\nint min_moves = INT_MAX;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint abs_diff(int a, int b) {\n    return a > b ? a - b : b - a;\n}\n\nint calculate_max_distance(Point target) {\n    int max_dist = 0;\n    for (int i = 0; i < N; i++) {\n        int dist;\n        if (slimes[i].x == target.x) {\n            dist = abs_diff(slimes[i].y, target.y);\n        } else if (slimes[i].y == target.y) {\n            dist = abs_diff(slimes[i].x, target.x);\n        } else {\n            dist = abs_diff(slimes[i].x, target.x) + abs_diff(slimes[i].y, target.y);\n        }\n        max_dist = max(max_dist, dist);\n    }\n    return max_dist;\n}\n\nvoid find_min_moves() {\n    for (int x = 1; x <= W; x++) {\n        for (int y = 1; y <= H; y++) {\n            Point target = {x, y};\n            int current_max = calculate_max_distance(target);\n            if (current_max < min_moves) {\n                min_moves = current_max;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &W, &H, &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &slimes[i].x, &slimes[i].y);\n    }\n    find_min_moves();\n    printf(\"%d\\n\", min_moves);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\nint W, H, N;\nvector<Point> slimes;\n\nint dist(const Point &a, const Point &b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nint calculateMinTime() {\n    if (slimes.size() <= 1) return 0;\n    \n    vector<int> minX(N), maxX(N), minY(N), maxY(N);\n    for (int i = 0; i < N; ++i) {\n        minX[i] = slimes[i].x;\n        maxX[i] = slimes[i].x;\n        minY[i] = slimes[i].y;\n        maxY[i] = slimes[i].y;\n    }\n    \n    int res = INT_MAX;\n    \n    for (int x = 1; x <= W; ++x) {\n        for (int y = 1; y <= H; ++y) {\n            int total = 0;\n            for (int i = 0; i < N; ++i) {\n                int dx = max({minX[i] - x, x - maxX[i], 0});\n                int dy = max({minY[i] - y, y - maxY[i], 0});\n                total = max(total, dx + dy);\n            }\n            res = min(res, total);\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    cin >> W >> H >> N;\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        slimes.emplace_back(x, y);\n    }\n    \n    cout << calculateMinTime() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KingSlime {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int W = sc.nextInt();\n        int H = sc.nextInt();\n        int N = sc.nextInt();\n        List<Point> slimes = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            slimes.add(new Point(x, y));\n        }\n\n        int minX = Integer.MAX_VALUE;\n        int maxX = Integer.MIN_VALUE;\n        int minY = Integer.MAX_VALUE;\n        int maxY = Integer.MIN_VALUE;\n\n        for (Point p : slimes) {\n            minX = Math.min(minX, p.x);\n            maxX = Math.max(maxX, p.x);\n            minY = Math.min(minY, p.y);\n            maxY = Math.max(maxY, p.y);\n        }\n\n        int moves = (maxX - minX) + (maxY - minY);\n        System.out.println(moves);\n    }\n}",
    "timestamp": "2025-08-05 21:28:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SlimeUnion {\n    static int W, H;\n    static char[][] grid;\n    static List<int[]> slimes;\n    static final int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public static int minimumMoves() {\n        if (slimes.size() <= 1) return 0;\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.offer(new State(slimes, 0));\n        visited.add(encodeState(slimes));\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            if (current.slimes.size() == 1) {\n                return current.moves;\n            }\n            \n            for (int i = 0; i < current.slimes.size(); i++) {\n                for (int[] dir : directions) {\n                    List<int[]> newSlimes = moveSlime(current.slimes, i, dir);\n                    \n                    if (newSlimes != null) {\n                        String stateKey = encodeState(newSlimes);\n                        if (!visited.contains(stateKey)) {\n                            visited.add(stateKey);\n                            queue.offer(new State(newSlimes, current.moves + 1));\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static List<int[]> moveSlime(List<int[]> currentSlimes, int slimeIndex, int[] direction) {\n        List<int[]> newSlimes = new ArrayList<>(currentSlimes);\n        int[] slime = currentSlimes.get(slimeIndex);\n        int x = slime[0], y = slime[1];\n        \n        while (true) {\n            int nx = x + direction[0];\n            int ny = y + direction[1];\n            \n            if (nx < 0 || nx >= W || ny < 0 || ny >= H || grid[ny][nx] == '#') {\n                break;\n            }\n            \n            boolean hitSlime = false;\n            for (int j = 0; j < newSlimes.size(); j++) {\n                if (j != slimeIndex && newSlimes.get(j)[0] == nx && newSlimes.get(j)[1] == ny) {\n                    newSlimes.remove(slimeIndex);\n                    newSlimes.remove(j > slimeIndex ? j - 1 : j);\n                    newSlimes.add(new int[]{nx, ny});\n                    hitSlime = true;\n                    break;\n                }\n            }\n            \n            if (hitSlime) break;\n            \n            x = nx;\n            y = ny;\n        }\n        \n        if (x == slime[0] && y == slime[1]) return null;\n        \n        newSlimes.set(slimeIndex, new int[]{x, y});\n        return newSlimes;\n    }\n    \n    static String encodeState(List<int[]> slimes) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] slime : slimes) {\n            sb.append(slime[0]).append(\",\").append(slime[1]).append(\";\");\n        }\n        return sb.toString();\n    }\n    \n    static class State {\n        List<int[]> slimes;\n        int moves;\n        \n        State(List<int[]> slimes, int moves) {\n            this.slimes = slimes;\n            this.moves = moves;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        W = scanner.nextInt();\n        H = scanner.nextInt();\n        \n        grid = new char[H][W];\n        slimes = new ArrayList<>();\n        \n        for (int y = 0; y < H; y++) {\n            String row = scanner.next();\n            grid[y] = row.toCharArray();\n            for (int x = 0; x < W; x++) {\n                if (grid[y][x] == 'S') {\n                    slimes.add(new int[]{x, y});\n                }\n            }\n        }\n        \n        System.out.println(minimumMoves());\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:29:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 50\n#define MAX_H 50\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint grid[MAX_W][MAX_H];\nint W, H;\nPoint slimes[MAX_W * MAX_H];\nint slime_count;\n\nint min_moves = INT_MAX;\n\nint abs_diff(int a, int b) {\n    return a > b ? a - b : b - a;\n}\n\nvoid solve(int moves) {\n    if (slime_count == 1) {\n        min_moves = moves < min_moves ? moves : min_moves;\n        return;\n    }\n\n    for (int i = 0; i < slime_count; i++) {\n        for (int j = i + 1; j < slime_count; j++) {\n            Point s1 = slimes[i];\n            Point s2 = slimes[j];\n\n            if (s1.x == s2.x && s1.y == s2.y) continue;\n\n            // Move horizontally\n            Point new_s1 = s1, new_s2 = s2;\n            int curr_moves = moves;\n\n            while (new_s1.x != new_s2.x) {\n                if (new_s1.x < new_s2.x) new_s1.x++;\n                else new_s1.x--;\n                curr_moves++;\n            }\n\n            while (new_s1.y != new_s2.y) {\n                if (new_s1.y < new_s2.y) new_s1.y++;\n                else new_s1.y--;\n                curr_moves++;\n            }\n\n            Point temp_slimes[MAX_W * MAX_H];\n            int temp_count = 0;\n\n            for (int k = 0; k < slime_count; k++) {\n                if (k != i && k != j) {\n                    temp_slimes[temp_count++] = slimes[k];\n                }\n            }\n\n            temp_slimes[temp_count++] = new_s1;\n\n            int old_count = slime_count;\n            memcpy(slimes, temp_slimes, sizeof(Point) * temp_count);\n            slime_count = temp_count;\n\n            solve(curr_moves);\n\n            slime_count = old_count;\n            memcpy(slimes, temp_slimes, sizeof(Point) * old_count);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &W, &H);\n\n    for (int y = 0; y < H; y++) {\n        for (int x = 0; x < W; x++) {\n            scanf(\"%d\", &grid[x][y]);\n            if (grid[x][y] == 1) {\n                slimes[slime_count].x = x;\n                slimes[slime_count].y = y;\n                slime_count++;\n            }\n        }\n    }\n\n    solve(0);\n\n    printf(\"%d\\n\", min_moves == INT_MAX ? -1 : min_moves);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nstruct Slime {\n    int x, y;\n    Slime(int _x, _y) : x(_x), y(_y) {}\n};\n\nint minMovesToUnite(vector<vector<char>>& grid) {\n    int W = grid[0].size(), H = grid.size();\n    vector<Slime> slimes;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                slimes.push_back(Slime(i, j));\n            }\n        }\n    }\n    \n    if (slimes.size() <= 1) return 0;\n    \n    int minMoves = INT_MAX;\n    \n    for (int targetX = 0; targetX < H; targetX++) {\n        for (int targetY = 0; targetY < W; targetY++) {\n            int totalMoves = 0;\n            bool possible = true;\n            \n            for (Slime& slime : slimes) {\n                int moves = bfs(grid, slime.x, slime.y, targetX, targetY);\n                if (moves == -1) {\n                    possible = false;\n                    break;\n                }\n                totalMoves += moves;\n            }\n            \n            if (possible) {\n                minMoves = min(minMoves, totalMoves);\n            }\n        }\n    }\n    \n    return minMoves == INT_MAX ? -1 : minMoves;\n}\n\nint bfs(vector<vector<char>>& grid, int startX, int startY, int targetX, int targetY) {\n    int H = grid.size(), W = grid[0].size();\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startX][startY] = true;\n    \n    int moves = 0;\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; i++) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            \n            if (x == targetX && y == targetY) return moves;\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x, ny = y;\n                while (true) {\n                    nx += dx[k];\n                    ny += dy[k];\n                    \n                    if (nx < 0 || nx >= H || ny < 0 || ny >= W) {\n                        nx -= dx[k];\n                        ny -= dy[k];\n                        break;\n                    }\n                    \n                    if (grid[nx][ny] == '#') {\n                        nx -= dx[k];\n                        ny -= dy[k];\n                        break;\n                    }\n                    \n                    if (grid[nx][ny] == 'S' || (nx == targetX && ny == targetY)) break;\n                }\n                \n                if (!visited[nx][ny]) {\n                    q.push({nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        moves++;\n    }\n    \n    return -1;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<char>> grid(H, vector<char>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    int result = minMovesToUnite(grid);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_moves_to_unite_slimes(W, H, slimes):\n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        distances = {}\n        distances[start] = 0\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:\n                nx, ny = x+dx, y+dy\n                if 0 <= nx < W and 0 <= ny < H and (nx, ny) not in visited and (nx, ny) not in slimes:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    distances[(nx, ny)] = distances[(x, y)] + 1\n        \n        return distances\n    \n    def calculate_costs(start):\n        costs = {}\n        for slime in slimes:\n            if slime != start:\n                if slime in distances_from_start:\n                    costs[slime] = distances_from_start[slime]\n        return costs\n    \n    total_min_moves = float('inf')\n    \n    for starting_slime in slimes:\n        slimes_left = set(slimes)\n        slimes_left.remove(starting_slime)\n        total_moves = 0\n        \n        while slimes_left:\n            distances_from_start = bfs(starting_slime)\n            costs_to_unite = calculate_costs(starting_slime)\n            \n            if not costs_to_unite:\n                total_moves = float('inf')\n                break\n            \n            closest_slime = min(costs_to_unite, key=costs_to_unite.get)\n            total_moves += costs_to_unite[closest_slime]\n            starting_slime = closest_slime\n            slimes_left.remove(starting_slime)\n        \n        total_min_moves = min(total_min_moves, total_moves)\n    \n    return total_min_moves\n\n# Example usage\nW, H = 5, 5\nslimes = {(1,1), (2,2), (3,3)}\nprint(min_moves_to_unite_slimes(W, H, slimes))",
    "timestamp": "2025-08-13 06:38:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y, dist;\n\n    Point(int x, int y, int dist) {\n        this.x = x;\n        this.y = y;\n        this.dist = dist;\n    }\n}\n\npublic class KingSlime {\n    public static int minMovesToUniteSlimes(int W, int H, List<Point> slimes) {\n        if (slimes == null || slimes.size() < 2) return 0;\n\n        boolean[][] grid = new boolean[W][H];\n        for (Point slime : slimes) {\n            grid[slime.x][slime.y] = true;\n        }\n\n        Queue<Point> queue = new LinkedList<>();\n        queue.addAll(slimes);\n        int totalMoves = 0;\n\n        while (queue.size() > 1) {\n            Point slime = queue.poll();\n            grid[slime.x][slime.y] = false;\n            boolean united = false;\n            int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            \n            for (int[] direction : directions) {\n                int nx = slime.x + direction[0];\n                int ny = slime.y + direction[1];\n                while (nx >= 0 && ny >= 0 && nx < W && ny < H && !grid[nx][ny]) {\n                    nx += direction[0];\n                    ny += direction[1];\n                }\n                \n                if (nx >= 0 && ny >= 0 && nx < W && ny < H && grid[nx][ny]) {\n                    grid[nx][ny] = false;\n                    queue.add(new Point(nx, ny, slime.dist + Math.abs(nx - slime.x) + Math.abs(ny - slime.y)));\n                    totalMoves += Math.abs(nx - slime.x) + Math.abs(ny - slime.y);\n                    united = true;\n                    break;\n                }\n            }\n            \n            if (!united) {\n                grid[slime.x][slime.y] = true;\n                queue.add(slime);\n            }\n        }\n        \n        return totalMoves;\n    }\n\n    public static void main(String[] args) {\n        int W = 5, H = 5;\n        List<Point> slimes = Arrays.asList(new Point(1, 1, 0), new Point(3, 3, 0), new Point(1, 3, 0));\n        System.out.println(minMovesToUniteSlimes(W, H, slimes)); // Output the result\n    }\n}",
    "timestamp": "2025-08-13 06:39:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_W 100\n#define MAX_H 100\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint W, H;\nchar grid[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nint slime_count = 0;\nPosition slimes[MAX_W * MAX_H];\nint dist[MAX_H][MAX_W];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool in_bounds(int x, int y) {\n    return x >= 0 && y >= 0 && x < W && y < H;\n}\n\nint bfs(Position start, Position end) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            visited[i][j] = false;\n            dist[i][j] = INT_MAX;\n        }\n    }\n\n    Position queue[MAX_H * MAX_W];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n    visited[start.y][start.x] = true;\n    dist[start.y][start.x] = 0;\n\n    while (front < rear) {\n        Position pos = queue[front++];\n        if (pos.x == end.x && pos.y == end.y) {\n            return dist[pos.y][pos.x];\n        }\n\n        for (int dir = 0; dir < 4; dir++) {\n            int nx = pos.x + dx[dir];\n            int ny = pos.y + dy[dir];\n            while (in_bounds(nx, ny) && grid[ny][nx] == '.') {\n                nx += dx[dir];\n                ny += dy[dir];\n            }\n            nx -= dx[dir];\n            ny -= dy[dir];\n\n            if (!visited[ny][nx]) {\n                visited[ny][nx] = true;\n                queue[rear++] = (Position){nx, ny};\n                dist[ny][nx] = dist[pos.y][pos.x] + 1;\n            }\n        }\n    }\n    return INT_MAX;\n}\n\nint solve() {\n    int total_moves = 0;\n    for (int i = 0; i < slime_count - 1; i++) {\n        int min_moves = INT_MAX;\n        int min_index = -1;\n        for (int j = i + 1; j < slime_count; j++) {\n            int moves = bfs(slimes[i], slimes[j]);\n            if (moves < min_moves) {\n                min_moves = moves;\n                min_index = j;\n            }\n        }\n        if (min_index != -1) {\n            total_moves += min_moves;\n            slimes[min_index] = slimes[i + 1];\n        }\n    }\n    return total_moves;\n}\n\nint main() {\n    scanf(\"%d %d\", &W, &H);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                slimes[slime_count++] = (Position){j, i};\n            }\n        }\n    }\n    int result = solve();\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:39:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom itertools import combinations\n\ndef solve_slime_unite(W: int, H: int, slimes: List[Tuple[int, int]]) -> int:\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def can_move(start, end, grid_slimes):\n        x1, y1 = start\n        x2, y2 = end\n        \n        # Check horizontal movement\n        if y1 == y2:\n            step = 1 if x2 > x1 else -1\n            for x in range(x1 + step, x2 + step, step):\n                if (x, y1) in grid_slimes:\n                    return False\n        \n        # Check vertical movement\n        if x1 == x2:\n            step = 1 if y2 > y1 else -1\n            for y in range(y1 + step, y2 + step, step):\n                if (x1, y) in grid_slimes:\n                    return False\n        \n        return True\n\n    def calculate_min_moves(grid_slimes):\n        if len(grid_slimes) <= 1:\n            return 0\n        \n        moves = 0\n        while len(grid_slimes) > 1:\n            min_dist = float('inf')\n            best_move = None\n            \n            for (x1, y1), (x2, y2) in combinations(grid_slimes, 2):\n                if can_move((x1, y1), (x2, y2), grid_slimes):\n                    dist = manhattan_distance((x1, y1), (x2, y2))\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_move = ((x1, y1), (x2, y2))\n            \n            if best_move is None:\n                return -1\n            \n            (x1, y1), (x2, y2) = best_move\n            moves += manhattan_distance((x1, y1), (x2, y2))\n            grid_slimes.remove((x1, y1))\n            grid_slimes.remove((x2, y2))\n            grid_slimes.add((x2, y2))\n        \n        return moves\n\n    return calculate_min_moves(set(slimes))",
    "timestamp": "2025-08-13 06:39:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    W, H = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(H)]\n    \n    slimes = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                slimes.append((i, j))\n    \n    if not slimes:\n        print(0)\n        return\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    total_moves = 0\n    while len(slimes) > 1:\n        min_dist = float('inf')\n        merge_pair = None\n        \n        for i in range(len(slimes)):\n            q = deque()\n            q.append((slimes[i][0], slimes[i][1], 0))\n            visited = [[-1 for _ in range(W)] for _ in range(H)]\n            visited[slimes[i][0]][slimes[i][1]] = 0\n            \n            while q:\n                x, y, dist = q.popleft()\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < H and 0 <= ny < W and visited[nx][ny] == -1:\n                        if grid[nx][ny] == 'S' and (nx, ny) != (slimes[i][0], slimes[i][1]):\n                            if dist + 1 < min_dist:\n                                min_dist = dist + 1\n                                merge_pair = (i, (nx, ny))\n                            break\n                        # Move until hit wall or another slime\n                        step = 1\n                        while True:\n                            next_x = x + dx * step\n                            next_y = y + dy * step\n                            if 0 <= next_x < H and 0 <= next_y < W:\n                                if grid[next_x][next_y] == 'S' and (next_x, next_y) != (x, y):\n                                    if dist + 1 < min_dist:\n                                        min_dist = dist + 1\n                                        merge_pair = (i, (next_x, next_y))\n                                    break\n                                step += 1\n                            else:\n                                break\n                        # Mark visited\n                        step = 1\n                        while True:\n                            next_x = x + dx * step\n                            next_y = y + dy * step\n                            if 0 <= next_x < H and 0 <= next_y < W:\n                                if visited[next_x][next_y] == -1 or dist + 1 < visited[next_x][next_y]:\n                                    visited[next_x][next_y] = dist + 1\n                                    if grid[next_x][next_y] != 'S':\n                                        q.append((next_x, next_y, dist + 1))\n                                    else:\n                                        break\n                                else:\n                                    break\n                                step += 1\n                            else:\n                                break\n        \n        if merge_pair is None:\n            break\n        \n        i, (x, y) = merge_pair\n        # Find the index of the other slime\n        for j in range(len(slimes)):\n            if slimes[j] == (x, y):\n                break\n        \n        # Merge slimes[i] and slimes[j], keep slimes[i]\n        total_moves += min_dist\n        slimes.pop(j)\n    \n    print(total_moves)\n\nsolve()",
    "timestamp": "2025-08-13 06:40:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nstruct Cell {\n    int x, y, dist;\n    Cell(int x, int y, int dist) : x(x), y(y), dist(dist) {}\n};\n\nbool isValid(int x, int y, int W, int H, vector<vector<bool>>& visited) {\n    return x >= 0 && x < W && y >= 0 && y < H && !visited[x][y];\n}\n\nint bfs(const vector<string>& grid, int startX, int startY, vector<pair<int, int>>& slimeCells) {\n    int W = grid.size(), H = grid[0].size();\n    vector<vector<bool>> visited(W, vector<bool>(H, false));\n    queue<Cell> q;\n    q.push(Cell(startX, startY, 0));\n    visited[startX][startY] = true;\n    \n    int moveCount = 0;\n    \n    while (!q.empty()) {\n        Cell current = q.front();\n        q.pop();\n        \n        for(auto& slime : slimeCells) {\n            if(slime.first == current.x && slime.second == current.y) {\n                moveCount += current.dist;\n                break;\n            }\n        }\n        \n        for (int i = 0; i < 4; ++i) {\n            int newX = current.x + directions[i][0];\n            int newY = current.y + directions[i][1];\n            \n            if (isValid(newX, newY, W, H, visited) && grid[newX][newY] == '0') {\n                visited[newX][newY] = true;\n                q.push(Cell(newX, newY, current.dist + 1));\n            }\n        }\n    }\n    \n    return moveCount;\n}\n\nint minimumMoves(vector<string> grid, vector<pair<int, int>>& slimeCells) {\n    int W = grid.size(), H = grid[0].size();\n    int minMoves = INT_MAX;\n    \n    for(auto& target : slimeCells) {\n        int currMoves = bfs(grid, target.first, target.second, slimeCells);\n        minMoves = min(minMoves, currMoves);\n    }\n    return minMoves;\n}\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<string> grid(W);\n    vector<pair<int, int>> slimeCells;\n    \n    for (int i = 0; i < W; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == '1') {\n                slimeCells.emplace_back(i, j);\n            }\n        }\n    }\n    \n    int result = minimumMoves(grid, slimeCells);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:33:20"
  }
]