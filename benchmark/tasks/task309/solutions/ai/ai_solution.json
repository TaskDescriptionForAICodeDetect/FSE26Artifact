[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid find_tanku(char *words[], int word_count) {\n    int sections[] = {5, 7, 5, 7, 7};\n    int section_count = 5;\n    int current_section = 0;\n    int current_length = 0;\n    int start_index = -1;\n    int end_index = -1;\n\n    for (int i = 0; i < word_count; i++) {\n        int word_len = strlen(words[i]);\n        if (current_section < section_count) {\n            if (current_length + word_len <= sections[current_section]) {\n                if (start_index == -1) {\n                    start_index = i;\n                }\n                current_length += word_len;\n                if (current_length == sections[current_section]) {\n                    current_section++;\n                    current_length = 0;\n                    end_index = i;\n                }\n            } else {\n                current_section = 0;\n                current_length = 0;\n                start_index = -1;\n                end_index = -1;\n                i--; // Retry current word\n            }\n        }\n    }\n\n    if (current_section == section_count) {\n        for (int i = start_index; i <= end_index; i++) {\n            printf(\"%s\", words[i]);\n            if (i < end_index) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"No tanku found.\\n\");\n    }\n}\n\nint main() {\n    char input[1000];\n    fgets(input, sizeof(input), stdin);\n    char *words[1000];\n    int word_count = 0;\n\n    char *token = strtok(input, \" \\n\");\n    while (token != NULL) {\n        words[word_count++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n\n    find_tanku(words, word_count);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> findTanku(const vector<string>& words) {\n    vector<int> sections = {5, 7, 5, 7, 7};\n    vector<string> result;\n    int currentSection = 0;\n    int currentCount = 0;\n    \n    for (const string& word : words) {\n        if (currentSection >= sections.size()) {\n            break;\n        }\n        int wordLen = word.size();\n        if (currentCount + wordLen <= sections[currentSection]) {\n            result.push_back(word);\n            currentCount += wordLen;\n            if (currentCount == sections[currentSection]) {\n                currentSection++;\n                currentCount = 0;\n            }\n        } else {\n            break;\n        }\n    }\n    \n    if (currentSection != sections.size()) {\n        result.clear();\n    }\n    \n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> words(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> words[i];\n    }\n    \n    vector<string> tanku = findTanku(words);\n    if (tanku.empty()) {\n        cout << \"No Tanku found\" << endl;\n    } else {\n        for (const string& word : tanku) {\n            cout << word << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShortPhraseFinder {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] words = input.split(\" \");\n        \n        List<String> result = findShortPhrase(words);\n        if (result != null) {\n            System.out.println(String.join(\" \", result));\n        } else {\n            System.out.println(\"No valid Short Phrase found.\");\n        }\n    }\n\n    private static List<String> findShortPhrase(String[] words) {\n        int n = words.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                List<String> sublist = Arrays.asList(words).subList(i, j);\n                if (isValidShortPhrase(sublist)) {\n                    return sublist;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static boolean isValidShortPhrase(List<String> phrase) {\n        int[] sections = {5, 7, 5, 7, 7};\n        int sectionIndex = 0;\n        int currentCount = 0;\n        \n        for (String word : phrase) {\n            if (!word.matches(\"[a-z]+\")) {\n                return false;\n            }\n            currentCount += word.length();\n            \n            if (sectionIndex >= sections.length) {\n                return false;\n            }\n            \n            if (currentCount == sections[sectionIndex]) {\n                sectionIndex++;\n                currentCount = 0;\n            } else if (currentCount > sections[sectionIndex]) {\n                return false;\n            }\n        }\n        \n        return sectionIndex == sections.length && currentCount == 0;\n    }\n}",
    "timestamp": "2025-08-05 21:01:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShortPhraseValidator {\n    public static String findShortPhrase(String[] words) {\n        for (int i = 0; i <= words.length - 5; i++) {\n            for (int j = i; j < words.length; j++) {\n                List<String> candidate = Arrays.asList(words).subList(i, j + 1);\n                if (isValidShortPhrase(candidate)) {\n                    return String.join(\" \", candidate);\n                }\n            }\n        }\n        return \"\";\n    }\n\n    private static boolean isValidShortPhrase(List<String> words) {\n        int[] letterCounts = new int[5];\n        int currentSection = 0;\n        int totalLetters = 0;\n\n        for (String word : words) {\n            int wordLetters = countLetters(word);\n            \n            if (currentSection > 4) return false;\n            \n            letterCounts[currentSection] += wordLetters;\n            totalLetters += wordLetters;\n\n            while (letterCounts[currentSection] >= getSectionTarget(currentSection)) {\n                if (letterCounts[currentSection] > getSectionTarget(currentSection)) return false;\n                currentSection++;\n                if (currentSection > 4) break;\n            }\n        }\n\n        return currentSection == 5 && \n               letterCounts[0] == 5 && \n               letterCounts[1] == 7 && \n               letterCounts[2] == 5 && \n               letterCounts[3] == 7 && \n               letterCounts[4] == 7;\n    }\n\n    private static int countLetters(String word) {\n        return (int) word.chars()\n                .filter(ch -> ch >= 'a' && ch <= 'z')\n                .count();\n    }\n\n    private static int getSectionTarget(int section) {\n        int[] targets = {5, 7, 5, 7, 7};\n        return targets[section];\n    }\n\n    public static void main(String[] args) {\n        String[] input = {\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\"};\n        System.out.println(findShortPhrase(input));\n    }\n}",
    "timestamp": "2025-08-05 21:01:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint count_letters(char* word) {\n    int count = 0;\n    for (int i = 0; word[i]; i++) {\n        if (islower(word[i])) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint is_valid_tanku(char** words, int num_words) {\n    int section_lengths[] = {5, 7, 5, 7, 7};\n    int current_section = 0;\n    int current_section_letters = 0;\n\n    for (int i = 0; i < num_words; i++) {\n        int word_letters = count_letters(words[i]);\n        current_section_letters += word_letters;\n\n        if (current_section_letters > section_lengths[current_section]) {\n            return 0;\n        }\n\n        if (current_section_letters == section_lengths[current_section]) {\n            current_section++;\n            current_section_letters = 0;\n\n            if (current_section == 5) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char** words = malloc(n * sizeof(char*));\n    for (int i = 0; i < n; i++) {\n        words[i] = malloc(101 * sizeof(char));\n        scanf(\"%s\", words[i]);\n    }\n\n    if (is_valid_tanku(words, n)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    for (int i = 0; i < n; i++) {\n        free(words[i]);\n    }\n    free(words);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isTanku(const vector<string>& words) {\n    int totalLetters = 0;\n    for (const string& word : words) {\n        totalLetters += word.length();\n    }\n    \n    for (int first = 1; first <= words.size(); first++) {\n        int letterCount = 0;\n        for (int i = 0; i < first; i++) {\n            letterCount += words[i].length();\n        }\n        \n        if (letterCount != 5) continue;\n        \n        for (int second = first + 1; second <= words.size(); second++) {\n            letterCount = 0;\n            for (int i = first; i < second; i++) {\n                letterCount += words[i].length();\n            }\n            \n            if (letterCount != 7) continue;\n            \n            for (int third = second + 1; third <= words.size(); third++) {\n                letterCount = 0;\n                for (int i = second; i < third; i++) {\n                    letterCount += words[i].length();\n                }\n                \n                if (letterCount != 5) continue;\n                \n                for (int fourth = third + 1; fourth <= words.size(); fourth++) {\n                    letterCount = 0;\n                    for (int i = third; i < fourth; i++) {\n                        letterCount += words[i].length();\n                    }\n                    \n                    if (letterCount != 7) continue;\n                    \n                    letterCount = 0;\n                    for (int i = fourth; i < words.size(); i++) {\n                        letterCount += words[i].length();\n                    }\n                    \n                    if (letterCount == 7) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> words(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> words[i];\n    }\n    \n    cout << (isTanku(words) ? \"YES\" : \"NO\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_short_phrase(words):\n    def is_valid_tanku(words):\n        lengths = [5, 7, 5, 7, 7]\n        current = 0\n        for length in lengths:\n            count = 0\n            while current < len(words) and count < length:\n                count += len(words[current])\n                if count > length:\n                    return False\n                current += 1\n            if count != length:\n                return False\n        return current == len(words)\n\n    word_lengths = [len(word) for word in words]\n    total_length = sum(word_lengths)\n    \n    # We're looking for a total length of 5 + 7 + 5 + 7 + 7 = 31\n    for start in range(len(words)):\n        for end in range(start, len(words)):\n            if sum(word_lengths[start:end+1]) == 31:\n                if is_valid_tanku(words[start:end+1]):\n                    return words[start:end+1]\n\n    return None\n\n# Example usage\nwords = [\"some\", \"irrelevant\", \"prefix\", \"then\", \"five\", \"sevenlet\", \"five\", \"sevenmore\", \"finalseven\", \"suffix\"]\nprint(find_short_phrase(words))",
    "timestamp": "2025-08-13 04:37:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class TankuFinder {\n\n    public static List<String> findShortPhrase(String[] words) {\n        int[] tankuPattern = {5, 7, 5, 7, 7};\n        int patternIndex = 0;\n        int currentLength = 0;\n        \n        List<String> shortPhrase = new ArrayList<>();\n        \n        for (String word : words) {\n            int wordLength = word.length();\n\n            while (wordLength > 0 && patternIndex < tankuPattern.length) {\n                int sectionLength = tankuPattern[patternIndex];\n                \n                if (currentLength + wordLength <= sectionLength) {\n                    shortPhrase.add(word);\n                    currentLength += wordLength;\n                    wordLength = 0;\n                } else {\n                    int remaining = sectionLength - currentLength;\n                    \n                    if (remaining > 0) {\n                        shortPhrase.add(word.substring(0, remaining));\n                        wordLength -= remaining;\n                        word = word.substring(remaining);\n                    }\n\n                    currentLength = 0;\n                    patternIndex++;\n                }\n            }\n\n            if (patternIndex == tankuPattern.length) {\n                break;\n            }\n        }\n\n        if (patternIndex != tankuPattern.length) {\n            return new ArrayList<>();\n        }\n\n        return shortPhrase;\n    }\n\n    public static void main(String[] args) {\n        String[] words = {\"hello\", \"world\", \"tank\", \"poet\", \"writing\", \"lines\", \"do\"};\n        List<String> result = findShortPhrase(words);\n        System.out.println(String.join(\" \", result));\n    }\n}",
    "timestamp": "2025-08-13 04:37:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define SECTION_COUNTS 5\nint section_lengths[] = {5, 7, 5, 7, 7};\n\nint main() {\n    char input[1000];\n    fgets(input, sizeof(input), stdin);\n\n    char *word;\n    int section = 0, current_length = 0;\n    \n    word = strtok(input, \" \");\n    while (word != NULL) {\n        int word_length = strlen(word);\n        current_length += word_length;\n        \n        if (current_length < section_lengths[section]) {\n            printf(\"%s \", word);\n        } else if (current_length == section_lengths[section]) {\n            printf(\"%s\", word);\n            section++;\n            current_length = 0;\n\n            if (section == SECTION_COUNTS) {\n                break;\n            } else {\n                printf(\" \");\n            }\n        } else {\n            printf(\"\\nInvalid input\\n\");\n            return 1;\n        }\n        \n        word = strtok(NULL, \" \");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 04:37:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_short_phrase(words):\n    def is_valid_section(section, expected_length):\n        return sum(len(word) for word in section) == expected_length\n\n    n = len(words)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    for m in range(l+1, n+1):\n                        section1 = words[i:j]\n                        section2 = words[j:k]\n                        section3 = words[k:l]\n                        section4 = words[l:m]\n                        section5 = words[m:]\n                        \n                        if (is_valid_section(section1, 5) and \n                            is_valid_section(section2, 7) and \n                            is_valid_section(section3, 5) and \n                            is_valid_section(section4, 7) and \n                            is_valid_section(section5, 7)):\n                            return ' '.join(words[i:m])\n    \n    return \"No Short Phrase found\"",
    "timestamp": "2025-08-13 04:37:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_short_phrase(words):\n    sections = [5, 7, 5, 7, 7]\n    total_letters = sum(sections)\n    n = len(words)\n    \n    for i in range(n):\n        current_letters = 0\n        current_words = []\n        for j in range(i, n):\n            word = words[j]\n            current_words.append(word)\n            current_letters += len(word)\n            if current_letters == total_letters:\n                break\n            elif current_letters > total_letters:\n                current_words = []\n                break\n        \n        if not current_words:\n            continue\n        \n        if len(current_words) < len(sections):\n            continue\n        \n        section_indices = []\n        start = 0\n        valid = True\n        for section in sections:\n            end = start + section\n            section_letters = 0\n            section_words = []\n            temp_start = start\n            while temp_start < len(current_words) and section_letters < section:\n                word = current_words[temp_start]\n                section_letters += len(word)\n                section_words.append(word)\n                temp_start += 1\n            \n            if section_letters != section:\n                valid = False\n                break\n            section_indices.append(section_words)\n            start = temp_start\n        \n        if valid and start == len(current_words):\n            return ' '.join(current_words)\n    \n    return \"\"",
    "timestamp": "2025-08-13 04:37:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool isShortPhrase(const vector<string>& words, int start) {\n    int counts[5] = {5, 7, 5, 7, 7};\n    int sectionIndex = 0;\n    int letterCount = 0;\n    \n    for (int i = start; i < words.size(); ++i) {\n        for (char c : words[i])\n            letterCount++;\n        \n        while (sectionIndex < 5 && letterCount > counts[sectionIndex]) {\n            sectionIndex++;\n            letterCount -= counts[sectionIndex - 1];\n        }\n\n        if (sectionIndex >= 5)\n            return false;\n\n        if (letterCount == counts[sectionIndex])\n            sectionIndex++;\n        \n        if (sectionIndex == 5 && letterCount == 0)\n            return true;\n    }\n    return false;\n}\n\nvector<string> findShortPhrase(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i) {\n        if (isShortPhrase(words, i)) {\n            vector<string> shortPhrase;\n            int counts[5] = {5, 7, 5, 7, 7};\n            int sectionIndex = 0;\n            int letterCount = 0;\n\n            for (int j = i; j < words.size() && sectionIndex < 5; ++j) {\n                for (char c : words[j])\n                    letterCount++;\n\n                shortPhrase.push_back(words[j]);\n\n                while (sectionIndex < 5 && letterCount > counts[sectionIndex]) {\n                    sectionIndex++;\n                    letterCount -= counts[sectionIndex - 1];\n                }\n\n                if (letterCount == counts[sectionIndex])\n                    sectionIndex++;\n                \n                if (sectionIndex == 5 && letterCount == 0)\n                    return shortPhrase;\n            }\n        }\n    }\n    return {};\n}\n\nint main() {\n    vector<string> words;\n    string word;\n\n    while (cin >> word) {\n        words.push_back(word);\n    }\n\n    vector<string> shortPhrase = findShortPhrase(words);\n\n    for (string& w : shortPhrase) {\n        cout << w << \" \";\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:36"
  }
]