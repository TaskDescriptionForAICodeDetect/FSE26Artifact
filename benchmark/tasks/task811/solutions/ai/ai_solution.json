[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 100005\n#define MAX_Q 20\n\nint arr[MAX_N];\nint n, q;\n\nlong long count_inversions(int* arr, int n) {\n    long long inv = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv++;\n            }\n        }\n    }\n    return inv;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &q);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    long long total_inv = 0;\n    \n    for (int mask = 0; mask < (1 << q); mask++) {\n        int temp[MAX_N];\n        memcpy(temp, arr, sizeof(arr));\n        \n        for (int i = 0; i < q; i++) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            x--; y--;\n            \n            if (mask & (1 << i)) {\n                int tmp = temp[x];\n                temp[x] = temp[y];\n                temp[y] = tmp;\n            }\n        }\n        \n        total_inv = (total_inv + count_inversions(temp, n)) % MOD;\n    }\n    \n    printf(\"%lld\\n\", total_inv);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MOD 1000000007\n#define MAXN 3005\n\nint N, Q;\nint A[MAXN];\nint X[MAXN], Y[MAXN];\nlong long dp[MAXN][MAXN];\nlong long inv2;\n\nlong long mod_pow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid solve() {\n    inv2 = mod_pow(2, MOD - 2);\n    long long total_inversions = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (A[i] > A[j]) {\n                total_inversions++;\n            }\n        }\n    }\n    total_inversions %= MOD;\n\n    long long pow2 = 1;\n    for (int q = 1; q <= Q; q++) {\n        int x = X[q], y = Y[q];\n        if (x > y) {\n            int tmp = x;\n            x = y;\n            y = tmp;\n        }\n        long long delta = 0;\n        for (int k = 1; k <= N; k++) {\n            if (k == x || k == y) continue;\n            if (k < x) {\n                if (A[k] > A[x]) delta++;\n                if (A[k] > A[y]) delta--;\n                if (A[k] < A[x]) delta--;\n                if (A[k] < A[y]) delta++;\n            } else if (k > y) {\n                if (A[x] > A[k]) delta++;\n                if (A[y] > A[k]) delta--;\n                if (A[x] < A[k]) delta--;\n                if (A[y] < A[k]) delta++;\n            } else if (k > x && k < y) {\n                if (A[x] > A[k]) delta++;\n                if (A[k] > A[y]) delta++;\n                if (A[y] > A[k]) delta--;\n                if (A[k] > A[x]) delta--;\n            }\n        }\n        delta %= MOD;\n        if (delta < 0) delta += MOD;\n        delta = (delta * inv2) % MOD;\n        total_inversions = (total_inversions * 2 + delta * pow2) % MOD;\n        pow2 = (pow2 * 2) % MOD;\n        int tmp = A[x];\n        A[x] = A[y];\n        A[y] = tmp;\n    }\n    printf(\"%lld\\n\", total_inversions);\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 1; i <= Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n    }\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n\nll modpow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> A(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> A[i];\n    }\n\n    vector<pair<int, int>> ops(Q);\n    for (auto& op : ops) {\n        cin >> op.first >> op.second;\n    }\n\n    ll total_inv = 0;\n    ll total_ways = modpow(2, Q);\n    ll inv2 = modpow(2, MOD - 2);\n\n    // Precompute for each pair (i, j) the probability that A[i] > A[j] after all operations\n    vector<vector<ll>> prob(N + 1, vector<ll>(N + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            if (A[i] > A[j]) {\n                prob[i][j] = 1;\n            }\n        }\n    }\n\n    for (const auto& op : ops) {\n        int x = op.first, y = op.second;\n        for (int i = 1; i <= N; ++i) {\n            if (i == x || i == y) continue;\n            ll p_ix = prob[i][x];\n            ll p_iy = prob[i][y];\n            prob[i][x] = prob[i][y] = (p_ix + p_iy) * inv2 % MOD;\n            ll p_xi = prob[x][i];\n            ll p_yi = prob[y][i];\n            prob[x][i] = prob[y][i] = (p_xi + p_yi) * inv2 % MOD;\n        }\n        ll p_xy = prob[x][y];\n        ll p_yx = prob[y][x];\n        prob[x][y] = prob[y][x] = (p_xy + p_yx) * inv2 % MOD;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j = i + 1; j <= N; ++j) {\n            total_inv = (total_inv + prob[i][j]) % MOD;\n        }\n    }\n\n    ll ans = total_inv * total_ways % MOD;\n    cout << ans << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:00:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int N, Q;\n    static int[] A;\n    static int[] X, Y;\n    static int[][] inv;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        Q = Integer.parseInt(st.nextToken());\n\n        A = new int[N + 1];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            A[i] = Integer.parseInt(st.nextToken());\n        }\n\n        X = new int[Q];\n        Y = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            st = new StringTokenizer(br.readLine());\n            X[i] = Integer.parseInt(st.nextToken());\n            Y[i] = Integer.parseInt(st.nextToken());\n        }\n\n        inv = new int[N + 1][N + 1];\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (i < j && A[i] > A[j]) {\n                    inv[i][j] = 1;\n                } else if (i > j && A[i] < A[j]) {\n                    inv[i][j] = 1;\n                }\n            }\n        }\n\n        long total = 0;\n        long half = 500000004; // 1/2 mod MOD\n        long pow2 = 1;\n\n        for (int q = 0; q < Q; q++) {\n            int x = X[q];\n            int y = Y[q];\n            if (x > y) {\n                int temp = x;\n                x = y;\n                y = temp;\n            }\n\n            long cnt = 0;\n            for (int k = 1; k <= N; k++) {\n                if (k != x && k != y) {\n                    int a = inv[x][k];\n                    int b = inv[y][k];\n                    cnt += a + b;\n                    if (k < x) {\n                        cnt += inv[k][x] + inv[k][y];\n                    } else if (k > y) {\n                        cnt += inv[x][k] + inv[y][k];\n                    } else {\n                        cnt += inv[x][k] + inv[k][y];\n                    }\n                }\n            }\n            cnt %= MOD;\n            cnt = cnt * half % MOD;\n            cnt += inv[x][y];\n            cnt %= MOD;\n            total = (total + cnt * pow2) % MOD;\n\n            for (int k = 1; k <= N; k++) {\n                if (k != x && k != y) {\n                    int avg = (int)((inv[x][k] + inv[y][k]) * half % MOD);\n                    inv[x][k] = avg;\n                    inv[y][k] = avg;\n                    if (k < x) {\n                        avg = (int)((inv[k][x] + inv[k][y]) * half % MOD);\n                        inv[k][x] = avg;\n                        inv[k][y] = avg;\n                    } else if (k > y) {\n                        avg = (int)((inv[x][k] + inv[y][k]) * half % MOD);\n                        inv[x][k] = avg;\n                        inv[y][k] = avg;\n                    } else {\n                        avg = (int)((inv[x][k] + inv[k][y]) * half % MOD);\n                        inv[x][k] = avg;\n                        inv[k][y] = avg;\n                    }\n                }\n            }\n            int avg = (int)((inv[x][y] + 1 - inv[x][y]) * half % MOD);\n            inv[x][y] = avg;\n\n            pow2 = pow2 * 2 % MOD;\n        }\n\n        long initialInv = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = i + 1; j <= N; j++) {\n                if (A[i] > A[j]) {\n                    initialInv++;\n                }\n            }\n        }\n        initialInv %= MOD;\n        long result = (initialInv * pow2 % MOD + total) % MOD;\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:01:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1000000007;\n\n    public static int countInversions(int[] arr) {\n        return mergeSort(arr, 0, arr.length - 1);\n    }\n\n    private static int mergeSort(int[] arr, int left, int right) {\n        int inversions = 0;\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            inversions += mergeSort(arr, left, mid);\n            inversions += mergeSort(arr, mid + 1, right);\n            inversions += merge(arr, left, mid, right);\n        }\n        return inversions;\n    }\n\n    private static int merge(int[] arr, int left, int mid, int right) {\n        int[] temp = new int[right - left + 1];\n        int i = left, j = mid + 1, k = 0;\n        int inversions = 0;\n\n        while (i <= mid && j <= right) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n                inversions += mid - i + 1;\n            }\n        }\n\n        while (i <= mid) {\n            temp[k++] = arr[i++];\n        }\n\n        while (j <= right) {\n            temp[k++] = arr[j++];\n        }\n\n        System.arraycopy(temp, 0, arr, left, temp.length);\n        return inversions;\n    }\n\n    public static int solve(int[] arr, int[][] operations) {\n        int n = arr.length;\n        int q = operations.length;\n        long totalInversions = 0;\n\n        for (int mask = 0; mask < (1 << q); mask++) {\n            int[] tempArr = Arrays.copyOf(arr, n);\n            \n            for (int i = 0; i < q; i++) {\n                if ((mask & (1 << i)) > 0) {\n                    int x = operations[i][0] - 1;\n                    int y = operations[i][1] - 1;\n                    int temp = tempArr[x];\n                    tempArr[x] = tempArr[y];\n                    tempArr[y] = temp;\n                }\n            }\n            \n            totalInversions += countInversions(tempArr);\n        }\n\n        return (int)(totalInversions % MOD);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = scanner.nextInt();\n        }\n\n        int q = scanner.nextInt();\n        int[][] operations = new int[q][2];\n        for (int i = 0; i < q; i++) {\n            operations[i][0] = scanner.nextInt();\n            operations[i][1] = scanner.nextInt();\n        }\n\n        System.out.println(solve(arr, operations));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:01:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 5e4 + 5;\n\nint N, Q;\nint A[MAXN];\n\nlong long countInversions(vector<int>& arr) {\n    long long inversions = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (arr[i] > arr[j]) {\n                inversions++;\n            }\n        }\n    }\n    return inversions;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> Q;\n    for (int i = 1; i <= N; i++) {\n        cin >> A[i];\n    }\n\n    vector<pair<int, int>> operations(Q);\n    for (int i = 0; i < Q; i++) {\n        cin >> operations[i].first >> operations[i].second;\n    }\n\n    long long totalInversions = 0;\n\n    for (int mask = 0; mask < (1 << Q); mask++) {\n        vector<int> current(A + 1, A + N + 1);\n        \n        for (int j = 0; j < Q; j++) {\n            if (mask & (1 << j)) {\n                swap(current[operations[j].first - 1], current[operations[j].second - 1]);\n            }\n        }\n        \n        totalInversions = (totalInversions + countInversions(current)) % MOD;\n    }\n\n    cout << totalInversions << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_inversions(sequence):\n    def merge_count_split_inv(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n        \n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n            \n        return inv_count\n    \n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    # Create a temp array\n    temp_array = [0] * len(sequence)\n    return merge_sort_and_count(sequence, temp_array, 0, len(sequence) - 1)\n    \ndef sum_inversion_numbers(n, a, q, operations):\n    factorials = [1] * (q + 1)\n    for i in range(2, q + 1):\n        factorials[i] = factorials[i - 1] * i % MOD\n\n    inv_factorials = [1] * (q + 1)\n    inv_factorials[q] = pow(factorials[q], MOD - 2, MOD)\n\n    for i in range(q - 1, 0, -1):\n        inv_factorials[i] = inv_factorials[i + 1] * (i + 1) % MOD\n\n    result = 0\n    initial_inversions = count_inversions(a)\n    \n    result = (result + initial_inversions * pow(2, q, MOD)) % MOD\n\n    for x, y in operations:\n        if a[x - 1] > a[y - 1]:\n            delta = a[x - 1] - a[y - 1]\n            result = (result + delta * pow(2, q - 1, MOD)) % MOD\n        if a[x - 1] < a[y - 1]:\n            delta = a[y - 1] - a[x - 1]\n            result = (result + delta * pow(2, q - 1, MOD)) % MOD\n        \n    return result\n\n# Example usage:\n# n = 4\n# a = [3, 1, 2, 4]\n# q = 2\n# operations = [(1, 3), (2, 4)]\n# print(sum_inversion_numbers(n, a, q, operations))",
    "timestamp": "2025-08-13 13:15:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class InversionSum {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        \n        int[][] operations = new int[Q][2];\n        for (int i = 0; i < Q; i++) {\n            operations[i][0] = scanner.nextInt() - 1;\n            operations[i][1] = scanner.nextInt() - 1;\n        }\n        \n        // Result is obtained by traversal and treating inversions\n        System.out.println((calculateInversion(A) * powerTwoModulo(Q, MOD)) % MOD);\n    }\n    \n    private static int calculateInversion(int[] array) {\n        return mergeSortAndCount(array, 0, array.length - 1);\n    }\n\n    private static int mergeSortAndCount(int[] arr, int l, int r) {\n        int count = 0;\n        if (l < r) {\n            int m = (l + r) / 2;\n\n            count += mergeSortAndCount(arr, l, m);\n            count += mergeSortAndCount(arr, m + 1, r);\n\n            count += merge(arr, l, m, r);\n        }\n        return count;\n    }\n\n    private static int merge(int[] arr, int l, int m, int r) {\n        int[] left = Arrays.copyOfRange(arr, l, m + 1);\n        int[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\n\n        int i = 0, j = 0, k = l, inversions = 0;\n        while (i < left.length && j < right.length) {\n            if (left[i] <= right[j]) {\n                arr[k++] = left[i++];\n            } else {\n                arr[k++] = right[j++];\n                inversions += (m + 1) - (l + i);\n            }\n        }\n\n        while (i < left.length) {\n            arr[k++] = left[i++];\n        }\n\n        while (j < right.length) {\n            arr[k++] = right[j++];\n        }\n\n        return inversions;\n    }\n\n    private static long powerTwoModulo(int exp, int mod) {\n        long result = 1;\n        long base = 2;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % mod;\n            }\n            base = (base * base) % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 13:15:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\n// Function to calculate inversion count using modified merge sort\nll merge_and_count(int arr[], int temp[], int left, int mid, int right) {\n    int i = left;\n    int j = mid;\n    int k = left;\n    ll inv_count = 0;\n\n    while ((i <= mid - 1) && (j <= right)) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            temp[k++] = arr[j++];\n            inv_count += (mid - i);\n        }\n    }\n\n    while (i <= mid - 1)\n        temp[k++] = arr[i++];\n\n    while (j <= right)\n        temp[k++] = arr[j++];\n\n    for (i = left; i <= right; i++)\n        arr[i] = temp[i];\n\n    return inv_count;\n}\n\nll merge_sort_and_count(int arr[], int temp[], int left, int right) {\n    int mid;\n    ll inv_count = 0;\n    if (right > left) {\n        mid = (right + left) / 2;\n\n        inv_count += merge_sort_and_count(arr, temp, left, mid);\n        inv_count += merge_sort_and_count(arr, temp, mid + 1, right);\n\n        inv_count += merge_and_count(arr, temp, left, mid + 1, right);\n    }\n    return inv_count;\n}\n\nll inversion_count(int arr[], int n) {\n    int *temp = (int *)malloc(sizeof(int) * n);\n    ll result = merge_sort_and_count(arr, temp, 0, n - 1);\n    free(temp);\n    return result;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n    int *a = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    scanf(\"%d\", &q);\n    int *x = (int*)malloc(q * sizeof(int));\n    int *y = (int*)malloc(q * sizeof(int));\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n        x[i]--; y[i]--;\n    }\n\n    ll total_inv_sum = 0;\n    ll power_two_q = 1LL << q;\n\n    for (ll mask = 0; mask < power_two_q; mask++) {\n        int *b = (int*)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            b[i] = a[i];\n        }\n\n        for (int i = 0; i < q; i++) {\n            if (mask & (1LL << i)) {\n                int temp = b[x[i]];\n                b[x[i]] = b[y[i]];\n                b[y[i]] = temp;\n            }\n        }\n\n        total_inv_sum = (total_inv_sum + inversion_count(b, n)) % MOD;\n        free(b);\n    }\n\n    printf(\"%lld\\n\", total_inv_sum);\n\n    free(a);\n    free(x);\n    free(y);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:16:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function inversionSumAfterOperations(N, A, Q, operations) {\n    const MOD = 1000000007;\n\n    const countInversions = (arr) => {\n        let inversions = 0;\n        const mergeSortAndCount = (tempArray, left, right) => {\n            if (left >= right) return 0;\n            const mid = Math.floor((left + right) / 2);\n            let count = 0;\n            count += mergeSortAndCount(tempArray, left, mid);\n            count += mergeSortAndCount(tempArray, mid + 1, right);\n            count += mergeAndCount(tempArray, left, mid, right);\n            return count;\n        };\n\n        const mergeAndCount = (tempArray, left, mid, right) => {\n            let i = left, j = mid + 1, k = left, swaps = 0;\n\n            while (i <= mid && j <= right) {\n                if (arr[i] <= arr[j]) {\n                    tempArray[k++] = arr[i++];\n                } else {\n                    tempArray[k++] = arr[j++];\n                    swaps += (mid + 1 - i);\n                }\n            }\n\n            while (i <= mid) tempArray[k++] = arr[i++];\n            while (j <= right) tempArray[k++] = arr[j++];\n\n            for (i = left; i <= right; i++) {\n                arr[i] = tempArray[i];\n            }\n\n            return swaps;\n        };\n\n        return mergeSortAndCount(new Array(arr.length), 0, arr.length - 1);\n    };\n\n    let inversionsOdd = 0, inversionsEven = 0;\n    for (let [X, Y] of operations) {\n        if (A[X-1] > A[Y-1]) inversionsOdd++;\n    }\n\n    inversionsEven = countInversions(A.slice());\n    \n    let result = (inversionsEven * BigInt(1 << Q)) % BigInt(MOD);\n    result = (result + BigInt(inversionsOdd * (1 << (Q - 1)))) % BigInt(MOD);\n\n    return result;\n}\n\n// Example usage\nconst N = 5;\nconst A = [1, 3, 2, 5, 4];\nconst Q = 2;\nconst operations = [[1, 3], [4, 5]];\nconsole.log(inversionSumAfterOperations(N, A, Q, operations)); // Output should be calculated based on the given problem",
    "timestamp": "2025-08-13 13:16:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def merge_sort_count_inversions(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_inv = merge_sort_count_inversions(arr[:mid])\n    right, right_inv = merge_sort_count_inversions(arr[mid:])\n    \n    merged, merge_inv = merge_and_count(left, right)\n    return merged, left_inv + right_inv + merge_inv\n\ndef merge_and_count(left, right):\n    merged = []\n    inversions = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            inversions += len(left) - i\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inversions\n\ndef solve(N, Q, A, operations):\n    MOD = 10**9 + 7\n    total_inversions = 0\n    \n    for mask in range(1 << Q):\n        current_A = A.copy()\n        \n        for i in range(Q):\n            if mask & (1 << i):\n                current_A[operations[i][0] - 1], current_A[operations[i][1] - 1] = current_A[operations[i][1] - 1], current_A[operations[i][0] - 1]\n        \n        _, inv_count = merge_sort_count_inversions(current_A)\n        total_inversions = (total_inversions + inv_count) % MOD\n    \n    return total_inversions\n\n# Example usage\nN, Q = map(int, input().split())\nA = list(map(int, input().split()))\noperations = []\nfor _ in range(Q):\n    X, Y = map(int, input().split())\n    operations.append((X, Y))\n\nresult = solve(N, Q, A, operations)\nprint(result)",
    "timestamp": "2025-08-13 13:16:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A, Q, operations) {\n    const MOD = 1e9 + 7;\n    \n    function countInversions(arr) {\n        let inversions = 0;\n        for (let i = 0; i < arr.length; i++) {\n            for (let j = i + 1; j < arr.length; j++) {\n                if (arr[i] > arr[j]) {\n                    inversions++;\n                }\n            }\n        }\n        return inversions;\n    }\n    \n    let totalInversions = 0;\n    \n    for (let mask = 0; mask < (1 << Q); mask++) {\n        let currentArr = [...A];\n        \n        for (let i = 0; i < Q; i++) {\n            if (mask & (1 << i)) {\n                const [x, y] = operations[i];\n                [currentArr[x-1], currentArr[y-1]] = [currentArr[y-1], currentArr[x-1]];\n            }\n        }\n        \n        totalInversions = (totalInversions + countInversions(currentArr)) % MOD;\n    }\n    \n    return totalInversions;\n}",
    "timestamp": "2025-08-13 13:16:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    A = list(map(int, input[ptr:ptr+N]))\n    ptr += N\n    Q = int(input[ptr])\n    ptr += 1\n    queries = []\n    for _ in range(Q):\n        x, y = map(int, input[ptr:ptr+2])\n        ptr += 2\n        queries.append((x-1, y-1))  # 0-based\n    \n    # Precompute the initial inversion count\n    inv = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if A[i] > A[j]:\n                inv += 1\n    inv %= MOD\n    \n    # For each query, track the probability that A[x] and A[y] are swapped\n    # Initially, each swap has a 1/2 probability\n    # We need to maintain for each pair (i,j) the probability that A[i] > A[j]\n    # The answer is sum_{i<j} P(A[i] > A[j])\n    \n    # Initialize the probability matrix\n    prob = [[0]*N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if A[i] > A[j]:\n                prob[i][j] = 1\n    \n    inv2 = (MOD + 1) // 2  # 1/2 mod MOD\n    \n    res = 0\n    current_inv = inv\n    pow2 = 1  # 2^0\n    \n    for step, (x, y) in enumerate(queries):\n        if x == y:\n            res = (res * 2) % MOD\n            continue\n        \n        # The contribution from pairs involving x or y\n        # For i != x, i != y, the pairs (i,x) and (i,y) and (x,i) and (y,i)\n        # Also the pair (x,y)\n        \n        # Compute the delta\n        delta = 0\n        for k in range(N):\n            if k == x or k == y:\n                continue\n            # (k, x) and (k, y)\n            # Before swap, prob[k][x] and prob[k][y]\n            # After swap, they become (prob[k][x] + prob[k][y]) * inv2\n            orig_kx = prob[k][x]\n            orig_ky = prob[k][y]\n            delta = (delta + (orig_kx + orig_ky) * inv2 - orig_kx - orig_ky) % MOD\n            \n            # (x, k) and (y, k)\n            orig_xk = prob[x][k]\n            orig_yk = prob[y][k]\n            delta = (delta + (orig_xk + orig_yk) * inv2 - orig_xk - orig_yk) % MOD\n        \n        # (x, y)\n        orig_xy = prob[x][y]\n        orig_yx = prob[y][x]\n        delta = (delta + (orig_xy + orig_yx) * inv2 - orig_xy - orig_yx) % MOD\n        \n        current_inv = (current_inv + delta) % MOD\n        \n        # Update the prob matrix\n        for k in range(N):\n            if k == x or k == y:\n                continue\n            # Update (k, x) and (k, y)\n            new_val = (prob[k][x] + prob[k][y]) * inv2 % MOD\n            prob[k][x] = new_val\n            prob[k][y] = new_val\n            \n            # Update (x, k) and (y, k)\n            new_val = (prob[x][k] + prob[y][k]) * inv2 % MOD\n            prob[x][k] = new_val\n            prob[y][k] = new_val\n        \n        # Update (x, y) and (y, x)\n        new_val = (prob[x][y] + prob[y][x]) * inv2 % MOD\n        prob[x][y] = new_val\n        prob[y][x] = new_val\n        \n        # The total contribution is current_inv * 2^{step+1}\n        res = (res * 2 + current_inv) % MOD\n        pow2 = pow2 * 2 % MOD\n    \n    print(res % MOD)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 13:16:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const A = input[1].split(' ').map(Number);\n    const Q = parseInt(input[2], 10);\n    const queries = [];\n    for (let i = 0; i < Q; i++) {\n        const [X, Y] = input[3 + i].split(' ').map(Number);\n        queries.push({ X: X - 1, Y: Y - 1 }); // converting to 0-based\n    }\n\n    let inv = 0;\n    // Calculate initial inversion count\n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            if (A[i] > A[j]) inv++;\n        }\n    }\n    inv %= MOD;\n\n    let total = 0;\n    let pow2 = 1; // 2^0\n    const inv2 = (MOD + 1) / 2; // since MOD is prime, 2^(-1) mod MOD is (MOD+1)/2\n\n    for (const { X, Y } of queries) {\n        if (X == Y) {\n            total = (total * 2) % MOD;\n            pow2 = (pow2 * 2) % MOD;\n            continue;\n        }\n\n        // Count elements between X and Y that affect the inversion count\n        let cnt = 0;\n        for (let k = 0; k < N; k++) {\n            if (k == X || k == Y) continue;\n            if ((A[k] > A[X] && A[k] > A[Y]) || (A[k] < A[X] && A[k] < A[Y])) continue;\n            cnt++;\n        }\n\n        const delta = (cnt * inv2) % MOD;\n        total = (total * 2 + delta) % MOD;\n        inv = (inv * 2) % MOD;\n        pow2 = (pow2 * 2) % MOD;\n\n        // Swap with 50% probability (represented by inv2)\n        const temp = A[X];\n        A[X] = A[Y];\n        A[Y] = temp;\n    }\n\n    const result = (inv * pow2) % MOD;\n    console.log(result);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:17:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Function to count inversions using modified merge sort\nlong long mergeAndCount(vector<int>& arr, int l, int m, int r) {\n    vector<int> left(arr.begin() + l, arr.begin() + m + 1);\n    vector<int> right(arr.begin() + m + 1, arr.begin() + r + 1);\n\n    int i = 0, j = 0, k = l;\n    long long swaps = 0;\n\n    while (i < left.size() && j < right.size()) {\n        if (left[i] <= right[j]) {\n            arr[k++] = left[i++];\n        } else {\n            arr[k++] = right[j++];\n            swaps += (left.size() - i);\n        }\n    }\n\n    while (i < left.size()) {\n        arr[k++] = left[i++];\n    }\n\n    while (j < right.size()) {\n        arr[k++] = right[j++];\n    }\n\n    return swaps;\n}\n\nlong long mergeSortAndCount(vector<int>& arr, int l, int r) {\n    long long count = 0;\n    if (l < r) {\n        int m = (l + r) / 2;\n\n        count += mergeSortAndCount(arr, l, m);\n        count += mergeSortAndCount(arr, m + 1, r);\n\n        count += mergeAndCount(arr, l, m, r);\n    }\n    return count;\n}\n\n// Recursive calculation of powers of 2\nlong long modPow(long long x, long long y, int mod) {\n    long long res = 1;\n    x = x % mod;\n\n    while (y > 0) {\n        if (y & 1) {\n            res = (res * x) % mod;\n        }\n        y = y >> 1;\n        x = (x * x) % mod;\n    }\n    return res;\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n\n    vector<pair<int, int>> operations(Q);\n    for (int i = 0; i < Q; ++i) {\n        cin >> operations[i].first >> operations[i].second;\n        --operations[i].first;\n        --operations[i].second;\n    }\n\n    long long inversionCount = mergeSortAndCount(A, 0, N - 1);\n\n    // Each operation can be applied or not, there are 2^Q ways\n    long long totalWays = modPow(2, Q, MOD);\n\n    // The sum of inversions over all permutations considering XOR logic\n    long long result = (inversionCount * totalWays) % MOD;\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:03"
  }
]