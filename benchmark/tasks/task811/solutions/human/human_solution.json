[
  {
    "language": "C++",
    "code": "/*\nProblem Source : agc-030D\nAuthor : oier_hzy\nTime : Nov 24 2019\n*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _tp> inline void read(_tp&x) {\n\tchar ch = getchar(), sgn = 0; x = 0;\n\twhile(ch != '-' and !isdigit(ch)) ch = getchar(); if(ch == '-') ch = getchar(), sgn = 1;\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar(); if(sgn) x = -x;\n}\n\nconst int N = 3001, p = 1e9+7, inv2 = p+1>>1;\nint f[N][N], g[N][N];\nint a[N];\nint n, Q;\n\nint main() {\n\tread(n), read(Q);\n\tfor(int i = 1; i <= n; ++ i) read(a[i]);\n\tfor(int i = 1; i <= n; ++ i)\n\tfor(int j = 1; j <= n; ++ j)\n\t\tf[i][j] = bool(a[i] < a[j]);\n\t\n\tint x, y, cas = 1;\n\twhile(Q--) {\n\t\tread(x), read(y);\n\t\tfor(int i = 1; i <= n; ++ i) {\n\t\t\tif(i != y) {\n\t\t\t\tg[i][x] = (ll)(f[i][x] + f[i][y]) * inv2%p;\n\t\t\t\tg[x][i] = (ll)(f[x][i] + f[y][i]) * inv2%p;\n\t\t\t}\n\t\t\tif(i != x) {\n\t\t\t\tg[i][y] = (ll)(f[i][x] + f[i][y]) * inv2%p;\n\t\t\t\tg[y][i] = (ll)(f[x][i] + f[y][i]) * inv2%p;\n\t\t\t}\n\t\t}\n\t\tg[x][y] = g[y][x] = (ll)(f[x][y] + f[y][x]) * inv2%p;\n\t\tfor(int i = 1; i <= n; ++ i) {\n\t\t\tf[i][x] = g[i][x], f[x][i] = g[x][i];\n\t\t\tf[i][y] = g[i][y], f[y][i] = g[y][i];\n\t\t}\n\t\tcas = (cas << 1)%p;\n\t}\n\tll sum = 0ll;\n\tfor(int i = 1; i <= n; ++ i)\n\tfor(int j = 1; j < i; ++ j)\n\t\tsum += f[i][j];\n\tsum %= p;\n\tprintf(\"%lld\\n\", sum * cas%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(int64_t k) const {\n        ModInt ret(1), mul(x);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<mod>;\n\nint N, Q;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> N >> Q;\n    V<int> A(N);\n    rep(i, N) cin >> A[i];\n    V<V<modint>> dp(N, V<modint>(N));\n    rep(i, N) rep(j, N) dp[i][j] = (A[i] > A[j]);\n    rep(_, Q) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) / 2;\n        rep(i, N) {\n            if(i != x && i != y) {\n                dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) / 2;\n                dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) / 2;\n            }\n        }\n    }\n    modint ans;\n    rep(i, N) FOR(j, i + 1, N) ans += dp[i][j];\n\n    cout << ans * modint(2).pow(Q) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\ntypedef pair<lint,pint> tint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nlint dp[3010][3010];\nint a[3010];\nlint mo=1000000007,ha=500000004;\nint main()\n{\n\tint n,q,x,y;\n\tcin>>n>>q;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n) cin>>a[i];\n\trep(i,n) rep(j,n){\n\t\tif(i!=j && a[i]>a[j]) dp[i][j]++;\n\t}\n\trep(i,q){\n\t\tcin>>x>>y;x--;y--;\n\t\tvector<tint> v;\n\t\tlint t=dp[x][y]+dp[y][x];\n\t\tt*=ha;t%=mo;\n\t\tv.pb(mp(t,mp(x,y)));v.pb(mp(t,mp(y,x)));\n\t\trep(j,n){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tlint t1=(dp[j][x]+dp[j][y])*ha%mo,t2=(dp[x][j]+dp[y][j])*ha%mo;\n\t\t\tv.pb(mp(t1,mp(j,x)));v.pb(mp(t1,mp(j,y)));\n\t\t\tv.pb(mp(t2,mp(x,j)));v.pb(mp(t2,mp(y,j)));\n\t\t}\n\t\trep(j,v.size()) dp[v[j].se.fi][v[j].se.se]=v[j].fi;\n\t}\n\tlint out=0;\n\trep(i,n) REP(j,i+1,n){\n\t\tout+=dp[i][j];out%=mo;\n\t}\n\trep(i,q){\n\t\tout*=2;out%=mo;\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright lzt\n#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef std::pair<int, int> pii;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef std::pair<long long, long long> pll;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define rep(i, j, k)  for (register int i = (int)(j); i <= (int)(k); i++)\n#define rrep(i, j, k) for (register int i = (int)(j); i >= (int)(k); i--)\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ninline ll read() {\n  ll x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch <= '9' && ch >= '0') {\n    x = 10 * x + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\n\nconst int mod = 1e9 + 7;\nconst int maxn = 3030;\nint n, m;\nint f[maxn][maxn];\nint a[maxn];\n\nvoid work() {\n  ll inv2 = (mod + 1) / 2;\n  n = read(), m = read();\n  rep(i, 1, n) a[i] = read();\n  rep(i, 1, n) rep(j, 1, n) if (a[i] < a[j]) f[i][j] = 1;\n  rep(i, 1, m) {\n    int x = read(), y = read();\n    rep(j, 1, n) {\n      if (j == x || j == y) continue;\n      f[x][j] = f[y][j] = (f[x][j] + f[y][j]) * inv2 % mod;\n      f[j][x] = f[j][y] = (f[j][x] + f[j][y]) * inv2 % mod;\n    }\n    f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv2 % mod;\n  }\n  int ans = 0;\n  rep(i, 1, n) rep(j, 1, i - 1) ans = (ans + f[i][j]) % mod;\n  rep(i, 1, m) ans = ans * 2 % mod;\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  #ifdef LZT\n    freopen(\"in\", \"r\", stdin);\n  #endif\n\n  work();\n\n  #ifdef LZT\n    Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n  #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 3010;\n\nint N, Q;\nint A[MN], X[MN], Y[MN], prec[MN][MN], po[MN];\nvector<int> V[MN];\n\nint cc[MN][MN][2][2];\nint dp(int q, int a, int x, int t) {\n    int &ret = cc[q][a][x][t];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    int b = x? X[q] : Y[q];\n    if(t) swap(a, b);\n\n    int pa = prec[a][q];\n    int pb = prec[b][q];\n    if(V[a][pa] == Q && V[b][pb] == Q) {\n        ret += 1LL * po[Q - q - 1] * (a < b) % mod;\n        ret %= mod;\n    }\n    else if(V[a][pa] < V[b][pb]) {\n        int nq = V[a][pa];\n        ret += 1LL * po[nq - q - 1] * dp(nq, b, X[nq] == a, 1) % mod;\n        ret %= mod;\n    }\n    else {\n        int nq = V[b][pb];\n        ret += 1LL * po[nq - q - 1] * dp(nq, a, X[nq] == b, 0) % mod;\n        ret %= mod;\n    }\n\n    a = a == X[q]? Y[q] : (a == Y[q]? X[q] : a);\n    b = b == X[q]? Y[q] : (b == Y[q]? X[q] : b);\n\n    pa = prec[a][q];\n    pb = prec[b][q];\n    if(V[a][pa] == Q && V[b][pb] == Q) {\n        ret += 1LL * po[Q - q - 1] * (a < b) % mod;\n        ret %= mod;\n    }\n    else if(V[a][pa] < V[b][pb]) {\n        int nq = V[a][pa];\n        ret += 1LL * po[nq - q - 1] * dp(nq, b, X[nq] == a, 1) % mod;\n        ret %= mod;\n    }\n    else {\n        int nq = V[b][pb];\n        ret += 1LL * po[nq - q - 1] * dp(nq, a, X[nq] == b, 0) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    //*\n    scanf(\"%d %d\", &N, &Q);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n\n        V[ X[i] ].push_back(i);\n        V[ Y[i] ].push_back(i);\n    }\n    //*/\n    for(int i = 0; i < N; i++) {\n        V[i].push_back(Q);\n    }\n\n    for(int i = 0; i < N; i++) {\n        int pos = 0;\n        for(int j = 0; j < Q; j++) {\n            if(pos < V[i].size() && V[i][pos] <= j) pos++;\n            prec[i][j] = pos;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n\n    int ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(A[j] < A[i]) {\n                if(V[i][0] == Q && V[j][0] == Q) {\n                    ans += 1LL * po[Q] * (i < j) % mod;\n                    ans %= mod;\n                    continue;\n                }\n                if(V[i][0] < V[j][0]) {\n                    int q = V[i][0];\n                    ans += 1LL * po[q] * dp(q, j, X[q] == i, 1) % mod;\n                    ans %= mod;\n                }\n                else {\n                    int q = V[j][0];\n                    ans += 1LL * po[q] * dp(q, i, X[q] == j, 0) % mod;\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>                                                                                                                                                                                      //YaLoh\n\n#define f first \n#define s second \n#define pb push_back               \n#define mp make_pair \n\nusing namespace std;                    \n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int N = 3010, inf = 1e9, mod = 1e9 + 7;\nconst ll INF = 1e18;\n\nint n, m, ans, a[N], s[N], t[N], dp[N][N], nxt[N][N], last[N][N], timer, pw2[N];\nbool was[N][N];\nvector< pii > v;\nvoid add(int i, int j, int val){\n\tnxt[i][j] += val;\n\tif(nxt[i][j] >= mod)\n\t\tnxt[i][j] -= mod;\n\tif(was[i][j])\n\t\treturn;\n\twas[i][j] = 1;\n\tv.pb({i, j});\n}\nvoid relax(int i, int j){\n\tdp[i][j] = 1ll * dp[i][j] * pw2[timer - last[i][j]] % mod;\n\tlast[i][j] = timer;\n}\nvoid relax(){\n\tfor(auto it : v){\n\t\tint i = it.f;\n\t\tint j = it.s;\n\t\trelax(i, j);\n\t\tdp[i][j] += nxt[i][j];\n\t\tif(dp[i][j] >= mod)\n\t\t\tdp[i][j] -= mod;\n\t\twas[i][j] = 0;\n\t\tnxt[i][j] = 0;\n\t}\n\tv.clear();\n}\nvoid upd(int x, int y){\n\ttimer++;\n\tfor(int i = 1; i <= n; i++){\n\t\tlast[i][x]++;\n\t\tlast[x][i]++;\n\t\tlast[i][y]++;\n\t\tlast[y][i]++;\n\t}\n\tlast[x][y] -= 1;\n\tlast[y][x] -= 1;\n}\nint main(){\n\tpw2[0] = 1;\n\tfor(int i = 1; i < N; i++)\n\t\tpw2[i] = pw2[i - 1] * 2 % mod;\t\n\tcin >> n >> m;  \n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\t\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(a[i] > a[j])\n            \tadd(i, j, 1);\n\trelax();\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\trelax(j, x);\n            relax(j, y);\n            relax(x, j);\n            relax(y, j);\n            if(j != y){\n\t\t\t\tadd(j, y, dp[j][x]);\n\t\t\t\tadd(y, j, dp[x][j]);\n\t\t\t}\n\t\t\tif(j != x){\n\t\t\t\tadd(x, j, dp[y][j]);\n\t\t\t\tadd(j, x, dp[j][y]);\n\t\t\t}\n\t\t}                       \n\t\tadd(x, y, dp[y][x]);\n\t\tadd(y, x, dp[x][y]);\n\t\trelax();\n\t\tupd(x, y);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\trelax(i, j);\n\t\t\tans += dp[i][j];\n\t\t\tif(ans >= mod)\n\t\t\t\tans -= mod;\n\t\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3e3 + 11;\nconst int mod = 1e9 + 7;\nint f[N][N], n, q, a[N];\ninline int A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\ninline int M(int x, int y){\n    return 1LL * x * y % mod;\n}\nint main(){\n    cin>>n>>q;\n    for(int i = 1;i <= n; i++)cin>>a[i];\n    for(int i = 1;i <= n; i++){\n        for(int j = 1;j <= n; j++)f[i][j] = a[i] < a[j];\n    }\n    int inv2 = (mod + 1) / 2, mi = 1;\n    for(int i = 1;i <= q; i++){\n        mi = (mi << 1) % mod;\n        int x, y;\n        cin>>x>>y;\n        f[x][y] = f[y][x] = M(inv2, A(f[x][y], f[y][x]));\n        for(int j = 1;j <= n; j++){\n            if(j == x || j == y)continue;\n            f[x][j] = f[y][j] = M(inv2, A(f[x][j], f[y][j]));\n            f[j][x] = f[j][y] = M(inv2, A(f[j][x], f[j][y]));\n        }\n    }\n    int ans = 0;\n    for(int i = 1;i <= n; i++){\n        for(int j = i - 1;j >= 1; j--)ans = A(ans, f[i][j]);\n    }\n    ans = M(ans, mi);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 1010 \n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007 ;\n\nconst int inv2 = 500000004 ;\n\nchar *p1, *p2, buf[100000];\n\n#define nc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1 ++ )\n\nint rd() {\n\tint x = 0, f = 1;\n\tchar c = nc();\n\twhile (c < 48) {\n\t\tif (c == '-')\n\t\t\tf = -1;\n\t\tc = nc();\n\t}\n\twhile (c > 47) {\n\t\tx = (((x << 2) + x) << 1) + (c ^ 48), c = nc();\n\t}\n\treturn x * f;\n}\n\nint a[N], f[N][N];\n\nint main() {\n\tint n = rd(), q = rd(), mdl = 1;\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\ta[i] = rd();\n\t}\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tfor (int j = 1; j <= n; j ++ ) {\n\t\t\tif (a[i] < a[j]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= q; i ++ ) {\n\t\tmdl = (ll)mdl * 2 % mod;\n\t\tint x = rd(), y = rd();\n\t\tf[x][y] = f[y][x] = ((ll)f[x][y] + f[y][x]) * inv2 % mod;\n\n\t\tfor (int j = 1; j <= n; j ++ ) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tf[x][j] = f[y][j] = ((ll)f[x][j] + f[y][j]) * inv2 % mod;\n\t\t\t\tf[j][x] = f[j][y] = ((ll)f[j][x] + f[j][y]) * inv2 % mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tfor (int j = 1; j < i; j ++ ) {\n\t\t\t(ans += f[i][j]) %= mod;\n\t\t}\n\t}\n\n\tans = (ll)ans * mdl % mod, (ans += mod) %= mod;\n\tcout << ans << endl ;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint x[3100];\nint y[3100];\nint las[3100][3100];\nint cur[3100];\nint p[3100];\nlong long ks[3100];\n\nmap<pair<int,pair<int,int> >,long long >dp;\nlong long calc(int a,int b,int c){\n\tif(a==0){\n\t\treturn p[b]>p[c];\n\t}\n\tif(dp.count(make_pair(a,make_pair(b,c)))){\n\t\treturn dp[make_pair(a,make_pair(b,c))];\n\t}\n\t//printf(\"%d %d %d\\n\",a,b,c);\n\tlong long ret=0;\n\tint to=max(las[a][b],las[a][c]);\n\tif(to==-1){\n\t\tret=calc(0,b,c);\n\t}else{\n\t\tret=calc(to,b,c);\n\t\tif(x[to]==b&&y[to]==c)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==c&&y[to]==b)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==b)ret=(ret+calc(to,y[to],c))%mod;\n\t\telse if(x[to]==c)ret=(ret+calc(to,b,y[to]))%mod;\n\t\telse if(y[to]==b)ret=(ret+calc(to,x[to],c))%mod;\n\t\telse if(y[to]==c)ret=(ret+calc(to,b,x[to]))%mod;\n\t}\n\tret=ret*ks[a-to-1]%mod;\n\treturn dp[make_pair(a,make_pair(b,c))]=ret;\n}\nint main(){\n\tks[0]=1;\n\tfor(int i=1;i<3100;i++)ks[i]=ks[i-1]*2%mod;\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);x[i]--;y[i]--;\n\t}\n\tfor(int i=0;i<a;i++)cur[i]=-1;\n\tfor(int i=0;i<b;i++){\n\t\tcur[x[i]]=cur[y[i]]=i;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tlas[i+1][j]=cur[j];\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tret+=calc(b,i,j);\n\t\t}\n\t}\n\tret%=mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007, inv2 = 500000004;\nint p[3010][3010];\nint a[3010], n, m;\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) p[i][j] = a[i] > a[j];\n    for (int i = 1; i <= m; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        if (x > y) swap(x, y);\n        for (int i = 1; i <= n; i++) {\n            if (i == x || i == y) continue;\n            p[x][i] = p[y][i] = 1ll * (p[x][i] + p[y][i]) * inv2 % mod;\n            p[i][x] = p[i][y] = 1ll * (p[i][x] + p[i][y]) * inv2 % mod;\n        }\n        p[x][x] = p[y][y] = 0;\n        p[x][y] = p[y][x] = 1ll * (p[x][y] + p[y][x]) * inv2 % mod;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ans = (ans + p[i][j]) % mod;\n    for (int i = 1; i <= m; i++) ans = ans * 2 % mod;\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\nconst int N = 3e3 + 7, mod = 1e9 + 7;\n\n#define inc(i, x, y) for (int i = x; i <= y; ++i)\n#define dec(i, x, y) for (int i = x; i >= y; --i)\n#define gc getchar\n\nbool chkmin(int &x, int y) { return x > y ? x = y, 1 : 0; }\nbool chkmax(int &x, int y) { return x < y ? x = y, 1 : 0; }\n\nint rd() {\n\tint ret = 0; bool fl = 0; char ch = 0;\n\twhile (!isdigit(ch)) fl |= (ch == '-'), ch = gc();\n\twhile (isdigit(ch)) ret = (ret << 1) + (ret << 3) + (ch ^ 48), ch = gc();\n\treturn fl ? -ret : ret;\n}\n\nint a[N], x[N], y[N];\nll ans, dp[N][N];\n\nll add(ll x, ll y) { return x + y > mod ? x - mod + y : x + y; }\n\nll qpow(ll x, int y) {\n\tll ret = 1ll;\n\tfor ( ;y; y >>= 1, x = 1ll * x * x % mod) if (y & 1) ret = 1ll * ret * x % mod;\n\treturn ret;\n}\n\nint main() {\n\tint n = rd(), q = rd();\n\tll sum = qpow(2, q), inv2 = qpow(2, mod - 2);\n\tinc(i, 1, n) a[i] = rd();\n\tinc(i, 1, q) x[i] = rd(), y[i] = rd();\n\tinc(i, 1, n) inc(j, 1, n) dp[i][j] = (a[i] < a[j] ? sum : 0);\n\tinc(i, 1, q) {\n\t\tdp[x[i]][y[i]] = dp[y[i]][x[i]] = 1ll * add(dp[x[i]][y[i]], dp[y[i]][x[i]]) * inv2 % mod;\n\t\tinc(j, 1, n) {\n\t\t\tif (j == x[i] || j == y[i]) continue;\n\t\t\tdp[j][y[i]] = dp[y[i]][j] = 1ll * add(dp[j][y[i]], dp[y[i]][j]) * inv2 % mod;\n\t\t\tdp[x[i]][j] = dp[j][x[i]] = 1ll * add(dp[x[i]][j], dp[j][x[i]]) * inv2 % mod;\n\t\t}\n\t}\n\tinc(i, 2, n) dec(j, i - 1, 1) ans = add(ans, dp[i][j]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 1000000007;\nconst ll half = 500000004;\n\nint main(){\n\n    ll N,Q;\n    cin >> N >> Q;\n    vector<ll> A(N,0);\n\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<vector<ll>> lis(N,vector<ll> (N,0));\n    rep(i,0,N){\n        rep(j,0,N){\n            if (A[i] > A[j]) lis[i][j] = 1;\n        }\n    }\n\n    cout << \"wa\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <vector>\n#include <fstream>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\n#define forifrom(i, s, n) for (ll i = s; i < n; ++i)\n#define forirto(i, n, e) for (ll i = (n) - 1; i >= e; --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n\nconst ll MOD = 1000000007;\nconst ll INF = 2000000000;\nconst long long BIG = 1446803456761533460LL;\n\n#define XL (x << 1)\n#define XR (XL | 1)\n#define MD ((l + r) >> 1)\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 3010;\n\nll N, Q, A[maxn], dp[maxn][maxn];\n\nll poww(ll a, ll b) {\n    ll r = 1;\n    while (b) {\n        if (b & 1) Mul(r, a);\n        Mul(a, a);\n        b >>= 1;\n    }\n    return r;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> N >> Q;\n    fori (i, N) cin >> A[i];\n\n    ll q2 = poww(2, Q);\n    ll inv2 = poww(2, MOD - 2);\n    fori (i, N) fori (j, N) {\n        if (A[i] > A[j]) dp[i][j] = q2;\n    }\n\n    fori (q, Q) {\n        ll x, y; cin >> x >> y; --x, --y;\n        fori (i, N) {\n            if (i == x || i == y) continue;\n            ll a = dp[x][i] = 1LL * dp[x][i] * inv2 % MOD;\n            ll b = dp[i][x] = 1LL * dp[i][x] * inv2 % MOD;\n            ll c = dp[y][i] = 1LL * dp[y][i] * inv2 % MOD;\n            ll d = dp[i][y] = 1LL * dp[i][y] * inv2 % MOD;\n            Add(dp[x][i], c), Add(dp[i][x], d);\n            Add(dp[y][i], a), Add(dp[i][y], b);\n        }\n        ll a = dp[x][y] = 1LL * dp[x][y] * inv2 % MOD;\n        ll b = dp[y][x] = 1LL * dp[y][x] * inv2 % MOD;\n        Add(dp[x][y], b), Add(dp[y][x], a);\n    }\n    ll s = 0;\n    fori (i, N) forifrom (j, i + 1, N) Add(s, dp[i][j]);\n    cout << s << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<functional>\n#include<cmath>\n#include<vector>\n#include<assert.h>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nvoid open2(const char *s){\n#ifdef DEBUG\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst int N=3010;\nconst ll p=1000000007;\nll fp(ll a,ll b)\n{\n\tll s=1;\n\tfor(;b;b>>=1,a=a*a%p)\n\t\tif(b&1)\n\t\t\ts=s*a%p;\n\treturn s;\n}\nconst ll inv2=fp(2,p-2);\nint a[N];\nint n,q;\nll f[N][N];\nint main()\n{\n\topen(\"d\");\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j])\n\t\t\t\tf[i][j]=1;\n\tint x,y;\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x&&j!=y)\n\t\t\t{\n\t\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])*inv2%p;\n\t\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])*inv2%p;\n\t\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])%p;\n\tans=ans*fp(2,q)%p;\n\tans=(ans%p+p)%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 3000;\nconst int MOD = int(1E9) + 7;\ninline int add(int x, int y) {return (x + y >= MOD ? x + y - MOD : x + y);}\ninline int sub(int x, int y) {return (x - y < 0 ? x - y + MOD : x - y);}\ninline int mul(int x, int y) {return 1LL*x*y%MOD;}\n\nint pw2[MAXN + 5];\nvoid init() {\n\tpw2[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tpw2[i] = mul(2, pw2[i-1]);\n}\n\nint f[2][MAXN + 5][MAXN + 5], lst[MAXN + 5][MAXN + 5];\nvoid update(int l, int r, int k) {\n\tf[0][l][r] = mul(f[0][l][r], pw2[lst[l][r] - k - 1]);\n\tf[1][l][r] = mul(f[1][l][r], pw2[lst[l][r] - k - 1]);\n\tlst[l][r] = k;\n}\nvoid transform(int &x, int &y) {\n\tint t = (x + y) % MOD;\n\tx = y = t;\n}\n\nint A[MAXN + 5], X[MAXN + 5], Y[MAXN + 5];\nint main() {\n\tinit();\n\tint N, Q; scanf(\"%d%d\", &N, &Q);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\", &A[i]);\n\tfor(int i=1;i<=Q;i++) scanf(\"%d%d\", &X[i], &Y[i]);\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i+1;j<=N;j++)\n\t\t\tf[0][i][j] = 1, lst[i][j] = Q + 1;\n\tfor(int i=Q;i>=1;i--) {\n\t\tif( X[i] > Y[i] ) swap(X[i], Y[i]);\n\t\tfor(int j=1;j<=X[i]-1;j++) {\n\t\t\tupdate(j, X[i], i), update(j, Y[i], i);\n\t\t\ttransform(f[0][j][X[i]], f[0][j][Y[i]]);\n\t\t\ttransform(f[1][j][X[i]], f[1][j][Y[i]]);\n\t\t}\n\t\tfor(int j=X[i]+1;j<=Y[i]-1;j++) {\n\t\t\tupdate(X[i], j, i), update(j, Y[i], i);\n\t\t\ttransform(f[0][X[i]][j], f[1][j][Y[i]]);\n\t\t\ttransform(f[1][X[i]][j], f[0][j][Y[i]]);\n\t\t}\n\t\tfor(int j=Y[i]+1;j<=N;j++) {\n\t\t\tupdate(X[i], j, i), update(Y[i], j, i);\n\t\t\ttransform(f[0][X[i]][j], f[0][Y[i]][j]);\n\t\t\ttransform(f[1][X[i]][j], f[1][Y[i]][j]);\n\t\t}\n\t\tupdate(X[i], Y[i], i);\n\t\ttransform(f[0][X[i]][Y[i]], f[1][X[i]][Y[i]]);\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i+1;j<=N;j++) {\n\t\t\tupdate(i, j, 0);\n\t\t\tif( A[i] < A[j] ) ans = add(ans, f[1][i][j]);\n\t\t\tif( A[i] > A[j] ) ans = add(ans, f[0][i][j]);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a != 0 ? gcd (b % a, a) : b; }\n\nconst int mod = 1000*1000*1000+7;\nconst int rev2 = (mod + 1) / 2;\n\nint n;\nint m;\nint v[3000];\nii w[3000];\nint g[3000][3000];\nint u[3000][3000];\nint was[3000][3000];\nint x[3000];\nint y[3000];\nint ct;\n\ninline int get (int i, int j) {\n\tif (was[i][j] == ct) re u[i][j];\n\tre g[i][j];\n}\n\ninline int apply (int a, int b, int c) {\n\tif (a == b) re c;\n\tif (a == c) re b;\n\tre a;\n}\n\ninline int div2 (int x) {\n\tif (!(x & 1)) re x >> 1;\n\tif (x < mod) re (x + mod) >> 1; else re (x - mod) >> 1;\n}\n\nint main () {\n\tscanf (\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf (\"%d\", &v[i]);\n\tint tot = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf (\"%d%d\", &x[i], &y[i]); x[i]--; y[i]--;\n\t\ttot = (tot * 2) % mod;\n\t}\n\tmemset (g, 0, sizeof (g));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tg[i][j] = int (i < j);\n\tct = 0;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tct++;\n\t\tint a = x[i];\n\t\tint b = y[i];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\twas[j][a] = was[j][b] = was[a][j] = was[b][j] = ct;\n\t\t\tu[j][a] = g[j][a];\n\t\t\tu[j][b] = g[j][b];\n\t\t\tu[a][j] = g[a][j];\n\t\t\tu[b][j] = g[b][j];\n\t\t}\n\t\tfor (int t = 0; t < n; t++) {\n\t\t\tif (a < t) {\n\t\t\t\tint j = a;\n\t\t\t\tint k = t;\n\t\t\t\tint nj = b;\n\t\t\t\tint nk = apply (k, a, b);\n\t\t\t\tg[j][k] = div2 (g[j][k] + get (nj, nk));\n\t\t\t\tg[k][j] = mod + 1 - g[j][k];\n\t\t\t\tif (g[k][j] >= mod) g[k][j] -= mod;\n\t\t\t}\n\t\t\tif (b < t) {\n\t\t\t\tint j = b;\n\t\t\t\tint k = t;\n\t\t\t\tint nj = a;\n\t\t\t\tint nk = apply (k, a, b);\n\t\t\t\tg[j][k] = div2 (g[j][k] + get (nj, nk));\n\t\t\t\tg[k][j] = mod + 1 - g[j][k];\n\t\t\t\tif (g[k][j] >= mod) g[k][j] -= mod;\n\t\t\t}\n\t\t\tif (t < a && t != a && t != b) {\n\t\t\t\tint j = t;\n\t\t\t\tint k = a;\n\t\t\t\tint nj = apply (j, a, b);\n\t\t\t\tint nk = b;\n\t\t\t\tg[j][k] = div2 (g[j][k] + get (nj, nk));\n\t\t\t\tg[k][j] = mod + 1 - g[j][k];\n\t\t\t\tif (g[k][j] >= mod) g[k][j] -= mod;\n\t\t\t}\n\t\t\tif (t < b && t != a && t != b) {\n\t\t\t\tint j = t;\n\t\t\t\tint k = b;\n\t\t\t\tint nj = apply (j, a, b);\n\t\t\t\tint nk = a;\n\t\t\t\tg[j][k] = div2 (g[j][k] + get (nj, nk));\n\t\t\t\tg[k][j] = mod + 1 - g[j][k];\n\t\t\t\tif (g[k][j] >= mod) g[k][j] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (v[i] > v[j])\n\t\t\t\tans = (ans + g[i][j]) % mod;\n\tans = ((ll)ans * tot) % mod;\n\tcout << ans << endl;\n\tcerr << clock () << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 3050;\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) >> 1;\nint A[N][N], a[N], n, q;\ninline ll add(int x, int y) { return x + y >= P ? x + y - P : x + y; }\nvoid out(void) {\n    for (int i = 1;i <= n; i++, puts(\"\"))\n        for (int j = 1;j <= n; j++)\n            write(A[i][j], ' ');\n    puts(\"\");\n}\nint main() {\n    read(n), read(q);\n    for (int i = 1;i <= n; i++) read(a[i]);\n    for (int i = 1;i <= n; i++)\n        for (int j = 1;j <= n; j++) \n            A[i][j] = a[i] > a[j];\n    /* puts(\"\"); */\n    ll mi = 1;\n    for (int i = 1, x, y;i <= q; i++) {\n        /* out(); */\n        mi = add(mi, mi);\n        read(x), read(y);\n        /* if (x > y) swap(x, y); */\n        for (int i = 1;i <= n; i++) {\n            if (i == x || i == y) continue;\n            int tx = A[x][i], ty = A[y][i];\n            int ttx = A[i][x], tty = A[i][y];\n            A[x][i] = A[y][i] = add(tx, ty) * inv2 % P;\n            A[i][y] = A[i][x] = add(ttx, tty) * inv2 % P;\n        }\n        A[x][y] = A[y][x] = (ll)inv2 * add(A[x][y], A[y][x]) % P;\n    }\n    /* out(); */\n    int ans = 0;\n    for (int i = 1;i <= n; i++) \n        for (int j = i + 1;j <= n; j++)\n            ans = add(ans, A[i][j]);\n    /* write(ans); */\n    write(1ll * ans * mi % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define LL long long\n#define N 3011\nint n,q,a[N],x,y;\nLL f[N][N],ans,inv2; \nLL q_pow(LL a,LL b){\n\tLL res=1;\n\twhile(b){\n\t\tif(b&1ll) res=res*a%MOD;\n\t\tb>>=1ll;\n\t\ta=a*a%MOD;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++){\n\t  \tif(i==j) continue;\n\t  \tf[i][j]=(a[i]>a[j]);\n\t  }\n\tinv2=q_pow(2,MOD-2);\n\tfor(int Q=1;Q<=q;Q++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tswap(a[x],a[y]); \n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i!=x&&i!=y){\n\t\t\t\tf[x][i]=f[y][i]=inv2*(f[x][i]+f[y][i])%MOD;\n\t\t\t\tf[i][x]=f[i][y]=inv2*(f[i][x]+f[i][y])%MOD;\n\t\t\t}\n\t\t}\n\t\tf[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%MOD;\n\t}\n\tans=0;\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<i;j++)\n\t    ans=(ans+f[j][i])%MOD;\n\tans=ans*q_pow(2,q)%MOD;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 3e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, M;\nint arr[MAXN];\nint dp[MAXN][MAXN], tmp[MAXN][MAXN];\n\ninline int add(int x, int y) {\n\tx += y;\n\tif (x >= MOD)\n\t\tx -= MOD;\n\treturn x;\n}\n\ninline int avg(int x, int y) {\n\treturn (long long)add(x, y) * (MOD + 1) / 2 % MOD;\n}\n\nvoid update(int a, int b) {\n\tfor (int i = 1; i <= N; i++) {\n\t\ttmp[a][i] = avg(dp[a][i], dp[b][i]);\n\t\ttmp[i][a] = avg(dp[i][a], dp[i][b]);\n\t\ttmp[b][i] = avg(dp[b][i], dp[a][i]);\n\t\ttmp[i][b] = avg(dp[i][b], dp[i][a]);\n\t}\n\ttmp[a][b] = tmp[b][a] = avg(dp[a][b], dp[b][a]);\n\t\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[a][i] = tmp[a][i];\n\t\tdp[i][a] = tmp[i][a];\n\t\tdp[b][i] = tmp[b][i];\n\t\tdp[i][b] = tmp[i][b];\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", arr + i);\n\t\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 1; j <= N; j++)\n\t\t\tdp[i][j] = arr[i] > arr[j];\n\t\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tupdate(a, b);\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tans = add(ans, dp[i][j]);\n\t\n\twhile (M--)\n\t\tans = add(ans, ans);\n\t\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007, Inv2 = (Mod + 1) / 2;\nconst int MN = 3005;\n\nint N, Q, A[MN], p1[MN], p2[MN];\nint dp[MN][MN], Coef, Sum;\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q), Coef = 1;\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= Q; ++i) {\n\t\tscanf(\"%d%d\", &p1[i], &p2[i]);\n\t\tif (p1[i] > p2[i]) std::swap(p1[i], p2[i]);\n\t}\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tdp[i][j] = A[i] > A[j];\n\tfor (int i = 1; i <= Q; ++i) {\n\t\tstatic int tmp[MN][MN];\n\t\tfor (int x = 1; x <= N; ++x)\n\t\t\tif (x != p1[i] && x != p2[i]) {\n\t\t\t\ttmp[x][p1[i]] = (LL)Inv2 * (dp[x][p1[i]] + dp[x][p2[i]]) % Mod;\n\t\t\t\ttmp[p1[i]][x] = (LL)Inv2 * (dp[p1[i]][x] + dp[p2[i]][x]) % Mod;\n\t\t\t\ttmp[x][p2[i]] = (LL)Inv2 * (dp[x][p2[i]] + dp[x][p1[i]]) % Mod;\n\t\t\t\ttmp[p2[i]][x] = (LL)Inv2 * (dp[p2[i]][x] + dp[p1[i]][x]) % Mod;\n\t\t\t}\n\t\tfor (int x = 1; x <= N; ++x)\n\t\t\tif (x != p1[i] && x != p2[i]) {\n\t\t\t\tdp[x][p1[i]] = tmp[x][p1[i]];\n\t\t\t\tdp[p1[i]][x] = tmp[p1[i]][x];\n\t\t\t\tdp[x][p2[i]] = tmp[x][p2[i]];\n\t\t\t\tdp[p2[i]][x] = tmp[p2[i]][x];\n\t\t\t}\n\t\tdp[p2[i]][p1[i]] = dp[p1[i]][p2[i]] = (LL)Inv2 * (dp[p1[i]][p2[i]] + dp[p2[i]][p1[i]]) % Mod;\n\t\tCoef = 2ll * Coef % Mod;\n\t}\n\tfor (int x = 1; x < N; ++x)\n\t\tfor (int y = x + 1; y <= N; ++y)\n\t\t\tSum = (Sum + dp[x][y]) % Mod;\n\tprintf(\"%lld\\n\", (LL)Coef * Sum % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for (ll i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nlong long inv_mod(long long n, long long mod) {\n    long long a = n % mod, b = mod - 2, ret = 1;\n    while (b > 0) {\n        if (b & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nconst ll MOD = 1000000007LL;\nll N,Q;\nll A[3010];\nll X[3010];\nll Y[3010];\n\nll dp[3010][3010];\n\nint main ()\n{\n    cin >> N >> Q;\n    REP(i,N) cin >> A[i];\n    REP(i,Q) cin >> X[i] >> Y[i];\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = (A[i] > A[j]);\n        }\n    }\n\n    ll inv2 = inv_mod(2LL, MOD);\n    for (int i = 0; i < Q; i++) {\n        dp[X[i]][Y[i]] = dp[Y[i]][X[i]] = ((dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv2 % MOD);\n        for (int j = 1; j <= N; j++) {\n            if (X[i] != j && Y[i] != j) {\n                dp[X[i]][j] = dp[Y[i]][j] = ((dp[X[i]][j] + dp[Y[i]][j]) * inv2 % MOD);\n                dp[j][X[i]] = dp[j][Y[i]] = ((dp[j][X[i]] + dp[j][Y[i]]) * inv2 % MOD);\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i; j <= N; j++) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << (ans * pow_mod(2LL, Q, MOD)) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll mod = 1e9+7;\nconst ll hlf = 5e8+4;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tvi as(n);\n\ttrav(x, as) cin >> x;\n\n\tvector<vector<ll>> mat(n, vector<ll>(n));\n\trep(i,0,n) rep(j,0,n) mat[i][j] = (as[i]>as[j]) - (as[j]>as[i]);\n\n\trep(_,0,q){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x, --y;\n\t\trep(k,0,n){\n\t\t\tll res = mat[x][k] + mat[y][k];\n\t\t\tres *= hlf;\n\t\t\tres %= mod;\n\t\t\tmat[x][k] = mat[y][k] = res;\n\t\t}\n\t\trep(k,0,n){\n\t\t\tll res = mat[k][x] + mat[k][y];\n\t\t\tres *= hlf;\n\t\t\tres %= mod;\n\t\t\tmat[k][y] = mat[k][x] = res;\n\t\t\t\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\trep(i,0,n) rep(j,0,i) ans += mat[j][i];\n\trep(i,0,n) rep(j,0,i) ans += (as[i]!=as[j]);\n\trep(i,0,q) ans = ans * 2 % mod;\n\tans = ans * hlf % mod;\n\tif(ans < 0) ans += mod;\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\n \ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            //cout<<x<<\"/\"<<y;\n            cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\nll T;\nvoid ave(ll &s,ll &t){\n    ll z=mod((s+t)*T);\n    s=z;\n    t=z;\n}\n\nint main(){fastio\n    T=bunbo(2);\n    ll n,q;cin>>n>>q;\n    ll a[n];rep(i,0,n-1)cin>>a[i];\n    ll dp[n][n];memset(dp,0,sizeof(dp));\n    rep(i,0,n-1)rep(j,0,n-1){\n        if(a[i]>a[j])dp[i][j]=1;\n    }\n    rep(zzzz,1,q){\n        ll x,y;cin>>x>>y;x--;y--;\n        rep(i,0,n-1){\n            if(i!=x&&i!=y){\n                ave(dp[i][x],dp[i][y]);\n                ave(dp[x][i],dp[y][i]);\n            }\n        }\n        ave(dp[x][y],dp[y][x]);\n    }\n    \n    ll ans=0;\n    rep(i,0,n-1)rep(j,i+1,n-1){\n        Add(ans,dp[i][j]);\n    }\n    cout<<mod(ans*po(2,q))<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 3030, mo = 1e9+7,inv2=(mo+1)/2;\nint n,q,a[N],f[N][N],res,dfn[N][N],mrk=1;\nvoid add(int &x,int y){x=x+y<mo?x+y:x+y-mo;}\nstruct qq{int a,b,c;}s[600000];int len;\ninline void tt(int a, int b, int x, int y){\n\tif(!f[a][b])return;\n\t++len;s[len].c=1LL*f[a][b]*inv2%mo;\n\ts[len].a=a==x?y:(a==y?x:a);\n\ts[len].b=b==x?y:(b==y?x:b);\n\tf[a][b]=1LL*f[a][b]*inv2%mo;\n}\nint main() {\n\tread(n);read(q);rep(i,1,n)read(a[i]);\n\trep(i,1,n)rep(j,1,n)if(a[i]>a[j])f[i][j]++;\n\trep(t,1,q){\n\t\t//rep(i,1,n)rep(j,1,n)if(f[i][j])printf(\"%d %d %d:%lld\\n\",t,i,j,1LL*f[i][j]*mrk%mo);\n\t\tint x,y;read(x);read(y);len=0;mrk=2LL*mrk%mo;\n\t\trep(j,1,n){\n\t\t\tif(dfn[x][j]!=t)dfn[x][j]=t,tt(x,j,x,y);\n\t\t\tif(dfn[y][j]!=t)dfn[y][j]=t,tt(y,j,x,y);\n\t\t}\n\t\trep(i,1,n){\n\t\t\tif(dfn[i][x]!=t)dfn[i][x]=t,tt(i,x,x,y);\n\t\t\tif(dfn[i][y]!=t)dfn[i][y]=t,tt(i,y,x,y);\n\t\t}\n\t\twhile(len)add(f[s[len].a][s[len].b],s[len].c),len--;\n\t}\n\trep(i,1,n)rep(j,i+1,n)add(res,f[i][j]);cout<<(1LL*res*mrk%mo+mo)%mo;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005 , mod = 1e9 + 7 ;\nlong long inv2 = 5e8 + 4 , mul = 1;\nint n , q , a[N] , p[N][N] , ans = 0;\n\nint main() {\n    scanf(\"%d %d\" , &n , &q);\n    for(int i = 1 ; i <= n ; ++i) scanf(\"%d\" , a + i);\n    for(int i = 1 ; i <= n ; ++i)\n        for(int j = 1 ; j <= n ; ++j) p[i][j] = (a[i] < a[j]);\n    while(q--) {\n        mul = (mul << 1) % mod;\n        int a , b;\n        scanf(\"%d %d\" , &a , &b);\n        for(int i = 1 ; i <= n ; ++i)\n            if(i != a && i != b) {\n                p[i][b] = p[i][a] = (p[i][a] * inv2 + p[i][b] * inv2) % mod;\n                p[b][i] = p[a][i] = (p[b][i] * inv2 + p[a][i] * inv2) % mod;\n            }\n        p[a][b] = p[b][a] = (p[a][b] * inv2 + p[b][a] * inv2) % mod;\n    }\n    for(int i = 1 ; i <= n ; ++i)\n        for(int j = i + 1 ; j <= n ; ++j) ans = (ans + mul * p[j][i]) % mod;\n    printf(\"%d\\n\" , ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007ll\n#define otz  500000004ll\nusing namespace std;\nll dp[3005][3005],f[3005][3005];\nint n,q,a[3005];\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j)if(a[i]>a[j])dp[i][j]=1;\n    }\n    for(int i=1;i<=q;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        f[x][y]=f[y][x]=dp[x][y]+dp[y][x];\n        for(int k=1;k<=n;++k){\n            if(k==x||k==y) continue;\n            f[x][k]=dp[x][k]+dp[y][k];\n            f[k][x]=dp[k][x]+dp[k][y];\n            f[y][k]=dp[y][k]+dp[x][k];\n            f[k][y]=dp[k][y]+dp[k][x];\n        }\n        for(int j=1;j<=n;++j){\n            dp[x][j]=f[x][j]*otz%orz;\n            dp[y][j]=f[y][j]*otz%orz;\n            dp[j][x]=f[j][x]*otz%orz;\n            dp[j][y]=f[j][y]*otz%orz;\n        }\n    }\n    ll ans=0;\n    for(int i=1;i<=n;++i){\n        for(int j=i+1;j<=n;++j)ans+=dp[i][j];\n    }\n    ans%=orz;\n    for(int i=1;i<=q;++i)ans=ans*2ll%orz;\n    printf(\"%lld\\n\",ans);\n\t//system(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\ntemplate<class Int> constexpr bool is_prime(Int n) {\n  if (n < 2 or n > 2 and ~n & 1) return false;\n  for (Int i = 3; i * i <= n; i += 2) if (n % i == 0) return false;\n  return true;\n}\ntemplate<uint P> struct ModInt {\n  static_assert(is_prime(P), \"template argument must be a prime number\");\n  using M = ModInt;\n  uint v;\n  ModInt() : v(0) {}\n  template<class Int> ModInt(Int x) : v(x >= 0 ? x % P : -x % P ? P - -x % P : 0) {}\n  ModInt(uint v, int _) : v(v) {} // 直接値を初期化\n  static constexpr uint p() { return P; }\n  M operator++(int) { M t = *this; if (++v == P) v = 0; return t; }\n  M operator--(int) { M t = *this; v = (v ? v : P) - 1; return t; }\n  M& operator++() { if (++v == P) v = 0; return *this; }\n  M& operator--() { v = (v ? v : P) - 1; return *this; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !static_cast<bool>(*this); }\n  M operator*(M rhs) const { return M(*this) *= rhs; }\n  M operator/(M rhs) const { return M(*this) /= rhs; }\n  M operator+(M rhs) const { return M(*this) += rhs; }\n  M operator-(M rhs) const { return M(*this) -= rhs; }\n  bool operator==(M rhs) { return v == rhs.v; }\n  bool operator!=(M rhs) { return !(*this == rhs); }\n  M& operator*=(M rhs) { v = (ulint) v * rhs.v % P; return *this; }\n  M& operator/=(M rhs) { return *this *= rhs.inv(); }\n  M& operator+=(M rhs) { v = rhs.v < P - v ? v + rhs.v : v - (P - rhs.v); return *this; }\n  M& operator-=(M rhs) { v = rhs.v <= v ? v - rhs.v : v + (P - rhs.v); return *this; }\n  M inv() const {\n    assert(v);\n    #ifdef __linux__ // ACとCFで動作を変えるための仮の対処\n      return pow(P - 2);\n    #else\n      int a = v, b = P, x = 1, u = 0;\n      while (b) {\n        int q = a / b;\n        swap(a -= q * b, b);\n        swap(x -= q * u, u);\n      }\n      return x;\n    #endif\n  }\n  template<class Int> M pow(Int n) const {\n    n = n >= 0 ? n % (P - 1) : P - 1 - -n % (P - 1);\n    M res = 1;\n    for (M a = *this; n > 0; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Int> friend M operator*(Int lhs, M rhs) { return M(lhs) *= rhs; }\n  template<class Int> friend M operator/(Int lhs, M rhs) { return M(lhs) /= rhs; }\n  template<class Int> friend M operator+(Int lhs, M rhs) { return M(lhs) += rhs; }\n  template<class Int> friend M operator-(Int lhs, M rhs) { return M(lhs) -= rhs; }\n  friend ostream& operator<<(ostream& os, M rhs) { return os << rhs.v; }\n  friend istream& operator>>(istream& is, M& rhs) { lint x; is >> x; rhs = x; return is; }\n  template<class Int> friend bool operator==(Int lhs, M rhs) { return M(lhs) == rhs; }\n  template<class Int> friend bool operator!=(Int lhs, M rhs) { return !(lhs == rhs); }\n};\n\nusing Mint = ModInt<static_cast<uint>(1e9 + 7)>;\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n, q; cin >> n >> q;\n  V<> a(n); for (int i = 0; i < n; ++i) cin >> a[i];\n  V<> x(q), y(q);\n  for (int i = 0; i < q; ++i) {\n    cin >> x[i] >> y[i], --x[i], --y[i];\n    if (x[i] > y[i]) swap(x[i], y[i]);\n  }\n  VV<Mint> dp0, dp1;\n  assign(dp0, n, n, 0);\n  assign(dp1, n, n, 0);\n  Mint i2 = Mint(2).inv();\n  for (int i = q - 1; i >= 0; --i) {\n    dp0[x[i]][y[i]] = i2 * dp1[x[i]][y[i]] + i2 * (1 - dp1[x[i]][y[i]]);\n    for (int l = 0; l < x[i]; ++l) {\n      dp0[l][x[i]] = i2 * dp1[l][x[i]] + i2 * dp1[l][y[i]];\n      dp0[l][y[i]] = i2 * dp1[l][y[i]] + i2 * dp1[l][x[i]];\n    }\n    for (int m = x[i] + 1; m < y[i]; ++m) {\n      dp0[x[i]][m] = i2 * dp1[x[i]][m] + i2 * (1 - dp1[m][y[i]]);\n      dp0[m][y[i]] = i2 * dp1[m][y[i]] + i2 * (1 - dp1[x[i]][m]);\n    }\n    for (int r = y[i] + 1; r < n; ++r) {\n      dp0[x[i]][r] = i2 * dp1[x[i]][r] + i2 * dp1[y[i]][r];\n      dp0[y[i]][r] = i2 * dp1[y[i]][r] + i2 * dp1[x[i]][r];\n    }\n    dp1[x[i]][y[i]] = dp0[x[i]][y[i]];\n    for (int l = 0; l < x[i]; ++l) {\n      dp1[l][x[i]] = dp0[l][x[i]];\n      dp1[l][y[i]] = dp0[l][y[i]];\n    }\n    for (int m = x[i] + 1; m < y[i]; ++m) {\n      dp1[x[i]][m] = dp0[x[i]][m];\n      dp1[m][y[i]] = dp0[m][y[i]];\n    }\n    for (int r = y[i] + 1; r < n; ++r) {\n      dp1[x[i]][r] = dp0[x[i]][r];\n      dp1[y[i]][r] = dp0[y[i]][r];\n    }\n  }\n  Mint res = 0;\n  for (int l = 0; l < n; ++l) for (int r = l + 1; r < n; ++r) {\n    if (a[l] < a[r]) {\n      res += dp0[l][r];\n    }\n    if (a[l] > a[r]) {\n      res += 1 - dp0[l][r];\n    }\n  }\n  res *= Mint(2).pow(q);\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vi a(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  vll dp(n, vl(n));\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) continue;\n      if (a[i] < a[j]) dp[i][j] = 1;\n    }\n  }\n  ll half = mod_inverse(2);\n  vll memo(n, vl(n));\n  rep (aaa, q) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      memo[i][u] = (dp[i][u] + dp[i][v]) % MOD * half % MOD;\n      memo[u][i] = (dp[u][i] + dp[v][i]) % MOD * half % MOD;\n      memo[i][v] = (dp[i][u] + dp[i][v]) % MOD * half % MOD;\n      memo[v][i] = (dp[u][i] + dp[v][i]) % MOD * half % MOD;\n    }\n    memo[u][v] = memo[v][u] = (dp[u][v] + dp[v][u]) % MOD * half % MOD;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      dp[i][u] = memo[i][u];\n      dp[i][v] = memo[i][v];\n      dp[u][i] = memo[u][i];\n      dp[v][i] = memo[v][i];\n    }\n    dp[u][v] = dp[v][u] = memo[u][v];\n  }\n  ll ans = 0;\n  ll po = pow(2, q);\n  rep (i, n) {\n    for (int j = 0; j < i; j++) {\n      ans += po * dp[i][j] % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n      \n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(3050);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N, Q, A[Max_N], F[Max_N][Max_N], inv2;\n\nint main()\n{\n\tgi(N), gi(Q), inv2 = inverse(2);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(A[i]);\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (i != j)\n\t\t\t\tF[i][j] = (A[i] > A[j]);\n\tfor (int i = 1, x, y;i <= Q;++i)\n\t{\n\t\tgi(x), gi(y), F[x][y] = F[y][x] = inv2;\n\t\tfor (int i = 1;i <= N;++i)\n\t\t\tif (i != x && i != y)\n\t\t\t{\n\t\t\t\tF[x][i] = F[y][i] = Mult(Add(F[x][i], F[y][i]), inv2);\n             \t\t\tF[i][x] = F[i][y] = Mult(Add(F[i][x], F[i][y]), inv2);\n\t\t\t}\n\t}\n\tint Ans = 0;\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = i + 1;j <= N;++j)\n\t\t\tAns = Add(Ans, F[i][j]);\n\twhile (Q--)\n\t\tAns = Add(Ans, Ans);\n\tprint(Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\n#define N 3002\nusing namespace std;\nconst int mod=1000000007;\nint n,q,i,j,a[N],f[N][N],x[N],y[N],p,inv,ans;\nint read()\n{\n\tchar c=getchar();\n\tint w=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c<='9'&&c>='0'){\n\t\tw=w*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn w;\n}\nint poww(int a,int b)\n{\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=ans*base%mod;\n\t\tbase=base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tn=read();q=read();\n\tp=poww(2,q),inv=poww(2,mod-2);\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tfor(i=1;i<=q;i++) x[i]=read(),y[i]=read();\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) f[i][j]=(a[i]>a[j]);\n\t}\n\tfor(i=1;i<=q;i++){\n\t\tf[x[i]][y[i]]=f[y[i]][x[i]]=(f[x[i]][y[i]]+f[y[i]][x[i]])%mod*inv%mod;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(j==x[i]||j==y[i]) continue;\n\t\t\tf[x[i]][j]=f[y[i]][j]=(f[x[i]][j]+f[y[i]][j])%mod*inv%mod;\n\t\t\tf[j][x[i]]=f[j][y[i]]=(f[j][x[i]]+f[j][y[i]])%mod*inv%mod;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=i+1;j<=n;j++) ans=(ans+f[i][j])%mod;\n\t}\n\tans=ans*p%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint N, Q; cin >> N >> Q; \n\tint A[3010]; \n\tfor(int i = 0; i < N; i++) cin >> A[i]; \n\tlong long mod = 1000000007; \n\tlong long half = 500000004; \n\tlong long P[3010][3010] = {}; \n\tlong long S[3010] = {}; \n\tlong long T[3010] = {}; \n\tlong long pow2[3010] = {}; \n\tpow2[0] = 1; \n\tfor(int i = 1; i < 3005; i++) pow2[i] = pow2[i-1] * 2 % mod; \n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(A[i] > A[j]) P[i][j] = 1; \n\t\t}\n\t}\n\tint R = Q; \n\twhile(Q--){\n\t\tint X, Y; cin >> X >> Y; \n\t\tX--; Y--; \n\t\tif(X > Y) swap(X, Y); \n\t\tfor(int i = 0; i < N; i++){\n\t\t\tS[i] = (P[i][X] + P[i][Y]) * half % mod; \n\t\t\tT[i] = (P[X][i] + P[Y][i]) * half % mod; \n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == X || i == Y) continue;\n\t\t\tP[i][X] = S[i]; P[i][Y] = S[i]; \n\t\t\tP[X][i] = T[i]; P[Y][i] = T[i]; \n\t\t}\n\t\tlong long mid = (P[X][Y] + P[Y][X]) * half % mod; \n\t\tP[X][Y] = mid; P[Y][X] = mid;  \n\t}\n\tlong long ans = 0; \n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = i+1; j < N; j++){\n\t\t\tans += P[i][j]; \n\t\t}\n\t}\n\tans %= mod; \n\tcout << ans * pow2[R] % mod << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 3009, MOD = 1e9 + 7;\n\nll dp[SZ][SZ][2];\nll n, q;\nvector<ll> vec;\n\nll bpow(ll vl, ll p, ll MOD) {\n\tif (p == 0) return 1ll;\n\tif (p % 2 == 1) {\n\t\treturn (bpow(vl, p - 1, MOD) * vl) % MOD;\n\t}\n\telse {\n\t\tll b = bpow(vl, p / 2, MOD);\n\t\treturn (b * b) % MOD;\n\t}\n}\nint main() {\n\tfastInp;\n\n\tcin >> n >> q;\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur;\n\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\tif (vec[i] < vec[j]) {\n\t\t\t\tdp[i][j][1]++;\n\t\t\t}\n\t\t\telse if (vec[i] > vec[j]) {\n\t\t\t\tdp[i][j][0]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tll curPw = 1, inv = bpow(2, MOD - 2, MOD), c = 0;\n\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (l > r) swap(l, r);\n\t\tvector<tuple<ll, ll, ll, ll>> add;\n\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tadd.push_back({ i, r, 1, (dp[i][l][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, r, 0, (dp[i][l][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ i, l, 1, (dp[i][r][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, l, 0, (dp[i][r][0] * curPw) % MOD });\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tadd.push_back({ r, i, 1, (dp[l][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ r, i, 0, (dp[l][i][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ l, i, 1, (dp[r][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ l, i, 0, (dp[r][i][0] * curPw) % MOD });\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tadd.push_back({ i, r, 0, (dp[l][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, r, 1, (dp[l][i][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ l, i, 0, (dp[i][r][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ l, i, 1, (dp[i][r][0] * curPw) % MOD });\n\t\t\t}\n\t\t}\n\t\tll s = ((dp[l][r][1] * curPw) % MOD + (dp[l][r][0] * curPw) % MOD) % MOD;\n\t\tc++;\n\t\tdp[l][r][1] = (s * bpow(bpow(2, c, MOD), MOD - 2, MOD)) % MOD;\n\t\tdp[l][r][0] = (s * bpow(bpow(2, c, MOD), MOD - 2, MOD)) % MOD;\n\t\tif (dp[l][r][1] >= MOD) dp[l][r][1] -= MOD;\n\t\tif (dp[l][r][0] >= MOD) dp[l][r][0] -= MOD;\n\n\t\tfor (auto cur : add) {\n\t\t\tll l = get<0>(cur), r = get<1>(cur), fl = get<2>(cur), vl = get<3>(cur);\n\t\t\tif (l > r) {\n\t\t\t\tswap(l, r);\n\t\t\t\tfl = !fl;\n\t\t\t}\n\t\t\tdp[l][r][fl] = (dp[l][r][fl] * curPw) % MOD;\n\t\t\tdp[l][r][fl] += vl;\n\n\t\t\tdp[l][r][fl] = ((dp[l][r][fl] * bpow(bpow(2, c - 1, MOD), MOD - 2, MOD)) % MOD);\n\t\t}\n\n\t\tcurPw *= 2;\n\t\tcurPw %= MOD;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tdp[i][r][0] *= inv;\n\t\t\t\tdp[i][l][0] *= inv;\n\n\t\t\t\tdp[i][l][1] *= inv;\n\t\t\t\tdp[i][r][1] *= inv;\n\n\t\t\t\tdp[i][r][0] %= MOD;\n\t\t\t\tdp[i][l][0] %= MOD;\n\n\t\t\t\tdp[i][l][1] %= MOD;\n\t\t\t\tdp[i][r][1] %= MOD;\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tdp[r][i][0] *= inv;\n\t\t\t\tdp[l][i][0] *= inv;\n\n\t\t\t\tdp[l][i][1] *= inv;\n\t\t\t\tdp[r][i][1] *= inv;\n\n\t\t\t\tdp[r][i][0] %= MOD;\n\t\t\t\tdp[l][i][0] %= MOD;\n\n\t\t\t\tdp[l][i][1] %= MOD;\n\t\t\t\tdp[r][i][1] %= MOD;\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tdp[i][r][1] *= inv;\n\t\t\t\tdp[i][r][0] *= inv;\n\n\t\t\t\tdp[l][i][0] *= inv;\n\t\t\t\tdp[l][i][1] *= inv;\n\n\t\t\t\tdp[i][r][1] %= MOD;\n\t\t\t\tdp[i][r][0] %= MOD;\n\n\t\t\t\tdp[l][i][0] %= MOD;\n\t\t\t\tdp[l][i][1] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0, pw = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tans += (dp[i][j][0] * curPw) % MOD;\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#define SIZE 3005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll dp[SIZE][SIZE];\nll nx[SIZE][SIZE];\nint X[SIZE],Y[SIZE];\nint A[SIZE];\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tfor(int i=0;i<m;i++) scanf(\"%d %d\",&X[i],&Y[i]),X[i]--,Y[i]--;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(A[i]<A[j]) dp[i][j]=1;\n\tll inv=(MOD+1)/2;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(j!=X[i]&&j!=Y[i])\n\t\t\t{\n\t\t\t\tll s=(dp[j][X[i]]+dp[j][Y[i]])%MOD*inv%MOD;\n\t\t\t\tdp[j][X[i]]=dp[j][Y[i]]=s;\n\t\t\t\ts=(dp[X[i]][j]+dp[Y[i]][j])%MOD*inv%MOD;\n\t\t\t\tdp[X[i]][j]=dp[Y[i]][j]=s;\n\t\t\t}\n\t\t}\n\t\tll s=(dp[Y[i]][X[i]]+dp[X[i]][Y[i]])%MOD*inv%MOD;\n\t\tdp[X[i]][Y[i]]=dp[Y[i]][X[i]]=s;\n\t}\n\tll ret=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tret+=dp[i][j];\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++) ret=ret*2LL%MOD;\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5;\nint n, q;\nint a[N];\nconst int mod = (int)1e9 + 7;\nint f[3000][3000][3];\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= mod) {\n        x -= mod;\n    }\n}\nint s1[N][3];\nint s2[N][3];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> q;\n    vector<vector<int> > all;\n    vector<int> cur;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        cur.push_back(a[i]);\n    }\n    all.push_back(cur);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (a[i] < a[j]) {\n                f[i][j][0] = 1;\n            } else if (a[i] > a[j]) {\n                f[i][j][1] = 1;\n            } else {\n                f[i][j][2] = 1;\n            }\n        }\n    }\n    int d2 = (mod + 1) / 2;\n    int mulp = 1;\n    for (int qr = 1; qr <= q; qr++) {\n        int x, y;\n        cin >> x >> y;\n        if (x > y) {\n            swap(x, y);\n        }\n        int q1 = f[x][y][0];\n        int q2 = f[x][y][1];\n        add(f[x][y][0], q2);\n        add(f[x][y][1], q1);\n        f[x][y][0] = 1ll * d2 * f[x][y][0] % mod;\n        f[x][y][1] = 1ll * d2 * f[x][y][1] % mod;\n        for (int j = 1; j <= n; j++) {\n            if (j < x) {\n                s1[j][0] = f[j][x][0] % mod;\n                s1[j][1] = f[j][x][1] % mod;\n                s2[j][2] = f[j][x][2] % mod;\n            } else {\n                s1[j][0] = f[x][j][0] % mod;\n                s1[j][1] = f[x][j][1] % mod;\n                s1[j][2] = f[x][j][2] % mod;\n            }\n            if (j < y) {\n                s2[j][0] = f[j][y][0] % mod;\n                s2[j][1] = f[j][y][1] % mod;\n                s2[j][2] = f[j][y][2] % mod;\n            } else {\n                s2[j][0] = f[y][j][0] % mod;\n                s2[j][1] = f[y][j][1] % mod;\n                s2[j][2] = f[y][j][2] % mod;\n            }\n        }\n        for (int j = 1; j <= n; j++) {\n            if (j != x && j != y) {\n               if (j < x) {\n                   add(f[j][y][0], s1[j][0]);\n                   add(f[j][y][1], s1[j][1]);\n                   add(f[j][y][2], s1[j][2]);\n\n                   add(f[j][x][0], s2[j][0]);\n                   add(f[j][x][1], s2[j][1]);\n                   add(f[j][x][2], s2[j][2]);\n               } else if (j > x && j < y) {\n                   add(f[j][y][0], s1[j][1]);\n                   add(f[j][y][1], s1[j][0]);\n                   add(f[j][y][2], s1[j][2]);\n\n                   add(f[x][j][0], s2[j][1]);\n                   add(f[x][j][1], s2[j][0]);\n                   add(f[x][j][2], s2[j][2]);\n               } else {\n                   add(f[y][j][0], s1[j][0]);\n                   add(f[y][j][1], s1[j][1]);\n                   add(f[y][j][2], s1[j][2]);\n\n                   add(f[x][j][0], s2[j][0]);\n                   add(f[x][j][1], s2[j][1]);\n                   add(f[x][j][2], s2[j][2]);\n               }\n               if (j < x) {\n                   for (int t = 0; t < 3; t++) {\n                       f[j][x][t] = 1ll * f[j][x][t] * d2 % mod;\n                       f[j][y][t] = 1ll * f[j][y][t] * d2 % mod;\n                   }\n               } else if (j > x && j < y) {\n                   for (int t = 0; t < 3; t++) {\n                       f[x][j][t] = 1ll * f[x][j][t] * d2 % mod;\n                       f[j][y][t] = 1ll * f[j][y][t] * d2 % mod;\n                   }\n               } else {\n                   for (int t = 0; t < 3; t++) {\n                       f[x][j][t] = 1ll * f[x][j][t] * d2 % mod;\n                       f[y][j][t] = 1ll * f[y][j][t] * d2 % mod;\n                   }\n               }\n            }\n        }\n        add(mulp, mulp);\n\n    }\n    int ans = 0;\n    for (int it = 1; it <= n; it++) {\n        for (int j = it + 1; j <= n; j++) {\n            int qq = 1ll * f[it][j][1] * mulp % mod;\n            add(ans, qq);\n        }\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 1000000007;\nconst ll half = 500000004;\n\nint main(){\n\n    ll N,Q;\n    cin >> N >> Q;\n    vector<ll> A(N,0);\n\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<vector<ll>> lis(N,vector<ll> (N,0));\n    rep(i,0,N){\n        rep(j,0,N){\n            if (A[i] > A[j]) lis[i][j] = 1;\n        }\n    }\n\n    rep(loop,0,Q){\n\n        vector<vector<ll>> q(5*N,vector<ll> (3,0));\n        ll qind = 0;\n        ll x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n\n        rep(v,0,N){\n            if ((v != x) && (v != y)){\n                q[qind++] = {y,v,lis[x][v]};\n                q[qind++] = {x,v,lis[y][v]};\n                q[qind++] = {v,y,lis[v][x]};\n                q[qind++] = {v,x,lis[v][y]}; \n            }\n        }\n\n        q[qind++] = {x,y,lis[y][x]};\n        q[qind++] = {y,x,lis[x][y]};\n\n        rep(t,0,qind){\n            ll i,j,n;\n            i = q[t][0];\n            j = q[t][1];\n            n = q[t][2];\n\n            lis[i][j] += n;\n            lis[i][j] *= half;\n            lis[i][j] %= mod;\n        }\n    }\n\n    cout << \"wa\" << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1000000000000000000\n\nint main(){\n\t\n\tint N,Q;\n\tcin>>N>>Q;\n\t\n\tvector<int> beki(10000,1);\n\tfor(int i=1;i<beki.size();i++){\n\t\tbeki[i] = mod(beki[i-1]*2);\n\t}\n\t\n\tvector<int> A(N);\n\tfor(int i=0;i<N;i++)cin>>A[i];\n\t\n\tvector<vector<int>> dp(N,vector<int>(N,0));\n\tvector<vector<int>> last(N,vector<int>(N,0));\n\t\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(A[i]<A[j])dp[i][j]++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<Q;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tvector<int> X(N),Y(N);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdp[x][j] = mod(dp[x][j] * beki[i-last[x][j]]);\n\t\t\tlast[x][j]=i+1;\n\t\t\tX[j] = dp[x][j];\n\t\t}\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdp[y][j] = mod(dp[y][j] * beki[i-last[y][j]]);\n\t\t\tlast[y][j]=i+1;\n\t\t\tY[j] = dp[y][j];\n\t\t}\n\t\t\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(x!=j)dp[x][j] = mod(dp[x][j] + Y[j]);\n\t\t\tif(y!=j)dp[y][j] = mod(dp[y][j] + X[j]);\n\t\t}\n\t\t\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(j==y)continue;\n\t\t\tdp[j][x] = mod(dp[j][x] * beki[i-last[j][x]]);\n\t\t\tlast[j][x]=i+1;\n\t\t\tX[j] = dp[j][x];\n\t\t}\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(j==x)continue;\n\t\t\tdp[j][y] = mod(dp[j][y] * beki[i-last[j][y]]);\n\t\t\tlast[j][y]=i+1;\n\t\t\tY[j] = dp[j][y];\n\t\t}\n\t\t\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(x!=j)dp[j][x] = mod(dp[j][x] + Y[j]);\n\t\t\tif(y!=j)dp[j][y] = mod(dp[j][y] + X[j]);\n\t\t}\n\t\t\n\t\t\n\t\tdp[x][y] = mod(dp[x][y] + Y[x]);\n\t\tdp[y][x] = mod(dp[y][x] + X[y]);\n\n\t\t/*\n\t\tfor(int j=0;j<N;j++){\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tcout<<dp[j][k] * beki[(i+1)-last[j][k]]<<',';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tdp[i][j] = mod(dp[i][j] * beki[Q-last[i][j]]);\n\t\t\tif(i>j){\n\t\t\t\tans = mod(ans + dp[i][j]);\n\t\t\t}\n\t\t\t//cout<<dp[i][j]<<',';\n\t\t}\n\t//\tcout<<endl;\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ins insert\n#define F first\n#define S second\n#define var auto\nusing namespace std;\ntypedef long long ll;\nconst int Max = 5e3 + 50;\nconst int Mod = 1e9 + 7;\n\nint A[Max];\nint X[Max] , Y[Max];\n\nll cnt[Max];\nll inv[Max][Max];\nll nrm[Max][Max];\nll lstedit[Max][Max];\nll _2pw[Max];\nll pw(int b)\n{\n\treturn _2pw[b];\n}\n\nll getInv(int i , int j , int q)\n{\n\tif(i > j)\n\t\tswap(i , j);\n\treturn inv[i][j] * pw(q - lstedit[i][j] - 1) % Mod;\n}\n\nll getNrm(int i , int j , int q)\n{\n\tif(i > j)\n\t\tswap(i , j);\n\treturn nrm[i][j] * pw(q - lstedit[i][j] - 1) % Mod;\n}\n\n\n\nint main()\n{\n\tint n , q;cin >> n >> q;\n\t_2pw[0] = 1;\n\tfor(int i = 1; i <= q + 1;i++)\n\t\t_2pw[i] = _2pw[i - 1] * 2 % Mod;\n\tfor(int i = 1; i <= n ; i++)\n\t\tcin >> A[i];\n\tfor(int i = 1; i <= q ; i++)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tif(X[i] > Y[i])\n\t\t\tswap(X[i] , Y[i]);\n\t}\n\n\tfor(int i = 1; i <= q; i++)\n\t{\n\t\tfor(int j = X[i] + 1; j <= Y[i];j++)\n\t\t\tcnt[i] += (A[X[i]] > A[j]);\n\t\tfor(int j = Y[i] - 1; j >= X[i];j--)\n\t\t\tcnt[i] += (A[j] > A[Y[i]]);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n ; j++)\n\t\t\tif(A[i] > A[j])\n\t\t\t{\n\t\t\t\tinv[i][j]++;\n\t\t\t\tinv[j][i]++;\n\t\t\t}\n\t\t\telse if(A[i] < A[j])\n\t\t\t{\n\t\t\t\tnrm[i][j]++;\n\t\t\t\tnrm[j][i]++;\n\t\t\t}\n\n\tll _2k = 1;\n\tfor(int i = 1; i <= q; i++ , _2k = _2k * 2 % Mod)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(j == X[i] || j == Y[i])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tll invX = getInv(j , X[i] , i);\n\t\t\t\tll invY = getInv(j , Y[i] , i);\n\t\t\t\tll nrmX = getNrm(j , X[i] , i);\n\t\t\t\tll nrmY = getNrm(j , Y[i] , i);\n\t\t\t\t\n\t\t\t\tif(j < X[i] || j > Y[i])\n\t\t\t\t{\n\t\t\t\t\tinv[j][X[i]] = inv[X[i]][j] =\n\t\t\t\t\t   inv[j][Y[i]] = inv[Y[i]][j] = \n\t\t\t\t\t   (invX + invY) % Mod;\n\t\t\t\t\tnrm[j][X[i]] = nrm[X[i]][j] =\n\t\t\t\t\t   nrm[j][Y[i]] = nrm[Y[i]][j] = \n\t\t\t\t\t   (nrmX + nrmY) % Mod;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinv[j][X[i]] = inv[X[i]][j] = (invX + nrmY) % Mod;\n\t\t\t\t\tinv[j][Y[i]] = inv[Y[i]][j] = (invY + nrmX) % Mod;\n\t\t\t\t\tnrm[j][X[i]] = nrm[X[i]][j] = (nrmX + invY) % Mod;\n\t\t\t\t\tnrm[j][Y[i]] = nrm[Y[i]][j] = (nrmY + invX) % Mod;\n\t\t\t\t}\n\n\t\t\t\tlstedit[j][X[i]] = lstedit[X[i]][j] =\n\t\t\t\t   lstedit[j][Y[i]] = lstedit[Y[i]][j] = i;\n\t\t\t}\n\t\t}\n\n\t\tll invxy = getInv(X[i] , Y[i] , i);\n\t\tll nrmxy = getNrm(X[i] , Y[i] , i);\n\t\tinv[X[i]][Y[i]] = inv[Y[i]][X[i]] = (invxy + nrmxy) % Mod;\n\t\tnrm[X[i]][Y[i]] = nrm[Y[i]][X[i]] = (invxy + nrmxy) % Mod;\n\t\tlstedit[X[i]][Y[i]] = lstedit[Y[i]][X[i]] = i;\n\t}\n\n\t/*cout << \"\\n**\\n\";\n\tfor(int j = 1; j <= n ; j++)\n\t{\n\t\tfor(int k = 1; k <= n ; k++)\n\t\t\tcout << getReal(j , k , q + 1) << \" \";\n\t\tcout << '\\n';\n\t}*/\n\n\tll ANS = 0;\n\tfor(int i = 1; i <= n ; i++)\n\t{\n\t\tfor(int j = i + 1; j <= n ; j++)\n\t\t\tANS += getInv(i,j, q + 1);\n\t}\n\tcout << '\\n' << ANS << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7); //998244353LL;\n\n\nvoid solve()\n{\n\tll N, Q;\n\tcin >> N >> Q;\n\tvll A = cinv(N);\n\tauto XY = cinv2(Q);\n\tEACH(e, XY){\n\t\te.first--; e.second--;\n\t}\n\n\tvector<vector<mll>> C(N, vector<mll>(N));\n\n\tmll two = 2;\n\tmll twoQ = POW(two, Q);\n\n\tREP(i, N) REP(j, N){\n\t\tif (i == j) continue;\n\t\tif (A[i] > A[j]) C[i][j] = twoQ;\n\t}\n\n\tREP(i, Q){\n\t\tll X = XY[i].first;\n\t\tll Y = XY[i].second;\n\n\t\tC[X][Y] = C[Y][X] = (C[X][Y] + C[Y][X]) / 2;\n\t\tREP(j, N){\n\t\t\tif (j == X || j == Y) continue;\n\t\t\tC[X][j] = C[Y][j] = (C[X][j] + C[Y][j]) / 2;\n\t\t}\n\n\t\tREP(j, N){\n\t\t\tif (j == X || j == Y) continue;\n\t\t\tC[j][X] = C[j][Y] = (C[j][X] + C[j][Y]) / 2;\n\t\t}\n\t}\n\n\tmll ans = 0;\n\tREP(i, N-1){\n\t\tans += Sum(C[i], i+1, N-1);\n\t}\n\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LOCAL\n#pragma region Macros\ntypedef long long ll;\n#define ALL(x) (x).begin(),(x).end()\nconst long long MOD=1e9+7;\n// const long long MOD=998244353;\nconst int INF=1e9;\nconst long long IINF=1e18;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst char dir[4]={'D','R','U','L'};\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T> &v){\n    for (T &x:v) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T> &v){\n    for (int i=0;i<v.size();++i){\n        os << v[i] << (i+1==v.size()?\"\": \" \");\n    }\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const pair<T,U> &p){\n    cout << '(' << p.first << ',' << p.second << ')';\n    return os;\n}\ntemplate<typename T,typename U>\nostream &operator<<(ostream &os,const map<T,U> &m){\n    os << '{';\n    for (auto itr=m.begin();itr!=m.end();++itr){\n        os << '(' << itr->first << ',' << itr->second << ')';\n        if (++itr!=m.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os,const set<T> &s){\n    os << '{';\n    for (auto itr=s.begin();itr!=s.end();++itr){\n        os << *itr;\n        if (++itr!=s.end()) os << ',';\n        --itr;\n    }\n    os << '}';\n    return os;\n}\n\nvoid debug_out(){cerr << '\\n';}\ntemplate<class Head,class... Tail>\nvoid debug_out(Head&& head,Tail&&... tail){\n    cerr << head;\n    if (sizeof...(Tail)>0) cerr << \", \";\n    debug_out(move(tail)...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \" \";\\\ncerr << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << '\\n';\\\ncerr << \" \";\\\ndebug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<typename T> T gcd(T x,T y){return y!=0?gcd(y,x%y):x;}\ntemplate<typename T> T lcm(T x,T y){return x/gcd(x,y)*y;}\n\ntemplate<class T1,class T2> inline bool chmin(T1 &a,T2 b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T1,class T2> inline bool chmax(T1 &a,T2 b){\n    if (a<b){a=b; return true;} return false;\n}\n#pragma endregion\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q; cin >> N >> Q;\n    vector<int> A(N);\n    for (int i=0;i<N;++i) cin >> A[i];\n    vector<vector<mint>> dp(N,vector<mint>(N,0))\n                        ,nxt(N,vector<mint>(N));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<N;++j){\n            if (A[i]<A[j]){\n                dp[i][j]+=1;\n            }\n        }\n    }\n    vector<vector<int>> pre(N,vector<int>(N,0));\n    vector<mint> po(Q+1,1);\n    auto to=[](int i,int x,int y){\n        return i==x?y:(i==y?x:i);\n    };\n    auto update=[&](int i,int j,int k){\n        nxt[j][k]=0; dp[j][k]*=po[i-pre[j][k]];\n    };\n    auto add=[&](int j,int k,int x,int y){\n        int nj=to(j,x,y),nk=to(k,x,y);\n        nxt[j][k]+=dp[j][k];\n        nxt[nj][nk]+=dp[j][k];\n    };\n    for (int i=0;i<Q;++i){\n        po[i+1]=po[i]*2;\n        int X,Y; cin >> X >> Y; --X,--Y;\n        vector<int> v={X,Y};\n        for (int j=0;j<N;++j){\n            if (j==X||j==Y) continue;\n            for (int k=0;k<2;++k){\n                update(i,j,v[k]);\n                update(i,v[k],j);\n            }\n        }\n        for (int j=0;j<2;++j){\n            for (int k=0;k<2;++k){\n                update(i,v[j],v[k]);\n            }\n        }\n        for (int j=0;j<N;++j){\n            if (j==X||j==Y) continue;\n            for (int k=0;k<2;++k){\n                add(j,v[k],X,Y);\n                add(v[k],j,X,Y);\n            }\n        }\n        for (int j=0;j<2;++j){\n            for (int k=0;k<2;++k){\n                add(v[j],v[k],X,Y);\n            }\n        }\n        for (int j=0;j<N;++j){\n            for (int k=0;k<2;++k){\n                pre[j][v[k]]=pre[v[k]][j]=i+1;\n                dp[j][v[k]]=nxt[j][v[k]];\n                dp[v[k]][j]=nxt[v[k]][j];\n            }\n        }\n    }\n    mint ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<i;++j){\n            ans+=dp[i][j]*po[Q-pre[i][j]];\n        }\n    }\n    cout << ans << '\\n';\n}\n\n/*\nmint dp[20][20][20];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q; cin >> N >> Q;\n    vector<int> A(N);\n    for (int i=0;i<N;++i) cin >> A[i];\n    for (int i=0;i<N;++i){\n        for (int j=0;j<N;++j){\n            if (A[i]<A[j]){\n                dp[0][i][j]+=1;\n            }\n        }\n    }\n    auto f=[](int i,int x,int y){\n        return (i==x?y:(i==y?x:i));\n    };\n    for (int i=0;i<Q;++i){\n        int X,Y; cin >> X >> Y; --X,--Y;\n        for (int j=0;j<N;++j){\n            for (int k=0;k<N;++k){\n                dp[i+1][j][k]+=dp[i][j][k];\n                dp[i+1][f(j,X,Y)][f(k,X,Y)]+=dp[i][j][k];\n            }\n        }\n        mint sum=0;\n        for (int j=0;j<N;++j){\n            for (int k=0;k<N;++k){\n                cerr << dp[i+1][j][k] << (k+1==N?'\\n':' ');\n                sum+=dp[i+1][j][k];\n            }\n        }\n        debug(i,sum);\n        cerr << '\\n';\n    }\n    mint ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<i;++j){\n            ans+=dp[Q][i][j];\n        }\n    }\n    cout << ans << '\\n';\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define modsum(a, b) ((a) + (b) >= M ? (a) + (b) - M : (a) + (b))\n#define modsubtract(a, b) ((a) - (b) < 0 ? (a) - (b) + M : (a) - (b))\n#define modmultiply(a, b) (((a) * (b)) % M)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)((a).size()))\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T>\nostream & operator << (ostream &out, vector<T> &a) {\n    out << \"{\";\n    fori (i, SZ(a))\n        out << a[i] << vector<string>{\", \", \"}\"}[i + 1 == SZ(a)];\n    return out;\n}\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\n\";\n    cout << \"TOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nint n, q;\nconst int N = 3003;\nconst ll M = 1e9 + 7;\nint a[N];\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % M;\n        a = (a * a) % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll pw2[N];\n\nmap<pii, int> dp[N];\n\npii queries[N];\n\nvi my_q[N];\n\nll dfs(int i, int l, int r) {\n    if (i == q) {\n        if (l > r) return 1;\n        return 0;\n    }\n    if (dp[i].count({l, r})) return dp[i][{l, r}];\n\n    vi cur_q;\n    for (int j = upper_bound(ALL(my_q[l]), i - 1) - my_q[l].begin(); j < SZ(my_q[l]); ++j) {\n        int ind = my_q[l][j];\n        cur_q.push_back(ind);\n    }\n    for (int j = upper_bound(ALL(my_q[r]), i - 1) - my_q[r].begin(); j < SZ(my_q[r]); ++j) {\n        int ind = my_q[r][j];\n        cur_q.push_back(ind);\n    }\n    sort(ALL(cur_q));\n    cur_q.resize(unique(ALL(cur_q)) - cur_q.begin());\n    ll ret = 0;\n    for (int j = 0; j < cur_q.size(); ++j) {\n        int ind = cur_q[j];\n        int lf = queries[ind].first, rf = queries[ind].second;\n        if ((l < r) ^ (lf < rf)) swap(lf, rf);\n        ll ways = pw2[ind - i - j];\n        if (lf == l && rf == r) {\n            ret = (ret + ways * dfs(ind + 1, r, l)) % M;\n        } else if (lf == l || rf == l) {\n            if (lf != l) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, rf, r)) % M;\n        } else if (rf == r || lf == r) {\n            if (rf != r) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, l, lf)) % M;\n        } else assert(0);\n    }\n    ret = (ret + pw2[q - i - cur_q.size()] * dfs(q, l, r)) % M;\n    return dp[i][{l, r}] = ret;\n}\n\nvoid smain() {\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n    cin >> n >> q;\n    fori (i, n) cin >> a[i];\n    fori (i, q) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--, queries[i].second--;\n        my_q[queries[i].first].push_back(i);\n        my_q[queries[i].second].push_back(i);\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ll cur = dfs(0, i, j);\n//            cout << \"cur[\" << i << \", \" << j << \"] = \" << cur << endl;\n            if (a[i] < a[j]) ans = (ans + cur) % M;\n            else if (a[i] > a[j]) ans = (ans + pw2[q] - cur + M) % M;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nll dp[3333][3333];\n\nint main(){\n\t\n\tll n,m;cin >> n >> m;\n\tvector<ll> v(n);\n\tREP(i,n)cin >> v[i];\n\tREP(i,n)REP(j,n)if(v[i] < v[j])dp[i][j] = 1;\n\tll inv = mod_div(1, 2);\n\t\n\tREP(q,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tREP(i,n){\n\t\t\tif(i != a && i != b){\n\t\t\t\tll tmp = (dp[i][a] + dp[i][b]) % MOD * inv % MOD;\n\t\t\t\tdp[i][a] = dp[i][b] = tmp;\n\t\t\t\ttmp = (dp[a][i] + dp[b][i]) % MOD * inv % MOD;\n\t\t\t\tdp[a][i] = dp[b][i] = tmp;\n\t\t\t}\n\t\t}\n\t\tll tmp = (dp[a][b] + dp[b][a]) % MOD * inv % MOD;\n\t\tdp[a][b] = dp[b][a] = tmp;\n\t}\n\t\t\n\tll ans = 0;\n\tREP(i,n)REP(j,i)ans = (ans + dp[i][j]) % MOD;\n\tREP(i,m)ans = (ans * 2) % MOD;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 3000;\nint const modulo = 1000000007;\n\nint v[5 + nmax];\nint _pow[5 + nmax];\n\nvoid precompute() {\n  _pow[0] = 1;\n  for(int i = 1;i <= nmax; i++)\n    _pow[i] = 1LL * _pow[i - 1] * 2 % modulo;\n}\n\nint dp[5 + nmax][5 + nmax];\nint last[5 + nmax][5 + nmax];\n\nvoid refresh(int x, int y, int time) {\n  dp[x][y] = 1LL * dp[x][y] * _pow[time - last[x][y] - 1] % modulo;\n  last[x][y] = time;\n}\n\nint main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0);\n\n  precompute();\n  int n, q;\n  std::cin >> n >> q;\n  for(int i = 1;i <= n; i++)\n    std::cin >> v[i];\n  for(int i = 1;i <= n; i++)\n    for(int j = 1;j <= n; j++)\n      dp[i][j] = (v[i] < v[j]);\n      \n  for(int i = 1;i <= q; i++) {\n    int x, y;\n    std::cin >> x >> y;\n    refresh(x, y, i);\n    refresh(y, x, i);\n    dp[y][x] = dp[x][y] = (dp[x][y] + dp[y][x]) % modulo;\n\n    for(int j = 1; j <= n; j++) \n      if(j != x && j != y) {\n        refresh(j, x, i);\n        refresh(j, y, i);\n        refresh(x, j, i);\n        refresh(y, j, i);\n        dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) % modulo;\n        dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) % modulo;    \n      }\n  }\n  int result = 0;\n  for(int i = 1;i <= n; i++)\n    for(int j = 1;j < i; j++) {\n      refresh(i, j, q + 1);\n      result += dp[i][j];\n      if(modulo <= result)\n        result -= modulo;\n    }\n  std::cout << result;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 3009, MOD = 1e9 + 7;\n\nll dp[SZ][SZ][2];\nll n, q;\nvector<ll> vec;\n\nint main() {\n\tfastInp;\n\n\tcin >> n >> q;\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur;\n\t\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\tif (vec[i] < vec[j]) {\n\t\t\t\tdp[i][j][1]++;\n\t\t\t}\n\t\t\telse if (vec[i] > vec[j]) {\n\t\t\t\tdp[i][j][0]++;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (l > r) swap(l, r);\n\t\tvector<tuple<ll, ll, ll, ll>> add;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tadd.push_back({ i, r, 1, dp[i][l][1] });\n\t\t\t\tadd.push_back({ i, r, 0, dp[i][l][0] });\n\n\t\t\t\tadd.push_back({ i, l, 1, dp[i][r][1] });\n\t\t\t\tadd.push_back({ i, l, 0, dp[i][r][0] });\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tadd.push_back({ i, r, 1, dp[l][i][1] });\n\t\t\t\tadd.push_back({ i, r, 0, dp[l][i][0] });\n\n\t\t\t\tadd.push_back({ i, l, 1, dp[r][i][1] });\n\t\t\t\tadd.push_back({ i, l, 0, dp[r][i][0] });\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tadd.push_back({ i, r, 0, dp[l][i][1] });\n\t\t\t\tadd.push_back({ i, r, 1, dp[l][i][0] });\n\n\t\t\t\tadd.push_back({ i, l, 0, dp[i][r][1] });\n\t\t\t\tadd.push_back({ i, l, 1, dp[i][r][0] });\n\t\t\t}\n\t\t}\n\t\tdp[l][r][1] += dp[l][r][0];\n\t\tdp[l][r][0] = dp[l][r][1];\n\t\tif (dp[l][r][1] >= MOD) dp[l][r][1] %= MOD;\n\t\tif (dp[l][r][0] >= MOD) dp[l][r][0] %= MOD;\n\n\t\tfor (auto cur : add) {\n\t\t\tll l = get<0>(cur), r = get<1>(cur), fl = get<2>(cur), vl = get<3>(cur);\n\t\t\tif (l > r) swap(l, r);\n\t\t\tdp[l][r][fl] += vl;\n\t\t\tif (dp[l][r][fl] >= MOD) dp[l][r][fl] -= MOD;\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tans += dp[i][j][0];\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int MOD = 1e9 + 7, N = 3333;\n\nint n, Q, pw[N], a[N], bel[N][N];\nvector<int> op[N], cp[N];\nlong long ans;\nmap<long long, int> mp;\n\nint Solve(int cur, int x, int y, int val) {\n  if(mp.find(cur * n * n + x * n + y) != mp.end()) {\n    return mp[cur * n * n + x * n + y];\n  }\n  int indx = bel[x][cur];\n  int indy = bel[y][cur];\n  if(indx == op[x].size() && indy == op[y].size()) {\n    ans = (ans + 1LL * (x > y) * val * pw[Q + 1 - cur] % MOD) % MOD;\n    return 1LL * (x > y) * val * pw[Q + 1 - cur] % MOD;\n  }\n  //cerr << indx << \" \" << indy << endl;\n  int ix = indx == op[x].size() ? n + 1 : op[x][indx];\n  int iy = indy == op[y].size() ? n + 1 : op[y][indy];\n  int now = 0;\n  //cerr << ix << \" \" << iy << endl;\n  if(ix < iy) {\n    val = 1LL * val * pw[ix - cur] % MOD;\n    if(cp[x][indx] != x) {\n      now += Solve(ix + 1, x, y, val);\n      x = cp[x][indx];\n      now += Solve(ix + 1, x, y, val);\n    } else {\n      now += Solve(ix + 1, x, y, val * 2 % MOD);\n    }\n  } else if(ix > iy) {\n    val = 1LL * val * pw[iy - cur] % MOD;\n    if(cp[y][indy] != y) { \n      now += Solve(iy + 1, x, y, val);\n      y = cp[y][indy];\n      now += Solve(iy + 1, x, y, val);\n    } else {\n      now += Solve(iy + 1, x, y, val * 2 % MOD);\n    }\n  } else {\n    val = 1LL * val * pw[iy - cur] % MOD;\n    now += Solve(iy + 1, x, y, val);\n    //assert(indy < cp[x].size());\n    x = cp[x][indx];\n    y = cp[y][indy];\n    now += Solve(iy + 1, x, y, val);\n  }\n  return mp[cur * n * n + x * n + y] = now;\n}\n\nmain(void) {\n  scanf(\"%lld%lld\", &n, &Q);\n  pw[0] = 1;\n  for(int i = 1; i <= Q; i++) {\n    pw[i] = pw[i - 1] * 2 % MOD;\n  }\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n  }\n  for(int i = 1, x, y; i <= Q; i++) {\n    scanf(\"%lld%lld\", &x, &y);\n    op[x].push_back(i);\n    cp[x].push_back(y);\n    op[y].push_back(i);\n    cp[y].push_back(x);\n  }\n  for(int i = 1; i <= n; i++) {\n    int k = 1;\n    for(int j = 0; j < op[i].size(); j++) {\n      while(k <= op[i][j]) {\n\tbel[i][k] = j;\n\tk++;\n      }\n    }\n    while(k <= Q + 1) {\n      bel[i][k] = op[i].size();\n      k++;\n    }\n    \n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if(a[i] < a[j]) {\n\tmp.clear();\n\tSolve(1, i, j, 1);\n      }\n      //cerr << ans << endl;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 3e3 + 10, MOD = 1e9 + 7, I2 = (MOD + 1) / 2;\n\nint n, Q;\nint a[MAXN], P[MAXN][MAXN];\n\nint main() {\n\tscanf(\"%d%d\", &n, &Q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) P[i][j] = a[i] > a[j];\n\tfor (int i = 1, x, y; i <= Q; ++i) {\n\t\tscanf(\"%d%d\", &x, &y), P[x][y] = P[y][x] = (P[x][y] + P[y][x]) * I2 % MOD;\n\t\tfor (int j = 1; j <= n; ++j) if (j != x && j != y) P[x][j] = P[y][j] = 1LL * (P[x][j] + P[y][j]) * I2 % MOD, P[j][x] = P[j][y] = 1LL * (P[j][x] + P[j][y]) * I2 % MOD;\n\t}\n\tint pro = 1, ans = 0;\n\tfor (int i = 1; i <= Q; ++i) pro = pro * 2 % MOD;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) ans = (ans + P[i][j]) % MOD;\n\tprintf(\"%d\\n\", 1LL * ans * pro % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int mo = 1e9 + 7;\n\nll ksm(ll x, ll y) {\n\tll s = 1;\n\tfor(; y; y /= 2, x = x * x % mo)\n\t\tif(y & 1) s = s * x % mo;\n\treturn s;\n}\n\nconst ll ni2 = ksm(2, mo - 2);\n\nconst int N = 3005;\n\nint n, q, a[N], x[N], y[N];\nll f[N][N];\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\tfo(i, 1, n) scanf(\"%d\", &a[i]);\n\tfo(i, 1, n) fo(j, 1, n) f[i][j] = a[i] > a[j];\n\tfo(i, 1, q) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tfo(j, 1, n) if(j != x[i] && j != y[i]) {\n\t\t\tf[j][y[i]] = f[j][x[i]] = (f[j][y[i]] + f[j][x[i]]) * ni2 % mo;\n\t\t\tf[y[i]][j] = f[x[i]][j] = (f[y[i]][j] + f[x[i]][j]) * ni2 % mo;\n\t\t}\n\t\tf[x[i]][y[i]] = f[y[i]][x[i]] = (f[x[i]][y[i]] + f[y[i]][x[i]]) * ni2;\n\t}\n\tll w = ksm(2, q), ans = 0;\n\tfo(i, 1, n) fo(j, i + 1, n) ans = (ans + f[i][j] * w) % mo;\n\tpp(\"%lld\\n\", ans);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 3010;\nconst ll MOD = 1e9 + 7, INV2 = (MOD + 1) / 2;\n\nint N, Q, A[MAX_N];\nll dp[MAX_N][MAX_N];\npair<int, int> oper[MAX_N];\n\nint main() {\n    scanf(\"%d%d\", &N, &Q);\n    for (int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n    for (int i = 1; i <= Q; i++) scanf(\"%d%d\", &oper[i].first, &oper[i].second);\n    for (int i = 1; i <= N; i++)\n        for (int j = 1; j <= N; j++)\n            dp[i][j] = i > j;\n    for (int i = Q; i; i--) {\n        int a = oper[i].first, b = oper[i].second;\n        vector<pair<ll *, ll>> modify;\n        modify.emplace_back(&dp[a][b], INV2);\n        modify.emplace_back(&dp[b][a], INV2);\n        for (int j = 1; j <= N; j++) {\n            if (j == a || j == b) continue;\n            modify.emplace_back(&dp[a][j], (dp[a][j] + dp[b][j]) * INV2 % MOD);\n            modify.emplace_back(&dp[j][a], (dp[j][a] + dp[j][b]) * INV2 % MOD);\n        }\n        for (int j = 1; j <= N; j++) {\n            if (j == a || j == b) continue;\n            modify.emplace_back(&dp[b][j], (dp[b][j] + dp[a][j]) * INV2 % MOD);\n            modify.emplace_back(&dp[j][b], (dp[j][b] + dp[j][a]) * INV2 % MOD);\n        }\n        for (auto i : modify)\n            *(i.first) = i.second;\n    }\n    ll ans = 0;\n    for (int i = 1; i <= N; i++)\n        for (int j = i + 1; j <= N; j++) {\n            if (A[i] > A[j]) (ans += dp[j][i]) %= MOD;\n            if (A[i] < A[j]) (ans += dp[i][j]) %= MOD;\n        }\n    for (int i = 1; i <= Q; i++) (ans *= 2) %= MOD;\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 3009, MOD = 1e9 + 7;\n\nll dp[SZ][SZ][2];\nll n, q;\nvector<ll> vec;\n\nll bpow(ll vl, ll p, ll MOD) {\n\tif (p == 0) return 1ll;\n\tif (p % 2 == 1) {\n\t\treturn (bpow(vl, p - 1, MOD) * vl) % MOD;\n\t}\n\telse {\n\t\tll b = bpow(vl, p / 2, MOD);\n\t\treturn (b * b) % MOD;\n\t}\n}\nint main() {\n\tfastInp;\n\n\tcin >> n >> q;\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur;\n\t\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\tif (vec[i] < vec[j]) {\n\t\t\t\tdp[i][j][1]++;\n\t\t\t}\n\t\t\telse if (vec[i] > vec[j]) {\n\t\t\t\tdp[i][j][0]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tll curPw = 1;\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (l > r) swap(l, r);\n\t\tvector<tuple<ll, ll, ll, ll>> add;\n\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tadd.push_back({ i, r, 1, (dp[i][l][1] * curPw) % MOD});\n\t\t\t\tadd.push_back({ i, r, 0, (dp[i][l][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ i, l, 1, (dp[i][r][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, l, 0, (dp[i][r][0] * curPw) % MOD });\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tadd.push_back({ r, i, 1, (dp[l][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ r, i, 0, (dp[l][i][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ l, i, 1, (dp[r][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ l, i, 0, (dp[r][i][0] * curPw) % MOD });\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tadd.push_back({ i, r, 0, (dp[l][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, r, 1, (dp[l][i][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ l, i, 0, (dp[i][r][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ l, i, 1, (dp[i][r][0] * curPw) % MOD });\n\t\t\t}\n\t\t}\n\t\tll s = (dp[l][r][1] * curPw) % MOD + (dp[l][r][0] * curPw) % MOD;\n\t\tdp[l][r][1] = s;\n\t\tdp[l][r][0] = s;\n\t\tif (dp[l][r][1] >= MOD) dp[l][r][1] -= MOD;\n\t\tif (dp[l][r][0] >= MOD) dp[l][r][0] -= MOD;\n\n\t\tfor (auto cur : add) {\n\t\t\tll l = get<0>(cur), r = get<1>(cur), fl = get<2>(cur), vl = get<3>(cur);\n\t\t\tif (l > r) {\n\t\t\t\tswap(l, r);\n\t\t\t\tfl = !fl;\n\t\t\t}\n\t\t\tdp[l][r][fl] += vl;\n\t\t\tif (dp[l][r][fl] >= MOD) dp[l][r][fl] -= MOD;\n\t\t}\n\n\t\tcurPw *= 2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tdp[i][r][0] *= bpow(2, MOD - 1, MOD);\n\t\t\t\tdp[i][l][0] *= bpow(2, MOD - 1, MOD);\n\n\t\t\t\tdp[i][l][1] *= bpow(2, MOD - 1, MOD);\n\t\t\t\tdp[i][r][1] *= bpow(2, MOD - 1, MOD);\n\n\t\t\t\tdp[i][r][0] %= MOD;\n\t\t\t\tdp[i][l][0] %= MOD;\n\n\t\t\t\tdp[i][l][1] %= MOD;\n\t\t\t\tdp[i][r][1] %= MOD;\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tdp[r][i][0] *= bpow(2, MOD - 1, MOD);\n\t\t\t\tdp[l][i][0] *= bpow(2, MOD - 1, MOD);\n\n\t\t\t\tdp[l][i][1] *= bpow(2, MOD - 1, MOD);\n\t\t\t\tdp[r][i][1] *= bpow(2, MOD - 1, MOD);\n\n\t\t\t\tdp[r][i][0] %= MOD;\n\t\t\t\tdp[l][i][0] %= MOD;\n\n\t\t\t\tdp[l][i][1] %= MOD;\n\t\t\t\tdp[r][i][1] %= MOD;\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tdp[i][r][1] *= bpow(2, MOD - 1, MOD);\n\t\t\t\tdp[i][r][0] *= bpow(2, MOD - 1, MOD);\n\n\t\t\t\tdp[l][i][0] *= bpow(2, MOD - 1, MOD);\n\t\t\t\tdp[l][i][1] *= bpow(2, MOD - 1, MOD);\n\n\t\t\t\tdp[i][r][1] %= MOD;\n\t\t\t\tdp[i][r][0] %= MOD;\n\n\t\t\t\tdp[l][i][0] %= MOD;\n\t\t\t\tdp[l][i][1] %= MOD;\n\t\t\t}\n\t\t}\n\n\t\tcurPw %= MOD;\n\t}\n\n\tll ans = 0, pw = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tans += dp[i][j][0] * curPw;\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nint a[3000];\nint b[3001];\nint last[3000][3000];\nlong long dp[3000][3000];\n\nint main() {\n    int n, q, i, j;\n    long long ans = 0;\n    \n    scanf(\"%d %d\", &n, &q);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    b[0] = 1;\n    for (i = 0; i < q; i++) b[i + 1] = b[i] * 2 % mod;\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            if (a[i] > a[j]) dp[i][j] = 1;\n        }\n    }\n    \n    for (i = 0; i < q; i++) {\n        int x, y;\n        \n        scanf(\"%d %d\", &x, &y);\n        \n        x--;\n        y--;\n        \n        for (j = 0; j < n; j++) {\n            if (j == x || j == y) continue;\n            \n            dp[j][x] = dp[j][x] * b[i - last[j][x]] % mod;\n            dp[j][y] = dp[j][y] * b[i - last[j][y]] % mod;\n            \n            last[j][x] = last[j][y] = i + 1;\n            dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) % mod;\n        }\n        \n        for (j = 0; j < n; j++) {\n            if (j == x || j == y) continue;\n            \n            dp[x][j] = dp[x][j] * b[i - last[x][j]] % mod;\n            dp[y][j] = dp[y][j] * b[i - last[y][j]] % mod;\n            \n            last[x][j] = last[y][j] = i + 1;\n            dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) % mod;\n        }\n        \n        dp[x][y] = dp[x][y] * b[i - last[x][y]] % mod;\n        dp[y][x] = dp[y][x] * b[i - last[y][x]] % mod;\n        \n        last[x][y] = last[y][x] = i + 1;\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) % mod;\n    }\n    \n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            dp[i][j] = dp[i][j] * b[q - last[i][j]] % mod;\n            ans += dp[i][j];\n        }\n    }\n    \n    printf(\"%lld\\n\", ans % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <utility>\nusing ll = long long;\nconst ll ha = 1000000007LL;\nconst ll inv_2 = (ha >> 1) + 1LL;\nconst int maxn = 3005;\nll f[maxn][maxn];\nint A[maxn];\n\nint main() {\n  int n, Q; scanf(\"%d%d\", &n, &Q);\n  for(int i = 1; i <= n; i ++) scanf(\"%d\", &A[i]);\n  for(int i = 1; i <= n; i ++) {\n    for(int j = 1; j <= n; j ++) {\n      if(A[i] < A[j]) f[i][j] = 1;\n    }\n  }\n  for(int p = 0; p < Q; p ++) {\n    int x, y; scanf(\"%d%d\", &x, &y);\n    f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv_2 % ha;\n    for(int j = 1; j <= n; j ++) {\n      if(j != x && j != y) {\n        f[j][y] = f[j][x] = (f[j][y] + f[j][x]) * inv_2 % ha;\n        f[y][j] = f[x][j] = (f[x][j] + f[y][j]) * inv_2 % ha;\n      }\n    }\n  }\n  ll ans = 0;\n  for(int i = 1; i <= n; i ++) {\n    for(int j = 1; j < i; j ++) {\n      ans = (ans + f[i][j]) % ha;\n    }\n  }\n  for(int p = 0; p < Q; p ++) ans = (ans << 1) % ha;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define CO const\n#define IN inline\ntypedef long long int64;\n\ntemplate<class T> IN T read(){\n\tT x=0,w=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar())if(c=='-') w=-w;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*w;\n}\ntemplate<class T> IN T read(T&x){\n\treturn x=read<T>();\n}\n\nCO int P=1e9+7,i2=(P+1)/2;\nIN int add(int a,int b){\n\treturn (a+=b)>=P?a-P:a;\n}\nIN int mul(int a,int b){\n\treturn (int64)a*b%P;\n}\nIN int fpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=mul(a,a))\n\t\tif(b&1) ans=mul(ans,a);\n\treturn ans;\n}\n\nCO int N=3e3+10;\nint A[N],F[N][N];\n\nint main(){\n\tint n=read<int>(),m=read<int>();\n\tfor(int i=1;i<=n;++i) read(A[i]);\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)\n\t\tF[i][j]=A[i]>A[j];\n\tfor(int i=1;i<=m;++i){\n\t\tint x=read<int>(),y=read<int>();\n\t\tF[x][y]=F[y][x]=mul(add(F[x][y],F[y][x]),i2);\n\t\tfor(int j=1;j<=n;++j)if(j!=x and j!=y){\n\t\t\tF[x][j]=F[y][j]=mul(add(F[x][j],F[y][j]),i2);\n\t\t\tF[j][x]=F[j][y]=mul(add(F[j][x],F[j][y]),i2);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)for(int j=i+1;j<=n;++j)\n\t\tans=add(ans,F[i][j]);\n\tans=mul(ans,fpow(2,m));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define p 1000000007\n#define inv2 500000004\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,ans;\nint f[3010][3010],g[3010][3010],a[3010];\nint main(){\n\tn=r;m=r;\n\tfor(rt i=1;i<=n;i++)a[i]=r;\n\tfor(rt i=1;i<=n;i++)\n\tfor(rt j=1;j<=n;j++)if(a[i]>a[j])f[i][j]=1;\n\tfor(rt i=1;i<=m;i++){\n\t\tx=r;y=r;\n\t\tfor(rt j=1;j<=n;j++)g[x][j]=f[x][j],g[j][x]=f[j][x],g[y][j]=f[y][j],g[j][y]=f[j][y];\n\t\tf[x][y]=f[y][x]=1ll*(g[x][y]+g[y][x])*inv2%p;\n\t\tfor(rt j=1;j<=n;j++){\n\t\t\tconst int v1=1ll*(g[x][j]+g[y][j])*inv2%p,v2=1ll*(g[j][x]+g[j][y])*inv2%p;\n\t\t\tif(j!=y&&j!=x)f[x][j]=v1,f[j][x]=v2;\n\t\t\tif(j!=x&&j!=y)f[y][j]=v1,f[j][y]=v2;\n\t\t}\t\n\t}\n\n\tint ans=0;\n\tfor(rt i=1;i<n;i++)\n\tfor(rt j=i+1;j<=n;j++)(ans+=f[i][j])%=p;\n\tfor(rt i=1;i<=m;i++)ans=ans*2%p;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nll dp[3005][3005];\n\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tint n,q;\n\tvector<int>num;\n\tcin >> n >> q;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; cin >> x;\n\t\tnum.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(num[i]>num[j]) dp[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--; b--;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t    if(j == a || j == b) continue;\n\t\t\tdp[j][a]=dp[j][b]=(dp[j][a]+dp[j][b])%mod*modpow(2LL,mod-2)%mod;\n\t\t\tdp[a][j]=dp[b][j]=(dp[a][j]+dp[b][j])%mod*modpow(2LL,mod-2)%mod;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=(dp[a][b]+dp[b][a])%mod*modpow(2LL,mod-2);;\n\t\tdp[a][a]=dp[b][b]=0;\n\t}\n\tll ret = 0;\n\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) ret+=dp[i][j];\n\tret %= mod;\n\tret = ret*modpow(2LL,q)%mod;\n\tcout<<(ret+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 3010, P = 1000000007;\n\nint a[N];\nint p[N][N][2];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, q;\n  cin >> n >> q;\n  for (int i = 1; i <= n; ++i)\n    cin >> a[i];\n  for (int i = 1; i < n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      if (a[i] > a[j])\n        p[i][j][1] = 1;\n      else if (a[i] < a[j])\n        p[i][j][0] = 1;\n  int pr = (P + 1) >> 1;\n  int rep = q;\n  while (rep--) {\n    int x, y;\n    cin >> x >> y;\n    if (x > y) swap(x, y);\n    for (int i = 1; i <= n; ++i)\n      if (i < x) {\n        for (int j = 0; j < 2; ++j) {\n          int a = (p[i][x][j] + p[i][y][j]) * (ll)pr % P;\n          p[i][x][j] = p[i][y][j] = a;\n        }\n      } else if (x < i && i < y) {\n        for (int j = 0; j < 2; ++j) {\n          int a = (p[x][i][j] + p[i][y][!j]) * (ll)pr % P;\n          p[x][i][j] = p[i][y][!j] = a;\n        }\n      } else if (y < i) {\n        for (int j = 0; j < 2; ++j) {\n          int a = (p[x][i][j] + p[y][i][j]) * (ll)pr % P;\n          p[x][i][j] = p[y][i][j] = a;\n        }\n      }\n    int a = (p[x][y][0] + p[x][y][1]) * (ll)pr % P;\n    p[x][y][0] = p[x][y][1] = a;\n  }\n  int ans = 0;\n  for (int i = 1; i < n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      ans = (ans + p[i][j][1]) % P;\n  while (q--)\n    ans = ans * 2 % P;\n  cout << ans << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int N = 3e3 + 5, mod = 1e9 + 7, inv2 = (mod + 1) / 2;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nLL ans, f[N][N];\nint n, m, a[N];\nLL ksm(LL x, LL y) {\n\tLL res = 1;\n\tfor( ; y; x = x * x % mod, y >>= 1) {\n\t\tif(y & 1) res = res * x % mod;\n\t}\n\treturn res;\n}\nint main() {\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; ++ i) a[i] = read();\n\tfor(int i = 1; i <= n; ++ i) for(int j = 1; j <= n; ++ j) f[i][j] = a[i] < a[j];\n\tfor(int i = 1, x, y; i <= m; ++ i) {\n\t\tx = read(); y = read();\n\t\tf[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv2 % mod;\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tf[x][j] = f[y][j] = (f[x][j] + f[y][j]) * inv2 % mod;\n\t\t\tf[j][x] = f[j][y] = (f[j][x] + f[j][y]) * inv2 % mod;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) for(int j = 1; j < i; ++ j) ans = (ans + f[i][j]) % mod;\n\tprintf(\"%lld\\n\", ans * ksm(2, m) % mod);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int MOD = 1000 * 1000 * 1000 + 7, N = 3001;\nint dp[N][N], last[N][N], a[N], pw[N];\nint cur = 0;\ninline int get(int i, int j) {\n    dp[i][j] = (dp[i][j] * pw[cur - last[i][j] - 1]) % MOD;\n    last[i][j] = cur;\n    return dp[i][j];\n}   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    pw[0] = 1;\n    for (int i = 1; i < N; ++i) pw[i] = (pw[i - 1] << 1) % MOD;\n    int n, q; cin >> n >> q;\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) last[i][j] = -1;\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) dp[i][j] = a[i] < a[j];\n    while (q--) {\n        int i, j; cin >> i >> j; --i; --j;        \n        dp[i][j] = dp[j][i] = (get(i, j) + get(j, i)) % MOD;\n        for (int k = 0; k < n; ++k) {\n            if (k != i && k != j) {\n                dp[i][k] = dp[j][k] = (get(i, k) + get(j, k)) % MOD;\n                dp[k][i] = dp[k][j] = (get(k, i) + get(k, j)) % MOD;\n            }   \n        }   \n        ++cur;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) for (int j = 0; j < i; ++j) ans = (ans + get(i, j)) % MOD;\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(ll i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst ll N=3007;\nconst ll mod=1e9+7;\nll Pow(ll x,ll y){\n\tll ans=1,now=x;\n\twhile(y){\n\t\tif(y&1)ans=ans*now%mod;\n\t\tnow=now*now%mod;\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\nll f[N][N],a[N];\nll n,Q,i2;\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&Q);\n\trep(i,n)scanf(\"%lld\",&a[i]);\n\trep(i,n)rep(j,n)if(a[i]>a[j])f[i][j]=1;\n\ti2=Pow(2,mod-2);\n\trep(i,Q){\n\t\tll x,y; scanf(\"%lld%lld\",&x,&y);\n\t\trep(j,n){\n\t\t\tif(j==x||j==y)continue;\n\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])*i2%mod;\n\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])*i2%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*i2%mod;\n\t}\n\tll ans=0;\n\trep(i,n)REP(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",ans*Pow(2,Q)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#define P 1000000007\n#define N 3200\nusing namespace std;\nlong long f[N][N];\nlong long inv2;\nint n,q,a[N];\nlong long power(long long x,int k){\n\tlong long ans=1;\n\twhile(k){\n\t\tif(k&1)(ans*=x)%=P;\n\t\t(x*=x)%=P;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tinv2=power(2,P-2);\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tif(a[i]==a[j])continue;\n\t\t\tif(a[i]<a[j])f[i][j]++;\n\t\t\tif(a[j]<a[i])f[j][i]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==y)continue;\n\t\tlong long tmp=(f[x][y]+f[y][x])*inv2%P;\n\t\tf[x][y]=tmp;\n\t\tf[y][x]=tmp;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x||i==y)continue;\n\t\t\tlong long tmp=(f[x][i]+f[y][i])*inv2%P;\n\t\t\tf[x][i]=tmp;\n\t\t\tf[y][i]=tmp;\n\t\t\ttmp=(f[i][x]+f[i][y])*inv2%P;\n\t\t\tf[i][x]=tmp;\n\t\t\tf[i][y]=tmp;\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)(ans+=f[i][j])%=P;\n\tprintf(\"%lld\\n\",ans*power(2,q)%P);\n} "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef long long int ll;\n#define int long long int\n#define pb push_back\n#define fi first\n#define se second\n#define deb cerr << \"Line no.\" << __LINE__\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define aint(x) x.begin(), x.end()\n#define IO ios :: sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\nconst int mod = 1e9 + 7;\nconst int mod1 = 998244353;\ntypedef double f80;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\ntemplate<typename T>\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rand(int l, int r){\n\tuniform_int_distribution<int> uid(l, r);\n\treturn uid(rng);\n}\nint pwr(int a,int b){\n\tint ans = 1;\n\twhile(b){\n\t\tif(b & 1) ans = (ans * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nconst int N = 3005;\nint dp[N][N], pre[N][N];\nint a[N];\nint iv2 = pwr(2, mod - 2);\nmap<int,int> m;\nvoid solve(){\n\tint n, q;\n\tcin >> n >> q;\n\tfr(i, 1, n){\n\t\tcin >> a[i];\n\t\tm[a[i]] = 0;\n\t}\n\tint cc = 0;\n\tfor(auto &it : m){\n\t\tit.se = ++cc;\n\t}\n\tfr(i, 1, n){\n\t\ta[i] = m[a[i]];\n\t}\n\tfr(i, 1, n){\n\t\tfr(j, 1, n){\n\t\t\tif(a[i] > a[j])\n\t\t\t\tdp[i][j] = 1;\n\t\t}\n\t}\n\t// fr(i, 1, n){\n\t// \tfr(j, 1, n){\n\t// \t\tcout << dp[i][j] << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n\tfr(i, 1, q){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint lol = (dp[x][y] + dp[y][x]);\n\t\tdp[x][y] = dp[y][x] = (iv2 * lol) % mod;\n\t\tfr(k, 1, n){\n\t\t\tif(k == x || k == y) continue;\n\t\t\tint lol = (dp[x][k] + dp[y][k]);\n\t\t\tdp[x][k] = dp[y][k] = (iv2 * lol) % mod;\n\t\t\tlol = (dp[k][x] + dp[k][y]) % mod;\n\t\t\tdp[k][x] = dp[k][y] = (iv2 * lol) % mod;\n\t\t}\n\t\t// fr(i, 1, n){\n\t\t// \tfr(j, 1, n){\n\t\t// \t\tcout << dp[i][j] << \" \";\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t}\n\tint ans = 0;\n\tfr(i, 1, n){\n\t\tfr(j, i + 1, n){\n\t\t\tans += dp[i][j];\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << (ans * pwr(2, q)) % mod;\n}\nsigned main(){\n  \tIO;\n  \t#ifdef LOCAL\n\t\tfreopen(\"inp.txt\",\"r\", stdin);\n\t\t// freopen(\"out.txt\", \"w\", stdout);\n\t#endif\n\tclock_t clk = clock();\n  \tint t = 1;\n  \t// cin >> t;\n  \tfr(tt, 1, t){\n    \tsolve();\n  \t}\n  \tcerr << endl << (double)(clock() - clk) / CLOCKS_PER_SEC;\n  \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007, inv2 = (P + 1) / 2;\n\nint N, Q, A[3005], p1[3005][3005], p2[3005][3005];\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tp1[j][i] = A[j] < A[i];\n\t\t\tp2[j][i] = A[j] > A[i];\n\t\t}\n\t}\n\tint all = 1;\n\tfor (int x, y; Q--;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif (x > y) swap(x, y);\n\t\tfor (int i = 1; i < x; ++i) {\n\t\t\tp1[i][y] = p1[i][x] = 1ll * inv2 * (p1[i][x] + p1[i][y]) % P;\n\t\t\tp2[i][y] = p2[i][x] = 1ll * inv2 * (p2[i][x] + p2[i][y]) % P;\n\t\t}\n\t\tfor (int i = x + 1; i < y; ++i) {\n\t\t\tint tmp1 = p1[x][i], tmp2 = p1[i][y];\n\t\t\tp1[i][y] = 1ll * inv2 * (p1[i][y] + p2[x][i]) % P;\n\t\t\tp1[x][i] = 1ll * inv2 * (p1[x][i] + p2[i][y]) % P;\n\t\t\tp2[i][y] = 1ll * inv2 * (p2[i][y] + tmp1) % P;\n\t\t\tp2[x][i] = 1ll * inv2 * (p2[x][i] + tmp2) % P;\n\t\t}\n\t\tfor (int i = y + 1; i <= N; ++i) {\n\t\t\tp1[x][i] = p1[y][i] = 1ll * inv2 * (p1[x][i] + p1[y][i]) % P;\n\t\t\tp2[x][i] = p2[y][i] = 1ll * inv2 * (p2[x][i] + p2[y][i]) % P;\n\t\t}\n\t\tp1[x][y] = p2[x][y] = 1ll * inv2 * (p1[x][y] + p2[x][y]) % P;\n\t\tall = 2 * all % P;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = i + 1; j <= N; ++j)\n\t\t\tans = (ans + p2[i][j]) % P;\n\tans = 1ll * ans * all % P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5;\nint n, q;\nint a[N];\nconst int mod = (int)1e9 + 7;\nint f[3002][3002][3];\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= mod) {\n        x -= mod;\n    }\n}\nint s1[N][3];\nint s2[N][3];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> q;\n    vector<vector<int> > all;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (a[i] < a[j]) {\n                f[i][j][0] = 1;\n            } else if (a[i] > a[j]) {\n                f[i][j][1] = 1;\n            } else {\n                f[i][j][2] = 1;\n            }\n        }\n    }\n    int d2 = (mod + 1) / 2;\n    int mulp = 1;\n    for (int qr = 1; qr <= q; qr++) {\n        int x, y;\n        cin >> x >> y;\n        if (x > y) {\n            swap(x, y);\n        }\n        int q1 = f[x][y][0];\n        int q2 = f[x][y][1];\n        add(f[x][y][0], q2);\n        add(f[x][y][1], q1);\n        f[x][y][0] = 1ll * d2 * f[x][y][0] % mod;\n        f[x][y][1] = 1ll * d2 * f[x][y][1] % mod;\n        for (int j = 1; j <= n; j++) {\n            if (j < x) {\n                s1[j][0] = f[j][x][0] % mod;\n                s1[j][1] = f[j][x][1] % mod;\n                s2[j][2] = f[j][x][2] % mod;\n            } else {\n                s1[j][0] = f[x][j][0] % mod;\n                s1[j][1] = f[x][j][1] % mod;\n                s1[j][2] = f[x][j][2] % mod;\n            }\n            if (j < y) {\n                s2[j][0] = f[j][y][0] % mod;\n                s2[j][1] = f[j][y][1] % mod;\n                s2[j][2] = f[j][y][2] % mod;\n            } else {\n                s2[j][0] = f[y][j][0] % mod;\n                s2[j][1] = f[y][j][1] % mod;\n                s2[j][2] = f[y][j][2] % mod;\n            }\n        }\n        for (int j = 1; j <= n; j++) {\n            if (j != x && j != y) {\n               if (j < x) {\n                   add(f[j][y][0], s1[j][0]);\n                   add(f[j][y][1], s1[j][1]);\n                   add(f[j][y][2], s1[j][2]);\n\n                   add(f[j][x][0], s2[j][0]);\n                   add(f[j][x][1], s2[j][1]);\n                   add(f[j][x][2], s2[j][2]);\n               } else if (j > x && j < y) {\n                   add(f[j][y][0], s1[j][1]);\n                   add(f[j][y][1], s1[j][0]);\n                   add(f[j][y][2], s1[j][2]);\n\n                   add(f[x][j][0], s2[j][1]);\n                   add(f[x][j][1], s2[j][0]);\n                   add(f[x][j][2], s2[j][2]);\n               } else {\n                   add(f[y][j][0], s1[j][0]);\n                   add(f[y][j][1], s1[j][1]);\n                   add(f[y][j][2], s1[j][2]);\n\n                   add(f[x][j][0], s2[j][0]);\n                   add(f[x][j][1], s2[j][1]);\n                   add(f[x][j][2], s2[j][2]);\n               }\n               if (j < x) {\n                   for (int t = 0; t < 3; t++) {\n                       f[j][x][t] = 1ll * f[j][x][t] * d2 % mod;\n                       f[j][y][t] = 1ll * f[j][y][t] * d2 % mod;\n                   }\n               } else if (j > x && j < y) {\n                   for (int t = 0; t < 3; t++) {\n                       f[x][j][t] = 1ll * f[x][j][t] * d2 % mod;\n                       f[j][y][t] = 1ll * f[j][y][t] * d2 % mod;\n                   }\n               } else {\n                   for (int t = 0; t < 3; t++) {\n                       f[x][j][t] = 1ll * f[x][j][t] * d2 % mod;\n                       f[y][j][t] = 1ll * f[y][j][t] * d2 % mod;\n                   }\n               }\n            }\n        }\n        add(mulp, mulp);\n\n    }\n    int ans = 0;\n    for (int it = 1; it <= n; it++) {\n        for (int j = it + 1; j <= n; j++) {\n            int qq = 1ll * f[it][j][1] * mulp % mod;\n            add(ans, qq);\n        }\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ins insert\n#define F first\n#define S second\n#define var auto\nusing namespace std;\ntypedef long long ll;\nconst int Max = 5e3 + 50;\nconst int Mod = 1e9 + 7;\n\nint A[Max];\nint X[Max] , Y[Max];\n\nll cnt[Max];\nll inv[Max][Max];\nll nrm[Max][Max];\nll lstedit[Max][Max];\nll _2pw[Max];\nll pw(int b)\n{\n\treturn _2pw[b];\n}\n\nll getInv(int i , int j , int q)\n{\n\tif(i > j)\n\t\tswap(i , j);\n\treturn inv[i][j] * pw(q - lstedit[i][j] - 1) % Mod;\n}\n\nll getNrm(int i , int j , int q)\n{\n\tif(i > j)\n\t\tswap(i , j);\n\treturn nrm[i][j] * pw(q - lstedit[i][j] - 1) % Mod;\n}\n\n\n\nint main()\n{\n\tint n , q;cin >> n >> q;\n\t_2pw[0] = 1;\n\tfor(int i = 1; i <= q + 1;i++)\n\t\t_2pw[i] = _2pw[i - 1] * 2 % Mod;\n\n\tfor(int i = 1; i <= n ; i++)\n\t\tcin >> A[i];\n\n\tfor(int i = 1; i <= q ; i++)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tif(X[i] > Y[i])\n\t\t\tswap(X[i] , Y[i]);\n\t}\n\n\tfor(int i = 1; i <= q; i++)\n\t{\n\t\tfor(int j = X[i] + 1; j <= Y[i];j++)\n\t\t\tcnt[i] += (A[X[i]] > A[j]);\n\t\tfor(int j = Y[i] - 1; j >= X[i];j--)\n\t\t\tcnt[i] += (A[j] > A[Y[i]]);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n ; j++)\n\t\t\tif(A[i] > A[j])\n\t\t\t{\n\t\t\t\tinv[i][j]++;\n\t\t\t\tinv[j][i]++;\n\t\t\t}\n\t\t\telse if(A[i] < A[j])\n\t\t\t{\n\t\t\t\tnrm[i][j]++;\n\t\t\t\tnrm[j][i]++;\n\t\t\t}\n\n\tll _2k = 1;\n\tfor(int i = 1; i <= q; i++ , _2k = _2k * 2 % Mod)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(j == X[i] || j == Y[i])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tll invX = getInv(j , X[i] , i);\n\t\t\t\tll invY = getInv(j , Y[i] , i);\n\t\t\t\tll nrmX = getNrm(j , X[i] , i);\n\t\t\t\tll nrmY = getNrm(j , Y[i] , i);\n\t\t\t\t\n\t\t\t\tif(j < X[i] || j > Y[i])\n\t\t\t\t{\n\t\t\t\t\tinv[j][X[i]] = inv[X[i]][j] = inv[j][Y[i]] = inv[Y[i]][j] = (invX + invY) % Mod;\n\t\t\t\t\tnrm[j][X[i]] = nrm[X[i]][j] = nrm[j][Y[i]] = nrm[Y[i]][j] = (nrmX + nrmY) % Mod;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinv[j][X[i]] = inv[X[i]][j] = (invX + nrmY) % Mod;\n\t\t\t\t\tinv[j][Y[i]] = inv[Y[i]][j] = (invY + nrmX) % Mod;\n\t\t\t\t\tnrm[j][X[i]] = nrm[X[i]][j] = (nrmX + invY) % Mod;\n\t\t\t\t\tnrm[j][Y[i]] = nrm[Y[i]][j] = (nrmY + invX) % Mod;\n\t\t\t\t}\n\n\t\t\t\tlstedit[j][X[i]] = lstedit[X[i]][j] =\n\t\t\t\t   lstedit[j][Y[i]] = lstedit[Y[i]][j] = i;\n\t\t\t}\n\t\t}\n\n\t\tll invxy = getInv(X[i] , Y[i] , i);\n\t\tll nrmxy = getNrm(X[i] , Y[i] , i);\n\t\tinv[X[i]][Y[i]] = inv[Y[i]][X[i]] = (invxy + nrmxy) % Mod;\n\t\tnrm[X[i]][Y[i]] = nrm[Y[i]][X[i]] = (invxy + nrmxy) % Mod;\n\t\tlstedit[X[i]][Y[i]] = lstedit[Y[i]][X[i]] = i;\n\t}\n\n\t/*cout << \"\\n**\\n\";\n\tfor(int j = 1; j <= n ; j++)\n\t{\n\t\tfor(int k = 1; k <= n ; k++)\n\t\t\tcout << getReal(j , k , q + 1) << \" \";\n\t\tcout << '\\n';\n\t}*/\n\n\tll ANS = 0;\n\tfor(int i = 1; i <= n ; i++)\n\t{\n\t\tfor(int j = i + 1; j <= n ; j++)\n\t\t\tANS = (ANS + getInv(i,j, q + 1)) % Mod;\n\t}\n\tcout << '\\n' << ANS << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+5,mo=1e9+7,iv2=mo+1>>1;\nint n,q,a[N],x,y,f[N][N],i,j,ans,mi=1;\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)f[i][j]=a[i]>a[j];\n\tfor(;q--;){\n\t\tstatic int g1[N],g2[N],g3[N],g4[N];\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(i=1;i<=n;++i)g1[i]=f[i][x],g2[i]=f[x][i],g3[i]=f[i][y],g4[i]=f[y][i];\n\t\tj=1ll*iv2*(f[x][y]+f[y][x])%mo;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tf[i][x]=1ll*iv2*(f[i][x]+g3[i])%mo;\n\t\t\tf[x][i]=1ll*iv2*(f[x][i]+g4[i])%mo;\n\t\t\tf[i][y]=1ll*iv2*(f[i][y]+g1[i])%mo;\n\t\t\tf[y][i]=1ll*iv2*(f[y][i]+g2[i])%mo;\n\t\t}\n\t\tf[y][x]=f[x][y]=j;mi=mi*2%mo;f[x][x]=f[y][y]=0;\n\t}\n\tfor(i=1;i<n;++i)for(j=i+1;j<=n;++j)ans=(ans+f[i][j])%mo;\n\tans=1ll*ans*mi%mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7, INV = MOD + 1 >> 1, N = 3333;\n\nint f[N][N], a[N], g[N], h[N], Q, n;\n\nint main(void) {\n  scanf(\"%d%d\", &n, &Q);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j < n; j++) {\n      if(a[j] < a[i]) {\n\tf[i][j] = 1;\n      }\n      if(a[j] > a[i]) {\n\tf[j][i] = 1;\n      }\n    }\n  }\n  long long coef = 1;\n  while(Q--) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    for(int i = 1; i <= n; i++) {\n      g[i] = 1LL * (f[x][i] + f[y][i]) * INV % MOD;\n      h[i] = 1LL * (f[i][y] + f[i][x]) * INV % MOD;\n    }\n    for(int i = 1; i <= n; i++) {\n      if(i == x || i == y) {\n\tcontinue;\n      }\n      f[x][i] = f[y][i] = g[i];\n      f[i][y] = f[i][x] = h[i];\n    }\n    f[x][y] = f[y][x] = 1LL * (f[x][y] + f[y][x]) * INV % MOD;\n    coef = coef * 2 % MOD;\n  }\n  int ans = 0;\n  for(int i = 1; i < n; i++) {\n    for(int j = i + 1; j <= n; j++) {\n      ans = (ans + f[i][j]) % MOD;\n    }\n  }\n  \n  cout << ans * coef % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 3005\n#define inv 500000004\n#define mod 1000000007\n\nusing namespace std;\n\nint n,q,a[maxn];\nint dp[maxn][maxn];\n\n\nsigned main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++)\tcin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j])\tdp[i][j]=1;\n\tfor(int i=1,x,y;i<=q;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tdp[x][y]=dp[y][x]=inv*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x || j==y)\tcontinue;\n\t\t\tdp[x][j]=dp[y][j]=(inv*dp[x][j]+inv*dp[y][j])%mod;\n\t\t\tdp[j][x]=dp[j][y]=(inv*dp[j][x]+inv*dp[j][y])%mod;\n\t\t}\n\t}\n\tint now=1,ans=0;\n\tfor(int i=1;i<=q;i++)\n\t\t(now*=2)%=mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\t(ans+=dp[i][j])%=mod;\n\tcout<<ans*now%mod<<endl;\n\t\t\t\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 3005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod p[MAX_N][MAX_N];\nint a[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    rep(i,n){\n        cin >> a[i];\n    }\n    mod inv2 = (mod)1 / (mod)2;\n    rep(i,n){\n        rep(j,n){\n            if(a[i] > a[j]) p[i][j] = 1;\n            else p[i][j] = 0;\n        }\n    }\n    mod two = 1;\n    rep(i,q){\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        if(x > y) swap(x, y);\n        p[x][y] = p[y][x] = (p[x][y] + p[y][x]) * inv2;\n        rep(k,n){\n            if(k == x || k == y) continue;\n            if(k < x){\n                p[k][x] = p[k][y] = (p[k][x] + p[k][y]) * inv2;\n                p[x][k] = p[y][k] = (p[x][k] + p[y][k]) * inv2;\n            }else if(k < y){\n                mod s = p[x][k], t = p[k][y];\n                p[x][k] = (p[x][k] + p[y][k]) * inv2;\n                p[k][y] = (p[k][x] + p[k][y]) * inv2;\n                p[k][x] = (p[k][x] + t) * inv2;\n                p[y][k] = (s + p[y][k]) * inv2;\n            }else{\n                p[x][k] = p[y][k] = (p[x][k] + p[y][k]) * inv2;\n                p[k][x] = p[k][y] = (p[k][x] + p[k][y]) * inv2;\n            }\n        }\n        two *= 2;\n    }\n    mod ans = 0;\n    rep(i,n){\n        srep(j,i+1,n){\n            ans += two * p[i][j];\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass ModInt {\n    using ll = long long;\n\npublic:\n    int value;\n    static int MOD;\n\n    ModInt(ll value = 0) {\n        this->value = value % MOD;\n        if (this->value < 0) this->value += MOD;\n    }\n\n    operator int() const noexcept { return this->value; }\n\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->value = x.value; }\n        return *this;\n    }\n\n    bool operator==(const ModInt& x) const { return this->value == x.value; }\n    bool operator!=(const ModInt& x) const { return !(*this == x); }\n\n    ModInt operator+() const { return value; }\n    ModInt operator-() const { return MOD - value; }\n    ModInt operator~() const { return (*this) ^ ModInt(MOD - 2); }\n\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    ModInt operator+=(const ModInt& x) {\n        int sum = this->value + x.value;\n        return *this = (sum < MOD ? sum : sum - MOD);\n    }\n    ModInt operator-=(const ModInt& x) {\n        int diff = this->value - x.value;\n        return *this = (diff >= 0 ? diff : diff + MOD);\n    }\n    ModInt operator*=(const ModInt& x) { return *this = ll(this->value) * ll(x.value) % MOD; }\n    ModInt operator/=(const ModInt& x) { return *this = (this->value % x.value == 0 ? ModInt(this->value / x.value) : *this * ~x); }\n\n    ModInt operator+=(const int& x) {\n        int sum = this->value + x;\n        return *this = (sum < MOD ? sum : sum - MOD);\n    }\n    ModInt operator-=(const int& x) {\n        int diff = this->value - x;\n        return *this = (diff >= 0 ? diff : diff + MOD);\n    }\n    ModInt operator*=(const int& x) { return *this = ll(this->value) * ll(x) % MOD; }\n    ModInt operator/=(const int& x) { return *this = (this->value % x == 0 ? ModInt(this->value / x) : *this * ~ModInt(x)); }\n\n    template <class T>\n    ModInt operator^=(const T& x) {\n        int n = int(x);\n        if (n == 0) return ModInt(1);\n        if (n & 1) {\n            return (*this) = ((*this) ^ ModInt(n - 1)) * (*this);\n        } else {\n            return (*this) = ((*this) * (*this)) ^ ModInt(n / 2);\n        }\n    }\n\n    template <class T>\n    ModInt operator+(const T& b) const { return ModInt(*this) += b; }\n    template <class T>\n    ModInt operator-(const T& b) const { return ModInt(*this) -= b; }\n    template <class T>\n    ModInt operator*(const T& b) const { return ModInt(*this) *= b; }\n    template <class T>\n    ModInt operator/(const T& b) const { return ModInt(*this) /= b; }\n    template <class T>\n    ModInt operator^(const T& b) const { return ModInt(*this) ^= b; }\n};\n\nint ModInt::MOD = 1000000007;\n\nostream& operator<<(ostream& os, const ModInt& x) { return os << x.value; }\nistream& operator>>(istream& is, ModInt& x) { return is >> x.value; }\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nconst ModInt inv2 = ~ModInt(2);\n\ninline ModInt div2(ModInt n) {\n    return (n.value & 1 ? n * inv2 : ModInt(n.value / 2));\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    auto A = Vec<int>(N, 0);\n    for (int& a : A) cin >> a;\n\n    auto dp = Vec<ModInt>(N, N, ModInt(0));\n    // i番目がj番目より大きい確率\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = (A[i] > A[j] ? 1 : 0);\n        }\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        for (int k = 0; k < N; ++k) {\n            if (k == x || k == y) continue;\n            dp[k][x] = div2(dp[k][x] + dp[k][y]);\n            dp[k][y] = dp[k][x];\n\n            dp[x][k] = div2(dp[x][k] + dp[y][k]);\n            dp[y][k] = dp[x][k];\n        }\n\n        dp[x][y] = div2(dp[x][y] + dp[y][x]);\n        dp[y][x] = dp[x][y];\n    }\n\n    ModInt ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << ans * (ModInt(2) ^ Q) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ni 500000004\n#define N 3010\n#define mo 1000000007\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nll n,a[N],dp[N][N],q,x,y,ansn;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(q);\n\tfor (int i=1;i<=n;i++) read(a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)dp[i][j]=(a[i]>a[j]);\n\tfor (int i=1;i<=q;i++){\n\t\tread(x);read(y);\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*ni%mo;\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j!=x&&j!=y)dp[j][x]=dp[j][y]=(dp[j][x]+dp[j][y])*ni%mo,dp[x][j]=dp[y][j]=(dp[x][j]+dp[y][j])*ni%mo;\n\t}\n\tll z=po(2,q);\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)ansn=(ansn+dp[i][j]*z)%mo;\n\tcout<<ansn<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n*/ \n//计数->期望/概率->独立 \n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int inv_2=5e8+4;\nconst int N=3005;\nint dp[N][N],a[N],x,y,ans,n,q;\nvoid up(int &x,int y){x=x-mod+y;x=(x<0)?x+mod:x;}\nint ksm(int x,int y)\n{\n\tint res=1;\n\twhile (y)\n\t{\n\t\tif (y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}\n\treturn res;\n}\nvoid SWAP(int x,int y)\n{\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i==x||i==y)\n\t\t{\n\t\t\tdp[x][y]=dp[y][x]=(ll)(dp[x][y]+dp[y][x])*inv_2%mod;\n\t\t}else{\n\t\t\tdp[i][x]=dp[i][y]=(ll)(dp[i][x]+dp[i][y])*inv_2%mod;\n\t\t\tdp[x][i]=dp[y][i]=(ll)(dp[x][i]+dp[y][i])*inv_2%mod;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t  for (int j=1;j<=n;j++) dp[i][j]=a[i]>a[j];\n\tfor (int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\t\tSWAP(x,y);\n\t}\t\n\tint t=ksm(2,q);\n\tfor (int i=1;i<=n;i++)\n\t  for (int j=i+1;j<=n;j++) up(ans,(ll)dp[i][j]*t%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int _=3e3+20,yl=1e9+7;\nll f[_][_],a[_],g[_],h[_],n,q,p;\nll POW(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)res=res*x%yl;\n\t\tx=x*x%yl;y>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>q;p=POW(2,yl-2);\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tfor(int j=0;j<i;++j){\n\t\t\tif(a[j]<a[i])f[i][j]=1;\n\t\t\tif(a[j]>a[i])f[j][i]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tg[i]=(f[x][i]+f[y][i])*p%yl;\n\t\t\th[i]=(f[i][x]+f[i][y])*p%yl;\n\t\t}\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=g[i];\n\t\t\tf[i][x]=f[i][y]=h[i];\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*p%yl;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tans+=f[i][j];\n\tans=ans%yl*POW(2,q)%yl;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=3e3+100,mod=1e9+7,inv2=(mod+1)>>1;\nint n,Q,a[N],f[N][N],fx[N],gx[N],Ans;\nvoid Inc(int &x,int y) {x+=y, x=x>=mod?x-mod:x;}\nint qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=(a[i]>a[j])?1:0;\n\tfor(int q=1;q<=Q;++q)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tif(x == y) continue;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfx[i]=1ll*inv2*(f[x][i]+f[y][i])%mod,\n\t\t\tgx[i]=1ll*inv2*(f[i][x]+f[i][y])%mod;\n\t\tfx[y]=1ll*inv2*(f[x][y]+f[y][x])%mod;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tf[x][i]=fx[i], f[i][x]=gx[i],\n\t\t\tf[y][i]=fx[i], f[i][y]=gx[i];\n\t\tf[x][y]=f[y][x]=fx[y], f[x][x]=f[y][y]=0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j) Inc(Ans,f[i][j]);\n\tAns=1ll*Ans*qpow(2,Q)%mod; printf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200005\n#define eps 1e-10\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nint N,Q,Inv2;\nint dp[3005][3005],f[3005][3005];\nint A[3005];\nvoid Solve() {\n\tInv2 = (MOD + 1) / 2;\n\tread(N);read(Q);\n\tfor(int i = 1 ; i <= N ; ++i) read(A[i]);\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfor(int j = 1 ; j <= N ; ++j) {\n\t\t\tif(A[i] > A[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\tint x,y;\n\tfor(int i = 1 ; i <= Q ; ++i) {\n\t\tread(x);read(y);\n\t\tfor(int j = 1 ; j <= N ; ++j) {\n\t\t\tf[x][j] = dp[x][j];\n\t\t\tf[j][x] = dp[j][x];\n\t\t\tf[j][y] = dp[j][y];\n\t\t\tf[y][j] = dp[y][j];\n\t\t}\n\t\tfor(int j = 1 ; j <= N ; ++j) {\n\t\t\tif(j != x && j != y)\n\t\t\tdp[x][j] = mul(Inv2,inc(f[x][j],f[y][j]));\n\t\t\tdp[j][x] = mul(Inv2,inc(f[j][x],f[j][y]));\n\t\t\tdp[y][j] = mul(Inv2,inc(f[y][j],f[x][j]));\n\t\t\tdp[j][y] = mul(Inv2,inc(f[j][y],f[j][x]));\n\t\t}\n\t\tdp[x][y] = mul(Inv2,inc(f[x][y],f[y][x]));\n\t\tdp[y][x] = mul(Inv2,inc(f[y][x],f[x][y]));\n\t}\n\tint ans = 0;\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t\tfor(int j = i + 1 ; j <= N ; ++j) {\n\t\t\tans = inc(ans,dp[i][j]);\n\t\t}\n\t}\n\tans = mul(ans,fpow(2,Q));\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3001;\nconst int mod = 1e9 + 7;\nint power(int a, int b){\n    int res = 1;\n    while(b > 0){\n        if(b % 2){\n            res = 1LL * res * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        b /= 2;\n    }\n    return res;\n}\nint dp[N][N], ndp[N][N];\nint main(){\n    int n, q, x, y, inv2 = power(2, mod - 2), ans = 0, a[N];\n    scanf(\"%d %d\", &n, &q);\n    for(int i = 1; i <= n; i++){\n        scanf(\"%d\", &a[i]);\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= n; j++){\n            dp[i][j] = (a[i] > a[j]);\n        }\n    }\n    for(int i = 1; i <= q; i++){\n        scanf(\"%d %d\", &x, &y);\n        for(int j = 1; j <= n; j++){\n            ndp[x][j] = (1LL * dp[y][j] * inv2 % mod + 1LL * inv2 * dp[x][j] % mod) % mod;\n            ndp[j][x] = (1LL * dp[j][x] * inv2 % mod + 1LL * inv2 * dp[j][y] % mod) % mod;\n        }\n        for(int j = 1; j <= n; j++){\n            ndp[y][j] = (1LL * dp[x][j] * inv2 % mod + 1LL * inv2 * dp[y][j] % mod) % mod;\n            ndp[j][y] = (1LL * dp[j][y] * inv2 % mod + 1LL * inv2 * dp[j][x] % mod) % mod;\n        }\n        ndp[x][x] = ndp[y][y] = 0;\n        for(int j = 1; j <= n; j++){\n            if(j != x && j != y){\n                dp[x][j] = ndp[x][j];\n                dp[y][j] = ndp[y][j];\n                dp[j][x] = ndp[j][x];\n                dp[j][y] = ndp[j][y];\n            }\n        }\n        dp[x][y] = (1LL * dp[y][x] * inv2 % mod + 1LL * inv2 * dp[x][y] % mod) % mod;\n        dp[y][x] = dp[x][y];\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = i + 1; j <= n; j++){\n            ans += dp[i][j];\n            ans %= mod;\n        }\n    }\n    ans = 1LL * ans * power(2, q) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 3010;\n\nint N, Q;\nint A[MN], X[MN], Y[MN], prec[MN][MN], po[MN];\nvector<int> V[MN];\n\nvector<int> cc[MN][MN][2];\nint dp(int a, int b, int t, int x) {\n    int &ret = cc[a][b][t][x];\n    if(ret != -1) return ret;\n\n    int cur = t? V[a][x] : V[b][x];\n    if(cur == Q) return ret = a < b;\n\n    ret = 0;\n    int pa = prec[a][cur];\n    int pb = prec[b][cur];\n    int nxt = min(V[a][pa], V[b][pb]);\n\n    if(V[a][pa] < V[b][pb]) {\n        ret += 1LL * po[nxt - cur - 1] * dp(a, b, 1, pa) % mod;\n        ret %= mod;\n    }\n    else {\n        ret += 1LL * po[nxt - cur - 1] * dp(a, b, 0, pb) % mod;\n        ret %= mod;\n    }\n\n    int na = a == X[cur]? Y[cur] : (a == Y[cur]? X[cur] : a);\n    int nb = b == X[cur]? Y[cur] : (b == Y[cur]? X[cur] : b);\n    pa = prec[na][cur];\n    pb = prec[nb][cur];\n    nxt = min(V[na][pa], V[nb][pb]);\n\n    if(V[na][pa] < V[nb][pb]) {\n        ret += 1LL * po[nxt - cur - 1] * dp(na, nb, 1, pa) % mod;\n        ret %= mod;\n    }\n    else {\n        ret += 1LL * po[nxt - cur - 1] * dp(na, nb, 0, pb) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    scanf(\"%d %d\", &N, &Q);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n\n        V[ X[i] ].push_back(i);\n        V[ Y[i] ].push_back(i);\n    }\n    for(int i = 0; i < N; i++) {\n        V[i].push_back(Q);\n    }\n\n    for(int i = 0; i < N; i++) {\n        int pos = 0;\n        for(int j = 0; j < Q; j++) {\n            if(pos < V[i].size() && V[i][pos] <= j) pos++;\n            prec[i][j] = pos;\n        }\n    }\n\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < 2; k++) {\n                cc[i][j][k] = vector<int>(max(V[i].size(), V[j].size()), -1);\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(A[j] < A[i]) {\n                if(V[i][0] < V[j][0]) {\n                    ans += 1LL * po[ V[i][0] ] * dp(i, j, 1, 0) % mod;\n                    ans %= mod;\n                }\n                else {\n                    ans += 1LL * po[ V[j][0] ] * dp(i, j, 0, 0) % mod;\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 3009, MOD = 1e9 + 7;\n\nll dp[SZ][SZ][2];\nll n, q;\nvector<ll> vec;\n\nint main() {\n\tfastInp;\n\n\tcin >> n >> q;\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur;\n\t\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\tif (vec[i] < vec[j]) {\n\t\t\t\tdp[i][j][1]++;\n\t\t\t}\n\t\t\telse if (vec[i] > vec[j]) {\n\t\t\t\tdp[i][j][0]++;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (l > r) swap(l, r);\n\t\tvector<tuple<ll, ll, ll, ll>> add;\n\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tadd.push_back({ i, r, 1, dp[i][l][1] });\n\t\t\t\tadd.push_back({ i, r, 0, dp[i][l][0] });\n\n\t\t\t\tadd.push_back({ i, l, 1, dp[i][r][1] });\n\t\t\t\tadd.push_back({ i, l, 0, dp[i][r][0] });\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tadd.push_back({ r, i, 1, dp[l][i][1] });\n\t\t\t\tadd.push_back({ r, i, 0, dp[l][i][0] });\n\n\t\t\t\tadd.push_back({ l, i, 1, dp[r][i][1] });\n\t\t\t\tadd.push_back({ l, i, 0, dp[r][i][0] });\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tadd.push_back({ i, r, 0, dp[l][i][1] });\n\t\t\t\tadd.push_back({ i, r, 1, dp[l][i][0] });\n\n\t\t\t\tadd.push_back({ l, i, 0, dp[i][r][1] });\n\t\t\t\tadd.push_back({ l, i, 1, dp[i][r][0] });\n\t\t\t}\n\t\t}\n\t\tll s = dp[l][r][1] + dp[l][r][0];\n\t\tdp[l][r][1] = s;\n\t\tdp[l][r][0] = s;\n\t\tif (dp[l][r][1] >= MOD) dp[l][r][1] -= MOD;\n\t\tif (dp[l][r][0] >= MOD) dp[l][r][0] -= MOD;\n\n\t\tfor (auto cur : add) {\n\t\t\tll l = get<0>(cur), r = get<1>(cur), fl = get<2>(cur), vl = get<3>(cur);\n\t\t\tif (l > r) {\n\t\t\t\tswap(l, r);\n\t\t\t\tfl = !fl;\n\t\t\t}\n\t\t\tdp[l][r][fl] += vl;\n\t\t\tif (dp[l][r][fl] >= MOD) dp[l][r][fl] -= MOD;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (i != l && i != r && j != l && j != r) {\n\t\t\t\t\tdp[i][j][0] *= 2;\n\t\t\t\t\tdp[i][j][1] *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0, pw = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tans += dp[i][j][0];\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#define MAX_N 105\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\n\n\nll mpow(ll x,ll n){\n    ll ret = 1;\n    while(n>0){\n        if((n&1)==1){\n            ret *= x;\n            ret %= mod;\n        }\n        x = (x*x)%mod;\n        n >>= 1;\n    }\n    return ret%mod;\n}\n\nll inv(ll x){\n    return mpow(x,mod-2);\n}\n\n\n\n\nint main(){\n    int N,Q;\n    ll A[MAX_N];\n    ll dp[2][MAX_N][MAX_N];\n    cin>>N>>Q;\n    for(int i = 0;i < N;i++){\n        cin >> A[i];\n    }\n    ll _2q = mpow(2,Q);\n    ll inv2 = inv(2);\n    for(int i = 0;i < N;i++){\n        for(int j = 0;j < N;j++){\n            if(A[i]>A[j]){dp[0][i][j]=dp[1][i][j]=1;}\n            else{dp[0][i][j]=dp[1][i][j]=0;}\n        }\n    }\n    for(int qqq = 0;qqq < Q;qqq++){\n        int x,y;cin>>x>>y;\n        x--,y--;\n        for(int i = 0;i < N;i++){\n            if(i!=x&&i!=y){\n                dp[1][x][i]=(dp[0][x][i]*inv2+dp[0][y][i]*inv2)%mod;\n                dp[1][i][x]=(dp[0][i][x]*inv2+dp[0][i][y]*inv2)%mod;\n                dp[1][y][i]=(dp[0][y][i]*inv2+dp[0][x][i]*inv2)%mod;\n                dp[1][i][y]=(dp[0][i][y]*inv2+dp[0][i][x]*inv2)%mod;\n            }\n        }\n        dp[1][x][y]=dp[1][y][x]=(dp[0][x][y]*inv2+dp[0][y][x]*inv2)%mod;\n        for(int i = 0;i < N;i++){\n            dp[0][i][x]=dp[1][i][x];\n            dp[0][i][y]=dp[1][i][y];\n            dp[0][x][i]=dp[1][x][i];\n            dp[0][y][i]=dp[1][y][i];\n        }\n        \n    }\n    ll ans = 0;\n\n    for(int i = 0;i < N;i++){\n        for(int j = i+1;j < N;j++){\n            ans += dp[0][i][j];\n            ans %= mod;\n//            cout<<(_2q*dp[0][i][j])%mod<<\" \";\n        }\n//        cout<<endl;\n    }\n    cout<<(ans*_2q)%mod<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\nconst ll MOD = 1e9 + 7;\n\nll power(ll x, ll e) {\n  ll v = 1;\n  for (; e > 0; e >>= 1) {\n    if (e & 1) {\n      v = v * x % MOD;\n    }\n    x = x * x % MOD;\n  }\n  return v;\n}\n\nll inverse(ll x) {\n  return power(x, MOD - 2);\n}\n\nusing P = tuple<int, int, ll>;\n\nint main() {\n#ifdef DEBUG\n  ifstream cin(\"in.txt\");\n#endif\n  int N, Q;\n  while (cin >> N >> Q) {\n    vector<ll> A(N);\n    for (ll& x : A) cin >> x;\n    vector<int> X(Q), Y(Q);\n    for (int i = 0; i < Q; i++) {\n      cin >> X[i] >> Y[i];\n      --X[i];\n      --Y[i];\n      if (X[i] > Y[i]) swap(X[i], Y[i]);\n    }\n    vec<ll, 2> dp = make_v(N, N, 0ll);\n    ll inv2 = inverse(2);\n    for (int q = Q - 1; q >= 0; q--) {\n      int x = X[q], y = Y[q];\n      // (x, *)\n      vector<P> ps;\n      for (int j = x + 1; j < N; j++) {\n        if (j == y) continue;\n        if (y < j) {\n          ps.emplace_back(x, j, (dp[x][j] + dp[y][j]) * inv2 % MOD);\n        } else {\n          ps.emplace_back(x, j, (dp[x][j] + (1 - dp[j][y] + MOD)) * inv2 % MOD);\n        }\n      }\n      // (*, y)\n      for (int i = 0; i < y; i++) {\n        if (i == x) continue;\n        if (i < x) {\n          ps.emplace_back(i, y, (dp[i][y] + dp[i][x]) * inv2 % MOD);\n        } else {\n          ps.emplace_back(i, y, (dp[i][y] + (1 - dp[x][i] + MOD)) * inv2 % MOD);\n        }\n      }\n      // (y, *)\n      for (int j = y + 1; j < N; j++) {\n        ps.emplace_back(y, j, (dp[y][j] + dp[x][j]) * inv2 % MOD);\n      }\n      // (*, x)\n      for (int i = 0; i < x; i++) {\n        ps.emplace_back(i, x, (dp[i][x] + dp[i][y]) * inv2 % MOD);\n      }\n      // (x, y)\n      ps.emplace_back(x, y, (dp[x][y] + (1 - dp[x][y] + MOD)) * inv2 % MOD);\n      for (auto& p : ps) {\n        int i, j;\n        ll v;\n        tie(i, j, v) = p;\n        dp[i][j] = v;\n      }\n    }\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n      for (int j = i + 1; j < N; j++) {\n        if (A[i] < A[j]) {\n          res += dp[i][j];\n          res %= MOD;\n        } else if (A[i] > A[j]) {\n          res += 1 - dp[i][j] + MOD;\n          res %= MOD;\n        }\n      }\n    }\n    res = res * power(2, Q) % MOD;\n    cout << res << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\n\nconst ll MOD = 1000000007;\nconst ll i2 = (MOD + 1) / 2;\nconst int MN = 3010;\n\nint N, Q;\nint A[MN];\nint X[MN], Y[MN];\nll p[MN][MN]; // <\n\nint main() {\n\tcin >> N >> Q;\n\trep(i, N) cin >> A[i];\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif (A[i] < A[j]) {\n\t\t\t\tp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, Q) {\n\t\tcin >> X[i] >> Y[i];\n\t\t--X[i]; --Y[i];\n\t}\n\n\trep(n, Q) {\n\t\tint a = X[n], b = Y[n];\n\n\t\tll t1 = (p[a][b] + p[b][a]) * i2 % MOD;\n\t\tp[a][b] = p[b][a] = t1;\n\n\t\trep(i, N) if (i != a && i != b) {\n\t\t\tll t = (p[i][a] + p[i][b]) * i2 % MOD;\n\t\t\tp[i][a] = p[i][b] = t;\n\t\t\tt = (p[a][i] + p[b][i]) * i2 % MOD;\n\t\t\tp[a][i] = p[b][i] = t;\n\t\t}\n\n\t}\n\n\tll ans = 0;\n\trep(i, N) {\n\t\trep(j, i) {\n\t\t\tans = (ans + p[i][j]) % MOD;\n\t\t}\n\t}\n\n\trep(i, Q) ans = ans * 2 % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 3007 , mo = 1000000007;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a)\n{\n\treturn powa(a,mo-2);\n}\n\nconst int inv2 = inva(2);\n\nint n,qn,val[_],px[_],py[_];\nlint gai[_][_];\n\nint main()\n{\n\tn=ty(),qn=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty();\n\tfor(int i=1;i<=qn;i++)px[i]=ty(),py[i]=ty();\n\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)gai[i][j]=val[i]<val[j];\n\tfor(int i=1;i<=qn;i++)\n\t{\n\t\tint a=px[i],b=py[i];\n\t\tgai[a][b]=gai[b][a]=(gai[a][b]+gai[b][a])%mo*inv2%mo;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(a==j || b==j)continue;\n\t\t\tgai[a][j]=gai[b][j]=(gai[a][j]+gai[b][j])%mo*inv2%mo;\n\t\t\tgai[j][a]=gai[j][b]=(gai[j][a]+gai[j][b])%mo*inv2%mo;\n\t\t}\n\t}\n\n\tlint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+gai[i][j])%mo;\n\tprintf(\"%lld\\n\",ans*powa(2,qn)%mo);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n//#pragma GCC target(\"avx,avx2\")\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n\n//# include <x86intrin.h>\n# include <bits/stdc++.h>\n\n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate<typename T> using ordered_set = tree <T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_bound\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid setIO(string s = \"\") {\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 3123;                                          \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n \nint rnd (int l, int r) {\n\treturn uniform_int_distribution<int> (l, r)(gen);\n}\n \nint n, m, k;\nint pw[N];\nint last[N][N];\nint dp[N][N];\nint was[N][N];\nint laz[N][N];\nint a[N];\n\nvector < pair<int, int> > sav;\n\n\nvoid add (int a, int b, int c) {\n\tlaz[a][b] += c;\n\tif(laz[a][b] >= mod) laz[a][b] -= mod;\n\tif(!was[a][b]) {\n\t\tsav.pb({a, b});\n\t\twas[a][b] = 1;\n\t}\n}\n\nint timer;\nvoid relax (int a, int b) {\n\tdp[a][b] = dp[a][b] * (ll)pw[timer-last[a][b]] % mod;\n\tlast[a][b] = timer;\n}\n\nvoid push () {\n\tfor (auto it : sav) {\n\t\tint i, j;\n\t\ttie(i, j) = it;\n\t\tdp[i][j] += laz[i][j];\n\t\tif (dp[i][j] >= mod) dp[i][j] -= mod;\n\t\twas[i][j] = laz[i][j] = 0;\n\t}\n\tsav.clear();\n}\n\nvoid upd(int x, int y) { \n\ttimer++;\n\tfor(int i = 1; i <= n; i++) {\n\t\tlast[i][x]++;\n\t\tlast[x][i]++;\n\t\tlast[i][y]++;\n\t\tlast[y][i]++;\n\t}\n\tlast[x][y] -= 1;\n\tlast[y][x] -= 1;\n}\n\nint main () {\n\tSpeedForce;\n\t\n\tcin >> n >> m;\n\tpw[0] = 1;\n\tfor (int i = 1; i < N; ++i)\n\t\tpw[i] = pw[i-1] * 2 % mod;\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) if (a[j] < a[i]) {\n\t\t\tadd(i, j, 1);\n\t\t}\n\n   \tpush();\n\n\n   \tfor (int i = 1; i <= m; ++i) {\n   \t\tint x, y;\n   \t\tcin >> x >> y;\n   \t\tfor (int j = 1; j <= n; ++j) {\n   \t\t\trelax(j, x);\n   \t\t\trelax(j, y);\n   \t\t\trelax(x, j);\n   \t\t\trelax(y, j);\n\n   \t\t\tif(j != y) {\n   \t\t\t\tadd(j, y, dp[j][x]);\n   \t\t\t\tadd(y, j, dp[x][j]);\n   \t\t\t}\n\n   \t\t\tif (j != x) {\n   \t\t\t\tadd (j, x, dp[j][y]);\n   \t\t\t\tadd (x, j, dp[y][j]);\n   \t\t\t}\n   \t\t}\n   \t\tadd(x, y, dp[y][x]);\n   \t\tadd(y, x, dp[x][y]);\n\n   \t\tpush();\n   \t\tupd (x, y);\n   \t}\n\n   \tint ans = 0;\n   \tfor (int i = 1; i <= n; ++i)\n   \t\tfor (int j = i+1; j <= n; ++j) {\n   \t\t\trelax(i, j);\n   \t\t\tans += dp[i][j];\n   \t\t\tif(ans >= mod) ans -= mod;\n   \t\t}\n\n\tcout << ans << '\\n';\n\n\treturn Accepted;\n}\n\n// B...a"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint n,dp[3001][3001],t[3001][3001],mi[3001],mo,xi,yi,sum,m,a[3001];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tmo=1000000007;\n\tmi[0]=1;\n\tfor(int i=1;i<=m;i++)mi[i]=(mi[i-1]*2)%mo;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)t[i][j]=dp[i][j]=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)if(j!=i)\n\t{\n\t\tif(a[i]>a[j])dp[i][j]=dp[i][j]+1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&xi,&yi);\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((j!=xi)&&(j!=yi))\n\t\t\t{\n\t\t\t\tdp[xi][j]=(1ll*dp[xi][j]*mi[i-t[xi][j]-1])%mo;\n\t\t\t\tdp[yi][j]=(1ll*dp[yi][j]*mi[i-t[yi][j]-1])%mo;\n\t\t\t\tsum=(dp[xi][j]+dp[yi][j])%mo;\n\t\t\t\tdp[xi][j]=dp[yi][j]=sum;\n\t\t\t\tt[xi][j]=t[yi][j]=i;\n\t\t\t\tdp[j][xi]=(1ll*dp[j][xi]*mi[i-t[j][xi]-1])%mo;\n\t\t\t\tdp[j][yi]=(1ll*dp[j][yi]*mi[i-t[j][yi]-1])%mo;\n\t\t\t\tsum=(dp[j][xi]+dp[j][yi])%mo;\n\t\t\t\tdp[j][xi]=dp[j][yi]=sum;\n\t\t\t\tt[j][xi]=t[j][yi]=i; \n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdp[xi][yi]=(1ll*dp[xi][yi]*mi[i-t[xi][yi]-1])%mo;\n\t\tdp[yi][xi]=(1ll*dp[yi][xi]*mi[i-t[yi][xi]-1])%mo;\n\t\tsum=(dp[yi][xi]+dp[xi][yi])%mo;\t\t\t\n\t\tdp[yi][xi]=dp[xi][yi]=sum;\n\t\tt[yi][xi]=t[xi][yi]=i; \n\t}\n\tsum=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++)sum=(sum+1ll*dp[i][j]*mi[m-t[i][j]])%mo;\n\tprintf(\"%d\\n\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 3005, mod = 1e9+7;\n\nint n, q, a[MX], x[MX], y[MX], cn[MX][MX], ult[MX][MX], pw[MX];\nll res = 0;\n\nvoid upd (int i, int act) {\n\tfor (int k = 0; k < n; k++) {\n\t\tcn[i][k] = ll(cn[i][k]) * pw[max(act-ult[i][k]-1,0)] % mod;\n\t\tult[i][k] = act;\n\n\t\tcn[k][i] = ll(cn[k][i]) * pw[max(act-ult[k][i]-1,0)] % mod;\n\t\tult[k][i] = act;\n\t}\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tpw[0] = 1;\n\tfor (int i = 1; i < MX; i++)\n\t\tpw[i] = 2 * pw[i-1] % mod;\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < q; i++)\n\t\tcin >> x[i] >> y[i];\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcn[i][j] = a[i] < a[j], ult[i][j] = -1;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tupd(--x[i], i);\n\t\tupd(--y[i], i);\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tif (k == x[i] || k == y[i]) continue;\n\n\t\t\tint d = cn[x[i]][k], e = cn[y[i]][k];\n\t\t\tcn[x[i]][k] = (cn[x[i]][k] + e) % mod;\n\t\t\tcn[y[i]][k] = (cn[y[i]][k] + d) % mod;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tif (k == x[i] || k == y[i]) continue;\n\t\t\t\n\t\t\tint d = cn[k][x[i]], e = cn[k][y[i]];\n\t\t\tcn[k][x[i]] = (cn[k][x[i]] + e) % mod;\n\t\t\tcn[k][y[i]] = (cn[k][y[i]] + d) % mod;\n\t\t}\n\n\t\tint d = cn[x[i]][y[i]], e = cn[y[i]][x[i]];\n\t\tcn[x[i]][y[i]] = (cn[x[i]][y[i]] + e) % mod;\n\t\tcn[y[i]][x[i]] = (cn[y[i]][x[i]] + d) % mod;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tupd(i, q);\n\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tres = (res + cn[i][j]) % mod;\n\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, Q, A[3009], X[3009], Y[3009], dp[3009][3009], mul = 1, inv = 500000004, mod = 1000000007;\nlong long nex[3009][3009];\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 1; i <= N; i++) cin >> A[i];\n\tfor (int i = 1; i <= Q; i++) { cin >> X[i] >> Y[i]; if (X[i] > Y[i]) swap(X[i], Y[i]); }\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (A[i] < A[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\t\n\t// 確率で DP\n\tfor (int i = 1; i <= Q; i++) {\n\t\tnex[X[i]][Y[i]] += (dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv; nex[X[i]][Y[i]] %= mod;\n\t\tnex[Y[i]][X[i]] += (dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv; nex[Y[i]][X[i]] %= mod;\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (j == X[i] || j == Y[i]) continue;\n\t\t\tnex[Y[i]][j] += (dp[Y[i]][j] + dp[X[i]][j]) * inv; nex[Y[i]][j] %= mod;\n\t\t\tnex[X[i]][j] += (dp[Y[i]][j] + dp[X[i]][j]) * inv; nex[X[i]][j] %= mod;\n\t\t\tnex[j][Y[i]] += (dp[j][Y[i]] + dp[j][X[i]]) * inv; nex[j][Y[i]] %= mod;\n\t\t\tnex[j][X[i]] += (dp[j][Y[i]] + dp[j][X[i]]) * inv; nex[j][X[i]] %= mod;\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tdp[j][X[i]] = nex[j][X[i]];\n\t\t\tdp[j][Y[i]] = nex[j][Y[i]];\n\t\t\tdp[X[i]][j] = nex[X[i]][j];\n\t\t\tdp[Y[i]][j] = nex[Y[i]][j];\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tnex[X[i]][j] = 0; nex[Y[i]][j] = 0; nex[j][X[i]] = 0; nex[j][Y[i]] = 0;\n\t\t}\n\t\tmul *= 2; mul %= mod;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (i > j) { ans += dp[i][j]; ans %= mod; }\n\t\t}\n\t}\n\tcout << (ans * mul) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ΔAGC030D\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 3333;\nconst int MO = 1e9+7;\nint mul(int x,int y){\n\treturn (LL)x*y%MO;\n}\nint n,q,a[N],f[N][N],g[N][N];\nint main()\n{\n\tint i,j,x,y,z=1,e=(MO+1)/2;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(i=1;i<=n;i=i+1)\n\t\tscanf(\"%d\",a+i);\n\tfor(i=1;i<=n;i=i+1)\n\t\tfor(j=1;j<=n;j=j+1)\n\t\t\tf[i][j]=a[i]>a[j];\n\twhile(q--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(i=1;i<=n;i=i+1){\n\t\t\tg[i][x]=f[i][x]+f[i][y];\n\t\t\tg[i][y]=f[i][y]+f[i][x];\n\t\t\tg[x][i]=f[x][i]+f[y][i];\n\t\t\tg[y][i]=f[y][i]+f[x][i];\n\t\t}\n\t\tg[x][y]=f[y][x]+f[x][y],g[y][x]=f[x][y]+f[y][x];\n\t\tfor(i=1;i<=n;i=i+1){\n\t\t\tf[i][x]=mul(g[i][x],e);\n\t\t\tf[i][y]=mul(g[i][y],e);\n\t\t\tf[x][i]=mul(g[x][i],e);\n\t\t\tf[y][i]=mul(g[y][i],e);\n\t\t}\n\t\tfor(i=1;i<=n;i=i+1){\n\t\t\tg[i][x]=0;\n\t\t\tg[i][y]=0;\n\t\t\tg[x][i]=0;\n\t\t\tg[y][i]=0;\n\t\t}\n\t\tz=z*2%MO;\n\t}\n\tx=0;\n\tfor(i=1;i<=n;i=i+1)\n\t\tfor(j=i+1;j<=n;j=j+1)\n\t\t\tx=(x+f[i][j])%MO;\n\tcout<<mul(x,z);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n//#pragma GCC target(\"avx,avx2\")\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n\n//# include <x86intrin.h>\n# include <bits/stdc++.h>\n\n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate<typename T> using ordered_set = tree <T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define lb lower_bound\n#define ub upper_bound\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid setIO(string s = \"\") {\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 3123;                                          \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n \nint rnd (int l, int r) {\n\treturn uniform_int_distribution<int> (l, r)(gen);\n}\n \nint n, m, k;\nint pw[N];\nint last[N][N];\nint dp[N][N];\nint was[N][N];\nint laz[N][N];\nint a[N];\n\nvector < pair<int, int> > sav;\n\n\nvoid add (int a, int b, int c) {\n\tlaz[a][b] += c;\n\tif(laz[a][b] >= mod) laz[a][b] -= mod;\n\tif(!was[a][b]) {\n\t\tsav.pb({a, b});\n\t\twas[a][b] = 1;\n\t}\n}\n\nint timer;\nvoid relax (int a, int b) {\n\tdp[a][b] = dp[a][b] * (ll)pw[timer-last[a][b]] % mod;\n\tlast[a][b] = timer;\n}\n\nvoid push () {\n\tfor (auto it : sav) {\n\t\tint i, j;\n\t\ttie(i, j) = it;\n\t\tdp[i][j] += laz[i][j];\n\t\tif (dp[i][j] >= mod) dp[i][j] -= mod;\n\t\twas[i][j] = laz[i][j] = 0;\n\t}\n\tsav.clear();\n}\n\nvoid upd(int x, int y) { \n\ttimer++;\n\tfor(int i = 1; i <= n; i++) {\n\t\tlast[i][x]++;\n\t\tlast[x][i]++;\n\t\tlast[i][y]++;\n\t\tlast[y][i]++;\n\t}\n\tlast[x][y] -= 1;\n\tlast[y][x] -= 1;\n}\n\nint main () {\n\tSpeedForce;\n\t\n\tcin >> n >> m;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t\tpw[i] = pw[i-1] * 2 % mod;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) if (a[j] < a[i]) {\n\t\t\tadd(i, j, 1);\n\t\t}\n\n   \tpush();\n\n\n   \tfor (int i = 1; i <= m; ++i) {\n   \t\tint x, y;\n   \t\tcin >> x >> y;\n   \t\tfor (int j = 1; j <= n; ++j) {\n   \t\t\trelax(j, x);\n   \t\t\trelax(j, y);\n   \t\t\trelax(x, j);\n   \t\t\trelax(y, j);\n\n   \t\t\tif(j != y) {\n   \t\t\t\tadd(j, y, dp[j][x]);\n   \t\t\t\tadd(y, j, dp[x][j]);\n   \t\t\t}\n\n   \t\t\tif (j != x) {\n   \t\t\t\tadd (j, x, dp[j][y]);\n   \t\t\t\tadd (x, j, dp[y][j]);\n   \t\t\t}\n   \t\t}\n   \t\tadd(x, y, dp[y][x]);\n   \t\tadd(y, x, dp[x][y]);\n\n   \t\tpush();\n   \t\tupd (x, y);\n   \t}\n\n   \tint ans = 0;\n   \tfor (int i = 1; i <= n; ++i)\n   \t\tfor (int j = i+1; j <= n; ++j) {\n   \t\t\trelax(i, j);\n   \t\t\tans += dp[i][j];\n   \t\t\tif(ans >= mod) ans -= mod;\n   \t\t}\n\tcout << ans << '\\n';\n\n\treturn Accepted;\n}\n\n// B...a"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x7fffffffffffffff;\nconst double eps=1e-10;\n\nuint seed=19260817;\nconst uint _RAND_MAX_=4294967295u;\nFinline uint Rand(){return seed=seed*998244353u+1000000007u;}\n\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline bool _cmp(const _Tp &a,const _Tp &b){return abs(a-b)<=eps;}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tregister char ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args)\n{\n\tread(t);read(args...);\n}\nFinline int read_str(char *s)\n{\n\tregister char ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tregister char *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=3005;\nconst int mod=1000000007;\nconst int inv2=500000004;\ntemplate<typename _Tp1,typename _Tp2>Finline void add(_Tp1 &a,_Tp2 b){(a+=b)>=mod&&(a-=mod);}\nint dp[N][N];\nint pos[N];\nint t1[N],t2[N],t3[N],t4[N];\nbool used1[N],used2[N],used3[N],used4[N];\nint a[N];\nint main()\n{\n\tint n,q;\n\tread(n,q);\n\tint x,y;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(a[i]<a[j])\n\t\t\t{\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint mul=1;\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tadd(mul,mul);\n\t\tread(x,y);\n\t\tmemset(used1,0,n+3);\n\t\tmemset(used2,0,n+3);\n\t\tmemset(used3,0,n+3);\n\t\tmemset(used4,0,n+3);\n\t\tfor(int j=1;j<=n;++j) t1[j]=dp[x][j],t3[j]=dp[y][j];\n\t\tfor(int j=1;j<=n;++j) t2[j]=dp[j][y],t4[j]=dp[j][x];\n\t\tif(!used1[y]&&!used4[x])\n\t\t{\n\t\t\tused1[y]=used4[x]=true;\n\t\t\tadd(dp[x][y],t3[x]);\n\t\t}\n\t\tif(!used2[x]&&!used3[y])\n\t\t{\n\t\t\tused2[x]=used3[y]=true;\n\t\t\tadd(dp[y][x],t1[y]);\n\t\t}\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(!used1[j])\n\t\t\t{\n\t\t\t\tused1[j]=true;\n\t\t\t\tadd(dp[x][j],t3[j]);\n\t\t\t}\n\t\t\tif(!used2[j])\n\t\t\t{\n\t\t\t\tused2[j]=true;\n\t\t\t\tadd(dp[y][j],t1[j]);\n\t\t\t}\n\t\t\tif(!used3[j])\n\t\t\t{\n\t\t\t\tused3[j]=true;\n\t\t\t\tadd(dp[j][x],t2[j]);\n\t\t\t}\n\t\t\tif(!used4[j])\n\t\t\t{\n\t\t\t\tused4[j]=true;\n\t\t\t\tadd(dp[j][y],t4[j]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tdp[x][j]=1ll*dp[x][j]*inv2%mod;\n\t\t\tdp[y][j]=1ll*dp[y][j]*inv2%mod;\n\t\t\tdp[j][x]=1ll*dp[j][x]*inv2%mod;\n\t\t\tdp[j][y]=1ll*dp[j][y]*inv2%mod;\n\t\t}\n\t\tadd(dp[x][y],dp[x][y]);\n\t\tadd(dp[y][x],dp[y][x]);\n\t\tadd(dp[x][x],dp[x][x]);\n\t\tadd(dp[y][y],dp[y][y]);\n\t\tfor(int j=1;j<=n;++j) dp[j][j]=0;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tadd(ans,1ll*dp[j][i]*mul%mod);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nconst int maxn = 3005;\nconst int inv2 = (mod + 1) / 2;\nint a[maxn];\nint dp[maxn][maxn];\nvoid add(int& a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint main() {\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) dp[i][j] = (a[i] < a[j]);\n\tint tot = 1;\n\twhile(q--) {\n\t\ttot = tot * 2 % mod;\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor(int i = 1; i <= n; i++) \n\t\t\tif(i != x && i != y) {\n\t\t\t\tdp[i][x] = dp[i][y] = (ll)(dp[i][x] + dp[i][y]) * inv2 % mod;\n\t\t\t\tdp[x][i] = dp[y][i] = (ll)(dp[x][i] + dp[y][i]) * inv2 % mod;\n\t\t\t}\n\t\tdp[x][y] = dp[y][x] = (ll)(dp[x][y] + dp[y][x]) * inv2 % mod;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++) \n\t\tfor(int j = 1; j < i; j++) add(ans, dp[i][j]);\n\tans = (ll)ans * tot % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 3050;\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) >> 1;\nint A[N][N], a[N], n, q;\ninline ll add(int x, int y) { return x + y >= P ? x + y - P : x + y; }\nvoid out(void) {\n    for (int i = 1;i <= n; i++, puts(\"\"))\n        for (int j = 1;j <= n; j++)\n            write(A[i][j], ' ');\n    puts(\"\");\n}\nint main() {\n    read(n), read(q);\n    for (int i = 1;i <= n; i++) read(a[i]);\n    for (int i = 1;i <= n; i++)\n        for (int j = 1;j <= n; j++) \n            A[i][j] = a[i] > a[j];\n    /* puts(\"\"); */\n    ll mi = 1;\n    for (int i = 1, x, y;i <= q; i++) {\n        /* out(); */\n        mi = add(mi, mi);\n        read(x), read(y);\n        /* if (x > y) swap(x, y); */\n        for (int i = 1;i <= n; i++) {\n            if (i == x || i == y) continue;\n            int tx = A[x][i], ty = A[y][i];\n            int ttx = A[i][x], tty = A[i][y];\n            A[x][i] = add(tx, ty) * inv2 % P;\n            A[y][i] = add(tx, ty) * inv2 % P;\n            A[i][x] = add(ttx, tty) * inv2 % P;\n            A[i][y] = add(ttx, tty) * inv2 % P;\n        }\n        A[x][y] = A[y][x] = (ll)inv2 * add(A[x][y], A[y][x]);\n    }\n    /* out(); */\n    int ans = 0;\n    for (int i = 1;i <= n; i++) \n        for (int j = i + 1;j <= n; j++)\n            ans = add(ans, A[i][j]);\n    write(1ll * ans * mi % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=3010,mo=1e9+7,inv2=mo+1>>1;\nll f[N][N],n,q,pw2=1,a[N];\nint main(){\n\tcin>>n>>q;\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tf[i][j]=a[i]<a[j];\n\twhile (q--){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (i==x||i==y)continue;\n\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*inv2%mo;\n\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])*inv2%mo;\t\t\t\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%mo;\n\t\tpw2=pw2*2%mo;\n\t}\n\tll ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tans=(ans+f[j][i])%mo;\n\tcout<<ans*pw2%mo<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n\nnamespace {\n  const int mo = 1e9 + 7;\n  inline int add(int x, int y) {\n    if ((x += y) >= mo) x -= mo;\n    return x;\n  }\n  inline int mul(int x, int y) {\n    return 1LL * x * y % mo;\n  }\n  inline int power(int a, int k) {\n    int ans = 1;\n    for (; k; k >>= 1, a = mul(a, a))\n      if (k & 1) ans = mul(ans, a);\n    return ans;\n  }\n}\nconst int N = 3333;\nint n, q, a[N], f[N][N];\n\nint main(void) {\n  read(n); read(q);\n  rep (i, n) read(a[i]);\n  rep (i, n) rep (j, n) f[i][j] = a[i] > a[j];\n  int inv2 = power(2, mo - 2);\n  rep (i, q) {\n    int x, y; read(x); read(y);\n    rep (j, n) if (j != x && j != y) {\n      f[j][x] = f[j][y] = mul(inv2, add(f[j][x], f[j][y]));\n      f[x][j] = f[y][j] = mul(inv2, add(f[x][j], f[y][j]));\n    }\n    f[x][y] = f[y][x] = mul(inv2, add(f[x][y], f[y][x]));\n  }\n  int ans = 0;\n  rep (i, n) rep (j, n) if (i < j) ans = add(ans, f[i][j]);\n  cout << mul(ans, power(2, q)) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nconst int MOD=1e9+7;\nll r2=(MOD+1)/2;\nint n,a[SZ],m,p[SZ],q[SZ],f[3333][3333];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=m;++i)\n\t\tcin>>p[i]>>q[i];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i!=j) f[i][j]=(a[i]>a[j]);\n\tll ans=0;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint u=(f[p[i]][q[i]]+f[q[i]][p[i]])%MOD*r2%MOD;\n\t\tf[p[i]][q[i]]=f[q[i]][p[i]]=u;\n\t\tfor(int t=1;t<=n;++t)\n\t\t{\n\t\t\tif(t!=p[i]&&t!=q[i]);else continue;\n\t\t\tint u=(f[t][p[i]]+f[t][q[i]])%MOD*r2%MOD;\n\t\t\tf[t][p[i]]=f[t][q[i]]=u;\n\t\t\tu=(f[p[i]][t]+f[q[i]][t])%MOD*r2%MOD;\n\t\t\tf[p[i]][t]=f[q[i]][t]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\t(ans+=f[i][j])%=MOD;\n\tfor(int j=1;j<=m;++j)\n\t\tans=ans*2LL%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 1000000007\n\nint A[3000];\nint dp[3000][3000];\nint x[50],y[50];\nint main() {\n    int i,j;\n    int N,Q,X,Y;\n    scanf(\"%d %d\",&N,&Q);\n    for (i = 0; i < N; i++) scanf(\"%d\",&A[i]);\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            if (A[i] < A[j]) dp[i][j]++;\n        }\n    }\n    print2dArr(dp,N,N);\n    for (i = 0; i < Q; i++) {\n        scanf(\"%d %d\",&X,&Y);\n        X--,Y--;\n        x[i] = X,y[i] = Y;\n        for (j = 0; j < N; j++) {\n            if ((j != X) && (j != Y)) {\n                dp[j][X] = dp[j][Y] = ((LLI) ((dp[j][X]+dp[j][Y]) % MOD)*((MOD+1)/2)) % MOD;\n                dp[X][j] = dp[Y][j] = ((LLI) ((dp[X][j]+dp[Y][j]) % MOD)*((MOD+1)/2)) % MOD;\n            }\n        }\n        dp[X][Y] = dp[Y][X] = ((LLI) ((dp[X][Y]+dp[Y][X]) % MOD)*((MOD+1)/2)) % MOD;\n    }\n\n    int ans = 0;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < i; j++) {\n            ans += dp[i][j];\n            if (ans >= MOD) ans -= MOD;\n        }\n    }\n    for (i = 0; i < Q; i++) ans = (2*ans) % MOD;\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=500005,M=998244353;\nint n,u[N],v[N],i,q,a[N],g[3005][3005],tmp[3005][3005],j;\nlong long inv,ans;\nlong long qpow(long long a,long long b)\n{\n\tlong long ans=1,s=a;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=q;++i)\n\t\tscanf(\"%d %d\",&u[i],&v[i]);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tg[i][j]=1;\n\tinv=qpow(2,M-2);\n\tfor(i=1;i<=q;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(j!=u[i]&&j!=v[i])\n\t\t\t{\n\t\t\t\ttmp[u[i]][j]=tmp[v[i]][j]=(g[v[i]][j]+g[u[i]][j])*inv%M;\n\t\t\t\ttmp[j][u[i]]=tmp[j][v[i]]=(g[j][u[i]]+g[j][v[i]])*inv%M;\n\t\t\t}\n\t\ttmp[v[i]][u[i]]=tmp[u[i]][v[i]]=(g[u[i]][v[i]]+g[v[i]][u[i]])*inv%M;\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tg[u[i]][j]=tmp[u[i]][j];\n\t\t\tg[v[i]][j]=tmp[v[i]][j];\n\t\t\tg[j][u[i]]=tmp[j][u[i]];\n\t\t\tg[j][v[i]]=tmp[j][v[i]];\n\t\t}\t\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tans+=g[i][j];\n\tcout<<(ans*qpow(2,q)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n   #define PP pair<int,pair<int,int>>\nconst int MAX = 510000;\nconst int MOD =  1000000007;\nconst int INV2 = (MOD+1)/2;\nint modpow(int a, int n, int mod) {\n    int res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n     signed main(){\n   int n,q;\n   cin>>n>>q;\n   int a[n];\n   for(int i=0;i<n;i++)cin>>a[i];\n   int dp[n][n],x0=modpow(2,q,MOD);\n   for(int i=0;i<n;i++)fill(dp[i],dp[i]+n,0);\n   for(int i=0;i<n;i++){\n     for(int j=0;j<n;j++){\n       if(a[i]>a[j])dp[i][j]=(dp[i][j]+x0)%MOD;\n     }\n   }\n   int x,y;\n   for(int p=0;p<q;p++){\n     cin>>x>>y;x--;y--;\n     int tmp=(dp[y][x]+dp[x][y])%MOD*INV2%MOD;\n      dp[y][x]=tmp;dp[x][y]=tmp;\n     for(int i=0;i<n;i++)if(i!=x&&i!=y){\n      tmp=(dp[i][x]+dp[i][y])%MOD*INV2%MOD;\n       dp[i][x]=tmp;dp[i][y]=tmp;\n       tmp=(dp[x][i]+dp[y][i])%MOD*INV2%MOD;\n       dp[x][i]=tmp;dp[y][i]=tmp;\n     }\n   }\n   int ans=0;\n   for(int i=0;i<n;i++)for(int j=i+1;j<n;j++)ans=(ans+dp[i][j])%MOD;\n   cout<<ans<<endl;\n   \n                  \n}\n\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<long long MOD>\nclass Num {\nprivate:\n\tlong long expow(long long base, long long e) const {\n\t\tlong long ans = 1;\n\t\tfor (; e > 0; e/= 2) {\n\t\t\tif (e % 2)\n\t\t\t\tans = ans * base % MOD;\n\t\t\tbase = base * base % MOD; }\n\t\treturn ans; }\n\npublic:\n\tlong long val;\n\n\tNum(long long _val) {\n\t\tval = _val % MOD;\n\t\tval = val < 0 ? val + MOD : val; }\n\tNum() : val(0) { }\n\n\tinline Num operator + (const Num &arg) const {\n\t\tNum res;\n\t\tres.val = val + arg.val;\n\t\tres.val = res.val >= MOD ? res.val - MOD : res.val;\n\t\treturn res; }\n\n\tinline Num operator - (const Num &arg) const {\n\t\tNum res;\n\t\tres.val = val - arg.val;\n\t\tres.val = res.val < 0 ? res.val + MOD : res.val;\n\t\treturn res; }\n\n\tinline Num operator - () const {\n\t\tNum res;\n\t\tres.val = MOD - res.val;\n\t\tres.val = res.val == MOD ? 0 : res.val;\n\t\treturn res; }\n\n\tinline Num operator ^ (const int &arg) const {\n\t\treturn Num(expow(val, arg)); }\n\n\tinline Num operator * (const Num &arg) const {\n\t\treturn Num(val * arg.val); }\n\n\tinline Num operator / (const Num &arg) const {\n\t\treturn Num(val * expow(arg.val, MOD - 2)); }\n\n\tinline void operator += (const Num &arg) {\n\t\t(*this) = (*this) + arg; }\n\n\tinline void operator -= (const Num &arg) {\n\t\t(*this) = (*this) - arg; }\n\n\tinline void operator *= (const Num &arg) {\n\t\t(*this) = (*this) * arg; }\n\n\tinline void operator /= (const Num &arg) {\n\t\t(*this) = (*this) / arg; }\n\n\tinline void operator ^= (const long long &arg) {\n\t\tval = expow(val, arg); } };\n\ntemplate<long long MOD>\nostream &operator << (ostream &fo, const Num<MOD> &c) {\n\tfo << c.val;\n\treturn fo; }\n\ntemplate<long long MOD>\nistream &operator >> (istream &fi, Num<MOD> &c) {\n\tfi >> c.val;\n\tc = Num<MOD>(c.val);\n\treturn fi; }\n\nconst int N = 3005, MOD = 1e9 + 7;\nconst Num<MOD> HALF = Num<MOD>(1) / 2;\n\nint n, q;\n\nvector<vector<Num<MOD>>> dp[2];\nvector<int> v;\n\nint main() {\n#ifdef HOME\n\tfreopen(\"agc30d.in\", \"r\", stdin);\n\tfreopen(\"agc30d.out\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false); \n\tcin.tie(0), cout.tie(0);\n\tNum<MOD> ant;\n\tint l, r;\n\n\tcin >> n >> q;\n\tv.resize(n);\n\tfor (auto &i: v)\n\t\tcin >> i;\n\n\tdp[0] = dp[1] = vector<vector<Num<MOD>>>(n, vector<Num<MOD>>(n));\n\tfor (int i = 0; i < n; ++i)\n\tfor (int j = 0; j < n; ++j)\n\t\tdp[0][i][j] = Num<MOD> {int(v[i] > v[j])};\n\n\tfor (int u = 0; u < q; ++u) {\n\t\tcin >> l >> r;\n\t\tif (--l == --r)\n\t\t\tcontinue;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (i != l && i != r) {\n\t\t\t\tdp[1][i][l] = (dp[0][i][l] + dp[0][i][r]) * HALF;\n\t\t\t\tdp[1][l][i] = (dp[0][l][i] + dp[0][r][i]) * HALF;\n\n\t\t\t\tdp[1][i][r] = (dp[0][i][l] + dp[0][i][r]) * HALF;\n\t\t\t\tdp[1][r][i] = (dp[0][l][i] + dp[0][r][i]) * HALF; }\n\n\t\tdp[0][r][l] = dp[0][l][r] = (dp[0][l][r] + dp[0][r][l]) * HALF;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (i != l && i != r) {\n\t\t\t\tdp[0][i][l] = dp[1][i][l];\n\t\t\t\tdp[0][i][r] = dp[1][i][r];\n\n\t\t\t\tdp[0][l][i] = dp[1][l][i];\n\t\t\t\tdp[0][r][i] = dp[1][r][i]; } }\n\n\tfor (int i = 0; i < n; ++i)\n\tfor (int j = i + 1; j < n; ++j)\n\t\tant+= dp[0][i][j];\n\n\tcout << (ant * (Num<MOD>(2) ^ q)) << endl;\n\n\treturn 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nll dp[3005][3005];\n\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tint n,q;\n\tvector<int>num;\n\tscanf(\"%d%d\",&n,&q);\n//\tn = 3000; q = 3000;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x; scanf(\"%d\",&x);\n\t\tnum.pb(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(num[i]>num[j]) dp[i][j]=1;\n\t\t}\n\t}\n\tll xx = modpow(2LL,mod-2);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint a,b;\n\t//\ta = i; b = (i*i)%n;\n\t\tscanf(\"%d %d\",&a,&b);\n\t    a--; b--;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t    if(j == a || j == b) continue;\n\t\t\tdp[j][a]=dp[j][b]=(dp[j][a]+dp[j][b])%mod*xx%mod;\n\t\t\tdp[a][j]=dp[b][j]=(dp[a][j]+dp[b][j])%mod*xx%mod;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=(dp[a][b]+dp[b][a])%mod*xx%mod;;\n\t\tdp[a][a]=dp[b][b]=0;\n\t}\n\tll ret = 0;\n\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) ret+=dp[i][j];\n\tret %= mod;\n\tret = ret*modpow(2LL,q)%mod;\n\tcout<<(ret+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for (register int i = l; i <= r; i++)\n#define ford(i, r, l) for (register int i = r; i >= l; i--)\n\nint read() {\n  int res = 0;\n  char c = getchar();\n  while (!isdigit(c)) c = getchar();\n  while (isdigit(c)) res = res * 10 + c - '0', c = getchar();\n  return res;\n}\n\nconst int mod = 1e9 + 7, inv_2 = (mod + 1) >> 1;\nvoid Inc(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }\nvoid Dec(int &x, int y) { x -= y, x += x < 0 ? mod : 0; }\nint inc(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\nint dec(int x, int y) { return x < y ? x - y + mod : x - y; }\nint mul(int x, int y) { return 1LL * x * y % mod; }\n\nconst int maxn = 3030;\nint N, Q, A[maxn];\nint f[maxn][maxn];\n\nint main() {\n  N = read(), Q = read();\n  for (int i = 1; i <= N; i++) A[i] = read();\n  for (int i = 1; i <= N; i++)\n    for (int j = 1; j <= N; j++) f[i][j] = A[i] > A[j];\n  for (int hhw = 1; hhw <= Q; hhw++) {\n    int x = read(), y = read();\n    f[x][y] = f[y][x] = mul(inc(f[x][y], f[y][x]), inv_2);\n    for (int i = 1; i <= N; i++) {\n      if (i == x || i == y) continue;\n      f[i][x] = f[i][y] = mul(inc(f[i][x], f[i][y]), inv_2);\n      f[x][i] = f[y][i] = mul(inc(f[x][i], f[y][i]), inv_2);\n    }\n  }\n  int Ans = 0;\n  for (int i = 1; i <= N; i++)\n    for (int j = i + 1; j <= N; j++) Inc(Ans, f[i][j]);\n  for (int i = 1; i <= Q; i++) Ans = mul(Ans, 2);\n  printf(\"%d\\n\", Ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Email: hany01dxx@gmail.com & hany01@foxmail.com\n * Inst: Yali High School\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\n#define Rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define X first\n#define Y second\n#define PB(a) push_back(a)\n#define MP(a, b) make_pair(a, b)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(), a.end()\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 wozenmezhemecaia\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\n\ntemplate <typename T> inline T read() {\n\tregister T _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n//EOT\n\n\nconst int MAXN = 3005, MOD = 1e9 + 7;\n\nint sum[MAXN], ls[MAXN], lss, n, m, sm[MAXN];\n\ninline int fpm(int a, int b = MOD - 2) {\n\tregister int ans = 1;\n\tfor ( ; b; b >>= 1, a = (LL)a * a % MOD)\n\t\tif (b & 1) ans = (LL)ans * a % MOD;\n\treturn ans;\n}\n\nint f[MAXN][MAXN], res[MAXN][MAXN], a[MAXN];\nint inv = (MOD + 1) / 2;\n\nvoid solve() {\n\tint u, v;\n\tFor(i, 1, n) For(j, i + 1, n) {\n\t\tif (a[i] < a[j]) f[i][j] = 1;\n\t\tif (a[j] < a[i]) f[j][i] = 1;\n\t}\n\tFor(i, 1, m) {\n\t\tu = read<int>(), v = read<int>();\n\t\tFor(i, 1, n) res[i][u] = res[i][v] = res[u][i] = res[v][i] = 0;\n\t\tFor(i, 1, n) if (i ^ u && i ^ v) {\n\t\t\t(res[i][v] += (f[i][u] + f[i][v]) % MOD) %= MOD;\n\t\t\t(res[i][u] += (f[i][u] + f[i][v]) % MOD) %= MOD;\n\t\t\t(res[u][i] += (f[u][i] + f[v][i]) % MOD) %= MOD;\n\t\t\t(res[v][i] += (f[u][i] + f[v][i]) % MOD) %= MOD;\n\t\t}\n\t\tres[u][v] = res[v][u] = (f[u][v] + f[v][u]) % MOD;\n\t\tFor(i, 1, n) {\n\t\t\tf[i][u] = 1ll * res[i][u] * inv % MOD;\n\t\t\tf[i][v] = 1ll * res[i][v] * inv % MOD;\n\t\t\tf[u][i] = 1ll * res[u][i] * inv % MOD;\n\t\t\tf[v][i] = 1ll * res[v][i] * inv % MOD;\n\t\t}\n\t}\n\tint ans = 0;\n\tFor(i, 1, n) For(j, 1, i - 1)\n\t\t(ans += f[i][j]) %= MOD;\n\tans = (LL)ans * fpm(2, m) % MOD;\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef hany01\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\n\tn = read<int>(), m = read<int>();\n\tFor(i, 1, n) a[i] = read<int>();\n\n\tsolve();\n\n\t/*For(i, 1, n) ls[i] = a[i] = read<int>();\n\tsort(ls + 1, ls + 1 + n), lss = unique(ls + 1, ls + 1 + n) - ls - 1;\n\tFor(i, 1, n) {\n\t\ta[i] = lower_bound(ls + 1, ls + 1 + lss, a[i]) - ls;\n\t\tf[i][i] = 1;\n\t}\n\tint inv = fpm(2);\n\tFor(i, 1, q) {\n\t\tint x = read<int>(), y = read<int>();\n\t\tFor(j, 1, n) f[j][x] = f[j][y] = (LL)(f[j][x] + f[j][y]) * inv % MOD;\n\t}\n\n\tint ans = 0;\n\tFor(i, 1, n) {\n\t\tFor(j, 1, n) (ans += (LL)sum[a[j] + 1] * f[j][i]) %= MOD;\n\t\tFor(j, 1, n) sm[j] = 0;\n\t\tFor(j, 1, n) (sm[a[j]] += f[j][i]) %= MOD;\n\t\tFordown(j, n, 1) (sm[j] += sm[j + 1]) %= MOD;\n\t\tFor(j, 1, n) (sum[j] += sm[j]) %= MOD;\n\t}\n\tprintf(\"%lld\\n\", (LL)ans * fpm(2, q) % MOD);*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n// 217\n// 44\n\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = 3000;\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1) {\n            ans = (1LL * ans * a) % MOD;\n        }\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\nint arr[MAXN + 1];\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n}\n\nint dp[MAXN + 1][MAXN + 1], aux[MAXN + 1][MAXN + 1];\nint last[MAXN + 1][MAXN + 1], now;\n\ninline void add(int l1, int c1, int l2, int c2) {\n    if(last[l1][c1] < now) {\n        dp[l1][c1] += aux[l1][c1];\n        mod(dp[l1][c1]);\n        aux[l1][c1] = 0;\n        dp[l1][c1] = (1LL * dp[l1][c1] * lgput(2, now - last[l1][c1] - 1)) % MOD;\n        last[l1][c1] = now;\n    }\n    if(last[l2][c2] < now) {\n        dp[l2][c2] += aux[l2][c2];\n        mod(dp[l2][c2]);\n        aux[l2][c2] = 0;\n        dp[l2][c2] = (1LL * dp[l2][c2] * lgput(2, now - last[l2][c2] - 1)) % MOD;\n        last[l2][c2] = now;\n    }\n    aux[l2][c2] += dp[l1][c1];\n    mod(aux[l2][c2]);\n}\n\nint main() {\n    //ifstream cin(\"A.in\");\n    //ofstream cout(\"A.out\");\n    int i, j, n, q;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> q;\n    for(i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n    for(i = 1; i <= n; i++) {\n        for(j = 1; j <= n; j++) {\n            dp[i][j] = (arr[i] > arr[j]);\n            //cerr << dp[i][j] << \" \";\n        }\n        //cerr << \"\\n\";\n    }\n    //cerr << \"\\n\";\n    while(q > 0) {\n        q--;\n        int x, y;\n        cin >> x >> y;\n        now++;\n        for(i = 1; i <= n; i++) {\n            if(i != x && i != y) {\n                add(x, i, y, i);\n                add(i, x, i, y);\n                add(y, i, x, i);\n                add(i, y, i, x);\n            }\n        }\n        add(x, y, y, x);\n        add(y, x, x, y);\n        /*for(i = 1; i <= n; i++) {\n            for(j = 1; j <= n; j++) {\n                cerr << 1LL * (dp[i][j] + aux[i][j]) * lgput(2, now - last[i][j]) << \" \";\n            }\n            cerr << \"\\n\";\n        }\n        cerr << \"\\n\";*/\n    }\n    int ans = 0;\n    for(i = 1; i <= n; i++) {\n        for(j = i + 1; j <= n; j++) {\n            dp[i][j] += aux[i][j];\n            mod(dp[i][j]);\n            dp[i][j] = (1LL * dp[i][j] * lgput(2, now - last[i][j])) % MOD;\n            ans += dp[i][j];\n            mod(ans);\n        }\n    }\n    cout << ans;\n    //cin.close();\n    //cout.close();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define nn 3008\n#define ll long long\n#define mod 1000000007\n#define lf double\nusing namespace std;\nll dp[nn][nn];\nll qpow(ll x,ll y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nll d2;\nint org[nn];\nll tmp1[nn],tmp2[nn];\nint main()\n{\n\td2=qpow(2,mod-2);\n\tll n,m;scanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&org[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(org[i]>org[j]) dp[i][j]=1;\n\tfor(int ytl=1;ytl<=m;ytl++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;i++) tmp1[i]=(dp[x][i]+dp[y][i])*d2%mod;\n\t\tfor(int i=1;i<=n;i++) tmp2[i]=(dp[i][x]+dp[i][y])*d2%mod;\n\t\tll tmp3=(dp[x][y]+dp[y][x])*d2%mod;\n\t\tfor(int i=1;i<=n;i++) \n\t\t\tdp[i][y]=dp[i][x]=tmp2[i];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tdp[x][i]=dp[y][i]=tmp1[i];\n\t\tdp[x][x]=dp[y][y]=0;\n\t\tdp[x][y]=dp[y][x]=tmp3;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans+=dp[i][j],ans%=mod;\n\tcout<<ans*qpow(2,m)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#define rr register\nusing namespace std;\nconst int N=3011,mod=1000000007,inv2=(mod+1)>>1;\nint n,Q,a[N],dp[N][N],f[N][N],ans,mi;\ninline signed iut(){\n\trr int ans=0; rr char c=getchar();\n\twhile (!isdigit(c)) c=getchar();\n\twhile (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();\n\treturn ans;\n}\ninline signed mo(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nsigned main(){\n\tn=iut(),Q=iut(),mi=1;\n\tfor (rr int i=1;i<=n;++i) a[i]=iut();\n\tfor (rr int i=1;i<=n;++i)\n\tfor (rr int j=1;j<=n;++j) dp[i][j]=a[i]>a[j];\n\tfor (rr int i=1;i<=Q;++i,mi=mo(mi,mi)){\n\t\trr int x1=iut(),x2=iut();\n\t\tfor (rr int j=1;j<=n;++j) if (j!=x1&&j!=x2)\n\t\t\tf[x1][j]=f[x2][j]=1ll*inv2*mo(dp[x1][j],dp[x2][j])%mod,\n\t\t\tf[j][x1]=f[j][x2]=1ll*inv2*mo(dp[j][x1],dp[j][x2])%mod;\n\t\tfor (rr int j=1;j<=n;++j) if (j!=x1&&j!=x2)\n\t\t    dp[x1][j]=f[x1][j],dp[x2][j]=f[x2][j],\n\t\t    dp[j][x1]=f[j][x1],dp[j][x2]=f[j][x2];\n\t\tdp[x1][x2]=dp[x2][x1]=1ll*inv2*mo(dp[x1][x2],dp[x2][x1])%mod;\n\t}\n\tfor (rr int i=1;i<n;++i)\n\tfor (rr int j=i+1;j<=n;++j)\n\t    ans=mo(ans,dp[i][j]);\n\treturn !printf(\"%d\\n\",1ll*ans*mi%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define ll long long\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();}\n\twhile(c<='9'&&c>='0'){sum=sum*10+c-'0';c=getchar();}\n\treturn f*sum;\n}\n\nconst int N=5005;\nconst int Mod=1000000007;\nint n,m,a[N];\nll f[N][N];\n\ninline ll fpow(ll a,ll b){\n\tll ret=1;\n\twhile(b){if(b&1) ret=ret*a%Mod;a=a*a%Mod;b>>=1;}\n\treturn ret;\n}\n\nsigned main(){\n\tn=read();m=read();ll inv=fpow(2,Mod-2);\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tif(a[i]>a[j]) f[i][j]=1;\n\t\t}\n\tfor(int i=1;i<=m;i++){\t\t\n\t\tint x=read(),y=read();\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%Mod*inv%Mod;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==x||j==y) continue;\t\t\t\n\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])%Mod*inv%Mod;\n\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])%Mod*inv%Mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) ans=(ans+f[i][j])%Mod;\n\tprintf(\"%lld\\n\",ans*fpow(2,m)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007, Inv2 = (Mod + 1) / 2;\nconst int MN = 3005;\n\nint N, Q, A[MN], p1[MN], p2[MN];\nint dp[MN][MN], Coef, Sum;\n\nint main() {\n        scanf(\"%d%d\", &N, &Q), Coef = 1;\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n        for (int i = 1; i <= Q; ++i) {\n                scanf(\"%d%d\", &p1[i], &p2[i]);\n                /* if (p1[i] > p2[i]) std::swap(p1[i], p2[i]); */\n        }\n        for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= N; ++j)\n                        dp[i][j] = A[i] > A[j];\n        for (int i = 1; i <= Q; ++i) {\n                static int tmp[MN][MN];\n                for (int x = 1; x <= N; ++x)\n                        if (x != p1[i] && x != p2[i]) {\n                                tmp[x][p1[i]] = (LL)Inv2 * (dp[x][p1[i]] + dp[x][p2[i]]) % Mod;\n                                tmp[p1[i]][x] = (LL)Inv2 * (dp[p1[i]][x] + dp[p2[i]][x]) % Mod;\n                                tmp[x][p2[i]] = (LL)Inv2 * (dp[x][p2[i]] + dp[x][p1[i]]) % Mod;\n                                tmp[p2[i]][x] = (LL)Inv2 * (dp[p2[i]][x] + dp[p1[i]][x]) % Mod;\n                        }\n                for (int x = 1; x <= N; ++x)\n                        if (x != p1[i] && x != p2[i]) {\n                                dp[x][p1[i]] = tmp[x][p1[i]];\n                                dp[p1[i]][x] = tmp[p1[i]][x];\n                                dp[x][p2[i]] = tmp[x][p2[i]];\n                                dp[p2[i]][x] = tmp[p2[i]][x];\n                        }\n                dp[p2[i]][p1[i]] = dp[p1[i]][p2[i]] = Inv2;\n                Coef = 2ll * Coef % Mod;\n        }\n        for (int x = 1; x < N; ++x)\n                for (int y = x + 1; y <= N; ++y)\n                        Sum = (Sum + dp[x][y]) % Mod;\n        printf(\"%lld\\n\", (LL)Coef * Sum % Mod);\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\n\nll powm(ll x,ll k){\n    ll res=1;\n    while(k){\n        if(k&1) res=(res*x)%MOD;\n        x=(x*x)%MOD;\n        k/=2;\n    }\n    return res;\n}\nll piyo=-1;\nll mod_inv(ll x){\n    if(piyo!=-1) return piyo;\n    return piyo=powm(x,MOD-2);\n}\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    vector<int> a(n);\n    for(int i=0;i<n;i++) cin>>a[i];\n    vector<vector<ll>> dp(n,vector<ll>(n,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            dp[i][j]=(a[i]<a[j]);\n        }\n    }\n    int rq=q;\n    while(q--){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        for(int i=0;i<n;i++){\n            if(i!=x && i!=y){\n                ll tmp=((dp[i][x]+dp[i][y])%MOD)*mod_inv(2)%MOD;\n                dp[i][x]=dp[i][y]=tmp;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(i!=x && i!=y){\n                ll tmp=((dp[x][i]+dp[y][i])%MOD)*mod_inv(2)%MOD;\n                dp[x][i]=dp[y][i]=tmp;\n            }\n        }\n        dp[x][y]=dp[y][x]=((dp[x][y]+dp[y][x])*mod_inv(2))%MOD;        \n    }\n    ll res=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<i;j++){\n            res+=dp[i][j];\n            res%=MOD;\n        }\n    }\n    for(int i=0;i<rq;i++){\n        res=(res*2)%MOD;\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nconst ll inv=500000004;\n\nll mod_pow(ll a,ll x){\n    ll ret=1;\n    if(a==0){return 0;}\n    while(x>0){\n        if(x&1){ret*=a; ret%=MOD;}\n        a*=a;\n        a%=MOD;\n        x>>=1;\n    }\n    return ret;\n}\n\n\nint main(){\n    ll n,q;\n    cin>>n>>q;\n    vector<ll> a(n);\n    for(auto &i:a){cin>>i;}\n    vector<vector<ll>> dp(n,vector<ll>(n));\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(a[i]>a[t]){dp[i][t]=1;}\n        }\n    }\n    for(int i=0;i<q;i++){\n        ll x,y;\n        cin>>x>>y;\n        x--; y--;\n        for(int i=0;i<n;i++){\n            if(x==i || y==i){continue;}\n            (dp[x][i]*=inv)%=MOD;\n            (dp[y][i]*=inv)%=MOD;\n            (dp[x][i]+=dp[y][i])%=MOD;\n            dp[y][i]=dp[x][i];\n            (dp[i][x]*=inv)%=MOD;\n            (dp[i][y]*=inv)%=MOD;\n            (dp[i][y]+=dp[i][x])%=MOD;\n            dp[i][x]=dp[i][y];\n        }\n        (dp[x][y]*=inv)%=MOD;\n        (dp[y][x]*=inv)%=MOD;\n        (dp[x][y]+=dp[y][x])%=MOD;\n        dp[y][x]=dp[x][y];\n    }\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        for(int t=i+1;t<n;t++){\n            ans+=dp[i][t];\n        }\n    }\n    ans%=MOD;\n    cout<<ans*mod_pow(2,q)%MOD<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=190;\nusing std::max;\nusing std::min;\nint n,m,a[N][N],sum[N][N],dp[N][N][N][15];\nchar c[N][N];\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++) scanf(\"%s\",c[i]+1);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++){\n            if (c[i][j]=='.') a[i][j]=1;\n            else a[i][j]=0;\n            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];\n        }\n    for (int i=1;i<=n;i++)  \n        for (int j=1;j<=m;j++)\n            for (int k=j;k<=m;k++){\n                int l=i,r=n,ans=i-1;\n                while (l<=r){\n                    int mid=(l+r)>>1;\n                    int s=sum[mid][k]-sum[mid][j-1]-sum[i-1][k]+sum[i-1][j-1];\n                    if (s==0 || s==(mid-i+1)*(k-j+1))\n                        ans=mid,l=mid+1;\n                    else r=mid-1;\n                }\n                dp[i][j][k][0]=ans;\n            }\n    int k=1;\n    for (k=1;dp[1][1][m][k-1]<n;k++)\n    for (int h=1;h<=m;h++)\n        for (int i=1;i<=n;i++)\n            for (int j1=1,j2=j1+h-1;j2<=m;j1++,j2++){\n                    if (dp[i][j1][j2][k-1]==n){\n                        dp[i][j1][j2][k]=n;\n                        continue;\n                    }\n                    dp[i][j1][j2][k]=dp[dp[i][j1][j2][k-1]+1][j1][j2][k-1];//横\n                    if(dp[i][j1][j2][k]==n) continue; \n                    int l=j1,r=j2-1,ans=0;//竖 \n                    while (l<=r){\n                        int mid=(l+r)>>1;\n                        int x=dp[i][j1][mid][k-1],y=dp[i][mid+1][j2][k-1];\n                        ans=max(ans,min(x,y));\n                        if (x<y) r=mid-1;\n                        else l=mid+1;\n                    }\n    \n                    dp[i][j1][j2][k]=max(dp[i][j1][j2][k],ans);\n                }\n    printf(\"%d\\n\",k-1);"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, Q, A[3010];\nmint dp[3010][3010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> Q;\n    rep(i, 0, N) cin >> A[i];\n\n    rep(i, 0, N) rep(j, 0, N) if (A[i] > A[j]) dp[i][j] = 1;\n    rep(q, 0, Q) {\n        int x, y; cin >> x >> y; x--; y--;\n        rep(i, 0, N) if (i != x and i != y) {\n            dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) / 2;\n            dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) / 2;\n        }\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) / 2;\n    }\n\n    mint ans = 0;\n    rep(i, 0, N) rep(j, i + 1, N) ans += dp[i][j];\n    ans *= mint(2) ^ Q;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\n#define pii pair<int, int>\n#define mp(x, y) make_pair(x, y)\nusing namespace std;\nconst int Maxn = 3e3 + 5, Mod = 1e9 + 7;\ntypedef long long ll;\ntypedef int arr[Maxn];\nll Add(ll x, ll y) { return (x += y) >= Mod ? x - Mod : (x < 0 ? x + Mod : x); }\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n, m;\narr a;\nll ans;\nll f[Maxn][Maxn];\nll qp(rg ll x, int y)\n{\n\trg ll res = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1)\n\t\t\tres = res * x % Mod;\n\t\tx = x * x % Mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint main()\n{\n\trg ll inv2 = qp(2, Mod - 2);\n\trg int x, y;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i] = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (rg int j = 1; j <= n; j++)\n\t\t\tf[i][j] = a[i] > a[j];\n\tfor (rg int i = 1; i <= m; i++)\n\t{\n\t\tx = read();\n\t\ty = read();\n\t\tf[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv2 % Mod;\n\t\tfor (rg int j = 1; j <= n; j++)\n\t\t\tif (j != x && j != y)\n\t\t\t{\n\t\t\t\tf[j][y] = f[j][x] = (f[j][x] + f[j][y]) * inv2 % Mod;\n\t\t\t\tf[y][j] = f[x][j] = (f[x][j] + f[y][j]) * inv2 % Mod;\n\t\t\t}\n\t}\n\tfor (rg int i = 1; i < n; i++)\n\t\tfor (rg int j = i + 1; j <= n; j++)\n\t\t\tans = Add(ans, f[i][j]);\n\tcout << ans * qp(2, m) % Mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(3050);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N, Q, A[Max_N], F[Max_N][Max_N], inv2;\n\nint main()\n{\n\tgi(N), gi(Q), inv2 = inverse(2);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(A[i]);\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (i != j)\n\t\t\t\tF[i][j] = (A[i] > A[j]);\n\tfor (int i = 1, x, y;i <= Q;++i)\n\t{\n\t\tgi(x), gi(y), F[x][y] = F[y][x] = Mult(Add(F[x][y], F[y][x]), inv2);\n\t\tfor (int i = 1;i <= N;++i)\n\t\t\tif (i != x && i != y)\n\t\t\t{\n\t\t\t\tF[x][i] = F[y][i] = Mult(Add(F[x][i], F[y][i]), inv2);\n             \t\t\tF[i][x] = F[i][y] = Mult(Add(F[i][x], F[i][y]), inv2);\n\t\t\t}\n\t}\n\tint Ans = 0;\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = i + 1;j <= N;++j)\n\t\t\tAns = Add(Ans, F[i][j]);\n\twhile (Q--)\n\t\tAns = Add(Ans, Ans);\n\tprint(Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=3005,mod=1e9+7;\nint n,q,f[N][N],inv2,mul,a[N],tx[N],ty[N],ans;\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d%d\",&n,&q),i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor (i=1;i<=q;++i) scanf(\"%d%d\",&tx[i],&ty[i]); inv2=quick_pow(2);\n\tfor (i=1;i<=n;++i) for (j=1;j<=n;++j) if (i!=j&&a[i]>a[j]) ++f[i][j];\n\tfor (mul=quick_pow(2,q),i=1;i<=q;++i)\n\t{\n\t\tint x=tx[i],y=ty[i]; f[x][y]=f[y][x]=1LL*sum(f[x][y],f[y][x])*inv2%mod;\n\t\tfor (j=1;j<=n;++j) if (j!=x&&j!=y) f[x][j]=f[y][j]=1LL*sum(f[x][j],f[y][j])*inv2%mod;\n\t\tfor (j=1;j<=n;++j) if (j!=x&&j!=y) f[j][x]=f[j][y]=1LL*sum(f[j][x],f[j][y])*inv2%mod;\n\t}\n\tfor (i=1;i<=n;++i) for (j=1;j<=n;++j) if (i<j) ans=sum(ans,1LL*f[i][j]*mul%mod);\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 3010 \n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 1000000007 ;\n\nconst int inv2 = 500000004 ;\n\nchar *p1, *p2, buf[100000];\n\n#define nc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1 ++ )\n\nint rd() {\n\tint x = 0, f = 1;\n\tchar c = nc();\n\twhile (c < 48) {\n\t\tif (c == '-')\n\t\t\tf = -1;\n\t\tc = nc();\n\t}\n\twhile (c > 47) {\n\t\tx = (((x << 2) + x) << 1) + (c ^ 48), c = nc();\n\t}\n\treturn x * f;\n}\n\nint a[N], f[N][N];\n\nint main() {\n\tint n = rd(), q = rd(), mdl = 1;\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\ta[i] = rd();\n\t}\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tfor (int j = 1; j <= n; j ++ ) {\n\t\t\tif (a[i] < a[j]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= q; i ++ ) {\n\t\tmdl = (ll)mdl * 2 % mod;\n\t\tint x = rd(), y = rd();\n\t\tf[x][y] = f[y][x] = ((ll)f[x][y] + f[y][x]) * inv2 % mod;\n\n\t\tfor (int j = 1; j <= n; j ++ ) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tf[x][j] = f[y][j] = ((ll)f[x][j] + f[y][j]) * inv2 % mod;\n\t\t\t\tf[j][x] = f[j][y] = ((ll)f[j][x] + f[j][y]) * inv2 % mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i ++ ) {\n\t\tfor (int j = 1; j < i; j ++ ) {\n\t\t\t(ans += f[i][j]) %= mod;\n\t\t}\n\t}\n\n\tans = (ll)ans * mdl % mod, (ans += mod) %= mod;\n\tcout << ans << endl ;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\nconst ll inv2 = (P+1)/2;\nconst int N = 3300;\nint n,q,a[N],x[N],y[N];\nint dp[N][N];\nstruct {int x,y;ll v;} s[N*10];\n\nint main() {\n\tscanf(\"%d%d\",&n,&q);\n\tREP(i,1,n) scanf(\"%d\",a+i);\n\tREP(i,1,q) scanf(\"%d%d\",x+i,y+i);\n\tREP(i,1,n) REP(j,1,n) dp[i][j] = a[i]>a[j];\n\tREP(z,1,q) { \n\t\tint top = 0;\n\t\tREP(i,1,n) {\n\t\t\tif (i!=y[z]) { \n\t\t\t\ts[++top] = {x[z],i,(dp[x[z]][i]+dp[y[z]][i])*inv2%P};\n\t\t\t\ts[++top] = {i,x[z],(dp[i][x[z]]+dp[i][y[z]])*inv2%P};\n\t\t\t}\n\t\t\telse { \n\t\t\t\ts[++top] = {x[z],y[z],(dp[x[z]][y[z]]+dp[y[z]][x[z]])*inv2%P};\n\t\t\t}\n\t\t\tif (i!=x[z]) {\n\t\t\t\ts[++top] = {y[z],i,(dp[y[z]][i]+dp[x[z]][i])*inv2%P};\n\t\t\t\ts[++top] = {i,y[z],(dp[i][y[z]]+dp[i][x[z]])*inv2%P};\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[++top] = {y[z],x[z],(dp[x[z]][y[z]]+dp[y[z]][x[z]])*inv2%P};\n\t\t\t}\n\t\t}\n\t\tREP(i,1,top) dp[s[i].x][s[i].y]=s[i].v;\n\t}\n\tint ans = 0;\n\tREP(i,1,n) REP(j,i+1,n) ans = (ans+dp[i][j])%P;\n\tans = ans*qpow(2,q)%P;\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3000, mod = 1000000007;\nint n, q, a[maxn + 10], lst[maxn + 10][maxn + 10];\nint x[maxn + 10], y[maxn + 10];\nbool vis[maxn + 10][maxn + 10][4];\nint f[maxn + 10][maxn + 10][4], ans;\nint p2[maxn + 10];\n\nint add(int x, int y) {\n\tx += y; return x < mod ? x : x - mod;\n}\nint mul(int x, int y) {\n\treturn 1ll * x * y % mod;\n}\n\nint calc(int p, int l, int r) {\n\tint w = p2[min(lst[p][l], lst[p][r]) - p];\n\tp = min(lst[p][l], lst[p][r]);\n\tif (p == q + 1) return mul(w, l > r);\n\tint s, d;\n\tassert(l == x[p] || l == y[p] || r == x[p] || r == y[p]);\n\tif (l == x[p]) {\n\t\td = 0; s = r;\n\t} else if (l == y[p]) {\n\t\td = 1; s = r;\n\t} else if (r == x[p]) {\n\t\td = 2; s = l;\n\t} else if (r == y[p]) {\n\t\td = 3; s = l;\n\t}\n\tif (vis[p][s][d]) return mul(w, f[p][s][d]);\n\tif ((l == x[p] && r == y[p]) || (l == y[p] && r == x[p]))\n\t\tf[p][s][d] = add(calc(p + 1, l, r), calc(p + 1, r, l));\n\telse if (l == x[p]) f[p][s][d] = add(calc(p + 1, l, r), calc(p + 1, y[p], r));\n\telse if (l == y[p]) f[p][s][d] = add(calc(p + 1, l, r), calc(p + 1, x[p], r));\n\telse if (r == x[p]) f[p][s][d] = add(calc(p + 1, l, r), calc(p + 1, l, y[p]));\n\telse if (r == y[p]) f[p][s][d] = add(calc(p + 1, l, r), calc(p + 1, l, x[p]));\n\tvis[p][s][d] = 1;\n\treturn mul(w, f[p][s][d]);\n}\n\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) p2[i] = add(p2[i - 1], p2[i - 1]);\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= q; ++i) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tlst[i][x[i]] = i; lst[i][y[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; ++i) lst[q + 1][i] = q + 1;\n\tfor (int i = q; i >= 1; --i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (!lst[i][j]) lst[i][j] = lst[i + 1][j];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (a[i] < a[j]) ans = add(ans, calc(1, i, j));\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int P=1e9+7,inv2=5e8+4;\nint f[3100][3100],A[3100],bs,Q,n,ans;\nsigned main()\n{\n\tcin>>n>>Q;\n\tfor(int i=1;i<=n;i++) cin>>A[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(A[i]<A[j]) f[i][j]=1;\n\tfor(int w=1;w<=Q;w++)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(x==i||y==i) continue;\n\t\t\tint t1=inv2*(f[i][x]+f[i][y])%P;\n\t\t\tint t2=inv2*(f[x][i]+f[y][i])%P;\n\t\t\tf[i][x]=f[i][y]=t1;\n\t\t\tf[x][i]=f[y][i]=t2;\n\t\t}\n\t\tf[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%P;\n\t}\n\tfor(int i=bs=1;i<=Q;i++) bs=2*bs%P;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\t(ans+=bs*f[i][j])%=P;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7, i2 = (mod+1)>>1;\n\nint dp[3000][3000],a[3000];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,q;\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tdp[i][j]=1;\n\tfor(int _=1;_<=q;_++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tif(x>y)\tswap(x,y);\n\t\tint xy = dp[x][y], yx = dp[y][x];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdp[x][i]=dp[y][i]=1LL*(dp[x][i]+dp[y][i])*i2%mod;\n\t\t\tdp[i][x]=dp[i][y]=1LL*(dp[i][x]+dp[i][y])*i2%mod;\n\t\t}\n\t\tdp[x][y]=dp[y][x]=1LL*(xy+yx)*i2%mod;\n\t}\n\tlong long int ans = 0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tans+=dp[i][j];\n\tans%=mod;\n\tfor(int i=0;i<q;i++)\n\t\tans=ans*2%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\nusing namespace std;\ncs int Mod = 1e9 + 7, iv2 = (Mod+1)>>1;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\ncs int N = 3e3 + 50;\nint n, m, a[N], dp[N][N];\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++) \n\tif(a[i]<a[j]) dp[i][j]=1; int coe=1;\n\tfor(int i=1,x,y; i<=m; i++){\n\t\tscanf(\"%d%d\",&x,&y); Mul(coe,2);\n\t\tdp[x][y]=dp[y][x]=mul(iv2,add(dp[x][y],dp[y][x]));\n\t\tfor(int j=1; j<=n; j++) if(j!=x&&j!=y){\n\t\t\tdp[x][j]=dp[y][j]=mul(iv2,add(dp[x][j],dp[y][j]));\n\t\t\tdp[j][x]=dp[j][y]=mul(iv2,add(dp[j][x],dp[j][y]));\n\t\t} \n\t} \n\tint as = 0;\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<i; j++) Add(as,dp[i][j]);\n\tcout<<mul(as,coe); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3010;\nconst int p = 1e9 + 7, inv2 = (p + 1) >> 1;\nint n, a[N], m, px[N], py[N];\nint f[N][N];\ninline void A(int &x, int y) {\n    x = (x + y >= p ? x + y - p : x + y);\n}\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n    for (int i = 1; i <= m; ++i) scanf(\"%d%d\", px + i, py + i);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            f[i][j] = i < j;\n    for (int i = m; i; --i) {\n        int x = px[i], y = py[i];\n        for (int j = 1; j <= n; ++j) if (j != y && j != x) {\n            f[x][j] = f[y][j] = 1ll * (f[x][j] + f[y][j]) * inv2 % p;\n            f[j][y] = f[j][x] = 1ll * (f[j][x] + f[j][y]) * inv2 % p;\n        }\n        f[x][y] = f[y][x] = 1ll * (f[x][y] + f[y][x]) * inv2 % p;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (a[i] > a[j]) \n                A(ans, f[i][j]);\n    while (m--) A(ans, ans);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\n#define p 1000000007\n#define ll long long\nusing namespace std;\n\nint a[N],f[2][N][N][2],tag[N][N][2],n,m,l[N],r[N],bin[N];\n\ninline void get(int &x,int &y,int k)\n{\n\tif(y<=x) return;\n\tf[1][x][y][0]=(ll)f[0][x][y][0]*bin[tag[x][y][0]-k]%p;\n\tf[1][x][y][1]=(ll)f[0][x][y][1]*bin[tag[x][y][1]-k]%p;\n}\n\ninline void tt(int &x,int &y,int &k)\n{\n\ttag[x][y][0]=tag[x][y][1]=k;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;++i) scanf(\"%d%d\",&l[i],&r[i]);\n\tbin[0]=1;\n\tfor(int i=1;i<=m;++i) bin[i]=(bin[i-1]<<1)%p;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tf[0][i][j][0]=1,tag[i][j][0]=tag[i][j][1]=m+1;\n\tfor(int k=m;k;k--)\n\t{\n\t\tif(l[k]>r[k]) swap(l[k],r[k]);\n\t\tint x=l[k],y=r[k];\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tget(x,i,k+1),get(y,i,k+1),\n\t\t\tget(i,x,k+1),get(i,y,k+1);\n\t\tf[0][x][y][0]=(f[1][x][y][0]+f[1][x][y][1])%p,tt(x,y,k);\n\t\tf[0][x][y][1]=(f[1][x][y][1]+f[1][x][y][0])%p;\n\t\tfor(int j=x+1;j<=n;++j)\n\t\t\tif(j<y)\n\t\t\t\tf[0][x][j][0]=(f[1][x][j][0]+f[1][j][y][1])%p,tt(x,j,k),\n\t\t\t\tf[0][x][j][1]=(f[1][x][j][1]+f[1][j][y][0])%p;\n\t\t\telse if(j>y)\n\t\t\t\tf[0][x][j][0]=(f[1][x][j][0]+f[1][y][j][0])%p,tt(x,j,k),\n\t\t\t\tf[0][x][j][1]=(f[1][x][j][1]+f[1][y][j][1])%p;\n\t\tfor(int i=1;i<y;++i)\n\t\t\tif(i<x)\n\t\t\t\tf[0][i][y][0]=(f[1][i][y][0]+f[1][i][x][0])%p,tt(i,y,k),\n\t\t\t\tf[0][i][y][1]=(f[1][i][y][1]+f[1][i][x][1])%p;\n\t\t\telse if(i>x)\n\t\t\t\tf[0][i][y][0]=(f[1][i][y][0]+f[1][x][i][1])%p,tt(i,y,k),\n\t\t\t\tf[0][i][y][1]=(f[1][i][y][1]+f[1][x][i][0])%p;\n\t\tfor(int j=y+1;j<=n;++j)\n\t\t\tf[0][y][j][0]=(f[1][y][j][0]+f[1][x][j][0])%p,tt(y,j,k),\n\t\t\tf[0][y][j][1]=(f[1][y][j][1]+f[1][x][j][1])%p;\n\t\tfor(int i=1;i<x;++i)\n\t\t\tf[0][i][x][0]=(f[1][i][x][0]+f[1][i][y][0])%p,tt(i,x,k),\n\t\t\tf[0][i][x][1]=(f[1][i][x][1]+f[1][i][y][1])%p;\n//\t\tfor(int i=1;i<=n;++i)\n//\t\t\tfor(int j=i+1;j<=n;++j)\n//\t\t\t\tget(i,j,k),printf(\"%d %d %d %d\\n\",i,j,f[1][i][j][0],f[1][i][j][1]);\n\t}\n\tint k=1;\n\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=i+1;j<=n;++j)\n\t\t\t\tget(i,j,k);//,printf(\"%d %d %d %d\\n\",i,j,f[1][i][j][0],f[1][i][j][1]);\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(a[i]>a[j]) ans=(ans+f[1][i][j][0])%p;//,printf(\"%d %d %d\\n\",i,j,f[1][i][j][0]);\n\t\t\telse if(a[j]>a[i]) ans=(ans+f[1][i][j][1])%p;//,printf(\"%d %d %d\\n\",i,j,f[1][i][j][1]);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MN = 3030;\nconst ll M = 1e9+7;\nconst ll H = 500000004;\nll nv[MN][MN],eq[MN][MN];\nll w[MN];\nll to[MN][2];\ninline ll mul(ll a, ll b) {return (a*b)%M;}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll norm(ll v) {\n\tll res = v%M;\n\treturn res>=0?res:res+M;\n}\nint main() {\n\tll n,q;\n\tcin >> n >> q;\n\tmemset(nv,0,sizeof(nv));\n\tmemset(eq,0,sizeof(eq));\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> w[i];\n\t}\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=i;j<n;j++) {\n\t\t\tif(w[i] > w[j]) {\n\t\t\t\tnv[i][j] = 1;\n\t\t\t}\n\t\t\tif(w[i] == w[j]) {\n\t\t\t\teq[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tint p[2] = {min(a,b),max(a,b)};\n\t\tfor(int id=0;id<2;id++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tint u = min(j,p[id]);\n\t\t\t\tint v = max(j,p[id]);\n\t\t\t\tif(j >= p[0] && j <= p[1]) {\n\t\t\t\t\tto[j][id] = norm(1-eq[u][v]-nv[u][v]);\n\t\t\t\t}  else {\n\t\t\t\t\tto[j][id] = nv[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(to[p[0]][0],to[p[1]][0]);\n\t\tswap(to[p[0]][1],to[p[1]][1]);\n\t\tfor(int id=0;id<2;id++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tint u = min(j,p[id^1]);\n\t\t\t\tint v = max(j,p[id^1]);\n\t\t\t\tif(j == p[id]) {\n\t\t\t\t\tif(id == 0) {\n\t\t\t\t\t\tu = p[0];\n\t\t\t\t\t\tv = p[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnv[u][v] += to[j][id];\n\t\t\t\tif(nv[u][v] >= M) {nv[u][v] -= M;}\n\t\t\t\tnv[u][v] = mul(nv[u][v],H);\n\t\t\t}\n\t\t}\n\t\tfor(int id=0;id<2;id++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tint u = min(j,p[id]);\n\t\t\t\tint v = max(j,p[id]);\n\t\t\t\tto[j][id] = eq[u][v];\n\t\t\t}\n\t\t}\n\t\tswap(to[p[0]][0],to[p[1]][0]);\n\t\tswap(to[p[0]][1],to[p[1]][1]);\n\t\tfor(int id=0;id<2;id++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tint u = min(j,p[id^1]);\n\t\t\t\tint v = max(j,p[id^1]);\n\t\t\t\tif(j == p[id]) {\n\t\t\t\t\tif(id == 0) {\n\t\t\t\t\t\tu = p[0];\n\t\t\t\t\t\tv = p[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teq[u][v] += to[j][id];\n\t\t\t\tif(eq[u][v] >= M) {eq[u][v] -= M;}\n\t\t\t\teq[u][v] = mul(eq[u][v],H);\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tll pu = bp(2,q);\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=i+1;j<n;j++) {\n\t\t\tres += mul(pu,nv[i][j]);\n\t\t}\n\t}\n\tres %= M;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 1e9 + 7;\nconst ll inv2 = 5e8 + 4;\n\nll D[3030][3030], K[3030][3030];\nll A[3030], X[3030], Y[3030];\nll n, q, ans;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll i, j, t;\n\t\n\tcin >> n >> q;\n\t\n\tfor(i=1; i<=n; i++){\n\t\tcin >> A[i];\n\t}\n\t\n\tfor(i=1, t=1; i<=q; i++){\n\t\tcin >> X[i] >> Y[i];\n\t\tt = t * 2 % mod;\n\t}\n\t\n\tfor(i=1; i<n; i++){\n\t\tfor(j=i+1; j<=n; j++){\n\t\t\tD[i][j] = t;\n\t\t}\n\t}\n\t\n\tfor(i=q; i>=1; i--){\n\t\tfor(j=1; j<=n; j++){\n\t\t\tif(j != Y[i]){\n\t\t\t\tK[j][X[i]] = (D[j][X[i]] + D[j][Y[i]]) * inv2 % mod;\n\t\t\t\tK[X[i]][j] = (D[X[i]][j] + D[Y[i]][j]) * inv2 % mod;\n\t\t\t}\n\t\t\tif(j != X[i]){\n\t\t\t\tK[j][Y[i]] = (D[j][Y[i]] + D[j][X[i]]) * inv2 % mod;\n\t\t\t\tK[Y[i]][j] = (D[Y[i]][j] + D[X[i]][j]) * inv2 % mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(j=1; j<=n; j++){\n\t\t\tif(j != Y[i]){\n\t\t\t\tD[j][X[i]] = K[j][X[i]];\n\t\t\t\tD[X[i]][j] = K[X[i]][j];\n\t\t\t}\n\t\t\tif(j != X[i]){\n\t\t\t\tD[j][Y[i]] = K[j][Y[i]];\n\t\t\t\tD[Y[i]][j] = K[Y[i]][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tD[X[i]][Y[i]] = D[Y[i]][X[i]] = t * inv2 % mod;\n\t}\n\t\n\tfor(i=1; i<=n; i++){\n\t\tfor(j=1; j<=n; j++){\n\t\t\tif(A[i] > A[j]) ans = (ans + D[i][j]) % mod;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(3005);\nconst int mod(1e9 + 7);\nconst int inv2(500000004);\n\ninline int Add(int x, int y) {\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\n\nint f[maxn][maxn], a[maxn], n, q, p = 1;\n\nstruct Data {\n\tint a, b, c;\n};\n\nvector <Data> trs;\n\nint main() {\n\tregister int i, j, x, y, ans;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tfor (i = 1; i <= n; ++i)\n\t\tfor (j = 1; j <= n; ++j) f[i][j] = a[i] < a[j];\n\twhile (q) {\n\t\tp = p * 2 % mod, --q;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif (x > y) swap(x, y);\n\t\ttrs.clear();\n\t\tfor (i = 1; i <= n; ++i) {\n\t\t\ttrs.push_back((Data){x, i, (ll)inv2 * Add(f[x][i], f[y][i]) % mod});\n\t\t\ttrs.push_back((Data){i, x, (ll)inv2 * Add(f[i][x], f[i][y]) % mod});\n\t\t\ttrs.push_back((Data){y, i, (ll)inv2 * Add(f[x][i], f[y][i]) % mod});\n\t\t\ttrs.push_back((Data){i, y, (ll)inv2 * Add(f[i][x], f[i][y]) % mod});\n\t\t}\n\t\ttrs.push_back((Data){x, y, (ll)inv2 * Add(f[x][y], f[y][x]) % mod});\n\t\ttrs.push_back((Data){y, x, (ll)inv2 * Add(f[x][y], f[y][x]) % mod});\n\t\tfor (auto t : trs) f[t.a][t.b] = t.c;\n\t}\n\tfor (ans = 0, i = 1; i <= n; ++i)\n\t\tfor (j = i + 1; j <= n; ++j) ans = Add(ans, f[j][i]);\n\tans = (ll)ans * p % mod, printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e3 + 5, mod = 1e9 + 7;\nint n, q, a[N], dp[N][N], inv2;\n\nint binPow (int _a, int _m) {\n    int ret = 1;\n    for (; _m; _m >>= 1, _a = 1LL * _a * _a % mod) if (_m & 1) ret = 1LL * ret * _a % mod;\n    return ret;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    inv2 = binPow(2, mod - 2);\n\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) dp[i][j] = (a[i] > a[j]);\n\n    for (int _ = 0; _ < q; ++_) {\n        int x, y; cin >> x >> y;\n        int tmpX[2][N], tmpY[2][N], tmp;\n        for (int i = 1; i <= n; ++i) if (y != i) {\n            tmpX[0][i] = 1LL * inv2 * (dp[x][i] + dp[y][i]) % mod;\n            tmpX[1][i] = 1LL * inv2 * (dp[i][x] + dp[i][y]) % mod;\n        }\n        for (int i = 1; i <= n; ++i) if (x != i) {\n            tmpY[0][i] = 1LL * inv2 * (dp[y][i] + dp[x][i]) % mod;\n            tmpY[1][i] = 1LL * inv2 * (dp[i][y] + dp[i][x]) % mod;\n        }\n        tmp = 1LL * inv2 * (dp[x][y] + dp[y][x]) % mod;\n\n        dp[x][y] = dp[y][x] = tmp;\n        for (int i = 1; i <= n; ++i) if (y != i) dp[x][i] = tmpX[0][i], dp[i][x] = tmpX[1][i];\n        for (int i = 1; i <= n; ++i) if (x != i) dp[y][i] = tmpY[0][i], dp[i][y] = tmpY[1][i];\n    }\n\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = i + 1; j <= n; ++j) ans = (ans + dp[i][j]) % mod;\n    }\n    while (q --) { ans = 2 * ans % mod; }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nint main(){\n\tint n,m,a,b;cin>>n>>m>>a>>b;\n\tbool f=false;\n\tint aa=0,bb=0;\n\tif(n*m<2*(a+b))f=true;\n\tif(n%2){\n\t\tint k=min(m/2,a);\n\t\ta-=k;\n\t\taa+=k;\n\t}\n\tif(m%2){\n\t\tint k=min(n/2,b);\n\t\tb-=k;\n\t\tbb+=k;\n\t}\n\tif(a/2+b/2+a%2+b%2>(n/2)*(m/2))f=true;\n\tif(f){\n\t\tcout<<\"NO\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<\"YES\"<<endl;\n\tvector<string> c(n);\n\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)c[i].push_back('.');\n\tfor(int i=0;i<n/2;i++){\n\t\tfor(int j=0;j<m/2;j++){\n\t\t\tint y=i*2,x=j*2;\n\t\t\tif(a>0){\n\t\t\t\tc[y][x]='<';\n\t\t\t\tc[y][x+1]='>';\n\t\t\t\ta--;\n\t\t\t\tif(a>0){\n\t\t\t\t\tc[y+1][x]='<';\n\t\t\t\t\tc[y+1][x+1]='>';\n\t\t\t\t\ta--;\n\t\t\t\t}\n\t\t\t}else if(b>0){\n\t\t\t\tc[y][x]='^';\n\t\t\t\tc[y+1][x]='v';\n\t\t\t\tb--;\n\t\t\t\tif(b>0){\n\t\t\t\t\tc[y][x+1]='^';\n\t\t\t\t\tc[y+1][x+1]='v';\n\t\t\t\t\tb--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(a==0);\n\tassert(b==0);\n\tif(aa){\n\t\tfor(int i=0;i<m/2;i++){\n\t\t\tif(aa>0){\n\t\t\t\tc[n-1][i*2]='<';\n\t\t\t\tc[n-1][i*2+1]='>';\n\t\t\t\taa--;\n\t\t\t}\n\t\t}\n\t}\n\tif(bb){\n\t\tfor(int i=0;i<n/2;i++){\n\t\t\tif(bb>0){\n\t\t\t\tc[i*2][m-1]='^';\n\t\t\t\tc[i*2+1][m-1]='v';\n\t\t\t\tbb--;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)cout<<c[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 120\n\nconst int mod= 1e9+7;\n\nlong long int dp[maxn][maxn][maxn];\nlong long int pw2[maxn];\nint A[maxn];\nint X[maxn], Y[maxn];\n\n\nint main(){\n\tpw2[0]=1;\n\tfor (int i=1; i<maxn; i++) pw2[i]= (pw2[i-1]+pw2[i-1])%mod;\n\tint n, q;\n\tcin>>n>>q;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\t\n\tfor (int i=1; i<=q; i++){\n\t\tcin>>X[i]>>Y[i];\n\t\tif (X[i]>Y[i]) swap(X[i], Y[i]);\n\t}\n\tfor (int i=1; i<=q; i++) assert(X[i]<Y[i]);\n\n\tfor (int i=1; i<=n; i++){\n\t\tfor (int j=1; j<=n; j++){\n\t\t\tdp[q][i][j]=2;\n\t\t}\n\t}\n\tfor (int i=X[q]+1; i<Y[q]; i++) dp[q][i][X[q]]--;\n\tfor (int i=X[q]+1; i<Y[q]; i++) dp[q][Y[q]][i]--;\n\tdp[q][Y[q]][X[q]]--;\n\tfor (int k=q-1; k>=1; k--){\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tfor (int j=1; j<i; j++){\n\t\t\t\tif (i==j) continue;\n\t\t\t\tdp[k][i][j]= dp[k+1][i][j];\n\t\t\t\tint x=i, y=j;\n\t\t\t\tif (x==X[k]) x=Y[k];\n\t\t\t\telse if (x==Y[k]) x=X[k];\n\t\t\t\tif (y==X[k]) y=Y[k];\n\t\t\t\telse if (y==Y[k]) y=X[k];\n\t\t\t\tassert(x!=y);\n\n\t\t\t\tif (x>y) {\n\t\t\t\t\tdp[k][i][j]= (dp[k][i][j]+dp[k+1][x][y])%mod;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[k][i][j]= (dp[k][i][j]+pw2[q-k]-dp[k+1][y][x])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans=0LL;\n\tfor (int i=1; i<=n; i++){\n\t\tfor (int j=1; j<i; j++){\n\t\t\tif (A[i]<A[j]) ans= (ans+dp[1][i][j])%mod;\n\t\t\telse if (A[i]>A[j]) ans= (ans+pw2[q]-dp[1][i][j])%mod;\n\t\t}\n\t}\t\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 1000000007\n#define INV 500000004\nusing namespace std;\nlong long f[3005][3005],g[3005],h[3005];\nint a[3005];\nint main()\n{\n int n,q;\n cin>>n>>q;\n for(int i=1;i<=n;i++)\n  cin>>a[i];\n for(int i=1;i<=n;i++)\n  for(int j=1;j<=n;j++)\n   if(a[i]>a[j])f[i][j]=1;\n long long ans=0,tmp=1;\n while(q--)\n {\n  int x,y;\n  cin>>x>>y;\n  for(int i=1;i<=n;i++)\n  {\n   g[i]=(f[x][i]+f[y][i])*INV%MOD;\n   h[i]=(f[i][x]+f[i][y])*INV%MOD;\n  }\n  for(int i=1;i<=n;i++)\n  {\n   f[x][i]=f[y][i]=g[i];\n   f[i][x]=f[i][y]=h[i];\n  }\n  tmp=tmp*2%MOD;\n  f[x][x]=f[y][y]=0;\n  f[x][y]=f[y][x]=(f[x][y]+f[y][x])%MOD;\n }\n for(int i=1;i<=n;i++)\n  for(int j=i+1;j<=n;j++)\n   ans=(ans+f[i][j])%MOD;\n cout<<ans*tmp%MOD<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\nconst LL Mod = 1000000007LL;\nconst LL iv2 = (Mod+1)/2;\n\nint N,Q; \nint a[MAXN+1]; LL f[3010][3010];\ninline void Add(LL &x,LL y){ x=(x+y>=Mod?x+y-Mod:x+y); }\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(),Q=read(); LL ret=1;\n\tfor(int i=1;i<=N;i++) a[i]=read();\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=i+1;j<=N;j++){\n\t\t\tif(a[i]>a[j]) f[i][j]=1;\n\t\t\telse if(a[i]<a[j]) f[j][i]=1;\n\t\t}\n\tfor(int i=1;i<=Q;i++){\n\t\tret=ret*2%Mod;\n\t\tint x=read(),y=read();\n\t\tif(x==y) continue;\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tLL jy=f[j][y],yj=f[y][j],jx=f[j][x],xj=f[x][j];\n\t\t\tif(j!=x) { Add(f[j][x],jy); Add(f[x][j],yj); }\n\t\t\tif(j!=y) { Add(f[j][y],jx); Add(f[y][j],xj); }\n\t\t} \n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(j!=x) {\n\t\t\t\tf[j][y]=f[j][y]*iv2%Mod;\n\t\t\t\tf[y][j]=f[y][j]*iv2%Mod;\n\t\t\t}if(j!=y) {\n\t\t\t\tf[j][x]=f[j][x]*iv2%Mod;\n\t\t\t\tf[x][j]=f[x][j]*iv2%Mod;\n\t\t\t}\n\t\t}\n\t\tLL s=f[x][y]+f[y][x]; s=s*iv2%Mod;\n\t\tf[x][y]=f[y][x]=s%Mod;\n\t} LL ans=0;\n\tfor(int i=1;i<=N;i++) for(int j=i+1;j<=N;j++) Add(ans,f[i][j]);\n\tprintf(\"%lld\\n\",ans*ret%Mod);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (3006)\nll n, q, A[MAXN], X[MAXN], Y[MAXN], mod=1e9+7, dp[MAXN][MAXN];\nll qexp(ll x,ll e){ll sum=1;for(;e;e>>=1,x*=x,x%=mod)if(e&1)sum*=x,sum%=mod;return sum;}\nint main(){\n\tFAST\n\tcin>>n>>q;\n\tFOR(i,1,n)cin>>A[i];\n\tFOR(i,1,q)cin>>X[i]>>Y[i];\n\tll inv=qexp(2,mod-2);\n\tFOR(i,1,n)FOR(j,1,n){\n\t\tdp[i][j] = (A[i] > A[j]);\n\t}\n\tFOR(i,1,q){\n\t\tFOR(j,1,n)if(j^X[i])if(j^Y[i]){\n\t\t\tll jX=dp[j][X[i]], Xj=dp[X[i]][j], jY=dp[j][Y[i]], Yj=dp[Y[i]][j];\n\t\t\tdp[j][X[i]] *= inv, dp[j][X[i]] %= mod, dp[j][X[i]] += jY * inv % mod, dp[j][X[i]]%=mod;\n\t\t\tdp[X[i]][j] *= inv, dp[X[i]][j] %= mod, dp[X[i]][j] += Yj * inv % mod, dp[X[i]][j]%=mod;\n\t\t\tdp[j][Y[i]] *= inv, dp[j][Y[i]] %= mod, dp[j][Y[i]] += jX * inv % mod, dp[j][Y[i]]%=mod;\n\t\t\tdp[Y[i]][j] *= inv, dp[Y[i]][j] %= mod, dp[Y[i]][j] += Xj * inv % mod, dp[Y[i]][j]%=mod;\n\t\t}\n\t\tll XY=dp[X[i]][Y[i]],YX=dp[Y[i]][X[i]];\n\t\tdp[X[i]][Y[i]] *= inv, dp[X[i]][Y[i]] %= mod, dp[X[i]][Y[i]] += YX * inv % mod, dp[X[i]][Y[i]]%=mod;\n\t\tdp[Y[i]][X[i]] *= inv, dp[Y[i]][X[i]] %= mod, dp[Y[i]][X[i]] += XY * inv % mod, dp[Y[i]][X[i]]%=mod;\n\t}\n\tll ans = 0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans += dp[i][j], ans %= mod;\n\tans *= qexp(2, q), ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 3030;\nconst int mod = 1e9 + 7;\ntypedef long long ll;\ninline void reduce(int & x){\n\tx += x >> 31 & mod;\n}\nint n,q,a[maxn];\nint dp[maxn][maxn];\nint tm[maxn][maxn];\nint dp2[maxn][maxn];\nint pw[maxn];\nint now;\ninline void down(int x,int y){\n\tif(tm[x][y] != now){\n\t\tdp[x][y] = (ll) dp[x][y] * pw[now - tm[x][y]] % mod;\n\t\ttm[x][y] = now;\n\t}\n}\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n >> q;\n\t*pw = 1;\n\tfor(int i = 1;i < maxn;++i) pw[i] = pw[i - 1] * 2 % mod;\n\tfor(int i = 1;i <= n;++i) std::cin >> a[i];\n\tfor(int i = 1;i <= n;++i) for(int j = 1;j <= n;++j) dp[i][j] = a[i] > a[j];\n\tfor(int i = 1,x,y;i <= q;++i){\n\t\tstd::cin >> x >> y;\n\t\tfor(int i = 1;i <= n;++i) {\n\t\t\tdown(i,x); down(i,y), down(x,i); down(y,i);\n\t\t\tdp2[i][x] = dp[i][x], dp2[i][y] = dp[i][y];\n\t\t\tdp2[x][i] = dp[x][i], dp2[y][i] = dp[y][i];\n\t\t}\n\t\tfor(int i = 1;i <= n;++i) if(i != x && i != y){\n\t\t\treduce(dp2[i][x] += dp[i][y] - mod);\n\t\t\treduce(dp2[x][i] += dp[y][i] - mod);\n\t\t\treduce(dp2[i][y] += dp[i][x] - mod);\n\t\t\treduce(dp2[y][i] += dp[x][i] - mod);\n\t\t}\n\t\tdp2[x][y] = dp2[y][x] = (dp2[x][y] + dp2[y][x]) % mod;\n\t\tnow = i;\n\t\tfor(int i = 1;i <= n;++i) {\n\t\t\tdp[i][x] = dp2[i][x], dp[i][y] = dp2[i][y];\n\t\t\tdp[x][i] = dp2[x][i], dp[y][i] = dp2[y][i];\n\t\t\ttm[i][x] = tm[i][y] = tm[x][i] = tm[y][i] = now;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1;i <= n;++i) for(int j = i + 1;j <= n;++j) {\n\t\tdown(i,j), reduce(ans += dp[i][j] - mod);\n\t}\n\tstd::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#define mod 1000000007\n#define inv2 500000004\nusing namespace std;\nint add(int a,int b){a+=b; return a>=mod?a-mod:a;}\nint sub(int a,int b){a-=b; return a<0?a+mod:a;}\nint mul(int a,int b){return 1ll*a*b%mod;}\nint ksm(int a,int b)\n{\n    int s=1;\n    for(;b;b>>=1,a=mul(a,a))\n        if(b&1) s=mul(s,a);\n    return s;\n}\nint f[3005][3005][2];\nint A[3005],tx[3005],ty[3005],t1[3000][2],t2[3000][2];\nint n,m;\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&A[i]);\n    for(int i=1;i<=m;i++) scanf(\"%d %d\",&tx[i],&ty[i]);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(A[i]>A[j]) f[i][j][0]=1;\n            else if(A[i]==A[j]) f[i][j][1]=1;\n    for(int i=1;i<=m;i++)\n    {\n        if(tx[i]>ty[i]) swap(tx[i],ty[i]);\n        for(int j=1;j<=tx[i];j++) t1[j][0]=f[j][tx[i]][0],t1[j][1]=f[j][tx[i]][1];\n        for(int j=tx[i]+1;j<=n;j++) t1[j][0]=f[tx[i]][j][0],t1[j][1]=f[tx[i]][j][1];\n        for(int j=1;j<=ty[i];j++) t2[j][0]=f[j][ty[i]][0],t2[j][1]=f[j][ty[i]][1];\n        for(int j=ty[i]+1;j<=n;j++) t2[j][0]=f[ty[i]][j][0],t2[j][1]=f[ty[i]][j][1];\n\n        for(int j=1;j<tx[i];j++)\n        {\n            f[j][tx[i]][0]=mul(inv2,add(f[j][tx[i]][0],t2[j][0]));\n            f[j][tx[i]][1]=mul(inv2,add(f[j][tx[i]][1],t2[j][1]));\n        }\n        for(int j=tx[i]+1;j<ty[i];j++)\n        {\n            f[tx[i]][j][0]=mul(inv2,add(f[tx[i]][j][0],sub(1,add(t2[j][0],t2[j][1]))));\n            f[tx[i]][j][1]=mul(inv2,add(f[tx[i]][j][1],t2[j][1]));\n        }\n        for(int j=ty[i]+1;j<=n;j++)\n        {\n            f[tx[i]][j][0]=mul(inv2,add(f[tx[i]][j][0],t2[j][0]));\n            f[tx[i]][j][1]=mul(inv2,add(f[tx[i]][j][1],t2[j][1]));\n        }\n\n        for(int j=1;j<tx[i];j++)\n        {\n            f[j][ty[i]][0]=mul(inv2,add(f[j][ty[i]][0],t1[j][0]));\n            f[j][ty[i]][1]=mul(inv2,add(f[j][ty[i]][1],t1[j][1]));\n        }\n        for(int j=tx[i]+1;j<ty[i];j++)\n        {\n            f[j][ty[i]][0]=mul(inv2,add(f[j][ty[i]][0],sub(1,add(t1[j][0],t1[j][1]))));\n            f[j][ty[i]][1]=mul(inv2,add(f[j][ty[i]][1],t1[j][1]));\n        }\n        for(int j=ty[i]+1;j<=n;j++)\n        {\n            f[ty[i]][j][0]=mul(inv2,add(f[ty[i]][j][0],t1[j][0]));\n            f[ty[i]][j][1]=mul(inv2,add(f[ty[i]][j][1],t1[j][1]));\n        }\n        f[tx[i]][ty[i]][0]=mul(inv2,add(f[tx[i]][ty[i]][0],sub(1,add(f[tx[i]][ty[i]][0],f[tx[i]][ty[i]][1]))));\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            ans=add(ans,mul(ksm(2,m),f[i][j][0]));\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=3010,Mod=1e9+7,INV2=500000004;\nint n,Q,a[N],f[N][N];\n\nint main()\n{\n\tn=gi();Q=gi();int pw=1;\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)f[i][j]=(a[i]<a[j]);\n\twhile(Q--)\n\t{\n\t\tint x=gi(),y=gi();pw=2ll*pw%Mod;\n\t\tf[x][y]=f[y][x]=1ll*INV2*(f[x][y]+f[y][x])%Mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(x!=i&&i!=y)\n\t\t\t{\n\t\t\t\tf[x][i]=f[y][i]=1ll*INV2*(f[x][i]+f[y][i])%Mod;\n\t\t\t\tf[i][x]=f[i][y]=1ll*INV2*(f[i][x]+f[i][y])%Mod;\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)ans=(ans+f[i][j])%Mod;\n\tprintf(\"%d\\n\",ans*pw%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,q,i,j,a[3005],f[3005][3005],g[3005][3005],x,y,flag,cm,ans;\nint add(int u,int v){\n\treturn u+v>=mo?u+v-mo:u+v;\n}\nint main(){\n\tn=read();q=read();\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tf[i][j]=1;\n\tcm=1;\n\twhile(q--){\n\t\tx=read();y=read();\n\t\tfor(i=1;i<=n;i++){\n\t\t\tflag=add(f[i][x],f[i][y]);\n\t\t\tif(i!=y)\n\t\t\t\tg[i][y]=add(g[i][y],flag);\n\t\t\tif(i!=x)\n\t\t\t\tg[i][x]=add(g[i][x],flag);\n\t\t\tflag=add(f[x][i],f[y][i]);\n\t\t\tif(i!=y)\n\t\t\t\tg[y][i]=add(g[y][i],flag);\n\t\t\tif(i!=x)\n\t\t\t\tg[x][i]=add(g[x][i],flag);\n\t\t}\n\t\tcm=cm*2%mo;\n\t\tg[x][y]=add(f[x][y],f[y][x]);\n\t\tg[y][x]=g[x][y];\n\t\tfor(i=1;i<=n;i++){\n\t\t\tf[i][y]=1LL*g[i][y]*500000004%mo;\n\t\t\tf[y][i]=1LL*g[y][i]*500000004%mo;\n\t\t\tf[i][x]=1LL*g[i][x]*500000004%mo;\n\t\t\tf[x][i]=1LL*g[x][i]*500000004%mo;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tg[i][y]=0;\n\t\t\tg[y][i]=0;\n\t\t\tg[i][x]=0;\n\t\t\tg[x][i]=0;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tans=add(ans,f[i][j]);\n\tans=1LL*ans*cm%mo;\n\tpus(ans,2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=3e3+100;\nconst int mod=1e9+7;\nint f[maxn][maxn],a[maxn];\nint ksm(int num,int t){\n    int res=1;\n    for(;t;t>>=1,num=1ll*num*num%mod){\n        if(t&1)res=1ll*num*res%mod;\n    }\n    return res;\n}\nint main(){\n    int n,q;cin>>n>>q;\n    rep(i,1,n)cin>>a[i];\n    rep(i,1,n)rep(j,1,n)f[i][j]=a[i]<a[j];\n    ll inv2=ksm(2,mod-2);\n    rep(i,1,q){\n        int x,y;cin>>x>>y;\n        f[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%mod;\n        rep(j,1,n){\n            if(j==x||j==y)continue;\n            f[x][j]=f[y][j]=inv2*(f[x][j]+f[y][j])%mod;\n            f[j][x]=f[j][y]=inv2*(f[j][x]+f[j][y])%mod;\n        }\n    }\n    ll last=0;rep(i,1,n)rep(j,1,i-1)last=(last+f[i][j])%mod;\n    cout<<last*ksm(2,q)%mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 3005\n#define inv 500000004\n#define mod 1000000007\n\nusing namespace std;\n\nint n,q,a[maxn];\nint dp[maxn][maxn];\n\n\nsigned main()\n{\n\t\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++)\tcin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]>a[j])\tdp[i][j]=1;\n\tfor(int i=1,x,y;i<=q;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tdp[x][y]=dp[y][x]=inv*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x || j==y)\tcontinue;\n\t\t\tdp[x][j]=dp[y][j]=(inv*dp[x][j]+inv*dp[y][j])%mod;\n\t\t\tdp[j][x]=dp[j][y]=(inv*dp[j][x]+inv*dp[j][y])%mod;\n\t\t}\n\t}\n\tint now=1,ans=0;\n\tfor(int i=1;i<=q;i++)\n\t\t(now*=2)%=mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\t(ans+=dp[i][j])%=mod;\n\tcout<<ans*now%mod<<endl;\n\t\t\t\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst long long MOD = 1000000007;\nconst int MAX = 3000 + 10;\n\nint n, m;\n\nlong long dpb[MAX][MAX];\nlong long dps[MAX][MAX];\nlong long tmpxb[MAX];\nlong long tmpxs[MAX];\nlong long tmpyb[MAX];\nlong long tmpys[MAX];\nlong long lazy[MAX];\n\nint rec[MAX];\n\nvoid update(int x) {\n    for(int i = 0 ; i < n ; i++) {\n        dpb[x][i] *= lazy[x];\n        dpb[x][i] %= MOD;\n        dps[x][i] *= lazy[x];\n        dps[x][i] %= MOD;\n    }\n    lazy[x] = 1LL;\n}\n\nlong long inv(int x) {\n    if(x == 1) return 2LL;\n    long long tmp = inv(x/2);\n    if(x&1) return tmp * tmp % MOD * 2 % MOD;\n    return tmp * tmp % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for(int i = 0 ; i < n ; i++) {\n        scanf(\"%d\", &rec[i]);\n    }\n\n    long long ans = 0;\n\n    for(int i = 0 ; i < n ; i++) {\n        lazy[i] = 1LL;\n        for(int j = 0 ; j < n ; j++) {\n            if (rec[j] < rec[i]) {\n                dps[i][j]++;\n                if (j > i) {\n                    ans++;\n                }\n            } else if (rec[j] > rec[i]) {\n                dpb[i][j]++;\n            }\n        }\n    }\n    \n    long long INV = inv(MOD-2);\n\n    while (m--) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--, y--;\n        update(x);\n        update(y);\n        if (x > y) swap(x, y);\n\n        ans *= 2;\n        ans %= MOD;\n        \n        for(int i = x+1 ; i <= y ; i++) {\n            ans += dpb[x][i] - dps[x][i];\n            ans %= MOD;\n        }\n\n        for(int i = x+1 ; i < y ; i++) {\n            ans += dps[y][i] - dpb[y][i];\n            ans %= MOD;\n        }\n\n        for(int i = 0 ; i < n ; i++) {\n            tmpxs[i] = dps[x][i];\n            tmpxb[i] = dpb[x][i];\n            tmpys[i] = dps[y][i];\n            tmpyb[i] = dpb[y][i];\n        }\n\n        swap(tmpxs[x], tmpxs[y]);\n        swap(tmpxb[x], tmpxb[y]);\n        swap(tmpys[y], tmpys[x]);\n        swap(tmpyb[y], tmpyb[x]);\n\n        for(int i = 0 ; i < n ; i++) {\n            dps[x][i] += tmpys[i];\n            dps[x][i] %= MOD;\n            dpb[x][i] += tmpyb[i];\n            dpb[x][i] %= MOD;\n            dps[y][i] += tmpxs[i];\n            dps[y][i] %= MOD;\n            dpb[y][i] += tmpxb[i];\n            dpb[y][i] %= MOD;\n        }\n\n        for(int i = 0 ; i < n ; i++) {\n            if(i == x || i == y) continue;\n            lazy[i] *= 2;\n            lazy[i] %= MOD;\n\n            long tmp = dpb[i][x];\n            dpb[i][x] += dpb[i][y];\n            dpb[i][y] += tmp;\n            dpb[i][x] *= INV;\n            dpb[i][x] %= MOD;\n            dpb[i][y] *= INV;\n            dpb[i][y] %= MOD;\n\n            tmp = dps[i][x];\n            dps[i][x] += dps[i][y];\n            dps[i][y] += tmp;\n            dps[i][x] *= INV;\n            dps[i][x] %= MOD;\n            dps[i][y] *= INV;\n            dps[i][y] %= MOD;\n        }\n    }\n    \n    ans = ((ans % MOD) + MOD) % MOD;\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nint a[3005];\nll power(ll n,ll x){\n    ll sp=1ll;\n    while(x){\n        if(x&1) sp=sp*n%mod;\n        n=n*n%mod;x>>=1;\n    }return sp;\n}\nll inv=(mod+1)>>1,base,ans;\nll dp[3005][3005];\nint n,m;\nint main(){\n    scanf(\"%d%d\",&n,&m);base=power(2,m);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n    dp[i][j]=(a[i]<a[j]);\n    while(m--){\n        ll l,r;scanf(\"%d%d\",&l,&r);\n        dp[l][r]=dp[r][l]=(dp[l][r]+dp[r][l])*inv%mod;\n        for(int i=1;i<=n;i++)\n        if(i!=l&&i!=r){\n            dp[i][l]=dp[i][r]=(dp[i][l]+dp[i][r])*inv%mod;\n            dp[l][i]=dp[r][i]=(dp[l][i]+dp[r][i])*inv%mod;\n        }\n    }\n    ans=0;\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<i;j++)\n    (ans+=dp[i][j])%=mod;\n    printf(\"%lld\",ans*base%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n\n  vvl dp = VV(n+1, n+1, 1, ll);\n  vvl rev = VV(n+1, n+1, 1, ll);\n  vll ml(n+1, 1);\n  vll mlrev(n+1, 1);\n\n  for(auto v:query){\n    vvl tmp; //i, j, flip or not, num\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    tmp.push_back(vll{x, y, 1, dp[x][y]});\n    tmp.push_back(vll{x, y, 0, rev[x][y]});\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(i<x){\n        tmp.push_back(vll{i, x, 1, rev[i][y]});\n        tmp.push_back(vll{i, x, 0, dp[i][y]});\n      }else if(y<i){\n        tmp.push_back(vll{x, i, 1, rev[y][i]});\n        tmp.push_back(vll{x, i, 0, dp[y][i]});\n      }else{\n        tmp.push_back(vll{x, i, 1, rev[i][y]});\n        tmp.push_back(vll{x, i, 0, dp[i][y]});\n      }\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(y<i){\n        tmp.push_back(vll{y, i, 1, rev[x][i]});\n        tmp.push_back(vll{y, i, 0, dp[x][i]});\n      }else if(i<x){\n        tmp.push_back(vll{i, y, 1, rev[i][x]});\n        tmp.push_back(vll{i, y, 0, dp[i][x]});\n      }else{\n        tmp.push_back(vll{i, y, 1, rev[x][i]});\n        tmp.push_back(vll{i, y, 0, dp[x][i]});\n      }\n    }\n\n    for(auto ad:tmp){\n      if(ad[2]==1) rev[ad[0]][ad[1]] = (rev[ad[0]][ad[1]]+ad[3])%P;\n      else dp[ad[0]][ad[1]] = (dp[ad[0]][ad[1]]+ad[3])%P;\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(a[i]<a[j]) ans = (ans + rev[i][j])%P;\n      if(a[i]>a[j]) ans = (ans + dp[i][j])%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int _ = 3e3 + 5, p = 1e9 + 7;\n\nint n, m, a[_], dp[_][_];\n\ninline int power(int x, int k) {\n    int res = 1;\n    for (; k; k >>= 1, x = 1ll * x * x % p)\n        if (k & 1) res = 1ll * res * x % p;\n    return res % p;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) dp[i][j] = a[i] < a[j];\n    int inv2 = power(2, p - 2);\n    for (int x, y, i = 1; i <= m; ++i) {\n        scanf(\"%d %d\", &x, &y);\n        dp[x][y] = dp[y][x] = 1ll * inv2 * ((dp[x][y] + dp[y][x]) % p) % p;\n        for (int j = 1; j <= n; ++j) {\n            if (j == x | j == y) continue ;\n            dp[x][j] = dp[y][j] = 1ll * inv2 * ((dp[x][j] + dp[y][j]) % p) % p;\n            dp[j][x] = dp[j][y] = 1ll * inv2 * ((dp[j][x] + dp[j][y]) % p) % p;\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) ans = (ans + dp[i][j]) % p;\n    ans = 1ll * ans * power(2, m) % p;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n//aass"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){\n\t\tret *= x;\n\t\tret %= M;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tll n,q;\n\tll a[3002];\n\tscanf(\"%lld%lld\",&n,&q);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\t\n\tstatic ll dp[3002][3002] = {};\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 1 ; j <= n ; j ++){\n\t\t\tif(a[i] < a[j])dp[i][j] ++;\n\t\t}\n\t}\n\t\n\tll div2 = modpow(2,M-2);\n\tfor(int t = 0 ; t < q ; t ++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\tif(i == x || i == y)continue;\n\t\t\tdp[i][x] = (dp[i][x]+dp[i][y])*div2;\n\t\t\tdp[i][x] %= M;\n\t\t\tdp[i][y] = dp[i][x];\n\t\t\tdp[x][i] = (dp[x][i]+dp[y][i])*div2;\n\t\t\tdp[x][i] %= M;\n\t\t\tdp[y][i] = dp[x][i];\n\t\t}\n\t\tdp[x][y] = (dp[x][y]+dp[y][x])*div2;\n\t\tdp[x][y] %= M;\n\t\tdp[y][x] = dp[x][y];\n\t\t\n\t\t/*for(int i = 1;  i <= n ; i ++){\n\t\t\tfor(int j = 1 ; j <= n ; j ++){\n\t\t\t\tprintf(\"%lld \",dp[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n\tll ret = 0;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 1 ; j < i ; j ++){\n\t\t\tret += dp[i][j];\n\t\t\tif(ret > M)ret -= M;\n\t\t}\n\t}\n\tret *= modpow(2,q);\n\tcout << ret%M << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int N = 3003;\nconst int mod = 1e9 + 7;\nint a[N];\nunsigned long long dp[2][N][N];\n\nvoid MOD(unsigned long long &x)\n{\n    if (x >= mod)\n        x %= mod;\n}\n\nint mpow(int b, int e)\n{\n    if (e == 0)\n        return 1;\n    int res = mpow(b, e / 2);\n    res = (res * 1LL * res) % mod;\n    if (e & 1)\n        res = (res * 1LL * b) % mod;\n    return res;\n}\n\nint main()\n{\n    int n, q, x, y, i, j;\n    bool t = 0;\n    long long inv2 = mpow(2, mod - 2);\n    cin >> n >> q;\n    long long den = mpow(2, q);\n\n    for (i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            dp[t][i][j] = a[i] > a[j] ? 1 : 0;\n        }\n    }\n\n    while (q--)\n    {\n        cin >> x >> y;\n        x--, y--;\n        MOD(dp[t][x][y] = inv2 * (dp[t][x][y] + dp[t][y][x]));\n        dp[t][y][x] = dp[t][x][y];\n\n        for (i = 0; i < n; i++)\n        {\n            if (i == y or i == x)\n                continue;\n\n            MOD(dp[t][x][i] = inv2 * (dp[t][x][i] + dp[t][y][i]));\n            dp[t][y][i] = dp[t][x][i];\n\n            MOD(dp[t][i][x] = inv2 * (dp[t][i][y] + dp[t][i][x]));\n            dp[t][i][y] = dp[t][i][x];\n        }\n\n        t = t;\n    }\n\n    unsigned long long ans = 0;\n    for (i = 0; i < n; i++)\n    {\n        for (j = i + 1; j < n; j++)\n        {\n            MOD(ans += dp[t][i][j]);\n        }\n    }\n\n    MOD(ans = ans * den);\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\n\nconst int mod = 1e9 + 7, inv2 = mod + 1 >> 1;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (li)x * y % mod; }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\n// ----------------------------------------\n\nconst int maxn = 3000;\n\nint n, q;\nint origin[maxn];\nint p[maxn][maxn];\n\nvoid Change(int x, int y) {\n  p[x][y] = p[y][x] = Mul(Add(p[x][y] + p[y][x]), inv2);\n  for (int z = 0; z < n; ++z) {\n    if (z == x || z == y) continue;\n    int p1 = Mul(Add(p[x][z] + p[y][z]), inv2);\n    int p2 = Mul(Add(p[z][x] + p[z][y]), inv2);\n    p[x][z] = p[y][z] = p1;\n    p[z][x] = p[z][y] = p2;\n  }\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", origin + i);\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      p[i][j] = origin[i] < origin[j];\n    }\n  }\n\n  for (int i = 0; i < q; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x; --y;\n    Change(x, y);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      Add(ans, p[j][i]);\n    }\n  }\n  ans = Mul(ans, Pow(2, q));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mo = 1e9 + 7;\n#define inv2 500000004ll\ntypedef long long LL;\nconst int MAXN = 3e3 + 10;\nint a[MAXN], f[MAXN][MAXN];\ntemplate <class T>\ninline void _read(T &x)\n{\n\tx = 0;\n\tchar t = getchar();\n\twhile(!isdigit(t)) t = getchar();\n\twhile(isdigit(t))\n\t{\n\t\tx = x * 10 + t - '0';\n\t\tt = getchar();\n\t}\n}\ntypedef long long ll;\ninline ll fpm(ll a, ll b)\n{\n\tll res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) res = 1ll * res * a % mo;\n\t\ta = 1ll * a * a % mo;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\nint n, q;\nint main()\n{\n\t_read(n), _read(q);\n\tfor(int i = 1; i <= n; ++i) _read(a[i]);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tf[i][j] = a[i] < a[j];\n\tfor(int i = 1; i <= q; ++i)\n\t{\n\t\tint x, y;\n\t\t_read(x), _read(y);\n\t\tf[x][y] = f[y][x] = inv2 * (f[x][y] + f[y][x]) % mo;\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(j != x && j != y)\n\t\t\t\tf[j][x] = f[j][y] = inv2 * (f[j][x] + f[j][y]) % mo, f[x][j] = f[y][j] = inv2 * (f[x][j] + f[y][j]) % mo;\n//\t\tcout << \"&*(@&*#)\" << endl;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j < i; ++j) ans += f[i][j];\n//\tcout << q << endl;\n\tprintf(\"%lld\\n\", 1ll * ans % mo * fpm(2, q) % mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 3005;\nconst ll MOD = 1000000007;\n\nint n,q;\nint a[MAXN];\n\nll ans;\nll f[MAXN][MAXN];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> q;\n\tfor (int i = 1;i <= n;i++)\n\t\tcin >> a[i];\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = 1;j <= n;j++)\n\t\t\tif (a[i] > a[j])\n\t\t\t\tf[i][j] = 1;\n\tfor (int x,y,i = 1;i <= q;i++)\n\t{\n\t\tcin >> x >> y;\n\t\tfor (int j = 1;j <= n;j++)\n\t\t{\n\t\t\tif (j == x || j == y)\n\t\t\t\tcontinue;\n\t\t\tf[j][x] = f[j][y] = (f[j][x] + f[j][y]) * ((MOD + 1) / 2) % MOD;\n\t\t}\n\t\tfor (int j = 1;j <= n;j++)\n\t\t{\n\t\t\tif (j == x || j == y)\n\t\t\t\tcontinue;\n\t\t\tf[x][j] = f[y][j] = (f[x][j] + f[y][j]) * ((MOD + 1) / 2) % MOD;\n\t\t}\n\t\tf[x][y] = f[y][x] = (f[x][y] + f[y][x]) * ((MOD + 1) / 2) % MOD;\n\t}\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = i + 1;j <= n;j++)\n\t\t\t(ans += f[i][j]) %= MOD;\n\tfor (int i = 1;i <= q;i++)\n\t\t(ans *= 2) %= MOD;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\tfix(s+=s);\n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tint ix=f[i][x],iy=f[i][y];\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=3005,P=1e9+7;\nconst long long I=5e8+4;\nint n,q,v[N],f[N][N],a;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&v[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(v[i]>v[j])++f[i][j];\n\t\t\telse if(v[i]<v[j])++f[j][i];\n\tfor(int i=1,x,y;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;++j)if(j!=x&&j!=y)\n\t\t\tf[x][j]=f[y][j]=I*(f[x][j]+f[y][j])%P,f[j][x]=f[j][y]=I*(f[j][x]+f[j][y])%P;\n\t\tf[x][y]=f[y][x]=I*(f[x][y]+f[y][x])%P;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\t(a+=f[i][j])%=P;\n\tfor(int i=1;i<=q;++i)(a*=2)%=P;\n\treturn printf(\"%d\",a),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nconst long long mod = 1000000007;\nconst long long inv2 = (mod + 1) / 2;\n\nint N,Q,A[3030],C[3030][3030];\n\nint main()\n{\n\tscanf (\"%d %d\",&N,&Q);\n\n\tfor (int i=1;i<=N;i++) scanf (\"%d\",&A[i]);\n\tfor (int i=1;i<=N;i++) for (int j=1;j<=N;j++) C[i][j] = A[i] > A[j];\n\n\tlong long mul = 1;\n\tfor (int q=1;q<=Q;q++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tfor (int i=1;i<=N;i++) if (i != x && i != y){\n\t\t\tint p = C[x][i] + C[y][i];\n\t\t\tint q = C[i][x] + C[i][y];\n\t\t\tC[x][i] = C[y][i] = p * inv2 % mod;\n\t\t\tC[i][x] = C[i][y] = q * inv2 % mod;\n\t\t}\n\t\tint r = C[x][y] + C[y][x];\n\t\tC[x][y] = C[y][x] = r * inv2 % mod;\n\t\tmul = mul * 2 % mod;\n\t}\n\n\tlong long ans = 0;\n\tfor (int i=1;i<=N;i++) for (int j=i+1;j<=N;j++) ans = (ans + C[i][j] * mul) % mod;\n\tprintf (\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int M=1e9+7;\nconst int N=3010;\nint n,q,a[N];\nint dp[N][N];\nint x[N],y[N];\nint ans;\nint tmp1[N],tmp2[N],tmp3[N];\nvoid ADD(int &x,int y){\n    (x+=y)>=M?x-=M:0;\n}\nvoid HALF(int &x){\n    x&1?(x+=M)>>=1:x>>=1;\n}\nvoid HALFPLUS(int &x,int y){\n    ADD(x,y);\n    HALF(x);\n}\nint fp(int x,int y){\n    int ret=1;\n    for (; y; y>>=1,x=(ll)x*x%M)\n\tif (y&1) ret=(ll)ret*x%M;\n    return ret;\n}\nint main(){\n    cin>>n>>q;\n    for (int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n    for (int i=1; i<=q; ++i){\n\tscanf(\"%d%d\",&x[i],&y[i]);\n    }\n    for (int i=1; i<=n; ++i)\n\tfor (int j=1; j<=n; ++j){\n\t    dp[i][j]=(a[i]>a[j]);\n\t}\n    for (int i=1; i<=q; ++i){\n\tint a=x[i],b=y[i];\n\t/*cerr<<a<<\" \"<<b<<endl;\n\tfor (int i=1; i<=n; ++i)\n\t    for (int j=1; j<=n; ++j)\n\t    cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;*/\n\t//cerr<<\"!!!!!!!\";\n\tfor (int i=1; i<=n; ++i) tmp1[i]=dp[a][i];\n\tfor (int i=1; i<=n; ++i) tmp2[i]=dp[i][a];\n\tint ttt=dp[a][b];\n\tHALFPLUS(dp[a][b],dp[b][a]);\n\tHALFPLUS(dp[b][a],ttt);\n\tfor (int j=1; j<=n; ++j)\n\t    if (j!=b&&j!=a){\n\t\tHALFPLUS(dp[a][j],dp[b][j]);\n\t\tHALFPLUS(dp[j][a],dp[j][b]);\n\t    }\n\tfor (int j=1; j<=n; ++j)\n\t    if (j!=a&&j!=b){\n\t\tHALFPLUS(dp[b][j],tmp1[j]);\n\t\tHALFPLUS(dp[j][b],tmp2[j]);\n\t    }\n\t//don't swap\n\t/*for (int i=1; i<=n; ++i)\n\t    for (int j=1; j<=n; ++j)\n\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;*/\n\t//return 0;\n    }\n    for (int i=1; i<=n; ++i)\n\tfor (int j=i+1; j<=n; ++j)\n\t    ADD(ans,dp[i][j]);\n    cout<<(ll)ans*fp(2,q)%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1000000007;\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[110000];\nLL invfact[110000];\n\nLL ncr(LL n, LL r){\n    if(r < 0 || n < 0) return 0;\n    if(n < r) return 0;\n    LL a = fact[n];\n    a = (a * invfact[r]) % MOD;\n    a = (a * invfact[n-r]) % MOD;\n    return a;\n}\nLL inv2;\nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    inv2 = inv(2);\n    for(LL i = 1; i < 110000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n\nLL prob[3100][3100]; //prob i > j\nLL temp1[3100][3100];\nLL temp2[3100][3100];\nint c, d;\nint f(int a){\n    if(a == c) return d;\n    if(a == d) return c;\n    return a;\n}\n\nint main(){\n    init();\n    int n, m;\n    cin >> n >> m;\n    int a[n];\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(a[i] > a[j]){\n                prob[i][j] = 1;\n            } else {\n                prob[i][j] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < m; i++){\n        cin >> c >> d;\n        c--; d--;\n        vector<int> r, s;\n        for(int j = 0; j < n; j++){\n            r.push_back(j); s.push_back(c);\n            r.push_back(j); s.push_back(d);\n            r.push_back(c); s.push_back(j);\n            r.push_back(d); s.push_back(j);\n        }\n        for(int j = 0; j < r.size(); j++){\n            int u = r[j]; int v = s[j];\n            temp1[u][v] = prob[u][v];\n            temp2[u][v] = prob[f(u)][f(v)];\n        }\n        for(int j = 0; j < r.size(); j++){\n            int u = r[j]; int v = s[j];\n            prob[u][v] = (temp1[u][v] + temp2[u][v]) * inv2;\n            prob[u][v] %= MOD;\n        }\n    }\n    LL ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i < j){\n                ans += prob[i][j];\n                ans %= MOD;\n            }\n        }\n    }\n    ans = ans * powmod(2, m);\n    ans %= MOD;\n    if(ans < 0) ans += MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=3010;\nconst int P=1000000007,inv2=(P+1)>>1;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint del(int x) { return x>=P?x-P:x; }\nvoid add(int &x,int y) { x=del(x+y); }\nint ksm (int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(LL)ans*a%P;\n\t\ta=(LL)a*a%P,b>>=1;\n\t}\n\treturn ans;\n}\nint n,m,a[N],b[N];\nint f[N][N],g[N][N];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(m); int s=ksm (2,m);\n\tfor (int i=1; i<=n; i++)\n\t\tsc(a[i]),b[i]=a[i];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tf[i][j]=b[i]< b[j];\n\twhile (m--)\n\t{\n\t\tint x,y; sc(x),sc(y);\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tg[i][x]=f[i][x],g[i][y]=f[i][y],g[x][i]=f[x][i],g[y][i]=f[y][i];\n\t\tfor (int i=1; i<=n; i++) if (i!=x&&i!=y)\n\t\t{\n\t\t\tf[i][x]=f[i][y]=(LL)inv2*(g[i][x]+g[i][y])%P;\n\t\t\tf[x][i]=f[y][i]=(LL)inv2*(g[x][i]+g[y][i])%P;\n\t\t}\n\t\tf[x][y]=f[y][x]=(LL)inv2*(g[x][y]+g[y][x])%P;\n\t}\n\tint ans=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j< i; j++)\n\t\t\tadd(ans,f[i][j]);\n\tpr((LL)ans*s%P);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"YES\"<<\"\\n\"\n#define no cout<<\"NO\"<<\"\\n\"\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,m;\n\tcin>>n>>m;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tvvi dp(n,vi(n));\n\trep(i,n)rep(j,n)if(in[i]>in[j])dp[i][j]=1;\n\tint MOD=1000000007;\n\trep(q,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\trep(i,n)if(i!=a&&i!=b){\n\t\t\tdp[i][a]=dp[i][b]=(dp[i][a]+dp[i][b])*((MOD+1)/2)%MOD;\n\t\t\tdp[a][i]=dp[b][i]=(dp[a][i]+dp[b][i])*((MOD+1)/2)%MOD;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=(dp[a][b]+dp[b][a])*((MOD+1)/2)%MOD;\n\t}\n\tint out=0;\n\trep(i,n)rep(j,i)(out+=dp[i][j])%=MOD;\n\trep(i,m)(out*=2)%=MOD;\n\tcout<<out<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int mod = (int) 1e9 + 7;\nconst int inv2 = (mod + 1) / 2;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = 3005;\nint n, m;\nint a[maxn];\nint xs[maxn], ys[maxn];\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    xs[i]--;\n    ys[i]--;\n  }\n  return true;\n}\n\nint dp[maxn][maxn];\n\nvoid solve() {\n  memset(dp, 0, sizeof(dp));\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      dp[i][j] = 1;\n    }\n  }\n  int tomul = 1;\n  for (int t = m - 1; t >= 0; t--) {\n    int x = xs[t], y = ys[t];\n    tomul = mul(tomul, 2);\n    for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n        continue;\n      }\n      auto &cur = dp[x][i];\n      add(cur, dp[y][i]);\n      cur = mul(cur, inv2);\n    }\n    for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n        continue;\n      }\n      dp[y][i] = dp[x][i];\n    }\n    for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n        continue;\n      }\n      auto &cur = dp[i][x];\n      add(cur, dp[i][y]);\n      cur = mul(cur, inv2);\n    }\n    for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n        continue;\n      }\n      dp[i][y] = dp[i][x];\n    }\n    {\n      int &cur = dp[x][y];\n      add(cur, dp[y][x]);\n      cur = mul(cur, inv2);\n      dp[y][x] = cur;\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (a[i] <= a[j]) {\n        continue;\n      }\n      auto cur = dp[i][j];\n      cur = mul(cur, tomul);\n      add(res, cur);\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007,iv2=(mod+1>>1);\nint f[3010][3010],a[3010],x,y,n,m,g[3010][3010],nw,ans;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),nw=1;\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) f[i][j]=(a[i]>a[j]);\n\twhile (m--)\n\t{\n\t\tnw=2ll*nw%mod,scanf(\"%d%d\",&x,&y);\n\t\tg[x][x]=g[y][y]=0;\n\t\tg[y][x]=g[x][y]=1ll*iv2*(f[x][y]+f[y][x])%mod;\n\t\tfor (int i=1; i<=n; i++) if (i!=x&&i!=y)\n\t\t\tg[i][y]=g[i][x]=1ll*iv2*(f[i][x]+f[i][y])%mod,\n\t\t\tg[x][i]=g[y][i]=1ll*iv2*(f[x][i]+f[y][i])%mod;\n\t\tfor (int i=1; i<=n; i++) f[i][x]=g[i][x],f[i][y]=g[i][y],f[x][i]=g[x][i],f[y][i]=g[y][i];\n\t}\n\tans=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++) ans=(ans+1ll*nw*f[i][j])%mod;\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 3005\n#define mod 1000000007\n#define inv 500000004\nint n,dp[N][N],v[N],q,a,b;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)dp[i][j]=(v[i]<v[j]);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint tp=dp[a][b]+dp[b][a];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tdp[j][a]=dp[j][b]=1ll*(dp[j][a]+dp[j][b])*inv%mod;\n\t\t\tdp[a][j]=dp[b][j]=1ll*(dp[a][j]+dp[b][j])*inv%mod;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=1ll*tp*inv%mod;\n\t}\n\tint as=0;\n\tfor(int i=2;i<=n;i++)\n\tfor(int j=1;j<i;j++)as=(as+dp[i][j])%mod;\n\tfor(int i=1;i<=q;i++)as=as*2%mod;\n\tprintf(\"%d\\n\",as);\n}//orz"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 3030\n#define ll long long\nusing namespace std;\n\nconst ll mod=1e9+7;\n\nll dp[maxn][maxn],times=1,ans;\n\nint a[maxn],n,T,x,y;\n\nvoid qpow(int k){\n\tll base=2;\n\twhile(k){\n\t\tif(k&1) times=(times*base)%mod;\n\t\tbase=base*base%mod;\n\t\tk>>=1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&T);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) dp[i][j]=a[i]>a[j];\n\tqpow(T);\n\twhile(T--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x||i==y) continue;\n\t\t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*((mod+1)/2)%mod;\n\t\t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*((mod+1)/2)%mod;\n\t\t}\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*((mod+1)/2)%mod;\n\t}\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) ans=(ans+dp[i][j])%mod;\n\tprintf(\"%lld\",ans*times%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 3005\n#define P 1000000007\n#define INV 499122177\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, q, ans, a[MAXN], f[MAXN][MAXN];\n\ninline int add(int x, int y) {return x+y>=P?x+y-P:x+y;}\ninline int sub(int x, int y) {return x>=y?x-y:x-y+P;}\n\ninline int ksm(int x, int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1) ans=1LL*x*ans%P;\n        x=1LL*x*x%P, y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &q);\n    for(rint i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=n; ++j) if(a[i]>a[j]) f[i][j]=1;\n    for(rint i=1, x, y; i<=q; ++i)\n    {\n        scanf(\"%d%d\", &x, &y);\n        int t1, t2;\n        for(rint j=1; j<=n; ++j)\n        {\n            if(j==x || j==y) continue;\n            t1=f[x][j], t2=f[y][j];\n            f[y][j]=f[x][j]=1LL*add(t1, t2)*INV%P;\n            t1=f[j][x], t2=f[j][y];\n            f[j][x]=f[j][y]=1LL*add(t1, t2)*INV%P;\n        }\n        \n        t1=f[x][y], t2=f[y][x];\n        f[x][y]=f[y][x]=1LL*add(t1, t2)*INV%P;\n    }\n    int temp=ksm(2, q);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=i+1; j<=n; ++j)\n            ans=add(ans, 1LL*f[i][j]*temp%P);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm>\nusing namespace std; \ninline int gi() {\n    register int data = 0, w = 1;\n    register char ch = 0;\n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int Mod = 1e9 + 7; \nint fpow(int x, int y) { \n\tint res = 1; \n\twhile (y) {\n\t\tif (y & 1) res = 1ll * res * x % Mod; \n\t\tx = 1ll * x * x % Mod; \n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nconst int inv2 = fpow(2, Mod - 2), MAX_N = 3005; \nint N, Q, A[MAX_N], f[MAX_N][MAX_N]; \n\nint main () { \n\tN = gi(), Q = gi(); \n\tfor (int i = 1; i <= N; i++) A[i] = gi(); \n\tfor (int i = 1; i <= N; i++) \n\t\tfor (int j = 1; j <= N; j++) f[i][j] = A[i] > A[j] ? 1 : 0; \n\tfor (int k = 1; k <= Q; k++) { \n\t\tint x = gi(), y = gi(); \n\t\tfor (int i = 1; i <= N; i++) { \n\t\t\tif (i == x || i == y) continue; \n\t\t\tf[x][i] = f[y][i] = 1ll * (f[x][i] + f[y][i]) * inv2 % Mod;  \n\t\t\tf[i][x] = f[i][y] = 1 + Mod - f[x][i]; \n\t\t} \n\t\tf[x][y] = f[y][x] = inv2; \n\t} \n\tint ans = 0; \n\tfor (int i = 1; i <= N; i++) \n\t\tfor (int j = i + 1; j <= N; j++) ans = (ans + f[i][j]) % Mod; \n\tprintf(\"%lld\\n\", 1ll * ans * fpow(2, Q) % Mod); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef unsigned u32;\ntypedef unsigned long long u64;\nconst int N=3005;\nconst u32 P=1e9+7, Half=5e8+4;\nint a[N], f[N][N], g[N][N];\nint main() {\n\tint n, q;\n\tu32 ans=0;\n\tassert(scanf(\"%d%d\", &n, &q)==2);\n\tfor(int i=1; i<=n; ++i) assert(scanf(\"%d\", a+i)==1);\n\tfor(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) f[i][j]=a[i]>a[j];\n\tfor(int t=0; t<q; ++t) {\n\t\tint x, y;\n\t\tassert(scanf(\"%d%d\", &x, &y)==2);\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tg[x][i]=f[x][i];\n\t\t\tg[i][x]=f[i][x];\n\t\t\tg[y][i]=f[y][i];\n\t\t\tg[i][y]=f[i][y];\n\t\t}\n\t\tfor(int i=1; i<=n; ++i)\n\t\t\tif(i!=x&&i!=y) {\n\t\t\t\tf[x][i]=(u64)Half*(f[x][i]+g[y][i])%P;\n\t\t\t\tf[i][x]=(u64)Half*(f[i][x]+g[i][y])%P;\n\t\t\t\tf[y][i]=(u64)Half*(f[y][i]+g[x][i])%P;\n\t\t\t\tf[i][y]=(u64)Half*(f[i][y]+g[i][x])%P;\n\t\t\t}\n\t\tf[x][y]=(u64)Half*(f[x][y]+g[y][x])%P;\n\t\tf[y][x]=(u64)Half*(f[y][x]+g[x][y])%P;\n\t}\n\tfor(int i=1; i<=n; ++i) for(int j=i+1; j<=n; ++j) ans=(ans+f[i][j])%P;\n\tfor(int i=1; i<=q; ++i) ans=ans*2%P;\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 3005\n#define ll long long\n#define mod 1000000007\n#define inv2 500000004\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint n, q;\nint f[N][N], A[N];\nint main()\n{\n\tRead(n), Read(q);\n\tfor (int i = 1; i <= n; i++)\n\t\tRead(A[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tf[i][j] = (A[i] > A[j]);\n\tint ans = 1;\n\tfor (; q--; )\n\t{\n\t\tans = (ans << 1) % mod;\n\t\tint x, y;\n\t\tRead(x), Read(y);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (i != x && i != y)\n\t\t\t{\n\t\t\t\tf[i][x] = f[i][y] = (ll)(f[i][x] + f[i][y]) * inv2 % mod;\n\t\t\t\tf[x][i] = f[y][i] = (ll)(f[x][i] + f[y][i]) * inv2 % mod;\n\t\t\t}\n\t\t}\n\t\tf[x][y] = f[y][x] = (ll)(f[x][y] + f[y][x]) * inv2 % mod;\n\t}\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tsum = (sum + f[i][j]) % mod;\n\tans = (ll)sum * ans % mod;\n\tprintf(\"%d\\n\", ans);\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\tfix(s+=s);\n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tint ix=f[i][x],iy=f[i][y];\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<utility>//pair\n#include<cmath>//abs,sqrt\n#include<cstring>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define prin(arg) std::cout<<arg<<\"\\n\"\n#define prin2(arg1,arg2) std::cout<<arg1<<\" \"<<arg2<<\"\\n\"\n#define fill(arg,n) memset(arg,n,sizeof(arg))\nusing std::cin;\ntypedef long long ll;\nconst int INF=1e+9;\nconst ll INFLL=1e+17;\nconst ll MOD=1e+9+7;\nint N,Q;\nint A[3010],X[3010],Y[3010];\nll dp[3010][3010][2];\nll modpow(int m){\n  ll res=1;\n  rep(i,m){\n    res=(res*2)%MOD;\n  }  \n  return res;\n}\nint Extgcd(int a,int b,int &x,int &y){\n  int d=a;\n  if(b!=0){\n    Extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }\n  else{\n    x=1;y=0;\n  }\n  return d;\n}\n\nint Invmod(int a,int p){//mod pでのaの逆元を求める\n  int x,y;\n  Extgcd(a,p,x,y);\n  return (x%p+p)%p;\n}\nvoid solve(){\n  rep(i,N){\n    rep(j,N){\n      if(A[i]<=A[j]){\n\tdp[i][j][0]=0;\n      }\n      else dp[i][j][0]=1;\n    }\n  }\n  ll in2=Invmod(2,MOD);\n  rep(i,Q){\n    int x=X[i],y=Y[i];\n    rep(j,N){\n      if(j!=y&&x!=j) {\n\tdp[x][j][1]=(in2*((dp[x][j][0]+dp[y][j][0])%MOD))%MOD;\n\t//\tdp[j][x][1]=(1-dp[x][j][1]+MOD)%MOD;\n\tdp[j][x][1]=(in2*((dp[j][x][0]+dp[j][y][0])%MOD))%MOD;\n\tdp[y][j][1]=(in2*((dp[x][j][0]+dp[y][j][0])%MOD))%MOD;\n\t//\tdp[j][y][1]=(1-dp[y][j][1]+MOD)%MOD;\n\tdp[j][y][1]=(in2*((dp[j][x][0]+dp[j][y][0])%MOD))%MOD;\n      }\n    }\n    dp[x][y][1]=dp[y][x][1]=(in2*((dp[x][y][0]+dp[y][x][0])%MOD))%MOD;\n    rep(j,N){\n      if(j!=y&&x!=j){\n\t  dp[x][j][0]=dp[x][j][1];\n\t  dp[j][x][0]=dp[j][x][1];\n\t  dp[y][j][0]=dp[y][j][1];\n\t  dp[j][y][0]=dp[j][y][1];\n\t}\n    }\n    dp[x][y][0]=dp[x][y][1];\n    dp[y][x][0]=dp[y][x][1];\n\n\n    /*  rep(a,N){\n      rep(b,N){\n\tstd::cout<<dp[a][b][0]<<\" \";\n      }\n      std::cout<<\"\\n\";\n      }*/\n  }\n  ll res=0;\n  ll q=modpow(Q);\n  rep(i,N){\n    for(int j=i+1;j<N;j++){\n      res=(res+(q*dp[i][j][0])%MOD)%MOD;\n    }\n  }\n\n  prin(res);\n}\n\n\nint main(){\n  cin>>N>>Q;\n  rep(i,N) cin>>A[i];\n  rep(i,Q){\n    cin>>X[i]>>Y[i];\n    X[i]--;Y[i]--;\n  }\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll n,q,i,x,y,j,dp[3005][3005],p2[3005],ans=0,st[3005][3005],a[3005],u,v;\nconst ll mod=1e9+7;\nint main()\n{\n\tp2[0]=1;for(i=1;i<=3000;i++)p2[i]=p2[i-1]*2%mod;\n\tscanf(\"%lld%lld\",&n,&q);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(a[i]==a[j])continue;\n\t\t\tif(a[i]>a[j])dp[j][i]++;\n\t\t\telse dp[i][j]++;\n\t\t}\n\t}\n\tfor(i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x||j==y)continue;\n\t\t\tu=dp[x][j]=dp[x][j]*p2[i-1-st[x][j]]%mod;st[x][j]=i;\n\t\t\tv=dp[y][j]=dp[y][j]*p2[i-1-st[y][j]]%mod;st[y][j]=i;\n\t\t\tdp[x][j]=(dp[x][j]+v)%mod;\n\t\t\tdp[y][j]=(dp[y][j]+u)%mod;\n\t\t\tu=dp[j][x]=dp[j][x]*p2[i-1-st[j][x]]%mod;st[j][x]=i;\n\t\t\tv=dp[j][y]=dp[j][y]*p2[i-1-st[j][y]]%mod;st[j][y]=i;\n\t\t\tdp[j][x]=(dp[j][x]+v)%mod;\n\t\t\tdp[j][y]=(dp[j][y]+u)%mod;\n\t\t}\n\t\tu=dp[x][y]=dp[x][y]*p2[i-1-st[x][y]]%mod;st[x][y]=i;\n\t\tv=dp[y][x]=dp[y][x]*p2[i-1-st[y][x]]%mod;st[y][x]=i;\n\t\tdp[x][y]=(dp[x][y]+v)%mod;\n\t\tdp[y][x]=(dp[y][x]+u)%mod;\n\t}\n\tfor(i=1;i<=n;i++)for(j=1;j<i;j++)ans=(ans+dp[i][j]*p2[q-st[i][j]])%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\nint div2(int x) {\n\tif (x & 1) x += MOD;\n\treturn x / 2;\n}\n\nconst int N = 3030;\nint a[N];\nint xs[N];\nint n, m, k;\nint b[N][2];\nint c[N], d[N];\nint ans;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\txs[i] = a[i];\n\t}\n\tsort(xs, xs + n);\n\tk = unique(xs, xs + n) - xs;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = lower_bound(xs, xs + k, a[i]) - xs;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tb[i][j]--;\n\t\t}\n\tfor (int it = k - 1; it >= 0; it--) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[i] = (int)(a[i] == it);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = div2(add(c[b[i][0]], c[b[i][1]]));\n\t\t\tc[b[i][0]] = c[b[i][1]] = x;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = add(ans, mult(sum, c[i]));\n\t\t\tans = add(ans, div2(mult(c[i], d[i])));\n\t\t\tsum = add(sum, d[i]);\n\t\t\td[i] = add(d[i], c[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tans = add(ans, ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 3003, MOD = 1e9 + 7;\nint n, q, a[N], X[N], Y[N], dp[N][N], pw[N];\nint rt = (MOD + 1) / 2;\n\nvoid add(int & x, int y) {\n\tx += y;\n\tif (x >= MOD) {\n\t\tx -= MOD;\n\t}\n}\n\nvoid dbg() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tcout << dp[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n >> q;\n\tpw[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tpw[i] = (ll)pw[i - 1] * 2 % MOD;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a[i] < a[j]) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tint x = X[i], y = Y[i];\n\t\tint t1 = dp[x][y], t2 = dp[y][x];\n\t\tadd(dp[x][y], t2);\n\t\tadd(dp[y][x], t1);\n\t\tdp[x][y] = (ll)dp[x][y] * rt % MOD;\n\t\tdp[y][x] = (ll)dp[y][x] * rt % MOD;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j == x || j == y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint d1 = dp[j][x], d2 = dp[j][y];\n\t\t\tint d3 = dp[x][j], d4 = dp[y][j];\n\t\t\tadd(dp[j][x], d2);\n\t\t\tdp[j][x] = (ll)dp[j][x] * rt % MOD;\n\t\t\tadd(dp[j][y], d1);\n\t\t\tdp[j][y] = (ll)dp[j][y] * rt % MOD;\n\t\t\tadd(dp[x][j], d4);\n\t\t\tdp[x][j] = (ll)dp[x][j] * rt % MOD;\n\t\t\tadd(dp[y][j], d3);\n\t\t\tdp[y][j] = (ll)dp[y][j] * rt % MOD;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tadd(res, dp[i][j]);\n\t\t}\n\t}\n\tcout << (ll)res * pw[q] % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=3005;\nconst int mo=1000000007;\nint n,Q,ans,a[N];\nint f[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) For(j,1,n) f[i][j]=(a[i]>a[j]);\n\tFor(i,1,Q){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tFor(j,1,n) if (j!=x&&j!=y){\n\t\t\tf[x][j]=f[y][j]=1ll*(f[x][j]+f[y][j])*(mo+1)/2%mo;\n\t\t\tf[j][x]=f[j][y]=1ll*(f[j][x]+f[j][y])*(mo+1)/2%mo;\n\t\t}\n\t\tf[x][y]=f[y][x]=\n\t\t\t1ll*(f[x][y]+f[y][x])*(mo+1)/2%mo;\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tans=(ans+f[i][j])%mo;\n\tFor(i,1,Q) ans=2ll*ans%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\nrandom_device(rd);\nmt19937 rng(rd());\nconst long long FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n\nstruct custom_hash\n{\n\ttemplate<class T>\n\tunsigned long long operator()(T v) const\n\t{\n\t\tunsigned long long x = v;\n\t\tx += FIXED_RANDOM; x += 11400714819323198485ull;\n\t\tx = (x ^ (x >> 30)) * 13787848793156543929ull;\n\t\tx = (x ^ (x >> 27)) * 10723151780598845931ull;\n\t\treturn x ^ (x >> 31);\n\t}\n};\n\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<class T, class U> using hash_table = gp_hash_table<T, U, custom_hash>;\n\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\ntemplate<class T>\nvoid readi(T &x)\n{\n\tx = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tx = x * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tx = -x;\n\t}\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint buf[20], n = 0;\n\twhile(output)\n\t{\n\t\tbuf[n] = ((output % 10));\n\t\toutput /= 10;\n\t\tn++;\n\t}\n\tfor (n--; n >= 0; n--)\n\t{\n\t\tputchar(buf[n] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\nlong long expo(long long a, long long e, long long mod)\n{\n\treturn ((e == 0) ? 1 : ((expo(a * a % mod, e >> 1, mod)) * ((e & 1) ? a : 1) % mod));\n}\ntemplate<class T, class U>\nvoid nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT gcd(T a, T b)\n{\n\treturn (b ? gcd(b, a % b) : a);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define DBG(x) cerr << #x << \" = \" << (x) << endl\n#define SZ(x) ((int) ((x).size()))\n#define FOR(i, a, b) for (auto i = (a); i < (b); i++)\n#define FORD(i, a, b) for (auto i = (a) - 1; i >= (b); i--)\n#define ALL(x) (x).begin(), (x).end()\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-9;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 3013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<pdd> vpd;\n\nint N, Q;\nint arr[MAXN];\npii go[MAXN];\nll half = (INF + 1) / 2;\nll dp[MAXN][MAXN], tmp[MAXN][MAXN];\nvi compress;\nll ans;\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// if (fopen(\"file.in\", \"r\"))\n\t// {\n\t// \tfreopen (\"file.in\", \"r\", stdin);\n\t// \tfreopen (\"file.out\", \"w\", stdout);\n\t// }\n\tcin >> N >> Q;\n\tFOR(i, 0, N)\n\t{\n\t\tcin >> arr[i];\n\t}\n\tFOR(i, 0, Q)\n\t{\n\t\tcin >> go[i].fi >> go[i].se;\n\t\tgo[i].fi--; go[i].se--;\n\t\tif (go[i].fi > go[i].se) swap(go[i].fi, go[i].se);\n\t}\n\tFOR(i, 0, N)\n\t{\n\t\tFOR(j, 0, N)\n\t\t{\n\t\t\tdp[i][j] = (bool) (arr[i] > arr[j]);\n\t\t\t// cerr << \"dp[\" << i << \"][\" << j << \"] = \" << dp[i][j] << endl;\n\t\t}\n\t}\n\t//dp[i][j] = p(x[i] > x[j]);\n\tFOR(i, 0, Q)\n\t{\n\t\tint x = go[i].fi, y = go[i].se;\n\t\tif (x == y) continue;\n\t\tFOR(j, 0, N)\n\t\t{\n\t\t\tif (j == x || j == y) continue;\n\t\t\ttmp[j][x] = half * dp[j][x] + half * dp[j][y];\n\t\t\ttmp[j][y] = half * dp[j][y] + half * dp[j][x];\n\t\t\ttmp[x][j] = half * dp[x][j] + half * dp[y][j];\n\t\t\ttmp[y][j] = half * dp[y][j] + half * dp[x][j];\n\t\t\t// cerr << y << ' ' << x << ' ' << j << ' ' << tmp[x][j] % INF << endl;\n\t\t}\n\t\ttmp[x][y] = half * dp[x][y] + half * dp[y][x];\n\t\ttmp[y][x] = half * dp[y][x] + half * dp[x][y];\n\t\tFOR(j, 0, N)\n\t\t{\n\t\t\tdp[j][x] = tmp[j][x] % INF;\n\t\t\tdp[j][y] = tmp[j][y] % INF;\n\t\t\tdp[x][j] = tmp[x][j] % INF;\n\t\t\tdp[y][j] = tmp[y][j] % INF;\n\t\t}\n\t\t// cerr << \"check\\n\";\n\t\t// FOR(j, 0, N)\n\t\t// {\n\t\t// \tFOR(k, 0, N)\n\t\t// \t{\n\t\t// \t\t// cerr << j << ' ' << k << ' ' << dp[j][k] << endl;\n\t\t// \t\t// ans += dp[j][k]; ans %= INF;\n\t\t// \t}\n\t\t// }\n\t}\n\t// cerr << \"final\\n\";\n\tFOR(i, 0, N)\n\t{\n\t\tFOR(j, i + 1, N)\n\t\t{\n\t\t\t// cerr << i << ' ' << j << ' ' << dp[i][j] << endl;\n\t\t\tans += dp[i][j]; nmod(ans, INF);\n\t\t}\n\t}\n\tFOR(i, 0, Q)\n\t{\n\t\tans += ans; nmod(ans, INF);\n\t}\n\tcout << ans << '\\n';\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n/* READ READ READ\n* int overflow, maxn too small, special cases (n=1?, two distinct?), cin.tie() interactive\n* reread the problem, try small cases\n* note down possible sources of error as you go\n* do smth instead of nothing\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define int long long\n#define mod 1000000007\n#define inv2 500000004\nint n,m,a[3010],f[3010][3010],g[3010][3010],A,B,ans;\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tf[i][j]=a[i]>a[j];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tif(A>B)A^=B^=A^=B;\n\t\tfor(int i=1;i<A;i++)\n\t\t\tg[i][A]=(f[i][A]+f[i][B])%mod*inv2%mod;\n\t\tfor(int i=A+1;i<B;i++)\n\t\t\tg[A][i]=(f[A][i]+1-f[i][B]+mod)%mod*inv2%mod;\n\t\tfor(int i=B+1;i<=n;i++)\n\t\t\tg[A][i]=(f[A][i]+f[B][i])%mod*inv2%mod;\n\t\tfor(int i=1;i<A;i++)\n\t\t\tg[i][B]=(f[i][B]+f[i][A])%mod*inv2%mod;\n\t\tfor(int i=A+1;i<B;i++)\n\t\t\tg[i][B]=(f[i][B]+1-f[A][i]+mod)%mod*inv2%mod;\n\t\tfor(int i=B+1;i<=n;i++)\n\t\t\tg[B][i]=(f[B][i]+f[A][i])%mod*inv2%mod;\n\t\tfor(int i=1;i<A;i++)\n\t\t\tf[i][A]=g[i][A];\n\t\tfor(int i=A+1;i<=n;i++)\n\t\t\tf[A][i]=g[A][i];\n\t\tfor(int i=1;i<B;i++)\n\t\t\tf[i][B]=g[i][B];\n\t\tfor(int i=B+1;i<=n;i++)\n\t\t\tf[B][i]=g[B][i];\n\t\tf[A][B]=(1-f[A][B]+mod)%mod*inv2%mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t(ans+=f[i][j])%=mod;\n\tfor(int i=1;i<=m;i++)\n\t\t(ans*=2)%=mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "///WRONG LIFE\n///DIE(RETRY)\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define pb push_back\n#define F first\n#define S second\n#define f(i,a,b)  for(int i = a; i < b; i++)\n#define endl '\\n'\n\nusing ll = long long;\nusing db = long double;\nusing row = vector<int>;\nusing ii = pair<int, int>;\n\nconst int N = 2e5 + 5, M = 26, A = 6561, LG = 19, MOD = 1e9+7;\nconst int BLOCK = 500;\nconst long double EPS = 1e-7;\nusing pii = pair<int,int>;\nint dp[3005][3005];\nint n, q, x, y;\nint a[3005];\nconst int INV2 = 500000004;\nint main(){\n#ifdef ONLINE_JUDGE\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n#endif // ONLINE_JUDGE\n\n  cin >> n >> q;\n\n  f(i,1,n+1)  cin>>a[i];\n\n  f(i,1,n+1)\n    f(j,1,n+1)dp[i][j]=  (a[i] < a[j]);\n  ll mul = 1;\n  f(i,1,q+1){\n    if((mul+=mul)>=MOD)mul-=MOD;\n    cin >> x >> y;\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * 1ll * INV2 % MOD;\n    f(j,1,n+1){\n      if(j == x || j == y)continue;\n      dp[j][x] = dp[j][y] =  (dp[j][x] + dp[j][y]) * 1ll * INV2 % MOD;\n      dp[x][j] = dp[y][j] =  (dp[x][j] + dp[y][j]) * 1ll * INV2 % MOD;\n    }\n  }\n\n  ll ans = 0;\n  f(i,1,n+1)\n    f(j,1,i)ans += dp[i][j];\n\n  cout << ans%MOD * mul % MOD << '\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"YES\"<<\"\\n\"\n#define no cout<<\"NO\"<<\"\\n\"\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,m;\n\tcin>>n>>m;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tvvi dp(n,vi(n));\n\trep(i,n)rep(j,n)if(in[i]>in[j])dp[i][j]=1;\n\tint MOD=1000000007;\n\trep(q,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\trep(i,n)if(i!=a&&i!=b){\n\t\t\tdp[i][a]=dp[i][b]=(dp[i][a]+dp[i][b])*((MOD+1)/2)%MOD;\n\t\t\tdp[a][i]=dp[b][i]=(dp[a][i]+dp[b][i])*((MOD+1)/2)%MOD;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=(dp[a][b]+dp[b][a])*((MOD+1)/2)%MOD;\n\t}\n\tint out=0;\n\trep(i,n)loop(j,i+1,n)(out+=dp[i][j])%=MOD;\n\trep(i,m)(out*=2)%=MOD;\n\tcout<<out<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint a[3005], x[3005], y[3005];\nint table[3005][3005];\nconst int inv2 = 500000004;\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\trep(i, n) {\n\t\tcin >> a[i]; a[i]--;\n\t}\n\trep(i, q) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tint ans = 0;\n\n\trep(i, n) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (a[i] == a[j])continue;\n\t\t\trep(k, n)rep(l, n)table[k][l] = 0;\n\t\t\tif (a[i] < a[j])table[i][j] = 1;\n\t\t\telse table[j][i] = 1;\n\t\t\trep(k, q) {\n\t\t\t\t//x[i]とy[i]をswap\n\t\t\t\trep(l, n) {//(x,l)->(y,l)\n\t\t\t\t\tif (x[k] == l||y[k]==l)continue;\n\t\t\t\t\ttable[x[k]][l] = table[x[k]][l] * inv2 % mod;\n\t\t\t\t\ttable[y[k]][l] = table[y[k]][l] * inv2 % mod;\n\t\t\t\t\ttable[l][x[k]] = table[l][x[k]] * inv2 % mod;\n\t\t\t\t\ttable[l][y[k]] = table[l][y[k]] * inv2 % mod;\n\t\t\t\t\tint p1 = table[x[k]][l], p2 = table[y[k]][l], p3 = table[l][x[k]], p4 = table[l][y[k]];\n\t\t\t\t\ttable[x[k]][l] = (table[x[k]][l] + p2) % mod;\n\t\t\t\t\ttable[y[k]][l] = (table[y[k]][l] + p1) % mod;\n\t\t\t\t\ttable[l][x[k]] = (table[l][x[k]] + p4) % mod;\n\t\t\t\t\ttable[l][y[k]] = (table[l][y[k]] + p3) % mod;\n\t\t\t\t}\n\t\t\t\ttable[x[k]][y[k]] = table[x[k]][y[k]] * inv2 % mod;\n\t\t\t\ttable[y[k]][x[k]] = table[y[k]][x[k]] * inv2 % mod;\n\t\t\t\tint p1 = table[y[k]][x[k]], p2 = table[x[k]][y[k]];\n\t\t\t\ttable[x[k]][y[k]] = (table[x[k]][y[k]] + p1) % mod;\n\t\t\t\ttable[y[k]][x[k]] = (table[y[k]][x[k]] + p2) % mod;\n\t\t\t}\n\t\t\tint r = 0;\n\t\t\trep(k, n) {\n\t\t\t\tfor (int l = 0; l < k; l++) {\n\t\t\t\t\tr += table[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += r;\n\t\t}\n\t}\n\tcout << ans*modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\n#define MOD 1000000007\n\nlong sum(long a, long b) { return (a + b) % MOD; }\nlong mult(long a, long b) { return (a * b) % MOD; }\n\nlong pow(long a, long b) {\n    long res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nlong inv(long a) {\n    return pow(a, MOD - 2);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<int> x(q), y(q);\n    for (int i = 0; i < q; i++) cin >> x[i] >> y[i];\n\n    vector<vector<long>> d(n, vector<long>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            d[i][j] = 1;\n        }\n    }\n\n    long inv2 = inv(2LL);\n\n    for (int i = q - 1; i >= 0; i--) {\n        int u = x[i];\n        int v = y[i];\n        u--; v--;\n\n        for (int i = 0; i < n; i++) {\n            if (i == v) continue;\n            if (i == u) continue;\n            d[u][i] = d[v][i] = mult(sum(d[u][i], d[v][i]), inv2);\n            d[i][u] = d[i][v] = mult(sum(d[i][u], d[i][v]), inv2);\n        }\n        d[u][v] = d[v][u] = inv2;\n\n    }\n\n    long res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] < a[j]) {\n                res = sum(res, d[j][i]);\n            }\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        res = sum(res, res);\n    }\n\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define N 3030\nusing namespace std;\nconst int Mod = 1e9 + 7;\nconst int i2 = (Mod + 1) >> 1;\n\nint n, m, a[N], f[N][N], t[N][N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n    \n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d\", a + i);\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j) f[i][j] = a[i] > a[j];\n\n    for (int k = 1, x, y; k <= m; ++k) {\n        scanf(\"%d%d\", &x, &y);\n        for (int i = 1 ;i <= n; ++i) {\n            t[i][x] = f[i][x], t[i][y] = f[i][y];\n            t[x][i] = f[x][i], t[y][i] = f[y][i];\n        }\n        for (int i = 1; i <= n; ++i)\n            if (i != x && i != y) {\n                f[i][x] = f[i][y] = 1ll * (t[i][x] + t[i][y]) * i2 % Mod;\n                f[x][i] = f[y][i] = 1ll * (t[x][i] + t[y][i]) * i2 % Mod;\n            }\n        f[x][y] = f[y][x] = 1ll * (f[x][y] + f[y][x]) * i2 % Mod;\n    }\n\n    int ans = 0;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j)\n            ans = (ans + f[i][j]) % Mod;\n\n    while (m--) ans = 2ll * ans % Mod;\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint a[3005], x[3005], y[3005];\nint table[3005][3005];\n\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nconst int inv2 = modpow(2, mod - 2);\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, q) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\n\trep(i, n)rep(j, n)if (a[i] < a[j])table[i][j]++;\n\n\trep(k, q) {\n\t\t//x[i]とy[i]をswap\n\t\trep(l, n) {//(x,l)->(y,l)\n\t\t\tif (x[k] == l || y[k] == l)continue;\n\t\t\ttable[x[k]][l] = table[x[k]][l] * inv2 % mod;\n\t\t\ttable[y[k]][l] = table[y[k]][l] * inv2 % mod;\n\t\t\ttable[l][x[k]] = table[l][x[k]] * inv2 % mod;\n\t\t\ttable[l][y[k]] = table[l][y[k]] * inv2 % mod;\n\t\t\tint p1 = table[x[k]][l], p2 = table[y[k]][l], p3 = table[l][x[k]], p4 = table[l][y[k]];\n\t\t\ttable[x[k]][l] = (table[x[k]][l] + p2) % mod;\n\t\t\ttable[y[k]][l] = (table[y[k]][l] + p1) % mod;\n\t\t\ttable[l][x[k]] = (table[l][x[k]] + p4) % mod;\n\t\t\ttable[l][y[k]] = (table[l][y[k]] + p3) % mod;\n\t\t}\n\t\ttable[x[k]][y[k]] = table[x[k]][y[k]] * inv2 % mod;\n\t\ttable[y[k]][x[k]] = table[y[k]][x[k]] * inv2 % mod;\n\t\tint p1 = table[y[k]][x[k]], p2 = table[x[k]][y[k]];\n\t\ttable[x[k]][y[k]] = (table[x[k]][y[k]] + p1) % mod;\n\t\ttable[y[k]][x[k]] = (table[y[k]][x[k]] + p2) % mod;\n\t}\n\tint r = 0;\n\trep(k, n) {\n\t\tfor (int l = 0; l < k; l++) {\n\t\t\tr += table[k][l];\n\t\t\tr %= mod;\n\t\t}\n\t}\n\n\tcout << r*modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nconst int N=3005,P=1e9+7,inv2=500000004;\ninline void Add(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);\n\treturn res;\n}\nstruct node{int x,y;}p[N];\nint f[N][N],g[2][N],ans[2][N][N],a[N];\nint n,q,res;\n//void solve1(int pos){\n//\tfd(t,q,1){\n//\t\tint x=p[t].x,y=p[t].y;\n//\t\tfp(i,1,n)g[0][i]=g[1][i]=0;\n//\t\tfp(i,1,n)g[0][i]=add(f[x][i],f[y][i]),g[1][i]=add(f[i][x],f[i][y]);\n//\t\tint c=f[x][y],d=f[y][x];\n//\t\tfp(i,1,n)f[x][i]=f[y][i]=g[0][i],f[i][x]=f[i][y]=g[1][i];\n//\t\tf[x][y]=f[y][x]=add(c,d);\n//\t}\n//\tfp(i,1,n)fp(j,1,n)ans[pos][i][j]=f[i][j];\n//}\nvoid solve(int pos){\n\tint tag=1;\n\tfd(t,q,1){\n\t\ttag=mul(tag,2);\n\t\tint x=p[t].x,y=p[t].y;\n\t\tfp(i,1,n)g[0][i]=g[1][i]=0;\n\t\tfp(i,1,n)g[0][i]=add(f[x][i],f[y][i]),g[1][i]=add(f[i][x],f[i][y]);\n\t\tint c=f[x][y],d=f[y][x];\n\t\tfp(i,1,n)f[x][i]=f[y][i]=mul(g[0][i],inv2),f[i][x]=f[i][y]=mul(g[1][i],inv2);\n\t\tf[x][y]=f[y][x]=mul(add(c,d),inv2),f[x][x]=f[y][y]=0;\n\t}\n\tfp(i,1,n)fp(j,1,n)ans[pos][i][j]=mul(f[i][j],tag);\n}\nvoid init(){\n\tfp(i,1,n)fp(j,1,n)f[i][j]=0;\n\tfp(i,1,n)fp(j,i+1,n)f[i][j]=1;\n\tsolve(0);\n\tfp(i,1,n)fp(j,1,n)f[i][j]=0;\n\tfp(i,1,n)fp(j,1,i-1)f[i][j]=1;\n\tsolve(1);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),q=read();\n\tfp(i,1,n)a[i]=read();\n\tfp(i,1,q)p[i].x=read(),p[i].y=read();\n\tinit();\n\tfp(i,1,n)fp(j,i+1,n)Add(res,a[i]==a[j]?0:a[i]>a[j]?ans[0][i][j]:ans[1][i][j]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc030/tasks/agc030_d\n\nNが小さいな…\n→ NC2のすべての組み合わせに関して、反転する場合は何通りあるか数える？\n→クエリの数を考えたら無理じゃね？\n\n各クエリを行った場合、全ての場合での反転数の合計はどうなるかをO(N)で求める？\n→わりとありそう\n→だとしたらdpっぽい\n\n反転数 = それより右にある小さい要素の数とする\n\n反転数をうまくdp式に縮められない…\n\nnum[i][j] = A[i] > A[j]となる通り数とする。(i < j なら反転数)\n\nindex xとyが交換される場合、全てのv(!=y)に関して\n\nnum[y][v] += num[x][v]\nnum[x][v] += num[y][v]\n\nnum[v][x] += num[v][y]\nnum[v][y] += num[v][x]\n\nnum[x][y] += num[y][x]\nnum[y][x] += num[x][y]\n\n更新は高々4*3000\nなので、C++なら可能？\n\nいじらない部分は2倍する操作が必要。\n最後にまとめて処理するために、いじった部分は半分にしておく\n\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 1000000007;\nconst ll half = 500000004;\n\nint main(){\n\n    ll N,Q;\n    cin >> N >> Q;\n    vector<ll> A(N,0);\n\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<vector<ll>> lis(N,vector<ll> (N,0));\n    rep(i,0,N){\n        rep(j,0,N){\n            if (A[i] > A[j]) lis[i][j] = 1;\n        }\n    }\n\n    rep(loop,0,Q){\n\n        vector<vector<ll>> q(0);\n        ll x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n\n        rep(v,0,N){\n            if ((v != x) && (v != y)){\n                q.push_back({y,v,lis[x][v]});\n                q.push_back({x,v,lis[y][v]});\n                q.push_back({v,y,lis[v][x]});\n                q.push_back({v,x,lis[v][y]}); \n            }\n        }\n\n        q.push_back({x,y,lis[y][x]});\n        q.push_back({y,x,lis[x][y]});\n\n        rep(t,0,q.size()){\n            ll i,j,n;\n            i = q[t][0];\n            j = q[t][1];\n            n = q[t][2];\n\n            lis[i][j] += n;\n            lis[i][j] *= half;\n            lis[i][j] %= mod;\n        }\n    }\n\n    ll ans = 0;\n    rep(j,0,N){\n        rep(i,0,j){\n            ans += lis[i][j];\n            ans %= mod;\n        }\n    }\n\n    rep(i,0,Q){\n        ans *= 2;\n        ans %= mod;\n    }\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nmint i2 = (mint)1/2;\nmint f[3000][3000];\nint is[20000];\nint js[20000];\nmint vs[20000];\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\tV<int> a(N);\n\trep(i,N) cin>>a[i];\n\trep(i,N) rep(j,N) if(i>j) f[i][j] = 1;\n\tV<int> X(Q),Y(Q);\n\trep(i,Q){\n\t\tcin>>X[i]>>Y[i];\n\t\tX[i]--,Y[i]--;\n\t}\n\tfor(int t=Q-1;t>=0;t--){\n\t\tint K = 0;\n\t\tauto add = [&](int i,int j,mint v){\n\t\t\tis[K] = i;\n\t\t\tjs[K] = j;\n\t\t\tvs[K] = v;\n\t\t\tK++;\n\t\t};\n\t\tint x = X[t], y = Y[t];\n\t\trep(_,2){\n\t\t\tadd(x,y,i2);\n\t\t\trep(j,N) if(j!=x && j!=y){\n\t\t\t\tadd(x,j,(f[x][j]+f[y][j])/2);\n\t\t\t\tadd(j,x,(f[j][x]+f[j][y])/2);\n\t\t\t}\n\t\t\tswap(x,y);\n\t\t}\n\t\trep(k,K){\n\t\t\tf[is[k]][js[k]] = vs[k];\n\t\t}\n\t}\n\tmint ans = 0;\n\trep(i,N) rep(j,N) if(a[i]<a[j]) ans += f[i][j];\n\trep(_,Q) ans *= 2;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\nstruct range {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_) noexcept : i(i_) { }\n    constexpr void operator ++ () noexcept { ++i; }\n    constexpr itr operator * () const noexcept { return i; }\n    constexpr bool operator != (iterator x) const noexcept { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr range(itr l_, itr r_) noexcept : l(l_), r(std::max(l_, r_)) { }\n  constexpr iterator begin() const noexcept { return l; }\n  constexpr iterator end() const noexcept { return r; }\n};\n\nstruct revrange {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_) noexcept : i(i_) { }\n    constexpr void operator ++ () noexcept { --i; }\n    constexpr itr operator * () const noexcept { return i; }\n    constexpr bool operator != (iterator x) const noexcept { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr revrange(itr l_, itr r_) noexcept : l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr iterator begin() const noexcept { return r; }\n  constexpr iterator end() const noexcept { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type get_mod() { return mod; }\n  static_assert(mod >= 2, \"invalid mod :: smaller than 2\");\n  static_assert(mod < (value_type(1) << 31), \"invalid mod :: over 2^31\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type get() const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing m32 = modular<1000000007>;\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nconstexpr auto pow2 = [] {\n  std::array<m32, 3010> res;\n  res[0] = m32(1);\n  for (auto i: range(1, 3010)) {\n    res[i] = res[i - 1] * m32(2);\n  }\n  return res;\n}();\n\nclass propagation_array {\nprivate:\n  size_t count;\n  std::vector<std::vector<m32>> data;\n  std::vector<std::vector<size_t>> done;\n\npublic:\n  propagation_array(size_t size): \n    count(0), \n    data(size, std::vector<m32>(size)), \n    done(size, std::vector<size_t>(size)) \n  { }\n\n  void multiply() {\n    ++count;\n  }\n\n  void reduce(size_t i, size_t j) {\n    done[i][j] = std::min(done[i][j] + 1, count);\n  }\n\n  m32& access(size_t i, size_t j) {\n    data[i][j] *= pow2[count - done[i][j]];\n    done[i][j] = count;\n    return data[i][j];\n  }\n\n};\n\nint main() {\n  size_t N, Q;\n  std::cin >> N >> Q;\n  std::vector<i32> A(N);\n  for (auto &x: A) {\n    std::cin >> x;\n  }\n  m32 ans;\n  propagation_array invert(N);\n  for (auto i: range(0, N)) {\n    for (auto j: range(0, N)) {\n      if (A[i] < A[j]) {\n        invert.access(i, j) = m32(1);\n      }\n    }\n    for (auto j: range(0, i)) {\n      ans += invert.access(i, j);\n    }\n  }\n  while (Q--) {\n    size_t x, y;\n    std::cin >> x >> y;\n    --x; --y;\n    if (x > y) {\n      std::swap(x, y);\n    }\n    m32 increase = ans;\n    for (auto i: range(x + 1, y)) {\n      increase += invert.access(i, y);\n      increase -= invert.access(i, x);\n    }\n    for (auto j: range(x + 1, y + 1)) {\n      increase += invert.access(x, j);\n    }\n    for (auto j: range(x, y)) {\n      increase -= invert.access(y, j);\n    }\n    ans += increase;\n    invert.multiply();\n    for (auto k: range(0, N)) {\n      if (k != x && k != y) {\n        invert.reduce(k, x);\n        invert.reduce(k, y);\n        invert.reduce(x, k);\n        invert.reduce(y, k);\n        invert.access(k, x) = invert.access(k, y) = invert.access(k, x) + invert.access(k, y);\n        invert.access(x, k) = invert.access(y, k) = invert.access(x, k) + invert.access(y, k);\n      }\n    }\n    invert.reduce(x, x);\n    invert.reduce(x, y);\n    invert.reduce(y, x);\n    invert.reduce(y, y);\n    invert.access(x, y) = invert.access(y, x) = invert.access(x, y) + invert.access(y, x);\n    invert.access(x, x) = invert.access(y, y) = invert.access(x, x) + invert.access(y, y);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt(): x(0) {}\n  ModInt(long long a) { x = a % mod; if (x < 0) x += mod; }\n  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n  ModInt &operator*=(ModInt that) { x = (long long) x * that.x % mod; return *this; }\n  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n  ModInt inverse() {\n    int a = x, b = mod, u = 1, v = 0;\n    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }\n    return ModInt(u);\n  }\n  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n    op(+, +=) op(-, -=) op(*, *=) op(/, /=)\n  #undef op\n  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n};\n\nusing mint = ModInt<1000000007>;\n\nmint dp[3010][3010];\n\nvoid solve() {\n  int N, Q; cin >> N >> Q;\n  vi32 a(N); cin >> a;\n  rep(i, N) rep(j, N) dp[i][j] = a[i] > a[j];\n  rep(j, Q) {\n    int x, y; cin >> x >> y;\n    x--, y--;\n    rep(i, N) {\n      if (i == x || i == y) continue;\n      dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) / 2;\n      dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) / 2;\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) / 2;\n  }\n  mint ans = 0;\n  rep(j, N) rep(i, j) ans += dp[i][j];\n  ans = ans * power((mint) 2, Q);\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define ll long long\n#define maxn 3010\nusing namespace std;\nint x[maxn], y[maxn], f[maxn][maxn], cur[maxn][maxn], val[maxn];\nll inv;\nint calc(int a, int k)\n{\n\tint ans = 1;\n\twhile (k)\n\t{\n\t\tif (k % 2) ans = (ll)ans * a % mod;\n\t\ta = (ll)a * a % mod;\n\t\tk /= 2;\n\t}\n\treturn ans;\n}\nint get_cur(int i, int j, int x, int y)\n{\n\tif (i == x && j == y || i == y && j == x) return (inv * f[i][j] + inv * f[j][i]) % mod;\n\tif (i == x || i == y) return (inv * f[x][j] + inv * f[y][j]) % mod;\n\telse return (inv * f[i][x] + inv * f[i][y]) % mod;\n}\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &val[i]);\n\tfor (int i = 1; i <= m; i++)\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\tinv = calc(2, mod - 2);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (i != j) f[i][j] = 1;\n\tfor (int i = m; i >= 1; i--)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (j != x[i])\n\t\t\t{\n\t\t\t\tcur[x[i]][j] = get_cur(x[i], j, x[i], y[i]);\n\t\t\t\tcur[j][x[i]] = get_cur(j, x[i], x[i], y[i]);\n\t\t\t}\n\t\t\tif (j != y[i])\n\t\t\t{\n\t\t\t\tcur[y[i]][j] = get_cur(y[i], j, x[i], y[i]);\n\t\t\t\tcur[j][y[i]] = get_cur(j, y[i], x[i], y[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (j != x[i])\n\t\t\t{\n\t\t\t\tf[x[i]][j] = cur[x[i]][j];\n\t\t\t\tf[j][x[i]] = cur[j][x[i]];\n\t\t\t}\n\t\t\tif (j != y[i])\n\t\t\t{\n\t\t\t\tf[y[i]][j] = cur[y[i]][j];\n\t\t\t\tf[j][y[i]] = cur[j][y[i]];\n\t\t\t}\n\t\t}\n\t}\n\tint tot = calc(2, m), res = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tint tmp = f[i][j];\n\t\t\tif (val[i] == val[j]) continue;\n\t\t\tif (val[i] < val[j]) tmp = (mod + 1 - tmp) % mod;\n\t\t\tres = (res + (ll)tmp * tot) % mod;\n\t\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 3003;\nconst int MOD = 1e9 + 7;\n\nint mul(int a, int b) {\n   return (a * b) % MOD; \n}\n\nint add(int a, int b) {\n   return (a + b) % MOD;\n}\n\nint binpow(int a, int b) {\n   int res = 1;\n   while (b) {\n      if (b & 1) res = mul(res, a);\n      a = mul(a, a);\n      b >>= 1;\n   }\n   return res;\n}\n\nint divv(int a, int b) {\n   return mul(a, binpow(b, MOD - 2));\n}\n\nint n;\nint dp[N][N];\n\nvoid rec_dp(int x, int y) {\n   vector<pair<int, int>> torel;\n   for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n         for (int j = 0; j < n; j++) {\n            torel.push_back({i, j});\n         }\n      } else {\n         torel.push_back({i, x});\n         torel.push_back({i, y});  \n      }\n   }\n   vector<tuple<int, int, int>> rval;\n   for (auto t : torel) {\n      int i, j;\n      tie(i, j) = t;\n      if (i == j) {\n         rval.push_back(make_tuple(i, j, dp[i][j]));\n         continue;\n      }\n      if (i != x && i != y && j != x && j != y) {\n         rval.push_back(make_tuple(i, j, dp[i][j]));\n         continue;  \n      }\n      if (i == x && j == y) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[j][i]), 2)));\n         continue;\n      }\n      if (i == y && j == x) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[j][i]), 2)));\n         continue;\n      }\n      if (i == x) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[y][j]), 2)));\n         continue;\n      }\n      if (i == y) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[x][j]), 2)));\n         continue;\n      }\n      if (j == x) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[i][y]), 2)));\n         continue;\n      }\n      if (j == y) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[i][x]), 2)));\n         continue;\n      }\n      assert(false);\n   }\n   for (auto t : rval) {\n      int i, j, c;\n      tie(i, j, c) = t;\n      dp[i][j] = c;\n   }\n}\n\nsigned main() {\n   ios_base::sync_with_stdio(false);\n   cin.tie(0);\n\n   int q;\n   cin >> n >> q;\n   vector<int> a(n);\n   for (auto &t : a) {\n      cin >> t;\n   }\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n         dp[i][j] = (a[i] > a[j]); \n      }\n   }\n   for (int i = 0; i < q; i++) {\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      rec_dp(x, y);\n   }\n   int ans = 0;\n   for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n         ans = add(ans, dp[i][j]);\n      }\n   }\n   // for (int i = 0; i < n; i++) {\n   //    for (int j = 0; j < n; j++) {\n   //       cerr << mul(2, dp[pnt][i][j]) << ' ';\n   //    }\n   //    cerr << endl;\n   // }\n   for (int i = 0; i < q; i++) {\n      ans = mul(ans, 2);\n   }\n   cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end());\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\n#include<iostream>\n#include<vector>\n\ntemplate<int MOD = 1000000007>\nstruct ModInt {\n    int val;\n    ModInt(long long val_ = 0) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    bool operator==(const ModInt &rhs) const { return val == rhs.val; }\n    bool operator!=(const ModInt &rhs) const { return val != rhs.val; }\n    ModInt &operator+=(const ModInt &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n    ModInt operator++(signed) {\n        const ModInt ret(*this);\n        ++*this;\n        return ret;\n    }\n    ModInt operator--(signed) {\n        const ModInt ret(*this);\n        --*this;\n        return ret;\n    }\n    ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        int a = val, b = MOD, u = 1, v = 0;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n) const {\n        ModInt ret = 1, mul = *this;\n        if (n < 0) { n = -n, mul = mul.inv(); }\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, ModInt &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &rhs) { return os << rhs.val; }\n    struct Combination {\n        std::vector<ModInt> fact, finv, inv;\n        Combination(int n) : fact(n + 1), finv(n + 1), inv(n + 1) {\n            fact[0] = fact[1] = 1;\n            finv[0] = finv[1] = 1;\n            inv[1] = 1;\n            for (int i = 2; i <= n; i++) {\n                fact[i] = fact[i - 1] * i;\n                inv[i] = -inv[MOD % i] * (MOD / i);\n                finv[i] = finv[i - 1] * inv[i];\n            }\n        }\n        ModInt P(int n, int r) const { return r < 0 || n < r ? 0 : fact[n] * finv[n - r]; }\n        ModInt C(int n, int r) const { return r < 0 || n < r ? 0 : fact[n] * finv[r] * finv[n - r]; }\n        ModInt H(int n, int r) const { return C(n + r - 1, r); }\n    };\n};\n\nint N, Q;\nint A[3300], X[3300], Y[3300];\nusing Mint=ModInt<>;\nMint dp[3300][3300];\nint last[3300][3300];\nsigned main() {\n    cin >> N >> Q;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, Q) { cin >> X[i] >> Y[i], X[i]--, Y[i]--; }\n    rep(i, N)rep(j, N) { if (A[i] < A[j]) { dp[i][j] = 1; }}\n    rep(i, Q) {\n        rep(j, N) {\n            dp[X[i]][j] *= Mint(2).pow(max(0LL, i - last[X[i]][j]));\n            last[X[i]][j] = i + 1;\n            dp[Y[i]][j] *= Mint(2).pow(max(0LL, i - last[Y[i]][j]));\n            last[Y[i]][j] = i + 1;\n        }\n        rep(j, N) {\n            dp[j][X[i]] *= Mint(2).pow(max(0LL, i - last[j][X[i]]));\n            last[j][X[i]] = i + 1;\n            dp[j][Y[i]] *= Mint(2).pow(max(0LL, i - last[j][Y[i]]));\n            last[j][Y[i]] = i + 1;\n        }\n        rep(j, N) { dp[X[i]][j] = dp[Y[i]][j] = dp[X[i]][j] + dp[Y[i]][j]; }\n        rep(j, N) { dp[j][X[i]] = dp[j][Y[i]] = dp[j][X[i]] + dp[j][Y[i]]; }\n        dp[X[i]][X[i]] = dp[Y[i]][Y[i]] = 0;\n    }\n    Mint ans = 0;\n    rep(i, N)rep(j, i) { ans += dp[i][j] * Mint(2).pow(Q - last[i][j]); }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\nconst int INV2 = (MOD+1)/2;\nconst int N = 3030;\n\nint n, a[N], m[N][N];\n\nvoid print() {\n    forn(i,n) { forn(j,n) cerr << m[i][j] << ' '; cerr << endl; }\n    cerr << string(120,'=') << endl;\n}\n\nvoid process(int i, int j, int x, int y) {\n    int ni = i, nj = j;\n\n    if (i == x) ni = y;\n    else if (i == y) ni = x;\n\n    if (j == x) nj = y;\n    else if (j == y) nj = x;\n\n    if (mp(i,j) < mp(ni,nj)) m[ni][nj] = m[i][j] = ll(m[i][j] + m[ni][nj]) * INV2 % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int q;\n    cin >> n >> q;\n    forn(i,n) cin >> a[i];\n    forn(i,n) forn(j,n) if (a[i] > a[j]) m[i][j]++;\n\n    ll mul = 1;\n    forn(_,q) {\n        mul = 2LL*mul%MOD;\n        int i,j; cin >> i >> j;\n        i--; j--;\n        forn(k,n) if (k != i && k != j) {\n            process(i,k,i,j);\n            process(j,k,i,j);\n            process(k,i,i,j);\n            process(k,j,i,j);\n        }\n        for (auto ii : vi{i,j})\n        for (auto jj : vi{i,j}) \n            process(ii,jj,i,j);\n    }\n    ll ans = 0;\n    forn(j,n) forn(i,j) ans += m[i][j];\n    cout << mul*(ans%MOD)%MOD;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 3010, Mod = 1e9 + 7;\nint a[N], f[N][N], g[N][N];\nint fpow(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % Mod)\n\t\tif (b & 1) res = 1ll * res * a % Mod;\n\treturn res;\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>(), q = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tf[i][j] = a[i] > a[j];\n\tint inv = fpow(2, Mod - 2), ans = 0;\n\tfor (int i = 1; i <= q; i++) {\n\t\tint x = gi<int>(), y = gi<int>();\n\t\tf[x][y] = f[y][x] = 1ll * (f[x][y] + f[y][x]) * inv % Mod;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j == x || j == y) continue;\n\t\t\tf[y][j] = f[x][j] = 1ll * (f[x][j] + f[y][j]) * inv % Mod;\n\t\t\tf[j][x] = f[j][y] = 1ll * (f[j][x] + f[j][y]) * inv % Mod;\n\t\t}\n\t\t/*for (int j = 1; j <= n; j++) {\n\t\t\tf[x][j] = g[x][j]; f[j][x] = g[j][x];\n\t\t\tf[y][j] = g[y][j]; f[j][y] = f[j][y];\n\t\t\t}*/\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) \n\t\t\t(ans += f[i][j]) %= Mod;\n\tcout << 1ll * ans * fpow(2, q) % Mod << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long Int;\n#define MOD (1000000007)\nInt n, q, x, y;\nInt a[3240];\nInt dp[3240][3240];\n\nInt pw(Int a, Int n){\n  if(n == 0)return 1;\n  Int res = pw(a, n/2);\n  res = res * res % MOD;\n  if(n % 2)res *= a;\n  return res % MOD;\n}\n\nint main(){\n  cin >> n >> q;\n  for(Int i = 0;i < n;i++)cin >> a[i];\n  for(Int i = 0;i < n;i++){\n    for(Int j = 0;j < n;j++){\n      dp[i][j] = a[i] < a[j];\n    }\n  }\n  for(Int i = 0;i < q;i++){\n    cin >> x >> y;\n    x--,y--;\n    Int a = dp[x][y] + dp[y][x];\n    if(a % 2)a += MOD;\n    dp[x][y] = a / 2;\n    dp[y][x] = a / 2;\n    for(Int j = 0;j < n;j++){\n      if(j == x || j == y)continue;\n      Int a = (dp[x][j] + dp[y][j]) % MOD;\n      if(a % 2)a += MOD;\n      a /= 2;\n      dp[x][j] = dp[y][j] = a;\n    }\n    \n    for(Int j = 0;j < n;j++){\n      if(j == x || j == y)continue;\n      Int a = (dp[j][x] + dp[j][y]) % MOD;\n      if(a % 2)a += MOD;\n      a /= 2;\n      dp[j][x] = dp[j][y] = a;\n    }\n  }\n  Int res = 0;\n  for(Int i = 0;i < n;i++){\n    for(Int j = 0;j < i;j++){\n      res += dp[i][j];\n      res %= MOD;\n    }\n  }\n  cout << res * pw(2, q) % MOD<< endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fio ios_base::sync_with_stdio(false)\n#define pdl cout << \"*\" << endl\n#define MOD 1000000007\n#define INF 1000000000\n#define INFLL 1000000000000000000ll\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define ss second\n#define long int64_t\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef priority_queue<pii, vector<pii>, greater<pii>> min_pq;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> OST;\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1> void __f(const char* name, Arg1&& arg1){ cout << name << \" : \" << arg1 << endl; }\ntemplate <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args)\n{ const char* comma = strchr(names + 1, ','); cout.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma+1, args...); }\n\nconst int N = 3001;\nconst int i2 = MOD + 1 >> 1;\n\nint a[N], dp[N][N], t[N][N];\n\nint main()\n{\n\tfio;\n\tint n, q;\n\tcin >> n >> q;\n\tfor(int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tdp[i][j] = int(a[i] > a[j]);\n\tint f = 1;\n\twhile(q--)\n\t{\n\t\tf <<= 1;\n\t\tf %= MOD;\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tint i = j;\n\t\t\tif(i == x or i == y)\n\t\t\t\ti ^= x ^ y;\n\t\t\tt[x][j] = (dp[x][j] * 1ll * i2 + dp[y][i] * 1ll * i2) % MOD;\n\t\t\tt[y][j] = (dp[y][j] * 1ll * i2 + dp[x][i] * 1ll * i2) % MOD;\n\t\t\tt[j][x] = (dp[j][x] * 1ll * i2 + dp[i][y] * 1ll * i2) % MOD;\n\t\t\tt[j][y] = (dp[j][y] * 1ll * i2 + dp[i][x] * 1ll * i2) % MOD;\n\t\t}\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tdp[x][i] = t[x][i];\n\t\t\tdp[y][i] = t[y][i];\n\t\t\tdp[i][x] = t[i][x];\n\t\t\tdp[i][y] = t[i][y];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t\tans = (ans + dp[i][j]) % MOD;\n\tans = (ans * 1ll * f) % MOD;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, ll> Pl;\nconst ll mod = (ll)1e9 + 7;\nconst int N = 3005;\n\nint n,q;\nint num[N];\nint a[N], b[N];\n\nll dp[N][N];\n\nll fac[N], facinv[N];\nll inv[N];\n\nll fp(ll x, ll k){\n    if(k == 0) return 1;\n    ll hf = fp(x, k/2);\n    return k % 2 ? hf * hf % mod * x % mod: hf * hf % mod;\n}\n\nint main(){\n    inv[1] = 1;\n    for(int i = 2; i < N; i++) inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n    fac[0] = 1;\n    for(int i = 1; i <= N-1; i++) fac[i] = fac[i-1] * i % mod;\n    facinv[N-1] = fp(fac[N-1], mod - 2);\n    for(int i = N-1 - 1; i >= 0; i--) facinv[i] = facinv[i+1] * (i+1) % mod;\n\n    cin >> n >> q;\n    for(int i = 0; i < n; i++) cin >> num[i];\n    for(int i = 0; i < q; i++) cin >> a[i] >> b[i], a[i]--, b[i]--;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            dp[i][j] = (num[i] > num[j]);\n        }\n    }\n    for(int i = 0; i < q; i++){\n        vector<Pl> upd;\n        for(int k = 0; k < n; k++){\n            if(k != a[i] && k != b[i]) {\n                upd.push_back({{a[i], k}, inv[2] * (dp[a[i]][k] + dp[b[i]][k]) % mod});\n                upd.push_back({{k, a[i]}, inv[2] * (dp[k][a[i]] + dp[k][b[i]]) % mod});\n            }\n            if(k != b[i] && k != a[i]){\n                upd.push_back({{b[i], k}, inv[2] * (dp[b[i]][k] + dp[a[i]][k]) % mod});\n                upd.push_back({{k, b[i]}, inv[2] * (dp[k][a[i]] + dp[k][b[i]]) % mod});\n            }\n        }\n        upd.push_back({{a[i], b[i]}, inv[2] * (dp[b[i]][a[i]] + dp[a[i]][b[i]])});\n        upd.push_back({{b[i], a[i]}, inv[2] * (dp[b[i]][a[i]] + dp[a[i]][b[i]])});\n        for(auto p : upd){\n            dp[p.first.first][p.first.second] = p.second;\n        }\n    }\n    ll res = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++) res += dp[i][j];\n    }\n    for(int i = 0; i < q; i++) res = (res * 2) % mod;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define P 1000000007\n#define N 3005\nint f[N][N],d[N][N],Q[N],a[N],F[N][N];\nint i,j,k,l,s,n,m;\ninline int get(int x,int y,int t) {\n    f[x][y]=1ll*f[x][y]*Q[t-d[x][y]-1]%P;\n    d[x][y]=t-1;\n}\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    Q[0]=1;\n    for (int i=1;i<=3000;i++) Q[i]=Q[i-1]*2ll%P;\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++) f[i][j]=(a[i]<a[j]),d[i][j]=0;\n    for (int i=1;i<=m;i++) {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        for (int j=1;j<=n;j++) {\n            get(j,x,i);\n            get(j,y,i);\n            get(x,j,i);\n            get(y,j,i);\n        }\n        for (int j=1;j<=n;j++) F[j][x]=f[j][x],F[j][y]=f[j][y],F[y][j]=f[y][j],F[x][j]=f[x][j];\n        for (int j=1;j<=n;j++) {\n            if (j==x||j==y) continue;\n            (f[j][x]+=F[j][y])%=P;\n            (f[j][y]+=F[j][x])%=P;\n            d[j][x]=d[j][y]=i;\n            (f[x][j]+=F[y][j])%=P;\n            (f[y][j]+=F[x][j])%=P;\n            d[x][j]=d[y][j]=i;\n        }\n        (f[x][y]+=F[y][x])%=P;\n        (f[y][x]+=F[x][y])%=P;\n        d[x][y]=d[y][x]=i;\n    }\n    int ans=0;\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<i;j++) get(i,j,m+1),(ans+=f[i][j])%=P;\n    printf(\"%d\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define IL __inline__ __attribute__((always_inline))\n\n#define For(i, a, b) for (int i = a, i##end = b; i <= i##end; ++ i)\n#define FOR(i, a, b) for (int i = a, i##end = b; i < i##end; ++ i)\n#define Rep(i, a, b) for (int i = a, i##end = b; i >= i##end; -- i)\n#define REP(i, a, b) for (int i = (a) - 1, i##end = b; i >= i##end; -- i)\n\ntypedef long long LL;\n\ntemplate <class T>\nIL bool chkmax(T &a, const T &b) {\n  return a < b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL bool chkmin(T &a, const T &b) {\n  return a > b ? ((a = b), 1) : 0;\n}\n\ntemplate <class T>\nIL T mymax(const T &a, const T &b) {\n  return a > b ? a : b;\n}\n\ntemplate <class T>\nIL T mymin(const T &a, const T &b) {\n  return a < b ? a : b;\n}\n\ntemplate <class T>\nIL T myabs(const T &a) {\n  return a > 0 ? a : -a;\n}\n\nconst int INF = 0X3F3F3F3F;\nconst double EPS = 1E-10, PI = acos(-1.0);\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define OK DEBUG(\"Passing [%s] in LINE %d...\\n\", __FUNCTION__, __LINE__)\n/*------------------------------header------------------------------*/\n\nconst int MAXN = 3000 + 5, MOD = 1000000007;\n\nIL int add(int a, int b) {\n  a += b;\n  return a >= MOD ? a - MOD : a;\n}\n\nIL int mul(int a, int b) {\n  return (LL)a * b % MOD;\n}\n\nint a[MAXN], f[MAXN][MAXN][2], tag[MAXN][MAXN], power[MAXN];\n\nint main() {\n  int n, q;\n  scanf(\"%d%d\", &n, &q);\n  For(i, 1, n) {\n    scanf(\"%d\", &a[i]);\n  }\n  For(i, 1, n) {\n    For(j, i + 1, n) {\n      f[i][j][0] = a[i] < a[j];\n      f[i][j][1] = a[i] > a[j];\n    }\n  }\n  power[0] = 1;\n  For(i, 1, q) {\n    power[i] = add(power[i - 1], power[i - 1]);\n  }\n  For(t, 1, q) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    if (x > y) {\n      std::swap(x, y);\n    }\n#define update(a, b) f[a][b][0] = mul(f[a][b][0], power[t - tag[a][b] - 1]), f[a][b][1] = mul(f[a][b][1], power[t - tag[a][b] - 1])\n    update(x, y);\n    f[x][y][0] = f[x][y][1] = add(f[x][y][0], f[x][y][1]);\n    tag[x][y] = t;\n    FOR(i, 1, x) {\n      update(i, x), update(i, y);\n      f[i][x][0] = f[i][y][0] = add(f[i][x][0], f[i][y][0]);\n      f[i][x][1] = f[i][y][1] = add(f[i][x][1], f[i][y][1]);\n      tag[i][x] = tag[i][y] = t;\n    }\n    FOR(i, x + 1, y) {\n      update(x, i), update(i, y);\n      f[x][i][0] = f[i][y][1] = add(f[x][i][0], f[i][y][1]);\n      f[x][i][1] = f[i][y][0] = add(f[x][i][1], f[i][y][0]);\n      tag[x][i] = tag[i][y] = t;\n    }\n    For(i, y + 1, n) {\n      update(x, i), update(y, i);\n      f[x][i][0] = f[y][i][0] = add(f[x][i][0], f[y][i][0]);\n      f[x][i][1] = f[y][i][1] = add(f[x][i][1], f[y][i][1]);\n      tag[x][i] = tag[y][i] = t;\n    }\n  }\n  int answer = 0;\n  For(i, 1, n) {\n    For(j, i + 1, n) {\n      answer = add(answer, mul(f[i][j][1], power[q - tag[i][j]]));\n    }\n  }\n  printf(\"%d\\n\", answer);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=3005,M=1e9+7;\nint f[N][N],a[N],g[N][N],n,Q,x,y;\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&Q);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (a[i]>a[j])f[i][j]=1;\n\tint K=ksm(2,Q),Inv=ksm(2,M-2);\t\t\n\twhile (Q--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tg[x][y]=f[y][x];\n\t\tg[y][x]=f[x][y];\n\t\tf[y][x]=(f[y][x]*Inv+g[y][x]*Inv)%M;\n\t\tf[x][y]=(f[x][y]*Inv+g[x][y]*Inv)%M;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y)g[x][i]=f[y][i],g[i][x]=f[i][y];\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y)g[y][i]=f[x][i],g[i][y]=f[i][x];\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y){\n\t\t\t\tf[x][i]=(g[x][i]*Inv+f[x][i]*Inv)%M;\n\t\t\t\tf[y][i]=(g[y][i]*Inv+f[y][i]*Inv)%M;\n\t\t\t\tf[i][x]=(g[i][x]*Inv+f[i][x]*Inv)%M;\n\t\t\t\tf[i][y]=(g[i][y]*Inv+f[i][y]*Inv)%M;\n\t\t\t}\n\t\tfor (int i=1;i<=n;i++)g[i][x]=g[i][y]=g[x][i]=g[y][i]=0;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)(ans+=f[i][j])%=M;\n\tprintf(\"%lld\\n\",ans*K%M);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    long long N,Q,i,j,count,s=0,mod=1e9+7;\n    cin>>N>>Q;\n    long long A[N],X[Q],Y[Q];\n    for(i=0;i<N;i++){\n        cin>>A[i];\n    }\n    for(i=0;i<N;i++){\n        for(j=i+1;j<N;j++){\n            if(A[i]!=A[j]){\n                s++;\n            }\n        }\n    }\n    for(i=0;i<Q;i++){\n        cin>>X[i]>>Y[i];\n    }\n    for(i=0;i<Q-1;i++){\n        s=(s*2)%mod;\n    }\n    cout<<s<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 3010;\n\nint N, Q;\nint A[MN], X[MN], Y[MN], prec[MN][MN], po[MN];\nvector<int> V[MN];\n\nunordered_map<int, int> mm[MN][MN];\nint dp(int a, int b, int x) {\n    if(x == Q) return a < b;\n    if(mm[a][b].find(x) != mm[a][b].end()) return mm[a][b][x];\n    int &ret = mm[a][b][x];\n\n    if(X[x] != a && Y[x] != a && X[x] != b && Y[x] != b) {\n        int c = min(prec[a][x], prec[b][x]);\n        return ret = 1LL * po[c - x] * dp(a, b, c) % mod;\n    }\n    ret += dp(a, b, x + 1);\n    ret %= mod;\n    ret += dp((a == X[x]? Y[x] : (a == Y[x]? X[x] : a)), (b == X[x]? Y[x] : (b == Y[x]? X[x] : b)), x + 1);\n    ret %= mod;\n\n    //cout << a << ' ' << b << ' ' << x << ' ' << ret << endl;\n\n    return ret;\n}\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    scanf(\"%d %d\", &N, &Q);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n\n        V[ X[i] ].push_back(i);\n        V[ Y[i] ].push_back(i);\n    }\n    for(int i = 0; i < N; i++) {\n        V[i].push_back(Q);\n    }\n\n    for(int i = 0; i < N; i++) {\n        int pos = 0;\n        for(int j = 0; j < Q; j++) {\n            if(pos < V[i].size() && V[i][pos] < j) pos++;\n            prec[i][j] = V[i][pos];\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(A[j] < A[i]) {\n                ans += dp(i, j, 0);\n                ans %= mod;\n            }\n        }\n    }\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar(); \n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\ntypedef long long LL;\nconst int maxn = 3010, mod = 1e9 + 7;\nint a[maxn], f[maxn][maxn];\n\nint Pow(int x, int p)\n{\n\tint r = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) r = (LL)x * r % mod;\n\t\tx = (LL)x * x % mod; p >>= 1;\n\t}\n\treturn r;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\n\tint n = read(), Q = read();\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(a[i] < a[j]) f[i][j] = 1;\n\n\tint inv2 = 500000004, tmp = Pow(2, Q);\n\twhile(Q--)\n\t{\n\t\tint x = read(), y = read();\n\t\tf[x][y] = f[y][x] = (LL)(f[x][y] + f[y][x]) * inv2 % mod;\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tif(i != x && i != y)\n\t\t\t\tf[i][x] = f[i][y] = (LL)inv2 * (f[i][x] + f[i][y]) % mod,\n\t\t\t\tf[x][i] = f[y][i] = (LL)inv2 * (f[x][i] + f[y][i]) % mod;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j < i; ++j)\n\t\t\t(ans += f[i][j]) %= mod;\n\n\tcout << (LL)ans * tmp % mod << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mod=1000000007;\nconst int inv2=mod+1>>1;\nconst int Maxn=3005;\nint n,q,a[Maxn];\nint p[Maxn][Maxn],t;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) p[i][j]=a[i]>a[j];\n\tfor (int q_=0;q_<q;++q_)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tp[x][y]=p[y][x]=1LL*(p[x][y]+p[y][x])*inv2%mod;\n\t\tfor (int i=1;i<=n;++i) if(i!=x && i!=y)\n\t\t\tp[i][x]=p[i][y]=1LL*(p[i][x]+p[i][y])*inv2%mod,\n\t\t\tp[x][i]=p[y][i]=1LL*(p[x][i]+p[y][i])*inv2%mod;\n\t}\n\tfor (int i=1;i<=n;++i) for (int j=n;j>i;--j) ans=(ans+p[i][j])%mod;\n\tfor (int i=0;i<q;++i) ans=(ans<<1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\n\nusing lint = long long;\n\nconst int N_ = 3050;\n\nint N, Q;\nint A[N_];\nint X[N_], Y[N_];\n\nint ways[N_][N_];\nint lazy[N_];\n\nlint P2 = 1, PINV2 = 1;\n\nvoid set_ways(int i, int j, long long v) {\n  ways[i][j] = v * PINV2 % MOD;\n}\n\nlint get_ways (int i, int j) {\n  return ways[i][j] * P2 % MOD;\n}\n\nint main() {\n#ifdef IN_MY_COMPUTER\n  freopen(\"example.in\", \"r\", stdin);\n#endif\n\n  //for(int i = 1; i < N_; i++) assert(1L * pow2[i] * pow2[-i] % MOD == 1);\n\n  scanf(\"%d%d\", &N, &Q);\n  for(int i = 1; i <= N; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n  for(int q = 1; q <= Q; q++) {\n    int x, y; scanf(\"%d%d\", &x, &y);\n    if(x > y) swap(x, y);\n    X[q] = x; Y[q] = y;\n  }\n\n  for(int i = 1; i <= N; i++) {\n    for(int j = 1; j < i; j++) {\n      ways[i][j] = 1;\n    }\n  }\n\n  for(int q = Q; q > 0; q--) {\n    int x = X[q], y = Y[q];\n    vector<tuple<int, int, long long>> updates;\n    for(int i = 1; i <= N; i++) {\n      lint cur = get_ways(i, x) + get_ways(i, y);\n      updates.emplace_back(i, x, cur);\n      updates.emplace_back(i, y, cur);\n    }\n    for(int j = 1; j <= N; j++) {\n      lint cur = get_ways(x, j) + get_ways(y, j);\n      updates.emplace_back(x, j, cur);\n      updates.emplace_back(y, j, cur);\n    }\n    {\n      lint cur = get_ways(x, y) + get_ways(y, x);\n      updates.emplace_back(x, y, cur);\n      updates.emplace_back(y, x, cur);\n    }\n\n    P2 = P2 * 2L % MOD;\n    PINV2 = PINV2 * 500000004L % MOD;\n\n    for(auto it : updates) {\n      int i, j; lint v;\n      tie(i, j, v) = it;\n      set_ways(i, j, v % MOD);\n    }\n  }\n\n  lint ans = 0;\n  for(int i = 1; i <= N; i++) for(int j = 1; j <= N; j++) {\n    if(A[i] < A[j]) (ans += get_ways(i, j)) %= MOD;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    if(n+1<=(signed)fact.size()) return;\n    fact.assign(n+1,1);\n    finv.assign(n+1,1);\n    invs.assign(n+1,1);\n    \n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=1;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=1;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    Mint res;\n    for(int j=1;j<=k;j++) res+=S(n,j);\n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int> x(q),y(q);\n  for(int i=0;i<q;i++) cin>>x[i]>>y[i];\n\n  using M = Mint<int>;    \n  auto dp=make_v<M>(n,n);\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      dp[i][j]=M(a[i]<a[j]);\n\n  M r2=M(2).inv();\n  for(int t=0;t<q;t++){\n    x[t]--;y[t]--;\n    M tmp=dp[x[t]][y[t]]+dp[y[t]][x[t]];\n    assert(dp[x[t]][x[t]]==M(0));\n    assert(dp[y[t]][y[t]]==M(0));\n    \n    vector<M> rx(n,0),ry(n,0);\n    vector<M> cx(n,0),cy(n,0);\n    \n    for(int j=0;j<n;j++){\n      rx[j]+=dp[x[t]][j]*r2;\n      rx[j]+=dp[y[t]][j]*r2;\n      ry[j]+=dp[x[t]][j]*r2;\n      ry[j]+=dp[y[t]][j]*r2;\n    }\n    for(int i=0;i<n;i++){\n      cx[i]+=dp[i][x[t]]*r2;\n      cx[i]+=dp[i][y[t]]*r2;\n      cy[i]+=dp[i][x[t]]*r2;\n      cy[i]+=dp[i][y[t]]*r2;\n    }\n    \n    for(int j=0;j<n;j++){\n      if(j==x[t]||j==y[t]) continue;\n      dp[x[t]][j]=rx[j];\n      dp[y[t]][j]=ry[j];\n    }\n    for(int i=0;i<n;i++){\n      if(i==x[t]||i==y[t]) continue;\n      dp[i][x[t]]=cx[i];\n      dp[i][y[t]]=cy[i];\n    }\n    \n    dp[x[t]][y[t]]=tmp*r2;\n    dp[y[t]][x[t]]=tmp*r2;\n  }\n  \n  M ans;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<i;j++)\n      ans+=dp[i][j];\n\n  ans*=M(2).pow(q);\n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\nconst int INV2 = (MOD+1)/2;\nconst int N = 3030;\n\nint n, a[N], m[N][N];\n\nvoid print() {\n    forn(i,n) { forn(j,n) cerr << m[i][j] << ' '; cerr << endl; }\n    cerr << string(120,'=') << endl;\n}\n\nvoid process(int i, int j, int x, int y) {\n    int ni = i, nj = j;\n\n    if (i == x) ni = y;\n    else if (i == y) ni = x;\n\n    if (j == x) nj = y;\n    else if (j == y) nj = x;\n\n    if (mp(i,j) < mp(ni,nj)) m[ni][nj] = m[i][j] = ll(m[i][j] + m[ni][nj]) * INV2 % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int q;\n    cin >> n >> q;\n    forn(i,n) cin >> a[i];\n    forn(i,n) forn(j,n) if (a[i] > a[j]) m[i][j]++;\n\n    ll mul = 1;\n    forn(_,q) {\n        mul = 2LL*mul%MOD;\n        int i,j; cin >> i >> j;\n        i--; j--;\n        forn(k,n) if (k != i && k != j) {\n            process(i,k,i,j);\n            process(j,k,i,j);\n            process(k,i,i,j);\n            process(k,j,i,j);\n        }\n        for (auto ii : vi{i,j})\n        for (auto jj : vi{i,j}) \n            process(ii,jj,i,j);\n    }\n    ll ans = 0;\n    forn(j,n) forn(i,j) ans += m[i][j];\n    cout << mul*ans%MOD;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\ninline int rd(){\n    int x=0,p=1;\n    char a=getchar();\n    while((a<48||a>57)&&a!='-')a=getchar();\n    if(a=='-')p=-p,a=getchar();\n    while(a>47&&a<58)x=(x<<1)+(x<<3)+(a&15),a=getchar();\n    return x*p;\n}\nconst int N=3002;\nconst ll mod=1e9+7;\nint n,q;\nint a[N];\nll f[N][N],ans;\ninline ll fpow(ll b,ll p=mod-2){\n\tll ans=1,tmp=b;\n\twhile(p){\n\t\tif(p&1)ans=ans*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=rd(),q=rd();\n\tfor(int i=1;i<=n;i++)a[i]=rd();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j];\n\tll inv=fpow(2);\n\tfor(int i=1,x,y;i<=q;i++){\n\t\tx=rd(),y=rd();\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%mod*inv%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x&&j!=y){\n\t\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])%mod*inv%mod;\n\t\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])%mod*inv%mod;\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",ans*fpow(2,q)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type get_mod() { return mod; }\n  static_assert(mod >= 2, \"invalid mod :: smaller than 2\");\n  static_assert(mod < (value_type(1) << 31), \"invalid mod :: over 2^31\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type get() const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing m32 = modular<1000000007>;\n\nconstexpr auto pow2 = [] {\n  std::array<m32, 3010> res;\n  res[0] = m32(1);\n  for (size_t i = 1; i < 3010; ++i) {\n    res[i] = res[i - 1] * m32(2);\n  }\n  return res;\n}();\n\nclass propagation_array {\nprivate:\n  size_t count;\n  std::vector<std::vector<m32>> data;\n  std::vector<std::vector<size_t>> done;\n\npublic:\n  propagation_array(size_t h, size_t w): \n    count(0), \n    data(h, std::vector<m32>(w)), \n    done(h, std::vector<size_t>(w)) \n  { }\n\n  void multiply() {\n    ++count;\n  }\n\n  void reduce(size_t i, size_t j) {\n    done[i][j] = std::min(done[i][j] + 1, count);\n  }\n\n  m32& access(size_t i, size_t j) {\n    data[i][j] *= pow2[count - done[i][j]];\n    done[i][j] = count;\n    return data[i][j];\n  }\n\n};\n\nint main() {\n  size_t N, Q;\n  std::cin >> N >> Q;\n  std::vector<i32> A(N);\n  for (auto &x: A) {\n    std::cin >> x;\n  }\n  propagation_array invert(N, N);\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i] < A[j]) {\n        invert.access(i, j) = m32(1);\n      }\n    }\n  }\n  while (Q--) {\n    size_t x, y;\n    std::cin >> x >> y;\n    --x; --y;\n    if (x > y) {\n      std::swap(x, y);\n    }\n    invert.multiply();\n    for (size_t k = 0; k < N; ++k) {\n      if (k != x && k != y) {\n        invert.reduce(k, x);\n        invert.reduce(k, y);\n        invert.reduce(x, k);\n        invert.reduce(y, k);\n        invert.access(k, x) = invert.access(k, y) = invert.access(k, x) + invert.access(k, y);\n        invert.access(x, k) = invert.access(y, k) = invert.access(x, k) + invert.access(y, k);\n      }\n    }\n    invert.reduce(x, x);\n    invert.reduce(x, y);\n    invert.reduce(y, x);\n    invert.reduce(y, y);\n    invert.access(x, y) = invert.access(y, x) = invert.access(x, y) + invert.access(y, x);\n    invert.access(x, x) = invert.access(y, y) = invert.access(x, x) + invert.access(y, y);\n  }\n  m32 ans;\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < i; ++j) {\n      ans += invert.access(i, j);\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nconst int N=3005,P=1e9+7,inv2=500000004;\ninline void Add(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);\n\treturn res;\n}\nstruct node{int x,y;}p[N];\nint f[N][N],ans[2][N][N],a[N];\nint n,q,res;\nvoid solve(int pos){\n\tint tag=1;\n\tfd(t,q,1){\n\t\ttag=mul(tag,2);\n\t\tint x=p[t].x,y=p[t].y;\n\t\tint c=f[x][y],d=f[y][x];\n\t\tfp(i,1,n)if(i!=x&&i!=y){\n\t\t\tf[x][i]=f[y][i]=mul(add(f[x][i],f[y][i]),inv2),\n\t\t\tf[i][x]=f[i][y]=mul(add(f[i][x],f[i][y]),inv2);\n\t\t}\n\t\tf[x][y]=f[y][x]=mul(add(c,d),inv2),f[x][x]=f[y][y]=0;\n\t}\n\tfp(i,1,n)fp(j,1,n)ans[pos][i][j]=mul(f[i][j],tag);\n}\nvoid init(){\n\tfp(i,1,n)fp(j,1,n)f[i][j]=0;\n\tfp(i,1,n)fp(j,i+1,n)f[i][j]=1;\n\tsolve(0);\n\tfp(i,1,n)fp(j,1,n)f[i][j]=0;\n\tfp(i,1,n)fp(j,1,i-1)f[i][j]=1;\n\tsolve(1);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),q=read();\n\tfp(i,1,n)a[i]=read();\n\tfp(i,1,q)p[i].x=read(),p[i].y=read();\n\tinit();\n\tfp(i,1,n)fp(j,i+1,n)Add(res,a[i]==a[j]?0:a[i]>a[j]?ans[0][i][j]:ans[1][i][j]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _WIN32\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nconst int MOD = ten(9) + 7;\n\nll pow2[3001];\n\nvoid init() {\n\tpow2[0] = 1;\n\tFOR(i, 3000) pow2[i + 1] = pow2[i] * 2 % MOD;\n}\n\nstruct P {\n\tll val;\n\tint lastUpdatedTurn;\n\n\tll get(int currentTurn) const {\n\t\tif (currentTurn < lastUpdatedTurn) {\n\t\t\tcout << \"?\";\n\t\t}\n\t\treturn val * pow2[currentTurn - lastUpdatedTurn] % MOD;\n\t}\n};\n\nP add(const P& l, const P& r, int turn) {\n\tP ret;\n\tret.val = l.get(turn - 1) + r.get(turn - 1);\n\tif (ret.val >= MOD) ret.val -= MOD;\n\tret.lastUpdatedTurn = turn;\n\treturn ret;\n}\n\nP dp[3000][3000];\n\nint main() {\n\tinit();\n\n\tint n, q; reader(n, q);\n\tvector<int> a(n); FOR(i, n) reader(a[i]);\n\tFOR(i, n) FOR(j, n) {\n\t\tif (a[i] > a[j]) dp[i][j].val = 1;\n\t}\n\n\tFOR(i, q) {\n\t\tconst int turn = i + 1;\n\t\tint x, y; reader(x, y);\n\t\tx--; y--;\n\t\tif (x > y) swap(x, y);\n\t\tdp[x][y] = add(dp[x][y], dp[y][x], turn);\n\t\tdp[y][x] = dp[x][y];\n\t\tFOR(i, n) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[x][i] = add(dp[x][i], dp[y][i], turn);\n\t\t\tdp[y][i] = dp[x][i];\n\t\t}\n\t\tFOR(i, n) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[i][x] = add(dp[i][x], dp[i][y], turn);\n\t\t\tdp[i][y] = dp[i][x];\n\t\t}\n\t}\n\n\tll ans = 0;\n\tFOR(l, n) {\n\t\tfor (int r = l + 1; r < n; r++) {\n\t\t\tll cur = dp[l][r].get(q);\n\t\t\tans += cur;\n\t\t}\n\t}\n\tans = (ans % MOD + MOD) % MOD;\n\twriterLn(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\nconst int N = 3005;\nconst int mod = 1000000007;\nint n,m,a[N],f[N][N],ans;\nint main(){\n\tn=gi();m=gi();\n\tfor (int i=1;i<=n;++i) a[i]=gi();\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tf[i][j]=(a[i]<a[j]);\n\tfor (int t=1;t<=m;++t){\n\t\tint x=gi(),y=gi();\n\t\tfor (int i=1;i<=n;++i)\n\t\t\tif (i!=x&&i!=y){\n\t\t\t\tf[i][x]=f[i][y]=500000004ll*(f[i][x]+f[i][y])%mod;\n\t\t\t\tf[x][i]=f[y][i]=500000004ll*(f[x][i]+f[y][i])%mod;\n\t\t\t}\n\t\tf[x][y]=f[y][x]=500000004ll*(f[x][y]+f[y][x])%mod;\n\t}\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n;++j)\n\t\t\tans=(ans+f[j][i])%mod;\n\tfor (int i=1;i<=m;++i) ans=(ans<<1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nusing P = Pa<int,int>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q;\n    cin >> N >> Q;\n    vec<int> A(N);\n    for(int i=0;i<N;i++) cin >> A[i];\n    vvec<mint> dp(N,vec<mint>(N));\n    for(int i=0;i<N;i++) for(int j=0;j<N;j++) if(A[i]<=A[j]) dp[i][j] = 1;\n    mint inv2 = ((mint) (2)).inv();\n    for(int _=0;_<Q;_++){\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if(x>y) swap(x,y);\n        map<P,mint> mp;\n        for(int i=0;i<N;i++){\n            mp[{i,x}] = dp[i][x];\n            mp[{x,i}] = dp[x][i];\n            mp[{i,y}] = dp[i][y];\n            mp[{y,i}] = dp[y][i];\n        }\n        for(int i=0;i<N;i++){\n            if(i!=x && i!=y){\n                dp[i][x] = (mp[{i,x}]+mp[{i,y}])*inv2;\n                dp[x][i] = (mp[{x,i}]+mp[{y,i}])*inv2;\n            }\n            if(i!=x && i!=y){\n                dp[i][y] = (mp[{i,y}]+mp[{i,x}])*inv2;\n                dp[y][i] = (mp[{y,i}]+mp[{x,i}])*inv2;\n            }\n        }\n        dp[x][y] = (mp[{x,y}]+mp[{y,x}])*inv2;\n        dp[y][x] = (mp[{x,y}]+mp[{y,x}])*inv2;\n    }\n    mint ans = 0;\n    //for(int i=0;i<N;i++) for(int j=0;j<N;j++) cerr << dp[i][j] << (j!=N-1? \" \":\"\\n\");\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++) ans += ((mint) 1-dp[i][j]);\n    cout << ans*((mint) 2).pow(Q) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// AGC030D\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > pii;\ntypedef long long LL;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nconst LL MOD=1000000007ll,i2=(MOD+1ll)/2ll;\nint n,q,a[3005],dp[3005][3005];\nint pw[3005];\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(i=0;i<n;++i) scanf(\"%d\",a+i);\n\tpw[0]=1;\n\tfor(i=1;i<=q;++i){\n\t\tpw[i]=(LL)pw[i-1]*2ll%MOD;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tdp[i][j]=(a[i]>a[j]);\n\t\t}\n\t}\n\tfor(i=0;i<q;++i){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\t--x;--y;\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tdp[x][j]=dp[y][j]=(LL)(dp[x][j]+dp[y][j])*(LL)i2%MOD;\n\t\t}\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tdp[j][x]=dp[j][y]=(LL)(dp[j][x]+dp[j][y])*(LL)i2%MOD;\n\t\t}\n\t\tdp[x][x]=dp[y][y]=0;\n\t\tdp[x][y]=dp[y][x]=(LL)(dp[x][y]+dp[y][x])*(LL)i2%MOD;\n\t}\n\tLL res=0ll;\n\tfor(i=0;i<n;++i){\n\t\tfor(j=i+1;j<n;++j){\n\t\t\tres+=(LL)dp[i][j]*(LL)pw[q]%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint mod = 1000000007;\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nsigned main(){\n\n    int N, Q; cin >> N >> Q;\n    vec A(N); readv(A);\n    vec X(Q), Y(Q);\n    REP(i, Q){\n        cin >> X[i] >> Y[i];\n        X[i]--;\n        Y[i]--;\n    }\n\n    int inv2 = modpow(2, mod - 2, mod);\n\n    mat p(N, vec(N, 0));\n    REP(i, N) REP(j, N) if(A[i] < A[j]) p[i][j] = 1;\n    \n    REP(q, Q){\n        REP(i, N){\n            if(i == X[q] || i == Y[q]) continue;\n            int ave = ((p[i][X[q]] + p[i][Y[q]]) * inv2) % mod;\n            p[i][X[q]] = ave;\n            p[i][Y[q]] = ave;\n            ave = ((p[X[q]][i] + p[Y[q]][i]) * inv2) % mod;\n            p[X[q]][i] = ave;\n            p[Y[q]][i] = ave;\n        }\n        int ave = ((p[X[q]][Y[q]] + p[Y[q]][X[q]]) * inv2) % mod;\n        p[X[q]][Y[q]] = ave;\n        p[Y[q]][X[q]] = ave;\n    }\n    int ans = 0;\n    REP(i, N) REP(j, i) ans = (ans + p[i][j]) % mod;\n    ans = (ans * modpow(2, Q, mod)) % mod;\n\n    cout << ans;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define ll long long\n#define mo 1000000007\n#define maxn 3005\ninline ll read()\n{\n\tll x=0,w=0;char ch=getchar();\n\twhile(!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn w?-x:x;\n}\ninline int ksm(int x,int y=mo-2)\n{\n    int a=1;\n    while(y)\n    {\n        if(y&1)a=1ll*a*x%mo;\n        x=1ll*x*x%mo;y>>=1;\n    }return a;\n}\ninline void Add(int &x,int y){x+=y;x-=(x>=mo?mo:0);}\ninline int add(int x,int y){x+=y;return x>=mo?x-mo:x;}\nint n,q;\nint a[maxn];\nint dp[maxn][maxn];\nint main()\n{\n    n=read(),q=read();\n    reg int i,j;\n    for(i=1;i<=n;++i)a[i]=read();\n    for(i=1;i<=n;++i)\n        for(j=1;j<=n;++j)\n            if(a[i]>a[j])dp[i][j]=1;\n    reg int x,y,inv2=ksm(2);\n    for(i=1;i<=q;++i)\n    {\n        x=read(),y=read();\n        dp[x][y]=dp[y][x]=1ll*inv2*(dp[x][y]+dp[y][x])%mo;\n        for(j=1;j<=n;++j)\n        {\n            if(j==x||j==y)continue;\n            dp[j][x]=dp[j][y]=1ll*inv2*(dp[j][x]+dp[j][y])%mo;\n            dp[x][j]=dp[y][j]=1ll*inv2*(dp[x][j]+dp[y][j])%mo;\n        }\n    }\n    reg int ans=0;\n    for(i=1;i<=n;++i)\n        for(j=i+1;j<=n;++j)\n            Add(ans,dp[i][j]);\n    ans=1ll*ans*ksm(2,q)%mo;\n    printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3050,mo=1e9+7,P=(mo+1)/2;\ninline int gi() {\n  char ch=getchar(); int q=0,x=0;\n  while(ch<'0'||ch>'9') q=(ch=='-'?1:q),ch=getchar();\n  while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q?(-x):x;\n}\nint a[N],f[N][N],g[N][N],p[N],t[N];\nint main(){\n  int n,q,x,y,s=1; cin>>n>>q;\n  for (int i=1; i<=n; ++i) a[i]=gi();\n  for (int i=1; i<=n; ++i)\n    for (int j=1; j<=n; ++j){\n      if (a[i]<a[j]) f[i][j]=1;\n      if (a[i]>a[j]) g[i][j]=1;\n    }\n  for (int i=1; i<=q; ++i){\n    x=gi(),y=gi(),s=s*2%mo;\n    for (int j=1; j<=n; ++j)\n      if(j!=x&&j!=y) {\n\tf[j][x]=f[j][y]=1ll*P*(f[j][x]+f[j][y])%mo;\n\tf[x][j]=f[y][j]=1ll*P*(f[x][j]+f[y][j])%mo;\n      }\n    f[x][y]=f[y][x]=1ll*P*(f[x][y]+f[y][x])%mo;\n  }\n  int ans=0;\n  for(int i=1; i<=n; ++i)\n    for(int j=i+1; j<=n; ++j)\n      ans=(ans+1ll*f[j][i]*s)%mo;\n  cout<<ans;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.12.2018 15:24:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<vector<int>> b(n, vector<int>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      b[i][j] = (a[i] < a[j]);\n    }\n  }\n  int inv2 = inv(2);\n  int final_coeff = power(2, tt);\n  while (tt--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    for (int i = 0; i < n; i++) {\n      if (i != x && i != y) {\n        {\n          int sum = b[i][x];\n          add(sum, b[i][y]);\n          sum = mul(sum, inv2);\n          b[i][x] = b[i][y] = sum;\n        }\n        {\n          int sum = b[x][i];\n          add(sum, b[y][i]);\n          sum = mul(sum, inv2);\n          b[x][i] = b[y][i] = sum;\n        }\n      }\n    }\n    {\n      int sum = b[x][y];\n      add(sum, b[y][x]);\n      sum = mul(sum, inv2);\n      b[x][y] = b[y][x] = sum;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      add(ans, b[i][j]);\n    }\n  }\n  ans = mul(ans, final_coeff);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=3000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL a[NN][NN]={};\nint seq[NN]={};\nconst int mod=1e9+7;\nint main(){\n\t//open();\n\tn=read();\n\tint q=read();\n\tfor(int i=1;i<=n;++i)seq[i]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\ta[i][j]=(seq[i]>seq[j]?1:0);\n\t\t}\n\t}\n\tint rev2=(mod+1)>>1;\n\tfor(int i=1;i<=q;++i){\n\t\tint x=read(),y=read();\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(i!=y&&i!=x){\n\t\t\t\ta[y][i]=a[x][i]=rev2*(a[x][i]+a[y][i])%mod;\n\t\t\t\ta[i][y]=a[i][x]=rev2*(a[i][x]+a[i][y])%mod;\n\t\t\t}\n\t\t}\n\t\ta[y][x]=a[x][y]=rev2*(a[y][x]+a[x][y])%mod;\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tans+=a[i][j];\n\t\t\tans%=mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tans=ans*2%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 3e3 + 5;\nconst int mod = 1e9 + 7;\nconst int inv = 5e8 + 4; \nusing namespace std; \n\nint n, q, a[N], f[N][N], ans; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint main()\n{\n\tn = read <int> (), q = read <int> ();\n\tfor(int i = 1; i <= n; i++)\n\t\ta[i] = read <int> ();\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tf[i][j] = a[i] > a[j]; \n\tfor(int x, y, i = 1; i <= q; i++)\n\t{\n\t\tx = read <int> (), y = read <int> ();\n\t\tf[x][y] = f[y][x] = 1ll * (f[x][y] + f[y][x]) % mod * inv % mod; \n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(j == x || j == y) continue;\n\t\t\tf[x][j] = f[y][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv % mod; \n\t\t\tf[j][x] = f[j][y] = 1ll * (f[j][x] + f[j][y]) % mod * inv % mod; \n\t\t}\n\t}\n\tfor(int i = n; i >= 1; i--)\n\t\tfor(int j = i - 1; j >= 1; j--)\n\t\t\tans = (ans + f[j][i]) % mod; \n\tprintf(\"%lld\\n\", 1ll * ans * fpow(2, q) % mod); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 3e3 + 5;\nint a[N];\nint dp[N][N];\nint x[N], y[N];\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) / 2;\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, q;\n  cin>>n>>q;\n  RE (i, n) {\n    cin>>a[i];\n  }\n  RE (i, q) {\n    cin>>x[i]>>y[i];\n    if (x[i] > y[i]) {\n      swap(x[i], y[i]);\n    }\n  }\n//   RE (i, n) {\n//     RE (j, i - 1) {\n//       dp[i][j] = 0;\n//     }\n//   }\n  FORD (i, q, 1) {\n    dp[x[i]][y[i]] = inv2;\n    dp[y[i]][x[i]] = inv2;\n    VI ziom{x[i], y[i]};\n    RE (j, n) {\n      if (j == x[i] || j == y[i]) { continue; }\n//       for (auto from : ziom) {\n//         int to = x[i] + y[i] - from;\n        int neguj = (y[i] > j) != (x[i] > j);\n//         int sec = dp[j][to];\n//         if (neguj) {\n//           sec = (P + 1 - dp[j][to]);\n//           if (sec >= P) {\n//             sec -= P;\n//           }\n//         }\n        int nx = -1;\n        int ny = -1;\n        if (neguj) {\n          nx = (dp[j][x[i]] + 1 - dp[j][y[i]]) * inv2 % P;\n          ny = (dp[j][y[i]] + 1 - dp[j][x[i]]) * inv2 % P;\n        } else {\n          nx = (dp[j][x[i]] + dp[j][y[i]]) * inv2 % P;\n          ny = nx;\n        }\n        dp[j][x[i]] = nx;\n        dp[j][y[i]] = ny;\n        dp[x[i]][j] = /*P + 1 -*/ nx;\n//         if (dp[x[i]][j] >= P) {\n//           dp[x[i]][j] -= P;\n//         }\n        dp[y[i]][j] =/* P + 1 - */ny;\n//         if (dp[y[i]][j] >= P) {\n//           dp[y[i]][j] -= P;\n//         }\n    }\n  }\n  int res = 0;\n  RE (i, n) {\n    FOR (j, i + 1, n) {\n      if (a[i] < a[j]) {\n        res += dp[i][j];\n      } else if (a[i] > a[j]) {\n        res += 1 - dp[i][j];\n      }\n    }\n    res %= P;\n    res += P;\n    res %= P;\n  }\n  RE (i, q) {\n    res = res * 2 % P;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define cerr cout\n#define F first\n#define S second\n#define FOR(i,a,b) for (auto i = (a); i <= (b); ++i)\n#define NFOR(i,a,b) for(auto i = (a); i >= (b); --i)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\ntypedef long long ll; typedef pair <int, int> ii; typedef vector <int> vi; const int inf = 1e9 + 7;\nstring to_string(string s) { return '\"' + s + '\"';}\nstring to_string(char s) { return string(1, s);}\nstring to_string(const char* s) { return to_string((string) s);}\nstring to_string(bool b) { return (b ? \"true\" : \"false\");}\ntemplate <typename A> string to_string(A);\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\ntemplate <typename A> string to_string(A v) {bool f = 1; string r = \"{\"; for (const auto &x : v) {if (!f)r += \", \"; f = 0; r += to_string(x);} return r + \"}\";}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H); debug_out(T...);}\n#define pr(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\ntemplate<int MOD>\nstruct ModInt {\n    static const int Mod = MOD;\n    unsigned x;\n    ModInt() : x(0) {}\n    ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n    ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n    int get() const { return (int)x; }\n    bool operator==(ModInt that) const {return this->x == that.x;}\n\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt &operator^=(ModInt<MOD - 1> that) { *this = that; return *this; }\n\n    friend ostream& operator<<(ostream& out, const ModInt& yo) { out << yo.x; return out; }\n\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n    ModInt operator^(ModInt<MOD - 1> that) const {\n    \tModInt ans = 1;\n    \tModInt a = *this;\n    \twhile (that.x > 0) {\n    \t\tif (that.x & 1) ans = ans * a;\n    \t\ta = a * a;\n    \t\tthat.x >>= 1;\n    \t}\n    \treturn ans;\n    }\n\n    ModInt inverse() const {\n        signed a = x, b = MOD, u = 1, v = 0;\n        while (b) {\n            signed t = a / b;\n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        if (u < 0) u += Mod;\n        ModInt res; res.x = (unsigned)u;\n        return res;\n    }\n};\ntemplate<int MOD> string to_string(ModInt<MOD> x) {return to_string(x.x);}\ntypedef ModInt<inf> mint;\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint n, q; cin >> n >> q; vi a(n);\n\tFOR (i, 0, n - 1) cin >> a[i];\n\n\tvector<vector<mint>> p(n);\n\tFOR (i, 0, n-1) {\n\t\tFOR (j, 0, n-1) {\n\t\t\tp[i].emplace_back(a[i] > a[j]);\n\t\t}\n\t}\n\n\n\tmint ti = mint(1) / 2;\n\n\tFOR (it, 1, q) {\n\t\tint x, y; cin >> x >> y; --x, --y;\n\t\t\n\t\tFOR (i, 0, n - 1) if (i != x and i != y) {\n\t\t\tp[i][y] = p[i][x] = ti * (p[i][x] + p[i][y]);\n\t\t\tp[y][i] = p[x][i] = ti * (p[x][i] + p[y][i]); \n\t\t}\n\t\tp[x][y] = p[y][x] = ti * (p[x][y] + p[y][x]);\n\t}\n\n\tmint ans = 0;\n\n\tFOR (i, 0, n - 1) FOR (j, i+1, n-1) ans += p[i][j];\n\tcout << ans * (mint(2) ^ q);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(int64_t k) const {\n        ModInt ret(1), mul(x);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<mod>;\n\nint N, Q;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> N >> Q;\n    V<int> A(N);\n    rep(i, N) cin >> A[i];\n    V<V<modint>> dp(N, V<modint>(N));\n    modint inv2(mod + 1 >> 1);\n    rep(i, N) rep(j, N) dp[i][j] = (A[i] > A[j]);\n    rep(_, Q) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * inv2;\n        rep(i, N) {\n            if(i != x && i != y) {\n                dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * inv2;\n                dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * inv2;\n            }\n        }\n    }\n    modint ans;\n    rep(i, N) FOR(j, i + 1, N) ans += dp[i][j];\n\n    cout << ans * modint(2).pow(Q) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 3009\nusing namespace std;\n\nint n,m,a[N],f[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j,x,y,tmp;\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=1; j<=n; j++) f[i][j]=(a[i]<a[j]);\n\tint t=1;\n\twhile (m--){\n\t\tt=t*2%mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor (i=1; i<=n; i++) if (i!=x && i!=y){\n\t\t\ttmp=(f[x][i]+f[y][i])%mod; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\t\tf[x][i]=f[y][i]=tmp%mod;\n\t\t\ttmp=(f[i][x]+f[i][y])%mod; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\t\tf[i][x]=f[i][y]=tmp%mod;\n\t\t}\n\t\ttmp=(f[x][y]+f[y][x])%mod; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\tf[x][y]=f[y][x]=tmp%mod;\n\t}\n\tint ans=0;\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=1; j<i; j++) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",(ll)ans*t%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007, inv2 = 500000004; \nnamespace Modulo {\n    int qpow(int x, int b) {int res = 1;while (b) {if (b & 1) res = 1LL * res * x % MOD;x = 1ll * x * x % MOD;b >>= 1;}return res; }\n    int inv(int x) {int b = MOD - 2, res = 1;while (b) {if (b & 1) res = 1LL * res * x % MOD;x = 1ll * x * x % MOD;b >>= 1;}return res; }\n    int add(int a, int b) {a += b;if (a >= MOD) a -= MOD;return a; }\n    int mns(int a, int b) {a += MOD;a -= b;while (a >= MOD) a -= MOD;return a; }\n    int mul(int a, int b) {return 1ll * a * b % MOD;}\n    int divi(int a, int b) {if (b == 2) return 1ll * a * inv2 % MOD; return 1ll * a * inv(b) % MOD;}\n}\nusing namespace Modulo;\n\nconst int N = 3005; \nint n, q, a[N];\nint prob[N][N], prob1[N][N];\n\n\n\nint main() {\n    scanf(\"%d%d\", &n, &q);\n    for (int i = 1; i <= n; i++) scanf (\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++)\n            prob[j][i] = (a[j] > a[i]);\n    }\n    int q1 = q; \n    while (q--) {\n        int x, y;\n        scanf (\"%d%d\", &x, &y);\n        if (x == y) continue;\n        for (int i = 1; i <= n; i++) {\n            if (i != x && i != y) {\n                prob1[x][i] = divi(add(prob[x][i], prob[y][i]), 2);\n                prob1[i][x] = divi(add(prob[i][x], prob[i][y]), 2);\n                prob1[y][i] = prob1[x][i]; prob1[i][y] = prob1[i][x]; \n            } \n        }\n\n        prob1[x][y] = prob1[y][x] = divi(add(prob[x][y], prob[y][x]), 2);\n        for (int i = 1; i <= n; i++) {\n            prob[x][i] = prob1[x][i];\n            prob[y][i] = prob1[y][i];\n            prob[i][x] = prob1[i][x];\n            prob[i][y] = prob1[i][y]; \n        }\n    }\n    int ans = 0; \n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j < i; j++)\n            ans = add(ans, prob[j][i]);\n    cout << 1LL * ans * qpow(2, q1) % MOD << endl; \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 3200\n#define LL long long\n\nconst int mod=1000000007,i2=500000004;\nint n,m,x,y,a[N],f[N][N],ans;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) f[i][j]=a[i]>a[j];\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (j==x||j==y) continue;\n\t\t\tf[x][j]=f[y][j]=((LL)f[x][j]+f[y][j])*i2%mod;\n\t\t\tf[j][x]=f[j][y]=((LL)f[j][x]+f[j][y])*i2%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=((LL)f[x][y]+f[y][x])*i2%mod;\n\t}\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i;j<=n;++j) ans=(ans+f[i][j])%mod;\n\twhile (m--) ans=ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace mint {\n  constexpr int md = 1e9 + 7;\n  inline void add (int &a, int b) {\n    a += b; if (a >= md) a -= md;\n  }\n  inline void sub (int &a, int b) {\n    a -= b; if (a < 0) a += md;\n  }\n  inline int sum (int a, int b) {\n    add(a, b); return a;\n  }\n  inline int dif (int a, int b) {\n    sub(a, b); return a;\n  }\n  inline int prod (int a, int b) {\n    return (int)((long long)a * b % md);\n  }\n  inline void mul (int &a, int b) {\n    a = prod(a, b);\n  }\n  inline int inv (int a) {\n    a %= md;\n    if(a < 0) a += md;\n    int b = md, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= a * t; swap(a, b);\n      u -= v * t; swap(u, v);\n    }\n    assert(b == 1);\n    if(u < 0) u += md;\n    return u;\n  }\n  inline int quat (int a, int b) {\n    return prod(a, inv(b));\n  }\n  inline void div (int& a, int b) {\n    a = quat(a, b);\n  }\n  inline int pow (int a, long long b) {\n    int res = 1;\n    for (; b; b >>= 1) {\n      if (b & 1) mul(res, a);\n      mul(a, a);\n    }\n    return res;\n  }\n}\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  int inv2 = mint::inv(2);\n  int coeff = mint::pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      mint::add(a, b);\n      a = b = mint::prod(a, inv2);\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      mint::mul(dp[i][j], coeff);\n      mint::add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const i64 mod = 1'000'000'007;\n    i64 N,Q;\n    cin >> N >> Q;\n\n    if(max(Q*N*N,N*N*N)>=300000000){\n        assert(false);\n    }\n\n    vector<i64> A(N);\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<i64> X(Q),Y(Q);\n    rep(i,0,Q){\n        cin >> X[i] >> Y[i];\n        --X[i];\n        --Y[i];\n    }\n\n    const i64 size=3000;\n    static i64 dp[size][size];\n    fill_n((i64*)dp,size*size,0);\n    rep(i,0,N) {\n        rep(j, 0, N) {\n            if (A[j] <= A[i]) continue;\n            ++dp[j][i];\n        }\n    }\n\n    rep(j,0,Q){\n        i64 x=X[j],y=Y[j];\n        i64 tmpxy=dp[x][y],tmpyx=dp[y][x];\n        rep(k,0,N){\n            if(k==x or k==y) continue;\n            rep(l,0,N){\n                if(l==x or l==y) continue;\n                dp[k][l]*=2;\n                dp[k][l]%=mod;\n            }\n        }\n\n        vector<i64> xk(N),kx(N),yk(N),ky(N);\n        rep(k,0,N){\n            xk[k]=dp[x][k];\n            kx[k]=dp[k][x];\n            yk[k]=dp[y][k];\n            ky[k]=dp[k][y];\n        }\n        rep(k,0,N){\n            if(k==x) continue;\n            dp[x][k]+=yk[k];\n            dp[x][k]%=mod;\n            dp[k][x]+=ky[k];\n            dp[k][x]%=mod;\n        }\n\n        rep(k,0,N){\n            if(k==y) continue;\n            dp[y][k]+=xk[k];\n            dp[y][k]%=mod;\n            dp[k][y]+=kx[k];\n            dp[k][y]%=mod;\n        }\n\n        dp[y][x]+=tmpxy;\n        dp[y][x]%=mod;\n        dp[x][y]+=tmpyx;\n        dp[x][y]%=mod;\n    }\n\n    i64 ans =0;\n    rep(j,0,N){\n        rep(k,j+1,N){\n            ans+=dp[j][k];\n            ans%=mod;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=3010,mod=1e9+7;\nconst int inv2=(mod+1)/2;\nint f[N][N],n;\nint A[N],xi[N],m;\nint main() {\n\tint q,x,y; rd(n),rd(q);\n\tfor(int i=1;i<=n;++i) rd(A[i]),xi[i]=A[i];\n\tsort(xi+1,xi+n+1);\n\tm=unique(xi+1,xi+n+1)-xi-1;\n\tfor(int i=1;i<=n;++i) A[i]=lower_bound(xi+1,xi+m+1,A[i])-xi;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j) if(i!=j)\n\t\t\tf[i][j]=A[i]>A[j];\n\tint ax=1;\n\twhile(q--) {\n\t\tax=ax*2ll%mod;\n\t\tint x,y; rd(x),rd(y);\n\t\tfor(int i=1;i<=n;++i) if(i!=x&&i!=y) {\n\t\t\tint tmp1=(f[i][x]+f[i][y])*(ll)inv2%mod;\n\t\t\tf[i][x]=f[i][y]=tmp1;\n\t\t\tint tmp2=(f[x][i]+f[y][i])*(ll)inv2%mod;\n\t\t\tf[x][i]=f[y][i]=tmp2;\n\t\t}\n\t\tint tmp=(f[x][y]+f[y][x])*(ll)inv2%mod;\n\t\tf[x][y]=f[y][x]=tmp;\n\t}\n//\tfor(int i=1;i<=n;++i,puts(\"\"))\n//\t\tfor(int j=1;j<=n;++j)\n//\t\t\tprintf(\"%d \",f[i][j]);\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tans=(ans+f[i][j])%mod;\n\tprintf(\"%d\",ans*(ll)ax%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 3010\nll po[N];\n\nll n,dat[N],q;\nll ok[N][N],ng[N][N];\nll rui[N][N],zen;\nll oe[N][N],ne[N][N];\n\nvoid eval(ll a,ll b){\n    ll dex=zen-rui[a][b];\n    ok[a][b]=ok[a][b]*po[dex]%mod;\n    ng[a][b]=ng[a][b]*po[dex]%mod;\n    rui[a][b]=zen;\n}\nvoid eva(ll a,ll b){\n    eval(a,b);\n    eval(b,a);\n}\n\nvoid setoe(ll a,ll b,ll x){\n    oe[a][b]=oe[b][a]=x;\n}\nvoid setne(ll a,ll b,ll x){\n    ne[a][b]=ne[b][a]=x;\n}\n\nvoid upe(ll a,ll b){\n    ok[a][b]+=oe[a][b];ok[a][b]%=mod;oe[a][b]=0;\n    ng[a][b]+=ne[a][b];ng[a][b]%=mod;ne[a][b]=0;\n    rui[a][b]=zen;\n}\nvoid outs(ll a,ll b){\n    eva(a,b);\n    cout<<a+1<<\" \"<<b+1<<\":\"<<ok[a][b]<<\" \"<<ng[a][b]<<endl;\n}\nvoid oute(){\n    outs(0,4);outs(1,2);\n}\n\nvoid upd(ll a,ll b){\n    lol(i,n){\n\teva(a,i);\n\teva(b,i);\n    }\n    setoe(a,b,ng[a][b]);\n    setne(a,b,ok[a][b]);\n    for(ll x=0;x<n;x++){\n\tif(x==a||x==b)continue;\n\tif(x<a||b<x){\n\t    setoe(x,a,ok[x][b]);\n\t    setoe(x,b,ok[x][a]);\n\t    setne(x,a,ng[x][b]);\n\t    setne(x,b,ng[x][a]);\n\t    continue;\n\t}\n\tsetoe(x,a,ng[x][b]);\n\tsetoe(x,b,ng[x][a]);\n\tsetne(x,a,ok[x][b]);\n\tsetne(x,b,ok[x][a]);\n    }\n    zen++;\n    lol(i,n){\n\tupe(a,i);upe(i,a);\n\tupe(b,i);upe(i,b);\n    }\n}\nint main(){\n    po[0]=1; for(ll i=1;i<N;i++)po[i]=po[i-1]*2%mod;\n    \n    cin>>n>>q;\n    lol(i,n)scanf(\"%lld\",&dat[i]);\n    lol(i,n)lol(j,n){\n\tif(dat[i]==dat[j]){\n\t    ok[i][j]=ng[i][j]=0;\n\t    continue;\n\t}\n\tif(dat[i]<dat[j] xor i<j){\n\t    ok[i][j]=0,ng[i][j]=1;\n\t}\n\telse ok[i][j]=1,ng[i][j]=0;\n\trui[i][j]=0;\n    }\n    zen=0;\n    while(q--){\n\tll a,b;\n\tscanf(\"%lld%lld\",&a,&b);\n\ta--,b--;\n\tupd(min(a,b),max(a,b));\n    }\n    ll ans=0;\n    lol(i,n)lol(j,i){\n\teva(i,j);\n\tans=(ans+ng[i][j])%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\nconst int MAXN=3111;\nconst LL Md=1000000007;\nconst LL Inv2=(Md+1)/2;\nLL f[MAXN][MAXN];\nLL tf[MAXN][MAXN];\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=n;++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tf[i][j]=(a[i]>a[j] ? 1 : 0);\n\t\t}\n\t}\n\tLL wgh=1;\n\tfor(int i=1, x, y;i<=m;++i) {\n\t\twgh=wgh*2ll%Md;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\ttf[x][j]=(f[y][j]*Inv2%Md+f[x][j]*Inv2%Md)%Md;\n\t\t\ttf[j][x]=(f[j][y]*Inv2%Md+f[j][x]*Inv2%Md)%Md;\n\t\t\ttf[y][j]=(f[y][j]*Inv2%Md+f[x][j]*Inv2%Md)%Md;\n\t\t\ttf[j][y]=(f[j][y]*Inv2%Md+f[j][x]*Inv2%Md)%Md;\n\t\t}\n\t\ttf[x][y]=(f[x][y]*Inv2%Md+f[y][x]*Inv2%Md)%Md;\n\t\ttf[y][x]=(f[y][x]*Inv2%Md+f[x][y]*Inv2%Md)%Md;\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tf[x][j]=tf[x][j];\n\t\t\tf[j][x]=tf[j][x];\n\t\t\tf[y][j]=tf[y][j];\n\t\t\tf[j][y]=tf[j][y];\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i) {\n\t\tfor(int j=i+1;j<=n;++j) {\n\t\t\tans=(ans+f[i][j])%Md;\n\t\t}\n\t}\n\tans=ans*wgh%Md;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*+lmake\n * STD = c++14\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<LL, LL> pll;\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#define massert(x) assert(x)\n#else\n#define debug(args...) // Just strip off all debug tokens\n#define massert(x)\n#endif\nstruct debugger\n{\n    template<typename T> debugger& operator , (const T& v)\n    {    \n        cerr<<v<<\" \";    \n        return *this;    \n    }\n} dbg;\n\ntemplate <typename T>\ninline void chmax(T &a, T b)\n{\n    a = std::max(a, b);\n}\n\ntemplate <typename T>\ninline void chmin(T &a, T b)\n{\n    a = std::min(a, b);\n}\n\ntemplate <typename T>\ninline T sqr(const T& x)\n{\n\treturn x*x;\n}\n\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    char _I_Buffer[_I_Buffer_Size];\n    char *_I_pos;\n    const char *_I_end;\n\n    char _O_Buffer[_O_Buffer_Size];\n    char *_O_pos;\n    const char *_O_end;\n\n    IO_Tp()\n        : _I_pos(_I_Buffer)\n        , _O_pos(_O_Buffer)\n        , _I_end(_I_Buffer + _I_Buffer_Size)\n        , _O_end(_O_Buffer + _O_Buffer_Size)\n    {\n    }\n\n    ~IO_Tp() { fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout); }\n\n    inline char getchar()\n    {\n        char res = *_I_pos;\n        nextchar();\n        return res;\n    }\n\n    inline bool is_digit(const char ch) { return '0' <= ch && ch <= '9'; }\n\n    inline void nextchar()\n    {\n        ++_I_pos;\n        if (_I_pos == _I_end) {\n            fread(_I_Buffer, 1, _I_Buffer_Size, stdin);\n            _I_pos = _I_Buffer;\n        }\n    }\n\n    template <typename Int>\n    inline IO_Tp &operator>>(Int &res)\n    {\n        res = 0;\n        int k = 1;\n        while (!is_digit(*_I_pos)) {\n            if (*_I_pos == '-')\n                k = -1;\n            nextchar();\n        }\n        do {\n            (res *= 10) += (*_I_pos) - '0';\n            nextchar();\n        } while (is_digit(*_I_pos));\n        res *= k;\n        return *this;\n    }\n\n    inline IO_Tp &operator>>(char &res)\n    {\n        do {\n            res = *_I_pos;\n            nextchar();\n        } while (res == ' ' || res == '\\0' || res == '\\t' || res == '\\n' || res == '\\r');\n        return *this;\n    }\n\n    inline void putchar(char x)\n    {\n        if (_O_pos == _O_end) {\n            fwrite(_O_Buffer, 1, _O_pos - _O_Buffer, stdout);\n            _O_pos = _O_Buffer;\n        }\n        *_O_pos++ = x;\n    }\n    template <typename Int>\n    inline IO_Tp &operator<<(Int n)\n    {\n        if (n < 0) {\n            putchar('-');\n            n = -n;\n        }\n        static char _buf[20];\n        char *_pos(_buf);\n        do\n            *_pos++ = '0' + n % 10;\n        while (n /= 10);\n        while (_pos != _buf)\n            putchar(*--_pos);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(char ch)\n    {\n        putchar(ch);\n        return *this;\n    }\n\n    inline IO_Tp &operator<<(const char *s)\n    {\n        while (*s != 0) {\n            putchar(*s);\n            ++s;\n        }\n        return *this;\n    }\n};\nIO_Tp<> IO;\nconst int MAXN=3000;\nLL f[MAXN+10][MAXN+10];\nLL g[MAXN+10][MAXN+10];\nLL s[MAXN+10][MAXN+10];\nLL tong[MAXN+10];\nconst LL kcz=1e9+7;\nLL qpow(LL x, LL n = kcz - 2)\n{\n    LL ans = 1;\n    while (n > 0) {\n        if (n & 1)\n            ans = ans * x % kcz;\n        x = x * x % kcz;\n        n /= 2;\n    }\n    return ans;\n}\nvoid solve(long long n, long long q, vector<long long> a, vector<long long> x, vector<long long> y){\n\tfor(int i=1; i<=n; ++i) {\n\t\ttong[i]=a[i-1];\n\t}\n\tsort(tong+1,tong+1+n);\n\tint m=unique(tong+1,tong+1+n)-tong-1;\n\tfor(auto &i:a) {\n\t\ti=lower_bound(tong+1,tong+1+m,i)-tong;\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tf[i][a[i-1]]=1;\n\t}\n\tLL inv=qpow(2);\n\tfor(int i=1; i<=q; ++i) {\n\t\tauto u=x[i-1],v=y[i-1];\n\t\tfor(int j=1; j<=n; ++j) {\n\t\t\tf[u][j]=f[u][j]*inv%kcz;\n\t\t\tf[v][j]=f[v][j]*inv%kcz;\n\t\t\tLL s=(f[u][j]+f[v][j])%kcz;\n\t\t\tf[u][j]=f[v][j]=s;\n\t\t}\t\n\t}\n\tLL tt=qpow(2,q);\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=1; j<=n; ++j) {\n\t\t\tf[i][j]=f[i][j]*tt%kcz;\n\t\t}\n\t}\n\tfor(int i=n; i>=1; --i) {\n\t\tfor(int j=1; j<=n; ++j) {\n\t\t\tg[i][j]=(g[i+1][j]+f[i][j])%kcz;\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=1; j<=n; ++j) {\n\t\t\ts[i][j]=(s[i][j-1]+g[i][j])%kcz;\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=1; j<=n; ++j) {\n\t\t\tans=(ans+f[i][j]*s[i+1][j-1])%kcz;\t\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\t\n#ifdef WAAUTOMATON\n\t//freopen(\"in.txt\",\"r\",stdin);\n#endif\n\tlong long Q;\n\tlong long N;\n\tscanf(\"%lld\",&N);\n\tvector<long long> A(N-1+1);\n\tscanf(\"%lld\",&Q);\n\tvector<long long> X(Q-1+1);\n\tvector<long long> Y(Q-1+1);\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tscanf(\"%lld\",&A[i]);\n\t}\n\tfor(int i = 0 ; i <= Q-1 ; i++){\n\t\tscanf(\"%lld\",&X[i]);\n\t\tscanf(\"%lld\",&Y[i]);\n\t}\n\tsolve(N, Q, A, X, Y);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n*/\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n       \n        \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int Mod = 1000000007;\nconst int MAXN = 3008;\n\n\nint sum(int a, int b) {\n    return (a + b) % Mod;\n}\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\n\nint n, q;\nint dp[MAXN][MAXN];\nint a[MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    int kek = powm(2, Mod - 2);\n    for (int it = 0; it < q; it++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        for (int i = 0; i < n; i++) {\n            if (i == x || i == y) {\n                continue;\n            }\n            dp[i][x] = mul(dp[i][x], kek);\n            dp[i][y] = mul(dp[i][y], kek);\n            dp[x][i] = mul(dp[x][i], kek);\n            dp[y][i] = mul(dp[y][i], kek);\n            int c = sum(dp[i][x], dp[i][y]);\n            dp[i][x] = c;\n            dp[i][y] = c;\n            c = sum(dp[x][i], dp[y][i]);\n            dp[x][i] = c;\n            dp[y][i] = c;\n        }\n        dp[x][y] = mul(dp[x][y], kek) + mul(dp[y][x], kek);\n        dp[y][x] = dp[x][y];\n        dp[x][x] = 0;\n        dp[y][y] = 0;\n    }   \n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            ans = sum(ans, dp[i][j]);\n        }\n    }\n    ans = mul(ans, powm(2, q));\n    cout << ans << '\\n';\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=3005,mod=998244353;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n,m,a[N];\nstruct data{int x,y;} dat[N];\nLL f[N][N],g[N][N],A,ans;\n\nint getint()\n{\t\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nvoid inc(LL &x,LL y)\n{\n\tx=(x+y)*inv2%mod;\n}\n\nint main()\n{\n\tn=getint(),m=getint();\n\trep(i,1,n) a[i]=getint();\n\trep(i,1,m) dat[i].x=getint(),dat[i].y=getint();\n\trep(i,1,n) rep(j,1,i-1) f[i][j]=1;\n\tA=1;\n\trepd(i,m,1)\n\t{\n\t\tint x=dat[i].x,y=dat[i].y;\n\t\trep(j,1,n)\n\t\t{\n\t\t\tg[x][j]=f[x][j];\n\t\t\tg[y][j]=f[y][j];\n\t\t\tg[j][x]=f[j][x];\n\t\t\tg[j][y]=f[j][y];\n\t\t}\n\t\trep(j,1,n) if(j!=x && j!=y)\n\t\t{\n\t\t\tinc(f[y][j],g[x][j]),inc(f[j][y],g[j][x]);\n\t\t\tinc(f[x][j],g[y][j]),inc(f[j][x],g[j][y]);\n\t\t}\n\t\tinc(f[x][y],g[y][x]),inc(f[y][x],g[x][y]);\n\t\tA=A*2%mod;\n\t}\n\trep(i,1,n) rep(j,1,n) if(a[i]<a[j]) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",ans*A%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define MAXN 3010\n#define MOD 1000000007\n#define INV 500000004\ninline void trim(int &x) { (x >= MOD) && (x -= MOD); }\ninline void up(int &x, int y) { trim(x += y); }\nint n, q, b = 1, ans = 0, a[MAXN], f[MAXN][MAXN];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tf[i][j] = a[i] > a[j];\n\t\t}\n\t}\n\tfor (int x, y; q; q--) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i != x && i != y) {\n\t\t\t\tf[i][x] = f[i][y] = 1LL * INV * (f[i][x] + f[i][y]) % MOD;\n\t\t\t\tf[x][i] = f[y][i] = 1LL * INV * (f[x][i] + f[y][i]) % MOD;\n\t\t\t}\n\t\t}\n\t\tf[x][y] = f[y][x] = 1LL * INV * (f[x][y] + f[y][x]) % MOD;\n\t\ttrim(b <<= 1);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tup(ans, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1LL * ans * b % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3010;\nconst ll p=1000000007;\nll fp(ll a,ll b)\n{\n\tll s=1;\n\tfor(;b;b>>=1,a=a*a%p)\n\t\tif(b&1)\n\t\t\ts=s*a%p;\n\treturn s;\n}\nconst ll inv2=fp(2,p-2);\nint a[N];\nint n,q;\nll f[N][N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j])\n\t\t\t\tf[i][j]=1;\n\tint x,y;\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x&&j!=y)\n\t\t\t{\n\t\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])*inv2%p;\n\t\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])*inv2%p;\n\t\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])%p;\n\tans=ans*fp(2,q)%p;\n\tans=(ans%p+p)%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=3010,mod=1e9+7,inv2=5e8+4;\nint n,Q,x,y,a[N];\nll dp[N][N],t1,t2,t3,t4;\nll ans,tot=1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);for (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)for (int j=1;j<=n;j++)if (a[i]>a[j]) dp[i][j]=1;\n\twhile (Q--)\n\t{\n\t\ttot=tot*2%mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=((ll)dp[x][y]*inv2%mod+(ll)dp[y][x]*inv2%mod)%mod;\n\t\tfor (int i=1;i<=n;i++) \n\t\tif (i!=x&&i!=y){\n\t\t\tt1=dp[x][i];t2=dp[i][x];t3=dp[y][i];t4=dp[i][y];\n\t\t\tdp[y][i]=dp[x][i]=((ll)t1*inv2%mod+(ll)t3*inv2%mod)%mod;\n\t\t\tdp[i][x]=dp[i][y]=((ll)t2*inv2%mod+(ll)t4*inv2%mod)%mod;\n\t\t}\n\t}\n\tfor (int i=1;i<n;i++) for (int j=i+1;j<=n;j++) ans=(ans+dp[i][j])%mod;\n\tans=ans*tot%mod;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 1);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 1) {\n            node[k] = (node[k] * lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1]*lazy[k])%P;\n                lazy[2*k+2] = (lazy[2*k+2]*lazy[k])%P;\n            }\n            lazy[k] = 1;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k]*x)%P;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1]+node[2*k+2])%P;\n        }\n    }\n\n    void adx(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            eval(k, l, r);\n        }else {\n            node[k] = (node[k]+x)%P;\n        }\n    }\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  LazySegmentTree dp(vector<ll>(n*n+1, 1));\n  LazySegmentTree rev(vector<ll>(n*n+1, 0));\n  for(auto v:query){\n    vvl tmp; //i, j, flip or not, num\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    ll adr = x*n+y;\n    tmp.push_back(vll{x, y, 1, dp.getsum(adr, adr+1)});\n    tmp.push_back(vll{x, y, 0, rev.getsum(adr, adr+1)});\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(i<x){\n        adr = i*n+y;\n        tmp.push_back(vll{i, x, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, x, 0, dp.getsum(adr, adr+1)});\n      }else if(y<i){\n        adr = y*n+i;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = i*n+y;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(y<i){\n        adr = x*n+i;\n        tmp.push_back(vll{y, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{y, i, 0, dp.getsum(adr, adr+1)});\n      }else if(i<x){\n        adr = i*n+x;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = x*n+i;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(auto ad:tmp){\n      ll adr = ad[0]*n+ad[1];\n      if(ad[2]==1) rev.adx(adr, adr+1, ad[3]);\n      else dp.adx(adr, adr+1, ad[3]);\n    }\n    //関係ないものは2倍\n    //xかyに関係するものはinv[2]を掛けておく\n\n    /*\n    for(int i=0;i<n;i++){\n      if(i!=x&&i!=y){\n        dp.add(i*n+x, i*n+x+1, I);\n        dp.add(x*n+i, x*n+i+1, I);\n        rev.add(i*n+x, i*n+x+1, I);\n        rev.add(x*n+i, x*n+i+1, I);\n        dp.add(i*n+y, i*n+y+1, I);\n        dp.add(y*n+i, y*n+i+1, I);\n        rev.add(i*n+y, i*n+y+1, I);\n        rev.add(y*n+i, y*n+i+1, I);\n      }\n    }\n    dp.add(x*n+y, x*n+y+1, I);\n    dp.add(y*n+x, y*n+x+1, I);\n    rev.add(x*n+y, x*n+y+1, I);\n    rev.add(y*n+x, y*n+x+1, I);\n    dp.add(0, n*n+1, 2);\n    rev.add(0, n*n+1, 2);\n    */\n  }\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ll adr = i*n+j;\n      if(a[i]<a[j]) ans = (ans + rev.getsum(adr, adr+1))%P;\n      if(a[i]>a[j]) ans = (ans + dp.getsum(adr, adr+1))%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<cassert>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int maxn=3e3+20;\nconst int mod=1e9+7;\nconst int inv2=mod+1>>1;\n\nint n,a[maxn],q;\nint f[maxn][maxn],g[maxn][maxn];\n\ninline void init()\n{\n\tn=read();q=read();\n\tREP(i,1,n)a[i]=read();\n}\n\ninline void doing()\n{\n\tint u=0;\n\tREP(i,1,n)REP(j,1,n)\n\t\tif(i<=j)g[i][j]=f[i][j]=a[i]<a[j];\n\t\telse g[i][j]=f[i][j]=a[i]<a[j];\n\tREP(t,1,q)\n\t{\n\t\tint i=read(),j=read();\n\t\tREP(k,1,n)if(k!=j)\n\t\t{\n\t\t\tg[i][k]=(ll)inv2*(f[i][k]+f[j][k])%mod;\n\t\t}else g[i][j]=(ll)inv2*(f[i][j]+f[j][i]);\n\n\t\tREP(k,1,n)if(k!=i)\n\t\t{\n\t\t\tg[j][k]=(ll)inv2*(f[j][k]+f[i][k])%mod;\n\t\t}else g[j][i]=(ll)inv2*(f[i][j]+f[j][i])%mod;\n\t\t\n\t\tREP(k,1,n)if(k!=i)\n\t\t{\n\t\t\tg[k][j]=(ll)inv2*(f[k][j]+f[k][i])%mod;\n\t\t}\n\n\t\tREP(k,1,n)if(k!=j)\n\t\t{\n\t\t\tg[k][i]=(ll)inv2*(f[k][i]+f[k][j])%mod;\n\t\t}\n\t\tREP(k,1,n)f[i][k]=g[i][k],f[j][k]=g[j][k];\n\t\tREP(k,1,n)f[k][i]=g[k][i],f[k][j]=g[k][j];\n\t}\n\tint ans=0,s=1;REP(i,1,q)s=(ll)s*2%mod;\n\tREP(i,1,n)REP(j,1,i-1)\n\t{\n\t\tans=(ans+(ll)f[i][j]*s)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\nint aa[3020];\n\nint dp[3020][3020]={};\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \tint n,q;\n \tcin>>n>>q;\n //\tcout<<fixed;\n //\tcout << std::setprecision(5);\n// \tint n=s.length();\n \tfor(int i=0;i<n;i++)cin>>aa[i];\n \n \t\n \tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n \t\tif(aa[i]>aa[j])dp[i][j]=1;\n \t}\n \tint ni=beki(2,inf-2,inf);\n \tfor(int ii=0;ii<q;ii++){\n \t\t\n \t\tint x,y;\n \t\tcin>>x>>y;\n \t\tx--;\n \t\ty--;\n \t\t{\n \t\tint e=(dp[x][y]+dp[y][x])*ni%inf;\n \t\tdp[x][y]=e;\n \t\tdp[y][x]=e;\n \t\t}\n \t\tfor(int i=0;i<n;i++)if(i!=x&&i!=y){\n \t\t\tint e=(dp[i][x]+dp[i][y])*ni%inf;\n \t\t\tdp[i][x]=e;\n \t\t\tdp[i][y]=e;\n \t\t\te=(dp[x][i]+dp[y][i])*ni%inf;\n \t\t\tdp[x][i]=e;\n \t\t\tdp[y][i]=e;\n \t\t}\n \t\tint wa=0;\n \t\n \t\t/*for(int i=0;i<n;i++){\n \t\t\tfor(int j=0;j<n;j++)cout<<dp[i][j]<<\" \",wa+=dp[i][j];\n \t\t\tcout<<endl;\n \t\t}\n \t\tcout<<endl;\n \t\tcout<<wa%inf<<endl;\n \t\t*/\n \t}\n \t\n \tint ans=0;\n \tfor(int i=0;i<n;i++)for(int j=i+1;j<n;j++)ans+=dp[i][j];\n \t\n \tans%=inf;\n \tans*=beki(2,q,inf);\n \tcout<<ans%inf<<endl;\n //\tcout<<ni<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nconst int N = (int) 3e3 + 10 ;\nconst int inf = (int) 2e9 ;\n\nint arr[N] , sum[3 * N] , n ;\npair< int , int > tmp[N] ;\n\nvoid upd( int node , int b , int e , int i , int j , int v ) {\n    if( e < i || b > j ) return ;\n    if( b >= i && e <= j ) {\n        sum[node] += v ; return ;\n    }\n    int lft = 2 * node , rt = lft + 1 , mid = (b + e) / 2 ;\n    upd(lft , b , mid , i , j , v) ;\n    upd(rt , mid + 1 , e , i , j , v) ;\n    sum[node] = sum[lft] + sum[rt] ;\n}\n\nint query( int node , int b , int e , int i , int j ) {\n    if( e < i || b > j ) return 0 ;\n    if( b >= i && e <= j ) return sum[node] ;\n    int lft = 2 * node , rt = lft + 1 , mid = (b + e) / 2 ;\n    return (query(lft , b , mid , i , j) + query(rt , mid + 1 , e , i , j)) ;\n}\n\nint get_sum(int l , int r) {\n    if( l > r ) return 0 ;\n    return query(1 , 1 , n , l , r) ;\n}\n\nint Inv() {\n    memset(sum , 0 , sizeof(sum)) ;\n    for( int i = 1 ; i <= n ; i++ ) {\n        tmp[i] = {arr[i] , i} ;\n    }\n    sort(tmp + 1 , tmp + 1 + n) ;\n    int answer = 0 , last = -1 ;\n    for( int i = 1 ; i <= n ; i++ ) {\n        if( tmp[i].first != last ) {\n            answer += get_sum(1 , tmp[i].second - 1) ;\n        }\n        upd(1 , 1 , n , tmp[i].second , tmp[i].second , 1) ;\n        last = tmp[i].first ;\n    }\n    return answer ;\n}\n\nconst long long mod = (long long) 1e9 + 7 ;\n\npair< int , int > Q[N] ;\nlong long dp[N][N] ;\nint q ;\n\nlong long F(int i , int cnt) {\n    if( i == q + 1 ) {\n        return Inv() ;\n    }\n    long long &ret = dp[i][cnt] ;\n    if( ret != -1 ) return ret ;\n    ret = 0 ;\n    int l = Q[i].first , r = Q[i].second ;\n    swap(arr[l] , arr[r]) ;\n    ret += F(i + 1 , cnt + 1) ;\n    swap(arr[l] , arr[r]) ;\n\n    if( ret >= mod ) ret %= mod ;\n    ret += F(i + 1 , cnt) ;\n    ret %= mod ;\n\n    return ret ;\n}\n\nint main() {\n//    freopen(\"in.txt\" , \"r\" , stdin ) ;\n    memset( dp , -1 , sizeof(dp)) ;\n    cin >> n >> q ;\n    for( int i = 1 ; i <= n ; i++ ) cin >> arr[i] ;\n    for( int i = 1 ; i <= q ; i++ ) {\n        cin >> Q[i].first >> Q[i].second ;\n    }\n    printf(\"%lld\\n\" , F(1 , 0) ) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 3010\nusing namespace std;\nconst int md=1e9+7;\nconst int invt=5e8+4;\n\nint ksm(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif (b&1) res=res*a%md;\n\t\ta=a*a%md;b>>=1;\n\t}\n\treturn res;\n}\n\nvoid mul(int &x,int y){\n\tx=1ll*x*y%md;\n}\n\nint n,Q,a[maxn];\nint f[maxn][maxn];\n\nvoid Pre(){\n\tfor (int i=1;i<=n;++i)\n\tfor (int j=1;j<=n;++j)\n\tf[i][j]=(bool)(a[i]>a[j]);\n}\n\nvoid Solve(int u,int v){\n\tint fu[maxn],fv[maxn];\n\tfor (int i=1;i<=n;++i)\n\tfu[i]=f[u][i],fv[i]=f[v][i];\n\tfor (int i=1;i<=n;++i)\n\tmul(fu[i],invt),mul(fv[i],invt);\n\tfor (int i=1;i<=n;++i)\n\tif (i!=u) (fu[i]+=(1ll*f[v][i]*invt)%md)%=md;\n\t(fu[v]+=(1ll*f[v][u]*invt)%md)%=md;\n\tfor (int i=1;i<=n;++i)\n\tif (i!=v) (fv[i]+=(1ll*f[u][i]*invt)%md)%=md;\n\t(fv[u]+=(1ll*f[u][v]*invt)%md)%=md;\n\tint gu[maxn],gv[maxn];\n\tfor (int i=1;i<=n;++i)\n\tgu[i]=f[i][u],gv[i]=f[i][v];\n\tfor (int i=1;i<=n;++i)\n\tmul(gu[i],invt),mul(gv[i],invt);\n\tfor (int i=1;i<=n;++i)\n\tif (i!=u) (gu[i]+=(1ll*f[i][v]*invt)%md)%=md;\n\t(gu[v]+=(1ll*f[u][v]*invt)%md)%=md;\n\tfor (int i=1;i<=n;++i)\n\tif (i!=v) (gv[i]+=(1ll*f[i][u]*invt)%md)%=md;\n\t(gv[u]+=(1ll*f[v][u]*invt)%md)%=md;\n\tfor (int i=1;i<=n;++i)\n\tf[u][i]=fu[i],f[v][i]=fv[i];\n\tfor (int i=1;i<=n;++i)\n\tf[i][u]=gu[i],f[i][v]=gv[i];\n}\n\nvoid Calc(){\n\tint ans=0;\n\tfor (int i=1;i<=n;++i)\n\tfor (int j=i+1;j<=n;++j)\n\t(ans+=f[i][j])%=md;\n\tmul(ans,ksm(2,Q));\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\tfor (int i=1;i<=n;++i)\n\tscanf(\"%d\",a+i);\n\tPre();\n\tfor (int i=1,u,v;i<=Q;++i)\n\tscanf(\"%d%d\",&u,&v),\n\tSolve(u,v);\n\tCalc();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long to; long long len;\n\tbool operator<(const edge& rhs) const {\n\t\treturn len > rhs.len;\n\t}\n};\n\nll const MAX = 3e3 + 5;\nll dp[MAX][MAX] = {};\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y + 5 * MOD) % MOD;\n}\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\nll mod_pow(ll x, ll t) {\n\tif (t == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tll v = mod_pow(x, t / 2);\n\t\tif (t % 2 == 0) {\n\t\t\treturn v * v%MOD;\n\t\t}\n\t\telse {\n\t\t\treturn v * v%MOD*x%MOD;\n\t\t}\n\t}\n}\n\nll mod_inv(ll x) {\n\treturn mod_pow(x, MOD - 2);\n}\n\nll a[MAX];\nll qx[MAX], qy[MAX];\nll row[MAX], ax[MAX];\n\nint main() {\n\tll n; ll q;\n\tcin >> n >> q;\n\tll inv2 = mod_inv(2);\n\tREP(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tREP(i, 1, q) {\n\t\tcin >> qx[i] >> qy[i];\n\t}\n\tREP(i, 1, n) {\n\t\tREP(j, 1, n) {\n\t\t\tif (a[i] > a[j]) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(k, 1, q) {\n\t\tll x = qx[k]; ll y = qy[k];\n\n\t\tREP(j, 1, n) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tax[j] = mod_p(mod_m(inv2, dp[x][j]), mod_m(inv2, dp[y][j]));\n\t\t\t\trow[j] = mod_p(mod_m(inv2, dp[j][x]), mod_m(inv2, dp[j][y]));\n\t\t\t}\n\t\t}\n\t\tREP(j, 1, n) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tdp[x][j] = dp[y][j] = ax[j];\n\t\t\t\tdp[j][x] = dp[j][y] = row[j];\n\t\t\t}\n\t\t}\n\t\tdp[x][y] = dp[y][x] = mod_m(inv2, mod_p(dp[x][y], dp[y][x]));\n\t}\n\tll ans = 0;\n\tREP(i, 1, n) {\n\t\tREP(j, i + 1, n) {\n\t\t\tans = mod_p(ans, dp[i][j]);\n\t\t}\n\t}\n\tREP(i, 1, q) {\n\t\tans = mod_m(ans, 2);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <iostream>\n#include <bitset>\nusing namespace std;\n#define N 3005\n#define ll long long\n#define mod 1000000007\n#define inv2 500000004ll\nint f[N][N],ans,n,Q,a[N],tmp=1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j])f[i][j]=1;\n\tint x,y;\n\twhile(Q--)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i!=x&&i!=y)\n\t\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])*inv2%mod,\n\t\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*inv2%mod;\n\t\ttmp=(tmp<<1)%mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",(ll)ans*tmp%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nconst int mod = 1000000007;\n\nint now[3333][3333];\nint pre[3333][3333];\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> a(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif(a[i] < a[j]) {\n\t\t\t\tnow[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow[i][j] = 0;\n\t\t\t}\n\t\t\tpre[i][j] = -1;\n\t\t}\n\t}\n\tvector<int> kai(q + 10);\n\tint nw = 1;\n\trep(i, q + 9) {\n\t\tkai[i + 1] = nw;\n\t\tnw = nw * 2 % mod;\n\t}\n\trep(i, q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tvector<pair<int, pair<int, int>>> q;\n\t\trep(j, n) {\n\t\t\tif(j != x && j != y) {\n\t\t\t\tq.push_back(make_pair(now[i][x] * kai[i - pre[i][x]], make_pair(i, y)));\n\t\t\t\tq.push_back(make_pair(now[i][y] * kai[i - pre[i][y]], make_pair(i, x)));\n\t\t\t\tq.push_back(make_pair(now[x][i] * kai[i - pre[x][i]], make_pair(y, i)));\n\t\t\t\tq.push_back(make_pair(now[y][i] * kai[i - pre[y][i]], make_pair(x, i)));\n\t\t\t}\n\t\t}\n\t\tq.push_back(make_pair(now[x][x] * kai[i - pre[x][x]], make_pair(y, y)));\n\t\tq.push_back(make_pair(now[x][y] * kai[i - pre[x][y]], make_pair(y, x)));\n\t\tq.push_back(make_pair(now[y][x] * kai[i - pre[y][x]], make_pair(x, y)));\n\t\tq.push_back(make_pair(now[y][y] * kai[i - pre[y][y]], make_pair(x, x)));\n\t\tfor(auto j: q) {\n\t\t\tnow[j.second.first][j.second.second] = (now[j.second.first][j.second.second] * kai[i - pre[j.second.first][j.second.second]] + j.first) % mod;\n\t\t\tpre[j.second.first][j.second.second] = i + 1;\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tans = (ans + now[i][j] * kai[q - pre[i][j]]) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\nconst int N=3050;\nconst int mod=1e9+7;\nint pow(int x, int k){ int ans=1;for(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ans=(ll)ans*x%mod;return ans;}\nint inv(int x){ return pow(x,mod-2);}\nint x[N],y[N],a[N],p[N],sum[N];\nint main()\n{\n\tint n,i,q,j;\n\tscanf(\"%i %i\",&n,&q);\n\tvector<int> id;\n\tfor(i=1;i<=n;i++) scanf(\"%i\",&a[i]),id.pb(a[i]);\n\tsort(id.begin(),id.end());id.resize(unique(id.begin(),id.end())-id.begin());\n\tfor(i=1;i<=n;i++) a[i]=lower_bound(id.begin(),id.end(),a[i])-id.begin()+1;\n\tfor(i=1;i<=q;i++) scanf(\"%i %i\",&x[i],&y[i]);\n\tint ans=0;\n\tfor(j=id.size();j>=1;j--)\n\t{\n\t\tfor(i=1;i<=n;i++) p[i]=a[i]==j;\n\t\tfor(i=1;i<=q;i++) p[x[i]]=p[y[i]]=(ll)(p[x[i]]+p[y[i]])*inv(2)%mod;\n\t\tint hi=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tans+=(ll)hi*p[i]%mod;ans%=mod;\n\t\t\tans+=(ll)sum[i]*p[i]%mod*inv(2)%mod;ans%=mod;\n\t\t\thi+=sum[i];hi%=mod;\n\t\t\tsum[i]+=p[i];sum[i]%=mod;\n\t\t}\n\t}\n\tfor(i=1;i<=q;i++) ans=ans*2%mod;\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 3005, MOD = 1e9 + 7;\nint dp[N][N], a[N], tmp[N][N];\n\nll bp(ll a, ll p) {\n\tll r = 1;\n\twhile (p > 0) {\n\t\tif (p & 1) {\n\t\t\tr = r * a % MOD;\n\t\t}\n\t\ta = a * a % MOD;\n\t\tp >>= 1;\n\t}\n\treturn r;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 0; i < n; i++) {\n    \tcin >> a[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n    \tfor (int j = 0; j < n; j++) {\n    \t\tdp[i][j] = (a[i] > a[j]);\n    \t}\n    }\n\n    ll inv_two = bp(2, MOD - 2);\n\n    for (int i = 0; i < q; i++) {\n    \tint x, y;\n    \tcin >> x >> y;\n    \tx--, y--;\n\n    \tfor (int j = 0; j < n; j++) {\n    \t\ttmp[x][j] = dp[x][j];\n    \t\ttmp[j][x] = dp[j][x];\n    \t\ttmp[y][j] = dp[y][j];\n    \t\ttmp[j][y] = dp[j][y];\n    \t}\n\n    \tfor (int j = 0; j < n; j++) {\n    \t\tif (j != x && j != y) {\n    \t\t\tdp[x][j] = (tmp[x][j] + tmp[y][j]) * inv_two % MOD;\n    \t\t\tdp[j][x] = (tmp[j][x] + tmp[j][y]) * inv_two % MOD;\n    \t\t}\n    \t}\n\n    \tfor (int j = 0; j < n; j++) {\n    \t\tif (j != x && j != y) {\n    \t\t\tdp[y][j] = (tmp[y][j] + tmp[x][j]) * inv_two % MOD;\n    \t\t\tdp[j][y] = (tmp[j][y] + tmp[j][x]) * inv_two % MOD;\n    \t\t}\n    \t}\n\n    \tdp[x][y] = (tmp[x][y] + tmp[y][x]) * inv_two % MOD;\n    \tdp[y][x] = (dp[y][x] + tmp[x][y]) * inv_two % MOD;\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n    \tfor (int j = i + 1; j < n; j++) {\n    \t\tans = (ans + dp[i][j]) % MOD;\n    \t}\n    }\n\n    ans = ans * bp(2, q) % MOD;\n\n    cout << ans;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7,inv2=5e8+4;\nint n,m,a[3005];\nll f[3005][3005],ans;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t    if(a[i]>a[j])f[i][j]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j!=x&&j!=y)\n\t\t\t{\n\t\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])*inv2%MOD;\n\t\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])*inv2%MOD;\n\t\t\t}\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%MOD;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=i+1;j<=n;j++)\n\t    ans+=f[i][j];\n\tans%=MOD;\n\tfor(int i=1;i<=m;i++)\n\t  ans=ans*2%MOD;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n    idea:\n\n\n\n*/\n#include<bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxn=3010;\nint n,q,a[maxn];\nll mod=1e9+7;\nll dp[maxn][maxn][3],dp2[maxn][maxn][3],q2;\n\nll step(ll base,ll pw){\n\n    ll ret=1;\n    while(pw){\n\n        if(pw&1)ret=(ret*base)%mod;\n\n        base=(base*base)%mod;\n        pw/=2;\n    }\n\nreturn ret;\n}\nvoid ispis(){\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n\n            printf(\"%d %d | %lld AA\\n\",i,j,(dp[i][j][2]*q2)%mod);\n        }\n    }\n    cout<<endl;\n}\nint main(){\n\n    ///freopen(\"test.txt\",\"r\",stdin);\n    ///freopen(\"out.txt\",\"w\",stdout);\n\n    scanf(\"%d %d\",&n,&q);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            dp[i][j][0]=(a[i]<a[j]);\n            dp[i][j][1]=(a[i]==a[j]);\n            dp[i][j][2]=(a[i]>a[j]);\n        }\n    }\n\n    ll inv2=step(2,mod-2);\n\n    q2=1;\n    while(q--){\n\n        q2=(q2*2)%mod;\n\n        int l,r;\n        scanf(\"%d %d\",&l,&r);\n        if(l>r)swap(l,r);\n\n        /// UPTO L\n        for(int i=1;i<l;i++){\n            ll pom0=dp[i][l][0];\n            ll pom1=dp[i][l][1];\n            ll pom2=dp[i][l][2];\n\n            dp[i][l][0]=(inv2*dp[i][l][0]+inv2*dp[i][r][0])%mod;\n            dp[i][l][1]=(inv2*dp[i][l][1]+inv2*dp[i][r][1])%mod;\n            dp[i][l][2]=(inv2*dp[i][l][2]+inv2*dp[i][r][2])%mod;\n\n            dp[i][r][0]=(inv2*dp[i][r][0]+inv2*pom0)%mod;\n            dp[i][r][1]=(inv2*dp[i][r][1]+inv2*pom1)%mod;\n            dp[i][r][2]=(inv2*dp[i][r][2]+inv2*pom2)%mod;\n        }\n\n        /// L\n        for(int i=l+1;i<=n;i++){\n\n            dp2[l][i][0]=dp[l][i][0];\n            dp2[l][i][1]=dp[l][i][1];\n            dp2[l][i][2]=dp[l][i][2];\n\n            if(i<r){\n                dp[l][i][0]=(inv2*dp[l][i][0]+inv2*dp[i][r][2])%mod;\n                dp[l][i][1]=(inv2*dp[l][i][1]+inv2*dp[i][r][1])%mod;\n                dp[l][i][2]=(inv2*dp[l][i][2]+inv2*dp[i][r][0])%mod;\n            }\n            else if(i==r){\n                ll pom=dp[l][i][0];\n                dp[l][i][0]=(inv2*dp[l][i][0]+inv2*dp[l][i][2])%mod;\n                dp[l][i][1]=(inv2*dp[l][i][1]+inv2*dp[l][i][1])%mod;\n                dp[l][i][2]=(inv2*dp[l][i][2]+inv2*pom)%mod;\n            }\n            else{\n                dp[l][i][0]=(inv2*dp[l][i][0]+inv2*dp[r][i][0])%mod;\n                dp[l][i][1]=(inv2*dp[l][i][1]+inv2*dp[r][i][1])%mod;\n                dp[l][i][2]=(inv2*dp[l][i][2]+inv2*dp[r][i][2])%mod;\n            }\n\n        }\n\n        /// L to R\n        for(int i=l+1;i<r;i++){\n            dp[i][r][0]=(inv2*dp[i][r][0]+inv2*dp2[l][i][2])%mod;\n            dp[i][r][1]=(inv2*dp[i][r][1]+inv2*dp2[l][i][1])%mod;\n            dp[i][r][2]=(inv2*dp[i][r][2]+inv2*dp2[l][i][0])%mod;\n        }\n\n        /// R\n        for(int i=r+1;i<=n;i++){\n            dp[r][i][0]=(inv2*dp[r][i][0]+inv2*dp2[l][i][0])%mod;\n            dp[r][i][1]=(inv2*dp[r][i][1]+inv2*dp2[l][i][1])%mod;\n            dp[r][i][2]=(inv2*dp[r][i][2]+inv2*dp2[l][i][2])%mod;\n        }\n\n        ///ispis();\n    }\n\n    ll rez=0;\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n\n            ///printf(\"%d %d | %lld AA\\n\",i,j,(dp[i][j][2]*q2)%mod);\n\n            rez+=(dp[i][j][2]*q2);\n            rez%=mod;\n        }\n    }\n\n    printf(\"%lld\\n\",rez);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    vector<lint> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<int> x(q), y(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> x[i] >> y[i];\n        x[i]--, y[i]--;\n        if (x[i] > y[i])\n            swap(x[i], y[i]);\n    }\n    vector<vector<mint>> dp(n, vector<mint>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (a[i] > a[j])\n                dp[i][j] = 1;\n            else if (a[i] < a[j])\n                dp[j][i] = 1;\n            else\n                continue; // equals\n        }\n    }\n    for (int i = 0; i < q; ++i) {\n        // flip x[i] : y[i]\n        for (int j = 0; j < x[i]; ++j) {\n            mint a0     = (dp[j][x[i]] + dp[j][y[i]]) / 2;\n            mint a1     = (dp[x[i]][j] + dp[y[i]][j]) / 2;\n            dp[j][x[i]] = dp[j][y[i]] = a0;\n            dp[x[i]][j] = dp[y[i]][j] = a1;\n        }\n        for (int j = x[i] + 1; j < y[i]; ++j) {\n            mint a0     = (dp[x[i]][j] + dp[y[i]][j]) / 2;\n            mint a1     = (dp[j][y[i]] + dp[j][x[i]]) / 2;\n            mint a2     = (dp[j][x[i]] + dp[j][y[i]]) / 2;\n            mint a3     = (dp[y[i]][j] + dp[x[i]][j]) / 2;\n            dp[x[i]][j] = a0;\n            dp[j][y[i]] = a1;\n            dp[j][x[i]] = a2;\n            dp[y[i]][j] = a3;\n        }\n        for (int j = y[i] + 1; j < n; ++j) {\n            mint a0     = (dp[j][x[i]] + dp[j][y[i]]) / 2;\n            mint a1     = (dp[x[i]][j] + dp[y[i]][j]) / 2;\n            dp[j][x[i]] = dp[j][y[i]] = a0;\n            dp[x[i]][j] = dp[y[i]][j] = a1;\n        }\n        mint t1        = (dp[x[i]][y[i]] + dp[y[i]][x[i]]) / 2;\n        dp[x[i]][y[i]] = t1;\n        dp[y[i]][x[i]] = t1;\n    }\n    mint ret = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ret += dp[i][j];\n        }\n    }\n    cout << ret * mint(2).pow(q) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nusing mint=ModInt<1000000007>;\n\nconst int N=3010;\nconst mint inv2=mint(2).inv();\nint n;\nmint dp[N][N];\nvoid go( int x, int y ) {\n    auto to=[&]( int i ) {\n        if ( i==x ) return y;\n        if ( i==y ) return x;\n        return i;\n    };\n    vector<tuple<int,int,mint>> v;\n    auto push=[&]( int r, int c ) {\n        if ( r<c ) v.PB(make_tuple(r,c,dp[r][c]));\n    };\n    REP1(i,1,n) {\n        push(i,x);\n        push(i,y);\n        push(x,i);\n        push(y,i);\n    }\n    sort_uniq(v);\n    for ( auto i:v ) {\n        int r=get<0>(i),c=get<1>(i);\n        mint t=get<2>(i);\n        dp[r][c]-=t*inv2;\n        int nr=to(r),nc=to(c);\n        mint nt=t;\n        if ( nr>nc ) {\n            swap(nr,nc);\n            nt=mint(1)-nt;\n        }\n        dp[nr][nc]+=nt*inv2;\n    }\n}\n\nint q,a[N],x[N],y[N];\n\nmint run() {\n    REP(i,q) go(x[i],y[i]);\n    mint ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) ans+=dp[i][j];\n    ans*=mint(2).pow(q);\n    return ans;\n}\n\nvoid main() {\n    R(n,q);\n    REP1(i,1,n) R(a[i]);\n    REP(i,q) R(x[i],y[i]);\n    mint ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) dp[i][j]=(a[i]>a[j]);\n    ans+=run();\n    memset(dp,0,sizeof(dp));\n    REP1(i,1,n) REP1(j,i+1,n) dp[i][j]=(a[i]>=a[j]);\n    ans+=run();\n    mint cnt=0;\n    REP1(i,1,n) REP1(j,i+1,n) cnt+=(a[i]==a[j]);\n    cnt*=mint(2).pow(q);\n    ans-=cnt;\n    ans*=inv2;\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    char c;\n    while (!isdigit(c = getChar())) {}\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return f;\n}\n\nconst int maxN = 3007, mod = 1e9 + 7;\nconst long long inv2 = 500000004;\nint a[maxN], dp[maxN][maxN];\ninline void add(int& x, int y) {\n    x += y;\n    if (x >= mod)\n        x -= mod;\n}\n\nint main() {\n    int n = read(), m = read(), i, j, x, y, ans = 0;\n    for (i = 1; i <= n; ++i)\n        a[i] = read();\n    for (i = 1; i <= n; ++i)\n        for (j = 1; j <= n; ++j)\n            dp[i][j] = a[i] < a[j];\n    \n    for (i = 1; i <= m; ++i) {\n        x = read(), y = read();\n        dp[x][y] = dp[y][x] = inv2 * (dp[x][y] + dp[y][x]) % mod;\n        for (j = 1; j <= n; ++j)\n            if (j != x && j != y) {\n                dp[x][j] = dp[y][j] = inv2 * (dp[x][j] + dp[y][j]) % mod;\n                dp[j][x] = dp[j][y] = inv2 * (dp[j][x] + dp[j][y]) % mod;\n            }\n    }\n    \n    for (i = 1; i <= n; ++i)\n        for (j = 1; j < i; ++j)\n            add(ans, dp[i][j]);\n    for (i = 1; i <= m; ++i)\n        ans = (ans << 1) % mod;\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int maxn=3e3+20;\nconst int mod=1e9+7;\nconst int inv2=mod+1>>1;\n\nint n,q,a[maxn],f[maxn][maxn],g[maxn][maxn];\n\ninline void init()\n{\n\tn=read();q=read();\n\tREP(i,1,n)a[i]=read();\n\tREP(i,1,n)REP(j,1,n)g[i][j]=f[i][j]=a[i]>a[j];\n}\n\ninline void doing()\n{\n\tREP(i,1,q)\n\t{\n\t\tint x=read(),y=read();\n\t\tREP(k,1,n)if(k!=y && k!=x)\n\t\t{\n\t\t\t//x,k\n\t\t\tg[x][k]=1ll*(f[x][k]+f[y][k])*inv2%mod;\n\t\t\tg[k][x]=1ll*(f[k][x]+f[k][y])*inv2%mod;\n//k,y\n\t\t\tg[k][y]=1ll*(f[k][y]+f[k][x])*inv2%mod;\n\t\t\tg[y][k]=1ll*(f[y][k]+f[x][k])*inv2%mod;\n\t\t\t\n\t\t}\n\t\tg[x][y]=1ll*(f[x][y]+f[y][x])*inv2%mod;\n\t\tg[y][x]=1ll*(f[x][y]+f[y][x])*inv2%mod;\n\t\tREP(k,1,n)f[x][k]=g[x][k],f[k][y]=g[k][y],f[k][x]=g[k][x],f[y][k]=g[y][k];\n\t}\n\tint p2=1; REP(i,1,q)p2=p2*2%mod; \n\tint ans=0;\n\tREP(i,1,n)REP(j,i+1,n)ans=(ans+(ll)p2*f[i][j])%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <typename T, typename U>\nT mpow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret = ret * b % MOD;\n        n >>= 1;\n        b = b * b % MOD;\n    }\n    return ret;\n}\n\nconst ll inv2 = mpow(2LL, MOD - 2);\n\n// 高速に2で割る\ninline ll div2(ll n) {\n    return (n & 1 ? n * inv2 % MOD : n / 2);\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    auto A = Vec<int>(N, 0);\n    for (int& a : A) cin >> a;\n\n    auto dp = Vec<ll>(N, N, 0LL);\n    // i番目がj番目より大きい確率\n\n    // 初期状態(比較するだけ)\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = (A[i] > A[j] ? 1 : 0);\n        }\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n\n        // xとyに関与するところだけ更新する\n        // ただしdp[x][x]とdp[y][y]は更新してはいけない\n        for (int k = 0; k < N; ++k) {\n            if (k == x || k == y) continue;\n            dp[k][x] = div2(dp[k][x] + dp[k][y]);\n            dp[k][y] = dp[k][x];\n\n            dp[x][k] = div2(dp[x][k] + dp[y][k]);\n            dp[y][k] = dp[x][k];\n        }\n\n        // 互いに位置が入れ替わるdp[x][y]とdp[y][x]を更新\n        dp[x][y] = div2(dp[x][y] + dp[y][x]);\n        dp[y][x] = dp[x][y];\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << ans % MOD * mpow(2LL, Q) % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 3000, mod = 1e9 + 7, inv2 = (mod + 1) >> 1;\nint n, q, a[maxn + 3], f[maxn + 3][maxn + 3], g[maxn + 3][maxn + 3];\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tf[i][j] = a[i] > a[j];\n\t\t\tf[j][i] = a[j] > a[i];\n\t\t}\n\t}\n\tint tot = 1;\n\tfor (int x, y; q --> 0; ) {\n\t\ttot = 2ll * tot % mod;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i != x) g[i][x] = f[i][x], g[x][i] = f[x][i];\n\t\t\tif (i != y) g[i][y] = f[i][y], g[y][i] = f[y][i];\n\t\t}\n\t\tf[x][y] = 1ll * (g[x][y] + g[y][x]) * inv2 % mod;\n\t\tf[y][x] = 1ll * (g[x][y] + g[y][x]) * inv2 % mod;\n\t\tfor (int i = 1; i <= n; i++) if (i != x && i != y) {\n\t\t\tf[i][x] = 1ll * (g[i][x] + g[i][y]) * inv2 % mod;\n\t\t\tf[i][y] = 1ll * (g[i][x] + g[i][y]) * inv2 % mod;\n\t\t\tf[x][i] = 1ll * (g[x][i] + g[y][i]) * inv2 % mod;\n\t\t\tf[y][i] = 1ll * (g[x][i] + g[y][i]) * inv2 % mod;\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tsum = (sum + f[i][j]) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1ll * sum * tot % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nconst int MAXN = 3010;\nint A[MAXN], n, Q;\nint f[MAXN][MAXN];\nvoid eff(int & x, int & y) {\n\tx = y = mul(x + y, mod + 1 >> 1);\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> Q;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) if (A[i] != A[j])\n\t\t\tA[i] < A[j] ? ++f[i][j] : ++f[j][i];\n\tfor (int i = 1; i <= Q; ++i) {\n\t\tint x, y; std::cin >> x >> y;\n\t\tfor (int j = 1; j <= n; ++j) if (j != x && j != y) {\n\t\t\teff(f[x][j], f[y][j]);\n\t\t\teff(f[j][x], f[j][y]);\n\t\t}\n\t\teff(f[x][y], f[y][x]);\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\treduce(ans += f[i][j] - mod);\n\tans = pow(2, Q, ans);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nusing P = Pa<int,int>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q;\n    cin >> N >> Q;\n    vec<int> A(N);\n    for(int i=0;i<N;i++) cin >> A[i];\n    vvec<mint> dp(N,vec<mint>(N));\n    for(int i=0;i<N;i++) for(int j=0;j<N;j++) if(A[i]<=A[j]) dp[i][j] = 1;\n    mint inv2 = ((mint) (2)).inv();\n    for(int _=0;_<Q;_++){\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if(x>y) swap(x,y);\n        unordered_map<int,mint> mp;\n        for(int i=0;i<N;i++){\n            mp[i*N+x] = dp[i][x];\n            mp[x*N+i] = dp[x][i];\n            mp[i*N+y] = dp[i][y];\n            mp[y*N+i] = dp[y][i];\n        }\n        for(int i=0;i<N;i++){\n            if(i!=x && i!=y){\n                dp[i][x] = (mp[i*N+x]+mp[i*N+y])*inv2;\n                dp[x][i] = (mp[x*N+i]+mp[y*N+i])*inv2;\n//              assert((dp[i][x]+dp[x][i]).x==1);\n            }\n            if(i!=x && i!=y){\n                dp[i][y] = (mp[i*N+y]+mp[i*N+x])*inv2;\n                dp[y][i] = (mp[y*N+i]+mp[x*N+i])*inv2;\n            }\n        }\n        dp[x][y] = (mp[x*N+y]+mp[y*N+x])*inv2;\n        dp[y][x] = (mp[x*N+y]+mp[y*N+x])*inv2;\n    }\n    mint ans = 0;\n//    for(int i=0;i<N;i++) for(int j=0;j<N;j++) cerr << dp[i][j] << (j!=N-1? \" \":\"\\n\");\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++) ans += ((mint) 1-dp[i][j]);\n    cout << ans*((mint) 2).pow(Q) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 3003; \nmint dp[2][N][N];\nmint tmp[2][N][N];\n\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (auto& x: a) {\n        cin >> x;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (a[i] > a[j]) dp[0][i][j] = 1;\n            if (a[i] == a[j])dp[1][i][j] = 1;\n        }\n    }\n    auto flip = [&](int& x, int& y){\n        dp[0][x][y] = 1 - dp[0][x][y] - dp[1][x][y];\n    };\n    mint half = mint(1)/2;\n    for (int _ = 0; _ < q; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if (x > y) swap(x, y);\n        memcpy(tmp, dp, sizeof tmp);\n        for (int i = 0; i < x; i++) {\n            swap(dp[0][i][x], dp[0][i][y]);\n            swap(dp[1][i][x], dp[1][i][y]);\n        }\n        flip(x, y);\n        for (int i = x+1; i < y; i++) {\n            swap(dp[0][x][i], dp[0][i][y]);\n            swap(dp[1][x][i], dp[1][i][y]);\n            flip(x, i);\n            flip(i, y);\n        }\n        for (int i = y+1; i < n; i++) {\n            swap(dp[0][x][i], dp[0][y][i]);\n            swap(dp[1][x][i], dp[1][y][i]);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                (dp[0][i][j] += tmp[0][i][j]) *= half;\n                (dp[1][i][j] += tmp[1][i][j]) *= half;\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            res += dp[0][i][j];\n        }\n    }\n    res *= mint(2).exp(q);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\nconst int mod=1e9+7,inv2=(mod+1)/2;\nusing namespace std;\nint n,q,x,y,ans;\nint f[3011][3011],a[3011];\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\trep(i,1,n)\n\t\tscanf(\"%d\",a+i);\n\trep(i,1,n)\n\t\trep(j,1,n)\n\t\t\tf[i][j]=(a[i]<a[j]);\n\trep(i,1,q){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%mod;\n\t\trep(i,1,n)\n\t\t\tif(x!=i&&y!=i){\n\t\t\t\tf[x][i]=f[y][i]=1ll*(f[y][i]+f[x][i])*inv2%mod;\n\t\t\t\tf[i][x]=f[i][y]=1ll*(f[i][y]+f[i][x])*inv2%mod;\n\t\t\t}\n\t}\n\trep(i,1,n)\n\t\trep(j,1,i-1)\n\t\t\tans=(ans+f[i][j])%mod;\n\trep(i,1,q)\n\t\tans=(ans<<1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q, p[3009], dp[3009][3009], old[3009][3009];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid div2 (int &x) {if (x & 1) x += mod; x >>= 1;}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &Q);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &p[i]);\nfor (int i=1; i<=N; i++)\n    for (int j=1; j<=N; j++)\n        dp[i][j] = (p[i] < p[j]);\nint p2 = 1;\nwhile (Q --)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y), p2 = add (p2, p2);\n    if (x > y) swap (x, y);\n    for (int i=1; i<=N; i++)\n        old[i][x] = dp[i][x], old[i][y] = dp[i][y],\n        old[x][i] = dp[x][i], old[y][i] = dp[y][i];\n    adto (dp[x][y], old[y][x]), div2 (dp[x][y]);\n    adto (dp[y][x], old[x][y]), div2 (dp[y][x]);\n    for (int i=1; i<=N; i++)\n    if (i != x && i != y)\n    {\n        adto (dp[i][x], old[i][y]),\n        adto (dp[x][i], old[y][i]);\n\n        adto (dp[i][y], old[i][x]);\n        adto (dp[y][i], old[x][i]);\n    }\n    for (int i=1; i<=N; i++)\n        if (i != x && i != y)\n            div2 (dp[i][x]), div2 (dp[i][y]),\n            div2 (dp[x][i]), div2 (dp[y][i]);\n/*    int sum = 0;\n    for (int i=1; i<=N; i++)\n        for (int j=1; j<=N; j++)\n            sum += dp[i][j];\n    printf (\"%d\\n\", sum);*/\n    for (int i=1; i<=N; i++)\n        assert (dp[i][i] == 0);\n}\nint ans = 0;\nfor (int i=1; i<=N; i++)\n    for (int j=1; j<i; j++)\n        adto (ans, dp[i][j]);\nans = mul (ans, p2);\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vi a(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  vll dp(n, vl(n));\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) continue;\n      if (a[i] < a[j]) dp[i][j] = 1;\n    }\n  }\n  ll half = mod_inverse(2);\n  vll memo(n, vl(n));\n  rep (aaa, q) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      memo[i][u] = (dp[i][u] + dp[i][v]) * half % MOD;\n      memo[u][i] = (dp[u][i] + dp[v][i]) * half % MOD;\n      memo[i][v] = (dp[i][u] + dp[i][v]) * half % MOD;\n      memo[v][i] = (dp[u][i] + dp[v][i]) * half % MOD;\n    }\n    memo[u][v] = memo[v][u] = (dp[u][v] + dp[v][u]) * half % MOD;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      dp[i][u] = memo[i][u];\n      dp[i][v] = memo[i][v];\n      dp[u][i] = memo[u][i];\n      dp[v][i] = memo[v][i];\n    }\n    dp[u][v] = dp[v][u] = memo[u][v];\n  }\n  ll ans = 0;\n  ll po = pow(2, q);\n  rep (i, n) {\n    for (int j = 0; j < i; j++) {\n      ans += po * dp[i][j] % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n      \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\nlong long a[3000][3000];\n\n\n\n\n\nint main() {\n\tint n, q, x, y;\n\tlong long z;\n\tint b[3000];\n\tscanf(\"%d %d\", &n,&q);\n\tf(i, n)scanf(\"%d\", &b[i]);\n\tf(i, n) {\n\t\tf(j, n)a[i][j] = 0;\n\t}\n\tf(i, n) {\n\t\tf(j, i) {\n\t\t\tif (b[j] < b[i]) {\n\t\t\t\ta[j][i] = 1;\n\t\t\t}\n\t\t\telse if (b[j] > b[i]) {\n\t\t\t\ta[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tf(qq, q) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tf(i, n) {\n\t\t\tif ((i != x) && (i != y)) {\n\t\t\t\tz = a[i][x];\n\t\t\t\tz += a[i][y];\n\t\t\t\tz *= 500000004;\n\t\t\t\tz %= MOD;\n\t\t\t\ta[i][x] = z;\n\t\t\t\ta[i][y] = z;\n\t\t\t}\n\t\t}\n\t\tf(i, n) {\n\t\t\tif ((i != x) && (i != y)) {\n\t\t\t\tz = a[x][i];\n\t\t\t\tz += a[y][i];\n\t\t\t\tz *= 500000004;\n\t\t\t\tz %= MOD;\n\t\t\t\ta[x][i] = z;\n\t\t\t\ta[y][i] = z;\n\t\t\t}\n\t\t}\n\t\tz = a[x][y];\n\t\tz += a[y][x];\n\t\tz *= 500000004;\n\t\tz %= MOD;\n\t\ta[x][y] = z;\n\t\ta[y][x] = z;\n\t}\n\tz = 0;\n\tf(i, n) {\n\t\tf(j, i) {\n\t\t\tz = (z + a[i][j]) % MOD;\n\t\t}\n\t}\n\tf(i, q)z = (z * 2) % MOD;\n\tprintf(\"%lld\\n\", z);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nll dp[3030][3030];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, q;\n\tcin >> n >> q;\n\tArray a(n);\n\tREP(i, n)cin >> a[i];\n\tREP(i, n)REP(j, n)dp[i][j] = a[i] > a[j];\n\tll inv = mod_inv(2, MOD);\n\tREP(i, q) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tx--; y--;\n\t\tREP(j, n) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tdp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) % MOD * inv % MOD;\n\t\t\t\tdp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) % MOD * inv % MOD;\n\t\t\t}\n\t\t}\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) % MOD * inv % MOD;\n\t}\n\tll ans = 0;\n\tREP(i, n)REP(j, i)(ans += dp[j][i]) %= MOD;\n\tREP(i, q)(ans *= 2) %= MOD;\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> pow (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const modular<T>& a) {\n  return stream << a();\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, modular<T>& a) {\n  int x; stream >> x;\n  a.value = modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  size_t n, q; std::cin >> n >> q;\n  std::vector<int> a(n);\n  std::for_each(a.begin(), a.end(), [](auto& x){std::cin >> x;});\n  using vec = std::vector<mint>;\n  using mat = std::vector<vec>;\n  auto dp = mat(n, vec(n, mint(0)));\n  for (size_t i = 0; i < n; i++) {\n    for (size_t j = 0; j < n; j++) {\n      dp.at(i).at(j) = a.at(i) > a.at(j);\n    }\n  }\n  auto inv2 = mint(1) / mint(2);\n  auto balance = [&] (auto& x, auto& y) {x = y = (x + y) * inv2;};\n  for (size_t i = 0; i < q; i++) {\n    size_t x, y; std::cin >> x >> y;\n    x--, y--;\n    balance(dp.at(x).at(y), dp.at(y).at(x));\n    for (size_t z = 0; z < n; z++) {\n      if (z == x || z == y) continue;\n      balance(dp.at(x).at(z), dp.at(y).at(z));\n      balance(dp.at(z).at(x), dp.at(z).at(y));\n    }\n  }\n  auto ret = mint(0);\n  for (size_t i = 0; i < n; i++) {\n    for (size_t j = i + 1; j < n; j++) {\n      ret += dp.at(i).at(j);\n    }\n  }\n  for (size_t i = 0; i < q; i++) ret *= mint(2);\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3005;\nconst int MOD = (int)1e9 + 7;\nconst int IV2 = (MOD + 1) / 2;\n\nint n, nq, ans, pw;\nint a[N], dp[N][N], tmp[N][N];\n\nint Add(int a, int b) { return (a += b) >= MOD? a - MOD : a; }\nint Mul(int a, int b) { return (long long)a * b % MOD; }\n\nint main() {\n  scanf(\"%d%d\", &n, &nq);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      if (a[i] > a[j]) {\n        dp[i][j] = 1;\n      }\n    }\n  }\n  pw = 1;\n  for (int x, y; nq--; ) {\n    pw = Mul(pw, 2);\n    scanf(\"%d%d\", &x, &y);\n    if (x == y) {\n      continue;\n    }\n    tmp[x][y] = dp[x][y];\n    tmp[y][x] = dp[y][x];\n    for (int i = 1; i <= n; ++i) {\n      tmp[i][x] = dp[i][x];\n      tmp[x][i] = dp[x][i];\n      tmp[i][y] = dp[i][y];\n      tmp[y][i] = dp[y][i];\n    }\n    dp[x][y] = Add(Mul(tmp[y][x], IV2), Mul(tmp[x][y], IV2));\n    dp[y][x] = Add(Mul(tmp[x][y], IV2), Mul(tmp[y][x], IV2));\n    for (int i = 1; i <= n; ++i) {\n      if (i == x || i == y) continue;\n      dp[i][x] = Add(Mul(tmp[i][x], IV2), Mul(tmp[i][y], IV2));\n      dp[x][i] = Add(Mul(tmp[x][i], IV2), Mul(tmp[y][i], IV2));\n      dp[i][y] = Add(Mul(tmp[i][y], IV2), Mul(tmp[i][x], IV2));\n      dp[y][i] = Add(Mul(tmp[y][i], IV2), Mul(tmp[x][i], IV2));\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i + 1; j <= n; ++j) {\n      ans = Add(ans, dp[i][j]);\n    }\n  }\n  printf(\"%d\\n\", Mul(ans, pw));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar(); \n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\ntypedef long long LL;\nconst int maxn = 3010, mod = 1e9 + 7;\nint a[maxn], f[maxn][maxn];\n\nint Pow(int x, int p)\n{\n\tint r = 1;\n\twhile(p)\n\t{\n\t\tif(p & 1) r = (LL)x * r % mod;\n\t\tx = (LL)x * x % mod; p >>= 1;\n\t}\n\treturn r;\n}\n\nint main()\n{\n\n\tint n = read(), Q = read();\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(a[i] < a[j]) f[i][j] = 1;\n\n\tint inv2 = 500000004, tmp = Pow(2, Q);\n\twhile(Q--)\n\t{\n\t\tint x = read(), y = read();\n\t\tf[x][y] = f[y][x] = (LL)(f[x][y] + f[y][x]) * inv2 % mod;\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tif(i != x && i != y)\n\t\t\t\tf[i][x] = f[i][y] = (LL)inv2 * (f[i][x] + f[i][y]) % mod,\n\t\t\t\tf[x][i] = f[y][i] = (LL)inv2 * (f[x][i] + f[y][i]) % mod;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j < i; ++j)\n\t\t\t(ans += f[i][j]) %= mod;\n\n\tcout << (LL)ans * tmp % mod << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int mod=1e9+7,N=3005;\nconst ll inv2=(mod+1)/2;\nint f[N][N],g[N],h[N],a[N],n,Q,x,y,pw=1,ans;\n\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint main(){\n\tread(n),read(Q);\n\trep(i,1,n)read(a[i]);\n\trep(i,1,n)rep(j,1,n)\n\t\tf[i][j]=(a[i]>a[j]);\n\trep(k,1,Q){\n\t\tread(x),read(y),pw=pw*2%mod;\n\t\trep(i,1,n)if(i!=x&&i!=y){\n\t\t\tg[i]=inv2*(f[x][i]+f[y][i])%mod;\n\t\t\th[i]=inv2*(f[i][x]+f[i][y])%mod;\n\t\t}\n\t\trep(i,1,n)if(i!=x&&i!=y){\n\t\t\tf[x][i]=f[y][i]=g[i];\n\t\t\tf[i][x]=f[i][y]=h[i];\n\t\t}\n\t\tf[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%mod;\n\t}\n\trep(i,1,n)rep(j,i+1,n)\n\t\tadd(ans,f[i][j]);\n\tans=(ll)ans*pw%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define R register\n#define ll long long\nconst int MAXN=3e3+10;\nconst int mod=1e9+7;\n\ninline int qpow(int x,int p)\n{\n\tint res=1;\n\twhile(p)\n\t{\n\t\tif(p&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\n\nint n,q;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(R int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(R int i=1;i<=n;i++)\n\t\tfor(R int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j]?1:0;\n\tint inv=qpow(2,mod-2);\n\tfor(R int i=1;i<=q;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(ll)(f[x][y]+f[y][x])*inv%mod;\n\t\tfor(R int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x||j==y) continue;\n\t\t\tf[j][x]=f[j][y]=(ll)(f[j][x]+f[j][y])*inv%mod;\n\t\t\tf[x][j]=f[y][j]=(ll)(f[x][j]+f[y][j])*inv%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(R int i=1;i<=n;i++)\n\t\tfor(R int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])>mod?ans+f[i][j]-mod:ans+f[i][j];\n\tprintf(\"%lld\\n\",(ll)ans*qpow(2,q)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nint N,Q, dp[3000][3000], A[3000];\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nvoid smooth(int& a, int& b) {\n    int avg = mul(ad(a,b),(MOD+1)/2);\n    a = b = avg;\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N,Q); F0R(i,N) re(A[i]);\n    F0R(i,N) F0R(j,N) if (A[i] > A[j]) dp[i][j] = 1;\n    F0R(i,Q) {\n        int x,y; re(x,y); x--, y--;\n        // x, smth or smth, x \n        F0R(j,N) if (j != x && j != y) {\n            smooth(dp[x][j],dp[y][j]);\n            smooth(dp[j][x],dp[j][y]);\n        }\n        smooth(dp[x][y],dp[y][x]);\n        // y, smth or smth, y \n        // x, y or y, x\n    }\n    int res = 0;\n    F0R(i,N) FOR(j,i+1,N) AD(res,dp[i][j]);\n    F0R(i,Q) MUL(res,2);\n    pr(res);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nconst int N = 3033;\n\nint n, a[N];\nint d[N][N];\nint q, qx[N], qy[N];\n\nint& getD(int x, int y) {\n    if (x > y)\n        swap(x, y);\n    return d[x][y];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    cin >> n >> q;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    for (int i = 0; i < q; ++i) {\n        cin >> qx[i] >> qy[i];\n        --qx[i];\n        --qy[i];\n    }\n\n    int gg = (MOD + 1) / 2;\n\n    int pow2 = 1;\n    for (int num = q - 1; num >= 0; --num) {\n        int p1 = qx[num], p2 = qy[num];\n        if (p1 > p2)\n            swap(p1, p2);\n\n        int nd0 = 1;\n        static int nd1[N], nd2[N];\n\n        for (int i = 0; i < n; ++i) {\n            if (i == p1 || i == p2)\n                continue;\n            if (i < p1)\n                nd1[i] = (getD(i, p1) + getD(i, p2)) % MOD;\n            else if (i < p2)\n                nd1[i] = (1LL*MOD + getD(i, p1) + 1 - getD(i, p2)) % MOD;\n            else\n                nd1[i] = (getD(i, p1) + getD(i, p2)) % MOD;\n            nd1[i] = (1LL * nd1[i] * gg) % MOD;\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i == p1 || i == p2)\n                continue;\n            if (i < p1)\n                nd2[i] = (getD(i, p1) + getD(i, p2)) % MOD;\n            else if (i < p2)\n                nd2[i] = (1LL*MOD - getD(i, p1) + 1 + getD(i, p2)) % MOD;\n            else\n                nd2[i] = (getD(i, p1) + getD(i, p2)) % MOD;\n            nd2[i] = (1LL * nd2[i] * gg) % MOD;\n        }\n        nd0 = (1LL * nd0 * gg) % MOD;\n\n        d[p1][p2] = nd0;\n        for (int i = 0; i < n; ++i)\n            if (i != p1 && i != p2)\n                getD(p1, i) = nd1[i];\n        for (int i = 0; i < n; ++i)\n            if (i != p1 && i != p2)\n                getD(p2, i) = nd2[i];\n\n        /*for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j)\n                fprintf(stderr, \"%4d\", getD(i, j));\n            fprintf(stderr, \"\\n\");\n        }\n        fprintf(stderr, \"\\n\");*/\n        pow2 = (pow2 * 2) % MOD;\n    }\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            d[i][j] = (1LL * d[i][j] * pow2) % MOD;\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            if (a[i] < a[j])\n                ans = (ans + getD(i, j)) % MOD;\n            else if (a[i] > a[j])\n                ans = (ans + 1LL*MOD + pow2 - getD(i, j)) % MOD;\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint max_kai = 300000;\nvel kai(max_kai, 1);\nvel inv_kai(max_kai, 1);\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x,vel &pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x],pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y,vel &pa) {\n    x = root(x,pa);\n    y = root(y,pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai() {\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nint inf = 100000;\nvel dijk(V<V<pin>>& way, int st) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nsigned main() {\n    int n, q; cin >> n >> q;\n    vel a(n);\n    rep(i, n) { cin >> a[i]; }\n    vvel b(n, vel(n));\n    rep(i, n) {\n        rep(j, n) {\n            if (a[i] > a[j]) { b[i][j]++; }\n        }\n    }\n    int inv2 = (p + 1) / 2;\n    rep(ind, q) {\n        int x, y; cin >> x >> y; x--; y--;\n        int sum1 = b[x][y] + b[y][x];\n        sum1 *= inv2; sum1 %= p;\n        b[x][y] = sum1; b[y][x] = sum1;\n        rep(i, n) {\n            if ((i != x) && (i != y)) {\n                sum1 = b[x][i] + b[y][i];\n                sum1 *= inv2; sum1 %= p;\n                b[x][i] = sum1; b[y][i] = sum1;\n                sum1 = b[i][x] + b[i][y];\n                sum1 *= inv2;sum1 %= p;\n                b[i][x] = sum1; b[i][y] = sum1;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(j, i) {\n            ans += b[j][i]; ans %= p;\n        }\n    }\n    ans *= rui(2, q, p);\n    cout << ans % p << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint dp[2][3001][3001];\n\nint Pow(int a, int b) {\n    int res = 1;\n    while(b) {\n        if(b&1) {\n            res = (1LL * res * a) % mod;\n        }\n        b >>= 1;\n        a = (1LL * a * a) % mod;\n    }\n    return res;\n}\n\nint div1(int a, int b) {\n    a %= mod;\n    return (1LL * a * (long long)Pow(b, mod - 2)) % mod;\n}\n\nint main() {\n    int n, q;\n    cin>>n>>q;\n    vector<int> A(n);\n    for(int i = 0; i < n; ++i) {\n        cin>>A[i];\n    }\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(A[i] > A[j]) {\n                dp[1][i][j] = 1;\n            }\n        }\n    }\n\n    for(int i = 1; i <= q; ++i) {\n        int x, y;\n        cin>>x>>y;\n        x--, y--;\n        for(int j = 0; j < n; ++j) {\n            if(j != x && j != y) {\n                dp[1][j][x] = dp[1][j][y] = div1(dp[1][j][x] + dp[1][j][y], 2);\n                dp[1][x][j] = dp[1][y][j] = div1(dp[1][x][j] + dp[1][y][j], 2);\n            }\n        }\n        dp[1][x][y] = dp[1][y][x] = div1(dp[1][x][y] + dp[1][y][x], 2);\n    }\n    int ans = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = i + 1; j < n; ++j) {\n            ans = (ans + dp[1][i][j]) % mod;\n        }\n    }\n    ans = (1LL * ans * Pow(2, q)) % mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#define N 3005\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nint n,q,ny=(mod+1)/2;\nint s[N],l[N],r[N];\nint f[N][N],g[N][N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&s[i]);\n\tfor(int i=1;i<=q;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(s[i]>s[j]) f[i][j]=1;\n\tint tmp=1;\n\tfor(int i=1;i<=q;i++){\n\t\tfor(int j=1;j<=n;j++) g[j][l[i]]=g[j][r[i]]=g[l[i]][j]=g[r[i]][j]=0;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j!=l[i]){\n\t\t\t\tg[j][l[i]]=(g[j][l[i]]+f[j][l[i]])%mod;\n\t\t\t\tif(j!=r[i]) g[j][l[i]]=(g[j][l[i]]+f[j][r[i]])%mod;\n\t\t\t\telse g[j][l[i]]=(g[j][l[i]]+f[l[i]][r[i]])%mod;\n\t\t\t}\n\t\t\tif(j!=r[i]){\n\t\t\t\tg[j][r[i]]=(g[j][r[i]]+f[j][r[i]])%mod;\n\t\t\t\tif(j!=l[i]) g[j][r[i]]=(g[j][r[i]]+f[j][l[i]])%mod;\n\t\t\t\telse g[j][r[i]]=(g[j][r[i]]+f[r[i]][l[i]])%mod;\n\t\t\t}\n\t\t\tif(j!=l[i]&&j!=r[i]){\n\t\t\t\tint tip=(f[l[i]][j]+f[r[i]][j])%mod;\n\t\t\t\tg[l[i]][j]=(g[l[i]][j]+tip)%mod,g[r[i]][j]=(g[r[i]][j]+tip)%mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tf[j][l[i]]=(ll)g[j][l[i]]*ny%mod;f[j][r[i]]=(ll)g[j][r[i]]*ny%mod;\n\t\t\tf[l[i]][j]=(ll)g[l[i]][j]*ny%mod;f[r[i]][j]=(ll)g[r[i]][j]*ny%mod;\n\t\t}\n\t\ttmp=(ll)tmp*2%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(ans+(ll)tmp*f[i][j]%mod)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n  }\n  public:\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    inline int prod (int a, int b) const {\n      return (long long)a * b % md;\n    }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  int inv2 = fld.inv(2);\n  int coeff = fld.pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      a = b = fld.prod(a, inv2);\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "2"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=500005,M=1000000007;\nint n,u[N],v[N],i,q,a[N],g[3005][3005],tmp[3005][3005],j;\nlong long inv,ans;\nlong long qpow(long long a,long long b)\n{\n\tlong long ans=1,s=a;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=q;++i)\n\t\tscanf(\"%d %d\",&u[i],&v[i]);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tg[i][j]=1;\n\tinv=qpow(2,M-2);\n\tfor(i=1;i<=q;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(j!=u[i]&&j!=v[i])\n\t\t\t{\n\t\t\t\ttmp[u[i]][j]=tmp[v[i]][j]=(g[v[i]][j]+g[u[i]][j])*inv%M;\n\t\t\t\ttmp[j][u[i]]=tmp[j][v[i]]=(g[j][u[i]]+g[j][v[i]])*inv%M;\n\t\t\t}\n\t\ttmp[v[i]][u[i]]=tmp[u[i]][v[i]]=(g[u[i]][v[i]]+g[v[i]][u[i]])*inv%M;\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tg[u[i]][j]=tmp[u[i]][j];\n\t\t\tg[v[i]][j]=tmp[v[i]][j];\n\t\t\tg[j][u[i]]=tmp[j][u[i]];\n\t\t\tg[j][v[i]]=tmp[j][v[i]];\n\t\t}\t\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tans+=g[i][j];\n\tans%=M;\n\tcout<<(ans*qpow(2,q)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mu=1000000007;\nconst int N=3005,inv2=(mu+1)>>1;\nint dp[N][N],a[N],x,y,n,m,ans;\nlong long ksm(int x,int y){\n\tlong long ans=1;\n\tfor (;y;y>>=1,x=x*1ll*x%mu)\n\t\tif (y&1) ans=ans*x%mu;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (a[i]>a[j]) dp[i][j]=1;\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=1ll*(dp[x][y]+dp[y][x])*inv2%mu;\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (j==x || y==j) continue;\n\t\t\tdp[y][j]=dp[x][j]=(dp[y][j]+dp[x][j])*1ll*inv2%mu;\n\t\t\tdp[j][y]=dp[j][x]=(dp[j][y]+dp[j][x])*1ll*inv2%mu; \n\t\t}\n\t}\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tans=(ans+dp[i][j])%mu;\n\tprintf(\"%d\",ans*ksm(2,m)%mu); \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, Q, w[3010];\nlong long Mod = 1000000007, D[3010][3010], TA[3010], TB[3010], SA[3010], SB[3010], I2 = Mod/2+1;\nint main() {\n\tint i, j, a, b;\n\tscanf(\"%d%d\", &n, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tfor (i = 1; i <= n; i++)for (j = 1; j <= n; j++)if (w[i] < w[j])D[i][j] = 1;\n\tfor(int TT=0;TT<Q;TT++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tTA[i] = D[a][i];\n\t\t\tTB[i] = D[b][i];\n\t\t\tSA[i] = D[i][a];\n\t\t\tSB[i] = D[i][b];\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (i != a && i != b) {\n\t\t\t\tD[a][i] = D[b][i] = (TA[i] + TB[i])*I2%Mod;\n\t\t\t\tD[i][a] = D[i][b] = (SA[i] + SB[i])*I2%Mod;\n\t\t\t}\n\t\t}\n\t\tD[a][b] = D[b][a] = (TA[b] + TB[a])*I2%Mod;\n\t}\n\tlong long res = 0;\n\tfor (i = 1; i <= n; i++)for (j = 1; j < i; j++)res = (res + D[i][j]) % Mod;\n\twhile (Q--)res = res * 2 % Mod;\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int N(3005), Mod(1e9 + 7), inv2((Mod + 1) >> 1);\nint n, Q, f[N][N], a[N], Pow = 1, ans;\n\nint main()\n{\n\tn = read(), Q = read();\n\tfor (int i = 1; i <= n; i++) a[i] = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) f[i][j] = a[i] < a[j];\n\tfor (int i = 1, x, y; i <= Q; i++)\n\t{\n\t\tPow = (Pow + Pow) % Mod, x = read(), y = read();\n\t\tf[x][y] = f[y][x] = 1ll * inv2 * (f[x][y] + f[y][x]) % Mod;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (j == x || j == y) continue;\n\t\t\tf[x][j] = f[y][j] = 1ll * inv2 * (f[x][j] + f[y][j]) % Mod;\n\t\t\tf[j][x] = f[j][y] = 1ll * inv2 * (f[j][x] + f[j][y]) % Mod;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) ans = (ans + f[j][i]) % Mod;\n\tprintf(\"%lld\\n\", 1ll * ans * Pow % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int p=1000000007,inv2=(p+1)/2; \nint qpow(int a,int k){\n\tint ans=1;\n\twhile(k){\n\t\tif(k&1) ans=1LL*ans*a%p;\n\t\ta=1LL*a*a%p;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\n\nint N,Q;\nint A[3005];\nint F[3005][3005];\n\nint main(){\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i=1;i<=N;i++) scanf(\"%d\",&A[i]);\n\tfor(int i=1;i<=N;i++)\n\tfor(int j=1;j<=N;j++)\n\t\tF[i][j]=(A[i]>A[j]);\n\tfor(int i=1;i<=Q;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tF[x][y]=F[y][x]=1LL*(F[x][y]+F[y][x])%p*inv2%p;\n\t\tfor(int j=1;j<=N;j++)if(j!=x&&j!=y){\n\t\t\tF[j][x]=F[j][y]=1LL*(F[j][x]+F[j][y])%p*inv2%p;\n\t\t\tF[x][j]=F[y][j]=1LL*(F[x][j]+F[y][j])%p*inv2%p;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=N;i++)\n\tfor(int j=i+1;j<=N;j++)\n\t\tans=(ans+F[i][j])%p;\n\tprintf(\"%d\\n\",1LL*ans*qpow(2,Q)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define Divhim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define Divher() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define LL long long\n\nconst int N=3333;\nconst int MOD=1e9+7;\n\nint U(int x,int y)\n{\n\treturn ((x+=y)>=MOD)?(x-MOD):x;\n}\n\nint Qpow(int x,int y=MOD-2)\n{\n\tint res=1;\n\tfor(;y;y>>=1,x=(LL)x*x%MOD)if(y&1)\n\t\tres=(LL)res*x%MOD;\n\treturn res;\n}\n\nint n,q,dp[N][N],a[N],ny2;\n\nvoid Doit(int x,int y)\n{\n\t//int a=U(dp[x][y],dp[y][x]);\n\t//dp[x][y]=(LL)ny2*a; dp[y][x]=(LL)ny2*a;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if(i!=j)\n\t\tdp[i][j]=(a[i]>a[j]);\n\tny2=Qpow(2);\n\tfor(int i=1,x,y;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;++i)if(i!=x&&i!=y)\n\t\t{\n\t\t\tdp[x][i]=dp[y][i]=(LL)ny2*U(dp[x][i],dp[y][i])%MOD;\n\t\t\tdp[i][x]=dp[i][y]=(LL)ny2*U(dp[i][x],dp[i][y])%MOD;\n\t\t}\n\t\tdp[x][y]=dp[y][x]=(LL)ny2*U(dp[x][y],dp[y][x])%MOD;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if(i<j)\n\t\tans=U(ans,dp[i][j]);\n\tans=(LL)ans*Qpow(2,q)%MOD;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll maxn = 3e3 + 100;\nconst ll mod = 1e9 + 7;\nconst ll nim = (mod + 1) >> 1;\nconst ll inf = 1e18;\n\n#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define file_io freopen(\"input.txt\", \"r+\", stdin);freopen(\"output.txt\", \"w+\", stdout);\n#define pb push_back\n#define Mp make_pair\n#define F first\n#define S second\n\nll n, q, a[maxn], dp[maxn][maxn];\n\nint main(){\n    fast_io;\n\n    cin >> n >> q;\n    for(ll i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for(ll i = 1; i <= n; i++){\n        for(ll j = 1; j <= n; j++){\n            dp[i][j] = ll(a[i] > a[j]);\n        }\n    }\n    for(ll i = 0; i < q; i++){\n        ll v, u;\n        cin >> v >> u;\n        for(ll j = 1; j <= n; j++){\n            if(v == j || u == j) continue;\n            dp[v][j] = dp[u][j] = ((dp[v][j] + dp[u][j]) * nim) % mod;\n            dp[j][v] = dp[j][u] = ((dp[j][v] + dp[j][u]) * nim) % mod;\n        }\n        dp[v][u] = dp[u][v] = ((dp[v][u] + dp[u][v]) * nim) % mod;\n    }\n    ll ans = 0;\n    for(ll i = 1; i <= n; i++){\n        for(ll j = 1; j < i; j++){\n            ans += dp[j][i];\n            if(ans >= mod) ans -= mod;\n        }\n    }\n    for(ll i = 0; i < q; i++){\n        ans <<= 1;\n        if(ans >= mod) ans -= mod;\n    }\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\n#include<bitset>\n#define int long long\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\nconst int maxn=3005,mod=1e9+7,niyuan=5e8+4;\nint n,q,dp[maxn][maxn],a[maxn],ans;\ninline int read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n\t\tif(ch=='-')\n\t\t\tf=-1;\n\t\tch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n    }\n    return x*f;\n}\ninline void write(int a)\n{\n    if(a<0)\n    {\n\t\tputchar('-');\n\t\tputchar('1');\n    }\n    else\n    {\n\t\tif(a>=10)\n\t\t\twrite(a/10);\n\t\tputchar(a%10+'0');\n    }\n}\nsigned main()\n{\n\tn=read(),q=read();\n\tint tmp=1;\n\tfor(int i=1;i<=q;++i)\n\t\ttmp=tmp*2%mod;\n\tfor(int i=1;i<=n;++i)\n\t\ta[i]=read();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tdp[i][j]=tmp*(a[i]>a[j]);\n//\tfor(int i=1;i<=n;++i,cout<<endl)\n//\t\tfor(int j=1;j<=n;++j)\n//\t\t\tcout<<dp[i][j]<<' ';\n\twhile(q--)\n\t{\n\t\tint x=read(),y=read();\n\t\tif(x>y)\n\t\t\tswap(x,y);\n\t\tint xi[maxn],yi[maxn],ix[maxn],iy[maxn];\n\t\tfor(int i=1;i<=n;++i)\n\t\t\txi[i]=dp[x][i],yi[i]=dp[y][i],ix[i]=dp[i][x],iy[i]=dp[i][y];\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(i!=x&&i!=y)\n\t\t\t{\n\t\t\t\tdp[i][x]=ix[i]*niyuan%mod+iy[i]*niyuan%mod;\n\t\t\t\tdp[i][y]=ix[i]*niyuan%mod+iy[i]*niyuan%mod;\n\t\t\t\tdp[x][i]=xi[i]*niyuan%mod+yi[i]*niyuan%mod;\n\t\t\t\tdp[y][i]=xi[i]*niyuan%mod+yi[i]*niyuan%mod;\n\t\t\t}\n\t\tdp[y][x]=dp[x][y]=xi[y]*niyuan%mod+yi[x]*niyuan%mod;\n//\t\tfor(int i=1;i<=n;++i,cout<<endl)\n//\t\t\tfor(int j=1;j<=n;++j)\n//\t\t\t\tcout<<dp[i][j]<<' ';\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tans=(ans+dp[i][j])%mod;\n\twrite(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string (string s) { return '\"' + s + '\"'; }\n\nstring to_string (const char *s) { return to_string ((string) s); }\n\nstring to_string (bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string (pair<A, B> p) { return \"(\" + to_string (p.first) + \", \" + to_string (p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string (A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string (x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out () { cerr<<endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out (Head H, Tail... T) {\n    cerr<<\" \"<<to_string (H);\n    debug_out (T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin (T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax (T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop (ll x) { return 1ULL<<x; }\n\nll MOD (ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse (ll a, ll m) {\n    a = MOD (a, m);\n    if (a <= 1)return a;\n    return MOD ((1 - inverse (m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr (T x) { return x * x; }\n\nll gcd (ll a, ll b) {\n    a = abs (a), b = abs (b);\n    while (b != 0) {\n        a %= b;\n        swap (a, b);\n    }\n    return a;\n}\n\nll fast (ll a, ll b, ll mod) {\n    if (b < 0)a = inverse (a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\nconst ll inv = inverse (2, mod);\nint prob[3010][3010], n, q;\nVI v;\n\nnamespace SOLVE {\n    void main () {\n        cin>>n>>q;\n        v.resize (n);\n        REP(i, 0, n) {\n            cin>>v[i];\n        }\n        REP(i, 0, n) {\n            REP(j, 0, n) {\n                prob[i][j] = v[i] > v[j];\n            }\n        }\n        dbg((prob[1][0] + prob[0][1]) * inv % mod);\n        REP(i, 0, q) {\n            int a, b;\n            cin>>a>>b;\n            a--;\n            b--;\n            REP(i, 0, n) {\n                if (i != a and i != b) {\n                    prob[i][b] = prob[i][a] = (prob[i][a] + prob[i][b]) * inv % mod;\n                    prob[b][i] = prob[a][i] = (prob[a][i] + prob[b][i]) * inv % mod;\n                }\n            }\n            prob[a][b] = prob[b][a] = (prob[b][a] + prob[a][b]) * inv % mod;\n        }\n        ll ans = 0;\n        REP(i, 0, n) {\n            REP(j, i + 1, n) {\n//                cout<<prob[i][j]<<\" \";\n                ans += prob[i][j];\n            }\n//            cout<<endl;\n        }\n        ans %= mod;\n        ans *= fast (2, q, mod);\n        cout<<ans % mod<<endl;\n    }\n}\n\n\nsigned main () {\n#ifdef LOCAL\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main ();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-12\n#define M_PI 3.141592653589793\n#define bsize 300\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 200031;\n\nlong long A[3031][3031];\nint n,tests,ar[N];\nint last_mod[N];\nlong long pw[N];\nint T;\n\nlong long inv2;\n\nvoid eval(int id){\n\tfor (int i=1;i<=n;i++){\n\t\tA[id][i]=A[id][i]*pw[T-last_mod[id]];\n\t\tA[id][i]%=bs;\n\t}\n\tlast_mod[id]=T;\n}\n\nlong long P(long long a,long long b){\n\tif (b==0)\n\t\treturn 1;\n\tif (b%2)\n\t\treturn a*P(a,b-1)%bs;\n\treturn P(a*a%bs,b/2);\n}\n\nlong long inv(long long x){\n\treturn P(x,bs-2);\n}\n\nint main(){\n//    freopen(\"apache.in\",\"r\",stdin);\n//    freopen(\"apache.out\",\"w\",stdout);\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    //cin.tie(0);\n\n    pw[0]=1;\n    for (int i=1;i<N;i++){\n    \tpw[i]=pw[i-1]*2%bs;\n    }\n\n    inv2=inv(2);\n\n    cin>>n>>tests;\n    for (int i=1;i<=n;i++){\n    \tcin>>ar[i];\n    }\n\n    for (int i=1;i<=n;i++){\n    \tfor (int j=1;j<=n;j++){\n    \t\tif (ar[i]>ar[j])\n    \t\t\tA[i][j]=1;\n    \t}\n    }\n\n    for (int i=1;i<=n;i++){\n    \tlast_mod[i]=0;\n    }\n\n    for (int test=1;test<=tests;test++){\n    \tint a,b;\n    \tcin>>a>>b;\n    \tfor (int i=1;i<=n;i++){\n    \t\tif (i!=a&&i!=b){\n    \t\t\tlong long here=A[a][i]+A[b][i];\n    \t\t\there=here*inv2;\n    \t\t\there%=bs;\n    \t\t\tA[a][i]=A[b][i]=here;\n    \t\t\there=A[i][a]+A[i][b];\n    \t\t\there=here*inv2;\n    \t\t\there%=bs;\n    \t\t\tA[i][a]=A[i][b]=here;\n    \t\t}\n    \t}\n    \tlong long here=A[a][b]+A[b][a];\n    \there=here*inv2;\n    \there%=bs;\n    \tA[a][b]=A[b][a]=here;\n    }\n\n\n    long long ans=0;\n\n    for (int i=1;i<=n;i++){\n    \tfor (int j=i+1;j<=n;j++){\n    \t\tlong long here=A[i][j]*pw[tests];\n    \t\there%=bs;\n    \t\tans+=here;//    \t\tcout<<A[i][j]*pw[tests]%bs<<\" \";\n    \t\tans%=bs;\n    \t}\n//    \tcout<<endl;\n    }\n\n    cout<<ans<<endl;\n\n//    cin.get(); cin.get();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = *this^(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, Q;\n\tcin >> N >> Q;\n\tvector<ll> A(N + 1);\n\trepn(i, N) cin >> A[i];\n\n\tvector<ll> X(Q + 1), Y(Q + 1);\n\trepn(i, Q) cin >> X[i] >> Y[i];\n\n\tvector<vector<mint>> dp(N + 1, vector<mint>(N + 1,0));\n\tvector<vector<ll>> up(N + 1, vector<ll>(N + 1, 0));\n\n\tvector<mint> pw(Q + 1, 1);\n\trepn(i, Q)pw[i] = pw[i - 1] * 2;\n\n\trepn(i, N)repn(j, N) {\n\t\tif (A[i] > A[j]) { dp[i][j] = 1; }\n\t}\n\t\n\trepn(q, Q) {\n\t\tll x = X[q];\n\t\tll y = Y[q];\n\n\t\trepn(i, N) {\n\t\t\tif (i == x || i == y) { continue; }\n\n\t\t\tmint t, u;\n\n\t\t\tt = pw[q - up[x][i] - 1] * dp[x][i];\n\t\t\tt += pw[q - up[y][i] - 1] * dp[y][i];\n\n\t\t\tu = pw[q - up[x][i] - 1] * dp[x][i];\n\t\t\tu += pw[q - up[y][i] - 1] * dp[y][i];\n\n\t\t\tdp[x][i] = t;\n\t\t\tdp[y][i] = u;\n\n\t\t\tt = 0;\n\t\t\tu = 0;\n\n\t\t\tt = pw[q - up[i][x] - 1] * dp[i][x];\n\t\t\tt += pw[q - up[i][y] - 1] * dp[i][y];\n\n\t\t\tu = pw[q - up[i][x] - 1] * dp[i][x];\n\t\t\tu += pw[q - up[i][y] - 1] * dp[i][y];\n\n\t\t\tdp[i][x] = t;\n\t\t\tdp[i][y] = u;\n\n\t\t\tup[x][i] = q;\n\t\t\tup[y][i] = q;\n\t\t\tup[i][x] = q;\n\t\t\tup[i][y] = q;\n\n\t\t}\n\n\t\tmint t, u;\n\n\t\tt = pw[q - up[x][y] - 1] * dp[x][y];\n\t\tt += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tu = pw[q - up[x][y] - 1] * dp[x][y];\n\t\tu+= pw[q - up[y][x] - 1] * dp[y][x];\n\n\t\tdp[x][y] = t;\n\t\tdp[y][x] = u;\n\n\t\tup[x][y] = q;\n\t\tup[y][x] = q;\n\n\n\t}\n\n\tmint ans = 0;\n\trepn(i, N)repn(j, N) {\n\t\tdp[i][j] *= ((mint)2 ^ (Q - up[i][j]));\n\t\tif (j > i) { ans += dp[i][j]; }\n\t}\n\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-01-25 21:32:53\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=3010,mod=1000000007;\ni64 power(i64 a,i64 b,i64 p)\n{\n\ti64 r=1; a%=p;\n\tfor(;b;b>>=1,a=a*a%p) if(b&1) r=r*a%p;\n\treturn r;\n}\ni64 inv(i64 a){ return power(a,mod-2,mod); }\ni64 n,q,a[N],f[N][N],F[N][N],i2=inv(2),x,y;\nint main()\n{\n\tn=read(); q=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n) fr(j,1,n) if(i!=j) f[i][j]=F[i][j]=(a[i]<a[j]);\n//\tfr(i,1,n) fr(j,1,n) printf(\"%d%c\",int(f[i][j]+f[j][i])%mod,j==end_j?'\\n':' ');\n\tfr(i,1,q)\n\t{\n\t\tx=read(); y=read();\n\t\tfr(j,1,n) if(j!=x&&j!=y) f[y][j]=f[x][j]=i2*(F[x][j]+F[y][j])%mod;\n\t\tfr(j,1,n) if(j!=x&&j!=y) f[j][y]=f[j][x]=i2*(F[j][x]+F[j][y])%mod;\n\t\tf[x][y]=f[y][x]=i2*(F[x][y]+F[y][x])%mod;\n\t\tfr(j,1,n){ F[x][j]=f[x][j]; F[y][j]=f[y][j]; F[j][x]=f[j][x]; F[j][y]=f[j][y]; }\n//\t\tfr(i,1,n) fr(j,1,n) printf(\"%d%c\",int(f[i][j]+f[j][i])%mod,j==end_j?'\\n':' ');\n\t}\n\ti64 ans=0;\n//\tfr(i,1,n) fr(j,1,n) printf(\"%d%c\",int(f[i][j]+f[j][i])%mod,j==end_j?'\\n':' ');\n\tfr(i,1,n) fr(j,1,i-1) ans+=f[i][j];\n\tprintf(\"%d\\n\",int(ans%mod*power(2,q,mod)%mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pdi = pair<double, int>;\ntemplate <class T> using mat = vector<vector<T>>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\n\n#define each(i,v) for (auto i = begin(v); i != end(v); ++i)\n#define reach(i,v) for (auto i = rbegin(v); i != rend(v); ++i)\n#define urep(i,s,t) for (int i = (s); i <= (t); ++i)\n#define drep(i,s,t) for (int i = (s); i >= (t); --i)\n#define rep(i,n) urep(i, 0, (n)-1)\n#define rep1(i,n) urep(i, 1, (n))\n#define rrep(i,n) drep(i, (n)-1, 0)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define front fro\n#define back bac\n#define vct vector\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper(uint_fast8_t prec) {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout << fixed << setprecision(prec);\n#ifdef Local\n        auto print_atexit = []() { cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\"; };\n        atexit(print_atexit);\n#endif\n    }\n} setuppre_obj(10);\n\nnamespace std {\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> ostream& operator << (ostream& s, pair<T,U> p) { return s << p.fir << \" \" << p.sec; }\ntemplate <class T> ostream& operator << (ostream& s, vct<T> v) { each(i,v) { if(i != begin(v)) s << \" \"; s << *i; } return s; }\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\nconst auto add = [](auto &x, auto y) { x += y; };\nconst auto mul = [](auto &x, auto y) { x *= y; };\nconst auto lam_min = [](auto x, auto y) { return min(x, y); };\nconst auto lam_max = [](auto x, auto y) { return max(x, y); };\nconst auto chmax = [](auto &m, auto x) { if(m < x){ m = x; return true; } return false; };\nconst auto chmin = [](auto &m, auto x) { if(m > x){ m = x; return true; } return false; };\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binsr(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> T cmprs(T &v) {\n    T tmp = v, ret = v;\n    sort(all(tmp));\n    tmp.erase(unique(all(tmp)), end(tmp));\n    each(i,ret) *i = l_bnd(all(tmp),*i) - begin(tmp);\n    return ret;\n}\n\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2 - 1;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double gold = 1.618033988;\nconstexpr long double eps = 1e-15;\nconstexpr uint_fast64_t mod = 1e9 + 7;\n\nint n,Q;\ni64 up[1<<12][1<<12],dw[1<<12][1<<12];\nint last[1<<12][1<<12];\ni64 two[1<<12];\n\nvoid upd(int i,int j,int t) {\n    assert(i<j);\n    if(t==last[i][j]) return;\n    assert(t>last[i][j]);\n    up[i][j]=up[i][j]*two[t-1-last[i][j]]%mod;\n    dw[i][j]=dw[i][j]*two[t-1-last[i][j]]%mod;\n    last[i][j]=t;\n    return;\n}\n\nint main() {\n    cin>>n>>Q;\n    int a[1<<12];\n    for(int i=0; i<n; i++) cin>>a[i];\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            if(a[i]>a[j]) up[j][i]++;\n            if(a[j]>a[i]) dw[j][i]++;\n            last[j][i]=-1;\n        }\n    }\n\n    two[0]=1;\n    for(int i=0; i<Q; i++) two[i+1]=two[i]*2%mod;\n\n    for(int i=0; i<Q; i++) {\n        u_map<pii,int> up_nx,dw_nx;\n        int x,y;\n        cin>>x>>y;\n        if(--x > --y) swap(x,y);\n\n        for(int j=0; j<x; j++) {\n            upd(j,y,i);\n            upd(j,x,i);\n            (dw_nx[mkp(j,y)]+=dw[j][x])%=mod;\n            (up_nx[mkp(j,y)]+=up[j][x])%=mod;\n            (dw_nx[mkp(j,x)]+=dw[j][y])%=mod;\n            (up_nx[mkp(j,x)]+=up[j][y])%=mod;\n        }\n        for(int j=y+1; j<n; j++) {\n            upd(x,j,i);\n            upd(y,j,i);\n            (dw_nx[mkp(x,j)]+=dw[y][j])%=mod;\n            (up_nx[mkp(x,j)]+=up[y][j])%=mod;\n            (dw_nx[mkp(y,j)]+=dw[x][j])%=mod;\n            (up_nx[mkp(y,j)]+=up[x][j])%=mod;\n        }\n        for(int j=x+1; j<y; j++) {\n            upd(j,y,i);\n            upd(x,j,i);\n            (up_nx[mkp(x,j)]+=dw[j][y])%=mod;\n            (up_nx[mkp(j,y)]+=dw[x][j])%=mod;\n            (dw_nx[mkp(x,j)]+=up[j][y])%=mod;\n            (dw_nx[mkp(j,y)]+=up[x][j])%=mod;\n        }\n        {\n            upd(x,y,i);\n            up_nx[mkp(x,y)]=dw[x][y];\n            dw_nx[mkp(x,y)]=up[x][y];\n        }\n        for(auto &p:up_nx) {\n            int s=p.fir.fir,t=p.fir.sec;\n            upd(s,t,i);\n            up[s][t]=(up[s][t]+p.sec)%mod;\n        }\n        for(auto &p:dw_nx) {\n            int s=p.fir.fir,t=p.fir.sec;\n            upd(s,t,i);\n            dw[s][t]=(dw[s][t]+p.sec)%mod;\n        }\n    }\n\n    int ans=0;\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            upd(j,i,Q);\n            ans=(ans+dw[j][i])%mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define int long long\n#define mod 1000000007\n#define inv2 500000004\nint n,m,a[3010],f[3010][3010],g[3010][3010],A,B,ans;\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tg[A][j]=(f[A][j]+f[B][j])%mod*inv2%mod;\n\t\t\tg[j][A]=(f[j][A]+f[j][B])%mod*inv2%mod;\n\t\t\tg[B][j]=g[A][j];\n\t\t\tg[j][B]=g[j][A];\t\t\n\t\t}\n\t\tg[A][B]=g[B][A]=(f[A][B]+f[B][A])%mod*inv2%mod;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tf[A][j]=g[A][j];\n\t\t\tf[B][j]=g[B][j];\n\t\t\tf[j][A]=g[j][A];\n\t\t\tf[j][B]=g[j][B];\t\t\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t(ans+=f[j][i])%=mod;\n\tfor(int i=1;i<=m;i++)\n\t\t(ans*=2)%=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n    static const int S=1e7;\n    char rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n    fastio() {rpos=len=wpos=0;}\n    inline char Getchar()\n    {\n        if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n        if (!len) return EOF;\n        return rbuf[rpos++];\n    }\n    template <class T> inline void Get(T &x)\n    {\n        char ch;bool f;T res;\n        while (!isdigit(ch=Getchar()) && ch!='-') {}\n        if (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n        while (isdigit(ch=Getchar())) res=res*10+ch-'0';\n        x=(f?res:-res);\n    }\n    inline void getstring(char *s)\n    {\n        char ch;\n        while ((ch=Getchar())<=32) {}\n        for (;ch>32;ch=Getchar()) *s++=ch;\n        *s='\\0';\n    }\n    inline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n    inline void Writechar(char ch)\n    {\n        if (wpos==S) flush();\n        wbuf[wpos++]=ch;\n    }\n    template <class T> inline void Print(T x,char ch)\n    {\n        char s[20];int pt=0;\n        if (x==0) s[++pt]='0';\n        else\n        {\n            if (x<0) Writechar('-'),x=-x;\n            while (x) s[++pt]='0'+x%10,x/=10;\n        }\n        while (pt) Writechar(s[pt--]);\n        Writechar(ch);\n    }\n    inline void printstring(char *s)\n    {\n        int pt=1;\n        while (s[pt]!='\\0') Writechar(s[pt++]);\n    }\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=3000;\n\nint n,q,a[MAXN+48];\nint dp[MAXN+48][MAXN+48];\n\nint main ()\n{\n#ifdef LOCAL\n    double TIME=clock();\n    freopen (\"a.in\",\"r\",stdin);\n    freopen (\"a.out\",\"w\",stdout);\n    cerr<<\"Running...\"<<endl;\n#endif\n    scanf(\"%d%d\",&n,&q);int l,r,inv2=quick_pow(2,MOD-2);\n    for (register int i=1;i<=n;i++) scanf(\"%d\",a+i);\n    for (register int i=1;i<=n;i++)\n        for (register int j=1;j<=n;j++)\n            dp[i][j]=(a[i]>a[j]);\n    for (register int ope=1;ope<=q;ope++)\n    {\n        scanf(\"%d%d\",&l,&r);\n        dp[l][r]=dp[r][l]=1ll*add(dp[l][r]+dp[r][l])*inv2%MOD;\n        for (register int i=1;i<=n;i++)\n        {\n            if (i==l || i==r) continue;\n            dp[i][l]=dp[i][r]=1ll*add(dp[i][l]+dp[i][r])*inv2%MOD;\n            dp[l][i]=dp[r][i]=1ll*add(dp[l][i]+dp[r][i])*inv2%MOD;\n        }\n    }\n    int ans=0;\n    for (register int i=1;i<=n-1;i++)\n        for (register int j=i+1;j<=n;j++)\n            Add(ans,dp[i][j]);\n    ans=1ll*ans*quick_pow(2,q)%MOD;\n    printf(\"%d\\n\",ans);\n    io.flush();\n#ifdef LOCAL\n    cerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=3005;\nconst int mod=1e9+7;\nconst int two=5e8+4;\nint n,q,a[MN],X[MN],Y[MN];\nint f[MN][MN];\ninline ll qpow(ll a,ll b){\n\treg ll res=1;\n\twhile(b){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(reg int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(reg int i=1;i<=q;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif(a[i]>a[j])f[i][j]=1;\n\tfor(reg int i=1;i<=q;i++){\n\t\tf[X[i]][Y[i]]=f[Y[i]][X[i]]=1ll*(f[X[i]][Y[i]]+f[Y[i]][X[i]])*two%mod;\n\t\tfor(reg int j=1;j<=n;j++){\n\t\t\tif(j==X[i]||j==Y[i])continue;\n\t\t\tf[X[i]][j]=f[Y[i]][j]=1ll*(f[X[i]][j]+f[Y[i]][j])*two%mod;\n\t\t\tf[j][X[i]]=f[j][Y[i]]=1ll*(f[j][X[i]]+f[j][Y[i]])*two%mod;\n\t\t}\n\t}\n\treg ll Ans=0;\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=i+1;j<=n;j++)\n\t\t\tAns=(Ans+f[i][j])%mod;\n\tprintf(\"%d\\n\",1ll*Ans*qpow(2,q)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=500005,M=1000000007;\nint n,u[N],v[N],i,q,a[N],g[3005][3005],tmp[3005][3005],j;\nlong long inv,ans;\nlong long qpow(long long a,long long b)\n{\n\tlong long ans=1,s=a;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=q;++i)\n\t\tscanf(\"%d %d\",&u[i],&v[i]);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tg[i][j]=1;\n\tinv=qpow(2,M-2);\n\tfor(i=1;i<=q;++i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(j!=u[i]&&j!=v[i])\n\t\t\t{\n\t\t\t\ttmp[u[i]][j]=tmp[v[i]][j]=(g[v[i]][j]+g[u[i]][j])*inv%M;\n\t\t\t\ttmp[j][u[i]]=tmp[j][v[i]]=(g[j][u[i]]+g[j][v[i]])*inv%M;\n\t\t\t}\n\t\ttmp[v[i]][u[i]]=tmp[u[i]][v[i]]=(g[u[i]][v[i]]+g[v[i]][u[i]])*inv%M;\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tg[u[i]][j]=tmp[u[i]][j];\n\t\t\tg[v[i]][j]=tmp[v[i]][j];\n\t\t\tg[j][u[i]]=tmp[j][u[i]];\n\t\t\tg[j][v[i]]=tmp[j][v[i]];\n\t\t}\t\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tans+=g[i][j];\n\tcout<<(ans*qpow(2,q)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n \nconst int mod=1000000007;\nconst int inv2=(mod+1)/2;\nint n,m,a[5010],x,y,i,j;\n \nlong long p[5010][5010],t;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)p[i][j]=a[i]>a[j];\n\tfor (int k=0;k<m;k++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tp[x][y]=p[y][x]=(p[x][y]+p[y][x])%mod;\n\t\tfor(i=1;i<=n;++i)if(i!=x&&i!=y) p[i][x]=p[i][y]=(p[i][x]+p[i][y])%mod,\n\t\t\tp[x][i]=p[y][i]=(p[x][i]+p[y][i])%mod;\n\t}\n\tfor(i=1;i<=n;++i)for(j=n;j>i;--j)t=(t+p[i][j])%mod;\n\tprintf(\"%lld\\n\",t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL mod = 1e9 + 7;\nconst int N = 3010;\n\ninline LL power(LL a, LL n, LL mod)\n{\n\tLL Ans = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1) Ans = Ans * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn Ans;\n}\n\nint a[N], X[N], Y[N];\nint n, q;\n\nLL dp[N][N];\n\nint main()\n{\n\tLL inv2 = power(2, mod-2, mod);\n\t\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= q; i++) scanf(\"%d%d\", X + i, Y + i);\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) dp[i][j] = a[i] < a[j] ? 1 : 0;\n\t\n\tint cur = 0;\n\tfor (int i = 1; i <= q; i++)\n\t{\n\t\tcur ^= 1;\n\t\tint a = X[i], b = Y[i];\n\t\tdp[a][b] = dp[b][a] = 1LL * inv2 * (dp[a][b] + dp[b][a]) % mod;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (j != a && j != b)\n\t\t\t{\n\t\t\t\tdp[j][a] = dp[j][b] = 1LL * inv2 * (dp[j][a] + dp[j][b]) % mod;\n\t\t\t\tdp[a][j] = dp[b][j] = 1LL * inv2 * (dp[a][j] + dp[b][j]) % mod;\n\t\t\t}\n\t}\n\t\n\tLL Ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j < i; j++) Ans = (Ans + dp[i][j]) % mod;\n\tcout << Ans * power(2, q, mod) % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nstruct mint {\n    int n;\n    mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) {\n    a.n += b.n;\n    if (a.n >= mod) a.n -= mod;\n    return a.n;\n}\n\nmint operator-(mint a, mint b) {\n    a.n -= b.n;\n    if (a.n < 0) a.n += mod;\n    return a.n;\n}\n\nmint operator*(mint a, mint b) {\n    return (long long)a.n * b.n % mod;\n}\n\nmint &operator+=(mint &a, mint b) {\n    return a = a + b;\n}\n\nmint &operator-=(mint &a, mint b) {\n    return a = a - b;\n}\n\nmint &operator*=(mint &a, mint b) {\n    return a = a * b;\n}\n\nmint dp[3030][3030];\nint A[3000];\nint X[3000], Y[3000];\nmint tmpX_[3000];\nmint tmpY_[3000];\nmint tmp_X[3000];\nmint tmp_Y[3000];\n\nint main() {\n    mint inv2 = (mod + 1) / 2;\n    int n, q;\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n    }\n    for (int i = 0; i < q; i++) {\n        cin >> X[i] >> Y[i];\n        X[i]--;\n        Y[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[i] < A[j]) {\n                dp[i][j] += 1;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        for (int j = 0; j < n; j++) {\n            tmpX_[j] = dp[X[i]][j];\n            tmpY_[j] = dp[Y[i]][j];\n            tmp_X[j] = dp[j][X[i]];\n            tmp_Y[j] = dp[j][Y[i]];\n        }\n        for (int j = 0; j < n; j++) {\n            if (j == X[i] || j == Y[i]) continue;\n            dp[j][X[i]] = (tmp_X[j] + tmp_Y[j]) * inv2;\n            dp[j][Y[i]] = (tmp_X[j] + tmp_Y[j]) * inv2;\n            dp[X[i]][j] = (tmpX_[j] + tmpY_[j]) * inv2;\n            dp[Y[i]][j] = (tmpX_[j] + tmpY_[j]) * inv2;\n            // dp[j][X[i]] -> dp[j][X[i]]\n            // dp[j][X[i]] -> dp[j][Y[i]]\n            // dp[X[i]][j] -> dp[X[i]][j]\n            // dp[X[i]][j] -> dp[Y[i]][j]\n            // dp[X[i]][Y[i]] -> dp[X[i]][Y[i]]\n            // dp[X[i]][Y[i]] -> dp[Y[i]][X[i]]\n            // dp[Y[i]][X[i]] -> dp[Y[i]][X[i]]\n            // dp[Y[i]][X[i]] -> dp[X[i]][Y[i]]\n        }\n        dp[X[i]][Y[i]] = (tmpX_[Y[i]] + tmpY_[X[i]]) * inv2;\n        dp[Y[i]][X[i]] = (tmpX_[Y[i]] + tmpY_[X[i]]) * inv2;\n    }\n    mint ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            ans += dp[i][j];\n        }\n    }\n    for (int i = 0; i < q; i++) ans *= 2;\n    cout << ans.n << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 1'000'000'007, INV2 = 500'000'004;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    vector<vector<int>> f(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            f[i][j] = a[i] > a[j];\n    for (int i = 0; i < q; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        for (int j = 0; j < n; ++j) {\n            if (j != x && j != y) {\n                int v = 1LL * (f[x][j] + f[y][j]) * INV2 % P;\n                f[x][j] = f[y][j] = v;\n                v = 1LL * (f[j][x] + f[j][y]) * INV2 % P;\n                f[j][x] = f[j][y] = v;\n            }\n        }\n        int v = 1LL * (f[x][y] + f[y][x]) * INV2 % P;\n        f[x][y] = f[y][x] = v;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < i; ++j)\n            ans = (ans + f[j][i]) % P;\n    for (int i = 0; i < q; ++i)\n        ans = 2 * ans % P;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 3005;\nconst int mod = 1e9 + 7;\n#define sz(v) ((int)v.size())\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, q, a[MAXN];\nint l[MAXN], r[MAXN];\n\nstruct ds{\n\tint val[MAXN];\n\tint lazy = 1;\n\tint lzinv = 1;\n\tvoid mul(int x){\n\t\tlazy *= 2;\n\t\tlzinv = (1ll * lzinv * ((mod + 1) / 2)) % mod;\n\t\tlazy %= mod;\n\t}\n\tvoid set(int x, int v){\n\t\tval[x] = 1ll * v * lzinv % mod;\n\t}\n\tint get(int x){\n\t\treturn 1ll * val[x] * lazy % mod;\n\t}\n}dp[MAXN];\n\nstruct rew{\n\tint x, y, z;\n};\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i=1; i<=n; i++) cin >> a[i];\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<i; j++) dp[i].set(j, 1);\n\t}\n\tfor(int i=0; i<q; i++){\n\t\tcin >> l[i] >> r[i];\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(int i=q-1; i>=0; i--){\n\t\tvector<rew> rewr;\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tif(l[i] == j){\n\t\t\t\tfor(int k=1; k<=n; k++){\n\t\t\t\t\tif(r[i] == k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[k].get(j)});\n\t\t\t\t\t}\n\t\t\t\t\telse if(j != k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[r[i]].get(k)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(r[i] == j){\n\t\t\t\tfor(int k=1; k<=n; k++){\n\t\t\t\t\tif(l[i] == k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[k].get(j)});\n\t\t\t\t\t}\n\t\t\t\t\telse if(j != k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[l[i]].get(k)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trewr.push_back({j, l[i], dp[j].get(l[i]) + dp[j].get(r[i])});\n\t\t\t\trewr.push_back({j, r[i], dp[j].get(l[i]) + dp[j].get(r[i])});\n\t\t\t}\n\t\t}\n\t\tfor(int j=1; j<=n; j++) dp[j].mul(2);\n\t\tfor(auto &j : rewr) dp[j.x].set(j.y, j.z);\n\t}\n\tlint ret = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tif(a[i] < a[j]) ret += dp[i].get(j);\n\t\t}\n\t}\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n  }\n  public:\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    inline int prod (int a, int b) const {\n      return (long long)a * b % md;\n    }\n    template <typename... Args>\n    inline int prod (Args... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  int inv2 = fld.inv(2);\n  int coeff = fld.pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      a = b = fld.prod(a, inv2);\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll p = 1e9+7;\nconst ll inv2 = (p+1)/2;\n\nll dp[3][3005][3005], n, q, a[3005];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = i+1; j < n; ++j) {\n\t\t\tif (a[i] == a[j])\n\t\t\t\tdp[1][i][j] = 1;\n\t\t\telse {\n\t\t\t\tdp[0][i][j] = (a[i] < a[j]);\n\t\t\t\tdp[2][i][j] = (a[i] > a[j]);\n\t\t\t}\n\t\t}\n\n\tfor (int k = 0; k < q; ++k) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif (x > y)\n\t\t\tswap(x, y);\n\t\tx--; y--;\n\t\tvector<ll> vx[3], vy[3];\n\t\tvx[0].resize(n);\n\t\tvx[1].resize(n);\n\t\tvx[2].resize(n);\n\t\tvy[0].resize(n);\n\t\tvy[1].resize(n);\n\t\tvy[2].resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i < x) {\n\t\t\t\tvx[0][i] = (dp[0][i][x] + dp[0][i][y])%p;\n\t\t\t\tvy[0][i] = (dp[0][i][y] + dp[0][i][x])%p;\n\t\t\t\tvx[1][i] = (dp[1][i][x] + dp[1][i][y])%p;\n\t\t\t\tvy[1][i] = (dp[1][i][y] + dp[1][i][x])%p;\n\t\t\t\tvx[2][i] = (dp[2][i][x] + dp[2][i][y])%p;\n\t\t\t\tvy[2][i] = (dp[2][i][y] + dp[2][i][x])%p;\n\t\t\t} if (x < i && i < y) {\n\t\t\t\tvx[0][i] = (dp[0][x][i] + dp[2][i][y])%p;\n\t\t\t\tvy[0][i] = (dp[0][i][y] + dp[2][x][i])%p;\n\t\t\t\tvx[1][i] = (dp[1][x][i] + dp[1][i][y])%p;\n\t\t\t\tvy[1][i] = (dp[1][i][y] + dp[1][x][i])%p;\n\t\t\t\tvx[2][i] = (dp[2][x][i] + dp[0][i][y])%p;\n\t\t\t\tvy[2][i] = (dp[2][i][y] + dp[0][x][i])%p;\n\t\t\t} if (i > y) {\n\t\t\t\tvx[0][i] = (dp[0][x][i] + dp[0][y][i])%p;\n\t\t\t\tvy[0][i] = (dp[0][x][i] + dp[0][y][i])%p;\n\t\t\t\tvx[1][i] = (dp[1][x][i] + dp[1][y][i])%p;\n\t\t\t\tvy[1][i] = (dp[1][x][i] + dp[1][y][i])%p;\n\t\t\t\tvx[2][i] = (dp[2][x][i] + dp[2][y][i])%p;\n\t\t\t\tvy[2][i] = (dp[2][y][i] + dp[2][x][i])%p;\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (i == x || i == y)\n\t\t\t\t\tcontinue;\n\t\t\t\t// cout << k << ' ' << i << ' ' << vx[k][i] << ' ' << vy[k][i] << endl;\n\t\t\t\tif (i < x)\n\t\t\t\t\tdp[k][i][x] = vx[k][i]*inv2%p;\n\t\t\t\telse\n\t\t\t\t\tdp[k][x][i] = vx[k][i]*inv2%p;\n\t\t\t\tif (i < y)\n\t\t\t\t\tdp[k][i][y] = vy[k][i]*inv2%p;\n\t\t\t\telse\n\t\t\t\t\tdp[k][y][i] = vy[k][i]*inv2%p;\n\t\t\t}\n\t\t}\n\n\t\tll r = dp[0][x][y] + dp[2][x][y];\n\t\tdp[0][x][y] = dp[2][x][y] = r*inv2%p;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = i+1; j < n; ++j) {\n\t\t\tans = (ans + dp[2][i][j])%p;\n\t\t\t// cout << i << ' ' << j << ' ' << dp[0][i][j] + dp[1][i][j] + dp[2][i][j] << endl;\n\t\t}\n\tfor (int i = 0; i < q; ++i)\n\t\tans = ans*2%p;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=3e3+5;\nint a[N],g[N][N],f[N][N],mod=1e9+7;\nconst ll inv2=mod+1>>1;\nint main(){\n\tri n,q,i,j,x,y,power,ans;\n\tgi(n);gi(q);\n\tfor(i=1;i<=n;++i) gi(a[i]);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tg[i][j]=a[i]>a[j];\n\tpower=1;\n\twhile(q--){\n\t\tpower=power*2%mod;\n\t\tgi(x);gi(y);\n\t\tfor(j=1;j<=n;++j){\n\t\t\tif(j!=y) // i = x j != y\n\t\t\t\tf[x][j]=(g[x][j]+g[y][j])*inv2%mod;\n\t\t\tif(j!=x) // i = y j != x\n\t\t\t\tf[y][j]=(g[y][j]+g[x][j])*inv2%mod;\n\t\t}\n\t\tfor(i=1;i<=n;++i){\n\t\t\tif(i!=x) // i != x j = y\n\t\t\t\tf[i][y]=(g[i][y]+g[i][x])*inv2%mod;\n\t\t\tif(i!=y) // i != y j = x\n\t\t\t\tf[i][x]=(g[i][x]+g[i][y])*inv2%mod; \n\t\t}\n\t\t// i = x j = y\n\t\tf[x][y]=(g[x][y]+g[y][x])*inv2%mod;\n\t\t// i = y j = x\n\t\tf[y][x]=(g[y][x]+g[x][y])*inv2%mod;\n\t\t\n\t\tfor(j=1;j<=n;++j){\n\t\t\tif(j!=y) // i = x j != y\n\t\t\t\tg[x][j]=f[x][j];\n\t\t\tif(j!=x) // i = y j != x\n\t\t\t\tg[y][j]=f[y][j];\n\t\t}\n\t\tfor(i=1;i<=n;++i){\n\t\t\tif(i!=x) // i != x j = y\n\t\t\t\tg[i][y]=f[i][y];\n\t\t\tif(i!=y) // i != y j = x\n\t\t\t\tg[i][x]=f[i][x]; \n\t\t}\n\t\t// i = x j = y\n\t\tg[x][y]=f[x][y];\n\t\t// i = y j = x\n\t\tg[y][x]=f[y][x];\n\t}\n\tans=0;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tans=(ans+(ll)g[i][j]*power)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int md = 1e9 + 7;\n\nint mul(int a, int b) {\n  return ((ll)a * b) % md;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\nconst int N = 500;\n\nint dp[N][N][N][2];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, q;\n  cin >> n >> q;\n  vector <int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  vector <pair <int, int>> op(q);\n  for (int i = 0; i < q; ++i) {\n    cin >> op[i].first >> op[i].second;\n    --op[i].first, --op[i].second;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      dp[q][i][j][0] = 1;\n    } \n  }\n  for (int t = q - 1; t >= 0; --t) {\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        for (int f = 0; f <= 1; ++f) {\n          add(dp[t][i][j][f], dp[t + 1][i][j][f]);\n          int go_i = i, go_j = j;\n          if (i == op[t].first || i == op[t].second) go_i = op[t].first ^ op[t].second ^ i;\n          if (j == op[t].first || j == op[t].second) go_j = op[t].first ^ op[t].second ^ j;\n          int go_f = f;\n          if (go_i > go_j) {\n            swap(go_i, go_j);\n            go_f ^= 1;\n          }\n          add(dp[t][i][j][f], dp[t + 1][go_i][go_j][go_f]);\n        }\n      } \n    }\n  } \n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (a[i] > a[j]) {\n        add(ans, dp[0][i][j][0]);\n      } else if (a[i] < a[j]) {\n        add(ans, dp[0][i][j][1]);\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\nusing namespace std;\nconst int nmax=3005;\nconst long long mod=1000*1000*1000+7;\nlong long dp[nmax][nmax],lzy[nmax][nmax],old[nmax][nmax];\nint a[nmax],X[nmax],Y[nmax];\nlong long inv2,I2,ans,p2;\nint n,i,j,q,x,y;\nlong long mu(long long x,long long y)\n{\n    return (1LL*x*y)%mod;\n}\nint main()\n{\n    //freopen(\"data.in\",\"r\",stdin);\n    cin>>n>>q;\n    for(i=1;i<=n;i++)\n        cin>>a[i];\n    for(i=1;i<=n;i++)\n        for(j=i+1;j<=n;j++)\n           dp[i][j]=1;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n          lzy[i][j]=1;\n    inv2=(mod+1)/2;I2=inv2;\n    p2=1;\n    for(i=1;i<=q;i++)\n        cin>>X[i]>>Y[i];\n    for(int cnt=q;cnt>=1;cnt--)\n    {\n        x=X[cnt];y=Y[cnt];\n        for(i=1;i<=n;i++)\n        {\n            old[i][x]=(dp[i][x]*mu(lzy[i][x],p2))%mod;\n            old[x][i]=(dp[x][i]*mu(lzy[x][i],p2))%mod;\n            old[i][y]=(dp[i][y]*mu(lzy[i][y],p2))%mod;;\n            old[y][i]=(dp[y][i]*mu(lzy[y][i],p2))%mod;\n        }\n        for(i=1;i<=n;i++)\n        {\n            lzy[i][x]=I2;\n            lzy[x][i]=I2;\n            lzy[i][y]=I2;\n            lzy[y][i]=I2;\n        }\n        lzy[x][x]=lzy[y][y]=0;\n        for(i=1;i<=n;i++)\n        {\n            dp[i][x]=(old[i][y]+old[i][x])%mod;\n            dp[i][y]=(old[i][x]+old[i][y])%mod;\n            dp[x][i]=(old[y][i]+old[x][i])%mod;\n            dp[y][i]=(old[x][i]+old[y][i])%mod;\n        }\n        dp[x][y]=(old[x][y]+old[y][x])%mod;\n        dp[y][x]=(old[x][y]+old[y][x])%mod;\n        dp[x][x]=dp[y][y]=0;\n        p2=(p2+p2)%mod;\n        I2=(I2*inv2)%mod;\n    }\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n          if(a[i]>a[j])\n    {\n        ans+=((1LL*(dp[i][j]*p2)%mod)*lzy[i][j])%mod;\n        ans%=mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x(x % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nconst ll mod = 1e9 + 7;\nusing mint = math::Modint<mod>;\n\nint main() {\n    ll n, q;\n    std::cin >> n >> q;\n    vec<ll> a(n);\n    for (ll &e : a) std::cin>> e;\n    vec<pll> xy(q);\n    for (auto &&e : xy) {\n        ll x, y;\n        std::cin >> x >> y;\n        x--; y--;\n        if (y < x) std::swap(x, y);\n        e = pll(x, y);\n    }\n    \n    auto poss = make_v<mint>(mint(0), n, n);\n    for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) if (a[i] > a[j]) poss[i][j] = 1;\n    auto inv2 = mint(2).inv();\n    \n    for (auto &&e : xy) {\n        ll x, y;\n        std::tie(x, y) = e;\n        for (ll i = 0; i < n; i++) {\n            if (i == y) continue;\n            if (i != x) {\n                auto a = poss[i][x];\n                auto b = poss[i][y];\n                auto nv = (a + b) * inv2;\n                poss[i][x] = poss[i][y] = nv;\n            } else {\n                for (ll j = 0; j < n; j++) if (j != x && j != y) {\n                    auto nv = (poss[x][j] + poss[y][j]) * inv2;\n                    poss[x][j] = poss[y][j] = nv;\n                }\n                auto nv = (poss[x][y] + poss[y][x]) * inv2;\n                poss[x][y] = poss[y][x] = nv;\n            }\n        }\n    }\n\n    auto perm = math::pow(mint(2), q);\n    mint ans = 0;\n    for (ll i = 0; i < n; i++) for (ll j = i + 1; j < n; j++) ans += poss[i][j];\n    ans *= perm;\n    std::cout << ans.value() << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long double ldb ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 3e3 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1e9 + 7 ;\nconst db eps = 1e-10 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, q;\n\nll a[maxn], x[maxn], y[maxn];\n\nll f[maxn][maxn], ans;\n\nll inv = 5e8 + 4;\n\nsigned main()\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\trep(i, 1, n) scanf(\"%lld\", &a[i]);\n\trep(i, 1, q) scanf(\"%lld %lld\", &x[i], &y[i]);\n\trep(i, 1, n) rep(j, 1, n) f[i][j] = a[i] > a[j];\n\trep(i, 1, q)\n\t{\n\t\tll u = x[i], v = y[i];\n\t\tf[v][u] = f[u][v] = inv * (f[u][v] + f[v][u]) % mod;\n\t\trep(j, 1, n)\n\t\t{\n\t\t\tif(i == u || i == v)  continue;\n\t\t\tf[v][i] = f[u][i] = inv * (f[u][i] + f[v][i]) % mod;\n\t\t\tf[i][v] = f[i][u] = inv * (f[i][u] + f[i][v]) % mod;\n\t\t}\n\t}\n\trep(i, 1, n) rep(j, i + 1, n) (ans += f[i][j]) %= mod;\n\trep(i, 1, q) (ans *= 2) %= mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, ll> Pl;\nconst ll mod = (ll)1e9 + 7;\nconst int N = 3005;\n\nint n,q;\nint num[N];\nint a[N], b[N];\n\nll dp[N][N];\n\nll fac[N], facinv[N];\nll inv[N];\n\nll fp(ll x, ll k){\n    if(k == 0) return 1;\n    ll hf = fp(x, k/2);\n    return k % 2 ? hf * hf % mod * x % mod: hf * hf % mod;\n}\n\nint main(){\n    inv[1] = 1;\n    for(int i = 2; i < N; i++) inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n    fac[0] = 1;\n    for(int i = 1; i <= N-1; i++) fac[i] = fac[i-1] * i % mod;\n    facinv[N-1] = fp(fac[N-1], mod - 2);\n    for(int i = N-1 - 1; i >= 0; i--) facinv[i] = facinv[i+1] * (i+1) % mod;\n\n    cin >> n >> q;\n    for(int i = 0; i < n; i++) cin >> num[i];\n    for(int i = 0; i < q; i++) cin >> a[i] >> b[i], a[i]--, b[i]--;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            dp[i][j] = (num[i] > num[j]);\n        }\n    }\n    for(int i = 0; i < q; i++){\n        vector<Pl> upd;\n        for(int k = 0; k < n; k++){\n            if(k != a[i] && k != b[i]) {\n                upd.push_back({{a[i], k}, inv[2] * (dp[a[i]][k] + dp[b[i]][k]) % mod});\n                upd.push_back({{k, a[i]}, inv[2] * (dp[k][a[i]] + dp[k][b[i]]) % mod});\n            }\n            if(k != b[i] && k != a[i]){\n                upd.push_back({{b[i], k}, inv[2] * (dp[b[i]][k] + dp[a[i]][k]) % mod});\n                upd.push_back({{k, b[i]}, inv[2] * (dp[k][a[i]] + dp[k][b[i]]) % mod});\n            }\n        }\n        upd.push_back({{a[i], b[i]}, inv[2] * (dp[b[i]][a[i]] + dp[a[i]][b[i]]) % mod});\n        upd.push_back({{b[i], a[i]}, inv[2] * (dp[b[i]][a[i]] + dp[a[i]][b[i]]) % mod});\n        for(auto p : upd){\n            dp[p.first.first][p.first.second] = p.second;\n        }\n    }\n    ll res = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++){\n            res += dp[i][j];\n            res %= mod;\n        }\n    }\n    for(int i = 0; i < q; i++) res = (res * 2) % mod;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3003,mod=1e9+7,inv2=5e8+4;\nint n,m,Q,a[N],f[N][N];\nvoid add(int &x,int y){x=(x+y)%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)f[i][j]=a[i]<a[j]?1:0;\n\tfor(int T=1;T<=Q;T++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;i++)\n\t\tif(i!=x&&i!=y)\n\t\t{\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*inv2%mod;\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*inv2%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<i;j++)\n\tans=(ans+f[i][j])%mod;\n\tfor(int i=1;i<=Q;i++)ans=2ll*ans%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#define MAX_N 3005\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\n\n\nll mpow(ll x,ll n){\n    ll ret = 1;\n    while(n>0){\n        if((n&1)==1){\n            ret *= x;\n            ret %= mod;\n        }\n        x = (x*x)%mod;\n        n >>= 1;\n    }\n    return ret%mod;\n}\n\nll inv(ll x){\n    return mpow(x,mod-2);\n}\n\n\n\n\nint main(){\n    int N,Q;\n    ll A[MAX_N];\n    ll dp[2][MAX_N][MAX_N];\n    cin>>N>>Q;\n    for(int i = 0;i < N;i++){\n        cin >> A[i];\n    }\n    ll _2q = mpow(2,Q);\n    ll inv2 = inv(2);\n    for(int i = 0;i < N;i++){\n        for(int j = 0;j < N;j++){\n            if(A[i]>A[j]){dp[0][i][j]=dp[1][i][j]=1;}\n            else{dp[0][i][j]=dp[1][i][j]=0;}\n        }\n    }\n    for(int qqq = 0;qqq < Q;qqq++){\n        int x,y;cin>>x>>y;\n        x--,y--;\n        for(int i = 0;i < N;i++){\n            if(i!=x&&i!=y){\n                dp[1][x][i]=(dp[0][x][i]*inv2+dp[0][y][i]*inv2)%mod;\n                dp[1][i][x]=(dp[0][i][x]*inv2+dp[0][i][y]*inv2)%mod;\n                dp[1][y][i]=(dp[0][y][i]*inv2+dp[0][x][i]*inv2)%mod;\n                dp[1][i][y]=(dp[0][i][y]*inv2+dp[0][i][x]*inv2)%mod;\n            }\n        }\n        dp[1][x][y]=dp[1][y][x]=(dp[0][x][y]*inv2+dp[0][y][x]*inv2)%mod;\n        for(int i = 0;i < N;i++){\n            dp[0][i][x]=dp[1][i][x];\n            dp[0][i][y]=dp[1][i][y];\n            dp[0][x][i]=dp[1][x][i];\n            dp[0][y][i]=dp[1][y][i];\n        }\n        \n    }\n    ll ans = 0;\n\n    for(int i = 0;i < N;i++){\n        for(int j = i+1;j < N;j++){\n            ans += dp[0][i][j];\n            ans %= mod;\n//            cout<<(_2q*dp[0][i][j])%mod<<\" \";\n        }\n//        cout<<endl;\n    }\n    cout<<(ans*_2q)%mod<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm>  \nusing namespace std; \nconst int MAX_N = 3e3 + 5; \nconst int Mod = 1e9 + 7; \nint fpow(int x, int y) {\n\tint res = 1; \n\twhile (y) { \n\t\tif (y & 1) res = 1ll * res * x % Mod; \n\t\tx = 1ll * x * x % Mod; \n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nconst int inv = fpow(2, Mod - 2); \nint N, Q, a[MAX_N]; \nint f[MAX_N][MAX_N]; \nint main () { \n\tscanf(\"%d %d\", &N, &Q); \n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", a + i); \n\tfor (int i = 1; i <= N; i++) \n\t\tfor (int j = 1; j <= N; j++) f[i][j] = a[i] < a[j]; \n\tfor (int i = 1; i <= Q; i++) { \n\t\tint x, y; scanf(\"%d %d\", &x, &y); \n\t\tf[x][y] = f[y][x] = 1ll * (f[x][y] + f[y][x]) * inv % Mod; \n\t\tfor (int j = 1; j <= N; j++) { \n\t\t\tif (j == x || j == y) continue; \n\t\t\tf[x][j] = f[y][j] = 1ll * (f[x][j] + f[y][j]) * inv % Mod; \n\t\t\tf[j][x] = f[j][y] = 1ll * (f[j][x] + f[j][y]) * inv % Mod; \n\t\t} \n\t} \n\tint ans = 0; \n\tfor (int i = 1; i <= N; i++) \n\t\tfor (int j = 1; j < i; j++) \n\t\t\tans = (ans + f[i][j]) % Mod; \n\tprintf(\"%lld\\n\", 1ll * ans * fpow(2, Q) % Mod); \n    return 0;  \n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\n#define N 3002\nusing namespace std;\nconst int mod=1000000007;\nint n,q,i,j,a[N],f[N][N],x[N],y[N],p,inv,ans;\nint read()\n{\n\tchar c=getchar();\n\tint w=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c<='9'&&c>='0'){\n\t\tw=w*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn w;\n}\nint poww(int a,int b)\n{\n\tint ans=1,base=a;\n\twhile(b){\n\t\tif(b&1) ans=ans*base%mod;\n\t\tbase=base*base%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tn=read();q=read();\n\tp=poww(2,q),inv=poww(2,mod-2);\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tfor(i=1;i<=q;i++) x[i]=read(),y[i]=read();\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++) f[i][j]=(a[i]>a[j]);\n\t}\n\tfor(i=1;i<=q;i++){\n\t\tf[x[i]][y[i]]=f[y[i]][x[i]]=(f[x[i]][y[i]]+f[y[i]][x[i]])%mod*inv%mod;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(j==x[i]||j==y[i]) continue;\n\t\t\tf[x[i]][j]=f[y[i]][j]=(f[x[i]][j]+f[y[i]][j])%mod*inv%mod;\n\t\t\tf[j][x[i]]=f[j][y[i]]=(f[j][x[i]]+f[j][y[i]])%mod*inv%mod;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=i+1;j<=n;j++) ans=(ans+f[i][j])%mod;\n\t}\n\tans=ans*p%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 3000;\nconst int mo = 1e9 + 7;\nconst int inv2 = (mo + 1) >> 1;\n\nint fpm(int x, int y) {\n    int res = 1;\n    for(; y > 0; y >>= 1) {\n        if(y & 1)\n            res = 1ll * res * x % mo;\n        x = 1ll * x * x % mo;\n    }\n    return res;\n}\n\nvoid merge(int &a, int &b) {\n    int x = a = 1ll * a * inv2 % mo;\n    int y = b = 1ll * b * inv2 % mo;\n    a = (a + y) % mo;\n    b = (b + x) % mo;\n}\n\nint n, q;\nint a[N + 5];\nint dp[N + 5][N + 5];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n), read(q);\n    for(int i = 1; i <= n; ++i) read(a[i]);\n    for(int i = 1; i <= n; ++i) \n        for(int j = 1; j <= n; ++j) if(a[i] > a[j]) { dp[i][j] = 1; }\n\n    for(int i = 1; i <= q; ++i) {\n        static int x, y;\n        read(x), read(y);\n        if(x == y) continue;\n\n        for(int j = 1; j <= n; ++j) if((j ^ y) && (j ^ x)) {\n            merge(dp[x][j], dp[y][j]);\n            merge(dp[j][x], dp[j][y]);\n        }\n        merge(dp[x][y], dp[y][x]);\n    }\n\n    int ans = 0;\n    for(int i = 1; i <= n; ++i) \n        for(int j = i + 1; j <= n; ++j)\n            ans = (ans + dp[i][j]) % mo;\n\n    ans = 1ll * ans * fpm(2, q) % mo;\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\tfix(s+=s);\n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*iv%mod;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    rep(i,0,n) cin >> a[i];\n    const ll MOD = 1e9+7;\n    vector<vector<ll>> dp(n,vector<ll>(n));\n    vector<vector<int>> time(n,vector<int>(n));\n    vector<ll> pow2(q+1,1);\n    rep(i,0,q) pow2[i+1]=(2*pow2[i])%MOD;\n    rep(i,0,n) rep(j,0,n) {\n        if(a[i]>a[j]) ++dp[i][j];\n    }\n    auto update = [&](int t, int a, int b) {\n        if(time[a][b]<t) {\n            dp[a][b]=(dp[a][b]*pow2[t-time[a][b]])%MOD;\n            time[a][b] = t;\n        }\n    };\n    rep(i,0,q) {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        rep(z,0,n) if(z!=x && z!=y) {\n            update(i, x, z);\n            update(i, y, z);\n            update(i, z, x);\n            update(i, z, y);\n            dp[x][z] = dp[y][z] = (dp[x][z]+dp[y][z])%MOD;\n            time[x][z] = time[y][z] = i+1;\n            dp[z][x] = dp[z][y] = (dp[z][x]+dp[z][y])%MOD;\n            time[z][x] = time[z][y] = i+1;\n        }\n        update(i, x, y);\n        update(i, y, x);\n        dp[x][y] = dp[y][x] = (dp[x][y]+dp[y][x])%MOD;\n        time[x][y] = time[y][x] = i+1;\n    }\n    ll sum = 0;\n    rep(i,0,n) rep(j,i+1,n) {\n        update(q,i,j); \n        sum=(sum+dp[i][j])%MOD;\n    }\n    cout<<sum<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#else\n#  define cerr __get_ce\n#endif\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\nmt19937 tw(9450189);\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\nconst int MOD = 1000000007;\n\nvoid add(int& a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\nint sum(int a, int b) {\n\tadd(a, b);\n\treturn a;\n}\n\nint mult(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint mpow(int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tret = mult(ret, a);\n\t\t}\n\t\ta = mult(a, a);\n\t\tb >>= 1;\n\t}\n\n\treturn ret;\n}\n\nint inv(int num) {\n\treturn mpow(num, MOD - 2);\n}\n\nvoid solve() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> inp;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint num;\n\t\tcin >> num;\n\t\tinp.push_back(num);\n\t}\n\tvector<pii> reqs;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (a > b) {\n\t\t\tswap(a, b);\n\t\t}\n\t\t--a; --b;\n\t\treqs.push_back({a, b});\n\t}\n\n\t/*\n\tvector<int> order(n);\n\tiota(order.begin(), order.end(), 0);\n\tvector<vector<int>> cnt(n, vector<int>(n));\n\n\tint ans0 = 0;\n\n\tfunction<void(int)> rec = [&](int pos) {\n\t\tif (pos == q) {\n\t\t\tfor (int num : order) {\n\t\t\t\tcerr << num + 1 << \" \";\n\t\t\t}\n\t\t\tcerr << endl;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\tif (order[i] < order[j]) {\n\t\t\t\t\t\tcnt[order[i]][order[j]]++;\n\t\t\t\t\t}\n\t\t\t\t\tif (inp[order[i]] > inp[order[j]]) {\n\t\t\t\t\t\t++ans0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\trec(pos + 1);\n\t\tswap(order[reqs[pos].ff], order[reqs[pos].ss]);\n\t\trec(pos + 1);\n\t\tswap(order[reqs[pos].ff], order[reqs[pos].ss]);\n\t};\n\n\trec(0);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tcerr << cnt[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\t*/\n\tvector<vector<int>> matr(n, vector<int>(n, 1));\n\tint inv2 = inv(2);\n\tint inv4 = mult(inv2, inv2);\n\tint tot = 1;\n\n\tfor (int i = q - 1; i >= 0; --i) {\n\t\tint a, b;\n\t\ttie(a, b) = reqs[i];\n\t\tfor (int j = a + 1; j < b; ++j) {\n\t\t\tint tmp1 = matr[a][j];\n\t\t\tint tmp2 = matr[j][b];\n\t\t\tmatr[a][j] = mult(sum(tmp1, sum(1, MOD - tmp2)), inv2);\n\t\t\tmatr[j][b] = mult(sum(tmp2, sum(1, MOD - tmp1)), inv2);\n\t\t}\n\t\tfor (int j = b + 1; j < n; ++j) {\n\t\t\tint tmp1 = matr[a][j];\n\t\t\tint tmp2 = matr[b][j];\n\t\t\tmatr[a][j] = mult(sum(tmp1, tmp2), inv2);\n\t\t\tmatr[b][j] = matr[a][j];\n\t\t}\n\t\tfor (int j = 0; j < a; ++j) {\n\t\t\tint tmp1 = matr[j][a];\n\t\t\tint tmp2 = matr[j][b];\n\t\t\tmatr[j][a] = mult(sum(tmp1, tmp2), inv2);\n\t\t\tmatr[j][b] = matr[j][a];\n\t\t}\n\t\tmatr[a][b] = inv2;\n\t\ttot = mult(tot, 2);\n\t}\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tmatr[i][j] = mult(matr[i][j], tot);\n\t\t\t// cerr << matr[i][j] << \" \";\n\t\t\tif (inp[i] > inp[j]) {\n\t\t\t\tadd(ans, matr[i][j]);\n\t\t\t} else if (inp[i] < inp[j]) {\n\t\t\t\tadd(ans, sum(tot, MOD - matr[i][j]));\n\t\t\t}\n\t\t}\n\t\t// cerr << endl;\n\t}\n\n\tcout << ans << \"\\n\";\n\t// cerr << ans0 << endl;\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\t\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=3007;\nconst ll mod=1000*1000*1000+7;\n\nint n, q;\n\nll tab[nax];\n\nint ost[nax][nax];\nll dp[nax][nax];\n\nll wyn;\n\npii zm[nax];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint czas;\nll pot[nax];\n\nvoid rel(int a, int b)\n{\n\tdp[a][b]=(dp[a][b]*pot[czas-ost[a][b]])%mod;\n\tost[a][b]=czas;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tfor (int h=1; h<=q; h++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tif (a>b)\n\t\t\tswap(a, b);\n\t\tzm[h]={a, b};\n\t}\n\tpot[0]=1;\n\tfor (int i=1; i<=q; i++)\n\t\tpot[i]=(pot[i-1]*2)%mod;\n\treverse(zm+1, zm+1+q);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<i; j++)\n\t\t\tdp[i][j]=1;\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tint a=zm[i].first;\n\t\tint b=zm[i].second;\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (j==a || j==b)\n\t\t\t\tcontinue;\n\t\t\tczas=i-1;\n\t\t\trel(j, a);\n\t\t\trel(j, b);\n\t\t\trel(a, j);\n\t\t\trel(b, j);\n\t\t\tll x=dp[j][a];\n\t\t\tll y=dp[j][b];\n\t\t\tdp[j][a]=dp[j][b]=(x+y)%mod;\n\t\t\tx=dp[a][j];\n\t\t\ty=dp[b][j];\n\t\t\tdp[a][j]=dp[b][j]=(x+y)%mod;\n\t\t\tost[a][j]=ost[b][j]=ost[j][a]=ost[j][b]=i;\n\t\t}\n\t\tczas=i-1;\n\t\trel(a, b);\n\t\trel(b, a);\n\t\tdp[a][b]=dp[b][a]=(dp[a][b]+dp[b][a])%mod;\n\t\tost[a][b]=ost[b][a]=i;\n\t}\n\tczas=q;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\trel(i, j);\n\t\t\trel(j, i);\n\t\t\t//~ debug() << i << \" \" << j << \"   \" << dp[i][j] << \" \" << dp[j][i];\n\t\t\tif (tab[i]<tab[j])\n\t\t\t\tdod(wyn, dp[i][j]);\n\t\t\tif (tab[i]>tab[j])\n\t\t\t\tdod(wyn, dp[j][i]);\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(0) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTIOn TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 3e3 + 10, K = 1e2 + 10, B = 1000, oo = 1e18, M = 1e9 + 7, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2, EPS = 1e-9;\n\n\nint dp[N][N], used[N], pw[N];\nvpi flex;\n\nvoid inc(int a, int b, int v)\n{\n    flex.push_back(mp(a * N + b, v));\n}\n\n\nint MOD(int v)\n{\n    v %= M;\n    if (v < 0)\n        v += M;\n\n    return v;\n}\n\n\nvoid smain() {\n    pw[0] = 1;\n    for (int i = 1; i < N; ++i)\n        pw[i] = MOD(pw[i - 1] * 2);\n\n    int n, q;\n    cin >> n >> q;\n\n    vi kek(n);\n    for (int i = 0; i < n; ++i)\n        cin >> kek[i];\n\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n        {\n            if (kek[i] < kek[j])\n                dp[i][j] = 1;\n            else if (kek[i] > kek[j])\n                dp[j][i] = 1;\n        }\n\n    fill(used, used + N, -1);\n\n\n    for (int i = 0; i < q; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        flex.clear();\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            dp[a][j] = MOD(dp[a][j] * pw[i - max(used[a], used[j]) - 1]);\n            dp[b][j] = MOD(dp[b][j] * pw[i - max(used[b], used[j]) - 1]);\n            dp[j][a] = MOD(dp[j][a] * pw[i - max(used[a], used[j]) - 1]);\n            dp[j][b] = MOD(dp[j][b] * pw[i - max(used[b], used[j]) - 1]);\n        }\n\n        dp[a][b] = MOD(dp[a][b] * pw[i - max(used[a], used[b]) - 1]);\n        dp[b][a] = MOD(dp[b][a] * pw[i - max(used[a], used[b]) - 1]);\n        used[a] = used[b] = i;\n\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            inc(a, j, dp[b][j]);\n            inc(b, j, dp[a][j]);\n            inc(j, a, dp[j][b]);\n            inc(j, b, dp[j][a]);\n        }\n\n        inc(a, b, dp[b][a]);\n        inc(b, a, dp[a][b]);\n\n\n        for (auto p : flex)\n        {\n            int a, b, v;\n            tie(a, v) = p;\n\n            b = a % N;\n            a /= N;\n            dp[a][b] = MOD(dp[a][b] + v);\n        }\n    }\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            dp[i][j] = MOD(dp[i][j] * pw[q - max(used[i], used[j]) - 1]);\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            ans = MOD(ans + dp[j][i]);\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  vvl dp = VV(n+1, n+1, 1, ll);\n  vvl rev = VV(n+1, n+1, 1, ll);\n  vll ml(n+1, 1);\n  vll mlrev(n+1, 1);\n\n  for(auto v:query){\n    vvl tmp; //i, j, flip or not, num\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    tmp.push_back(vll{x, y, 1, dp[x][y]});\n    tmp.push_back(vll{x, y, 0, rev[x][y]});\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      /*\n      if(i<x){\n        tmp.push_back(vll{i, x, 1, rev[i][y]});\n        tmp.push_back(vll{i, x, 0, dp[i][y]});\n      }else if(y<i){\n        tmp.push_back(vll{x, i, 1, rev[y][i]});\n        tmp.push_back(vll{x, i, 0, dp[y][i]});\n      }else{\n        tmp.push_back(vll{x, i, 1, rev[i][y]});\n        tmp.push_back(vll{x, i, 0, dp[i][y]});\n      }\n      */\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      /*\n      if(y<i){\n        tmp.push_back(vll{y, i, 1, rev[x][i]});\n        tmp.push_back(vll{y, i, 0, dp[x][i]});\n      }else if(i<x){\n        tmp.push_back(vll{i, y, 1, rev[i][x]});\n        tmp.push_back(vll{i, y, 0, dp[i][x]});\n      }else{\n        tmp.push_back(vll{i, y, 1, rev[x][i]});\n        tmp.push_back(vll{i, y, 0, dp[x][i]});\n      }\n      */\n    }\n    for(auto ad:tmp){\n      if(ad[2]==1) rev[ad[0]][ad[1]] = (rev[ad[0]][ad[1]]+ad[3])%P;\n      else dp[ad[0]][ad[1]] = (dp[ad[0]][ad[1]]+ad[3])%P;\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(a[i]<a[j]) ans = (ans + rev[i][j])%P;\n      if(a[i]>a[j]) ans = (ans + dp[i][j])%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, Q;\n\tcin >> N >> Q;\n\tvector<ll> A(N + 1);\n\trepn(i, N) cin >> A[i];\n\n\tvector<ll> X(Q + 1), Y(Q + 1);\n\trepn(i, Q) cin >> X[i] >> Y[i];\n\n\tvector<vector<mint>> dp(N + 1, vector<mint>(N + 1,0));\n\tvector<vector<ll>> up(N + 1, vector<ll>(N + 1, 0));\n\n\trepn(i, N)repn(j, N) {\n\t\tif (A[i] > A[j]) { dp[i][j] = 1; }\n\t}\n\t\n\trepn(q, Q) {\n\t\tmap<pair<ll, ll>, mint> mp;\n\t\tll x = X[q];\n\t\tll y = Y[q];\n\n\t\trepn(i, N) {\n\t\t\tif (i == x || i == y) { continue; }\n\n\t\t\tmp[{x, i}] = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tmp[{x, i}] += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tmp[{y, i}] = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tmp[{y, i}] += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tmp[{i, x}] = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tmp[{i, x}] += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tmp[{i, y}] = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tmp[{i, y}] += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tup[x][i] = q;\n\t\t\tup[y][i] = q;\n\t\t\tup[i][x] = q;\n\t\t\tup[i][y] = q;\n\n\t\t}\n\n\t\tmp[{x, y}] = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tmp[{x, y}] += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tmp[{y, x}] = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tmp[{y, x}] += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tup[x][y] = q;\n\t\tup[y][x] = q;\n\n\t\tfor (auto p : mp) {\n\t\t\tdp[p.first.first][p.first.second] = p.second;\n\t\t}\n\n\t\trepn(i, N)repn(j, N) {\n\t\t\t//cout << i << \" \" << j << \" \" << up[i][j]<<dp[i][j] << endl;\n\t\t}\n\n\t}\n\n\tmint ans = 0;\n\trepn(i, N)repn(j, N) {\n\t\tdp[i][j] *= ((mint)2 ^ (Q - up[i][j]));\n\t\tif (j > i) { ans += dp[i][j]; }\n\t}\n\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(__int128 x) {\n\tif (x == 0) { fast_print('0'); return; }\n\tif (x < 0) {\n\t\tfast_print('-');\n\t\tx = -x;\n\t}\n\t__int128 p = 1;\n\twhile (x / (p * 10)) p *= 10;\n\twhile (p) {\n\t\t__int128 symb = x / p;\n\t\tfast_print((int)symb);\n\t\tx -= p * symb;\n\t\tp /= 10;\n\t}\n};\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 1e9 + 7;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tif (p == 0) return 1;\t\n\t\tif (p & 1) {\n\t\t\treturn Ring(value).pow(p - 1) * value;\n\t\t} else {\n\t\t\tRing sub = Ring(value).pow(p / 2);\n\t\t\treturn sub * sub;\n\t\t}\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nint n, q;\nvector<int> a;\n\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, q;\n\ta.resize(n);\n\tscan a;\n\tvector<vector<num>> p(n, vector<num>(n));\n\tvector<vector<num>> pref(n, vector<num>(n));\n\tf(i, n)\n\t\tf(j, n)\n\t\t\tp[i][j] = (a[i] < a[j]);\n\n\tnum I = num(2).inv();\n\tf(i, q) {\n\t\tint x, y;\n\t\tscan x, y;\n\t\tx--;y--;\n\t\tf(z, n) {\n\t\t\tpref[x][z] = p[x][z];\n\t\t\tpref[z][x] = p[z][x];\n\n\t\t\tpref[z][y] = p[z][y];\n\t\t\tpref[y][z] = p[y][z];\n\t\t}\n\t\tp[x][y] = p[y][x] = (pref[x][y] + pref[y][x]) * I;\n\t\tf(z, n) {\n\t\t\tif (z == x) continue;\n\t\t\tif (z == y) continue;\n\t\t\tp[z][x] = (pref[z][x] + pref[z][y]) * I;\n\t\t\tp[x][z] = (pref[x][z] + pref[y][z]) * I;\n\n\t\t\tp[z][y] = (pref[z][y] + pref[z][x]) * I;\n\t\t\tp[y][z] = (pref[y][z] + pref[x][z]) * I;\n\t\t}\n\t}\n\tnum rez = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\trez += p[j][i];\n\tprint rez * num(2).pow(q);\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nusing mint=ModInt<1000000007>;\n\nconst int N=3010;\nconst mint inv2=mint(2).inv();\nint n;\nmint dp[N][N];\nvoid go( int x, int y ) {\n    auto to=[&]( int i ) {\n        if ( i==x ) return y;\n        if ( i==y ) return x;\n        return i;\n    };\n    vector<tuple<int,int,mint>> v;\n    auto push=[&]( int r, int c ) {\n        if ( r<c ) v.PB({r,c,dp[r][c]});\n    };\n    REP1(i,1,n) {\n        push(i,x);\n        push(i,y);\n        push(x,i);\n        push(y,i);\n    }\n    sort_uniq(v);\n    for ( auto i:v ) {\n        int r=get<0>(i),c=get<1>(i);\n        mint t=get<2>(i);\n        dp[r][c]-=t*inv2;\n        int nr=to(r),nc=to(c);\n        mint nt=t;\n        if ( nr>nc ) {\n            swap(nr,nc);\n            nt=mint(1)-nt;\n        }\n        dp[nr][nc]+=nt*inv2;\n    }\n}\n\nint q,a[N],x[N],y[N];\n\nmint run() {\n    REP(i,q) go(x[i],y[i]);\n    mint ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) ans+=dp[i][j];\n    ans*=mint(2).pow(q);\n    return ans;\n}\n\nvoid main() {\n    R(n,q);\n    REP1(i,1,n) R(a[i]);\n    REP(i,q) R(x[i],y[i]);\n    mint ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) dp[i][j]=(a[i]>a[j]);\n    ans+=run();\n    memset(dp,0,sizeof(dp));\n    REP1(i,1,n) REP1(j,i+1,n) dp[i][j]=(a[i]>=a[j]);\n    ans+=run();\n    mint cnt=0;\n    REP1(i,1,n) REP1(j,i+1,n) cnt+=(a[i]==a[j]);\n    cnt*=mint(2).pow(q);\n    ans-=cnt;\n    ans*=inv2;\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define N 3009\nusing namespace std;\n\nint n,m,a[N],f[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j,x,y,tmp;\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=1; j<=n; j++) f[i][j]=(a[i]<a[j]);\n\tint t=1;\n\twhile (m--){\n\t\tt=t*2%mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor (i=1; i<=n; i++) if (i!=x && i!=y){\n\t\t\ttmp=(f[x][i]+f[y][i])%mod; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\t\tf[x][i]=f[y][i]=tmp%mod;\n\t\t\ttmp=(f[i][x]+f[i][y])%mod; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\t\tf[i][x]=f[i][y]=tmp%mod;\n\t\t}\n\t\ttmp=(f[x][y]+f[y][x])%mod; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\tf[x][y]=f[y][x]=tmp%mod;\n\t}\n\tint ans=0;\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=1; j<i; j++) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",(ll)ans*t%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define INF (1ll<<60)\n\n\nlong long M = 1000000007;\n\nint main(int argc, char const *argv[]) {\n    int n,q;cin>>n>>q;\n    long long inv2 = M/2 + 1;\n    vector<int> a(n);\n    for(int i=0;i<n;++i)cin>>a[i];\n    vector<vector<long long>> dp(n,vector<long long>(n));\n    for(int i=0;i<n;++i){\n        for(int j=0;j<n;++j){\n            if(a[i]<a[j])dp[i][j]=1;\n        }\n    }\n    for(int qq=0;qq<q;++qq){\n        int s,t;cin>>s>>t;\n        s--;\n        t--;\n        for(int i=0;i<n;++i){\n            if(i!=s && i!=t){\n                long long tmp = dp[i][t] + dp[i][s];\n                tmp *= inv2;\n                tmp %= M;\n                dp[i][t] = tmp;\n                dp[i][s] = tmp;\n                tmp = dp[s][i] + dp[t][i];\n                tmp *= inv2;\n                tmp %= M;\n                dp[s][i] = tmp;\n                dp[t][i] = tmp;\n            }\n        }\n        // for(int i=0;i<n;++i){\n        //     for(int j=0;j<n;++j){\n        //         if(i!=s&&i!=t&&j!=s&&j!=t)dp[i][j]*=2;\n        //     }\n        // }\n        long long tmp = dp[s][t] + dp[t][s];\n        tmp *= inv2;\n        tmp %= M;\n        // cout<<tmp<<endl;\n        dp[s][t] = tmp;\n        dp[t][s] = tmp;\n    }\n    long long res = 0;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<i;++j)res=(res+dp[i][j])%M;\n    }\n    for(int i=0;i<q;++i)res = (res*2)%M;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1e9+7,inv2=(mod+1)/2;\nint n,q,a[4001],dp[4001][4001];\nint main() {\n\tcin>>n>>q; for(int i=1;i<=n;i++)cin>>a[i]; for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)dp[i][j]=(a[i]>a[j]);\n\tfor(int k=1,x,y;k<=q;k++) {\n\t\tcin>>x>>y; dp[x][y]=dp[y][x]=1ll*inv2*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int i=1;i<=n;i++) if(i!=x&&i!=y)dp[i][x]=dp[i][y]=1ll*inv2*(dp[i][x]+dp[i][y])%mod,dp[x][i]=dp[y][i]=1ll*inv2*(dp[x][i]+dp[y][i])%mod;\n\t}\n\tlong long ans=0; for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++)ans+=dp[i][j]; while(q--)ans=ans*2%mod;\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ttgl, null_type,less<ttgl>, rb_tree_tag,tree_order_statistics_node_update>*/\n \nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 3001;\nint n, q;\nint arr[mxN];\nttgl query[mxN];\nll dp_prev[mxN][mxN];\nll dp[mxN][mxN];\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>q;\n    owo(i, 0, n) {\n        cin>>arr[i];\n    }\n    int inv2 = modInv(2);\n    owo(i, 0, q) {\n        cin>>query[i].first>>query[i].second;\n        if(query[i].first>query[i].second)swap(query[i].first, query[i].second);\n        query[i].first--;\n        query[i].second--;\n    }\n    owo(i, 0, n) {\n        owo(j, 0, n) {\n            if(i==j)continue;\n            if(arr[i]>arr[j]) {\n                dp_prev[i][j] = 1;\n                dp[i][j] = 1;\n            }\n        }\n    }\n    owo(i, 0, q) {\n        int a = query[i].first;\n        int b = query[i].second;\n        owo(j, 0, n) {\n            if(j==a||j==b)continue;\n            dp[j][a] = (dp_prev[j][a]*inv2 + dp_prev[j][b]*inv2)%MOD;\n            dp[a][j] = (dp_prev[a][j]*inv2 + dp_prev[b][j]*inv2)%MOD;\n            dp[j][b] = (dp_prev[j][b]*inv2 + dp_prev[j][a]*inv2)%MOD;\n            dp[b][j] = (dp_prev[b][j]*inv2 + dp_prev[a][j]*inv2)%MOD;\n        }\n        dp[a][b] = (dp_prev[a][b]*inv2 + dp_prev[b][a]*inv2)%MOD;\n        dp[b][a] = dp[a][b];\n        owo(j, 0, n) {\n            dp_prev[j][a] = dp[j][a];\n            dp_prev[j][b] = dp[j][b];\n            dp_prev[a][j] = dp[a][j];\n            dp_prev[b][j] = dp[b][j];\n            \n        }\n    }\n    ll mul = binpow(2, q);\n    ll ans = 0;\n    owo(i, 0, n){\n        owo(j, i+1, n) {\n            ans= (ans + dp[i][j]);\n        }\n    }\n    ans = (ans*mul)%MOD;\n    cout<<ans<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 3005\n#define ll long long\nusing namespace std ;\n\nIL int gi(){\n    int data = 0 , m = 1; char ch = 0;\n    while(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n    if(ch == '-'){m = 0 ; ch = getchar() ; }\n    while(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n    return (m) ? data : -data ; \n}\n\n#define mod 1000000007\nIL int Pow(int ts , int js) {\n\tint al = 1 ;\n\twhile(js) {\n\t\tif(js & 1) al = 1ll * al * ts % mod ; js >>= 1 ;\n\t\tts = 1ll * ts * ts % mod ; \n\t}return al ;\n}\nint n , Q , A[_] , f[_][_] , Ans , inv2 ; \n\nint main() {\n\tn = gi() ; Q = gi() ;\n\tfor(int i = 1; i <= n; i ++) A[i] = gi() ;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++) f[i][j] = (A[i] > A[j]) ;\n\tint x , y ; inv2 = (mod + 1) >> 1 ; \n\tfor(int sq = 1 ; sq <= Q; sq ++) {\n\t\tx = gi() ; y = gi() ;\n\t\tfor(int i = 1; i <= n; i ++) if(i != x && i != y) f[x][i] = f[y][i] = 1ll * (f[x][i] + f[y][i]) * inv2 % mod ;\n\t\tfor(int i = 1; i <= n; i ++) if(i != x && i != y) f[i][x] = f[i][y] = 1ll * (f[i][x] + f[i][y]) * inv2 % mod ;\n\t\tint sum = f[x][y] + f[y][x] ;\n\t\tf[x][y] = f[y][x] = 1ll * sum * inv2 % mod ;\n\t}\n\tAns = 0 ;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = i + 1; j <= n; j ++) Ans = (Ans + f[i][j]) % mod ;\n\tprintf(\"%lld\\n\" , 1ll * Ans * Pow(2 , Q) % mod) ;\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int md = 1e9 + 7;\ninline void mad (int &a, int b) {\n  a += b; if (a >= md) a -= md;\n}\ninline void msb (int &a, int b) {\n  a -= b; if (a < 0) a += md;\n}\ninline int vad (int a, int b) {\n  mad(a, b); return a;\n}\ninline int vsb (int a, int b) {\n  msb(a, b); return a;\n}\ninline int mul (int a, int b) {\n  return (int)((long long)a * b % md);\n}\ninline int mow (int a, long long b) {\n  int res = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n  }\n  return res;\n}\ninline int inv (int a) {\n  a %= md;\n  if(a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t; swap(a, b);\n    u -= v * t; swap(u, v);\n  }\n  assert(b == 1);\n  if(u < 0) u += md;\n  return u;\n}\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  int inv2 = inv(2);\n  int coeff = mow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      mad(a, b);\n      a = b = mul(a, inv2);\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      dp[i][j] = mul(dp[i][j], coeff);\n      mad(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 3003;\nconst int MOD = 1e9 + 7;\nconst int INV2 = 500000004;\n\nint mul(int a, int b) {\n   return (a * b) % MOD; \n}\n\nint add(int a, int b) {\n   return (a + b) % MOD;\n}\n\nint n;\nint dp[N][N];\n\nvoid rec_dp(int x, int y) {\n   vector<pair<int, int>> torel;\n   for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n         for (int j = 0; j < n; j++) {\n            torel.push_back({i, j});\n         }\n      } else {\n         torel.push_back({i, x});\n         torel.push_back({i, y});  \n      }\n   }\n   vector<tuple<int, int, int>> rval;\n   for (auto t : torel) {\n      int i, j;\n      tie(i, j) = t;\n      if (i == j) {\n         rval.push_back(make_tuple(i, j, dp[i][j]));\n         continue;\n      }\n      if (i != x && i != y && j != x && j != y) {\n         rval.push_back(make_tuple(i, j, dp[i][j]));\n         continue;  \n      }\n      if (i == x && j == y) {\n         rval.push_back(make_tuple(i, j, mul(add(dp[i][j], dp[j][i]), INV2)));\n         continue;\n      }\n      if (i == y && j == x) {\n         rval.push_back(make_tuple(i, j, mul(add(dp[i][j], dp[j][i]), INV2)));\n         continue;\n      }\n      if (i == x) {\n         rval.push_back(make_tuple(i, j, mul(add(dp[i][j], dp[y][j]), INV2)));\n         continue;\n      }\n      if (i == y) {\n         rval.push_back(make_tuple(i, j, mul(add(dp[i][j], dp[x][j]), INV2)));\n         continue;\n      }\n      if (j == x) {\n         rval.push_back(make_tuple(i, j, mul(add(dp[i][j], dp[i][y]), INV2)));\n         continue;\n      }\n      if (j == y) {\n         rval.push_back(make_tuple(i, j, mul(add(dp[i][j], dp[i][x]), INV2)));\n         continue;\n      }\n      assert(false);\n   }\n   for (auto t : rval) {\n      int i, j, c;\n      tie(i, j, c) = t;\n      dp[i][j] = c;\n   }\n}\n\nsigned main() {\n   ios_base::sync_with_stdio(false);\n   cin.tie(0);\n\n   int q;\n   cin >> n >> q;\n   vector<int> a(n);\n   for (auto &t : a) {\n      cin >> t;\n   }\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n         dp[i][j] = (a[i] > a[j]); \n      }\n   }\n   for (int i = 0; i < q; i++) {\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      rec_dp(x, y);\n   }\n   int ans = 0;\n   for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n         ans = add(ans, dp[i][j]);\n      }\n   }\n   // for (int i = 0; i < n; i++) {\n   //    for (int j = 0; j < n; j++) {\n   //       cerr << mul(2, dp[pnt][i][j]) << ' ';\n   //    }\n   //    cerr << endl;\n   // }\n   for (int i = 0; i < q; i++) {\n      ans = mul(ans, 2);\n   }\n   cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 1);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 1) {\n            node[k] = (node[k] * lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1]*lazy[k])%P;\n                lazy[2*k+2] = (lazy[2*k+2]*lazy[k])%P;\n            }\n            lazy[k] = 1;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k]*x)%P;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1]+node[2*k+2])%P;\n        }\n    }\n\n    void adx(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            eval(k, l, r);\n        }else {\n            node[k] = (node[k]+x)%P;\n        }\n    }\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  LazySegmentTree dp(vector<ll>(n*n+1, 1));\n  LazySegmentTree rev(vector<ll>(n*n+1, 0));\n\n  for(auto v:query){\n    vvl tmp;//i, j, flip or not, num\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    ll adr = x*n+y;\n    tmp.push_back(vll{x, y, 1, dp.getsum(adr, adr+1)});\n    tmp.push_back(vll{x, y, 0, rev.getsum(adr, adr+1)});\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(i<x){\n        adr = i*n+y;\n        tmp.push_back(vll{i, x, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, x, 0, dp.getsum(adr, adr+1)});\n      }else if(y<i){\n        adr = y*n+i;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = i*n+y;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(y<i){\n        adr = x*n+i;\n        tmp.push_back(vll{y, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{y, i, 0, dp.getsum(adr, adr+1)});\n      }else if(i<x){\n        adr = i*n+x;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = x*n+i;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(auto ad:tmp){\n      ll adr = ad[0]*n+ad[1];\n      if(ad[2]==1) rev.adx(adr, adr+1, ad[3]);\n      else dp.adx(adr, adr+1, ad[3]);\n    }\n    //関係ないものは2倍\n    //xかyに関係するものはinv[2]を掛けておく\n    for(int i=0;i<n;i++){\n      if(i!=x&&i!=y){\n        dp.add(i*n+x, i*n+x+1, I);\n        dp.add(x*n+i, x*n+i+1, I);\n        rev.add(i*n+x, i*n+x+1, I);\n        rev.add(x*n+i, x*n+i+1, I);\n        dp.add(i*n+y, i*n+y+1, I);\n        dp.add(y*n+i, y*n+i+1, I);\n        rev.add(i*n+y, i*n+y+1, I);\n        rev.add(y*n+i, y*n+i+1, I);\n      }\n    }\n    dp.add(x*n+y, x*n+y+1, I);\n    dp.add(y*n+x, y*n+x+1, I);\n    rev.add(x*n+y, x*n+y+1, I);\n    rev.add(y*n+x, y*n+x+1, I);\n    dp.add(0, n*n+1, 2);\n    rev.add(0, n*n+1, 2);\n\n  }\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ll adr = i*n+j;\n      if(a[i]<a[j]) ans = (ans + rev.getsum(adr, adr+1))%P;\n      if(a[i]>a[j]) ans = (ans + dp.getsum(adr, adr+1))%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nlong long qpow(long long base,int tms)\n{\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nlong long inv2 = qpow(2,mod - 2);\nlong long dp[3050][3050];\nint N,Q;\nint seq[3050];\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i = 1;i <= N; ++ i)\n\t\tscanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= N; ++ i)\n\t\tfor(int j = 1;j <= N; ++ j)\n\t\t\tdp[i][j] = seq[i] > seq[j];\n\tlong long make_me_burn = qpow(2,Q);\n\twhile(Q --)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * inv2 % mod;\n\t\tfor(int i = 1;i <= N; ++ i)\n\t\t\tif(i != x && i != y)\n\t\t\t\tdp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * inv2 % mod,\n\t\t\t\tdp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * inv2 % mod;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 1;i <= N; ++ i)\n\t\tfor(int j = i + 1;j <= N; ++ j)\n\t\t\tans = ans + dp[i][j] * make_me_burn % mod,ans %= mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=3005;\nconst int mo=998244353;\nint n,Q,a[N],f[N][N],ans;\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) For(j,1,n) f[i][j]=(a[i]>a[j]);\n\tFor(i,1,Q){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tFor(p,1,n) if (p!=x&&p!=y){\n\t\t\tf[x][p]=f[y][p]=1ll*(f[x][p]+f[y][p])*(mo+1)/2%mo;\n\t\t\tf[p][x]=f[p][y]=1ll*(f[p][x]+f[p][y])*(mo+1)/2%mo;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*(mo+1)/2%mo;\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tans=(ans+f[i][j])%mo;\n\tFor(i,1,Q) ans=1ll*ans*2%mo;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N=3e3+5;\nconst int mod=1e9+7;\nconst int inv2=500000004;\nint n,x,y,q,ans,tmp=1,a[N],f[N][N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nint main() {\n\tIN(n),IN(q);\n\tfor(int i=1;i<=n;++i) IN(a[i]);\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) f[i][j]=(bool)(a[i]>a[j]);\n\tfor(int t=1;t<=q;++t) {\n\t\tIN(x),IN(y),\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%mod;\n\t\tfor(int i=1;i<=n;++i) if(i!=x&&i!=y)\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*inv2%mod,\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*inv2%mod;\n\t\ttmp=2ll*tmp%mod;\n\t}\n\tfor(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) ans=(ans+f[i][j])%mod;\n\tprintf(\"%d\\n\",1ll*ans*tmp%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,Q;\nint A[3030];\nll mo=1000000007;\n\nll P[3030][3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tFOR(i,N) cin>>A[i];\n\tFOR(i,N) FOR(j,N) P[i][j]=A[i]>A[j];\n\t\n\tFOR(j,Q) {\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tFOR(i,N) {\n\t\t\tif(i!=x && i!=y) {\n\t\t\t\tP[i][x]=P[i][y]=(P[i][x]+P[i][y])*((mo+1)/2)%mo;\n\t\t\t\tP[x][i]=P[y][i]=(P[x][i]+P[y][i])*((mo+1)/2)%mo;\n\t\t\t}\n\t\t}\n\t\tP[x][y]=P[y][x]=(P[x][y]+P[y][x])*((mo+1)/2)%mo;\n\t}\n\t\n\tll ret=0;\n\tFOR(i,N) FOR(j,i) ret+=P[j][i];\n\tret%=mo;\n\tFOR(i,Q) ret=ret*2%mo;\n\t\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pdi = pair<double, int>;\ntemplate <class T> using mat = vector<vector<T>>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\n\n#define each(i,v) for (auto i = begin(v); i != end(v); ++i)\n#define reach(i,v) for (auto i = rbegin(v); i != rend(v); ++i)\n#define urep(i,s,t) for (int i = (s); i <= (t); ++i)\n#define drep(i,s,t) for (int i = (s); i >= (t); --i)\n#define rep(i,n) urep(i, 0, (n)-1)\n#define rep1(i,n) urep(i, 1, (n))\n#define rrep(i,n) drep(i, (n)-1, 0)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define front fro\n#define back bac\n#define vct vector\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper(uint_fast8_t prec) {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout << fixed << setprecision(prec);\n#ifdef Local\n        auto print_atexit = []() { cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\"; };\n        atexit(print_atexit);\n#endif\n    }\n} setuppre_obj(10);\n\nnamespace std {\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> ostream& operator << (ostream& s, pair<T,U> p) { return s << p.fir << \" \" << p.sec; }\ntemplate <class T> ostream& operator << (ostream& s, vct<T> v) { each(i,v) { if(i != begin(v)) s << \" \"; s << *i; } return s; }\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\nconst auto add = [](auto &x, auto y) { x += y; };\nconst auto mul = [](auto &x, auto y) { x *= y; };\nconst auto lam_min = [](auto x, auto y) { return min(x, y); };\nconst auto lam_max = [](auto x, auto y) { return max(x, y); };\nconst auto chmax = [](auto &m, auto x) { if(m < x){ m = x; return true; } return false; };\nconst auto chmin = [](auto &m, auto x) { if(m > x){ m = x; return true; } return false; };\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binsr(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> T cmprs(T &v) {\n    T tmp = v, ret = v;\n    sort(all(tmp));\n    tmp.erase(unique(all(tmp)), end(tmp));\n    each(i,ret) *i = l_bnd(all(tmp),*i) - begin(tmp);\n    return ret;\n}\n\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2 - 1;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double gold = 1.618033988;\nconstexpr long double eps = 1e-15;\nconstexpr uint_fast64_t mod = 1e9 + 7;\n\nint n,Q;\ni64 up[1<<12][1<<12],dw[1<<12][1<<12];\nint last[1<<12][1<<12];\ni64 two[1<<12];\n\nvoid upd(int i,int j,int t) {\n    assert(i<j);\n    if(t==last[i][j]) return;\n    assert(t>last[i][j]);\n    up[i][j]=up[i][j]*two[t-1-last[i][j]]%mod;\n    dw[i][j]=dw[i][j]*two[t-1-last[i][j]]%mod;\n    last[i][j]=t;\n    return;\n}\n\nint main() {\n    cin>>n>>Q;\n    int a[1<<12];\n    for(int i=0; i<n; i++) cin>>a[i];\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            if(a[i]>a[j]) up[j][i]++;\n            if(a[j]>a[i]) dw[j][i]++;\n            last[j][i]=-1;\n        }\n    }\n\n    two[0]=1;\n    for(int i=0; i<Q; i++) two[i+1]=two[i]*2%mod;\n\n    for(int i=0; i<Q; i++) {\n        //u_map<pii,int> up_nx,dw_nx;\n        stack<pair<pii,int>> up_nx,dw_nx;\n        int x,y;\n        cin>>x>>y;\n        if(--x > --y) swap(x,y);\n\n        for(int j=0; j<x; j++) {\n            upd(j,y,i);\n            upd(j,x,i);\n            dw_nx.emp(mkp(j,y),dw[j][x]);\n            up_nx.emp(mkp(j,y),up[j][x]);\n            dw_nx.emp(mkp(j,x),dw[j][y]);\n            up_nx.emp(mkp(j,x),up[j][y]);\n        }\n        for(int j=y+1; j<n; j++) {\n            upd(x,j,i);\n            upd(y,j,i);\n            dw_nx.emp(mkp(y,j),dw[x][j]);\n            up_nx.emp(mkp(y,j),up[x][j]);\n            dw_nx.emp(mkp(x,j),dw[y][j]);\n            up_nx.emp(mkp(x,j),up[y][j]);\n        }\n        for(int j=x+1; j<y; j++) {\n            upd(j,y,i);\n            upd(x,j,i);\n            dw_nx.emp(mkp(j,y),up[x][j]);\n            up_nx.emp(mkp(j,y),dw[x][j]);\n            dw_nx.emp(mkp(x,j),up[j][y]);\n            up_nx.emp(mkp(x,j),dw[j][y]);\n        }\n        {\n            upd(x,y,i);\n            up_nx.emp(mkp(x,y),dw[x][y]);\n            dw_nx.emp(mkp(x,y),up[x][y]);\n        }\n        while(!up_nx.empty()) {\n            auto p=up_nx.top();\n            up_nx.pop();\n            (up[p.fir.fir][p.fir.sec]+=p.sec)%=mod;\n        }\n        while(!dw_nx.empty()) {\n            auto p=dw_nx.top();\n            dw_nx.pop();\n            (dw[p.fir.fir][p.fir.sec]+=p.sec)%=mod;\n        }\n    }\n\n    int ans=0;\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            upd(j,i,Q);\n            ans=(ans+dw[j][i])%mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3010;\nconst int MOD = 1e9 + 7;\nint n, q;\nint F[N][N], G[N], A[N], inv2 = (MOD + 1) / 2, sum = 1, res;\nint main()\n{\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++ i)\n        cin >> A[i];\n    for (int i = 1; i <= n; ++ i)\n        for (int j = 1; j <= n; ++ j)\n            if (A[i] < A[j]) F[i][j] = 1;\n    while (q --)\n    {\n        int a, b;\n        cin >> a >> b; sum = 2ll * sum % MOD;\n        for (int i = 1; i <= n; ++ i) if ((i != a) && (i != b))\n            F[a][i] = F[b][i] = 1ll * (F[a][i] + F[b][i]) * inv2 % MOD,\n            F[i][a] = F[i][b] = 1ll * (F[i][a] + F[i][b]) * inv2 % MOD;\n        F[a][b] = F[b][a] = 1ll * (F[a][b] + F[b][a]) * inv2 % MOD;\n    }\n    for (int i = 1; i <= n; ++ i)\n        for (int j = 1; j < i; ++ j)\n            res = (res + F[i][j]) % MOD;\n    cout << 1ll * sum * res % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7); //998244353LL;\n\n\nvoid solve()\n{\n\tll N, Q;\n\tcin >> N >> Q;\n\tvll A = cinv(N);\n\tauto XY = cinv2(Q);\n\tEACH(e, XY){\n\t\te.first--; e.second--;\n\t}\n\n\tvector<vector<mll>> C(N, vector<mll>(N));\n\n\tmll two = 2;\n\tmll twoQ = POW(two, Q);\n\n\tREP(i, N) REP(j, N){\n\t\tif (i == j) continue;\n\t\tif (A[i] > A[j]) C[i][j] = twoQ;\n\t}\n\n\tREP(i, Q){\n\t\tll X = XY[i].first;\n\t\tll Y = XY[i].second;\n\n\t\tC[X][Y] = C[Y][X] = (C[X][Y] + C[Y][X]) / 2;\n\t\tREP(j, N){\n\t\t\tif (j == X || j == Y) continue;\n\t\t\tC[X][j] = C[Y][j] = (C[X][j] + C[Y][j]) / 2;\n\t\t}\n\n\t\tREP(j, N){\n\t\t\tif (j == X || j == Y) continue;\n\t\t\tC[j][X] = C[j][Y] = (C[j][X] + C[j][Y]) / 2;\n\t\t}\n\t}\n\n\tmll ans = 0;\n\tREP(i, N-1){\n\t\tans += Sum(C[i], i+1, N-1);\n\t}\n\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007 \nusing namespace std;\nint n,q,ans;\nint x[3005],y[3005];\nint a[3005],two[3005];\nint dp[3005][3005][2],G[3005][3005][2];\nint f[4][3005],g[2];\n\nvoid up(int A,int B,int C,int D){\n\tif(G[A][B][C]==D) return;\n\tdp[A][B][C]=1ll*dp[A][B][C]*two[D-1-G[A][B][C]]%mod;\n\tG[A][B][C]=D; \n}\n\nvoid work(int id,int k){\n\tmemset(f,0,sizeof(f));\n\tfor(int t=1;t<=n;t++){\n\t\tif(t!=y[k]) up(x[k],t,id,k),f[0][t]=dp[x[k]][t][id];\n\t\tif(t!=x[k]) up(y[k],t,id,k),f[1][t]=dp[y[k]][t][id];\n\t\tif(t!=y[k]) up(t,x[k],id,k),f[2][t]=dp[t][x[k]][id];\n\t\tif(t!=x[k]) up(t,y[k],id,k),f[3][t]=dp[t][y[k]][id];\n\t}\n\tup(x[k],y[k],id,k),g[0]=dp[x[k]][y[k]][id];\n\tup(y[k],x[k],id,k),g[1]=dp[y[k]][x[k]][id];\n\tfor(int t=1;t<=n;t++){\n\t\tup(y[k],t,id,k),(dp[y[k]][t][id]+=f[0][t])%=mod;\n\t\tup(x[k],t,id,k),(dp[x[k]][t][id]+=f[1][t])%=mod;\n\t\tup(t,y[k],id,k),(dp[t][y[k]][id]+=f[2][t])%=mod;\n\t\tup(t,x[k],id,k),(dp[t][x[k]][id]+=f[3][t])%=mod;\n\t}\n\tup(y[k],x[k],id,k),(dp[y[k]][x[k]][id]+=g[0])%=mod;\n\tup(x[k],y[k],id,k),(dp[x[k]][y[k]][id]+=g[1])%=mod;\n\t/*for(int t=1;t<=n;t++){\n\t\tfor(int T=1;T<=n;T++) if(t!=x[k]&&t!=y[k]&&T!=x[k]&&T!=y[k]) dp[t][T][id]=2*dp[t][T][id]%mod;\n\t}*/\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=q;i++) scanf(\"%d %d\",&x[i],&y[i]);\n\ttwo[0]=1;for(int i=1;i<=q+1;i++) two[i]=2*two[i-1]%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(a[i]<a[j]) dp[i][j][0]++;\n\t\t\telse if(a[i]>a[j]) dp[i][j][1]++;\n\t\t}\n\t}\n\tfor(int k=1;k<=q;k++){\n\t\twork(0,k);\n\t\twork(1,k);\n\t}\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int t=1;t<k;t++) up(k,t,0,q+1),(ans+=dp[k][t][0])%=mod;\n\t}\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int t=k+1;t<=n;t++) up(k,t,1,q+1),(ans+=dp[k][t][1])%=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nlong long qpow(long long base,int tms)\n{\n\tlong long tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * base % mod;\n\t\tbase = base * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nlong long inv2 = qpow(2,mod - 2);\nlong long dp[3050][3050];\nint N,Q;\nint seq[3050];\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i = 1;i <= N; ++ i)\n\t\tscanf(\"%d\",&seq[i]);\n\tfor(int i = 1;i <= N; ++ i)\n\t\tfor(int j = 1;j <= N; ++ j)\n\t\t\tdp[i][j] = seq[i] > seq[j];\n\tlong long make_me_burn = qpow(2,Q);\n\twhile(Q --)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * inv2 % mod;\n\t\tfor(int i = 1;i <= N; ++ i)\n\t\t\tif(i != x && i != y)\n\t\t\t\tdp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * inv2 % mod,\n\t\t\t\tdp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * inv2 % mod;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 1;i <= N; ++ i)\n\t\tfor(int j = i + 1;j <= N; ++ j)\n\t\t\tans = ans + dp[i][j] * make_me_burn % mod,ans %= mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll inv=mod/2+1;\nint n,m;\nvi a;\nvvl dp;\n\nint main(){\n\tcin>>n>>m;\n\ta=vi(n);\n\tdp=vvl(n,vl(n));\n\tfor(auto &i:a) cin>>i;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(a[i]>a[j]) dp[i][j]++;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tfor(int j=0;j<n;j++) if(j!=x&&j!=y){\n\t\t\tll t=(dp[j][x]+dp[j][y])*inv%mod;\n\t\t\tdp[j][x]=dp[j][y]=t;\n\t\t}\n\t\tfor(int j=0;j<n;j++) if(j!=x&&j!=y){\n\t\t\tll t=(dp[x][j]+dp[y][j])*inv%mod;\n\t\t\tdp[x][j]=dp[y][j]=t;\n\t\t}\n\t\tll t=(dp[x][y]+dp[y][x])*inv%mod;\n\t\tdp[x][y]=dp[y][x]=t;\n\t\t\n\t}\n\tll res=0;\n\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) (res+=dp[i][j])%=mod;\n\tfor(int i=0;i<m;i++) (res*=2)%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <map>\n#include <bitset>\n#include <fstream>\n#include <tr1/unordered_map>\n#include <assert.h>\n\n#define x first\n#define y second\n#define y0 Y0\n#define y1 Y1\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int MAXN = 3000;\nconst int MOD = 1e9 + 7;\n\ninline void ADD (int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\nint N, Q;\nint A[MAXN + 5], pw[MAXN + 5];\nint F[MAXN + 5][MAXN + 5];\nint lst[MAXN + 5][MAXN + 5];\n\ninline int trans (int i, int x, int y)\n{\n\tif (i == x) return y;\n\tif (i == y) return x;\n\treturn i;\n}\n\ninline void Solve ()\n{\n\tpw[0] = 1;\n\tfor (int i = 1; i <= MAXN; ++i) pw[i] = 2ll * pw[i - 1] % MOD;\n\n\tfor (int i = 1; i <= N; ++i) for (int j = 1; j <= N; ++j) if (A[i] > A[j])\n\t\tF[i][j] = 1;\n\n\tfor (int t = 1; t <= Q; ++t)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\n\t\tstatic pii stk[MAXN * 5 + 5];\n\t\tint top = 0;\n\n\t\tfor (int i = 1; i <= N; ++i) if (i != x && i != y)\n\t\t{\n\t\t\tstk[++top] = mp (x, i), stk[++top] = mp (i, x);\n\t\t\tstk[++top] = mp (y, i), stk[++top] = mp (i, y);\n\t\t}\n\n\t\tstk[++top] = mp (x, y), stk[++top] = mp (y, x);\n\n\t\tstatic int G[MAXN * 5 + 5];\n\n\t\tfor (int p = 1; p <= top; ++p)\n\t\t{\n\t\t\tint i = stk[p].x, j = stk[p].y;\n\t\t\tint di = trans (i, x, y), dj = trans (j, x, y);\n\n\t\t\tG[p] = ((LL) F[i][j] * pw[t - lst[i][j] - 1] % MOD + (LL) F[di][dj] * pw[t - lst[di][dj] - 1] % MOD) % MOD;\n\t\t}\n\n\t\tfor (int p = 1; p <= top; ++p)\n\t\t{\n\t\t\tint i = stk[p].x, j = stk[p].y;\n\t\t\tF[i][j] = G[p];\n\t\t\tlst[i][j] = t;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i < N; ++i) for (int j = i + 1; j <= N; ++j)\n\t{\n//\t\tcout << i << ' ' << j << ' ' << F[i][j] << endl;\n\t\tF[i][j] = (LL) F[i][j] * pw[Q - lst[i][j]] % MOD;\n\t\tADD (ans, F[i][j]);\n\t}\n\n\tcout << ans << endl;\n}\n\ninline void Input ()\n{\n\tN = read<int>(), Q = read<int>();\n\tfor (int i = 1; i <= N; ++i) A[i] = read<int>();\n}\n\nint main ()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint nxt[3005][3005], arr[3005], lst[3005], n, m;\nint dp[3005][2][2][3005], qx[3005], qy[3005], pw[3005];\nint solve(int p, int x, int y)\n{\n\tint t = p == -1 ? -1 : std::max(nxt[p][x], nxt[p][y]), coef = pw[p - t];\n\tp = t;\n\tif (p == -1) {\n\t\treturn (arr[x] > arr[y]) * coef;\n\t}\n\tint tp = qx[p] == x || qy[p] == x;\n\tint &res = dp[p][tp][tp ? (x == qx[p]) : (y == qx[p])][tp ? y : x];\n\tif (~res)\n\t\treturn res;\n\tres = solve(p - 1, x, y);\n\tif ((qx[p] == x && qy[p] == y) || (qy[p] == x && qx[p] == y)) {\n\t\tres += solve(p - 1, y, x);\n\t} else if (qx[p] == x || qy[p] == x) {\n\t\tres += solve(p - 1, qx[p] ^ qy[p] ^ x, y);\n\t} else if (qx[p] == y || qy[p] == y) {\n\t\tres += solve(p - 1, x, qx[p] ^ qy[p] ^ y);\n\t}\n\treturn res = (ll)res * coef % MOD;\n}\nint main()\n{\n\t// freopen(\"AGC030-D.in\", \"r\", stdin);\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tpw[0] = 1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tpw[i] = pw[i - 1] * 2 % MOD;\n\t}\n\tmemset(lst, -1, sizeof(lst));\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", qx + i, qy + i);\n\t\tqx[i]--;\n\t\tqy[i]--;\n\t\tlst[qx[i]] = lst[qy[i]] = i;\n\t\tmemcpy(nxt[i], lst, sizeof(lst));\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t(ans += solve(m - 1, i, j)) %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7 , inv2 = (mod+1)/2;\nll n,p=1,q,ans,a[3005],dp[3005][3005];\nint main(){\n    ios_base:: sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n    cin>>n>>q;\n    for(ll i=1;i<=n;i++)cin>>a[i];\n    for(ll i=1;i<=n;i++)for(ll j=1;j<=n;j++)dp[i][j]=a[i]>a[j];\n    for(;q>0;q--){\n        ll x,y;cin>>x>>y;\n        for(ll i=1;i<=n;i++){\n            if(i==x || i==y)continue;\n            ll p = dp[x][i] + dp[y][i];\n            ll q = dp[i][x] + dp[i][y];\n            dp[x][i]=dp[y][i]=p*inv2%mod;\n            dp[i][x]=dp[i][y]=q*inv2%mod;\n        }\n        ll r = dp[x][y] + dp[y][x];\n        dp[x][y]=dp[y][x]=r*inv2%mod;\n        p=(p*2)%mod;\n    }\n    for(ll i=1;i<=n;i++)for(ll j=i+1;j<=n;j++)ans=(ans + dp[i][j])%mod;\n    ans = (ans * p)%mod;\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nconst int N=3002;\nconst LL MOD=1e9+7;\nint n,q,a[N],x[N],y[N];\nLL dp[N][N];\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=q;i++) scanf(\"%d%d\",&x[i],&y[i]);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(a[i]<a[j])dp[i][j]=1;\n\n    for(int i=1;i<=q;i++){\n        for(int A=1;A<=n;A++){\n            if(A!=x[i] && A!=y[i]) \n            {\n                LL tmpX = dp[x[i]][A];\n                LL tmpY = dp[y[i]][A];\n                dp[y[i]][A] = (dp[y[i]][A] + tmpX) * ((MOD+1)/2) % MOD;\n                dp[x[i]][A] = (dp[x[i]][A] + tmpY) * ((MOD+1)/2) % MOD;\n            }\n        }\n\n        for(int A=1;A<=n;A++){\n            if(A!=x[i] && A!=y[i]) \n            {\n                LL tmpX = dp[A][x[i]];\n                LL tmpY = dp[A][y[i]];\n                dp[A][y[i]] = (dp[A][y[i]] + tmpX) * ((MOD+1)/2) % MOD;\n                dp[A][x[i]] = (dp[A][x[i]] + tmpY) * ((MOD+1)/2) % MOD;\n            }\n        }\n        \n        {\n            LL tmpX = dp[x[i]][y[i]];\n            LL tmpY = dp[y[i]][x[i]];\n            dp[x[i]][y[i]] = (dp[x[i]][y[i]] + tmpY) * ((MOD+1)/2) % MOD;\n            dp[y[i]][x[i]] = (dp[y[i]][x[i]] + tmpX) * ((MOD+1)/2) % MOD;\n        }\n        /*\n        printf(\"Round %d\\n\", i);\n        for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n            printf(\"dp[%d][%d]=%d\\n\", i,j,dp[i][j]);\n        */\n    }\n    LL ans=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<i;j++){\n            ans=(ans+dp[i][j])%MOD;\n        }\n    }\n    for(int i=1;i<=q;i++)ans=ans*2LL%MOD;\n    cout<<ans<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=3000+10,mod=1e9+7,inv=(mod+1)/2;\nint a[maxn],f[maxn][maxn],g[maxn][maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tint n=read(),q=read();\n\tREP(i,1,n) a[i]=read();\n\tREP(i,1,n) REP(j,1,n) if(a[i]>a[j]) f[i][j]=1;\n\tREP(_,1,q){\n\t\tint x=read(),y=read();\n\t\tREP(i,1,n) g[i][x]=f[i][x],g[i][y]=f[i][y],g[x][i]=f[x][i],g[y][i]=f[y][i];\n\t\tREP(i,1,n) if(i!=y && i!=x){\n\t\t\tf[i][x]=(ll)inv*(f[i][x]+g[i][y])%mod;\n\t\t\tf[i][y]=(ll)inv*(f[i][y]+g[i][x])%mod;\n\t\t\tf[x][i]=(ll)inv*(f[x][i]+g[y][i])%mod;\n\t\t\tf[y][i]=(ll)inv*(f[y][i]+g[x][i])%mod;\n\t\t}\n\t\tf[x][y]=(ll)inv*(f[x][y]+g[y][x])%mod;\n\t\tf[y][x]=(ll)inv*(f[y][x]+g[x][y])%mod;\n\t}\n\tint ans=0;\n\tREP(i,1,n) REP(j,1,n) if(i<j) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",(ll)ans*ksm(2,q)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 1000000007\n\nint A[3000];\nint dp[3000][3000];\nint main() {\n    int i,j;\n    int N,Q,X,Y;\n    scanf(\"%d %d\",&N,&Q);\n    for (i = 0; i < N; i++) scanf(\"%d\",&A[i]);\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            if (A[i] < A[j]) dp[i][j]++;\n        }\n    }\n    print2dArr(dp,N,N);\n    for (i = 0; i < Q; i++) {\n        scanf(\"%d %d\",&X,&Y);\n        X--,Y--;\n        for (j = 0; j < N; j++) {\n            if ((j != X) && (j != Y)) {\n                dp[j][X] = dp[j][Y] = ((LLI) ((dp[j][X]+dp[j][Y]) % MOD)*((MOD+1)/2)) % MOD;\n                dp[X][j] = dp[Y][j] = ((LLI) ((dp[X][j]+dp[Y][j]) % MOD)*((MOD+1)/2)) % MOD;\n            }\n        }\n        dp[X][Y] = dp[Y][X] = ((LLI) ((dp[X][Y]+dp[Y][X]) % MOD)*((MOD+1)/2)) % MOD;\n    }\n\n    int ans = 0;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < i; j++) {\n            ans += dp[i][j];\n            if (ans >= MOD) ans -= MOD;\n        }\n    }\n    for (i = 0; i < Q; i++) ans = (2*ans) % MOD;\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define debug printf(\"fuck %d\\n\", __LINE__);\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int N = 3e3 + 10, p = 1e9 + 7, inv2 = (p + 1) / 2;\n\nint f[N][N], a[N], g[N][N];\n\nint main() {\n\tint n = read(), m = read(), now = 1;\n\tfor (int i = 1; i <= n; ++ i) read(a[i]);\n\tfor (int i = 1; i <= n; ++ i) for (int j = 1; j <= n; ++ j) f[i][j] = a[i] > a[j];\n\tfor (; m -- > 0; ) {\n\t\tint x = read(), y = read();\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tg[i][y] = g[i][x] = 1LL * (f[i][x] + f[i][y]) * inv2 % p;\n\t\t\tg[x][i] = g[y][i] = 1LL * (f[x][i] + f[y][i]) * inv2 % p;\n\t\t}\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tf[i][y] = g[i][y]; f[i][x] = g[i][x];\n\t\t\tf[x][i] = g[x][i]; f[y][i] = g[y][i];\n\t\t}\n\t\tf[y][x] = f[x][y] = 1LL * (f[x][y] + f[y][x]) * inv2 % p;\n\t\tnow = (now << 1) % p;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = i; j <= n; ++ j) {\n\t\t\t(ans += f[i][j]) %= p;\n\t\t}\n\t}\n\tstd::cout << 1LL * ans * now % p << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sstream>\n#include <iostream>\n#include <math.h>\n#include <time.h>\n#include <unistd.h>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <string>\n\n#ifndef ONLINE_JUDGE\n\t#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#else\n\t#define DEBUG(x) do {} while(0);\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define FOR(i, A, N) for(int (i) = (A); (i) < (N); (i)++)\n#define REP(i, N) for(int (i) = 0; (i) < (N); (i)++)\n\nusing namespace std;\ntypedef long long ll;\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\nint n,m;\nconst int mod = 1000000007;\nll modpow(ll a, ll e) {\n\tif (e == 0) return 1;\n\tll x = modpow(a * a % mod, e >> 1);\n\treturn e & 1 ? x * a % mod : x;\n}\n\nll A[3333];\nll dp[3333][3333];\n\nint main() {\n\tll inv2 = modpow(2, mod-2);\n\tint n,q;\n\tscanf(\"%d%d\", &n, &q);\n\tREP(i, n) scanf(\"%lld\", A+i);\n\tREP(i, n) REP(j, n) dp[i][j] = A[i]>A[j];\n\tREP(i, q) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;y--;\n\t\tll o = dp[x][y];\n\t\tdp[x][y] = (inv2*dp[x][y]+inv2*dp[y][x])%mod; \n\t\tdp[y][x] = (inv2*dp[y][x]+inv2*o)%mod;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i == x || i == y)\n\t\t\t\tcontinue;\n\t\t\tll ix = dp[i][x];\n\t\t\tll xi = dp[x][i];\n\t\t\tdp[i][x] = (inv2*dp[i][x]+inv2*dp[i][y])%mod;\n\t\t\tdp[x][i] = (inv2*dp[x][i]+inv2*dp[y][i])%mod;\n\t\t\tdp[i][y] = (inv2*dp[i][y]+inv2*ix)%mod;\n\t\t\tdp[y][i] = (inv2*dp[y][i]+inv2*xi)%mod;\n\t\t}\n\t\t\n\t}\n\tll sum = 0;\n\tREP(i, n) REP(j, n) if(i < j) sum = (sum+(mod+dp[i][j])%mod+mod)%mod;\n\tREP(i, q) sum = (2*sum)%mod;\n\tprintf(\"%lld\\n\", sum);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\tfix(s+=s);\n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*iv%mod;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int MOD = 1e9 + 7, N = 3333;\n\nint n, Q, pw[N], a[N], bel[N][N];\nvector<int> op[N], cp[N];\nlong long ans;\nunordered_map<long long, int> mp;\n\nint Solve(int cur, int x, int y, int val) {\n  if(mp.find(cur * n * n + x * n + y) != mp.end()) {\n    return mp[cur * n * n + x * n + y];\n  }\n  int indx = bel[x][cur];\n  int indy = bel[y][cur];\n  \n  if(indx == op[x].size() && indy == op[y].size()) {\n    ans = (ans + 1LL * (x > y) * val * pw[Q + 1 - cur] % MOD) % MOD;\n    return 1LL * (x > y) * val * pw[Q + 1 - cur] % MOD;\n  }\n  //cerr << indx << \" \" << indy << endl;\n  int ix = indx == op[x].size() ? n + 1 : op[x][indx];\n  int iy = indy == op[y].size() ? n + 1 : op[y][indy];\n  int now = 0;\n  //cerr << ix << \" \" << iy << endl;\n  if(ix < iy) {\n    val = 1LL * val * pw[ix - cur] % MOD;\n    if(cp[x][indx] != x) {\n      now += Solve(ix + 1, x, y, val);\n      now += Solve(ix + 1, cp[x][indx], y, val);\n    } else {\n      now += Solve(ix + 1, x, y, val * 2 % MOD);\n    }\n  } else if(ix > iy) {\n    val = 1LL * val * pw[iy - cur] % MOD;\n    if(cp[y][indy] != y) { \n      now += Solve(iy + 1, x, y, val);\n      now += Solve(iy + 1, x, cp[y][indy], val);\n    } else {\n      now += Solve(iy + 1, x, y, val * 2 % MOD);\n    }\n  } else {\n    val = 1LL * val * pw[iy - cur] % MOD;\n    now += Solve(iy + 1, x, y, val);\n    now += Solve(iy + 1, cp[x][indx], cp[y][indy], val);\n  }\n  return mp[cur * n * n + x * n + y] = now;\n}\n\nmain(void) {\n  scanf(\"%lld%lld\", &n, &Q);\n  pw[0] = 1;\n  for(int i = 1; i <= Q; i++) {\n    pw[i] = pw[i - 1] * 2 % MOD;\n  }\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n  }\n  for(int i = 1, x, y; i <= Q; i++) {\n    scanf(\"%lld%lld\", &x, &y);\n    op[x].push_back(i);\n    cp[x].push_back(y);\n    op[y].push_back(i);\n    cp[y].push_back(x);\n  }\n  //cerr << \"!\" << endl;\n  for(int i = 1; i <= n; i++) {\n    int k = 1;\n    for(int j = 0; j < op[i].size(); j++) {\n      while(k <= op[i][j]) {\n\tbel[i][k] = j;\n\tk++;\n      }\n    }\n    while(k <= Q + 1) {\n      bel[i][k] = op[i].size();\n      k++;\n    }\n    //cerr << i << endl;\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if(a[i] < a[j]) {\n\tSolve(1, i, j, 1);\n      }\n      //cerr << i << \" \" << j << \" \" << ans << endl;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\nconst int N = 3e3 + 7, mod = 1e9 + 7;\n\n#define inc(i, x, y) for (int i = x; i <= y; ++i)\n#define dec(i, x, y) for (int i = x; i >= y; --i)\n#define gc getchar\n\nbool chkmin(int &x, int y) { return x > y ? x = y, 1 : 0; }\nbool chkmax(int &x, int y) { return x < y ? x = y, 1 : 0; }\n\nint rd() {\n\tint ret = 0; bool fl = 0; char ch = 0;\n\twhile (!isdigit(ch)) fl |= (ch == '-'), ch = gc();\n\twhile (isdigit(ch)) ret = (ret << 1) + (ret << 3) + (ch ^ 48), ch = gc();\n\treturn fl ? -ret : ret;\n}\n\nint a[N];\nll ans, dp[N][N];\n\nll add(ll x, ll y) { return x + y > mod ? x - mod + y : x + y; }\n\nll qpow(ll x, int y) {\n\tll ret = 1ll;\n\tfor (; y; y >>= 1, x = 1ll * x * x % mod) if (y & 1) ret = 1ll * ret * x % mod;\n\treturn ret;\n}\n\nint main() {\n\tint n = rd(), q = rd();\n\tll sum = qpow(2, q), inv2 = qpow(2, mod - 2);\n\tinc(i, 1, n) a[i] = rd();\n\tinc(i, 1, n) inc(j, 1, n) dp[i][j] = (a[i] < a[j] ? sum : 0);\n\twhile (q--) {\n\t\tint x = rd(), y = rd();\n\t\tdp[x][y] = dp[y][x] = 1ll * add(dp[x][y], dp[y][x]) * inv2 % mod;\n\t\tinc(j, 1, n) {\n\t\t\tif ((j == x) || (j == y)) continue;\n\t\t\tdp[x][j] = dp[y][j] = 1ll * add(dp[x][j], dp[y][j]) * inv2 % mod;\n\t\t\tdp[j][y] = dp[j][x] = 1ll * add(dp[j][y], dp[j][x]) * inv2 % mod;\n\t\t}\n\t}\n\tinc(i, 2, n) dec(j, i - 1, 1) ans = add(ans, dp[i][j]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nnamespace zyt\n{\n\ttemplate<typename T>\n\tinline bool read(T &x)\n\t{\n\t\tchar c;\n\t\tbool f = false;\n\t\tx = 0;\n\t\tdo\n\t\t\tc = getchar();\n\t\twhile (c != EOF && c != '-' && !isdigit(c));\n\t\tif (c == EOF)\n\t\t\treturn false;\n\t\tif (c == '-')\n\t\t\tf = true, c = getchar();\n\t\tdo\n\t\t\tx = x * 10 + c - '0', c = getchar();\n\t\twhile (isdigit(c));\n\t\tif (f)\n\t\t\tx = -x;\n\t\treturn true;\n\t}\n\ttemplate<typename T>\n\tinline void write(T x)\n\t{\n\t\tstatic char buf[20];\n\t\tchar *pos = buf;\n\t\tif (x < 0)\n\t\t\tputchar('-'), x = -x;\n\t\tdo\n\t\t\t*pos++ = x % 10 + '0';\n\t\twhile (x /= 10);\n\t\twhile (pos > buf)\n\t\t\tputchar(*--pos);\n\t}\n\ttypedef long long ll;\n\ttypedef pair<int, int> pii;\n\tconst int N = 3e3 + 10, P = 1e9 + 7, INV2 = (P + 1) / 2;\n\tint n, q, arr[N], f[N][N], tmp[N][N];\n\tint power(int a, int b)\n\t{\n\t\tint ans = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1)\n\t\t\t\tans = (ll)ans * a % P;\n\t\t\ta = (ll)a * a % P;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint inv(const int a)\n\t{\n\t\treturn power(a, P - 2);\n\t}\n\tint work()\n\t{\n\t\tread(n), read(q);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tread(arr[i]);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tf[i][j] = (arr[i] > arr[j] ? 1 : 0);\n\t\tfor (int i = 1; i <= q; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tread(x), read(y);\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\ttmp[x][j] = f[x][j], tmp[y][j] = f[y][j], tmp[j][x] = f[j][x], tmp[j][y] = f[j][y];\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tif (j != x && j != y)\n\t\t\t\t{\n\t\t\t\t\tf[x][j] = ll(f[x][j] + tmp[y][j]) * INV2 % P;\n\t\t\t\t\tf[j][x] = ll(f[j][x] + tmp[j][y]) * INV2 % P;\n\t\t\t\t\tf[y][j] = ll(f[y][j] + tmp[x][j]) * INV2 % P;\n\t\t\t\t\tf[j][y] = ll(f[j][y] + tmp[j][x]) * INV2 % P;\n\t\t\t\t}\n\t\t\tf[x][y] = ll(f[x][y] + tmp[y][x]) * INV2 % P;\n\t\t\tf[y][x] = ll(f[y][x] + tmp[x][y]) * INV2 % P;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\t\tans = (ans + f[i][j]) % P;\n\t\twrite((ll)ans * power(2, q) % P);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=3e3+5,Mo=1e9+7,i2=Mo+1>>1;\n\nint n,q,a[N],x,y;\nll f[N][N],g[N][N];\n\nint main() {\n\tscanf(\"%d%d\",&n,&q);\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tfo(i,1,n) fo(j,1,n) f[i][j]=a[i]>a[j];\n\tll pw=1;\n\tfor(;q;q--) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\n\t\tfo(i,1,n) {\n\t\t\tif (i==x||i==y) continue;\n\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])*i2%Mo;\n\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*i2%Mo;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*i2%Mo;\n\n\t\tpw=(pw<<1)%Mo;\n\t}\n\tll ans=0;\n\tfo(i,1,n) fo(j,i+1,n) (ans+=f[i][j]*pw)%=Mo;\n\tprintf(\"%lld\\n\",(ans+Mo)%Mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 998244353\nusing namespace std;\nlong long ans,x,y,n,q,a[3001],t[3001][3001],T[3001][3001],sum[3001][3001],Sum[3001][3001];\nint read()\n{\n  char c=0;\n  int sum=0;\n  while (c<'0'||c>'9')\n    c=getchar();\n  while ('0'<=c&&c<='9')\n    {\n      sum=sum*10+c-'0';\n      c=getchar();\n    }\n  return sum;\n}\nlong long fast_pow(long long a,int b)\n{\n  if (b==0)\n    return 1;\n  if (b&1)\n    return fast_pow(a*a%mod,b/2)*a%mod;\n  else\n    return fast_pow(a*a%mod,b/2);\n}\nint main()\n{\n  n=read(),q=read();\n  for (int i=1;i<=n;++i)\n    a[i]=read();\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      {\n\tif (a[i]>a[j])\n\t  t[i][j]=1;\n\tif (a[i]<a[j])\n\t  T[i][j]=1;\n      }\n  int a,b,c,d;\n  for (int i=1;i<=q;++i)\n    {\n      x=read(),y=read();\n      if (x>y)\n\tswap(x,y);\n      for (int j=x+1;j<=y-1;++j)\n\t{\n\t   a=t[x][j],b=T[x][j],c=t[j][y],d=T[j][y];\n\t   t[x][j]=T[j][y]=(a+d)%mod*fast_pow(2,mod-2)%mod;\n\t   T[x][j]=t[j][y]=(b+c)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=1;j<=x-1;++j)\n\t {\n\t   a=t[j][x],b=T[j][x],c=t[j][y],d=T[j][y];\n\t   t[j][x]=t[j][y]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t   T[j][x]=T[j][y]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=y+1;j<=n;++j)\n\t{\n\t  a=t[x][j],b=T[x][j],c=t[y][j],d=T[y][j];\n\t  t[x][j]=t[y][j]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t  T[x][j]=T[y][j]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t}\n      a=t[x][y],b=T[x][y];\n      t[x][y]=T[x][y]=(a+b)%mod*fast_pow(2,mod-2)%mod;\n    }\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      ans=(ans+t[i][j]*fast_pow(2,q)%mod)%mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\ntypedef tuple<int, int, ll> p;\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  vvl dp = VV(n+1, n+1, 1, ll);\n  vvl rev = VV(n+1, n+1, 0, ll);\n  vll ml(n+1, 1);\n\n  ll z = 1;\n  for(auto v:query){\n    vector<p> tmp;\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    tmp.push_back(p(y, x, dp[x][y]));\n    tmp.push_back(p(x, y, dp[y][x]));\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      tmp.push_back(p(i, x, dp[i][y]));\n      tmp.push_back(p(x, i, dp[y][i]));\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      tmp.push_back(p(i, y, dp[i][x]));\n      tmp.push_back(p(y, i, dp[x][i]));\n    }\n    for(auto ad:tmp){\n      ll s = get<0>(ad);\n      ll t = get<1>(ad);\n      ll u = get<2>(ad);\n      dp[s][t] = (dp[s][t] + u)%P;\n    }\n\n    z = (z*2)%P;\n    ml[x] = (ml[x]*I)%P;\n    ml[y] = (ml[y]*I)%P;\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(a[i]<a[j]) ans = (ans + rev[i][j])%P;\n      if(a[i]>a[j]) ans = (ans + dp[i][j])%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(0) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTIOn TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 3e3 + 10, K = 1e2 + 10, B = 1000, oo = 1e18, M = 1e9 + 7, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2, EPS = 1e-9;\n\n\nint dp[N][N], used[N], pw[N];\nvpi flex;\n\nvoid inc(int a, int b, int v)\n{\n    flex.push_back(mp(a * N + b, v));\n}\n\n\nint MOD(int v)\n{\n    v %= M;\n    if (v < 0)\n        v += M;\n\n    return v;\n}\n\n\nvoid smain() {\n    pw[0] = 1;\n    for (int i = 1; i < N; ++i)\n        pw[i] = MOD(pw[i - 1] * 2);\n\n    int n, q;\n    cin >> n >> q;\n\n    vi kek(n);\n    for (int i = 0; i < n; ++i)\n        cin >> kek[i];\n\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n        {\n            if (kek[i] < kek[j])\n                dp[i][j] = 1;\n            else if (kek[i] > kek[j])\n                dp[j][i] = 1;\n        }\n\n    fill(used, used + N, -1);\n\n\n    for (int i = 0; i < q; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        flex.clear();\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            dp[a][j] = MOD(dp[a][j] * pw[i - max(used[a], used[j]) - 1]);\n            dp[b][j] = MOD(dp[b][j] * pw[i - max(used[b], used[j]) - 1]);\n            dp[j][a] = MOD(dp[j][a] * pw[i - max(used[a], used[j]) - 1]);\n            dp[j][b] = MOD(dp[j][b] * pw[i - max(used[b], used[j]) - 1]);\n        }\n\n        dp[a][b] = MOD(dp[a][b] * pw[i - max(used[a], used[b]) - 1]);\n        dp[b][a] = MOD(dp[b][a] * pw[i - max(used[a], used[b]) - 1]);\n        used[a] = used[b] = i;\n\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            inc(a, j, dp[b][j]);\n            inc(b, j, dp[a][j]);\n            inc(j, a, dp[j][b]);\n            inc(j, b, dp[j][a]);\n        }\n\n        inc(a, b, dp[b][a]);\n        inc(b, a, dp[a][b]);\n\n\n        for (auto p : flex)\n        {\n            int a, b, v;\n            tie(a, v) = p;\n\n            b = a % N;\n            a /= N;\n            dp[a][b] = MOD(dp[a][b] + v);\n        }\n    }\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            dp[i][j] = MOD(dp[i][j] * pw[q - max(used[i], used[j]) - 1]);\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            ans = MOD(ans + dp[j][i]);\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, ll> Pl;\nconst ll mod = (ll)1e9 + 7;\nconst int N = 3005;\n\nint n,q;\nint num[N];\nint a[N], b[N];\n\nll dp[N][N];\n\nll fac[N], facinv[N];\nll inv[N];\n\nll fp(ll x, ll k){\n    if(k == 0) return 1;\n    ll hf = fp(x, k/2);\n    return k % 2 ? hf * hf % mod * x % mod: hf * hf % mod;\n}\n\nint main(){\n    inv[1] = 1;\n    for(int i = 2; i < N; i++) inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n    fac[0] = 1;\n    for(int i = 1; i <= N-1; i++) fac[i] = fac[i-1] * i % mod;\n    facinv[N-1] = fp(fac[N-1], mod - 2);\n    for(int i = N-1 - 1; i >= 0; i--) facinv[i] = facinv[i+1] * (i+1) % mod;\n\n    cin >> n >> q;\n    for(int i = 0; i < n; i++) cin >> num[i];\n    for(int i = 0; i < q; i++) cin >> a[i] >> b[i], a[i]--, b[i]--;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            dp[i][j] = (num[i] > num[j]);\n        }\n    }\n    for(int i = 0; i < q; i++){\n        for(int k = 0; k < n; k++){\n            if(k != a[i] && k != b[i]) {\n                ll sum1 = inv[2] * (dp[k][a[i]] + dp[k][b[i]]) % mod;\n                ll sum2 = inv[2] * (dp[a[i]][k] + dp[b[i]][k]) % mod;\n                dp[k][a[i]] = dp[k][b[i]] = sum1;\n                dp[a[i]][k] = dp[b[i]][k] = sum2;\n            }\n        }\n        ll sum = inv[2] * (dp[b[i]][a[i]] + dp[a[i]][b[i]]) % mod;\n        dp[a[i]][b[i]] = dp[b[i]][a[i]] = sum;\n    }\n    ll res = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = i + 1; j < n; j++){\n            res += dp[i][j];\n            res %= mod;\n        }\n    }\n    for(int i = 0; i < q; i++) res = (res * 2) % mod;\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define mod 1000000007\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint ksm(int u, int v){\n\tint s = 1;\n\tfor(int i = v; i; i >>= 1){\n\t\tif(i & 1) s = 1ll * s * u % mod;\n\t\tu = 1ll * u * u % mod;\n\t}\n\treturn s;\n}\nint n, m, f[5001][5001], inv2, ans, a[5001], g[5001][5001];\nint main()\n{\n\tn = read(); m = read(); inv2 = 500000004;\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) f[i][j] = (a[i] > a[j]);\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tint x = read(), y = read();\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tg[x][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv2 % mod;\t\t\n\t\t\tg[j][x] = 1ll * (f[j][x] + f[j][y]) % mod * inv2 % mod;\n\t\t\tg[y][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv2 % mod;\n\t\t\tg[j][y] = 1ll * (f[j][y] + f[j][x]) % mod * inv2 % mod;\n\t\t}\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tf[x][j] = g[x][j]; f[j][x] = g[j][x];\n\t\t\tf[y][j] = g[y][j]; f[j][y] = g[j][y];\n\t\t}\n\t\tf[x][y] = 1ll * (f[x][y] + f[y][x]) % mod * inv2 % mod; f[y][x] = f[x][y];\n\t\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tans = (ans + f[i][j]) % mod;\n\tans = 1ll * ans * ksm(2, m) % mod; cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int         long long\n#define pb          push_back\n#define pii         pair<int,int>\n#define vi          vector<int>\n#define vii         vector<pii>\n#define mi          map<int,int>\n#define mii         map<pii,int>\n#define all(a)      (a).begin(),(a).end()\n#define x           first\n#define y           second\n#define sz(x)       (int)x.size()\n#define endl        '\\n'\n#define hell        1000000007\n#define rep(i,a,b)  for(int i=a;i<b;i++)\nusing namespace std;\nint expo(int base,int exponent,int mod){\n    int ans=1;\n    while(exponent!=0){\n        if(exponent&1) ans=(1LL*ans*base)%mod;\n        base=(1LL*base*base)%mod;\n        exponent>>=1;\n    }\n    return ans%mod;\n}\nint n,q,a[3003],x[3003],y[3003];\nint dp[3003][3003];\nint f[3003][3003];\nint inv2=(hell+1)/2;\nvoid solve(){\n    cin>>n>>q;\n    rep(i,1,n+1){\n        cin>>a[i];\n    }\n    rep(i,0,q){\n        cin>>x[i]>>y[i];\n    }\n    rep(i,1,n+1){\n        rep(j,1,n+1){\n            dp[i][j]=i>j;\n        }\n    }\n    for(int i=q-1;i>=0;i--){\n        int l=x[i],r=y[i];\n        rep(j,1,n+1){\n            if(j==r) continue;\n            f[l][j]=(dp[r][j]+dp[l][j])*inv2%hell;\n        }\n        rep(j,1,n+1){\n            if(j==r) continue;\n            f[j][l]=(dp[j][r]+dp[j][l])*inv2%hell;\n        }\n        rep(j,1,n+1){\n            if(j==l) continue;\n            f[r][j]=(dp[r][j]+dp[l][j])*inv2%hell;\n        }\n        rep(j,1,n+1){\n            if(j==l) continue;\n            f[j][r]=(dp[j][r]+dp[j][l])*inv2%hell;\n        }\n        f[l][r]=(dp[l][r]+dp[r][l])*inv2%hell;\n        f[r][l]=(dp[l][r]+dp[r][l])*inv2%hell;\n        rep(j,1,n+1){\n            dp[j][l]=f[j][l];\n            dp[j][r]=f[j][r];\n            dp[l][j]=f[l][j];\n            dp[r][j]=f[r][j];\n        }\n    }\n    int ans=0;\n    rep(i,1,n+1){\n        rep(j,1,n+1){\n            if(a[i]>a[j]) ans=(ans+dp[j][i])%hell;\n        }\n    }\n    cout<<ans*expo(2,q,hell)%hell<<endl;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t=1;\n    // cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NDEBUG\n#include <cassert>\n\n\ntypedef long long ll;\ntypedef long double Double;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> llll;\ntypedef pair<double,double> dd;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ii> vii;\ntypedef vector<vector<ii>> vvii;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<llll> vllll;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<long double> vD;\n\n#define sz(a)  int((a).size())\n#define pb  push_back\n#define eb  emplace_back\n#define FOR(var,from,to) for(int var=(from);var<=(to);++var)\n#define rep(var,n)  for(int var=0;var<(n);++var)\n#define rep1(var,n)  for(int var=1;var<=(n);++var)\n#define repC2(vari,varj,n)  for(int vari=0;vari<(n)-1;++vari)for(int varj=vari+1;varj<(n);++varj)\n#define repC3(vari,varj,vark,n)  for(int vari=0;vari<(n)-2;++vari)for(int varj=vari+1;varj<(n)-1;++varj)for(int vark=varj+1;vark<(n);++vark)\n#define ALL(c)  (c).begin(),(c).end()\n#define RALL(c)  (c).rbegin(),(c).rend()\n#define tr(i,c)  for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define found(s,e)  ((s).find(e)!=(s).end())\n#define mset(arr,val)  memset(arr,val,sizeof(arr))\n#define mid(x,y) ((x)+((y)-(x))/2)\n#define IN(x,a,b) ((a)<=(x)&&(x)<=(b))\n#define cons make_pair\n\ntemplate<class T> inline void amin(T & a, T const & b) { a = min(a, b); }\ntemplate<class T> inline void amax(T & a, T const & b) { a = max(a, b); }\ntemplate<typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate<typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\n\nll gcd(ll a, ll b) { while(a) swap(a, b%=a); return b; }\n\nconst ll MOD=1000000007LL;\n\nll ADD(ll x, ll y) { return (x+y) % MOD; }\nll SUB(ll x, ll y) { return (x-y+MOD) % MOD; }\nll MUL(ll x, ll y) { return x*y % MOD; }\nll POW(ll x, ll e) { ll v=1; for(; e; x=MUL(x,x), e>>=1) if (e&1) v = MUL(v,x); return v; }\nll DIV(ll x, ll y) { /*assert(y%MOD!=0);*/ return MUL(x, POW(y, MOD-2)); }\n\nconst ll half = DIV(1LL, 2LL);\n\ninline ll avg(ll a, ll b) {\n    return MUL(ADD(a, b), half);\n}\n\nll solve(int N, int Q, vi& a, vi& qx, vi& qy) {\n    vector<vll> dp(N, vll(N, 0));\n    rep(i,N) rep(j,N) if (a[i] > a[j]) dp[i][j] = 1;\n\n    rep(q,Q) {\n        int x = qx[q], y = qy[q];\n        rep(i,N) {\n            if (i != x && i != y) {\n                dp[x][i] = dp[y][i] = avg(dp[x][i], dp[y][i]);\n                dp[i][x] = dp[i][y] = avg(dp[i][x], dp[i][y]);\n            }\n            dp[x][y] = dp[y][x] = avg(dp[x][y], dp[y][x]);\n        }\n    }\n\n    ll ans = 0;\n    repC2(i,j,N) ans = ADD(ans, dp[i][j]);\n    ans = MUL(ans, POW(2, Q));\n    return ans;\n}\n\nint main() {\n    int N,Q; scanf(\"%d%d\", &N, &Q);\n    vi a(N);\n    rep(i,N) scanf(\"%d\", &a[i]);\n    vi x(Q), y(Q);\n    rep(i,Q) {\n        scanf(\"%d%d\", &x[i], &y[i]);\n        --x[i]; --y[i];\n    }\n    cout << solve(N,Q,a,x,y) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <Mylib/Debug/debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T> void puts_all(const T &value){std::cout << value << \"\\n\";}\ntemplate <typename T, typename ...Args> void puts_all(const T &value, const Args&... args){std::cout << value << \" \";puts_all(args...);}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\ntemplate <typename T> auto make_vector(int n, int m, const T &value){return vector<vector<T>>(n, vector<T>(m, value));}\n\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n  }\n}init;\n\n\ntemplate <std::uint32_t M> class ModInt{\npublic:\n  std::uint64_t val;\n  ModInt(): val(0){}\n  ModInt(std::int64_t n){\n    if(n >= M) val = n % M;\n    else if(n < 0) val = n % M + M;\n    else val = n;\n  }\n  \n  inline constexpr auto operator+(const ModInt &a) const {return ModInt(val + a.val);}\n  inline constexpr auto operator-(const ModInt &a) const {return ModInt(val - a.val);}\n  inline constexpr auto operator*(const ModInt &a) const {return ModInt(val * a.val);}\n  inline constexpr auto operator/(const ModInt &a) const {return ModInt(val * a.inv().val);}\n  \n  inline constexpr auto& operator=(const ModInt &a){val = a.val; return *this;}\n  inline constexpr auto& operator+=(const ModInt &a){if((val += a.val) >= M) val -= M; return *this;}\n  inline constexpr auto& operator-=(const ModInt &a){if(val < a.val) val += M; val -= a.val; return *this;}\n  inline constexpr auto& operator*=(const ModInt &a){(val *= a.val) %= M; return *this;}\n  inline constexpr auto& operator/=(const ModInt &a){(val *= a.inv().val) %= M; return *this;}\n\n  inline constexpr bool operator==(const ModInt &a) const {return val == a.val;}\n  inline constexpr bool operator!=(const ModInt &a) const {return val != a.val;}\n\n  inline constexpr auto& operator++(){*this += 1; return *this;}\n  inline constexpr auto& operator--(){*this -= 1; return *this;}\n\n  inline constexpr auto operator++(int){auto t = *this; *this += 1; return t;}\n  inline constexpr auto operator--(int){auto t = *this; *this -= 1; return t;}\n\n  inline constexpr static auto frac(std::int64_t a, std::int64_t b){\n    return ModInt(a) / ModInt(b);\n  }\n  \n  inline constexpr static ModInt power(std::int64_t n, std::int64_t p){\n    if(p < 0) return power(n, -p).inv();\n    \n    ModInt ret = 1, e = n;\n    for(; p; e *= e, p >>= 1) if(p & 1) ret *= e;\n    return ret;\n  }\n\n  inline constexpr auto power(std::int64_t p) const {return power(val, p);}\n  \n  inline constexpr ModInt inv() const {\n    std::int64_t a = val, b = M, u = 1, v = 0;\n    \n    while(b){\n      std::int64_t t = a/b;\n      a -= t*b; std::swap(a,b);\n      u -= t*v; std::swap(u,v);\n    }\n    u %= M;\n    if(u < 0) u += M;\n    \n    return u;\n  }\n};\n\ntemplate <std::uint32_t M> auto operator-(const ModInt<M> &a){return ModInt<M>(-a.val);}\n\ntemplate <std::uint32_t M> auto operator+(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) + b;}\ntemplate <std::uint32_t M> auto operator-(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) - b;}\ntemplate <std::uint32_t M> auto operator*(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) * b;}\ntemplate <std::uint32_t M> auto operator/(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) / b;}\n\ntemplate <std::uint32_t M> std::istream& operator>>(std::istream &is, ModInt<M> &a){is >> a.val; return is;}\ntemplate <std::uint32_t M> std::ostream& operator<<(std::ostream &os, const ModInt<M> &a){os << a.val; return os;}\n\n\nusing mint = ModInt<1000000007>;\n\n\ntemplate <typename T>\nclass Compressor{\n  std::vector<T> data;\n\npublic:\n  inline void add(const T &val) {data.push_back(val);}\n  inline void add(const std::vector<T> &vals) {data.insert(data.end(), vals.begin(), vals.end());}\n  template <typename U> inline void add_all(const U &val) {add(val);}\n  template <typename U, typename ...Args> inline void add_all(const U &val, const Args&... args) {add(val); add_all(args...);}\n\n  inline void build(){\n    std::sort(data.begin(), data.end());\n    data.erase(std::unique(data.begin(), data.end()), data.end());\n  }\n\n  inline int get_index(const T &val) const {return std::lower_bound(data.begin(), data.end(), val) - data.begin();}\n\n  inline void compress(std::vector<T> &vals) const {for(auto &x : vals) x = get_index(x);}\n  inline void compress(T &val) const {val = get_index(val);}\n  template <typename U> inline void compress_all(U &val) const {compress(val);}\n  template <typename U, typename ...Args> inline void compress_all(U &val, Args&... args) const {compress(val); compress_all(args...);}\n\n  inline void decompress(std::vector<T> &vals) const {for(auto &x : vals) x = data[x];}\n  inline void decompress(T &val) const {val = data[val];}\n  template <typename U> inline void decompress_all(U &val) const {decompress(val);}\n  template <typename U, typename ...Args> inline void decompress_all(U &val, Args&... args) const {decompress(val); decompress_all(args...);}\n  \n  inline int size() const {return data.size();}\n  inline T operator[](int index) const {return data[index];}\n};\n\n\nint main(){\n  int N, Q; cin >> N >> Q;\n\n  vector<int> A(N); cin >> A;\n  {\n    Compressor<int> c;\n    c.add(A);\n    c.build();\n    c.compress(A);\n  }\n\n  vector<int> X(Q), Y(Q);\n  REP(i,Q){\n    cin >> X[i] >> Y[i];\n    --X[i], --Y[i];\n  }\n\n  auto dp1 = make_vector<mint>(N, N, 0);\n\n  REP(i,N){\n    REP(j,N){\n      if(A[i] > A[j]) dp1[i][j] = 1;\n    }\n  }\n\n  REP(i,Q){\n    int x = X[i], y = Y[i];\n\n    dp1[x][y] = dp1[y][x] = (dp1[x][y] + dp1[y][x]) / 2;\n\n    REP(j,N){\n      if(j == x or j == y) continue;\n\n      dp1[j][x] = dp1[j][y] = (dp1[j][x] + dp1[j][y]) / 2;\n      dp1[x][j] = dp1[y][j] = (dp1[x][j] + dp1[y][j]) / 2;\n    }\n  }\n\n\n  mint ans = 0;\n\n  REP(i,N){\n    FOR(j,i+1,N){\n      ans += dp1[i][j];\n    }\n  }\n\n  ans *= mint::power(2, Q);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int M=1e9+7;\nconst int N=3010;\nint n,q,a[N];\nint dp[N][N];\nint x[N],y[N];\nint ans;\nint tmp1[N],tmp2[N],tmp3[N];\nvoid ADD(int &x,int y){\n    (x+=y)>=M?x-=M:0;\n}\nvoid HALF(int &x){\n    x&1?(x+=M)>>=1:x>>=1;\n}\nvoid HALFPLUS(int &x,int y){\n    ADD(x,y);\n    HALF(x);\n}\nint fp(int x,int y){\n    int ret=1;\n    for (; y; y>>=1,x=(ll)x*x%M)\n\tif (y&1) ret=(ll)ret*x%M;\n    return ret;\n}\nint main(){\n    cin>>n>>q;\n    for (int i=1; i<=n; ++i) scanf(\"%d\",&a[i]);\n    for (int i=1; i<=q; ++i){\n\tscanf(\"%d%d\",&x[i],&y[i]);\n    }\n    for (int i=1; i<=n; ++i)\n\tfor (int j=1; j<=n; ++j){\n\t    dp[i][j]=(a[i]>a[j]);\n\t}\n    for (int i=1; i<=q; ++i){\n\tint a=x[i],b=y[i];\n\t/*cerr<<a<<\" \"<<b<<endl;\n\tfor (int i=1; i<=n; ++i)\n\t    for (int j=1; j<=n; ++j)\n\t    cerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;*/\n\t//cerr<<\"!!!!!!!\";\n\tfor (int i=1; i<=n; ++i) tmp1[i]=dp[a][i];\n\tfor (int i=1; i<=n; ++i) tmp2[i]=dp[i][a];\n\tint ttt=dp[a][b];\n\tHALFPLUS(dp[a][b],dp[b][a]);\n\tHALFPLUS(dp[b][a],ttt);\n\tfor (int j=1; j<=n; ++j)\n\t    if (j!=b&&j!=a){\n\t\tHALFPLUS(dp[a][j],dp[b][j]);\n\t\tHALFPLUS(dp[j][a],dp[j][b]);\n\t    }\n\tfor (int j=1; j<=n; ++j)\n\t    if (j!=a&&j!=b){\n\t\tHALFPLUS(dp[b][j],tmp1[j]);\n\t\tHALFPLUS(dp[j][b],tmp2[j]);\n\t    }\n\t//don't swap\n\t/*for (int i=1; i<=n; ++i)\n\t    for (int j=1; j<=n; ++j)\n\t\tcerr<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;*/\n\t//return 0;\n    }\n    for (int i=1; i<=n; ++i)\n\tfor (int j=i+1; j<=n; ++j)\n\t    ADD(ans,dp[i][j]);\n    cout<<(ll)ans*fp(2,q)%M;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#define N 3010\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar();\n\twhile (!isdigit(c)) c = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\ninline ll quickpow(ll x, int k) {\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1)\tres = res *x  % P;\n\t\tx = x * x % P;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\nint n, q;\nint a[N];\nint f[N][N], g[N][N];\nint main() {\n\tread(n), read(q);\n\tfor (int i = 1; i <= n; ++i)\tread(a[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = a[i] > a[j];\n\t\t\tf[j][i] = a[j] > a[i];\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint l, r; read(l), read(r);\n\t\tif (l > r)\tswap(l, r);\n\t\tint tmp = 1ll * inv2 * (f[l][r] + f[r][l]) % P;\n\t\tf[l][r] = f[r][l] = tmp;\n\t\tfor (int j = 1; j <= n; ++j) if (j != l && j != r) {\n\t\t\tf[j][l] = f[j][r] = 1ll * inv2 * (f[j][l] + f[j][r]) % P;\n\t\t\tf[l][j] = f[r][j] = 1ll * inv2 * (f[l][j] + f[r][j]) % P;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tans = (ans + f[i][j]) % P;\n\t\t}\n\t}\n\tans = ans * quickpow(2, q) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n #ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DInversionSum {\npublic:\nvoid solve(istream& cin, ostream& cout) {\n    int N, Q; cin >> N >> Q;\n    vector<int> A(N); cin >> A;\n    vector<pii> X(Q); cin >> X;\n\n    vector2<FieldMod> I(N,N,0);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            I[i][j] = A[i] > A[j];\n        }\n    }\n\n    for (pii&x:X) {\n        int a = x.x-1;\n        int b = x.y-1;\n        for (int j = 0; j < N; ++j) {\n            if (j != a && j != b) {\n                FieldMod f = I[j][a] + I[j][b];\n                f /= 2;\n                I[j][a] = I[j][b] = f;\n\n\n                FieldMod g = I[a][j] + I[b][j];\n                g /= 2;\n                I[a][j] = I[b][j] = g;\n            }\n        }\n\n        FieldMod f = I[a][b] + I[b][a];\n        f /= 2;\n        I[a][b] = I[b][a] = f;\n\n\n    }\n\n    FieldMod ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            ans += I[i][j];\n        }\n    }\n    cout << ans * FieldMod{2}.pow(Q) << endl;\n}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDInversionSum solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N, Q;\nint A[3000];\nMInt DP[3000][3000];\nint main() {\n\tcin >> N >> Q;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\t\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tDP[i][j] = A[i] > A[j];\n\t\t}\n\t}\n\n\tREP(z, 0, Q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\n\t\t{\n\t\t\tMInt t = (DP[x][y] + DP[y][x]) * 500000004;\n\t\t\tDP[x][y] = t;\n\t\t\tDP[y][x] = t;\n\t\t}\n\n\t\tREP(j, 0, N) {\n\t\t\tif (j == x || j == y) continue;\n\t\t\tMInt t = (DP[x][j] + DP[y][j]) * 500000004;\n\t\t\tDP[x][j] = t;\n\t\t\tDP[y][j] = t;\n\t\t}\n\n\t\tREP(i, 0, N) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tMInt t = (DP[i][x] + DP[i][y]) * 500000004;\n\t\t\tDP[i][x] = t;\n\t\t\tDP[i][y] = t;\n\t\t}\n\t}\n\n\tMInt sum = 0;\n\tMInt base = MInt(2).power(Q);\n\tREP(i, 0, N) {\n\t\tREP(j, i + 1, N) {\n\t\t\tsum += DP[i][j] * base;\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nlong long ans,x,y,n,q,a[3001],t[3001][3001],T[3001][3001],sum[3001][3001],Sum[3001][3001];\nint read()\n{\n  char c=0;\n  int sum=0;\n  while (c<'0'||c>'9')\n    c=getchar();\n  while ('0'<=c&&c<='9')\n    {\n      sum=sum*10+c-'0';\n      c=getchar();\n    }\n  return sum;\n}\nlong long fast_pow(long long a,int b)\n{\n  if (b==0)\n    return 1;\n  if (b&1)\n    return fast_pow(a*a%mod,b/2)*a%mod;\n  else\n    return fast_pow(a*a%mod,b/2);\n}\nint main()\n{\n  n=read(),q=read();\n  for (int i=1;i<=n;++i)\n    a[i]=read();\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      {\n\tif (a[i]>a[j])\n\t  t[i][j]=1;\n\tif (a[i]<a[j])\n\t  T[i][j]=1;\n      }\n  int a,b,c,d;\n  for (int i=1;i<=q;++i)\n    {\n      x=read(),y=read();\n      if (x>y)\n\tswap(x,y);\n      for (int j=x+1;j<=y-1;++j)\n\t{\n\t   a=t[x][j],b=T[x][j],c=t[j][y],d=T[j][y];\n\t   t[x][j]=T[j][y]=(a+d)%mod*fast_pow(2,mod-2)%mod;\n\t   T[x][j]=t[j][y]=(b+c)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=1;j<=x-1;++j)\n\t {\n\t   a=t[j][x],b=T[j][x],c=t[j][y],d=T[j][y];\n\t   t[j][x]=t[j][y]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t   T[j][x]=T[j][y]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=y+1;j<=n;++j)\n\t{\n\t  a=t[x][j],b=T[x][j],c=t[y][j],d=T[y][j];\n\t  t[x][j]=t[y][j]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t  T[x][j]=T[y][j]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t}\n      a=t[x][y],b=T[x][y];\n      t[x][y]=T[x][y]=(a+b)%mod*fast_pow(2,mod-2)%mod;\n    }\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      ans=(ans+t[i][j]*fast_pow(2,q)%mod)%mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n    friend istream& operator << (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(int e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    /* requires prime MOD */\n    modnum& operator /= (const modnum& o) { return (*this) *= o.pow(MOD - 2); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n};\nconst int MOD = 1e9 + 7;\nusing mn = modnum<MOD>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vi val(N);\n    for (int i = 0; i < N; i++) {\n        cin >> val[i];\n    }\n\n    vector<vector<mn>> gt(N, vector<mn>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            gt[i][j] = val[i] > val[j];\n        }\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n\n        for (int i = 0; i < N; i++) {\n            if (i == x || i == y) continue;\n            {\n                mn avg = (gt[i][x] + gt[i][y]) / 2;\n                gt[i][x] = gt[i][y] = avg;\n            }\n            {\n                mn avg = (gt[x][i] + gt[y][i]) / 2;\n                gt[x][i] = gt[y][i] = avg;\n            }\n        }\n        mn avg = (gt[x][y] + gt[y][x]) / 2;\n        gt[x][y] = gt[y][x] = avg;\n    }\n\n    mn ans = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            ans += gt[i][j];\n        }\n    }\n    cout << (ans * mn(2).pow(Q)) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nconst int mo=1e9+7;\nconst int inv2=(mo+1)>>1;\n\nint f[3001][3001],n,q,a[3001];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j) f[i][j]=a[i]>a[j];\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=1ll*(f[y][x]+f[x][y])*inv2%mo;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif((x!=i)&&(y!=i))\n\t\t\t{\n\t\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*inv2%mo;\n\t\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*inv2%mo;\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) ans=(ans+f[i][j])%mo;\n\tfor(int i=1;i<=q;i++) ans=1ll*ans*2%mo;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll inv=mod/2+1;\nint n,m;\nvi a;\nvvl dp;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>m;\n\ta=vi(n);\n\tdp=vvl(n,vl(n));\n\tfor(auto &i:a) cin>>i;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(a[i]>a[j]) dp[i][j]++;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--;y--;\n\t\tfor(int j=0;j<n;j++) if(j!=x&&j!=y){\n\t\t\tll t=(dp[j][x]+dp[j][y])*inv%mod;\n\t\t\tdp[j][x]=dp[j][y]=t;\n\t\t}\n\t\tfor(int j=0;j<n;j++) if(j!=x&&j!=y){\n\t\t\tll t=(dp[x][j]+dp[y][j])*inv%mod;\n\t\t\tdp[x][j]=dp[y][j]=t;\n\t\t}\n\t\tll t=(dp[x][y]+dp[y][x])*inv%mod;\n\t\tdp[x][y]=dp[y][x]=t;\n\t\t\n\t}\n\tll res=0;\n\tfor(int i=0;i<n;i++) for(int j=i+1;j<n;j++) (res+=dp[i][j])%=mod;\n\tfor(int i=0;i<m;i++) (res*=2)%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 3005;\nconst int mod = 1000000007;\nconst int inv2 = 500000004;\n\nint n, q;\nint a[Maxn];\nint qa[Maxn], qb[Maxn];\nint nxt[Maxn][Maxn];\nint dpa[Maxn][Maxn], dpb[Maxn][Maxn];\nint res;\n\nint Get(int from, int a, int b)\n{\n    int r = min(nxt[from][a], nxt[from][b]);\n    if (r >= q) return a < b;\n    if (qa[r] == a) return dpa[r][b];\n    if (qa[r] == b) return (1 - dpa[r][a] + mod) % mod;\n    if (qb[r] == a) return dpb[r][b];\n    if (qb[r] == b) return (1 - dpb[r][a] + mod) % mod;\n}\n\nint Change(int quer, int x)\n{\n    if (qa[quer] == x) x = qb[quer];\n    else if (qb[quer] == x) x = qa[quer];\n    return x;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d\", &qa[i], &qb[i]);\n        qa[i]--; qb[i]--;\n    }\n    for (int j = 0; j < n; j++)\n        nxt[q][j] = q;\n    for (int i = q - 1; i >= 0; i--) {\n        for (int j = 0; j < n; j++)\n            nxt[i][j] = nxt[i + 1][j];\n        nxt[i][qa[i]] = nxt[i][qb[i]] = i;\n        for (int j = 0; j < n; j++) {\n            if (j != qa[i]) {\n                int a = qa[i], b = j;\n                int lst = Get(i + 1, a, b);\n                a = Change(i, a), b = Change(i, b);\n                dpa[i][j] = ll(lst + Get(i + 1, a, b)) * inv2 % mod;\n            }\n            if (j != qb[i]) {\n                int a = qb[i], b = j;\n                int lst = Get(i + 1, a, b);\n                a = Change(i, a), b = Change(i, b);\n                dpb[i][j] = ll(lst + Get(i + 1, a, b)) * inv2 % mod;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) if (a[i] > a[j])\n            res = (res + Get(0, i, j)) % mod;\n    while (q--)\n        res = 2ll * res % mod;\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 3005;\nint n, q;\nint A[MAXN];\npair<int, int> Q[MAXN];\nvector<int> swaps[MAXN];\nint nxt[MAXN][MAXN];\nvector<int> dp[MAXN][MAXN][2];\nint pw2[MAXN];\n\nint getNxt(int i, int sw) {\n\treturn nxt[i][sw];\n}\nint getSw(int i, int x) {\n\tpair<int, int> sw = Q[swaps[i][x]];\n\tif (sw.first == i) return sw.second;\n\treturn sw.first;\n}\nint sol(int i, int j, int x, int y) {\n\tif (q == swaps[i][x] && q == swaps[j][y]) {\n\t\treturn (i > j) ? 1 : 0;\n\t}\n\tint smaller = 0;\n\tint mn = x;\n\tif (swaps[i][x] > swaps[j][y]) {\n\t\tsmaller = 1;\n\t\tmn = y;\n\t}\n\tif (dp[i][j][smaller][mn] != -1) return dp[i][j][smaller][mn];\n\tint ans = 0;\n\tif (swaps[j][y] < swaps[i][x]) {\n\t\tint dis = min(swaps[i][x], swaps[j][y+1]) - swaps[j][y] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(i, j, x, y + 1)) % MOD;\n\t\tans %= MOD;\n\t\tint nj = getSw(j, y);\n\t\tint ny = getNxt(nj, swaps[j][y] + 1);\n\t\tdis = min(swaps[nj][ny], swaps[i][x]) - swaps[j][y] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(i, nj, x, ny)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[i][j][smaller][mn] = ans;\n\t}\n\tif (swaps[j][y] > swaps[i][x]) {\n\t\tint dis = min(swaps[j][y], swaps[i][x + 1]) - swaps[i][x]-1;\n\t\tans += (pw2[dis] * 1ll * sol(i, j, x+1, y)) % MOD;\n\t\tans %= MOD;\n\t\tint ni = getSw(i, x);\n\t\tint nx = getNxt(ni, swaps[i][x] + 1);\n\t\tdis = min(swaps[j][y], swaps[ni][nx]) - swaps[i][x] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(ni, j, nx, y)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[i][j][smaller][mn] = ans;\n\t}\n\tint dis = min(swaps[i][x+1] - swaps[i][x], swaps[j][y+1] - swaps[j][y]) - 1;\n\tans += (pw2[dis] * 1ll * sol(i, j, x + 1, y + 1)) % MOD;\n\tans %= MOD;\n\tans += (pw2[dis] * 1ll * sol(j, i, y + 1, x + 1)) % MOD;\n\tans %= MOD;\n\treturn dp[i][j][smaller][mn] = ans;\n}\n\nint main() {\n\tpw2[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tpw2[i] = (pw2[i-1] * 2) % MOD;\n\t}\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", A + i);\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tswaps[x].push_back(i);\n\t\tswaps[y].push_back(i);\n\t\tQ[i] = {x, y};\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tswaps[i].push_back(q);\n\t\tint k = 0;\n\t\tfor (int j = 0; j < swaps[i].size(); j++) {\n\t\t\twhile (k <= swaps[i][j]) {\n\t\t\t\tnxt[i][k] = j;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n\t\tdp[i][j][0] = vector<int> (max(swaps[i].size(), swaps[j].size()), -1);\n\t\tdp[i][j][1] = vector<int> (max(swaps[i].size(), swaps[j].size()), -1);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (A[i] == A[j]) continue;\n\t\t\tint res = (pw2[min(swaps[i][0], swaps[j][0])] * 1ll * sol(i, j, 0, 0)) % MOD;\n\t\t\tif (A[i] < A[j]) ans += res;\n\t\t\telse {\n\t\t\t\tans += (pw2[q] - res + MOD) % MOD;\n\t\t\t}\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mk make_pair\n#define ll long long\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 3010;\nconst int mod = 1e9+7;\n\nint qsm(int i,int j)\n{\n\tint ans=1;\n\twhile (j)\n\t{\n\t\tif (j&1) ans=ans*i%mod;\n\t\tj>>=1;\n\t    i=i*i%mod;\n\t}\n\treturn ans;\n}\n\nint dp[maxn][maxn];\nint n,m;\nint q;\nint a[maxn];\n\nsigned main()\n{\n   scanf(\"%lld%lld\",&n,&m);\n   for (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);//a[i]=read();\n   for (int i=1;i<=n;i++)\n     for (int j=1;j<=n;j++)\n       dp[i][j]=(a[i]>a[j]);\n   int inv = qsm(2,mod-2);\n   for (int i=1;i<=m;i++)\n   {\n   \t  int x,y;\n   \t  scanf(\"%lld%lld\",&x,&y);\n   \t  dp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv%mod;\n   \t  for (int i=1;i<=n;i++)\n   \t  {\n   \t  \tif (i!=x && i!=y)\n   \t  \t{\n   \t  \t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*inv%mod;\n   \t  \t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*inv%mod;\n\t\t}\n\t  }\n   }\n   int ans=0;\n   for (int i=1;i<=n;i++)\n     for (int j=1;j<=n;j++)\n        ans=(ans+dp[i][j])%mod;\n   cout<<ans*qsm(2,m)%mod*inv;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3005;\nconst int Mod=1e9+7;\nconst int pw=(Mod+1)>>1;\nint n,q,now,inv,a[N];\nint dp[N][N],f[N][N];\nint s[N],t[N];\ninline int read(){\n\tint x=0,w=1;\n\tchar ch=0;\n\twhile (ch<'0' || ch>'9'){\n\t\tch=getchar();\n\t\tif (ch=='-') w=-1;\t\n\t}\n\twhile (ch<='9' && ch>='0'){\n\t\tx=(x<<1)+(x<<3)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*w;\n}\ninline int Pow(int x,int y){\n\tint res=1;\n\twhile (y){\n\t\tif (y&1) res=1ll*res*x%Mod;\n\t\tx=1ll*x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline void ad(int &x,int y){\n\tx+=y;\n\tif (x>=Mod) x-=Mod;\n}\nint main(){\n\t//freopen(\"d.in\",\"r\",stdin);\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\tfor (int i=1;i<=q;++i)\n\t\ts[i]=read(),t[i]=read();\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif (a[i]<a[j]) dp[i][j]=1;\n\tnow=1,inv=1;\n\tfor (int i=1;i<=q;++i){\n\t\tf[t[i]][s[i]]=f[s[i]][t[i]]=(1ll*now*(dp[s[i]][t[i]]+dp[t[i]][s[i]]))%Mod;\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (j==t[i] || j==s[i]) continue;\n\t\t\tf[t[i]][j]=(1ll*now*(dp[s[i]][j]+dp[t[i]][j]))%Mod;\n\t\t\tf[j][t[i]]=(1ll*now*(dp[j][s[i]]+dp[j][t[i]]))%Mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (j==s[i] || j==t[i]) continue;\n\t\t\tf[s[i]][j]=(1ll*now*(dp[t[i]][j]+dp[s[i]][j]))%Mod;\n\t\t\tf[j][s[i]]=(1ll*now*(dp[j][t[i]]+dp[j][s[i]]))%Mod;\n\t\t}\n\t\tnow=2ll*now%Mod;\n\t\tinv=1ll*inv*pw%Mod;\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tdp[j][s[i]]=1ll*inv*f[j][s[i]]%Mod;\n\t\t\tdp[j][t[i]]=1ll*inv*f[j][t[i]]%Mod;\n\t\t\tdp[s[i]][j]=1ll*inv*f[s[i]][j]%Mod;\n\t\t\tdp[t[i]][j]=1ll*inv*f[t[i]][j]%Mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tf[s[i]][j]=f[j][s[i]]=f[j][t[i]]=f[t[i]][j]=0;\n\t}\n\tint Ans=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<i;++j){\n\t\t\tad(Ans,1ll*now*dp[i][j]%Mod);\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,1ll*now*dp[i][j]%Mod);\t\n\t\t}\t\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 3005\n#define P 1000000007\n#define INV 500000004\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, q, ans, a[MAXN], f[MAXN][MAXN];\n\ninline int add(int x, int y) {return x+y>=P?x+y-P:x+y;}\ninline int sub(int x, int y) {return x>=y?x-y:x-y+P;}\n\ninline int ksm(int x, int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1) ans=1LL*x*ans%P;\n        x=1LL*x*x%P, y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &q);\n    for(rint i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=n; ++j) if(a[i]>a[j]) f[i][j]=1;\n    for(rint i=1, x, y; i<=q; ++i)\n    {\n        scanf(\"%d%d\", &x, &y);\n        int t1, t2;\n        for(rint j=1; j<=n; ++j)\n        {\n            if(j==x || j==y) continue;\n            t1=f[x][j], t2=f[y][j];\n            f[y][j]=f[x][j]=1LL*add(t1, t2)*INV%P;\n            t1=f[j][x], t2=f[j][y];\n            f[j][x]=f[j][y]=1LL*add(t1, t2)*INV%P;\n        }\n        \n        t1=f[x][y], t2=f[y][x];\n        f[x][y]=f[y][x]=1LL*add(t1, t2)*INV%P;\n    }\n    int temp=ksm(2, q);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=i+1; j<=n; ++j)\n            ans=add(ans, 1LL*f[i][j]*temp%P);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=1e9+7, iv2=(mod+1)/2;\n\nint f[3333][3333], g[3333][3333];\n\nint n, q, a[3333];\n\nint main(){\n  cin>>n>>q;\n  for (int i=1;i<=n;++i) cin>>a[i];\n  for (int i=1;i<=n;++i)\n    for (int j=1;j<=n;++j)\n      if (i!=j) f[i][j]= a[i]>a[j];\n  \n  ll pw=1;\n  for (int x,y;q--;){\n    cin>>x>>y;\n    for (int i=1;i<=n;++i)\n      if (i!=x&&i!=y){\n        // i,x  i,y  x,i  y,i\n        g[i][x]=(f[i][x]+f[i][y])*(ll)iv2%mod;\n        g[i][y]=(f[i][x]+f[i][y])*(ll)iv2%mod;\n        g[x][i]=(f[x][i]+f[y][i])*(ll)iv2%mod;\n        g[y][i]=(f[x][i]+f[y][i])*(ll)iv2%mod;\n      }\n    f[x][y]=f[y][x]=(f[x][y]+f[y][x])*(ll)iv2%mod;\n    for (int i=1;i<=n;++i)\n      if (i!=x&&i!=y){\n        // i,x  i,y  x,i  y,i\n        f[i][x]=g[i][x];\n        f[i][y]=g[i][y];\n        f[x][i]=g[x][i];\n        f[y][i]=g[y][i];\n      }\n    pw=pw*2%mod;\n  }\n  ll ans=0;\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      ans=(ans+f[i][j])%mod;\n  \n  ans=ans*pw%mod;\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nll ppow(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll E[4000][4000];\nint a[4000];\n\nint main(){\n\tll t=ppow(2,MOD-2);\n\tint n,q;scanf(\"%d%d\",&n,&q);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\trep(i,n)rep(j,n){\n\t\tE[i][j]=(a[i]>a[j]);\n\t}\n\trep(i,q){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);x--;y--;\n\t\tif(x>y)swap(x,y);\n\t\trep(j,n){\n\t\t\tif(j==x||j==y)continue;\n\t\t\tE[j][x]=E[j][y]=(E[j][x]*t+E[j][y]*t)%MOD;\n\t\t\tE[x][j]=E[y][j]=(E[x][j]*t+E[y][j]*t)%MOD;\n\t\t}\n\t\tE[x][y]=E[y][x]=E[x][y]*t+E[y][x]*t;\n\t}\n\tll ans=0;\n\trep(i,n){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\t(ans+=E[i][j])%=MOD;\n\t\t}\n\t}\n\tcout<<ans*ppow(2,q)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint x[3100];\nint y[3100];\nint las[3100][3100];\nint cur[3100];\nint p[3100];\nlong long ks[3100];\n\nmap<pair<int,pair<int,int> >,long long >dp;\nlong long calc(int a,int b,int c){\n\tif(a==0){\n\t\treturn p[b]>p[c];\n\t}\n\tif(dp.count(make_pair(a,make_pair(b,c)))){\n\t\treturn dp[make_pair(a,make_pair(b,c))];\n\t}\n\tlong long ret=0;\n\tint to=max(las[a][b],las[a][c]);\n\tif(to==a-1){\n\t\tret=calc(to,b,c);\n\t\tif(x[to]==b&&y[to]==c)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==c&&y[to]==b)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==b)ret=(ret+calc(to,y[to],c))%mod;\n\t\telse if(x[to]==c)ret=(ret+calc(to,b,y[to]))%mod;\n\t\telse if(y[to]==b)ret=(ret+calc(to,x[to],c))%mod;\n\t\telse if(y[to]==c)ret=(ret+calc(to,b,x[to]))%mod;\n\t\t\n\t}else{\n\t\tret=calc(to+1,b,c);\n\t\tret=ret*ks[a-to-1]%mod;\n\t}\n\treturn dp[make_pair(a,make_pair(b,c))]=ret;\n}\nint main(){\n\tks[0]=1;\n\tfor(int i=1;i<3100;i++)ks[i]=ks[i-1]*2%mod;\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);x[i]--;y[i]--;\n\t}\n\tfor(int i=0;i<a;i++)cur[i]=-1;\n\tfor(int i=0;i<b;i++){\n\t\tcur[x[i]]=cur[y[i]]=i;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tlas[i+1][j]=cur[j];\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tret+=calc(b,i,j);\n\t\t}\n\t}\n\tret%=mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007, Inv2 = (Mod + 1) / 2;\nconst int MN = 3005;\n\nint N, Q, A[MN], p1[MN], p2[MN];\nint dp[MN][MN], Coef, Sum;\n\nint main() {\n        scanf(\"%d%d\", &N, &Q), Coef = 1;\n        for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n        for (int i = 1; i <= Q; ++i) {\n                scanf(\"%d%d\", &p1[i], &p2[i]);\n                /* if (p1[i] > p2[i]) std::swap(p1[i], p2[i]); */\n        }\n        for (int i = 1; i <= N; ++i)\n                for (int j = 1; j <= N; ++j)\n                        dp[i][j] = A[i] > A[j];\n        for (int i = 1; i <= Q; ++i) {\n                static int tmp[MN][MN];\n                for (int x = 1; x <= N; ++x)\n                        if (x != p1[i] && x != p2[i]) {\n                                tmp[x][p1[i]] = (LL)Inv2 * (dp[x][p1[i]] + dp[x][p2[i]]) % Mod;\n                                tmp[p1[i]][x] = (LL)Inv2 * (dp[p1[i]][x] + dp[p2[i]][x]) % Mod;\n                                tmp[x][p2[i]] = (LL)Inv2 * (dp[x][p2[i]] + dp[x][p1[i]]) % Mod;\n                                tmp[p2[i]][x] = (LL)Inv2 * (dp[p2[i]][x] + dp[p1[i]][x]) % Mod;\n                        }\n                for (int x = 1; x <= N; ++x)\n                        if (x != p1[i] && x != p2[i]) {\n                                dp[x][p1[i]] = tmp[x][p1[i]];\n                                dp[p1[i]][x] = tmp[p1[i]][x];\n                                dp[x][p2[i]] = tmp[x][p2[i]];\n                                dp[p2[i]][x] = tmp[p2[i]][x];\n                        }\n                dp[p2[i]][p1[i]] = dp[p1[i]][p2[i]] = (LL)Inv2 * (dp[p1[i]][p2[i]] + dp[p2[i]][p1[i]]) % Mod;\n                Coef = 2ll * Coef % Mod;\n        }\n        for (int x = 1; x < N; ++x)\n                for (int y = x + 1; y <= N; ++y)\n                        Sum = (Sum + dp[x][y]) % Mod;\n        printf(\"%lld\\n\", (LL)Coef * Sum % Mod);\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\ntypedef long long ll;\ntypedef long double  ld;\n#define pii pair<ll,ll> \n#define pic pair<ll,char>\n#define vi vector< ll > \n#define vvi vector< vi > \n#define vpi vector< pii > \n#define vvpi vector< vpi > \n#define st  set <ll, greater <ll> >\n#define mst  multiset <ll, greater <ll> >\n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define mapp  unordered_map <ll, ll>\n#define ppii pair< pii, pii > \n#define test(t) ll t;cin>>t;while(t--)\n#define inarr(n) ll arr[n];for(ll i=0;i<n;i++)cin>>arr[i];\n#define ingra(m) vvi arr(100005);for(ll i=0;i<m;i++){ll u,v;cin>>u>>v;arr[u].pb(v);arr[v].pb(u);}\n#define mem(a,b) memset(a,b,sizeof(a))\n#define inn freopen(\"input.txt\", \"r\", stdin)\n#define outt freopen(\"output.txt\", \"w\", stdout)\n#define all(arr) arr.begin(),arr.end()\nll power(ll x,ll y){ll res = 1;while(y){if(y&1) res = (res*x)%mod;y=y/2,x=(x*x)%mod;}return res%mod;}\nll dp[3001][3001];\nll arr[3001];\nsigned main()\n{\n    fast;\n    ll n,q,i,j;\n    cin>>n>>q;\n    ll tot = power(2,q);\n    for(i=1;i<=n;i++)\n        cin>>arr[i];\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n;j++)\n        {\n            if(arr[i]>arr[j])\n                dp[i][j] = tot;\n        }\n    }\n    ll inv = power(2,mod-2);\n    while(q--)\n    {\n        ll x,y;\n        cin>>x>>y;\n        for(i=1;i<=n;i++)\n        {\n            if(i!=x and i!=y)\n            {\n                dp[i][x] = inv*(dp[i][x]+dp[i][y])%mod;\n                dp[i][y] = dp[i][x];\n                dp[x][i] = inv*(dp[x][i]+dp[y][i])%mod;\n                dp[y][i] = dp[x][i];\n            }\n        }\n        dp[x][y] = inv*(dp[x][y]+dp[y][x])%mod;\n        dp[y][x] = dp[x][y];\n    }\n    ll ans = 0;\n    for(i=1;i<=n;i++)\n        for(j=i+1;j<=n;j++)\n            ans+=dp[i][j],ans%=mod;\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ninline int in()\n{\n\tint k=0;char ch=gt;\n\twhile(ch<'-')ch=gt;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn k;\n}\nconst int N=3005,YL=1e9+7,inv2=5e8+4;\ninline int MO(const int &x){return x>=YL?x-YL:x;}\ninline int ksm(int a,int k){int r=1;while(k){if(k&1)r=1ll*r*a%YL;a=1ll*a*a%YL,k>>=1;}return r;}\nint a[N],f[N][N],g[4][N];\nint main()\n{\n\tint n=in(),Q=in();int ans=ksm(2,Q);\n\tfor(int i=1;i<=n;++i)a[i]=in();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=(a[i]<a[j]);\n\twhile(Q--)\n\t{\n\t\tint x=in(),y=in();\n\t\tfor(int i=1;i<=n;++i)g[0][i]=f[x][i],g[1][i]=f[y][i];\n\t\tfor(int i=1;i<=n;++i)g[2][i]=f[i][x],g[3][i]=f[i][y];\n\t\tfor(int i=1;i<=n;++i)f[y][i]=f[x][i]=1ll*inv2*MO(g[0][i]+g[1][i])%YL;\n\t\tfor(int i=1;i<=n;++i)f[i][x]=f[i][y]=1ll*inv2*MO(g[2][i]+g[3][i])%YL;\n\t\tf[x][y]=f[y][x]=1ll*inv2*MO(g[0][y]+g[1][x])%YL;\n\t}\n\tint sum=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tsum=MO(sum+f[i][j]);\n\tprintf(\"%lld\\n\",1ll*ans*sum%YL);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n    friend istream& operator << (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(int e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    /* requires prime MOD */\n    modnum& operator /= (const modnum& o) { return (*this) *= o.pow(MOD - 2); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n};\nconst int MOD = 1e9 + 7;\nusing mn = modnum<MOD>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vi val(N);\n    for (int i = 0; i < N; i++) {\n        cin >> val[i];\n    }\n\n    const mn HALF = mn(1) / 2;\n\n    vector<vector<mn>> gt(N, vector<mn>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            gt[i][j] = val[i] > val[j];\n        }\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n\n        for (int i = 0; i < N; i++) {\n            if (i == x || i == y) continue;\n            {\n                mn avg = (gt[i][x] + gt[i][y]) * HALF;\n                gt[i][x] = gt[i][y] = avg;\n            }\n            {\n                mn avg = (gt[x][i] + gt[y][i]) * HALF;\n                gt[x][i] = gt[y][i] = avg;\n            }\n        }\n        mn avg = (gt[x][y] + gt[y][x]) * HALF;\n        gt[x][y] = gt[y][x] = avg;\n    }\n\n    mn ans = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            ans += gt[i][j];\n        }\n    }\n    cout << (ans * mn(2).pow(Q)) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 3005\n#define ll long long\n#define mod 1000000007\n#define inv2 500000004\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint n, q;\nint f[N][N], A[N];\nint main()\n{\n\tRead(n), Read(q);\n\tfor (int i = 1; i <= n; i++)\n\t\tRead(A[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tf[i][j] = (A[i] > A[j]);\n\tint ans = 1;\n\tfor (; q--; )\n\t{\n\t\tans = (ans << 1) % mod;\n\t\tint x, y;\n\t\tRead(x), Read(y);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (i != x && i != y)\n\t\t\t{\n\t\t\t\tf[i][x] = f[i][y] = (ll)(f[i][x] + f[i][y]) * inv2 % mod;\n\t\t\t\tf[x][i] = f[y][i] = (ll)(f[x][i] + f[y][i]) * inv2 % mod;\n\t\t\t}\n\t\t}\n\t\tf[x][y] = f[y][x] = (ll)(f[x][y] + f[y][x]) * inv2 % mod;\n\t}\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tsum = (sum + f[i][j]) % mod;\n\tans = (ll)sum * ans % mod;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <vector>\n#include <iostream>\nusing namespace std;\nusing modulo = modint<1000000007>;\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; ++i) cin >> A[i];\n\tvector<int> X(Q), Y(Q);\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcin >> X[i] >> Y[i]; --X[i], --Y[i];\n\t}\n\tvector<vector<modulo> > dp(N, vector<modulo>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tdp[i][j] = 1;\n\t\t}\n\t}\n\tmodulo inv2 = modulo(2).inv();\n\tfor (int i = Q - 1; i >= 0; --i) {\n\t\tmodulo SS = (dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv2;\n\t\tdp[X[i]][Y[i]] = SS;\n\t\tdp[Y[i]][X[i]] = SS;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (j == X[i] || j == Y[i]) continue;\n\t\t\tmodulo S1 = (dp[X[i]][j] + dp[Y[i]][j]) * inv2;\n\t\t\tdp[X[i]][j] = S1;\n\t\t\tdp[Y[i]][j] = S1;\n\t\t\tmodulo S2 = (dp[j][X[i]] + dp[j][Y[i]]) * inv2;\n\t\t\tdp[j][X[i]] = S2;\n\t\t\tdp[j][Y[i]] = S2;\n\t\t}\n\t}\n\tmodulo ex = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (A[i] > A[j]) ex += dp[i][j];\n\t\t}\n\t}\n\tmodulo ans = ex * modulo(2).binpow(Q);\n\tcout << ans.get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nconst int mod=1e9+7,inv2=(mod+1)/2;\nint n,q;\nint a[3005],f[3005][3005],mi=1,ans=0;\nint main()\n{\n\tn=read(),q=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++) f[i][j]=a[i]>a[j];\n\twhile(q--)\n\t{\n\t\tmi=mi*2%mod;\n\t\tint x=read(),y=read();\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x||j==y) continue;\n\t\t\tf[x][j]=f[y][j]=1ll*inv2*(f[x][j]+f[y][j])%mod;\n\t\t\tf[j][x]=f[j][y]=1ll*inv2*(f[j][x]+f[j][y])%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*inv2*(f[x][y]+f[y][x])%mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) ans=(ans+f[i][j])%mod;\n\tans=1ll*ans*mi%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 3005\n#define inv 500000004\n#define mod 1000000007\n\nusing namespace std;\n\nint n,q,a[maxn];\nint dp[maxn][maxn];\n\n\nsigned main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++)\tcin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]>a[j])\tdp[i][j]=1;\n\tfor(int i=1,x,y;i<=q;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tdp[x][y]=dp[y][x]=inv*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x || j==y)\tcontinue;\n\t\t\tdp[x][j]=dp[y][j]=(inv*dp[x][j]+inv*dp[y][j])%mod;\n\t\t\tdp[j][x]=dp[j][y]=(inv*dp[j][x]+inv*dp[j][y])%mod;\n\t\t}\n\t}\n\tint now=1,ans=0;\n\tfor(int i=1;i<=q;i++)\n\t\t(now*=2)%=mod;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\t(ans+=dp[i][j])%=mod;\n\tcout<<ans*now%mod<<endl;\n\t\t\t\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define ll long long\nconst int MAXN = 5e5 + 7;\nconst ll p = 1e9 + 7;\nconst ll inv2 = 500000004ll;\nint n, m;\nint a[MAXN];\nstruct rec\n{\n    int x, y;\n} q[MAXN];\nll f[3500][3500];\n\ninline ll ksm(int x, int y)\n{\n    ll ans = 1;\n    while (y)\n    {\n        if (y & 1)\n            ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lld\", &a[i]);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d\", &q[i].x, &q[i].y);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            f[i][j] = a[i] < a[j];\n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        f[q[i].x][q[i].y] = f[q[i].y][q[i].x] = inv2 * (f[q[i].x][q[i].y] + f[q[i].y][q[i].x]) % p;\n        for (int j = 1; j <= n; j++)\n        {\n            if (j != q[i].x && j != q[i].y)\n            {\n                f[j][q[i].x] = f[j][q[i].y] = inv2 * (f[j][q[i].x] + f[j][q[i].y]) % p;\n                f[q[i].y][j] = f[q[i].x][j] = inv2 * (f[q[i].y][j] + f[q[i].x][j]) % p;\n            }\n        }\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j < i; j++)\n        {\n            ans += f[i][j];\n        }\n    }\n    printf(\"%lld\", ans % p * ksm(2, m) % p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long inv(long long a, long long b){\n return 1 < a ? b - inv(b % a, a) * b / a : 1;\n}\n\nconst int N = 3030;\nconst int mod = 1e9 + 7;\n\nint n, q;\nint a[N];\nint f[N][N];\nint test[N][N];\npair < int, int > queries[N];\n\nint main(){\n  \n  cin >> n >> q;\n  for(int i = 1; i <= n; ++i) cin >> a[i];\n  for(int i = 1; i <= q; ++i) cin >> queries[i].first >> queries[i].second;\n  \n  int mul = 1, halve = inv(2, mod);\n  for(int i = 1; i <= q; ++i) mul = (mul + mul) % mod;\n  \n  for(int i = 1; i <= n; ++i) {\n    for(int j = i + 1; j <= n; ++j) f[i][j] = mul;\n  }\n  \n  \n  vector < int > tempX(n + 1, 0), tempY(n + 1, 0), tempX1(n + 1, 0), tempY1(n + 1, 0);\n\n  for(int i = q; i >= 1; --i) {\n    int x = queries[i].first, y = queries[i].second;\n    \n    fill(tempX.begin(), tempX.end(), 0);\n    fill(tempY.begin(), tempY.end(), 0);\n    fill(tempY1.begin(), tempY1.end(), 0);\n    fill(tempX1.begin(), tempX1.end(), 0);\n    \n    for(int j = 1; j <= n; ++j) {\n      if(j == y || j == x) continue;\n      tempX[j] = f[x][j] + f[y][j];\n      tempX1[j] = f[j][x] + f[j][y];\n    }\n    \n    for(int j = 1; j <= n; ++j) {\n      if(j == x || j == y) continue;\n      tempY[j] = f[y][j] + f[x][j];\n      tempY1[j] = f[j][y] + f[j][x];\n    }\n    \n    \n    tempY[x] = tempX[y] = f[x][y] + f[y][x]; \n    \n    for(int j = 1; j <= n; ++j) {\n      f[x][j] = (1LL * tempX[j] * halve) % mod;\n      f[y][j] = (1LL * tempY[j] * halve) % mod;\n      \n      if(j != x && j != y) f[j][x] = 1LL * tempX1[j] * halve % mod, f[j][y] = 1LL * tempY1[j] * halve % mod;\n    }\n    \n    \n  /*  for(int i = 1; i <= n; ++i) {\n      for(int j = 1; j <= n; ++j) cout << f[i][j] << \" \\n\"[j == n];\n    }*/\n  }\n  \n\n  int ans = 0;\n  \n  for(int i = 1; i <= n; ++i) {\n    for(int j = i + 1; j <= n; ++j) {\n      if(a[i] == a[j]) continue;\n      if(a[i] < a[j]) ans += f[j][i];\n      else ans += f[i][j];\n      ans %= mod;\n    }\n  }\n  \n  cout << ans;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 3005;\nint n, q;\nint A[MAXN];\npair<int, int> Q[MAXN];\nvector<int> swapTime[MAXN];\nvector<int> swapWith[MAXN];\nint nxt[MAXN][MAXN];\nvector<int> dp[MAXN][MAXN][2];\nint pw2[MAXN];\n\nint sol(int i, int j, int x, int y) {\n\tif (q == swapTime[i][x] && q == swapTime[j][y]) {\n\t\treturn (i > j) ? 1 : 0;\n\t}\n\tint smaller = 0;\n\tint mn = x;\n\tif (swapTime[i][x] > swapTime[j][y]) {\n\t\tsmaller = 1;\n\t\tmn = y;\n\t}\n\tif (dp[i][j][smaller][mn] != -1) return dp[i][j][smaller][mn];\n\tint ans = 0;\n\tif (swapTime[j][y] < swapTime[i][x]) {\n\t\tint dis = min(swapTime[i][x], swapTime[j][y+1]) - swapTime[j][y] - 1;\n\t\tans = (pw2[dis] * 1ll * sol(i, j, x, y + 1)) % MOD;\n\t\tint nj = swapWith[j][y];\n\t\tint ny = nxt[nj][swapTime[j][y] + 1];\n\t\tdis = min(swapTime[nj][ny], swapTime[i][x]) - swapTime[j][y] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(i, nj, x, ny)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[i][j][smaller][mn] = ans;\n\t}\n\tif (swapTime[j][y] > swapTime[i][x]) {\n\t\tint dis = min(swapTime[j][y], swapTime[i][x + 1]) - swapTime[i][x]-1;\n\t\tans = (pw2[dis] * 1ll * sol(i, j, x+1, y)) % MOD;\n\t\tint ni = swapWith[i][x];\n\t\tint nx = nxt[ni][swapTime[i][x] + 1];\n\t\tdis = min(swapTime[j][y], swapTime[ni][nx]) - swapTime[i][x] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(ni, j, nx, y)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[i][j][smaller][mn] = ans;\n\t}\n\tint dis = min(swapTime[i][x+1] - swapTime[i][x], swapTime[j][y+1] - swapTime[j][y]) - 1;\n\tans = (pw2[dis] * 1ll * sol(i, j, x + 1, y + 1)) % MOD;\n\tans += (pw2[dis] * 1ll * sol(j, i, y + 1, x + 1)) % MOD;\n\tans %= MOD;\n\treturn dp[i][j][smaller][mn] = ans;\n}\n\nint main() {\n\tpw2[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tpw2[i] = (pw2[i-1] * 2) % MOD;\n\t}\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", A + i);\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tswapTime[x].push_back(i);\n\t\tswapWith[x].push_back(y);\n\t\tswapTime[y].push_back(i);\n\t\tswapWith[y].push_back(x);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tswapTime[i].push_back(q);\n\t\tint k = 0;\n\t\tfor (int j = 0; j < swapTime[i].size(); j++) {\n\t\t\twhile (k <= swapTime[i][j]) {\n\t\t\t\tnxt[i][k] = j;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n\t\tif (i == j) continue;\n\t\tdp[i][j][0].resize(swapTime[i].size(), -1);\n\t\tdp[i][j][1].resize(swapTime[j].size(), -1);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (A[i] == A[j]) continue;\n\t\t\tint res = (pw2[min(swapTime[i][0], swapTime[j][0])] * 1ll * sol(i, j, 0, 0)) % MOD;\n\t\t\tif (A[i] < A[j]) ans += res;\n\t\t\telse {\n\t\t\t\tans += (pw2[q] - res + MOD) % MOD;\n\t\t\t}\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 3054, mod = 1000000007, iv2 = (mod + 1) / 2;\n\nint n, q;\nint a[N], f[N][N];\n\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\ninline int half(int x) {return x = (x >> 1) + (-(x & 1) & (iv2 - mod)), x + (x >> 31 & mod);;}\n\nint main() {\n\tint i, j, u, v; ll I = 0;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (i = 1; i <= n; ++i)\n\t\tfor (j = 1; j <= n; ++j)\n\t\t\tf[i][j] = a[i] > a[j];\n\tfor (i = 0; i < q; ++i) {\n\t\tscanf(\"%d%d\", &u, &v), f[u][v] = f[v][u] = half(f[u][v] + f[v][u]);\n\t\tfor (j = 1; j <= n; ++j) if (j != u && j != v)\n\t\t\tf[u][j] = f[v][j] = half(f[u][j] + f[v][j]),\n\t\t\tf[j][u] = f[j][v] = half(f[j][u] + f[j][v]);\n\t}\n\tfor (i = 1; i <= n; ++i) I += std::accumulate(f[i] + i, f[i] + (n + 1), 0ll);\n\tprintf(\"%d\\n\", (int)PowerMod(2, q, I % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define ll long long\nusing namespace std;\n\ninline int read(){\n\tint sum=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();}\n\twhile(c<='9'&&c>='0'){sum=sum*10+c-'0';c=getchar();}\n\treturn f*sum;\n}\n\nconst int N=5005;\nconst int Mod=1000000007;\n//const int inv=500000004;\nint n,m,a[N];\nll f[N][N],s[N][N];\n\ninline ll fpow(ll a,ll b){\n\tll ret=1;\n\twhile(b){if(b&1) ret=ret*a%Mod;a=a*a%Mod;b>>=1;}\n\treturn ret;\n}\n\nsigned main(){\n\tn=read();m=read();ll inv=fpow(2,Mod-2);\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tif(a[i]>a[j]) f[i][j]=1;\n\t\t}\n\tfor(int i=1;i<=m;i++){\t\t\n\t\tint x=read(),y=read();\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%Mod*inv%Mod;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==x||j==y) continue;\t\t\t\n\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])%Mod*inv%Mod;\n\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])%Mod*inv%Mod;\n\t\t}\n/*\t\tfor(int j=1;j<=n;j++){\n\t\t\tf[x][j]=s[x][j],f[j][x]=s[j][x];\n\t\t\tf[y][j]=s[y][j],f[j][y]=s[j][y];\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++) printf(\"f[%d][%d]=%d\\n\",i,j,f[i][j]);\n\t\t*/\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) ans=(ans+f[i][j])%Mod;\n\tprintf(\"%lld\\n\",ans*fpow(2,m)%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 3010, mod = 1e9 + 7, i2 = (mod + 1) / 2;\n\nint a[N], dp[N][N];\n\nint main() {\n    int n, q, tot = 1; scanf(\"%d%d\", &n, &q);\n    for (int i = 1; i <= q; i++) tot <<= 1, tot %= mod;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            dp[i][j] = a[i] > a[j];\n    for (int i = 1; i <= q; i++) {\n        int l, r; scanf(\"%d%d\", &l, &r);\n        dp[l][r] = dp[r][l] = (LL)(dp[l][r] + dp[r][l]) * i2 % mod;\n        for (int j = 1; j <= n; j++) if (j != r && j != l) {\n            dp[j][r] = dp[j][l] = (LL)(dp[j][r] + dp[j][l]) * i2 % mod;\n            dp[l][j] = dp[r][j] = (LL)(dp[l][j] + dp[r][j]) * i2 % mod;\n        }\n    }\n    int res = 0;\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            res = (res + dp[i][j]) % mod;\n    printf(\"%d\\n\", (LL)res * tot % mod);\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint x[3100];\nint y[3100];\nint las[3100][3100];\nint cur[3100];\nint p[3100];\nlong long ks[3100];\nlong long dp[3100][4][3100];\nint Q;\n//map<pair<int,pair<int,int> >,long long >dp;\nlong long calc(int a,int b,int c){\n\tif(a==0){\n\t\treturn p[b]>p[c];\n\t}\n\tint ty=-1;\n\tint rm=0;\n\tif(a<Q&&b==x[a]){ty=0;rm=c;}\n\telse if(a<Q&&b==y[a]){ty=1;rm=c;}\n\telse if(a<Q&&c==x[a]){ty=2;rm=b;}\n\telse if(a<Q&&c==y[a]){ty=3;rm=b;}\n\tif(ty!=-1&&~dp[a][ty][rm]){\n\t\treturn dp[a][ty][rm];\n\t}\n\t//printf(\"%d %d %d %d %d\\n\",a,b,c,ty,rm);\n\tlong long ret=0;\n\tint to=max(las[a][b],las[a][c]);\n\tif(to==-1){\n\t\tret=calc(0,b,c);\n\t}else{\n\t\tret=calc(to,b,c);\n\t\tif(x[to]==b&&y[to]==c)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==c&&y[to]==b)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==b)ret=(ret+calc(to,y[to],c))%mod;\n\t\telse if(x[to]==c)ret=(ret+calc(to,b,y[to]))%mod;\n\t\telse if(y[to]==b)ret=(ret+calc(to,x[to],c))%mod;\n\t\telse if(y[to]==c)ret=(ret+calc(to,b,x[to]))%mod;\n\t}\n\tret=ret*ks[a-to-1]%mod;\n\tif(ty!=-1){\n\t\tdp[a][ty][rm]=ret;\n\t}\n\treturn ret;\n}\nint main(){\n\tks[0]=1;\n\tfor(int i=1;i<3100;i++)ks[i]=ks[i-1]*2%mod;\n\tint a,b;scanf(\"%d%d\",&a,&b);Q=b;\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);x[i]--;y[i]--;\n\t}\n\tfor(int i=0;i<=b;i++)for(int j=0;j<4;j++)for(int k=0;k<a;k++)\n\t\tdp[i][j][k]=-1;\n\tfor(int i=0;i<a;i++)cur[i]=-1;\n\tfor(int i=0;i<b;i++){\n\t\tcur[x[i]]=cur[y[i]]=i;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tlas[i+1][j]=cur[j];\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tret+=calc(b,i,j);\n\t\t}\n\t}\n\tret%=mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const i64 mod = 1'000'000'007;\n    i64 N,Q;\n    cin >> N >> Q;\n    \n    if(max(Q*N*N,N*N*N)>=100000000){\n        return;\n    }\n\n    vector<i64> A(N);\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<i64> X(Q),Y(Q);\n    rep(i,0,Q){\n        cin >> X[i] >> Y[i];\n        --X[i];\n        --Y[i];\n    }\n\n    vector<pair<i64,i64>> vi;\n    rep(i,0,N){\n        vi.push_back(make_pair(A[i],i));\n    }\n    sort(rbegin(vi),rend(vi));\n\n    i64 ans=0;\n    for(auto p:vi){\n        i64 Ai=p.first,i=p.second;\n\n        const i64 size=3000;\n        static i64 dp[size][size];\n        fill_n((i64*)dp,size*size,0);\n        rep(j,0,N){\n            if(A[j]<=Ai) continue;\n            ++dp[j][i];\n        }\n\n        rep(j,0,Q){\n            i64 x=X[j],y=Y[j];\n            i64 tmpxy=dp[x][y],tmpyx=dp[y][x];\n            rep(k,0,N){\n                if(k==x or k==y) continue;\n                rep(l,0,N){\n                    if(l==x or l==y) continue;\n                    dp[k][l]*=2;\n                    dp[k][l]%=mod;\n                }\n            }\n\n            vector<i64> xk(N),kx(N),yk(N),ky(N);\n            rep(k,0,N){\n                xk[k]=dp[x][k];\n                kx[k]=dp[k][x];\n                yk[k]=dp[y][k];\n                ky[k]=dp[k][y];\n            }\n            rep(k,0,N){\n                if(k==x) continue;\n                dp[x][k]+=yk[k];\n                dp[x][k]%=mod;\n                dp[k][x]+=ky[k];\n                dp[k][x]%=mod;\n            }\n\n            rep(k,0,N){\n                if(k==y) continue;\n                dp[y][k]+=xk[k];\n                dp[y][k]%=mod;\n                dp[k][y]+=kx[k];\n                dp[k][y]%=mod;\n            }\n\n            dp[y][x]+=tmpxy;\n            dp[y][x]%=mod;\n            dp[x][y]+=tmpyx;\n            dp[x][y]%=mod;\n        }\n\n        rep(j,0,N){\n            rep(k,j+1,N){\n                ans+=dp[j][k];\n                ans%=mod;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=3009;\nconst long long Mod=1000000007ll,_two=500000004ll;\nint n,q,x,y,ans;\nlong long a[maxn],p[maxn][maxn],pe[maxn][maxn],pp[maxn][maxn],ppe[maxn][maxn];\n\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\ta[i]==a[j]?pe[i][j]=1:p[i][j]=((i>j)!=(a[i]>a[j]));\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tif(x>y) swap(x,y);\n\t\tfor(int j=x+1;j<y;j++)\n\t\t\tpp[x][j]=(p[x][j]+2*Mod+1-p[j][y]-pe[j][y])*_two%Mod,pp[j][y]=(p[j][y]+2*Mod+1-p[x][j]-pe[x][j])*_two%Mod,ppe[x][j]=ppe[j][y]=(pe[x][j]+pe[j][y])*_two%Mod;\n\t\tfor(int j=x+1;j<y;j++) p[x][j]=pp[x][j],pe[x][j]=ppe[x][j],p[j][y]=pp[j][y],pe[j][y]=ppe[j][y];\n\t\tp[x][y]=(Mod+1-pe[x][y])*_two%Mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) ans=(ans+p[i][j])%Mod;\n\tfor(int i=0;i<q;i++) ans=ans*2%Mod;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,q;\n  cin >> n >> q;\n  \n  vector<int> a(n);\n  REP(i,n) cin >> a[i];\n  \n  mat dp(n,vec(n,0));\n  REP(i,n) REP(j,n){\n    if(a[i] > a[j]) dp[i][j] = 1;\n  }\n\n  mint t = 1; t /= 2;\n  REP(_,q){\n    int x,y; \n    cin >> x >> y; x--; y--;\n    REP(i,n){\n      if(i!=x&&i!=y){\n        dp[i][x] = dp[i][y] = (dp[i][x]+dp[i][y])*t;\n        dp[x][i] = dp[y][i] = (dp[x][i]+dp[y][i])*t;\n      }\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y]+dp[y][x])*t;\n  }\n\n  mint ans = 0;\n  REP(i,n) FOR(j,i+1,n) ans += dp[i][j];\n\n  REP(_,q) ans *= 2;\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <iostream>\n\nconst long int mod = 1e9+7;\nlong int MOD(long int x){\n  return x%mod;\n}\nlong int Ntimes2(long int x, int n){\n  for(int i = 0; i< n; i++){\n    //std::cerr << \"i= \" << i;\n    x = (x*2)%mod;\n  }\n  return x;\n}\n\nint main(){\n  \n  /* read input */\n  long int N;\n  long int Q;\n  long int tmp1, tmp2;\n  std::vector<long int> A;\n  std::vector<long int> X;\n  std::vector<long int> Y;\n  \n  scanf(\"%ld\", &N);\n  scanf(\"%ld\", &Q);\n  \n  for(int i = 0; i < N; i++){\n    scanf(\"%ld\", &tmp1);\n    A.push_back(tmp1);\n  }\n  for(int i = 0; i < Q; i++){\n    scanf(\"%ld %ld\", &tmp1, &tmp2);\n    // X<Y\n    X.push_back(tmp1-1);\n    Y.push_back(tmp2-1);\n  }\n  \n  std::cerr << \"Input : done \" << std::endl;\n  for(int i = 0; i < N; i++){\n    std::cerr << A[i] << \" \";\n  }std::cerr << std::endl;\n  for(int i = 0; i < Q; i++){\n    std::cerr << \"(\" << X[i] << \",\" << Y[i] << \") \";\n  }std::cerr << std::endl;\n  std::cerr << \"start to solve problem\" << std::endl;\n  // solve problem\n  long int P[N][N][2][2];\n  \n  // initialize table\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < N; j++){\n      P[i][j][0][0] = P[i][j][1][0] = 0;\n      P[i][j][0][1] = P[i][j][1][1] = 0;\n      if(A[i] < A[j]){\n        P[i][j][0][0] = 1;\n      }\n      else if(A[i] > A[j]){\n        P[i][j][1][0] = 1;\n      }\n    }\n  }\n  std::cerr << \"intialized P : done\" << std::endl;\n  /*for(int i = 0; i < N; i++){\n    for(int j = 0; j < N; j++){\n      std::cerr << P[i][j][0][0] << \" \";\n    }std::cerr << std::endl;\n  }*/\n  \n  // update table\n  for(int q = 0; q < Q; q++){\n    \n    //std::cerr << \"q = \" << q << std::endl;\n    \n    P[X[q]][Y[q]][0][0] = MOD(P[X[q]][Y[q]][0][0]*Ntimes2(1, q-P[X[q]][Y[q]][0][1]) + P[Y[q]][X[q]][0][0]*Ntimes2(1, q-P[Y[q]][X[q]][0][1]));\n    P[X[q]][Y[q]][0][1] = q+1;\n    \n    P[Y[q]][X[q]][0][0] = P[X[q]][Y[q]][0][0];\n    P[Y[q]][X[q]][0][1] = q+1;\n    \n    P[X[q]][Y[q]][1][0] = MOD(P[X[q]][Y[q]][1][0]*Ntimes2(1, q-P[X[q]][Y[q]][1][1]) + P[Y[q]][X[q]][1][0]*Ntimes2(1, q-P[Y[q]][X[q]][1][1]));\n    P[X[q]][Y[q]][1][1] = q+1;\n    \n    P[Y[q]][X[q]][1][0] = P[X[q]][Y[q]][1][0];\n    P[Y[q]][X[q]][1][1] = q+1;\n    \n    for(int i = 0; i < N; i++){\n     \n      if((i != X[q]) && (i != Y[q])){\n        //std::cerr << i << \"\\n\";\n        P[X[q]][i][0][0] = MOD(P[X[q]][i][0][0]*Ntimes2(1, q-P[X[q]][i][0][1]) + P[Y[q]][i][0][0]*Ntimes2(1, q-P[Y[q]][i][0][1]));\n        P[X[q]][i][0][1] = q+1;\n        \n        P[Y[q]][i][0][0] = P[X[q]][i][0][0];\n        P[Y[q]][i][0][1] = q+1;\n      \n        P[i][X[q]][0][0] = MOD(P[i][X[q]][0][0]*Ntimes2(1, q-P[i][X[q]][0][1]) + P[i][Y[q]][0][0]*Ntimes2(1, q-P[i][Y[q]][0][1]));\n        P[i][X[q]][0][1] = q+1;\n        \n        P[i][Y[q]][0][0] = P[i][X[q]][0][0];\n        P[i][Y[q]][0][1] = q+1;\n      \n        P[X[q]][i][1][0] = MOD(P[X[q]][i][1][0]*Ntimes2(1, q-P[X[q]][i][1][1]) + P[Y[q]][i][1][0]*Ntimes2(1, q-P[Y[q]][i][1][1]));\n        P[X[q]][i][1][1] = q+1;\n        \n        P[Y[q]][i][1][0] = P[X[q]][i][1][0];\n        P[Y[q]][i][1][1] = q+1;\n      \n        P[i][X[q]][1][0] = MOD(P[i][X[q]][1][0]*Ntimes2(1, q-P[i][X[q]][1][1]) + P[i][Y[q]][1][0]*Ntimes2(1, q-P[i][Y[q]][1][1]));\n        P[i][X[q]][1][1] = q+1;\n        \n        P[i][Y[q]][1][0] = P[i][X[q]][1][0];\n        P[i][Y[q]][1][1] = q+1;\n      }\n    }\n    /*\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < N; j++){\n        std::cerr << P[i][j][0][0] << \" \";\n      }std::cerr << std::endl;\n    }\n     */\n  }\n  std::cerr << \"calculate table P : done\" << std::endl;\n  \n  // calculate inverse sum\n  int inverse_sum = 0;\n  for(int i = 0; i < N; i++){\n    for(int j = i+1; j < N; j++){\n      inverse_sum += P[i][j][1][0] * Ntimes2(1, Q-P[i][j][1][1]);\n      inverse_sum = MOD(inverse_sum);\n    }\n  }\n  printf(\"%d\", inverse_sum);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define MAXN 3010\n#define MOD 1000000007\n#define INV 500000004\ninline void trim(int &x) { (x >= MOD) && (x -= MOD); }\ninline void up(int &x, int y) { trim(x += y); }\nint n, q, b = 1, ans = 0, a[MAXN], f[MAXN][MAXN];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tf[i][j] = a[i] > a[j];\n\t\t}\n\t}\n\tfor (int x, y; q; q--) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i != x && i != y) {\n\t\t\t\tf[i][x] = f[i][y] = 1LL * INV * (f[i][x] + f[i][y]) % MOD;\n\t\t\t\tf[x][i] = f[y][i] = 1LL * INV * (f[x][i] + f[y][i]) % MOD;\n\t\t\t}\n\t\t}\n\t\tf[x][y] = f[y][x] = 1LL * INV * (f[x][y] + f[y][x]) % MOD;\n\t\ttrim(b <<= 1);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tup(ans, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", 1LL * ans * b % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=1e9+7;\nLL n,q,a[3010],Q;\nLL f[3010][3010];\nLL fp(LL a,LL b)\n{\n\tLL ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn ans;\n}\nconst LL inv=fp(2,mod-2);\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&q);Q=q;\n\tfor(LL i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tfor(LL i=1;i<=n;i++)\n\t\tfor(LL j=1;j<=n;j++) f[i][j]=(a[i]<a[j]);\n\twhile(q--)\n\t{\n\t\tLL x,y;scanf(\"%lld %lld\",&x,&y);\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv%mod;\n\t\tfor(LL i=1;i<=n;i++)\n\t\t\tif(i!=x&&i!=y)\n\t\t\t{\n\t\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*inv%mod;\n\t\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])*inv%mod;\n\t\t\t}\n\t}\n\tLL ans=0;\n\tfor(LL i=1;i<=n;i++)\n\t\tfor(LL j=1;j<i;j++) (ans+=f[i][j])%=mod;\n\t(ans*=fp(2,Q))%=mod;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007,inv_2=(mod+1)/2;\ntypedef long long ll;\nconst int N=3010;\nint f[N][N],g[N][N],a[N],b[N],n,q,pw=1,ans;\n\nint main(){\n#ifdef ONLINE_JUDGE\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#endif\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=(a[i]<a[j]);\n\tfor(int i=1;i<=q;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(int j=1;j<=n;++j)b[j]=j;swap(b[x],b[y]);\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tg[x][j]=(ll)(f[b[x]][b[j]]+f[x][j])*inv_2%mod;\n\t\t\tg[j][x]=(ll)(f[b[j]][b[x]]+f[j][x])*inv_2%mod;\n\t\t\tg[y][j]=(ll)(f[b[y]][b[j]]+f[y][j])*inv_2%mod;\n\t\t\tg[j][y]=(ll)(f[b[j]][b[y]]+f[j][y])*inv_2%mod;\n\t\t}\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tf[x][j]=g[x][j];\n\t\t\tf[j][x]=g[j][x];\n\t\t\tf[y][j]=g[y][j];\n\t\t\tf[j][y]=g[j][y];\n\t\t}\n\t\tpw=(pw+pw)%mod;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tans=(ans+(ll)pw*f[i][j])%mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint a[3005], x[3005], y[3005];\nint table[3005][3005];\n\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, q) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tint ans = 0;\n\n\trep(i, n) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (a[i] < a[j])table[i][j] = 1;\n\t\t\tif (a[i] > a[j])table[j][i] = 1;\n\t\t}\n\t}\n\n\tint inv2 = modpow(2, mod - 2);\n\n\trep(k, q) {\n\t\t//x[i]とy[i]をswap\n\t\trep(l, n) {//(x,l)->(y,l)\n\t\t\tif (x[k] == l || y[k] == l)continue;\n\t\t\ttable[x[k]][l] = table[x[k]][l] * inv2 % mod;\n\t\t\ttable[y[k]][l] = table[y[k]][l] * inv2 % mod;\n\t\t\ttable[l][x[k]] = table[l][x[k]] * inv2 % mod;\n\t\t\ttable[l][y[k]] = table[l][y[k]] * inv2;\n\t\t\tint p1 = table[x[k]][l], p2 = table[y[k]][l], p3 = table[l][x[k]], p4 = table[l][y[k]];\n\t\t\ttable[x[k]][l] = (table[x[k]][l] + p2) % mod;\n\t\t\ttable[y[k]][l] = (table[y[k]][l] + p1) % mod;\n\t\t\ttable[l][x[k]] = (table[l][x[k]] + p4) % mod;\n\t\t\ttable[l][y[k]] = (table[l][y[k]] + p3) % mod;\n\t\t}\n\t\ttable[x[k]][y[k]] = table[x[k]][y[k]] * inv2 % mod;\n\t\ttable[y[k]][x[k]] = table[y[k]][x[k]] * inv2 % mod;\n\t\tint p1 = table[y[k]][x[k]], p2 = table[x[k]][y[k]];\n\t\ttable[x[k]][y[k]] = (table[x[k]][y[k]] + p1) % mod;\n\t\ttable[y[k]][x[k]] = (table[y[k]][x[k]] + p2) % mod;\n\t}\n\tint r = 0;\n\trep(k, n) {\n\t\tfor (int l = 0; l < k; l++) {\n\t\t\tr += table[k][l];\n\t\t}\n\t}\n\tans += r;\n\n\tcout << ans*modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=3010,MaxQ=3010,mod=1000000007,I2=mod+1>>1;\nint N,Q,A[MaxN],X[MaxQ][2],tmp[MaxN],nxt[MaxQ][2],f[MaxQ][MaxQ],g[MaxQ][MaxN];\nint main(){\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(int i=1;i<=N;i++)scanf(\"%d\",A+i),tmp[i]=-1;\n\tfor(int i=0;i<Q;i++)scanf(\"%d%d\",X[i],X[i]+1);\n\tfor(int i=Q;i--;){\n\t\tfor(int j=2;j--;)nxt[i][j]=tmp[X[i][j]],tmp[X[i][j]]=i;\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tfor(int k=2;k--;)g[i][j]=(g[i][j]+(nxt[i][k]==-1?(X[i][k]<j):g[nxt[i][k]][j]))%mod;\n\t\t\tg[i][j]=1ll*g[i][j]*I2%mod;\n\t\t}\n\t}\n\tfor(int i=Q;i--;)for(int j=Q;j-->i;){\n\t\tif(i==j)f[i][j]=I2;\n\t\telse{\n\t\t\tfor(int k=2;k--;){\n\t\t\t\tif(nxt[i][k]==-1)f[i][j]=(f[i][j]+(mod+1-g[j][X[i][k]]))%mod;\n\t\t\t\telse if(nxt[i][k]<=j)f[i][j]=(f[i][j]+f[nxt[i][k]][j])%mod;\n\t\t\t\telse f[i][j]=(f[i][j]+(mod+1-f[j][nxt[i][k]]))%mod;\n//\t\t\t\tf[i][j]=(f[i][j]+(nxt[i][k]==-1?g[j][X[i][k]]:f[nxt[i][k]][j]))%mod,printf(\"i=%d j=%d k=%d nxt=%d %d\\n\",i,j,k,nxt[i][k],(nxt[i][k]==-1?g[j][X[i][k]]:f[nxt[i][k]][j]));\n\t\t\t}\n\t\t\tf[i][j]=1ll*f[i][j]*I2%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=N;i++)for(int j=i+1;j<=N;j++)if(A[i]!=A[j]){\n\t\tint t=0;\n\t\tif(tmp[i]==-1){\n\t\t\tif(tmp[j]==-1)t=1;\n\t\t\telse t=(mod+1-g[tmp[j]][i])%mod;\n\t\t}\n\t\telse if(tmp[j]==-1)t=g[tmp[i]][j]%mod;\n\t\telse t=tmp[i]<tmp[j]?f[tmp[i]][tmp[j]]:(mod+1-f[tmp[j]][tmp[i]])%mod;//,printf(\"f(%d,%d)=%lld\\n\",tmp[j],tmp[i],f[tmp[j]][tmp[i]]*(1ll<<Q)%mod);\n\t\tif(A[i]<A[j])t=(mod+1-t)%mod;\n\t\tans=(ans+t)%mod;\n\t\t//printf(\"i=%d j=%d ans=%lld\\n\",i,j,t*(1ll<<Q)%mod);\n\t}\n\tfor(int i=Q;i--;)ans=ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\tfix(s+=s);\n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*iv%mod;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3030, mod = 1e9 + 7;\n\nint a[N][N];\nint b[N][N];\nint s[N];\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint main() {\n  int n, q;\n  scanf(\"%d %d\", &n, &q);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", s+i);\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j < n; ++j) {\n      if (s[i] < s[j])\n        b[i][j] = 1;\n      if (s[i] > s[j])\n        a[i][j] = 1;\n    }\n  }\n  int inv2 = (mod + 1) / 2;\n  for (int it = 0; it < q; ++it) {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    --l, --r;\n    if (l > r)\n      swap(l, r);\n    for (int i = 0; i < l; ++i) {\n      a[i][l] = a[i][r] = 1LL * (a[i][l] + a[i][r]) * inv2 % mod;\n      b[i][l] = b[i][r] = 1LL * (b[i][l] + b[i][r]) * inv2 % mod;\n    }\n    for (int i = l+1; i < r; ++i) {\n      a[l][i] = b[i][r] = 1LL * (a[l][i] + b[i][r]) * inv2 % mod;\n      a[i][r] = b[l][i] = 1LL * (b[l][i] + a[i][r]) * inv2 % mod;\n    }\n    for (int i = r+1; i < n; ++i) {\n      a[l][i] = a[r][i] = 1LL * (a[l][i] + a[r][i]) * inv2 % mod;\n      b[l][i] = b[r][i] = 1LL * (b[l][i] + b[r][i]) * inv2 % mod;\n    }\n    a[l][r] = b[l][r] = 1LL * (a[l][r] + b[l][r]) * inv2 % mod;\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j < n; ++j) {\n      ans = (ans + a[i][j]) % mod;\n    }\n  }\n  ans = ans * powmod(2, q) % mod;\n  if (ans < 0) ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 3003; \nmint dp[2][N][N];\nmint tmp[2][N][N];\n#define rep(i) for(int i=0;i<2;i++)\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (auto& x: a) {\n        cin >> x;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (a[i] > a[j]) dp[0][i][j] = 1;\n            if (a[i] == a[j])dp[1][i][j] = 1;\n        }\n    }\n    auto flip = [&](int& x, int& y){\n        dp[0][x][y] = 1 - dp[0][x][y] - dp[1][x][y];\n    };\n    mint half = mint(1)/2;\n    for (int _ = 0; _ < q; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if (x > y) swap(x, y);\n        //memcpy(tmp, dp, sizeof tmp);\n        for (int i = 0; i < x; i++) {\n            rep(_) {\n                //swap(dp[_][i][x], dp[_][i][y]);\n                //(dp[_][i][x] += tmp[_][i][x]) *= half;\n                //(dp[_][i][y] += tmp[_][i][y]) *= half;\n                dp[_][i][x] = dp[_][i][y] = (dp[_][i][x] + dp[_][i][y]) * half;\n            }\n        }\n        //flip(x, y);\n        //rep(_)(dp[_][x][y] += tmp[_][x][y]) *= half;\n        dp[0][x][y] = (1-dp[1][x][y])*half;\n        for (int i = x+1; i < y; i++) {\n            //swap(dp[0][x][i], dp[0][i][y]);\n            //swap(dp[1][x][i], dp[1][i][y]);\n            //flip(x, i);\n            //flip(i, y);\n            //rep(_) {\n            //    (dp[_][x][i] += tmp[_][x][i]) *= half;\n            //    (dp[_][i][y] += tmp[_][i][y]) *= half;\n            //}\n            mint xi = dp[0][x][i] + (1 - dp[1][i][y] - dp[0][i][y]);\n            mint iy = dp[0][i][y] + (1 - dp[1][x][i] - dp[0][x][i]);\n            dp[0][x][i] = xi * half;\n            dp[0][i][y] = iy * half;\n            dp[1][x][i] = dp[1][i][y] = (dp[1][x][i] + dp[1][i][y]) * half;\n        }\n        for (int i = y+1; i < n; i++) {\n            rep(_) {\n                //swap(dp[_][x][i], dp[_][y][i]);\n                //(dp[_][x][i] += tmp[_][x][i]) *= half;\n                //(dp[_][y][i] += tmp[_][y][i]) *= half;\n                dp[_][x][i] = dp[_][y][i] = (dp[_][x][i] + dp[_][y][i]) * half;\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            res += dp[0][i][j];\n        }\n    }\n    res *= mint(2).exp(q);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nusing P = Pa<int,int>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q;\n    cin >> N >> Q;\n    vec<int> A(N);\n    for(int i=0;i<N;i++) cin >> A[i];\n    vvec<mint> dp(N,vec<mint>(N));\n\n    for(int i=0;i<N;i++) for(int j=0;j<N;j++) if(A[i]<=A[j]) dp[i][j] = 1;\n    mint inv2 = ((mint) (2)).inv();\n    for(int _=0;_<Q;_++){\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if(x>y) swap(x,y);\n        vec<mint> dpx(N,1),dpy(N,1);\n        vec<mint> dp_x(N,1),dp_y(N,1); \n        for(int i=0;i<N;i++){\n            if(i!=x && i!=y){\n                dpx[i] = (dp[x][i]+dp[y][i])*inv2;\n                dp_x[i] = (dp[i][x]+dp[i][y])*inv2;\n            }\n            if(i!=x && i!=y){\n                dpy[i] = (dp[y][i]+dp[x][i])*inv2;\n                dp_y[i] = (dp[i][x]+dp[i][y])*inv2;\n            }\n        }\n        dpx[y] = (dp[x][y]+dp[y][x])*inv2;\n        dpy[x] = (dp[x][y]+dp[y][x])*inv2;\n        dp[x].swap(dpx);\n        dp[y].swap(dpy);\n        for(int i=0;i<N;i++) if(i!=x && i!=y){\n            dp[i][x] = dp_x[i];\n            dp[i][y] = dp_y[i];\n        }\n    }\n    mint ans = 0;\n//    for(int i=0;i<N;i++) for(int j=0;j<N;j++) cerr << dp[i][j] << (j!=N-1? \" \":\"\\n\");\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++) ans += ((mint) 1-dp[i][j]);\n    cout << ans*((mint) 2).pow(Q) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//4182_543_731 is vegetable\n#include<cstdio>\nusing namespace std;\n#define N 3005\n#define mod 1000000007\n#define inv 500000004\nint n,dp[N][N],v[N],q,a,b;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)dp[i][j]=(v[i]<v[j]);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint tp=dp[a][b]+dp[b][a];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tdp[j][a]=dp[j][b]=1ll*(dp[j][a]+dp[j][b])*inv%mod;\n\t\t\tdp[a][j]=dp[b][j]=1ll*(dp[a][j]+dp[b][j])*inv%mod;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=1ll*tp*inv%mod;\n\t}\n\tint as=0;\n\tfor(int i=2;i<=n;i++)\n\tfor(int j=1;j<i;j++)as=(as+dp[i][j])%mod;\n\tfor(int i=1;i<=q;i++)as=as*2%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int mod=1000000007;\n\nint a[3010],x[3010],y[3010],pw2[3010];\nint g[3010][3010],dp[3010][3010];\n\nint main()\n{\n\tint n,q;scanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=q;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tg[i][j]=q;\n\t\t\tdp[i][j]=i<j ? 1 : 0;\n\t\t}\n\tpw2[0]=1;for (int i=1;i<=n;i++) pw2[i]=pw2[i-1]*2%mod;\n\tfor (int i=q;i;i--)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tint t=(ll(dp[x[i]][j])*pw2[g[x[i]][j]-i]+ll(dp[y[i]][j])*pw2[g[y[i]][j]-i])%mod;\n\t\t\t\tdp[x[i]][j]=dp[y[i]][j]=t;\n\t\t\t\tg[x[i]][j]=g[y[i]][j]=i-1;\n\t\t\t}\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tint t=(ll(dp[j][x[i]])*pw2[g[j][x[i]]-i]+ll(dp[j][y[i]])*pw2[g[j][y[i]]-i])%mod;\n\t\t\t\tdp[j][x[i]]=dp[j][y[i]]=t;\n\t\t\t\tg[j][x[i]]=g[j][y[i]]=i-1;\n\t\t\t}\n\t\tint t=(ll(dp[x[i]][y[i]])*pw2[g[x[i]][y[i]]-i]+ll(dp[y[i]][x[i]])*pw2[g[y[i]][x[i]]-i])%mod;\n\t\tdp[x[i]][y[i]]=dp[y[i]][x[i]]=t;\n\t\t//printf(\"%d\\n\",t);\n\t\tg[x[i]][y[i]]=g[y[i]][x[i]]=i-1;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (a[i]<a[j]) ans=(ll(dp[j][i])*pw2[g[j][i]]+ans)%mod; else if (a[i]>a[j]) ans=(ll(dp[i][j])*pw2[g[i][j]]+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tK = power(2, M, MOD);\n\tvector<vector<long long int>>dp(N, vector<long long int>(N, 0));\n\tvector<vector<long long int>>ch(N, vector<long long int>(N, 0));\n\tvector<long long int>rev_by(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\trev_by[i] = rev_by[i] * power(2, MOD - 2, MOD);\n\t\trev_by[i] %= MOD;\n\t}\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (v[i] > v[j])dp[i][j] = K;\n\t\t\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tlong long int sum = dp[L][j] + dp[R][j];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[R][j] = ch[L][j] = sum;\n\t\t\tsum = dp[j][L] + dp[j][R];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[j][R] = ch[j][L] = sum;\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tdp[R][j] = dp[L][j] = ch[L][j];\n\t\t\tdp[j][R] = dp[j][L] = ch[j][L];\n\t\t}\n\t\tdp[L][R] = dp[R][L] = ((dp[L][R] + dp[R][L])*rev_by[1]) % MOD;\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tcerr << dp[k][j] << \" \";\n\t\t\t}\n\t\t\tcerr << endl;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++)ans += dp[i][j];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\tcout << ans % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tK = power(2, M, MOD);\n\tvector<vector<long long int>>dp(N, vector<long long int>(N, 0));\n\tvector<vector<long long int>>ch(N, vector<long long int>(N, 0));\n\tvector<long long int>rev_by(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\trev_by[i] = rev_by[i] * power(2, MOD - 2, MOD);\n\t\trev_by[i] %= MOD;\n\t}\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (v[i] > v[j])dp[i][j] = K;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tlong long int sum = dp[L][j] + dp[R][j];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[R][j] = ch[L][j] = sum;\n\t\t\tsum = dp[j][L] + dp[j][R];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[j][R] = ch[j][L] = sum;\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tdp[R][j] = dp[L][j] = ch[L][j];\n\t\t\tdp[j][R] = dp[j][L] = ch[j][L];\n\t\t}\n\t\tdp[L][R] = dp[R][L] = ((dp[L][R] + dp[R][L])*rev_by[1]) % MOD;\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++)ans += dp[i][j];\n\t}\n\tcout << ans % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (3010)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,f[N][N],inv2,a[N],ans;\nint ksm(int a,int p){\n\tint res=1;\n\twhile(p){\n\t\tif(p&1)res=1ll*res*a%P;\n\t\ta=1ll*a*a%P,p>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tread(n),read(m),inv2=ksm(2,P-2);\n\tfor(int i=1;i<=n;i++)read(a[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tf[i][j]=(int)(a[i]>a[j]);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y; read(x),read(y);\n//\t\tif(x>y)swap(x,y);\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%P;\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(j!=x&&j!=y){\n\t\t\tf[x][j]=f[y][j]=1ll*(f[x][j]+f[y][j])*inv2%P;\n\t\t\tf[j][x]=f[j][y]=1ll*(f[j][y]+f[j][x])*inv2%P;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++)\n\t(ans+=f[i][j])%=P;\n\tprintf(\"%lld\\n\",1ll*ans*ksm(2,m)%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mk make_pair\n#define ll long long\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 3010;\nconst int mod = 1e9+7;\n\nint qsm(int i,int j)\n{\n\tint ans=1;\n\twhile (j)\n\t{\n\t\tif (j&1) ans=ans*i%mod;\n\t\tj>>=1;\n\t    i=i*i%mod;\n\t}\n\treturn ans;\n}\n\nint dp[maxn][maxn];\nint n,m;\nint q;\nint a[maxn];\n\nsigned main()\n{\n   scanf(\"%lld%lld\",&n,&m);\n   for (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);//a[i]=read();\n   for (int i=1;i<=n;i++)\n     for (int j=1;j<=n;j++)\n       dp[i][j]=(a[i]>a[j]);\n   int inv = qsm(2,mod-2);\n   for (int i=1;i<=m;i++)\n   {\n   \t  int x,y;\n   \t  scanf(\"%lld%lld\",&x,&y);\n   \t  dp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv%mod;\n   \t  for (int i=1;i<=n;i++)\n   \t  {\n   \t  \tif (i!=x && i!=y)\n   \t  \t{\n   \t  \t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*inv%mod;\n   \t  \t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*inv%mod;\n\t\t}\n\t  }\n   }\n   int ans=0;\n   for (int i=1;i<=n;i++)\n     for (int j=1;j<=n;j++)\n        ans=(ans+dp[i][j])%mod;\n   cout<<ans*qsm(2,m)%mod*inv%mod;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\nconst int mod= 1e9+7;\nmap<pair<ll,vector<ll>>, ll> dp;\nmap <vector<ll>,ll> inver;\nll q, n, *x=NULL, *y=NULL;\n\nll inversion_num(vector<ll> v){\n\tif(inver.count(v)){return inver[v];}\n\tll inv=0;\n\tfor(int i=0; i<n-1; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\tif(v[i] > v[j]){inv++;}\n\t\t}\n\t}\n\tinv %=mod;\n\treturn inver[v]=inv;\n}\n\nll func(ll i, vector<ll> v){\n\t//base case\n\tif(i==q){\n\t\treturn inversion_num(v);\n\t}\n\t//recusive case\n\tif(dp.count(make_pair(i,v))){ return dp[make_pair(i,v)];}\n\tll ans= func(i+1, v);\n\tswap(v[x[i]-1], v[y[i]-1]);\n\tans += func(i+1, v)%mod;\n\tans %= mod;\n\t//swap(v[x[i]], v[y[i]]);\n\treturn dp[make_pair(i,v)] = ans;\n}\n\n\n\nint main(){\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\tcin>>n>>q;\n\tvector<ll> v(n,0);\n\tfor(int i=0; i<n; i++){\n\t\tcin>>v[i];\n\t}\n\tx = new ll[q];\n\ty = new ll[q];\n\tfor(int i=0; i<q; i++){\n\t\tcin>>x[i]>>y[i];\n\t}\n\tcout<<func(0, v)<<endl;\n\t// for(auto x:dp){\n\t// \tcout<<x.first.first<<\" :\";\n\t// \tfor(auto y:x.first.second){\n\t// \t\tcout<<y<<\" \";\n\t// \t}\n\t// \tcout<<\" :: \"<<x.second<<endl;\n\t// }\n\t// for(auto w:inver){\n\t// \tfor(auto e:w.first){\n\t// \t\tcout<<e<<\" \";\n\t// \t}\n\t// \tcout<<\" :\"<<w.second<<endl;\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\n#include<bitset>\n#define int long long\n#define lowbit(x) ((x)&(-x))\nusing namespace std;\nconst int maxn=3005,mod=1e9+7,niyuan=5e8+4;\nint n,q,dp[maxn][maxn],a[maxn],ans;\ninline int read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n\t\tif(ch=='-')\n\t\t\tf=-1;\n\t\tch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n    }\n    return x*f;\n}\ninline void write(int a)\n{\n    if(a<0)\n    {\n\t\tputchar('-');\n\t\tputchar('1');\n    }\n    else\n    {\n\t\tif(a>=10)\n\t\t\twrite(a/10);\n\t\tputchar(a%10+'0');\n    }\n}\nsigned main()\n{\n\tn=read(),q=read();\n\tint tmp=1;\n\tfor(int i=1;i<=q;++i)\n\t\ttmp=tmp*2%mod;\n\tfor(int i=1;i<=n;++i)\n\t\ta[i]=read();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tdp[i][j]=tmp*(a[i]>a[j]);\n//\tfor(int i=1;i<=n;++i,cout<<endl)\n//\t\tfor(int j=1;j<=n;++j)\n//\t\t\tcout<<dp[i][j]<<' ';\n\twhile(q--)\n\t{\n\t\tint x=read(),y=read();\n\t\tif(x>y)\n\t\t\tswap(x,y);\n\t\tint xi[maxn],yi[maxn],ix[maxn],iy[maxn];\n\t\tfor(int i=1;i<=n;++i)\n\t\t\txi[i]=dp[x][i],yi[i]=dp[y][i],ix[i]=dp[i][x],iy[i]=dp[i][y];\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(i!=x&&i!=y)\n\t\t\t{\n\t\t\t\tdp[i][x]=ix[i]*niyuan%mod+iy[i]*niyuan%mod;\n\t\t\t\tdp[i][y]=ix[i]*niyuan%mod+iy[i]*niyuan%mod;\n\t\t\t\tdp[x][i]=xi[i]*niyuan%mod+yi[i]*niyuan%mod;\n\t\t\t\tdp[y][i]=xi[i]*niyuan%mod+yi[i]*niyuan%mod;\n\t\t\t}\n\t\tdp[y][x]=dp[x][y]=xi[y]*niyuan%mod+yi[x]*niyuan%mod;\n//\t\tfor(int i=1;i<=n;++i,cout<<endl)\n//\t\t\tfor(int j=1;j<=n;++j)\n//\t\t\t\tcout<<dp[i][j]<<' ';\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tans=(ans+dp[i][j])%mod;\n\twrite(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define ch() getchar()\n#define pc(x) putchar(x)\ntemplate<typename T>inline void read(T&x){\n\tint f;char c;\n\tfor(f=1,c=ch();c<'0'||c>'9';c=ch())if(c=='-')f=-f;\n\tfor(x=0;c<='9'&&c>='0';c=ch())x=x*10+(c&15);x*=f;\n}\ntemplate<typename T>inline void write(T x){\n\tstatic char q[64];int cnt=0;\n\tif(!x)pc('0');if(x<0)pc('-'),x=-x;\n\twhile(x)q[cnt++]=x%10+'0',x/=10;\n\twhile(cnt--)pc(q[cnt]);\n}\nconst int maxn=3005,mod=1000000007,inv2=500000004;\nint a[maxn],dp[maxn][maxn];\nint mo(const int x){return x>=mod?x-mod:x;}\nint main(){\n\tint n,q;\n\tread(n),read(q);\n\tfor(int i=1;i<=n;++i)\n\t\tread(a[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tdp[i][j]=(a[i]>a[j]);\n\t\t}\n\t}\n\tint tmp=1;\n\twhile(q--){\n\t\tint u,v;tmp=mo(tmp<<1);\n\t\tread(u),read(v);\n\t\tdp[u][v]=dp[v][u]=1ll*mo(dp[u][v]+dp[v][u])*inv2%mod;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(i==u||i==v)continue;\n\t\t\tdp[i][u]=dp[i][v]=1ll*mo(dp[i][u]+dp[i][v])*inv2%mod;\n\t\t\tdp[u][i]=dp[v][i]=1ll*mo(dp[u][i]+dp[v][i])*inv2%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tans=mo(ans+dp[i][j]);\n\t\t}\n\t}\n\twrite(1ll*ans*tmp%mod),pc('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n    int n, q, x, y, a;\n    cin >> n >> q;\n    int sum = 0;\n    for (int i = 0; i < n; i++){\n        cin >> a;\n        sum += a;\n    }\n    for (int i = 0; i < q; i++){\n        cin >> x >> y;\n    }\n    cout << sum % (1000000000 + 7) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\nusing namespace std;\nconst int N=3005,mod=1e9+7,inv2=5e8+4;\nint n,Q,a[N],f[N][N],ans,p;\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\trep (i,1,n) rep (j,1,n) f[i][j]=a[i]>a[j];\n\tp=1;\n\twhile (Q--){\n\t\tint x,y; scanf(\"%d%d\",&x,&y); p=(p+p)%mod;\n\t\tif (x>y) swap(x,y); if (x==y) continue;\n\t\trep (i,1,n) if (x!=i&&y!=i){\n\t\t\tint v=(f[x][i]+f[y][i])%mod;\n\t\t\tf[x][i]=f[y][i]=(ll)v*inv2%mod;\n\t\t\tv=(f[i][x]+f[i][y])%mod;\n\t\t\tf[i][x]=f[i][y]=(ll)v*inv2%mod;\n\t\t}\n\t\tint v=(f[x][y]+f[y][x])%mod;\n\t\tf[x][y]=f[y][x]=(ll)v*inv2%mod;\n\t}\n\trep (i,1,n) rep (j,i+1,n) (ans+=f[i][j])%=mod;\n\tprintf(\"%lld\\n\",(ll)ans*p%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for (ll i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nlong long inv_mod(long long n, long long mod) {\n    long long a = n % mod, b = mod - 2, ret = 1;\n    while (b > 0) {\n        if (b & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nconst ll MOD = 1000000007LL;\nll N,Q;\nll A[3010];\nll X[3010];\nll Y[3010];\n\nll dp[3010][3010];\n\nint main ()\n{\n    cin >> N >> Q;\n    REP(i,N) cin >> A[i];\n    REP(i,Q) cin >> X[i] >> Y[i];\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = (A[i] > A[j]);\n        }\n    }\n\n    for (int i = 0; i < Q; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (X[i] != j && Y[i] != j) {\n                dp[X[i]][j] = dp[Y[i]][j] = ((dp[X[i]][j] + dp[Y[i]][j]) * inv_mod(2LL, MOD) % MOD);\n                dp[j][X[i]] = dp[j][Y[i]] = ((dp[j][X[i]] + dp[j][Y[i]]) * inv_mod(2LL, MOD) % MOD);\n            }\n        }\n        dp[X[i]][Y[i]] = dp[Y[i]][X[i]] = ((dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv_mod(2LL, MOD) % MOD);\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            ans += dp[i][j] * pow_mod(2LL, Q, MOD);\n            ans %= MOD;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nll dp[3333][3333];\n\nint main(){\n\t\n\tll n,m;cin >> n >> m;\n\tvector<ll> v(n);\n\tREP(i,n)cin >> v[i];\n\tREP(i,n)REP(j,n)if(v[i] < v[j])dp[i][j] = 1;\n\tll inv = mod_div(1, 2);\n\t\n\tREP(q,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tREP(i,n){\n\t\t\tif(i != a && i != b){\n\t\t\t\tll tmp = (dp[i][a] + dp[i][b]) % MOD * inv % MOD;\n\t\t\t\tdp[i][a] = dp[i][b] = tmp;\n\t\t\t\ttmp = (dp[a][i] + dp[b][i]) % MOD * inv % MOD;\n\t\t\t\tdp[a][i] = dp[b][i] = tmp;\n\t\t\t}\n\t\t}\n\t\tll tmp = (dp[a][b] + dp[b][a]) % MOD * inv % MOD;\n\t\tdp[a][b] = dp[b][a] = tmp;\n\t}\n\t\n\tll ans = 0;\n\tREP(i,n)REP(j,i)ans = (ans + dp[i][j]) % MOD;\n\tREP(i,m)ans = (ans * 2) % MOD;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2020-02-15 11:47:21\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst ll mod=(int)1e9+7;\nint an[3003],bn[3003],cn[3003],dp[2][3003][3003];\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,0,n) scanf(\"%d\",an+i);\n    rep(i,0,m) {\n        scanf(\"%d%d\",bn+i,cn+i);\n        --bn[i]; --cn[i];\n        if(bn[i]>cn[i]) swap(bn[i],cn[i]);\n    }\n    rep(i,0,n) rep(j,0,n) if(i != j){\n        if(an[i]>an[j]) dp[0][i][j]=1;\n    }\n    ll rtwo=powmod(2,mod-2,mod);\n    rep(i,0,m){\n        int a1=bn[i],a2=cn[i];\n        rep(j,0,n){\n            dp[1][a1][j] = rtwo * (dp[0][a1][j] + dp[0][a2][j]) % mod;\n            dp[1][j][a1] = rtwo * (dp[0][j][a1] + dp[0][j][a2]) % mod;\n            dp[1][a2][j] = rtwo * (dp[0][a2][j] + dp[0][a1][j]) % mod;\n            dp[1][j][a2] = rtwo * (dp[0][j][a2] + dp[0][j][a1]) % mod;\n        }\n        dp[1][a2][a1] = dp[1][a1][a2] = rtwo * (dp[0][a1][a2] + dp[0][a2][a1]) % mod;\n        rep(j,0,n){\n            dp[0][a1][j] = dp[1][a1][j];\n            dp[0][j][a1] = dp[1][j][a1];\n            dp[0][a2][j] = dp[1][a2][j];\n            dp[0][j][a2] = dp[1][j][a2];\n        }\n        dp[0][a1][a2] = dp[0][a2][a1] = dp[1][a2][a1];\n    }\n    ll sum = 0;\n    rep(i,0,n) rep(j,i+1,n) sum += dp[0][i][j];\n    sum %= mod;\n    sum = sum * powmod(2, m, mod) % mod;\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n #ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass DInversionSum {\npublic:\nvoid solve(istream& cin, ostream& cout) {\n    int N, Q; cin >> N >> Q;\n    vector<int> A(N); cin >> A;\n    vector<pii> X(Q); cin >> X;\n\n    vector2<FieldMod> I(N,N,0);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            I[i][j] = A[i] > A[j];\n        }\n    }\n\n    FieldMod inv = FieldMod{1} / 2;\n\n    for (pii&x:X) {\n        int a = x.x-1;\n        int b = x.y-1;\n        for (int j = 0; j < N; ++j) {\n            if (j != a && j != b) {\n                FieldMod f = I[j][a] + I[j][b];\n                f *= inv;\n                I[j][a] = I[j][b] = f;\n\n                FieldMod g = I[a][j] + I[b][j];\n                g *= inv;\n                I[a][j] = I[b][j] = g;\n            }\n        }\n\n        FieldMod f = I[a][b] + I[b][a];\n        f *= inv;\n        I[a][b] = I[b][a] = f;\n    }\n\n    FieldMod ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i+1; j < N; ++j) {\n            ans += I[i][j];\n        }\n    }\n    cout << ans * FieldMod{2}.pow(Q) << endl;\n}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDInversionSum solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long dp[4000][4000];\nint main(){\n\tint n, query;\n\tcin >> n >> query;\n\tvector<long long> geko;\n\tREP(i, n) {\n\t\tlong long a;\n\t\tcin >> a;\n\t\tgeko.push_back(a);\n\t}\n\tREP(i, n) {\n\t\tREP(q, n) {\n\t\t\tif (i != q) {\n\t\t\t\tdp[i][q] = (geko[i] > geko[q]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long nya = 1;\n\tfor (int i = 0; i < query; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tlong long hoge = dp[a][b] + dp[b][a];\n\t\thoge *= GYAKU;\n\t\thoge %= MAX_MOD;\n\t\tdp[a][b] = hoge;\n\t\tdp[b][a] = hoge;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (a == j || b == j) continue;\n\t\t\tlong long neko = dp[a][j] + dp[b][j];\n\t\t\tneko *= GYAKU;\n\t\t\tneko %= MAX_MOD;\n\t\t\tdp[a][j] = neko;\n\t\t\tdp[b][j] = neko;\n\t\t\tneko = dp[j][a] + dp[j][b];\n\t\t\tneko *= GYAKU;\n\t\t\tneko %= MAX_MOD;\n\t\t\tdp[j][a] = neko;\n\t\t\tdp[j][b] = neko;\n\t\t}\n\t\tnya *= 2LL;\n\t\tnya %= MAX_MOD;\n\t}\n\tlong long ans = 0;\n\tREP(i, n) {\n\t\tfor (int q = i+1; q < n; ++q) {\n\t\t\tans += dp[i][q] * nya;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int _ = 3e3 + 5, p = 1e9 + 7;\n\nint n, m, a[_], dp[_][_];\n\ninline int power(int x, int k) {\n    int res = 1;\n    for (; k; k >>= 1, x = 1ll * x * x % p)\n        if (k & 1) res = 1ll * res * x % p;\n    return res % p;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) dp[i][j] = a[i] < a[j];\n    int inv2 = power(2, p - 2);\n    for (int x, y, i = 1; i <= m; ++i) {\n        scanf(\"%d %d\", &x, &y);\n        dp[x][y] = dp[y][x] = 1ll * inv2 * ((dp[x][y] + dp[y][x]) % p) % p;\n        for (int j = 1; j <= n; ++j) {\n            if (j == x | j == y) continue ;\n            dp[x][j] = dp[y][j] = 1ll * inv2 * ((dp[x][j] + dp[y][j]) % p) % p;\n            dp[j][x] = dp[j][y] = 1ll * inv2 * ((dp[j][x] + dp[j][y]) % p) % p;\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) ans = (ans + dp[i][j]) % p;\n    ans = 1ll * ans * power(2, m) % p;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 1000000007;\nconstexpr ll modsize = 0;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nll dp[3010][3010];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> a(n);\n\trep(i, n) cin >> a[i];\n\trep(i, n) rep(j, n) if (a[i] > a[j]) dp[i][j] = 1;\n\tll inv2 = (mod + 1) / 2;\n\trep(_, q) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tdp[l][r] = dp[r][l] = (dp[l][r] + dp[r][l])*inv2%mod;\n\t\trep(i, n) {\n\t\t\tif (i != l && i != r) {\n\t\t\t\tdp[l][i] = dp[r][i] = (dp[l][i] + dp[r][i])*inv2%mod;\n\t\t\t\tdp[i][l] = dp[i][r] = (dp[i][l] + dp[i][r])*inv2%mod;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i, n) {\n\t\trep(j, i) {\n\t\t\tans += dp[j][i];\n\t\t\tif (ans > mod) ans -= mod;\n\t\t}\n\t}\n\tcout << ans * modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define mod 1000000007\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint ksm(int u, int v){\n\tint s = 1;\n\tfor(int i = v; i; i >>= 1){\n\t\tif(i & 1) s = 1ll * s * u % mod;\n\t\tu = 1ll * u * u % mod;\n\t}\n\treturn s;\n}\nint n, m, f[5001][5001], inv2, ans, a[5001], g[5001][5001];\nint main()\n{\n\tn = read(); m = read(); inv2 = 500000004;\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) f[i][j] = (a[i] > a[j]);\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tint x = read(), y = read();\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tg[x][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv2 % mod;\t\t\n\t\t\tg[j][x] = 1ll * (f[j][x] + f[j][y]) % mod * inv2 % mod;\n\t\t\tg[y][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv2 % mod;\n\t\t\tg[j][y] = 1ll * (f[j][y] + f[j][x]) % mod * inv2 % mod;\n\t\t}\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tf[x][j] = g[x][j]; f[j][x] = g[j][x];\n\t\t\tf[y][j] = g[y][j]; f[j][y] = g[j][y];\n\t\t}\n\t\tf[x][y] = 1ll * (f[x][y] + f[y][x]) % mod * inv2 % mod; f[y][x] = f[x][y];\n\t\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tans = (ans + f[i][j]) % mod;\n\tans = 1ll * ans * ksm(2, m) % mod; cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 3010\n#define mod 1000000007\n#define inv 500000004\nint f[N][N],a[N];\nint qpow(int base,int n)\n{\n\tif (!n) return 1;\n\tint ans=base%mod;--n;\n\twhile(n)\n\t{\n\t\tif (n&1) ans=1ll*ans*base%mod;\n\t\tbase=1ll*base*base%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\ninline int read(){\n\tint n=0;char a;bool z=false;\n\twhile(a=getchar())\n\t{\n\t\tif (a>'9'||a<'0')\n\t\t\tif (z) break;\n\t\t\telse continue;\n\t\tif (!z) z=true;\n\t\tn=(n<<1)+(n<<3)+(a^48);\n\t}\n\treturn n;\n}\nint main()\n{\n\tint n,Q,x,y,ans=0;\n\tscanf(\"%d%d\",&n,&Q);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tf[i][j]=a[i]>a[j];\n\tfor (int i=1;i<=Q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv%mod;\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif (j^x&&j^y)\n\t\t\t{\n\t\t\t\tf[j][x]=f[j][y]=1ll*(f[j][x]+f[j][y])*inv%mod;\n\t\t\t\tf[x][j]=f[y][j]=1ll*(f[x][j]+f[y][j])*inv%mod;\n\t\t\t}\n\t}\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<i;++j)\n\t\t\tans=(ans+f[j][i])>=mod?ans+f[j][i]-mod:ans+f[j][i];\n\tprintf(\"%lld\",1ll*ans*qpow(2,Q)%mod);\n\treturn 0;\n}\n\n//by qlwpc\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 3000, md = 1e9 + 7, i2 = md - md / 2;\nint bd[N + 1][N + 1], gd[N + 1][N + 1], x[N + 1];\n\nint main(){\n\tint i2 = md - md / 2;\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tf(i, 1, n + 1)scanf(\"%d\", x + i);\n\tf(i, 1, n + 1)f(j, i + 1, n + 1)bd[i][j] = x[i] > x[j];\n\tf(i, 1, n + 1)f(j, i + 1, n + 1)gd[i][j] = x[i] < x[j];\n\tf(i, 0, q){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tif (a > b)swap(a, b);\n\t\tf(i, 1, a)bd[i][a] = bd[i][b] = (ll)(bd[i][a] + bd[i][b]) * i2 % md;\n\t\tf(i, 1, a)gd[i][a] = gd[i][b] = (ll)(gd[i][a] + gd[i][b]) * i2 % md;\n\t\tf(i, a + 1, b){\n\t\t\tint ab = bd[a][i], ag = gd[a][i], bb = bd[i][b], bg = gd[i][b];\n\t\t\tbd[a][i] = (ll)(ab + bg) * i2 % md;\n\t\t\tgd[a][i] = (ll)(ag + bb) * i2 % md;\n\t\t\tbd[i][b] = (ll)(bb + ag) * i2 % md;\n\t\t\tgd[i][b] = (ll)(bg + ab) * i2 % md;\n\t\t}\n\t\tf(i, b + 1, n + 1)bd[a][i] = bd[b][i] = (ll)(bd[a][i] + bd[b][i]) * i2 % md;\n\t\tf(i, b + 1, n + 1)gd[a][i] = gd[b][i] = (ll)(gd[a][i] + gd[b][i]) * i2 % md;\n\t\tbd[a][b] = gd[a][b] = (ll)(bd[a][b] + gd[a][b]) * i2 % md;\n\t}\n\tint an = 0;\n\tf(i, 1, n + 1)f(j, i + 1, n + 1)if ((an += bd[i][j])>= md)an -= md;\n\tf(i, 0, q)if ((an <<= 1) >= md)an -= md;\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\nconst int INV2 = (MOD + 1) / 2;\n\nint dp[2005][2005];\nint n, p[2005];\nPII pinv[2005];\nint m, u[2005], v[2005];\nint cdp[2005];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep1(i, n) scanf(\"%d\", &p[i]);\n\trep(i, m) scanf(\"%d%d\", &u[i], &v[i]);\n\t\n\trep1(i, n) dp[i][i] = 1;\n\trep(i, m) rep1(j, n) {\n\t\tint cur = 1LL * (dp[j][u[i]] + dp[j][v[i]]) * INV2 % MOD;\n\t\tdp[j][u[i]] = dp[j][v[i]] = cur;\n\t}\n\t\n\trep1(i, n) pinv[i] = MP(p[i], i);\n\tsort(pinv + 1, pinv + n + 1);\n\tint ans = 0;\n\trep1(i, n) {\n\t\tint tot = 0;\n\t\tfor(int j = n; j >= 1; j --) {\n\t\t\tans = (ans + 1LL * (tot + 1LL * cdp[j] * INV2 % MOD) * dp[pinv[i].second][j]) % MOD;\n\t\t\ttot = (tot + cdp[j]) % MOD;\n\t\t}\n\t\tif(i == n || pinv[i].first != pinv[i + 1].first)\n\t\tfor(int i0 = i; i0 >= 0 && pinv[i0].first == pinv[i].first; i0 --)\n\t\trep1(j, n) cdp[j] = (cdp[j] + dp[pinv[i0].second][j]) % MOD;\n\t}\n\t\n\trep(i, m) ans = ans * 2 % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005;\nconst int mod = 1e9 + 7;\nconst int two = 5e8 + 4;\n\nvoid add(int& x,int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint mul(int x,int y) {\n\treturn (long long) x * y % mod;\n}\n\nint n, q;\nint a[N];\nint f[N][N];\nint nf[N][N];\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tf[i][j] = (a[i] > a[j]);\n\t\t}\n\t}\n\tfor (int it = 1; it <= q; ++it) {\n\t\tint x, y; \n\t\tscanf(\"%d %d\", &x, &y);\n\t\tif (x > y) swap(x, y);\n\t\tnf[x][y] = nf[y][x] = mul(two, f[x][y] + f[y][x]);\n\t\tfor (int i = 1; i <= n; ++i) if (i != x && i != y) {\n\t\t\tnf[i][x] = nf[i][y] = mul(two, f[i][x] + f[i][y]);\n\t\t\tnf[x][i] = nf[y][i] = mul(two, f[x][i] + f[y][i]);\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tf[i][x] = nf[i][x];\n\t\t\tf[x][i] = nf[x][i];\n\t\t\tf[i][y] = nf[i][y];\n\t\t\tf[y][i] = nf[y][i];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tadd(ans, f[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; ++i) {\n\t\tans = mul(ans, 2);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nnamespace IO\n{\n\tchar buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];\n\t#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)\n\t#define gt() getchar()\n\tinline int read()\n\t{\n\t\tint x = 0 , f = 1; char ch = gt();\n\t\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = gt();}\n\t\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}\n\t\treturn x * f;\n\t}\n\ttemplate <class T> inline void write(T x)\n\t{\n\t\tif(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');\n\t\tif(x < 0) *f3 ++ = '-' , x = ~x + 1;\n\t\tchar *top = sta;\n\t\twhile(x) *top ++ = x % 10 + 48 , x /= 10;\n\t\twhile(top != sta) *f3 ++ = *-- top;\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void put(std::string s)\n\t{\n\t\tint len = s.length();\n\t\tfor(int i = 0;i < len;i ++) *f3 ++ = s[i];\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void endline() { *f3 ++ = '\\n';}\n\t#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)\n\ttemplate <class T> inline T abs(T a) { return a < 0 ? -a : a;}\n\ttemplate <class T> inline T max(T a,T b) { return a > b ? a : b;}\n\ttemplate <class T> inline T min(T a,T b) { return a < b ? a : b;}\n\ttemplate <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}\n}\nusing namespace IO;\nconst int N = 3e3 + 5 , mod = 1e9 + 7 , inv = (mod + 1) / 2;\nint n , m;\nint a[N];\nll f[N][N] , g[N][N];\nint main()\n{\n\tn = read(); m = read(); ll ans = 0 , tmp = 1;\n\tfor(int i = 1;i <= n;i ++) a[i] = read();\n\tfor(int i = 1;i <= n;i ++) for(int j = 1;j <= n;j ++) f[i][j] = a[i] > a[j];\n\twhile(m --> 0)\n\t{\n\t\tint u = read() , v = read();\n\t\tif(u > v) swap(u,v); tmp = tmp * 2 % mod;\n\t\tfor(int i = 1;i <= n;i ++) if(i != u && i != v) g[i][u] = (f[i][u] + f[i][v]) * inv % mod , g[u][i] = (f[u][i] + f[v][i]) * inv % mod , g[i][v] = (f[i][v] + f[i][u]) * inv % mod , g[v][i] = (f[v][i] + f[u][i]) * inv % mod;\n\t\tfor(int i = 1;i <= n;i ++) if(i != u && i != v) f[i][u] = g[i][u] , f[u][i] = g[u][i] , f[i][v] = g[i][v] , f[v][i] = g[v][i];\n\t\tf[u][v] = f[v][u] = (f[u][v] + f[v][u]) * inv % mod;\n\t}\n\tfor(int i = 1;i <= n;i ++) for(int j = i + 1;j <= n;j ++) ans = (ans + f[i][j]) % mod;\n\tprintf(\"%lld\\n\",ans * tmp % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=3003;\nconst int mod=1000000007;\nint n,m;\nint a[N];\nint dp[N][N];\nint fpow(int x,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tdp[i][j]=(a[i]>a[j]);\n\tint inv=fpow(2,mod-2);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=1ll*(dp[x][y]+dp[y][x])%mod*inv%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x||j==y) continue;\n\t\t\tdp[x][j]=dp[y][j]=1ll*(dp[x][j]+dp[y][j])%mod*inv%mod;\n\t\t\tdp[j][x]=dp[j][y]=1ll*(dp[j][x]+dp[j][y])%mod*inv%mod;\n\t\t}\n\t}\n\tint ans=0,num=fpow(2,m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(ans+1ll*dp[i][j]*num%mod)%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst LL MOD = 1e9+7;\nconst LL inv2 = (MOD+1)/2;\nconst int MAXN = 3100;\n\nLL val[MAXN][MAXN];\n\nvoid make_average(LL& x, LL & y) {\n    LL z = (x+y)*inv2 % MOD;\n    x = z, y = z;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n    int N;\n    int Q;\n    cin >> N >> Q;\n    vector<int> A(N);\n    for (int i = 0; i < N; i++) cin >> A[i];\n    for (int i = 0; i < N; i++) for (int j = i+1; j < N; j++){\n        if (A[i] > A[j]) val[i][j] = 1;\n        if (A[j] > A[i]) val[j][i] = 1;\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int I, J;\n        cin >> I >> J;\n        if (I > J) swap(I, J);\n        I--, J--;\n        for (int a = 0; a < N; a++) {\n            if (a == I or a == J) continue;\n            make_average(val[a][I], val[a][J]);\n            make_average(val[I][a], val[J][a]);\n        }\n        make_average(val[I][J], val[J][I]);\n    }\n    LL res = 0;\n    for (int i = 0; i < N; i++) for (int j = i+1; j < N; j++) res += val[i][j];\n    res %= MOD;\n    for (int i = 0; i < Q; i++) res = (res * 2) % MOD;\n    cout << res << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=3000+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n,m;\nint a[N];\nint x[N],y[N];\nvoid input()\n{\n\tn=read<int>(),m=read<int>();\n\tFor(i,1,n)a[i]=read<int>();\n\tFor(i,1,m)\n\t{\n\t\tx[i]=read<int>(),y[i]=read<int>();\n\t\t//if(x[i]>y[i])swap(x[i],y[i]);\n\t}\n}\nint dp[N][N],tmp[N][N];\nconst int mo=1e9+7;\nll power(ll x,int y)\n{\n\tll res=1;\n\tfor(;y;x=x*x%mo,y>>=1)if(y&1)res=res*x%mo;\n\treturn res;\n}\nint inv;\nvoid add(int &x,int y){x+=y;x-=(x>=mo?mo:0);}\nvoid work()\n{\n\t//inv=power(2,mo-2);\n\tinv=(mo+1)/2;\n\tFor(i,1,n)For(j,i+1,n)\n\t{\n\t\tif(a[i]>a[j])dp[j][i]=1;\n\t\tif(a[i]<a[j])dp[i][j]=1;\n\t}\n\tFor(i,1,m)\n\t{\n\t\tint u=x[i],v=y[i];\n\t\tFor(j,1,n)tmp[j][u]=tmp[u][j]=tmp[v][j]=tmp[j][v]=0;\n\t\tFor(j,1,n)if(j!=u&&j!=v)\n\t\t{\n\t\t\tadd(tmp[j][v],(dp[j][u]+dp[j][v])%mo);\n\t\t\tadd(tmp[j][u],(dp[j][u]+dp[j][v])%mo);\n\t\t\tadd(tmp[u][j],(dp[u][j]+dp[v][j])%mo);\n\t\t\tadd(tmp[v][j],(dp[u][j]+dp[v][j])%mo);\n\t\t}\n\t\ttmp[u][v]=tmp[v][u]=(dp[u][v]+dp[v][u])%mo;\n\t\tFor(j,1,n)\n\t\t{\n\t\t\tdp[j][u]=1ll*tmp[j][u]*inv%mo;\t\n\t\t\tdp[j][v]=1ll*tmp[j][v]*inv%mo;\t\n\t\t\tdp[u][j]=1ll*tmp[u][j]*inv%mo;\t\n\t\t\tdp[v][j]=1ll*tmp[v][j]*inv%mo;\t\n\t\t}\n\t}\n\tint s=power(2,m);\n\tint ans=0;\n\tFor(i,1,n)For(j,1,i-1)\n\t{\n\t//\tcout<<1ll*dp[i][j]*s%mo<<(j==i-1?'\\n':' ');\n\t\tadd(ans,1ll*dp[i][j]*s%mo);\n\t}\n\twrite(ans,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(__int128 x) {\n\tif (x == 0) { fast_print('0'); return; }\n\tif (x < 0) {\n\t\tfast_print('-');\n\t\tx = -x;\n\t}\n\t__int128 p = 1;\n\twhile (x / (p * 10)) p *= 10;\n\twhile (p) {\n\t\t__int128 symb = x / p;\n\t\tfast_print((int)symb);\n\t\tx -= p * symb;\n\t\tp /= 10;\n\t}\n};\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nconst ll MOD = 1e9 + 7;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tif (p == 0) return 1;\t\n\t\tif (p & 1) {\n\t\t\treturn Ring(value).pow(p - 1) * value;\n\t\t} else {\n\t\t\tRing sub = Ring(value).pow(p / 2);\n\t\t\treturn sub * sub;\n\t\t}\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nint n, q;\nvector<int> a;\n\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, q;\n\ta.resize(n);\n\tscan a;\n\tvector<vector<num>> p(n, vector<num>(n));\n\tvector<vector<num>> pref(n, vector<num>(n));\n\tf(i, n)\n\t\tf(j, n)\n\t\t\tp[i][j] = (a[i] < a[j]);\n\tf(i, q) {\n\t\tint x, y;\n\t\tscan x, y;\n\t\tx--;y--;\n\t\tf(z, n) {\n\t\t\tpref[x][z] = p[x][z];\n\t\t\tpref[z][x] = p[z][x];\n\n\t\t\tpref[z][y] = p[z][y];\n\t\t\tpref[y][z] = p[y][z];\n\t\t}\n\t\tp[x][y] = p[y][x] = (pref[x][y] + pref[y][x]) / 2;\n\t\tf(z, n) {\n\t\t\tif (z == x) continue;\n\t\t\tif (z == y) continue;\n\t\t\tp[z][x] = (pref[z][x] + pref[z][y]) / 2;\n\t\t\tp[x][z] = (pref[x][z] + pref[y][z]) / 2;\n\n\t\t\tp[z][y] = (pref[z][y] + pref[z][x]) / 2;\n\t\t\tp[y][z] = (pref[y][z] + pref[x][z]) / 2;\n\t\t}\n\t}\n\tnum rez = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\trez += p[j][i];\n\tprint rez * num(2).pow(q);\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-01-25 21:32:53\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=3010,mod=1000000007;\ni64 power(i64 a,i64 b,i64 p)\n{\n\ti64 r=1; a%=p;\n\tfor(;b;b>>=1,a=a*a%p) if(b&1) r=r*a%p;\n\treturn r;\n}\ni64 inv(i64 a){ return power(a,mod-2,mod); }\ni64 n,q,a[N],f[N][N],F[N][N],i2=inv(2),x,y;\nint main()\n{\n\tn=read(); q=read();\n\tfr(i,1,n) a[i]=read();\n\tfr(i,1,n) fr(j,1,n) if(i!=j) f[i][j]=F[i][j]=(a[i]<a[j]);\n\tfr(i,1,q)\n\t{\n\t\tx=read(); y=read();\n\t\tfr(j,1,n) if(j!=x&&j!=y) f[y][j]=f[x][j]=i2*(F[x][j]+F[y][j])%mod;\n\t\tfr(j,1,n) if(j!=x&&j!=y) f[j][y]=f[j][x]=i2*(F[j][x]+F[j][y])%mod;\n\t\tf[x][y]=f[y][x]=i2;\n\t\tfr(j,1,n){ F[x][j]=f[x][j]; F[y][j]=f[y][j]; F[j][x]=f[j][x]; F[j][y]=f[j][y]; }\n\t}\n\ti64 ans=0;\n\tfr(i,1,n) fr(j,1,i-1) ans+=f[i][j];\n\tprintf(\"%d\\n\",int(ans%mod*power(2,q,mod)%mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Mod 1000000007\n#define inv 500000004\n#define N 5005\nusing namespace std;\nint n,x,y,Q,a[N],dp[N][N];\ninline int ksm(int x,int y){\n\tint ans1=1;while (y){\n\t\tif (y&1) ans1=1ll*ans1*x%Mod;\n\t\ty>>=1;x=1ll*x*x%Mod;\n\t}return ans1;\n} \nint main(){\n\tscanf(\"%d%d\",&n,&Q);int tmp=ksm(2,Q); \n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++) dp[i][j]=a[i]<a[j];//a[i]<a[j]的方案数 \n\twhile (Q--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (i==x||i==y) continue;\n\t\t\t//dp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])%Mod;\n\t\t\t//dp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])%Mod;\n\t\t\tdp[x][i]=dp[y][i]=1ll*(dp[x][i]+dp[y][i])*inv%Mod;\n\t\t\tdp[i][x]=dp[i][y]=1ll*(dp[i][x]+dp[i][y])*inv%Mod;\n\t\t}\n\t\t//dp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])%Mod;\n\t\tdp[x][y]=dp[y][x]=1ll*(dp[x][y]+dp[y][x])*inv%Mod;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=i;j++) ans=(ans+1ll*tmp*dp[i][j]%Mod)%Mod;\n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 3009, MOD = 1e9 + 7;\n\nll dp[SZ][SZ][2];\nll n, q;\nvector<ll> vec;\n\nll bpow(ll vl, ll p, ll MOD) {\n\tif (p == 0) return 1ll;\n\tif (p % 2 == 1) {\n\t\treturn (bpow(vl, p - 1, MOD) * vl) % MOD;\n\t}\n\telse {\n\t\tll b = bpow(vl, p / 2, MOD);\n\t\treturn (b * b) % MOD;\n\t}\n}\nint main() {\n\tfastInp;\n\n\tcin >> n >> q;\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur;\n\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\tif (vec[i] < vec[j]) {\n\t\t\t\tdp[i][j][1]++;\n\t\t\t}\n\t\t\telse if (vec[i] > vec[j]) {\n\t\t\t\tdp[i][j][0]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tll curPw = 1, inv = bpow(2, MOD - 2, MOD), c = 0;\n\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (l > r) swap(l, r);\n\t\tvector<tuple<ll, ll, ll, ll>> add;\n\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tadd.push_back({ i, r, 1, (dp[i][l][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, r, 0, (dp[i][l][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ i, l, 1, (dp[i][r][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, l, 0, (dp[i][r][0] * curPw) % MOD });\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tadd.push_back({ r, i, 1, (dp[l][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ r, i, 0, (dp[l][i][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ l, i, 1, (dp[r][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ l, i, 0, (dp[r][i][0] * curPw) % MOD });\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tadd.push_back({ i, r, 0, (dp[l][i][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ i, r, 1, (dp[l][i][0] * curPw) % MOD });\n\n\t\t\t\tadd.push_back({ l, i, 0, (dp[i][r][1] * curPw) % MOD });\n\t\t\t\tadd.push_back({ l, i, 1, (dp[i][r][0] * curPw) % MOD });\n\t\t\t}\n\t\t}\n\t\tll s = ((dp[l][r][1] * curPw) % MOD + (dp[l][r][0] * curPw) % MOD) % MOD;\n\t\tc++;\n\t\tdp[l][r][1] = (s * bpow(bpow(2, c, MOD), MOD - 2, MOD)) % MOD;\n\t\tdp[l][r][0] = (s * bpow(bpow(2, c, MOD), MOD - 2, MOD)) % MOD;\n\t\tif (dp[l][r][1] >= MOD) dp[l][r][1] -= MOD;\n\t\tif (dp[l][r][0] >= MOD) dp[l][r][0] -= MOD;\n\n\t\tfor (auto cur : add) {\n\t\t\tll l = get<0>(cur), r = get<1>(cur), fl = get<2>(cur), vl = get<3>(cur);\n\t\t\tif (l > r) {\n\t\t\t\tswap(l, r);\n\t\t\t\tfl = !fl;\n\t\t\t}\n\t\t\tdp[l][r][fl] = (dp[l][r][fl] * curPw) % MOD;\n\t\t\tdp[l][r][fl] += vl;\n\n\t\t\tdp[l][r][fl] = ((dp[l][r][fl] * bpow(bpow(2, c, MOD), MOD - 2, MOD)) % MOD);\n\t\t}\n\n\t\tcurPw *= 2;\n\t\tcurPw %= MOD;\n\t}\n\n\tll ans = 0, pw = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tans += (dp[i][j][0] * curPw) % MOD;\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 3000 + 5;\nconst int mod = 1e9 + 7;\nconst int inv = 500000004;\nint dp[maxn][maxn], a[maxn], mult[maxn][maxn];\nint pw[maxn], wp[maxn];\n\nint main() {\n    int n, q; scanf(\"%d%d\", &n, &q);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = a[i] > a[j];\n            mult[i][j] = 0;\n        }\n    } \n    pw[0] = 1, wp[0] = 1;\n    for (int i = 1; i <= q; ++i) {\n        pw[i] = pw[i - 1] * 1ll * 2 % mod;\n        wp[i] = wp[i - 1] * 1ll * inv % mod;\n    }\n    for (int t = 0; t < q; ++t) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        --x, --y;\n        vector<int> dxj, djx, dyj, djy;\n        for (int j = 0; j < n; ++j) dxj.push_back(dp[x][j] * 1ll * pw[mult[x][j] + t] % mod);\n        for (int j = 0; j < n; ++j) djx.push_back(dp[j][x] * 1ll * pw[mult[j][x] + t] % mod);\n        for (int j = 0; j < n; ++j) dyj.push_back(dp[y][j] * 1ll * pw[mult[y][j] + t] % mod);\n        for (int j = 0; j < n; ++j) djy.push_back(dp[j][y] * 1ll * pw[mult[j][y] + t] % mod);\n        for (int j = 0; j < n; ++j) {\n            if (j == x || j == y) continue;\n            dp[x][j] = pw[mult[x][j] + t] * 1ll * dp[x][j] % mod;\n            dp[j][x] = pw[mult[j][x] + t] * 1ll * dp[j][x] % mod;\n            dp[y][j] = pw[mult[y][j] + t] * 1ll * dp[y][j] % mod;\n            dp[j][y] = pw[mult[j][y] + t] * 1ll * dp[j][y] % mod;\n        }\n        for (int j = 0; j < n; ++j) {\n            if (j == x || j == y) continue;\n            (dp[x][j] += dyj[j]) %= mod;\n            (dp[j][x] += djy[j]) %= mod;\n            (dp[y][j] += dxj[j]) %= mod;\n            (dp[j][y] += djx[j]) %= mod;\n        }\n        for (int j = 0; j < n; ++j) {\n            if (j == x || j == y) continue;\n            dp[x][j] = wp[mult[x][j] + t] * 1ll * dp[x][j] % mod;\n            dp[j][x] = wp[mult[j][x] + t] * 1ll * dp[j][x] % mod;\n            dp[y][j] = wp[mult[y][j] + t] * 1ll * dp[y][j] % mod;\n            dp[j][y] = wp[mult[j][y] + t] * 1ll * dp[j][y] % mod;\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i == x || i == y) continue;\n            mult[i][x]--;\n            mult[x][i]--;\n            mult[i][y]--;\n            mult[y][i]--;\n        }\n        dp[x][y] = (pw[mult[x][y] + t] * 1ll * dp[x][y] % mod + dyj[x]) % mod;\n        dp[y][x] = (pw[mult[y][x] + t] * 1ll * dp[y][x] % mod + dxj[y]) % mod;\n        dp[x][y] = dp[x][y] * 1ll * wp[mult[x][y] + t] % mod;\n        dp[y][x] = dp[y][x] * 1ll * wp[mult[y][x] + t] % mod;\n        mult[x][y]--;\n        mult[y][x]--;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            (ans += dp[i][j] * 1ll * pw[mult[i][j] + q] % mod) %= mod;\n            if (ans >= mod) ans -= mod;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v((a %= mod) < 0 ? a + mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<MOD>;\nmint rec[3010][3010];\n\nsigned main() {\n    int N, Q; cin >> N >> Q;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(A[i] == A[j]) rec[i][j] = mint(1) / mint(2);\n            if(A[i] <  A[j]) rec[i][j] = mint(0);\n            if(A[i] >  A[j]) rec[i][j] = mint(1);\n        }\n    }\n\n    mint mul = mint(2).pow(Q);\n    while(Q--) {\n        int x, y; cin >> x >> y; x--; y--;\n\n        // x < y にする\n        if(x > y) swap(x, y);\n        \n        map< pair<int, int>, mint > memo;\n        \n        // (i, x, y) -> (i, y, x)\n        // (i, x) -> (i, y), (i, y) -> (i, x) と変える\n        for(int i=0; i<x; i++) {\n            memo[ make_pair(i, y) ] += rec[i][x] / mint(2);\n            memo[ make_pair(i, x) ] += rec[i][x] / mint(2);\n            memo[ make_pair(i, x) ] += rec[i][y] / mint(2);\n            memo[ make_pair(i, y) ] += rec[i][y] / mint(2);\n        }\n        \n        // (x, i, y) -> (y, i, x)\n        // (x, i) -> (y, i), (i, y) -> (i, x) と変える\n        for(int i=x+1; i<y; i++) {\n            memo[ make_pair(x, i) ] += (mint(1) - rec[i][y]) / mint(2);\n            memo[ make_pair(x, i) ] += rec[x][i] / mint(2);\n            memo[ make_pair(i, y) ] += (mint(1) - rec[x][i]) / mint(2);\n            memo[ make_pair(i, y) ] += rec[i][y] / mint(2);\n        }\n        \n        // (x, y, i) -> (y, x, i)\n        // (x, i) -> (y, i), (y, i) -> (x, i) と変える\n        for(int i=y+1; i<N; i++) {\n            memo[ make_pair(y, i) ] += rec[x][i] / mint(2);\n            memo[ make_pair(x, i) ] += rec[x][i] / mint(2);\n            memo[ make_pair(x, i) ] += rec[y][i] / mint(2);\n            memo[ make_pair(y, i) ] += rec[y][i] / mint(2);\n        }\n        \n        // x, y -> y, x\n        {\n            memo[ make_pair(x, y) ] += rec[x][y] / mint(2);\n            memo[ make_pair(x, y) ] += (mint(1) - rec[x][y]) / mint(2);\n        }\n\n        for(auto p : memo) {\n            int u, v; tie(u, v) = p.first;\n            mint val = p.second;\n            rec[u][v] = val;\n        }\n    }\n\n    mint ans(0);\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            ans += rec[i][j];\n        }\n    }\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(A[i] == A[j]) ans -= mint(1) / mint(2);\n        }\n    }\n    ans *= mul;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint f[maxn][maxn], n, a[maxn], p2c[maxn][maxn], q;\nint l[maxn], r[maxn], tmp[maxn], ptmp[maxn];\nint pow2[maxn], ans, tmpl, tmpr;\ninline int mul(const int &a, const int &b) {\n\treturn 1ll * a * b % mod;\n}\ninline void Add(int &a, const int &b) {\n\ta = a + b >= mod ? a + b - mod : a + b;\n}\ninline int Minus(const int &a, const int &b) {\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q), pow2[0] = 1;\n\tfor(register int i = 1; i <= q; ++i)\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfor(register int j = i + 1; j <= n; ++j)\n\t\t\tf[i][j] = 1;\n\treverse(l + 1, l + q + 1);\n\treverse(r + 1, r + q + 1);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tfor(register int j = 1; j <= n; ++j)\n\t\t\ttmp[j] = f[j][r[i]], ptmp[j] = p2c[j][r[i]];\n\t\tfor(register int j = 1; j <= n; ++j) {\n\t\t\tif(j == l[i] || j == r[i]) continue;\n\t\t\tf[j][r[i]] = mul(f[j][r[i]], pow2[i + p2c[j][r[i]] - 1]);\n\t\t\tf[j][l[i]] = mul(f[j][l[i]], pow2[i + p2c[j][l[i]] - 1]);\n\t\t\ttmpl = f[j][l[i]], tmpr = f[j][r[i]];\n\t\t\tAdd(f[j][r[i]], tmpl);\n\t\t\tAdd(f[j][l[i]], tmpr);\n\t\t\tf[r[i]][j] = pow2[i] - f[j][r[i]];\n\t\t\tf[l[i]][j] = pow2[i] - f[j][l[i]];\n\t\t\tp2c[j][l[i]] = p2c[j][r[i]] = -i;\n\t\t\tp2c[l[i]][j] = p2c[r[i]][j] = -i;\n\t\t}\n\t\tp2c[l[i]][r[i]] = -i;\n\t\tf[l[i]][r[i]] = pow2[i - 1];\n\t\tp2c[r[i]][l[i]] = -i;\n\t\tf[r[i]][l[i]] = pow2[i - 1];\n\t\t/*for(register int j = 1; j <= n; ++j) {\n\t\t\tfor(register int k = 1; k <= n; ++k) {\n\t\t\t\t//f[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\t\tprintf(\"%d \", mul(f[j][k], pow2[i + p2c[j][k]]));\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}*/\n\t}\n\tfor(register int i = 1; i <= n; ++i) {\n\t\tfor(register int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\tif(a[i] > a[j]) Add(ans, f[i][j]);\n\t\t\telse if(a[i] < a[j]) Add(ans, Minus(pow2[q], f[i][j]));\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,q,ans,mod=1e9+7,ress,tmp,a[3333],p[3333],f[3333][3333];\nlong long quick_q(int x,int y){\n\tlong long res=x,ans=1;\n\tfor(;y;y>>=1,res*=res,res%=mod)if(y&1)ans*=res,ans%=mod;\n\treturn (int)ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q),ress=quick_q(2,q),tmp=quick_q(2,mod-2);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(a[i]>a[j])f[i][j]=1;\n\tfor(int i=1,x,y;i<=q;f[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])%mod*tmp%mod,i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;j++)if(j!=x&&j!=y)f[x][j]=f[y][j]=1ll*(f[x][j]+f[y][j])%mod*tmp%mod;\n\t\tfor(int j=1;j<=n;j++)if(j!=x&&j!=y)f[j][x]=f[j][y]=1ll*(f[j][x]+f[j][y])%mod*tmp%mod;\n\t}\n\tfor(int i=1;i<n;i++)for(int j=i+1;j<=n;j++)ans+=1ll*ress*f[i][j]%mod,ans%=mod;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/agc030/tasks/agc030_d\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\nint N,Q;\nint A[3123];\nint X[3123];\nint Y[3123];\nconstexpr int mod = 1e9+7;\nLL dp[3123][3123];\nLL last_update[3123][3123];\nLL x[3123];\nint main(){\n    cin>>N>>Q;\n    for(int i:range(N))cin>>A[i];\n    for(int i:range(Q)){\n        cin>>X[i]>>Y[i];\n        X[i]--;\n        Y[i]--;\n    }\n    x[0]=1;\n    for(int i:range(3120)){\n        x[i+1]=x[i]*2%mod;\n    }\n    for(int i:range(N)){\n        for(int j:range(i+1,N)){\n            if(A[i]<A[j]){\n                dp[i][j]++;\n            }\n            if(A[i]>A[j]){\n                dp[j][i]++;\n            }\n        }\n    }\n    using T=tuple<int,int,LL>;\n    queue<T> que;\n    for(int q:range(Q)){\n        for(int i:range(N)){\n            if(i!=X[q]){\n                dp[i][Y[q]]=dp[i][Y[q]]*x[q-last_update[i][Y[q]]]%mod;\n                last_update[i][Y[q]]=q+1;\n                dp[Y[q]][i]=dp[Y[q]][i]*x[q-last_update[Y[q]][i]]%mod;\n                last_update[Y[q]][i]=q+1;\n\n                que.push({i,X[q],dp[i][Y[q]]});\n                que.push({X[q],i,dp[Y[q]][i]});\n            }\n            if(i!=Y[q]){\n                dp[i][X[q]]=dp[i][X[q]]*x[q-last_update[i][X[q]]]%mod;\n                last_update[i][X[q]]=q+1;\n                dp[X[q]][i]=dp[X[q]][i]*x[q-last_update[X[q]][i]]%mod;\n                last_update[X[q]][i]=q+1;\n\n                que.push({i,Y[q],dp[i][X[q]]});\n                que.push({Y[q],i,dp[X[q]][i]});\n            }\n        }\n        dp[X[q]][Y[q]]=dp[X[q]][Y[q]]*x[q-last_update[X[q]][Y[q]]]%mod;\n        last_update[X[q]][Y[q]]=q+1;\n        dp[Y[q]][X[q]]=dp[Y[q]][X[q]]*x[q-last_update[Y[q]][X[q]]]%mod;\n        last_update[Y[q]][X[q]]=q+1;\n        que.push({X[q],Y[q],dp[Y[q]][X[q]]});\n        que.push({Y[q],X[q],dp[X[q]][Y[q]]});\n        while(que.size()){\n            int i,j;\n            LL p;\n            tie(i,j,p)=que.front();\n            que.pop();\n            dp[i][j]+=p;\n            dp[i][j]%=mod;\n        }\n\n    }\n    LL ret=0;\n    for(int i:range(N)){\n        for(int j:range(N)){\n                dp[i][j]=dp[i][j]*x[Q-last_update[i][j]]%mod;\n                if(i>j)ret+=dp[i][j];\n        }\n    }\n    cout<<ret%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<int,int> P;\n#define Mod 1000000007\n\n\nint main(){\n    ll i,j;\n    ll n,q;\n    cin>>n>>q;\n    ll a[n];\n    for(i=0;i<n;i++){\n        cin>>a[i];\n    }\n\n    ll bi[q+10];\n\n    bi[0]=1;\n    for(i=1;i<q+10;i++){\n        bi[i]=2*bi[i-1];\n        bi[i]%=Mod;\n    }\n\n    ll nq=bi[q];\n\n    ll hal=(1+Mod)/2;\n\n    ll cal[n][n];\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            if(a[i]>a[j]) cal[i][j]=nq;\n            else cal[i][j]=0;\n        }\n    }\n\n    for(j=0;j<q;j++){\n        ll x,y;\n        cin>>x>>y;\n        x--;\n        y--;\n        for(i=0;i<n;i++){\n            if(i!=x&&i!=y){\n                ll mx=min(x,i);\n                ll my=min(y,i);\n\n                \n                    ll calxi=cal[x][i];\n                    ll calix=cal[i][x];\n                    ll calyi=cal[y][i];\n                    ll caliy=cal[i][y];\n\n                    cal[x][i]=hal*(calxi+calyi);\n                    cal[i][x]=hal*(calix+caliy);\n\n                    cal[x][i]%=Mod;\n                    cal[i][x]%=Mod;\n\n                    cal[y][i]=hal*(calyi+calxi);\n                    cal[i][y]=hal*(caliy+calix);\n\n                    cal[y][i]%=Mod;\n                    cal[i][y]%=Mod;\n                \n            }\n        }\n            ll calxy=cal[x][y];\n            ll calyx=cal[y][x];\n\n            cal[x][y]=hal*(calxy+calyx);\n            cal[x][y]%=Mod;\n            cal[y][x]=cal[x][y];\n\n\n\n    }\n\n\n    ll ans=0;\n    for(i=0;i<n;i++){\n        for(j=i+1;j<n;j++){\n            ans+=cal[i][j];\n            ans%=Mod;\n        }\n    }\n    cout<<ans<<endl;\n\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\n\nconst int mod = 1e9 + 7;\nvector<int> comp;\nint n, q, m;\nint A[3001];\nint p2[3001];\n\nint T;\nstruct number {\n    int x, t;\n    number() : x(0), t(0) {}\n    void update() {\n        x = (llong)x * p2[T - t] % mod;\n        t = T;\n    }\n};\n\nnumber dp[3001][3001];\n\nstruct query {\n    int x, y, v;\n    query(int x, int y, int v) : x(x), y(y), v(v) {}\n};\n\nint ch[3001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    p2[0] = 1;\n    for (int i = 1; i <= 3000; ++i) p2[i] = p2[i - 1] * 2 % mod;\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        cin >> A[i];\n        ch[i] = i;\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            if (A[i] != A[j]) {\n                if (A[i] < A[j]) ++dp[i][j].x;\n                else ++dp[j][i].x;\n            }\n        }\n    }\n    for (int it = 0; it < q; ++it) {\n        int x, y;\n        cin >> x >> y;\n        ch[x] = y;\n        ch[y] = x;\n        vector<pii> P;\n        vector<query> Q;\n        for (int i = 1; i <= n; ++i) {\n            P.emplace_back(x, i);\n            P.emplace_back(y, i);\n            if (i == x || i == y) continue;\n            P.emplace_back(i, x);\n            P.emplace_back(i, y);\n        }\n        for (pii i : P) dp[i.fs][i.se].update();\n        for (pii i : P) {\n            int v = dp[i.fs][i.se].x;\n            i.fs = ch[i.fs];\n            i.se = ch[i.se];\n            Q.emplace_back(i.fs, i.se, v);\n        }\n        for (query q : Q) {\n            dp[q.x][q.y].x += q.v;\n            dp[q.x][q.y].x %= mod;\n        }\n        for (pii i : P) {\n            ++dp[i.fs][i.se].t;\n        }\n        ch[x] = x;\n        ch[y] = y;\n        ++T;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            dp[i][j].update();\n            ans += dp[i][j].x;\n            ans %= mod;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 3003, MOD = 1e9 + 7;\nint n, q, a[N], X[N], Y[N], dp[N][N], pw[N];\nint rt = (MOD + 1) / 2;\n\nvoid add(int & x, int y) {\n\tx += y;\n\tif (x >= MOD) {\n\t\tx -= MOD;\n\t}\n}\n\nvoid dbg() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tcout << dp[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\t\n\tcin >> n >> q;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpw[i] = (ll)pw[i - 1] * 2 % MOD;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a[i] < a[j]) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tint x = X[i], y = Y[i];\n\t\tint t1 = dp[x][y], t2 = dp[y][x];\n\t\tadd(dp[x][y], t2);\n\t\tadd(dp[y][x], t1);\n\t\tdp[x][y] = (ll)dp[x][y] * rt % MOD;\n\t\tdp[y][x] = (ll)dp[y][x] * rt % MOD;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j == x || j == y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint d1 = dp[j][x], d2 = dp[j][y];\n\t\t\tint d3 = dp[x][j], d4 = dp[y][j];\n\t\t\tadd(dp[j][x], d2);\n\t\t\tdp[j][x] = (ll)dp[j][x] * rt % MOD;\n\t\t\tadd(dp[j][y], d1);\n\t\t\tdp[j][y] = (ll)dp[j][y] * rt % MOD;\n\t\t\tadd(dp[x][j], d4);\n\t\t\tdp[x][j] = (ll)dp[x][j] * rt % MOD;\n\t\t\tadd(dp[y][j], d3);\n\t\t\tdp[y][j] = (ll)dp[y][j] * rt % MOD;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tadd(res, dp[i][j]);\n\t\t}\n\t}\n\tcout << (ll)res * pw[q] % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author: ReseeCher\n#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\n#define ckmax(a,b) (a)=max(a,b)\n#define ckmin(a,b) (a)=min(a,b)\n#define pb push_back\nusing namespace std;\nconst int P=1000000007;\nconst int N=3010;\nconst LL Inv2=(P+1)/2;\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nint n,Q;\nint a[N];\nLL g[N][N],b[N],c[N];\nLL Pow(LL x,LL bs){\n    x%=P;\n    LL an=1;\n    for(;bs;bs>>=1,x=x*x%P)\n        if(bs&1)an=an*x%P;\n    return an;\n}\nvoid Work(){\n\tint x=R(),y=R();\n\tF(i,1,n)\n\t\tb[i]=Inv2*(g[x][i]+g[y][i])%P;\n\tF(i,1,n)\n\t\tc[i]=Inv2*(g[i][x]+g[i][y])%P;\n\tF(i,1,n)if(i!=x&&i!=y)g[x][i]=b[i];\n\tF(i,1,n)if(i!=x&&i!=y)g[y][i]=b[i];\n\tF(i,1,n)if(i!=x&&i!=y)g[i][x]=c[i];\n\tF(i,1,n)if(i!=x&&i!=y)g[i][y]=c[i];\n\tint g1=g[x][y],g2=g[y][x];\n\tg[x][y]=Inv2*(g1+g2)%P;\n\tg[y][x]=Inv2*(g1+g2)%P;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n    n=R();int ss=Q=R();\n    F(i,1,n)a[i]=R();\n    F(i,1,n)F(j,1,n)\n    \tg[i][j]=(a[i]>a[j]);\n    while(Q--)Work();\n    LL ans=0;\n    F(i,1,n)\n    \tF(j,i+1,n)ans+=g[i][j];\n    ans%=P;\n    ans*=Pow(2,ss);\n    ans%=P;\n    cout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 3005\n#define mod 1000000007\n#define inv 500000004\nint n,dp[N][N],v[N],q,a,b;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)dp[i][j]=(v[i]<v[j]);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint tp=dp[a][b]+dp[b][a];\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tdp[j][a]=dp[j][b]=1ll*(dp[j][a]+dp[j][b])*inv%mod;\n\t\t\tdp[a][j]=dp[b][j]=1ll*(dp[a][j]+dp[b][j])*inv%mod;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=1ll*tp*inv%mod;\n\t}\n\tint as=0;\n\tfor(int i=2;i<=n;i++)\n\tfor(int j=1;j<i;j++)as=(as+dp[i][j])%mod;\n\tfor(int i=1;i<=q;i++)as=as*2%mod;\n\tprintf(\"%d\\n\",as);\n}\n//111222333"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst ll base = 1'000'000'000 + 7;\nconst ll half = 500'000'004; // 1/2 mod base\nint n, Q;\nll d[3333][3333];\nll a[3333];\nint main()\n{\n\tscanf(\"%d%d\", &n, &Q);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (a[i] < a[j]) d[i][j] = 1;\n\t\t}\n\t}\n\tfor (int q = 1; q <= Q; q++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\td[u][v] = d[v][u] = ((d[u][v] + d[v][u]) * half) % base;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (i == u || i == v) continue;\n\t\t\t// prob that a[i]<a[u]\n\t\t\td[i][u] = d[i][v] = ((d[i][u] + d[i][v]) * half) % base;\n\t\t\t// prob that a[u]<a[i]\n\t\t\td[u][i] = d[v][i] = ((d[u][i] + d[v][i]) * half) % base;\n\t\t}\n\t}\n\tll pow2 = 1;\n\tfor (int i = 1; i <= Q; i++) pow2 = (pow2 << 1) % base;\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j < i; j++)\n\t\t{\n\t\t\tans = (ans + d[i][j] * pow2) % base;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=3005;\nconst int mod=1e9+7;\nconst int inv=(mod+1)/2;\nint n,q;\nint a[maxn],dp[maxn][maxn];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&q);\n\tREP(i,n)scanf(\"%d\",&a[i]);\n\tREP(i,n)REP(j,n)if(a[i]>a[j])dp[i][j]=1;\n\tREP(i,q){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tREP(j,n){\n\t\t\tif(j==x||j==y)continue;\n\t\t\tint sum=1LL*(dp[j][x]+dp[j][y])*inv%mod;\n\t\t\tdp[j][x]=dp[j][y]=sum;\n\t\t\tsum=1LL*(dp[x][j]+dp[y][j])*inv%mod;\n\t\t\tdp[x][j]=dp[y][j]=sum;\n\t\t}\n\t\tint sum=1LL*(dp[x][y]+dp[y][x])*inv%mod;\n\t\tdp[x][y]=dp[y][x]=sum;\n\t}\n\tint ans=0;\n\tREP(j,n)for(int k=j+1;k<=n;k++)ans=(ans+dp[j][k])%mod;\n\tREP(i,q)ans=2LL*ans%mod;\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#define MN 3010\n#define mod 1000000007\n#define inv 500000004\n\nint x[MN], y[MN], a[MN];\nint f[MN][MN];\n\nint main()\n{\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor(int i = 1; i <= m; i++) scanf(\"%d%d\", &x[i], &y[i]);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(a[i] > a[j]) f[i][j]++;\n\t\t\telse if(a[i] < a[j]) f[j][i]++;\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint w;\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(j == x[i] || j == y[i]) continue;\n\t\t\tw = 1ll * (f[x[i]][j] + f[y[i]][j]) * inv % mod;\n\t\t\tf[x[i]][j] = f[y[i]][j] = w;\n\t\t\t\n\t\t\tw = 1ll * (f[j][x[i]] + f[j][y[i]]) * inv % mod;\n\t\t\tf[j][x[i]] = f[j][y[i]] = w;\n\t\t}\n\t\tw = 1ll * (f[x[i]][y[i]] + f[y[i]][x[i]]) * inv % mod;\n\t\tf[x[i]][y[i]] = f[y[i]][x[i]] = w;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tans = (ans + f[i][j]) % mod;\n\tfor(int i = 1; i <= m; i++) ans = ans * 2 % mod;\n\tprintf(\"%d\\n\", ans);\n}\n\n//考虑求出每对 (i,j) 的贡献，如果 a_i > a_j，那么就是求有多少种方案使得交换完后i在j前面，否则就是求i在j后面\n//那可以对每对 (i,j) DP 一下，f[i][j][k]表示前i个操作后第一个数在j，第二个数在k的方案\n//把所有(i,j)一起DP，f[i]转移到f[i+1]时只会改n个数 "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n \ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n \ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n \nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll n, q;\n  cin >> n >> q;\n  vector<ll> a(n), x(q), y(q);\n  REP(i, n) cin >> a[i];\n  REP(i, q) cin >> x[i] >> y[i], x[i]--, y[i]--;\n\n  vector<vector<ll>> p(n, vector<ll>(n));\n  REP(i, n) REP(j, n) p[i][j] = a[i] > a[j];\n\n  ll inv2 = (MOD+1) / 2;\n  REP(i, q) {\n    REP(j, n) {\n      if(j == x[i] || j == y[i]) continue;\n      ll tmp = (p[j][x[i]] + p[j][y[i]]) * inv2 % MOD;\n      p[j][x[i]] = p[j][y[i]] = tmp;\n      tmp = (p[x[i]][j] + p[y[i]][j]) * inv2 % MOD;\n      p[x[i]][j] = p[y[i]][j] = tmp;\n    }\n    ll tmp = (p[y[i]][x[i]] + p[x[i]][y[i]]) * inv2 % MOD;\n    p[x[i]][y[i]] = p[y[i]][x[i]] = tmp;\n  }\n\n  ll ans = 0;\n  REP(i, n) FOR(j, i+1, n) (ans += p[i][j]) %= MOD;\n  REP(i, q) (ans *= 2) %= MOD;\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 998244353\nusing namespace std;\nlong long ans,x,y,n,q,a[3001],t[3001][3001],T[3001][3001],sum[3001][3001],Sum[3001][3001];\nint read()\n{\n  char c=0;\n  int sum=0;\n  while (c<'0'||c>'9')\n    c=getchar();\n  while ('0'<=c&&c<='9')\n    {\n      sum=sum*10+c-'0';\n      c=getchar();\n    }\n  return sum;\n}\nlong long fast_pow(long long a,int b)\n{\n  if (b==0)\n    return 1;\n  if (b&1)\n    return fast_pow(a*a%mod,b/2)*a%mod;\n  else\n    return fast_pow(a*a%mod,b/2);\n}\nint main()\n{\n  n=read(),q=read();\n  for (int i=1;i<=n;++i)\n    a[i]=read();\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      {\n\tif (a[i]>a[j])\n\t  t[i][j]=1;\n\tif (a[i]<a[j])\n\t  T[i][j]=1;\n      }\n  int a,b,c,d;\n  for (int i=1;i<=q;++i)\n    {\n      x=read(),y=read();\n      if (x>y)\n\tswap(x,y);\n      for (int j=x+1;j<=y-1;++j)\n\t{\n\t   a=t[x][j],b=T[x][j],c=t[j][y],d=T[j][y];\n\t   t[x][j]=T[j][y]=(a+d)%mod*fast_pow(2,mod-2)%mod;\n\t   T[x][j]=t[j][y]=(b+c)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=1;j<=x-1;++j)\n\t {\n\t   a=t[j][x],b=T[j][x],c=t[j][y],d=T[j][y];\n\t   t[j][x]=t[j][y]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t   T[j][x]=T[j][y]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=y+1;j<=n;++j)\n\t{\n\t  a=t[x][j],b=T[x][j],c=t[y][j],d=T[y][j];\n\t  t[x][j]=t[y][j]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t  T[x][j]=T[y][j]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t}\n      a=t[x][y],b=T[x][y];\n      t[x][y]=T[x][y]=(a+b)%mod*fast_pow(2,mod-2)%mod;\n    }\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      ans=(ans+t[i][j]*fast_pow(2,q)%mod)%mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 3005, mod = 1e9 + 7, INV2 = (mod + 1) >> 1;\n\n\tint n, q, A[N], F[N][N], G[N][N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d%d\", &n, &q);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tA[i] = read();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tF[i][j] = A[i] > A[j];\n\t\tint ans = 0, tmp = 1;\n\t\twhile (q--)\n\t\t{\n\t\t\ttmp = (tmp << 1) % mod;\n\t\t\tint x = read(), y = read();\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tG[i][x] = F[i][x], G[i][y] = F[i][y];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tG[x][i] = F[x][i], G[y][i] = F[y][i];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (i != x && i != y)\n\t\t\t\t{\n\t\t\t\t\tF[x][i] = F[y][i] = int((ll)(G[x][i] + G[y][i]) * INV2 % mod);\n\t\t\t\t\tF[i][x] = F[i][y] = int((ll)(G[i][x] + G[i][y]) * INV2 % mod);\n\t\t\t\t}\n\t\t\tF[x][y] = F[y][x] = int((ll)(G[x][y] + G[y][x]) * INV2 % mod);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\t\tans = int((ans + (ll)F[i][j] * tmp) % mod);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt(): x(0) {}\n  ModInt(long long a) { x = a % mod; if (x < 0) x += mod; }\n  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n  ModInt &operator*=(ModInt that) { x = (long long) x * that.x % mod; return *this; }\n  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n  ModInt inverse() {\n    int a = x, b = mod, u = 1, v = 0;\n    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }\n    return ModInt(u);\n  }\n  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n    op(+, +=) op(-, -=) op(*, *=) op(/, /=)\n  #undef op\n  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n};\n\nusing mint = ModInt<1000000007>;\n\nmint dp[3010][3010];\n\nvoid solve() {\n  int N, Q; cin >> N >> Q;\n  vi32 a(N); cin >> a;\n  rep(i, N) rep(j, N) dp[i][j] = a[i] > a[j];\n  rep(j, Q) {\n    int x, y; cin >> x >> y;\n    x--, y--;\n    rep(i, N) {\n      if (i == x || i == y) continue;\n      dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * 500000004;\n      dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * 500000004;\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * 500000004;\n  }\n  mint ans = 0;\n  rep(j, N) rep(i, j) ans += dp[i][j];\n  ans = ans * power((mint) 2, Q);\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 3000 + 10;\nconst int MOD = 1e9 + 7;\n\nint n, q;\nint a[MAXN];\nint f[MAXN][MAXN];\nint last[MAXN][MAXN];\nnamespace {\n  inline int add(int x) { return x >= MOD ? x - MOD : x; }\n  inline int mul(int x, int y) { return 1ll * x * y % MOD; }\n}\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  static int pwr[MAXN];\n  pwr[0] = 1;\n  for (int i = 1; i <= q; i++) pwr[i] = mul(pwr[i - 1], 2);\n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (a[i] > a[j]) f[i][j] = 1;\n      last[i][j] = q;\n    }\n  }\n\n  while(q--) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    // x, y => y, x\n    int tmp1 = mul(f[x][y], pwr[last[x][y] - q - 1]),\n      tmp2 = mul(f[y][x], pwr[last[y][x] - q - 1]);\n    f[x][y] = add(tmp1 + tmp2);\n    f[y][x] = add(tmp2 + tmp1);\n    last[x][y] = last[y][x] = q;\n\n    for (int i = 1; i <= n; i++) {\n      if (i == x || i == y) continue;\n      int tmp1 = mul(f[x][i], pwr[last[x][i] - q - 1]),\n        tmp2 = mul(f[y][i], pwr[last[y][i] - q - 1]);\n      f[x][i] = add(tmp1 + tmp2);\n      f[y][i] = add(tmp1 + tmp2);\n\n      \n      tmp1 = mul(f[i][x], pwr[last[i][x] - q - 1]);\n      tmp2 = mul(f[i][y], pwr[last[i][y] - q - 1]);\n      \n      f[i][x] = add(tmp2 + tmp1);\n      f[i][y] = add(tmp1 + tmp2);\n\n      last[x][i] = last[y][i] = last[i][x] = last[i][y] = q;\n    }\n  }\n\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      ans = add(ans + mul(f[i][j], pwr[last[i][j]]));\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nstd::map<int, int> inv;\nll invMod(ll n, ll mod) {\n\tif (inv.count(n)) return inv[n];\n\treturn inv[n] = powMod(n, mod - 2, mod);\n}\n\nint dp[3003][3003];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, q);\n\tVEC(int, a, n);\n\n\t{\n\t\tint t = powMod(2, q, MOD);;\n\t\tREP(i, n) REP(j, n) if(a[i] > a[j]) dp[i][j] = t;\n\t}\n\tint inv2 = invMod(2, MOD);\n\n\tREP(_, q) {\n\t\tVAR(int, x, y);\n\t\t--x; --y;\n\n\t\t{\n\t\t\tint t = (dp[x][y] + dp[y][x]) * inv2 % MOD;\n\t\t\tdp[x][y] = dp[y][x] = t;\n\t\t}\n\t\t{\n\t\t\tREP(j, n) if (j != x && j != y) {\n\t\t\t\tint t = (dp[x][j] + dp[y][j]) * inv2 % MOD;\n\t\t\t\tdp[x][j] = dp[y][j] = t;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tREP(i, n) if (i != x && i != y) {\n\t\t\t\tint t = (dp[i][x] + dp[i][y]) * inv2 % MOD;\n\t\t\t\tdp[i][x] = dp[i][y] = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i, n) FOR(j, i + 1, n) (ans += dp[i][j]) %= MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 3003\n\nusing namespace std;\n\nconst int mod = 1e9 + 7, inv = (mod + 1) / 2;\n\nint n, m;\nint a[N], f[N][N], x[N][2], y[N][2];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(a[i] > a[j]) f[i][j] = 1;\n\tint sum = 1;\n\twhile(m--){\n\t\tint X, Y; (sum *= 2) %= mod;\n\t\tscanf(\"%d%d\", &X, &Y);\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tx[i][0] = f[X][i], x[i][1] = f[i][X];\n\t\t\ty[i][0] = f[Y][i], y[i][1] = f[i][Y];\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tf[X][i] = 1ll * inv * (x[i][0] + y[i][0]) % mod;\n\t\t\tf[i][X] = 1ll * inv * (x[i][1] + y[i][1]) % mod;\n\t\t\tf[Y][i] = 1ll * inv * (y[i][0] + x[i][0]) % mod;\n\t\t\tf[i][Y] = 1ll * inv * (y[i][1] + x[i][1]) % mod;\n\t\t}\n\t\tf[X][Y] = f[Y][X] = 1ll * inv * (x[Y][0] + y[X][0]) % mod;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\t(ans += f[i][j]) %= mod;\n\tans = 1ll * ans * sum % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 3005, mod = 1e9 + 7;\nint f[MAXN][MAXN];\nint a[MAXN];\n\ninline int qpow(int a, int k) {\n  int re = 1;\n  for (; k; k >>= 1, a = a * a % mod)\n    if (k & 1) re = re * a % mod;\n  return re;\n}\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, q; read(n), read(q);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 1; j <= n; ++j)\n      f[i][j] = a[i] > a[j];\n  int inv2 = qpow(2, mod - 2);\n  for (RI i = 1, x, y; i <= q; ++i) {\n    read(x), read(y);\n    f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv2 % mod;\n    for (RI j = 1; j <= n; ++j)\n      if (j != x && j != y) {\n        f[x][j] = f[y][j] = (f[x][j] + f[y][j]) * inv2 % mod;\n        f[j][x] = f[j][y] = (f[j][x] + f[j][y]) * inv2 % mod;\n      }\n  }\n  int ans = 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = i + 1; j <= n; ++j)\n      ans = (ans + f[i][j]) % mod;\n  printf(\"%lld\\n\", ans * qpow(2, q) % mod);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define inv2 500000004\n\nusing namespace std;\n\nconst int N = 3010;\nint add(int x,int y){\n\tx += y;\n\tif (x >= mod) x -= mod;\n\treturn x;\n}\n\nint n , q , a[N] , f[N][N] , g[N][N];\n\nint main(){\n\t\n\tscanf(\"%d%d\",&n,&q);\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tscanf(\"%d\",a+i);\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tfor (int j = i + 1;j <= n;j++){\n\t\t\tif (a[i] > a[j]){\n\t\t\t\tf[i][j]++;\n\t\t\t}\n\t\t\tif (a[i] < a[j]){\n\t\t\t\tf[j][i]++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tint mul = 1;\n\twhile (q--){\n\t\tmul = 2ll * mul % mod;\n\t\tint x , y;scanf(\"%d%d\",&x,&y);\n\t\t\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (i != x && i != y){\n\t\t\t\tg[y][i] = add(g[y][i] , f[x][i]);\t\t\n\t\t\t\tg[x][i] = add(g[x][i] , f[y][i]);\t\t\n\t\t\t\t\n\t\t\t\tg[i][x] = add(g[i][x] , f[i][y]);\n\t\t\t\tg[i][y] = add(g[i][y] , f[i][x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tg[x][y] = add(g[x][y] , f[y][x]);\t\n\t\tg[y][x] = add(g[y][x] , f[x][y]);\n\t\t\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (i != x && i != y){\n\t\t\t\tf[i][x] = add(f[i][x] , g[i][x]);g[i][x] = 0;\n\t\t\t\tf[i][y] = add(f[i][y] , g[i][y]);g[i][y] = 0;\n\t\t\t\tf[x][i] = add(f[x][i] , g[x][i]);g[x][i] = 0;\n\t\t\t\tf[y][i] = add(f[y][i] , g[y][i]);g[y][i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tf[x][y] = add(f[x][y] , g[x][y]);g[x][y] = 0;\n\t\tf[y][x] = add(f[y][x] , g[y][x]);g[y][x] = 0;\n\t\t\n\t\t\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (i != x && i != y){\n\t\t\t\tf[i][x] = 1ll * inv2 * f[i][x] % mod;\n\t\t\t\tf[i][y] = 1ll * inv2 * f[i][y] % mod;\n\t\t\t\tf[x][i] = 1ll * inv2 * f[x][i] % mod;\n\t\t\t\tf[y][i] = 1ll * inv2 * f[y][i] % mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tf[x][y] = 1ll * f[x][y] * inv2 % mod;\n\t\tf[y][x] = 1ll * f[y][x] * inv2 % mod;\t\t\n\t\n\t/*\n\t\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = 1;j <= n;j++)\n\t\tif (f[i][j]) printf(\"%d %d] %d\\n\",i,j,f[i][j]);*/\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 1;i <= n;i++)\n\tfor (int j = i + 1;j <= n;j++)\n\tres = add(res , f[i][j]);\n\t\n\tres = 1ll * res * mul % mod;\n\tcout<<res;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\ntemplate <int mod>\nstruct modint {\n    lint v;\n    modint() : v(0) {}\n    modint(signed v) : v(v) {}\n    modint(lint t) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    modint pow(lint k) {\n        modint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static modint add_identity() { return modint(0); }\n    static modint mul_identity() { return modint(1); }\n    modint inv() { return pow(mod - 2); }\n\n    modint &operator+=(modint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator-=(modint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    modint &operator*=(modint a) {\n        v = v * a.v % mod;\n        return *this;\n    }\n    modint &operator/=(modint a) { return (*this) *= a.inv(); }\n\n    modint operator+(modint a) const { return modint(v) += a; };\n    modint operator-(modint a) const { return modint(v) -= a; };\n    modint operator*(modint a) const { return modint(v) *= a; };\n    modint operator/(modint a) const { return modint(v) /= a; };\n\n    modint operator-() const { return v ? modint(mod - v) : modint(v); }\n\n    bool operator==(const modint a) const { return v == a.v; }\n    bool operator!=(const modint a) const { return v != a.v; }\n    bool operator<(const modint a) const { return v < a.v; }\n};\nusing mint = modint<mod>;\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    vector<lint> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    vector<int> x(q), y(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> x[i] >> y[i];\n        x[i]--, y[i]--;\n        if (x[i] > y[i])\n            swap(x[i], y[i]);\n    }\n    vector<vector<mint>> dp(n, vector<mint>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (a[i] > a[j])\n                dp[i][j] = 1;\n            else if (a[i] < a[j])\n                dp[j][i] = 1;\n            else\n                continue; // equals\n        }\n    }\n    mint inv2 = mint(1) / 2;\n    for (int i = 0; i < q; ++i) {\n        // flip x[i] : y[i]\n        for (int j = 0; j < x[i]; ++j) {\n            mint a0     = (dp[j][x[i]] + dp[j][y[i]]) * inv2;\n            mint a1     = (dp[x[i]][j] + dp[y[i]][j]) * inv2;\n            dp[j][x[i]] = dp[j][y[i]] = a0;\n            dp[x[i]][j] = dp[y[i]][j] = a1;\n        }\n        for (int j = x[i] + 1; j < y[i]; ++j) {\n            mint a0     = (dp[x[i]][j] + dp[y[i]][j]) * inv2;\n            mint a1     = (dp[j][y[i]] + dp[j][x[i]]) * inv2;\n            mint a2     = (dp[j][x[i]] + dp[j][y[i]]) * inv2;\n            mint a3     = (dp[y[i]][j] + dp[x[i]][j]) * inv2;\n            dp[x[i]][j] = a0;\n            dp[j][y[i]] = a1;\n            dp[j][x[i]] = a2;\n            dp[y[i]][j] = a3;\n        }\n        for (int j = y[i] + 1; j < n; ++j) {\n            mint a0     = (dp[j][x[i]] + dp[j][y[i]]) * inv2;\n            mint a1     = (dp[x[i]][j] + dp[y[i]][j]) * inv2;\n            dp[j][x[i]] = dp[j][y[i]] = a0;\n            dp[x[i]][j] = dp[y[i]][j] = a1;\n        }\n        mint t1        = (dp[x[i]][y[i]] + dp[y[i]][x[i]]) * inv2;\n        dp[x[i]][y[i]] = t1;\n        dp[y[i]][x[i]] = t1;\n    }\n    mint ret = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ret += dp[i][j];\n        }\n    }\n    cout << ret * mint(2).pow(q) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 3010\nll po[N];\n\nll n,dat[N],q;\nll ok[N][N],ng[N][N];\nll rui[N][N],zen;\nll oe[N][N],ne[N][N];\n\nvoid eva(ll a,ll b){\n    if(a>b)swap(a,b);\n    ll dex=zen-rui[a][b];\n    ok[a][b]=ok[a][b]*po[dex]%mod;\n    ng[a][b]=ng[a][b]*po[dex]%mod;\n    rui[a][b]=zen;\n}\n\nvoid upe(ll a,ll b){\n    if(a>b)swap(a,b);\n    ok[a][b]+=oe[a][b];ok[a][b]%=mod;oe[a][b]=0;\n    ng[a][b]+=ne[a][b];ng[a][b]%=mod;ne[a][b]=0;\n    rui[a][b]=zen;\n}\nvoid outs(ll a,ll b){\n    eva(a,b);\n    cout<<a+1<<\" \"<<b+1<<\":\"<<ok[a][b]<<\" \"<<ng[a][b]<<endl;\n}\nvoid oute(){\n    outs(0,4);outs(1,2);\n}\n\nvoid upd(ll a,ll b){\n    lol(i,n){\n\teva(a,i);\n\teva(b,i);\n    }\n    oe[a][b]=ng[a][b];\n    ne[a][b]=ok[a][b];\n    for(ll x=0;x<n;x++){\n\tif(x==a||x==b)continue;\n\tif(x<a){\n\t    oe[x][a]=ok[x][b];\n\t    oe[x][b]=ok[x][a];\n\t    ne[x][a]=ng[x][b];\n\t    ne[x][b]=ng[x][a];\n\t    continue;\n\t}\n\tif(b<x){\n\t    oe[a][x]=ok[b][x];\n\t    oe[b][x]=ok[a][x];\n\t    ne[a][x]=ng[b][x];\n\t    ne[b][x]=ng[a][x];\n\t    continue;\n\t}\n\toe[a][x]=ng[x][b];\n\toe[x][b]=ng[a][x];\n\tne[a][x]=ok[x][b];\n\tne[x][b]=ok[a][x];\n    }\n    zen++;\n    lol(i,n){\n\tupe(a,i);\n\tupe(b,i);\n    }\n}\nint main(){\n    po[0]=1; for(ll i=1;i<N;i++)po[i]=po[i-1]*2%mod;\n    \n    cin>>n>>q;\n    lol(i,n)scanf(\"%lld\",&dat[i]);\n    lol(i,n)lol(j,n){\n\tif(dat[i]==dat[j]){\n\t    ok[i][j]=ng[i][j]=0;\n\t    continue;\n\t}\n\tif(dat[i]<dat[j] xor i<j){\n\t    ok[i][j]=0,ng[i][j]=1;\n\t}\n\telse ok[i][j]=1,ng[i][j]=0;\n\trui[i][j]=0;\n    }\n    zen=0;\n    while(q--){\n\tll a,b;\n\tscanf(\"%lld%lld\",&a,&b);\n\ta--,b--;\n\tupd(min(a,b),max(a,b));\n    }\n    ll ans=0;\n    lol(i,n)lol(j,i){\n\teva(j,i);\n\tans=(ans+ng[j][i])%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=3005,mod=1e9+7;\nint n,q;\nint a[N];\nint dp[N][N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nint Div2(int x){\n\treturn (x&1)?((x+mod)>>1):(x>>1);\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nint add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tdp[i][j]=a[i]<a[j]?1:0;\n\tfor (int t=1;t<=q;t++){\n\t\tint a=read(),b=read();\n\t\tfor (register int i=1;i<=n;i++){\n\t\t\tif (i==a||i==b)\n\t\t\t\tcontinue;\n\t\t\tdp[i][a]=dp[i][b]=Div2(add(dp[i][a],dp[i][b]));\n\t\t\tdp[a][i]=dp[b][i]=Div2(add(dp[a][i],dp[b][i]));\n\t\t}\n\t\tdp[a][b]=dp[b][a]=Div2(add(dp[a][b],dp[b][a]));\n\t}\n\tint ans=0;\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<i;j++)\n\t\t\tAdd(ans,dp[i][j]);\n\tans=(LL)ans*Pow(2,q)%mod;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3005\n#define mod 1000000007\n#define count 500000004ll\nusing namespace std;\n\nint n,q;\nint a[maxn];\nlong long ans;\nint dp[maxn][maxn];\n\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0' || ch>'9')\n\t{\n\t\tif(ch=='-')\n\t\t\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0' && ch<='9')\n\t{\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\n\nint work(int x,int k)\n{\n\tint temp=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod)\n\t\tif(k&1)\n\t\t\ttemp=1ll*temp*x%mod;\n\treturn temp;\n}\n\nint main()\n{\n\tn=read(), q=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tdp[i][j]=a[i]<a[j];\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint x=read(), y=read();\n\t\tdp[x][y]=dp[y][x]=count*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x && j!=y)\n\t\t\t{\n\t\t\t\tdp[j][x]=dp[j][y]=count*(dp[j][x]+dp[j][y])%mod;\n\t\t\t\tdp[x][j]=dp[y][j]=count*(dp[x][j]+dp[y][j])%mod;\n\t\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans+=dp[i][j];\n\t\n\tcout<<ans%mod*work(2,q)%mod<<endl;\n\t\n//\tsystem(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nconst int MOD=1e9+7;\nll r2=(MOD+1)/2;\nint n,a[SZ],m,p[SZ],q[SZ],f[2333][2333];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=m;++i)\n\t\tcin>>p[i]>>q[i];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i!=j) f[i][j]=(a[i]>a[j]);\n\tll ans=0;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint u=(f[p[i]][q[i]]+f[q[i]][p[i]])%MOD*r2%MOD;\n\t\tf[p[i]][q[i]]=f[q[i]][p[i]]=u;\n\t\tfor(int t=1;t<=n;++t)\n\t\t{\n\t\t\tif(t!=p[i]&&t!=q[i]);else continue;\n\t\t\tint u=(f[t][p[i]]+f[t][q[i]])%MOD*r2%MOD;\n\t\t\tf[t][p[i]]=f[t][q[i]]=u;\n\t\t\tu=(f[p[i]][t]+f[q[i]][t])%MOD*r2%MOD;\n\t\t\tf[p[i]][t]=f[q[i]][t]=u;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\t(ans+=f[i][j])%=MOD;\n\tfor(int j=1;j<=m;++j)\n\t\tans=ans*2LL%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3000, mod = int(1e9) + 7;\n\nint fpow(int x, int y) {\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % mod)\n\t\tif (y & 1) r = 1LL * r * x % mod;\n\treturn r;\n}\n\nconst int inv2 = (mod + 1) / 2;\n\nint n, q, a[N + 5], dp[N + 5][N + 5];\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tdp[i][j] = a[i] > a[j];\n\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tdp[x][y] = dp[y][x] = 1LL * (dp[x][y] + dp[y][x]) * inv2 % mod;\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (j != x && j != y) {\n\t\t\t\tdp[x][j] = dp[y][j] = 1LL * (dp[x][j] + dp[y][j]) * inv2 % mod;\n\t\t\t\tdp[j][x] = dp[j][y] = 1LL * (dp[j][x] + dp[j][y]) * inv2 % mod;\n\t\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tans = (ans + dp[i][j]) % mod;\n\tans = 1LL * ans * fpow(2, q) % mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n\nnamespace {\n  const int mo = 1e9 + 7;\n  inline int add(int x, int y) {\n    if ((x += y) >= mo) x -= mo;\n    return x;\n  }\n  inline int mul(int x, int y) {\n    return 1LL * x * y % mo;\n  }\n  inline int power(int a, int k) {\n    int ans = 1;\n    for (; k; k >>= 1, a = mul(a, a))\n      if (k & 1) ans = mul(ans, a);\n    return ans;\n  }\n}\nconst int N = 3333;\nint n, q, a[N], f[N][N];\n\nint main(void) {\n  read(n); read(q);\n  rep (i, n) read(a[i]);\n  rep (i, n) rep (j, n) f[i][j] = a[i] > a[j];\n  int inv2 = power(2, mo - 2);\n  rep (i, q) {\n    int x, y; read(x); read(y);\n    rep (j, n) if (j != x && j != y) {\n      f[j][x] = f[j][y] = mul(inv2, add(f[j][x], f[j][y]));\n      f[x][j] = f[y][j] = mul(inv2, add(f[x][j], f[y][j]));\n    }\n    f[x][y] = f[y][x] = mul(inv2, add(f[x][y], f[y][x]));\n  }\n  int ans = 0;\n  rep (i, n) rep (j, n) if (i < j) ans = add(ans, f[i][j]);\n  cout << mul(ans, power(2, q)) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=3e3+100,mod=1e9+7,inv2=(mod+1)>>1;\nint n,Q,a[N],f[N][N],fx[N],gx[N],Ans;\nvoid Inc(int &x,int y) {x+=y, x=x>=mod?x-mod:x;}\nint qpow(LL x,int y)\n{\n\tLL ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret=ret*x%mod;\n\t\tx=x*x%mod, y>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=(a[i]>a[j])?1:0;\n\tfor(int q=1;q<=Q;++q)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tif(x == y) continue;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfx[i]=1ll*inv2*(f[x][i]+f[y][i])%mod,\n\t\t\tgx[i]=1ll*inv2*(f[i][x]+f[i][y])%mod;\n\t\tfx[y]=1ll*inv2*(f[x][y]+f[y][x])%mod;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tf[x][i]=fx[i], f[i][x]=gx[i],\n\t\t\tf[y][i]=fx[i], f[i][y]=gx[i];\n\t\tf[x][y]=f[y][x]=fx[y], f[x][x]=f[y][y]=0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j) Inc(Ans,f[i][j]);\n\tAns=1ll*Ans*qpow(2,Q)%mod; printf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nll n, q;\nll a[3000];\nP ind[3000];\nll x[3000], y[3000];\nll pow2[10000];\nP t[3000][3000];\nll z[3000][3000];\nll to[3000];\nll sum[3000];\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret * x % MOD;\n        x = x * x % MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nint main() {\n    pow2[0] = 1;\n    for (int i = 1; i < 10000; i++) pow2[i] = pow2[i-1] * 2 % MOD;\n    cin >> n >> q;\n    rep(i,n) cin >> a[i];\n    rep(i,q) cin >> x[i] >> y[i];\n    rep(i,q) { x[i]--; y[i]--; }\n    rep(i,n) t[i][i] = P(1, 0);\n    rep(i,q) {\n        rep(j,n) {\n            P tmp1 = t[j][x[i]];\n            P tmp2 = t[j][y[i]];\n            t[j][x[i]] = P((tmp1.first * pow2[i-tmp1.second] % MOD + tmp2.first * pow2[i-tmp2.second] % MOD) % MOD, i+1);\n            t[j][y[i]] = P((tmp1.first * pow2[i-tmp1.second] % MOD + tmp2.first * pow2[i-tmp2.second] % MOD) % MOD, i+1);\n        }\n    }\n    rep(i,n) rep(j,n) {\n        z[i][j] = t[i][j].first * pow2[q-t[i][j].second] % MOD;\n    }\n    rep(i,n) ind[i] = P(a[i], i);\n    sort(ind, ind+n);\n    ll ans = 0;\n    ll st = 0;\n    rep(i,n) {\n        for (int j = 0; j < n-1; j++) {\n            ans = (ans + z[ind[i].second][j] * sum[j+1]) % MOD;\n        }\n        for (int j = 0; j < n; j++) {\n            ans = (ans + (z[ind[i].second][j] * to[j] % MOD) * mod_pow(2,MOD-2)) % MOD;\n        }\n        if (i == n-1 || ind[i].first != ind[i+1].first) {\n            for (int u = st; u <= i; u++) {\n                rep(j,n) {\n                    to[j] = (to[j] + z[ind[u].second][j]) % MOD;\n                }\n                sum[n-1] = to[n-1];\n                for (int j = n-2; j >= 0; j--) {\n                    sum[j] = (sum[j+1] + to[j]) % MOD;\n                }\n            }\n            st = i+1;\n        }\n    }\n    ans = ans * mod_pow(pow2[q], MOD-2) % MOD;\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 3e3 + 10;\nconst int xm = - 20 + 10;\nconst int sq = 320;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst int base = 257;\n\nint n, q, a[xn], dp[2][xn][xn], ans, qq;\nll inv = power(2, mod - 2, mod);\n\nint main(){\n    InTheNameOfGod;\n    \n    cin >> n >> q;\n    for (int i = 1; i <= n; ++ i) cin >> a[i];\n    for (int i = 1; i <= n; ++ i){\n    \tfor (int j = i + 1; j <= n; ++ j){\n    \t\tif (a[i] < a[j]) dp[0][i][j] = 1;\n    \t\telse if (a[i] != a[j]) dp[1][i][j] = 1;\n\t\t}\n\t}\n\tqq = q;\n\twhile (qq --){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif (y < x) swap(x, y);\n\t\tfor (int i = 1; i < x; ++ i){\n\t\t\tdp[0][i][x] = dp[0][i][y] = ll((dp[0][i][x] + dp[0][i][y]) % mod) * inv % mod;\n\t\t\tdp[1][i][x] = dp[1][i][y] = ll((dp[1][i][x] + dp[1][i][y]) % mod) * inv % mod;\n\t\t}\n\t\tfor (int i = y + 1; i <= n; ++ i){\n\t\t\tdp[0][x][i] = dp[0][y][i] = ll((dp[0][x][i] + dp[0][y][i]) % mod) * inv % mod;\n\t\t\tdp[1][x][i] = dp[1][y][i] = ll((dp[1][x][i] + dp[1][y][i]) % mod) * inv % mod;\n\t\t}\n\t\tfor (int i = x + 1; i < y; ++ i){\n\t\t\tdp[0][x][i] = dp[1][i][y] = ll((dp[0][x][i] + dp[1][i][y]) % mod) * inv % mod;\n\t\t\tdp[1][x][i] = dp[0][i][y] = ll((dp[1][x][i] + dp[0][i][y]) % mod) * inv % mod;\n\t\t}\n\t\tdp[0][x][y] = dp[1][x][y] = ll((dp[0][x][y] + dp[1][x][y]) % mod) * inv % mod;\n\t}\n\tfor (int i = 1; i <= n; ++ i) for (int j = i + 1; j <= n; ++ j) ans = (ans + dp[1][i][j]) % mod;\n\tfor (int i = 0; i < q; ++ i) ans = ans * 2 % mod;\n\tcout << ans << endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <Mylib/Debug/debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T> void puts_all(const T &value){std::cout << value << \"\\n\";}\ntemplate <typename T, typename ...Args> void puts_all(const T &value, const Args&... args){std::cout << value << \" \";puts_all(args...);}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\ntemplate <typename T> auto make_vector(int n, int m, const T &value){return vector<vector<T>>(n, vector<T>(m, value));}\n\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n  }\n}init;\n\n\ntemplate <std::uint32_t M> class ModInt{\npublic:\n  std::uint64_t val;\n  ModInt(): val(0){}\n  ModInt(std::int64_t n){\n    if(n >= M) val = n % M;\n    else if(n < 0) val = n % M + M;\n    else val = n;\n  }\n  \n  inline constexpr auto operator+(const ModInt &a) const {return ModInt(val + a.val);}\n  inline constexpr auto operator-(const ModInt &a) const {return ModInt(val - a.val);}\n  inline constexpr auto operator*(const ModInt &a) const {return ModInt(val * a.val);}\n  inline constexpr auto operator/(const ModInt &a) const {return ModInt(val * a.inv().val);}\n  \n  inline constexpr auto& operator=(const ModInt &a){val = a.val; return *this;}\n  inline constexpr auto& operator+=(const ModInt &a){if((val += a.val) >= M) val -= M; return *this;}\n  inline constexpr auto& operator-=(const ModInt &a){if(val < a.val) val += M; val -= a.val; return *this;}\n  inline constexpr auto& operator*=(const ModInt &a){(val *= a.val) %= M; return *this;}\n  inline constexpr auto& operator/=(const ModInt &a){(val *= a.inv().val) %= M; return *this;}\n\n  inline constexpr bool operator==(const ModInt &a) const {return val == a.val;}\n  inline constexpr bool operator!=(const ModInt &a) const {return val != a.val;}\n\n  inline constexpr auto& operator++(){*this += 1; return *this;}\n  inline constexpr auto& operator--(){*this -= 1; return *this;}\n\n  inline constexpr auto operator++(int){auto t = *this; *this += 1; return t;}\n  inline constexpr auto operator--(int){auto t = *this; *this -= 1; return t;}\n\n  inline constexpr static auto frac(std::int64_t a, std::int64_t b){\n    return ModInt(a) / ModInt(b);\n  }\n  \n  inline constexpr static ModInt power(std::int64_t n, std::int64_t p){\n    if(p < 0) return power(n, -p).inv();\n    \n    ModInt ret = 1, e = n;\n    for(; p; e *= e, p >>= 1) if(p & 1) ret *= e;\n    return ret;\n  }\n\n  inline constexpr auto power(std::int64_t p) const {return power(val, p);}\n  \n  inline constexpr ModInt inv() const {\n    std::int64_t a = val, b = M, u = 1, v = 0;\n    \n    while(b){\n      std::int64_t t = a/b;\n      a -= t*b; std::swap(a,b);\n      u -= t*v; std::swap(u,v);\n    }\n    u %= M;\n    if(u < 0) u += M;\n    \n    return u;\n  }\n};\n\ntemplate <std::uint32_t M> auto operator-(const ModInt<M> &a){return ModInt<M>(-a.val);}\n\ntemplate <std::uint32_t M> auto operator+(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) + b;}\ntemplate <std::uint32_t M> auto operator-(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) - b;}\ntemplate <std::uint32_t M> auto operator*(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) * b;}\ntemplate <std::uint32_t M> auto operator/(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) / b;}\n\ntemplate <std::uint32_t M> std::istream& operator>>(std::istream &is, ModInt<M> &a){is >> a.val; return is;}\ntemplate <std::uint32_t M> std::ostream& operator<<(std::ostream &os, const ModInt<M> &a){os << a.val; return os;}\n\n\nusing mint = ModInt<1000000007>;\n\n\nconst mint div_2 = mint::frac(1, 2);\n\nint main(){\n  int N, Q; cin >> N >> Q;\n\n  vector<int> A(N); cin >> A;\n\n  vector<int> X(Q), Y(Q);\n  REP(i,Q){\n    cin >> X[i] >> Y[i];\n    --X[i], --Y[i];\n  }\n\n  auto dp = make_vector<mint>(N, N, 0);\n\n  REP(i,N){\n    REP(j,N){\n      if(A[i] > A[j]) dp[i][j] = 1;\n    }\n  }\n\n  REP(i,Q){\n    int x = X[i], y = Y[i];\n\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) / 2;\n\n    REP(j,N){\n      if(j == x or j == y) continue;\n\n      dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) / 2;\n      dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) / 2;\n    }\n  }\n\n\n  mint ans = 0;\n\n  REP(i,N){\n    FOR(j,i+1,N){\n      ans += dp[i][j];\n    }\n  }\n\n  ans *= mint::power(2, Q);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _WIN32\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stdout, format, args ...);\n\tfflush(stdout);\n}\n#else\n#define debugPrintf(...)\n#endif\n\nconst int MOD = ten(9) + 7;\n\nll dp[3000][3000];\n\nint main() {\n\tint n, q; reader(n, q);\n\tvector<int> a(n); FOR(i, n) reader(a[i]);\n\tFOR(i, n) FOR(j, n) {\n\t\tif (a[i] > a[j]) dp[i][j] = 1;\n\t}\n\tconst int inv2 = ((ten(9) + 7) + 1) / 2;\n\n\tFOR(i, q) {\n\t\tconst int turn = i + 1;\n\t\tint x, y; reader(x, y);\n\t\tx--; y--;\n\t\tif (x > y) swap(x, y);\n\t\tdp[x][y] = (dp[x][y] + dp[y][x]) * inv2 % MOD;\n\t\tdp[y][x] = dp[x][y];\n\t\tFOR(i, n) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[x][i] = (dp[x][i] + dp[y][i]) * inv2 % MOD;\n\t\t\tdp[y][i] = dp[x][i];\n\t\t}\n\t\tFOR(i, n) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[i][x] = (dp[i][x] + dp[i][y]) * inv2 % MOD;\n\t\t\tdp[i][y] = dp[i][x];\n\t\t}\n\t}\n\n\tll ans = 0;\n\tFOR(l, n) {\n\t\tfor (int r = l + 1; r < n; r++) {\n\t\t\tans += dp[l][r];\n\t\t}\n\t}\n\tFOR(i, q) ans = ans * 2 % MOD;\n\n\tans = (ans % MOD + MOD) % MOD;\n\twriterLn(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii_ pair<int,int>\n#define mp_ make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define show1(a) cout<<#a<<\" = \"<<a<<endl\n#define show2(a,b) cout<<#a<<\" = \"<<a<<\"; \"<<#b<<\" = \"<<b<<endl\nusing namespace std;\nconst ll INF = 1LL<<60;\nconst int inf = 1<<30;\nconst int maxn = 2e5+5;\nconst ll M = 1e9+7;\ninline void fastio() {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\ninline void add(ll &x,ll y){\n    x += y;\n    if(x>M) x-=M;\n    if(x<0) x+=M;\n}\nll qmul(ll a,ll b) {ll s=0;while(b){if(b&1)add(s,a);add(a,a);b>>=1;}return s; }\nll qpow(ll a,ll b) {ll s=1;while(b){if(b&1)s=qmul(s,a);a=qmul(a,a);b>>=1;}return s; }\nint n,a[3005],q,x,y;\nll f[3005][3005];\n\nint main()\n{\n    fastio();\n    cin>>n>>q;\n    rep(i,1,n) cin>>a[i];\n    rep(i,1,n) rep(j,1,n) f[i][j] = (a[i]>a[j]);\n    ll inv2 = qpow(2,M-2);\n    ll fc = qpow(2,q);\n    while(q--){\n        cin>>x>>y;\n        rep(i,1,n){\n            if(i!=x && i!=y){\n                f[i][x] = f[i][y] = (f[i][x]+f[i][y])*inv2%M;\n                f[x][i] = f[y][i] = (f[x][i]+f[y][i])*inv2%M;\n            }\n        }\n        f[x][y] = f[y][x] = (f[x][y]+f[y][x])*inv2%M;\n    }\n    ll ans = 0;\n    rep(i,1,n) rep(j,i+1,n) {\n        add(ans, f[i][j]*fc%M);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\nusing ll = long long int;\ntemplate<typename T>\nostream& operator+(ostream& out, const vector<T> &vec){\n    for(const auto &x : vec){\n        out<<x<<\" \";\n    }\n    out<<\"\\n\";\n    return out;\n}\ntemplate<typename T>\nostream& operator*(ostream& out, const vector<T> &vec){\n    for(const auto &x : vec){\n        out+x;\n    }\n    return out;\n}\ntemplate<typename T>\nistream& operator>>(istream& in, vector<T> &vec){\n    for(auto &x : vec){\n        in>>x;\n    }\n    return in;\n}\nconst int p = 1e9 + 7;\nvoid solve(){\n    int n,Q;\n    cin>>n>>Q;\n    vector<int> seq(n);\n    cin>>seq;\n    vector<pair<int,int>> op(Q);\n    for(auto &[u,v] : op){\n        cin>>u>>v;\n        --u;--v;\n    }\n    vector<vector<int>> dp(n, vector<int>(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            dp[i][j] = (seq[i]<seq[j]);\n        }\n    }\n    const ll inv2 = (p+1)/2;\n    for(const auto &[u,v] : op){\n        vector<int> dp1(n), dp2(n); \n        for(int i=0;i<n;i++){\n            if(i==u || i==v) continue;\n            dp1[i] = (dp[i][u] + dp[i][v])*inv2%p;\n            dp2[i] = (dp[u][i] + dp[v][i])*inv2%p;\n        }\n        for(int i=0;i<n;i++){\n            if(i==u || i==v) continue;\n            dp[i][u] = dp[i][v] = dp1[i];\n            dp[u][i] = dp[v][i] = dp2[i];\n        }\n        dp[u][v] = dp[v][u] = (dp[u][v] + dp[v][u])*inv2%p;\n    }\n    ll ans = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<i;j++){\n            ans+=dp[i][j];\n            if(ans>=p) ans-=p;\n        }\n    }\n    auto modpower = [&](int x){\n        int ans = 1;\n        while(x--){\n            ans<<=1;\n            if(ans>=p) ans-=p;\n        }\n        return ans;\n    };\n    cout<<ans*modpower(Q)%p<<'\\n';\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t dp[3000][3000];\n\nint main(){\n    int N, Q, A[3000];\n    cin >> N >> Q;\n    for(int i=0; i<N; i++) cin >> A[i];\n\n    for(int i=0; i<N; i++) for(int j=0; j<N; j++) if(A[i] > A[j]) dp[i][j] = 1;\n    int64_t inv2 = power_mod(2, MOD-2);\n\n    for(int q=0; q<Q; q++){\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n\n        for(int i=0; i<N; i++) if(i!=x && i!=y){\n            dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * inv2 % MOD;\n            dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * inv2 % MOD;\n        }\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * inv2 % MOD;\n    }\n\n    int64_t ans = 0;\n    for(int i=0; i<N; i++) for(int j=i+1; j<N; j++) add(ans, dp[i][j]);\n    ans = ans * power_mod(2, Q) % MOD;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,i,j,dp[3005][3005],a[3005],mod=1e9+7,inv=5e8+4,x,y,ans,f=1;\nint ag(int x,int y){return 1ll*(x+y)*inv%mod;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (i=1;i<=n;i++) for (j=1;j<=n;j++) if (i!=j) dp[i][j]=(a[i]>a[j]);\n\twhile (m--)\n\t{\n\t\t(f*=2)%=mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=ag(dp[x][y],dp[y][x]);\n\t\tfor (i=1;i<=n;i++) if (i!=x&&i!=y)\n\t\t{\n\t\t\tdp[x][i]=dp[y][i]=ag(dp[x][i],dp[y][i]);\n\t\t\tdp[i][y]=dp[i][x]=ag(dp[i][y],dp[i][x]);\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) for (j=i+1;j<=n;j++) (ans+=dp[i][j])%=mod;\n\tcout<<(1ll*ans*f)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// awoooooo\n\n# include <bits/stdc++.h>\n# define sz(x) (int)((x).size())\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair < int, int > pii;\n\nconst int N = (int)2e5 + 5;\nconst int inf = (int)1e9 + 7;\n\nint n, q;\nint a[3001];\nint nd[3001][3001], d[3001][3001];\n\nint main(){\n  int inv2 = (inf + 1) / 2;\n  scanf(\"%d %d\", &n, &q);\n  for(int i = 1; i <= n; ++i){\n    scanf(\"%d\", a + i);\n  }\n  for(int i = 1; i <= n; ++i){\n    for(int j = 1; j <= n; ++j){\n      d[i][j] = a[i] > a[j];\n    }\n  }\n  for(int i = 1; i <= q; ++i){\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    for(int z = 1; z <= n; ++z){\n      if(z == x || z == y) continue;\n      nd[z][x] = (d[z][x] + d[z][y]) * 1ll * inv2 % inf;\n      nd[z][y] = (d[z][y] + d[z][x]) * 1ll * inv2 % inf;\n      nd[x][z] = (d[y][z] + d[x][z]) * 1ll * inv2 % inf;\n      nd[y][z] = (d[x][z] + d[y][z]) * 1ll * inv2 % inf;\n    }\n    nd[x][y] = (d[x][y] + d[y][x]) * 1ll * inv2 % inf;\n    nd[y][x] = (d[x][y] + d[y][x]) * 1ll * inv2 % inf;\n    for(int z = 1; z <= n; ++z){\n      d[z][x] = nd[z][x];\n      d[z][y] = nd[z][y];\n      d[x][z] = nd[x][z];\n      d[y][z] = nd[y][z];\n    }\n  }\n  int ans = 0;\n  for(int i = 1; i <= n; ++i){\n    for(int j = i + 1; j <= n; ++j){\n      ans += d[i][j];\n      if(ans >= inf){\n        ans -= inf;\n      }\n    }\n  }\n  for(int i = 1; i <= q; ++i){\n    ans = ans * 2ll % inf;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\ntypedef tuple<int, int, ll> p;\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  vvl dp = VV(n+1, n+1, 0, ll); //iの方が前にある\n  for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) dp[i][j] = 1;\n\n  ll z = 1;\n  for(int i=0;i<q;i++) z = (z*2)%P;\n  for(auto v:query){\n    vector<p> tmp;\n    ll x = v[0], y = v[1];\n    if(x>y) swap(x, y);\n\n    // x, y\n    tmp.push_back(p(y, x, dp[x][y]));\n    tmp.push_back(p(x, y, dp[y][x]));\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      tmp.push_back(p(i, x, dp[i][y]));\n      tmp.push_back(p(x, i, dp[y][i]));\n    }\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      tmp.push_back(p(i, y, dp[i][x]));\n      tmp.push_back(p(y, i, dp[x][i]));\n    }\n\n    for(auto ad:tmp){\n      ll s = get<0>(ad);\n      ll t = get<1>(ad);\n      ll u = get<2>(ad);\n      dp[s][t] = (dp[s][t] + u)%P;\n    }\n    dp[x][y] = (dp[x][y]*I)%P;\n    dp[y][x] = (dp[y][x]*I)%P;\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      dp[i][x] = (dp[i][x]*I)%P;\n      dp[i][y] = (dp[i][y]*I)%P;\n      dp[x][i] = (dp[x][i]*I)%P;\n      dp[y][i] = (dp[y][i]*I)%P;\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(a[i]<a[j]) ans = (ans + (z*dp[j][i])%P)%P;\n      if(a[i]>a[j]) ans = (ans + (z*dp[i][j])%P)%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1e9+7,inv2=(mod+1)/2;\nint n,q,a[4001],dp[4001][4001];\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)dp[i][j]=(a[i]>a[j]);\n\tfor(int k=1,x,y;k<=q;k++)\n\t{\n\t\tcin>>x>>y;\n\t\tdp[x][y]=dp[y][x]=1ll*inv2*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i!=x&&i!=y)dp[i][x]=dp[i][y]=1ll*inv2*(dp[i][x]+dp[i][y])%mod,dp[x][i]=dp[y][i]=1ll*inv2*(dp[x][i]+dp[y][i])%mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)ans+=dp[i][j];\n\twhile(q--)ans=ans*2%mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nint f[3001][3001],n,q,x[3001],y[3001],a[3001],Pow[3001],ans;\nconst int P=1000000007;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tPow[0]=1;\n\tfor(int i=1;i<=q;i++)scanf(\"%d%d\",x+i,y+i),(x[i]>y[i])?std::swap(x[i],y[i]):(void)0,Pow[i]=add(Pow[i-1],Pow[i-1]);\n\tfor(int i=q;i;i--){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j<x[i])f[j][x[i]]=f[j][y[i]]=mul(add(f[j][y[i]],f[j][x[i]]),(P+1)>>1);\n\t\t\telse if(j>x[i]&&j<y[i]){\n\t\t\t\tint tem=mul(add(f[x[i]][j],sub(1,f[j][y[i]])),(P+1)>>1);\n\t\t\t\tf[j][y[i]]=mul(add(f[j][y[i]],sub(1,f[x[i]][j])),(P+1)>>1);\n\t\t\t\tf[x[i]][j]=tem;\n\t\t\t}\n\t\t\telse if(j>y[i])f[x[i]][j]=f[y[i]][j]=mul(add(f[y[i]][j],f[x[i]][j]),(P+1)>>1);\n\t\tf[x[i]][y[i]]=(P+1)>>1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(a[i]<a[j])ans=add(ans,f[i][j]);\n\t\t\telse if(a[i]>a[j])ans=add(ans,sub(1,f[i][j]));\n\tprintf(\"%d\\n\",mul(ans,Pow[q]));\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/*\n * Dependencies: typedef long long ll\n * Headers: iostream\n * Verified by: ARC099-F\n *              https://beta.atcoder.jp/contests/arc099/submissions/2743855\n */\n\ntemplate<ll mod = (ll)1e9 + 7>\nstruct ModInt {\n  ll x;\n  ModInt(void): x(0) {}\n  ModInt(ll x): x(x % mod){}\n  ModInt(const ModInt &x): x(x.x) {}\n  ModInt operator+(ModInt o) const {\n    ll y = x + o.x;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator-(ModInt o) const {\n    ll y = x - o.x + mod;\n    if (y >= mod) y -= mod;\n    return ModInt(y);\n  }\n  ModInt operator*(ModInt o) const {\n    return ModInt((x * o.x) % mod);\n  }\n  void operator+=(ModInt o) { *this = *this + o; }\n  void operator-=(ModInt o) { *this = *this - o; }\n  void operator*=(ModInt o) { *this = *this * o; }\n  ModInt operator-(void) const { return ModInt() - *this; }\n  ll to_ll() const {\n    return x;\n  }\n  bool operator<(ModInt o) const {\n    return x < o.x;\n  }\n  ModInt pow(ll e) {\n    assert (e >= 0);\n    ModInt sum = 1;\n    ModInt cur = *this;\n    while (e > 0) {\n      if (e % 2) {\n        sum = sum * cur;\n      }\n      cur = cur * cur;\n      e /= 2;\n    }\n    return sum;\n  }\n  ModInt inv(void) {\n    return pow(mod - 2);\n  }\n};\n\ntemplate<ll mod>\nostream &operator<<(ostream &os, ModInt<mod> mi) {\n  return os << mi.x;\n}\n\nconst int N = 3010;\nModInt<> dp[N][N];\nModInt<> acc[N][N];\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  VL a(n);\n  REP(i, 0, n) cin >> a[i];\n  VI x(q), y(q);\n  REP(i, 0, q) {\n    cin >> x[i] >> y[i];\n    x[i]--, y[i]--;\n  }\n  REP(i, 0, n) {\n    dp[i][i] = 1;\n  }\n  ModInt<> two(2);\n  ModInt<> twoinv = two.inv();\n  REP(i, 0, q) {\n    REP(j, 0, n) {\n      ModInt<> tmp = (dp[j][x[i]] + dp[j][y[i]]) * twoinv;\n      dp[j][x[i]] = tmp;\n      dp[j][y[i]] = tmp;\n    }\n  }\n  REP(i, 0, n) {\n    REP(j, 0, n) acc[i][j + 1] = acc[i][j] + dp[i][j];\n  }\n  vector<PI> pool;\n  REP(i, 0, n) pool.push_back(PI(a[i], i));\n  sort(pool.rbegin(), pool.rend());\n  vector<ModInt<> > tap(n + 1);\n  VI que;\n  // TODO proof\n  ModInt<> tot = 0;\n  REP(i, 0, n) {\n    if (DEBUG) cerr << \"pool:\" << pool[i].first << \" \" << pool[i].second << endl;\n    if (i > 0 && pool[i].first != pool[i - 1].first) {\n      // tap\n      for (int t: que) {\n        if (DEBUG) cerr << \"pushing \" << t << endl;\n        REP(j, 0, n + 1) {\n          tap[j] += acc[t][j];\n        }\n      }\n      que.clear();\n    }\n    int idx = pool[i].second;\n    REP(k, 0, n) {\n      tot += dp[idx][k] * tap[k];\n      tot += dp[idx][k] * (tap[k + 1] - tap[k]) * twoinv;\n    }\n    que.push_back(idx);\n  }\n  REP(i, 0, q) tot *= two;\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[20000100];\n                int inv[20000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\nint dp[3010][3010]={};\n\nsigned main(){\n\t\n\t\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\t\n\tint n,Q;\n\tcin>>n>>Q;\n\tvector<int> a(n);\n\t\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(a[i]<a[j]){\n\t\tdp[i][j]=1;\n\t//\tcout<<i<<\" \"<<j<<endl;\n\t}\n\tint ni=beki(2,inf-2,inf);\n\tfor(int er=0;er<Q;er++){\n\t\t\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tfor(int i=0;i<n;i++)if(x!=i && y!=i){\n\t\t\tint t=dp[i][x]+dp[i][y];\n\t\t\tt*=ni;\n\t\t\tt%=inf;\n\t\t\tdp[i][x]=t;\n\t\t\tdp[i][y]=t;\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)if(x!=i && y!=i){\n\t\t\tint t=dp[x][i]+dp[y][i];\n\t\t\tt*=ni;\n\t\t\tt%=inf;\n\t\t\tdp[x][i]=t;\n\t\t\tdp[y][i]=t;\n\t\t\t\n\t\t}\n\t\t{\n\t\t\t//cout<<dp[x][y]<<\" \"<<\n\t\t\tint t=dp[x][y]+dp[y][x];\n\t\t\tt*=ni;\n\t\t\tt%=inf;\n\t\t\t\n\t\t\tdp[x][y]=t;\n\t\t\tdp[y][x]=t;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(i>j){\n\tans+=dp[i][j];\n\t\tans%=inf;\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tans*=2;\n\t\tans%=inf;\n\t}\n\tcout<<ans<<endl;\n\treturn 0; \n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define re register\n#define gc getchar()\n#define ll long long\n\ninline ll read() {\n\tre ll x(0), f(1); re char c(gc);\n\twhile (c > '9' || c < '0') f = c == '-' ? -1 : 1, c = gc;\n\twhile (c <= '9' && c >= '0') x = x * 10 + c -48, c = gc;\n\treturn x * f;\n}\n\nconst int N = 3030, mod = 1e9 + 7;\nint n, q, a[N];\nll ans, f[N][N], inv;\n\nll qpow (ll a, int b) {\n    ll x (1);\n    while (b) {\n        if (b & 1) x = x * a % mod;\n        a = a * a % mod, b >>= 1;\n    } return x;\n}\n\nint main () {\n    n = read(), q = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <=n; ++j) \n            f[i][j] = a[i] < a[j];\n    inv = qpow (2, mod -2);\n    for (int d = 1; d <= q; ++d) {\n        int x = read(), y = read();\n        f[x][y] = f[y][x] = inv * (f[x][y] + f[y][x]) % mod;\n        for (int j = 1; j <= n; ++j) if (j != x && j != y) {\n            f[j][x] = f[j][y] = inv * (f[j][x] + f[j][y]) % mod;\n            f[x][j] = f[y][j] = inv * (f[x][j] + f[y][j]) % mod;\n        }\n    } ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = i+1; j <= n; ++j)\n            ans += f[i][j];\n    cout << ans * qpow (2, q) % mod << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t  Author : @evenbao\n\t  Created : 2020 / 07 / 27\n*/\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define pii pair<int , int>\n#define mp make_pair\n#define fi first\n#define se second\n\nconst int MN = 3005;\nconst int mod = 1e9 + 7;\nconst int Inv2 = (mod + 1) / 2;\n\nint N , Q , Coef;\nint a[MN] , dp[MN][MN] , p1[MN] , p2[MN];\n\ntemplate <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }\ntemplate <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }\ntemplate <typename T> inline void read(T &x) {\n    T f = 1; x = 0;\n    char c = getchar();\n    for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n    x *= f;\n}\n\ninline void inc(int &x , int y) {\n\t\tx = x + y < mod ? x + y : x + y - mod;\n}\ninline void dec(int &x , int y) {\n\t\tx = x - y >= 0 ? x - y : x - y + mod;\n}\n\nint main() {\n\t\t\n\t\tread(N); read(Q); Coef = 1;\n\t\tfor (int i = 1; i <= N; ++i) read(a[i]);\n\t\tfor (int i = 1; i <= Q; ++i) {\n\t\t\t\tread(p1[i]) , read(p2[i]);\n\t\t\t\tif (p1[i] > p2[i]) swap(p1[i] , p2[i]);\n\t\t}\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\t\tfor (int j = 1; j <= N; ++j)\n\t\t\t\t\t\tdp[i][j] = a[i] > a[j];\n\t\tfor (int i = 1; i <= Q; ++i) {\n\t\t\t\tstatic int tmp[MN][MN];\n\t\t\t\tfor (int x = 1; x <= N; ++x)\n\t\t\t\t\t\tif (x != p1[i] && x != p2[i]) {\n\t\t\t\t\t\t\t\ttmp[x][p1[i]] = (LL) Inv2 * (dp[x][p1[i]] + dp[x][p2[i]]) % mod;\n\t\t\t\t\t\t\t\ttmp[p1[i]][x] = (LL) Inv2 * (dp[p1[i]][x] + dp[p2[i]][x]) % mod;\n\t\t\t\t\t\t\t\ttmp[x][p2[i]] = (LL) Inv2 * (dp[x][p2[i]] + dp[x][p1[i]]) % mod;\n\t\t\t\t\t\t\t\ttmp[p2[i]][x] = (LL) Inv2 * (dp[p2[i]][x] + dp[p1[i]][x]) % mod;\n\t\t\t\t\t\t}\n\t\t\t\tfor (int x = 1; x <= N; ++x) \n\t\t\t\t\t\tif (x != p1[i] && x != p2[i]) {\n\t\t\t\t\t\t\t\tdp[x][p1[i]] = tmp[x][p1[i]];\n\t\t\t\t\t\t\t\tdp[p1[i]][x] = tmp[p1[i]][x];\n\t\t\t\t\t\t\t\tdp[x][p2[i]] = tmp[x][p2[i]];\n\t\t\t\t\t\t\t\tdp[p2[i]][x] = tmp[p2[i]][x];\n\t\t\t\t\t\t}\n\t\t\t\tdp[p1[i]][p2[i]] = dp[p2[i]][p1[i]] = (LL) Inv2 * (dp[p1[i]][p2[i]] + dp[p2[i]][p1[i]]) % mod;\n\t\t\t\tCoef = 2LL * Coef % mod;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int x = 1; x < N; ++x)\n\t\t\t\tfor (int y = x + 1; y <= N; ++y)\n\t\t\t\t\t\tinc(ans , dp[x][y]);\n\t\tprintf(\"%d\\n\" , (LL) ans * Coef % mod);\n\t  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 3005;\nconst int   mod = 1e9 + 7;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\n\nint f[N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int q;  cin >> q;\n\n    vector<int> a(n);\n\n    for(int&x : a)\n        cin >> x;\n\n    for(int i = 0 ; i < n ; ++i)\n    for(int j = 0 ; j < n ; ++j)\n        f[i][j] = (a[i] > a[j]);\n\n    for(int i = 0 ; i < q ; ++i)    {\n        int x;  cin >> x;   --x;\n        int y;  cin >> y;   --y;\n\n        for(int j = 0 ; j < n ; ++j)    if (x != j && y != j)   {\n            int S = 0;\n            add(S,f[j][x]);\n            add(S,f[j][y]);\n\n            f[j][x] = f[j][y] = mul(S,500000004);   S = 0;\n\n            add(S,f[x][j]);\n            add(S,f[y][j]);\n\n            f[x][j] = f[y][j] = mul(S,500000004);\n        }\n        add(f[x][y],f[y][x]);\n\n        f[x][y] = mul(f[x][y],500000004);\n        f[y][x] = f[x][y];\n    }\n    int ans = 0;\n\n    for(int i = 0 ; i < n ; ++i)\n    for(int j = i ; j < n ; ++j)\n        add(ans,f[i][j]);\n\n    cout << mul(ans,Pow(2,q)) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=3010,Mod=1e9+7,INV2=500000004;\nint n,Q,a[N],f[N][N];\n\nint main()\n{\n\tn=gi();Q=gi();int pw=1;\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)f[i][j]=(a[i]<a[j]);\n\twhile(Q--)\n\t{\n\t\tint x=gi(),y=gi();pw=2ll*pw%Mod;\n\t\tf[x][y]=f[y][x]=1ll*INV2*(f[x][y]+f[y][x])%Mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(x!=i&&i!=y)\n\t\t\t{\n\t\t\t\tf[x][i]=f[y][i]=1ll*INV2*(f[x][i]+f[y][i])%Mod;\n\t\t\t\tf[i][x]=f[i][y]=1ll*INV2*(f[i][x]+f[i][y])%Mod;\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)ans=(ans+f[i][j])%Mod;\n\tprintf(\"%lld\\n\",1ll*ans*pw%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=3e3+5,Mod=1e9+7,Inv2=Mod+1>>1;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,q,a[MAXN],F[MAXN][MAXN],ans,t;\ninline void Add(int&x,int y){x+=y,x>=Mod?x-=Mod:0;}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),q=read();\n\tRep(i,1,n)a[i]=read();\n\tRep(i,1,n)Rep(j,1,n)F[i][j]=a[i]>a[j];\n\tfor(t=1;q--;){\n\t\tint x=read(),y=read();t=t*2%Mod;\n\t\tF[x][y]=F[y][x]=1ll*(F[x][y]+F[y][x])*Inv2%Mod;\n\t\tRep(i,1,n)if(i!=x&&i!=y)F[i][x]=F[i][y]=1ll*(F[i][x]+F[i][y])*Inv2%Mod,F[x][i]=F[y][i]=1ll*(F[x][i]+F[y][i])*Inv2%Mod;\n\t}Rep(i,1,n)Rep(j,i+1,n)ans=(ans+F[i][j])%Mod;cout<<1ll*ans*t%Mod<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int P=1e9+7,N=3005,I2=500000004;\n\nint n,q;\nint a[N];\nint f[N][N];\n\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    FOR(i,1,n)scanf(\"%d\",&a[i]);\n    FOR(i,1,n)FOR(j,1,n){\n        if(a[i]>a[j])f[i][j]=1;\n    }\n    FOR(i,1,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        if(x>y)swap(x,y);\n        f[x][y]=(1ll*f[x][y]*I2+1ll*f[y][x]*I2)%P;\n        f[y][x]=f[x][y];\n        FOR(i,1,n){\n            if(i==x||i==y)continue;\n            f[x][i]=(1ll*f[x][i]*I2+1ll*f[y][i]*I2)%P;\n            f[y][i]=f[x][i];\n            f[i][x]=(1ll*f[i][x]*I2+1ll*f[i][y]*I2)%P;\n            f[i][y]=f[i][x];\n        }\n    }\n    int ans=0;\n    FOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%P;\n    FOR(i,1,q)ans=ans*2%P;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n\n*/\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define gc() getchar()\n#define mod 1000000007\n#define inv2 500000004ll\ntypedef long long LL;\nconst int N=3005;\n\ninline int read()\n{\n\tint now=0;register char c=gc();\n\tfor(;!isdigit(c);c=gc());\n\tfor(;isdigit(c);now=now*10+c-48,c=gc());\n\treturn now;\n}\ninline int FP(int x,int k)\n{\n\tint t=1;\n\tfor(; k; k>>=1,x=1ll*x*x%mod)\n\t\tif(k&1) t=1ll*t*x%mod;\n\treturn t;\n}\n\nint main()\n{\n\tstatic int A[N],f[N][N];\n\tconst int n=read(),q=read();\n\tfor(int i=1; i<=n; ++i) A[i]=read();\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=n; ++j) f[i][j]=A[i]<A[j];\n\tfor(int i=1; i<=q; ++i)\n\t{\n\t\tint x=read(),y=read();\n\t\tf[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%mod;\n\t\tfor(int j=1; j<=n; ++j)\n\t\t\tif(j!=x && j!=y)\n\t\t\t\tf[j][x]=f[j][y]=inv2*(f[j][x]+f[j][y])%mod,\n\t\t\t\tf[x][j]=f[y][j]=inv2*(f[x][j]+f[y][j])%mod;\n\t}\n\tLL ans=0;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<i; ++j) ans+=f[i][j];\n\tprintf(\"%lld\\n\",ans%mod*FP(2,q)%mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n\n#define N 3010\n#define RG register\n#define ll long long\n#define MOD 1000000007\n#define Iv2 500000004\n\nusing namespace std;\n\ninline int read(){\n    RG int x=0,t=1;RG char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return x*t;\n}\n\nint n,Q,a[N],f[N][N],tA[N],tB[N],tC[N],tD[N];\ninline int Plu(const int &x,const int &y) { return x+y>=MOD?x+y-MOD:x+y; }\ninline int Pow(int x,int y){ int ans=1;\n\twhile(y) { if(y&1) ans=1LL*ans*x%MOD; x=1LL*x*x%MOD,y>>=1; }\n\treturn ans;\n}\n\nint main(){\n\tn=read(),Q=read(); int cp=Q;\n\tfor(RG int i=1;i<=n;++i) a[i]=read();\n\tfor(RG int i=1;i<=n;++i)\n\t\tfor(RG int j=1;j<=n;++j)\n\t\t\tf[i][j]=a[i]>a[j];\n\twhile(Q--){\n\t\tint x=read(),y=read();\n\t\tfor(RG int i=1;i<=n;++i)\n\t\t\ttA[i]=f[x][i],tB[i]=f[y][i],tC[i]=f[i][x],tD[i]=f[i][y];\n\t\tfor(RG int i=1;i<=n;++i){\n\t\t\tif(i==x||i==y) continue ;\n\t\t\tf[x][i]=1LL*Plu(tB[i],f[x][i])*Iv2%MOD;\n\t\t\tf[y][i]=1LL*Plu(tA[i],f[y][i])*Iv2%MOD;\n\t\t\tf[i][x]=1LL*Plu(tD[i],f[i][x])*Iv2%MOD;\n\t\t\tf[i][y]=1LL*Plu(tC[i],f[i][y])*Iv2%MOD;\n\t\t}\n\t\tf[x][y]=1LL*Plu(f[x][y],tB[x])*Iv2%MOD;\n\t\tf[y][x]=1LL*Plu(f[y][x],tA[y])*Iv2%MOD;\n\t}   int ans=0;\n\tfor(RG int i=1;i<=n;++i)\n\t\tfor(RG int j=i+1;j<=n;++j)\n\t\t\tans=Plu(f[i][j],ans);\n\tprintf(\"%lld\\n\",1LL*ans*Pow(2,cp)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MOD = 1000000007;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0) a += MOD;\n}\n\nint mul(int a, int b) {\n  return (int) ((a * 1LL * b) % MOD);\n}\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) {\n  return mpow(x, MOD - 2);\n}\n\nstruct data {\n  int m;\n  int im;\n  vector<vector<int>> vals;\n\n  int get(int x, int y) {\n    return mul(vals[x][y], m);\n  }\n\n  void set(int x, int y, int v) {\n    vals[x][y] = mul(v, im);\n  }\n\n  void mult_all(int x) {\n    m = mul(m, x);\n    im = mul(im, minv(x));\n  }\n\n  data(int n): m(1), im(1), vals(n, vector<int>(n, 0)) {}\n};\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  int n, q;\n  int i2 = minv(2);\n  while (scanf(\"%d%d\", &n, &q) == 2) {\n    data d(n);\n    vector<int> v(n);\n    for (int i = 0; i < n; i++){\n      scanf(\"%d\", &v[i]);\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        d.set(i, j, v[i] > v[j]);\n      }\n    }\n\n    for (int i = 0; i < q; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      --x, --y;\n      if (x > y) swap(x, y);\n      d.mult_all(2);\n      for (int z = 0; z < n; z++) {\n        if (z == x || z == y) continue;\n        {\n          int a = d.get(x, z);\n          int b = d.get(y, z);\n          add(a, b);\n          a = mul(a, i2);\n          d.set(x, z, a);\n          d.set(y, z, a);\n        }\n        {\n          int a = d.get(z, x);\n          int b = d.get(z, y);\n          add(a, b);\n          a = mul(a, i2);\n          d.set(z, x, a);\n          d.set(z, y, a);\n        }\n      }\n\n      int a = d.get(x, y);\n      int b = d.get(y, x);\n      add(a, b);\n      a = mul(a, i2);\n      d.set(x, y, a);\n      d.set(y, x, a);\n\n//      eprintf(\"===\\n\");\n//      for (int i = 0; i < n; i++) {\n//        for (int j = 0; j < n; j++) {\n//          eprintf(\"%d \", d.get(i, j));\n//        }\n//        eprintf(\"\\n\");\n//      }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        add(ans, d.get(i, j));\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n#define MAXN 3005\n#define P 998244353\n#define INV 499122177\n#define INF 0x3f3f3f3f\n#define rint register int\n#define LL long long\n#define LD long double\nusing namespace std;\n\nint n, q, ans, a[MAXN], f[MAXN][MAXN];\n\ninline int add(int x, int y) {return x+y>=P?x+y-P:x+y;}\ninline int sub(int x, int y) {return x>=y?x-y:x-y+P;}\n\ninline int ksm(int x, int y)\n{\n    int ans=1;\n    while(y)\n    {\n        if(y&1) ans=1LL*x*ans%P;\n        x=1LL*x*x%P, y>>=1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &q);\n    for(rint i=1; i<=n; ++i) scanf(\"%d\", &a[i]);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=1; j<=n; ++j) if(a[i]>a[j]) f[i][j]=1;\n    for(rint i=1, x, y; i<=q; ++i)\n    {\n        scanf(\"%d%d\", &x, &y);\n        int t1, t2;\n        for(rint j=1; j<=n; ++j)\n        {\n            if(j==x || j==y) continue;\n            t1=f[x][j], t2=f[y][j];\n            f[y][j]=f[x][j]=1LL*add(t1, t2)*INV%P;\n            t1=f[j][x], t2=f[j][y];\n            f[j][x]=f[j][y]=1LL*add(t1, t2)*INV%P;\n        }\n        \n        t1=f[x][y], t2=f[y][x];\n        f[x][y]=f[y][x]=1LL*add(t1, t2)*INV%P;\n    }\n    int temp=ksm(2, q);\n    for(rint i=1; i<=n; ++i)\n        for(rint j=i+1; j<=n; ++j)\n            ans=add(ans, 1LL*f[i][j]*temp%P);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\nusing namespace std;\ntypedef long long ll;\nconst int N = 3005;\nconst int mod = 1e9 + 7;\nint n, q, x[N], y[N], a[N];\nll inv[N], fac[N];\nll Pow(ll a, int x) {\n\tll res = 1;\n\twhile (x) {\n\t\tif (x & 1) (res *= a) %= mod;\n\t\t(a *= a) %= mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\nll s[N][N], ss[N][4], ans;\npair<int, int> Swap(int X, int Y, int i) {\n\tif (X == x[i]) X = y[i];\n\telse if (X == y[i]) X = x[i];\n\tif (Y == x[i]) Y = y[i];\n\telse if (Y == y[i]) Y = x[i];\n\treturn mk(X, Y); \n}\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= q; ++i) scanf(\"%d %d\", x + i, y + i);\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; ++i) fac[i] = fac[i - 1] * 2 % mod;\n\tfor (int i = 0; i < N; ++i) inv[i] = Pow(fac[i], mod - 2);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\ts[i][j] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (a[i] < a[j]) s[i][j] = 1;\n\tfor (int i = 1; i <= q; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tss[j][0] = s[x[i]][j];\n\t\t\tss[j][1] = s[y[i]][j];\n\t\t\tss[j][2] = s[j][x[i]];\n\t\t\tss[j][3] = s[j][y[i]];\n\t\t}\t\t\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tpair<int, int> p;\n\t\t\tp = Swap(x[i], j, i);\n\t\t\t(s[p.first][p.second] += (ss[j][0] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t\tp = Swap(y[i], j, i);\n\t\t\t(s[p.first][p.second] += (ss[j][1] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t\tp = Swap(j, x[i], i);\n\t\t\tif (j != x[i] && j != y[i])\n\t\t\t\t(s[p.first][p.second] += (ss[j][2] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t\tp = Swap(j, y[i], i);\n\t\t\tif (j != x[i] && j != y[i])\n\t\t\t\t(s[p.first][p.second] += (ss[j][3] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\t(ans += fac[q] * s[i][j] % mod) %= mod;\n\t//\n\t/*for (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\ts[i][j] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (a[i] > a[j]) s[i][j] = 1;\n\tfor (int i = 1; i <= q; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tss[j][0] = s[x[i]][j];\n\t\t\tss[j][1] = s[y[i]][j];\n\t\t\tss[j][2] = s[j][x[i]];\n\t\t\tss[j][3] = s[j][y[i]];\n\t\t}\t\t\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tpair<int, int> p;\n\t\t\tp = Swap(x[i], j, i);\n\t\t\t(s[p.first][p.second] += (ss[j][0] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t\tp = Swap(y[i], j, i);\n\t\t\t(s[p.first][p.second] += (ss[j][1] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t\tp = Swap(j, x[i], i);\n\t\t\tif (j != x[i] && j != y[i])\n\t\t\t\t(s[p.first][p.second] += (ss[j][2] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t\tp = Swap(j, y[i], i);\n\t\t\tif (j != x[i] && j != y[i])\n\t\t\t\t(s[p.first][p.second] += (ss[j][3] - s[p.first][p.second] + mod) * inv[1] % mod) %= mod;\n\t\t\t//\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t(ans += fac[q] * s[i][j] % mod) %= mod;*/\n\t//\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define nn 3008\n#define ll long long\n#define mod 998244353\n#define lf double\nusing namespace std;\nll dp[nn][nn];\nll qpow(ll x,ll y)\n{\n\tll res=1;\n\twhile(y)\n\t{\n\t\tif(y&1) res=res*x%mod;\n\t\tx=x*x%mod;y=y/2;\n\t}\n\treturn res;\n}\nll d2;\nint org[nn];\nll tmp1[nn],tmp2[nn];\nint main()\n{\n\td2=qpow(2,mod-2);\n\tll n,m;scanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&org[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(org[i]>org[j]) dp[i][j]=1;\n\tfor(int ytl=1;ytl<=m;ytl++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;i++) tmp1[i]=(dp[x][i]+dp[y][i])*d2%mod;\n\t\tfor(int i=1;i<=n;i++) tmp2[i]=(dp[i][x]+dp[i][y])*d2%mod;\n\t\tll tmp3=(dp[x][y]+dp[y][x])*d2%mod;\n\t\tfor(int i=1;i<=n;i++) \n\t\t\tdp[i][y]=dp[i][x]=tmp2[i];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tdp[x][i]=dp[y][i]=tmp1[i];\n\t\tdp[x][x]=dp[y][y]=0;\n\t\tdp[x][y]=dp[y][x]=tmp3;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans+=dp[i][j],ans%=mod;\n\tcout<<ans*qpow(2,m)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, Q;\n\tcin >> N >> Q;\n\tvector<ll> A(N + 1);\n\trepn(i, N) cin >> A[i];\n\n\tvector<ll> X(Q + 1), Y(Q + 1);\n\trepn(i, Q) cin >> X[i] >> Y[i];\n\n\tvector<vector<mint>> dp(N + 1, vector<mint>(N + 1,0));\n\tvector<vector<ll>> up(N + 1, vector<ll>(N + 1, 0));\n\n\trepn(i, N)repn(j, N) {\n\t\tif (A[i] > A[j]) { dp[i][j] = 1; }\n\t}\n\t\n\trepn(q, Q) {\n\t\tmap<pair<ll, ll>, mint> mp;\n\t\tll x = X[q];\n\t\tll y = Y[q];\n\n\t\trepn(i, N) {\n\t\t\tif (i == x || i == y) { continue; }\n\n\t\t\tmint t, u;\n\n\t\t\tt = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tt += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tu = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tu += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tdp[x][i] = t;\n\t\t\tdp[y][i] = u;\n\n\t\t\tt = 0;\n\t\t\tu = 0;\n\n\t\t\tt = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tt += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tu = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tu += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tdp[i][x] = t;\n\t\t\tdp[i][y] = u;\n\n\t\t\tup[x][i] = q;\n\t\t\tup[y][i] = q;\n\t\t\tup[i][x] = q;\n\t\t\tup[i][y] = q;\n\n\t\t}\n\n\t\tmint t, u;\n\n\t\tt = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tt += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tu = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tu+= ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tdp[x][y] = t;\n\t\tdp[y][x] = u;\n\n\t\tup[x][y] = q;\n\t\tup[y][x] = q;\n\n\n\n\t}\n\n\tmint ans = 0;\n\trepn(i, N)repn(j, N) {\n\t\tdp[i][j] *= ((mint)2 ^ (Q - up[i][j]));\n\t\tif (j > i) { ans += dp[i][j]; }\n\t}\n\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint N, Q;\nint A[3000];\nMInt DP[3000][3000];\nint main() {\n\tcin >> N >> Q;\n\tREP(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\t\n\tREP(i, 0, N) {\n\t\tREP(j, 0, N) {\n\t\t\tDP[i][j] = A[i] > A[j];\n\t\t}\n\t}\n\n\tREP(z, 0, Q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\n\t\t{\n\t\t\tMInt t = (DP[x][y] + DP[y][x]) / 2;\n\t\t\tDP[x][y] = t;\n\t\t\tDP[y][x] = t;\n\t\t}\n\n\t\tREP(j, 0, N) {\n\t\t\tif (j == x || j == y) continue;\n\t\t\tMInt t = (DP[x][j] + DP[y][j]) / 2;\n\t\t\tDP[x][j] = t;\n\t\t\tDP[y][j] = t;\n\t\t}\n\n\t\tREP(i, 0, N) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tMInt t = (DP[i][x] + DP[i][y]) / 2;\n\t\t\tDP[i][x] = t;\n\t\t\tDP[i][y] = t;\n\t\t}\n\t}\n\n\tMInt sum = 0;\n\tREP(i, 0, N) {\n\t\tREP(j, i + 1, N) {\n\t\t\tsum += DP[i][j] * MInt(2).power(Q);\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MAX 3030\n#define MOD 1000000007\n#define inv2 500000004\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint A[MAX],S[MAX],tot;\nint f[MAX][MAX];\nint tmp[MAX][MAX];\nint n,Q;\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tn=read();Q=read();\n\tfor(int i=1;i<=n;++i)A[i]=S[i]=read();\n\tsort(&S[1],&S[n+1]);tot=unique(&S[1],&S[n+1])-S-1;\n\tfor(int i=1;i<=n;++i)A[i]=lower_bound(&S[1],&S[n+1],A[i])-S;\n\t//for(int i=1;i<=n;++i)f[i][i]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(A[i]<A[j])f[i][j]=1;\n\tint bin=1;for(int i=1;i<=Q;++i)bin=(bin+bin)%MOD;\n\twhile(Q--)\n\t{\n\t\tint x=read(),y=read();\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[i][y]=f[i][x]=1ll*inv2*(f[i][x]+f[i][y])%MOD;\n\t\t\tf[y][i]=f[x][i]=1ll*inv2*(f[x][i]+f[y][i])%MOD;\n\t\t\t//tmp[i][y]=1ll*inv2*(f[i][y]+f[i][x])%MOD;\n\t\t\t//tmp[y][i]=1ll*inv2*(f[y][i]+f[x][i])%MOD;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*inv2*(f[y][x]+f[x][y])%MOD;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tans=(ans+1ll*bin*f[i][j])%MOD;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define mod 1000000007\n#define G2 500000004\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn=3E3+5;\nint n,q,a[maxn],X[maxn],Y[maxn];\nll f[maxn][maxn],g[maxn][maxn];\ninline void add(ll&x,ll y)\n{\n\tx=(x+y)%mod;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=q;++i)\n\t\tcin>>X[i]>>Y[i];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=a[i]>a[j];\n\tfor(int k=1;k<=q;++k)\n\t{\n\t\tint x=X[k],y=Y[k];\n\t\t/*\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif(i!=x&&i!=y&&j!=x&&j!=y)\n\t\t\t\t\tadd(g[i][j],f[i][j]*2);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd(g[i][j],f[i][j]);\n\t\t\t\t\tif((i==x&&j==y)||(i==y&&j==x))\n\t\t\t\t\t\tadd(g[i][j],f[j][i]);\n\t\t\t\t\telse if(i==j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if(i==x)\n\t\t\t\t\t\tadd(g[i][j],f[y][j]);\n\t\t\t\t\telse if(i==y)\n\t\t\t\t\t\tadd(g[i][j],f[x][j]);\n\t\t\t\t\telse if(j==x)\n\t\t\t\t\t\tadd(g[i][j],f[i][y]);\n\t\t\t\t\telse if(j==y)\n\t\t\t\t\t\tadd(g[i][j],f[i][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t*/\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(i==x||i==y)\n\t\t\t\tcontinue;\n\t\t\tf[x][i]=(f[x][i]+f[y][i])*G2%mod;\n\t\t\tf[y][i]=f[x][i];\n\t\t\tf[i][x]=(f[i][x]+f[i][y])*G2%mod;\n\t\t\tf[i][y]=f[i][x];\n\t\t}\n\t\tf[y][x]=f[x][y]=(f[x][y]+f[y][x])*G2%mod;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tadd(ans,f[i][j]);\n\tfor(int i=1;i<=q;++i)\n\t\tans=ans*2%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e3 + 100;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nll C[maxn][maxn];\n\nll S[maxn][maxn];\n\nll A[maxn];\n\nvector <pll> Q;\n\nvector <ll> I;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll geti(ll x) {\n    return lower_bound(all(I), x) - I.begin();\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> k;\n    ll r2 = del(1, 2);\n    for (q = 0; q < n; q++) {\n        cin >> A[q];\n        I.pb(A[q]);\n        // A[q]--;\n        // C[q][A[q]]++;\n    }\n    sort(all(I));\n    I.resize(unique(all(I)) - I.begin());\n    for (q = 0; q < n; q++) {\n        A[q] = geti(A[q]);\n        // C[q][A[q]]++;\n    }\n    for (q = 0; q < n; q++) {\n        for (w = 0; w < n; w++) {\n            if (A[q] > A[w]) {\n                // cout << q << \" \" << w << \" Q W\" << endl;\n                C[q][w]++;\n            }\n        }\n    }\n    // cout << \"C:\" << endl;;\n    // for (w = 0; w < n; w++) {\n    //     for (e = 0; e < n; e++) {\n    //         cout << C[w][e] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n    for (q = 0; q < k; q++) {\n        cin >> a >> b;\n        a--; b--;\n        Q.pb(mp(a, b));\n        // cout << \"A B \" << a << \" \" << b << endl;\n        for (w = 0; w < n; w++) {\n            if (w == a || w == b) {\n                continue;\n            }\n            C[w][a] = (C[w][a] + C[w][b]) % mod;\n            C[a][w] = (C[a][w] + C[b][w]) % mod;\n            C[w][b] = C[w][a];\n            C[b][w] = C[a][w];\n\n            C[w][a] = C[w][a] * r2 % mod;\n            C[a][w] = C[a][w] * r2 % mod;\n            C[w][b] = C[w][b] * r2 % mod;\n            C[b][w] = C[b][w] * r2 % mod;;\n        }\n        ll sum = C[a][b] + C[b][a];\n        C[a][b] = C[b][a] = sum;\n        C[a][b] = C[a][b] * r2 % mod;\n        C[b][a] = C[b][a] * r2 % mod;\n        // swap(C[a][b], C[b][a]);\n        // cout << \"C:\" << endl;;\n        // for (w = 0; w < n; w++) {\n        //     for (e = 0; e < n; e++) {\n        //         cout << C[w][e] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        // for (w = 0; w < n; w)\n    }\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        for (w = q + 1; w < n; w++) {\n            ll dans = C[q][w];\n            // ll dans = (C[q][w] * S[q - 1][w + 1]) % mod;\n            ans += dans;\n            ans %= mod;\n        }\n    }\n    cout << ans * step(2, k) % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long Int;\n#define MOD (1000000007)\nInt n, q, x, y;\nInt a[3240];\nInt dp[3240][3240];\n\nInt pw(Int a, Int n){\n  if(n == 0)return 1;\n  Int res = pw(a, n/2);\n  res = res * res % MOD;\n  if(n % 2)res *= a;\n  return res % MOD;\n}\n\nint main(){\n  cin >> n >> q;\n  for(Int i = 0;i < n;i++)cin >> a[i];\n  for(Int i = 0;i < n;i++){\n    for(Int j = 0;j < n;j++){\n      dp[i][j] = a[i] < a[j];\n    }\n  }\n  for(Int i = 0;i < q;i++){\n    cin >> x >> y;\n    x--,y--;\n    dp[x][y] = (MOD+1) / 2;\n    dp[y][x] = (MOD+1) / 2;\n    for(Int j = 0;j < n;j++){\n      if(j == x || j == y)continue;\n      Int a = (dp[x][j] + dp[y][j]) % MOD;\n      if(a % 2)a += MOD;\n      a /= 2;\n      dp[x][j] = dp[y][j] = a;\n    }\n    \n    for(Int j = 0;j < n;j++){\n      if(j == x || j == y)continue;\n      Int a = (dp[j][x] + dp[j][y]) % MOD;\n      if(a % 2)a += MOD;\n      a /= 2;\n      dp[j][x] = dp[j][y] = a;\n    }\n  }\n  Int res = 0;\n  for(Int i = 0;i < n;i++){\n    for(Int j = 0;j < i;j++){\n      res += dp[i][j] * pw(2, q) % MOD;\n      res %= MOD;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\n\nint N, Q;\nconstexpr int Nmax = 3000;\nint A[Nmax];\nlint dp[Nmax][Nmax];\n\nconstexpr lint MOD = 1000000007;\nconstexpr lint inv2 = (MOD + 1) / 2;\n\nlint power(lint x, lint n)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= MOD;\n        (x *= x) %= MOD;\n       n >>= 1;\n    }\n   return ans;\n}\n\n\nint main()\n{\n    cin >> N >> Q;\n    REP(i, N) cin >> A[i];\n\n    REP(i, N) REP(j, N) dp[i][j] = (A[i] > A[j]);\n\n    REP(_, Q)\n    {\n        int X, Y;\n        cin >> X >> Y;\n        X--;\n        Y--;\n        REP(i, N) if (X != i and Y != i)\n        {\n            dp[i][X] = dp[i][Y] = (dp[i][X] + dp[i][Y]) * inv2 % MOD;\n            dp[X][i] = dp[Y][i] = (dp[X][i] + dp[Y][i]) * inv2 % MOD;\n        }\n        dp[X][Y] = dp[Y][X] = (dp[X][Y] + dp[Y][X]) * inv2 % MOD;\n    }\n\n    lint ans = 0;\n    REP(i, N) FOR(j, i + 1, N) ans += dp[i][j];\n    cout << ans % MOD * power(2, Q) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\n \ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            //cout<<x<<\"/\"<<y;\n            cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\n\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\nvoid ave(ll &s,ll &t){\n    ll z=mod((s+t)*bunbo(2));\n    s=z;\n    t=z;\n}\n\nint main(){fastio\n    ll n,q;cin>>n>>q;\n    ll a[n];rep(i,0,n-1)cin>>a[i];\n    ll dp[n][n];memset(dp,0,sizeof(dp));\n    rep(i,0,n-1)rep(j,0,n-1){\n        if(a[i]>a[j])dp[i][j]=1;\n    }\n    rep(zzzz,1,q){\n        ll x,y;cin>>x>>y;x--;y--;\n        rep(i,0,n-1){\n            if(i!=x&&i!=y){\n                ave(dp[i][x],dp[i][y]);\n                ave(dp[x][i],dp[y][i]);\n            }\n        }\n        ave(dp[x][y],dp[y][x]);\n        /*\n        rep(i,0,n-1){\n            rep(j,0,n-1){\n                mod_print(dp[i][j]);\n                cout<<\" \";\n            }cout<<endl;\n        }cout<<endl;*/\n    }\n    \n    ll ans=0;\n    rep(i,0,n-1)rep(j,i+1,n-1){\n        Add(ans,dp[i][j]);\n    }\n    cout<<mod(ans*po(2,q))<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll INF = 1e9, MOD = 1e9 + 7;\n\nll a[3000], n, q, pw, inv2;\n\nll qpow (ll a, ll b)\n{\n\tll s = 1;\n\n\twhile (b)\n\t{\n\t\tif (b & 1) s = s * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * a % MOD;\n\t}\n\n\treturn s;\n}\n\nll d[3000][3000];\n\nll div2 (ll a)\n{\n\treturn {a * inv2 % MOD};\n}\n\nll sum (ll a, ll b)\n{\n\treturn {(a + b) % MOD};\n}\n\nint main ()\n{\n\tcin >> n >> q;\n\n\tpw = qpow (2, q);\n\tinv2 = qpow (2, MOD - 2);\n\n\n\tfor (int i = 0; i < n; i++)\n\t\tscanf (\"%lld\", &a[i]);\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[i] > a[j]) {\n\t\t\t\td[i][j] = pw;\n\t\t\t}\n\t\t\telse if (a[i] < a[j]) {\n\t\t\t\td[j][i] = pw;\n\t\t\t}\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf (\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (j != x && j != y) {\n\n\t\t\t\tauto xj = d[x][j], yj = d[y][j], jx = d[j][x], jy = d[j][y];\n\n\t\t\t\td[x][j] = div2 (sum (xj, yj));\n\t\t\t\td[y][j] = div2 (sum (xj, yj));\n\t\t\t\td[j][x] = div2 (sum (jx, jy));\n\t\t\t\td[j][y] = div2 (sum (jx, jy));\n\t\t\t}\n\n\t\tauto xy = d[x][y], yx = d[y][x];\n\n\t\td[x][y] = div2 (sum (xy, yx));\n\t\td[y][x] = div2 (sum (xy, yx));\n\t}\n\n\tll ans = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tans += d[i][j];\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Query {\n  int i1, i2;\n};\n\nconstexpr int64 P = 1000000007;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, num_queries;\n  cin >> n >> num_queries;\n  vector<int> xs(n);\n  for (int i = 0; i < n; i++) cin >> xs[i];\n\n  FiniteField total = 1;\n  for (int i = 0; i < num_queries; i++) total *= 2;\n\n  auto dp = Make2DVector<FiniteField>(n, n, 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (xs[i] > xs[j]) {\n        dp[i][j] = total;\n      }\n    }\n  }\n\n  for (int i = 0; i < num_queries; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    for (int k = 0; k < n; k++) {\n      if (k == x || k == y) continue;\n      dp[x][k] = dp[y][k] = (dp[x][k] + dp[y][k]) / 2;\n      dp[k][x] = dp[k][y] = (dp[k][x] + dp[k][y]) / 2;\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) / 2;\n  }\n\n  FiniteField solution = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      solution += dp[i][j];\n    }\n  }\n  cout << solution.Value() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct add{\n  ll i,j,val;\n};\n\nll N,Q;\nll A[3001];\nll x[3001],y[3001];\nll p2[5001];\nll last[3001][3001];\nll dp[3001][3001];\n\nll extract(ll i,ll j,ll t){\n  if(t-last[i][j]>1){\n    dp[i][j]*=p2[t-last[i][j]-1];\n    dp[i][j]%=mod;\n  }\n  last[i][j]=t;\n  return dp[i][j];\n}\n\nvoid adding(ll i,ll j,ll v,ll t){\n  if(t-last[i][j]>1){\n    dp[i][j]*=p2[t-last[i][j]-1];\n    dp[i][j]%=mod;\n  }\n  last[i][j]=t;\n  (dp[i][j]+=v)%=mod;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  p2[0]=1;\n  rep(i,5000)p2[i+1]=p2[i]*2%mod;\n\n  cin>>N>>Q;\n  rep(i,N)cin>>A[i];\n  rep(i,Q){\n    cin>>x[i]>>y[i];\n    x[i]--; y[i]--;\n    if(x[i]>y[i])swap(x[i],y[i]);\n  }\n\n  rep(i,N)rep(j,N){\n    if(A[i]<A[j])dp[i][j]=1;\n  }\n\n  memset(last,-1,sizeof(last));\n\n  rep(i,Q){\n    vector<add> ads;\n    rep(a,N){\n      if(a==x[i]||a==y[i])continue;\n      ads.push_back((add){y[i],a,extract(x[i],a,i)});\n      ads.push_back((add){a,y[i],extract(a,x[i],i)});\n\n      ads.push_back((add){x[i],a,extract(y[i],a,i)});\n      ads.push_back((add){a,x[i],extract(a,y[i],i)});\n    }\n    ads.push_back((add){x[i],y[i],extract(y[i],x[i],i)});\n    ads.push_back((add){y[i],x[i],extract(x[i],y[i],i)});\n\n    for(add a : ads)adding(a.i,a.j,a.val,i);\n  }\n\n  ll res=0;\n  rep(i,N)rep(j,N){\n    if(j<i){\n      (res+=extract(i,j,Q))%=mod;\n    }\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 3e3 + 33, P = 1e9 + 7, div2 = (P + 1) / 2;\n\nint n, m, x, y, a[N], b[N], dp[N][N], tmp[N][N], ans, pw2 = 1;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i), b[i] = a[i];\n\tstd::sort(b + 1, b + n + 1);\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(b + 1, b + n + 1, a[i]) - b;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) dp[i][j] = a[i] > a[j];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int j = 1, u, v; j <= n; j++)\n\t\t\tif (j != x && j != y) {\n\t\t\t\tu = 1ll * (dp[j][x] + dp[j][y]) * div2 % P;\n\t\t\t\tv = 1ll * (dp[y][j] + dp[x][j]) * div2 % P;\n\t\t\t\tdp[j][x] = u, dp[j][y] = u;\n\t\t\t\tdp[x][j] = v, dp[y][j] = v;\n\t\t\t}\n\t\tint u = 1ll * (dp[x][y] + dp[y][x]) * div2 % P;\n\t\tdp[x][y] = dp[y][x] = u;\n\t\tpw2 = pw2 * 2 % P;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) ans = (ans + dp[i][j]) % P;\n\tprintf(\"%lld\", 1ll * ans * pw2 % P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint dp[2][3001][3001];\nint p2;\n\nint Pow(int a, int b) {\n    int res = 1;\n    while(b) {\n        if(b&1) {\n            res = (1LL * res * a) % mod;\n        }\n        b >>= 1;\n        a = (1LL * a * a) % mod;\n    }\n    return res;\n}\n\nint div1(int a, int b) {\n    a %= mod;\n    return (1LL * a * p2) % mod;\n}\n\nint main() {\n    int n, q;\n    cin>>n>>q;\n    vector<int> A(n);\n    for(int i = 0; i < n; ++i) {\n        cin>>A[i];\n    }\n    p2 = Pow(2, mod - 2);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(A[i] > A[j]) {\n                dp[1][i][j] = 1;\n            }\n        }\n    }\n\n    for(int i = 1; i <= q; ++i) {\n        int x, y;\n        cin>>x>>y;\n        x--, y--;\n        for(int j = 0; j < n; ++j) {\n            if(j != x && j != y) {\n                dp[1][j][x] = dp[1][j][y] = div1(dp[1][j][x] + dp[1][j][y], 2);\n                dp[1][x][j] = dp[1][y][j] = div1(dp[1][x][j] + dp[1][y][j], 2);\n            }\n        }\n        dp[1][x][y] = dp[1][y][x] = div1(dp[1][x][y] + dp[1][y][x], 2);\n    }\n    int ans = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = i + 1; j < n; ++j) {\n            ans = (ans + dp[1][i][j]) % mod;\n        }\n    }\n    ans = (1LL * ans * Pow(2, q)) % mod;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\nconstexpr ll I2 = 500000004;\nint main()\n{\n    int N, Q;\n    std::cin >> N >> Q;\n    std::vector<int> A(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i]; }\n    std::vector<int> x(Q), y(Q);\n    for (int i = 0; i < Q; i++) { std::cin >> x[i] >> y[i], x[i]--, y[i]--; }\n    std::vector<std::vector<ll>> dp(N, std::vector<ll>(N, 0));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) { dp[i][j] = A[i] > A[j]; }\n    }\n    for (int i = 0; i < Q; i++) {\n        dp[x[i]][y[i]] = dp[y[i]][x[i]] = (dp[x[i]][y[i]] + dp[y[i]][x[i]]) * I2 % MOD;\n        for (int Y = 0; Y < N; Y++) {\n            if (Y == y[i] or Y == x[i]) { continue; }\n            dp[x[i]][Y] = dp[y[i]][Y] = (dp[x[i]][Y] + dp[y[i]][Y]) * I2 % MOD;\n        }\n        for (int X = 0; X < N; X++) {\n            if (X == y[i] or X == x[i]) { continue; }\n            dp[X][x[i]] = dp[X][y[i]] = (dp[X][x[i]] + dp[X][y[i]]) * I2 % MOD;\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) { (ans += dp[i][j]) %= MOD; }\n    }\n    for (int i = 0; i < Q; i++) { (ans *= 2) %= MOD; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Inversion Sum*/ \n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long \n#define mod 1000000007\nint f[3010][3010]; \nint g[3010][3010];\nint inv2;\nint quickpow(int x,int y){\n\tint ans = 1;\n\twhile(y){\n\t\tif(y & 1)\tans = (1ll * ans * x) % mod;\n\t\tx = (1ll * x * x) % mod;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\nint a[3010];\nint main()\n{\n\tint n,q;\n\tcin >> n >> q;\n\tinv2 = quickpow(2,mod-2) ;\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif(a[i] > a[j])\t\tf[i][j] = g[i][j] = 1;\n\t\t}\n\tfor(int i = 1; i <= q; ++i){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tf[l][r] = f[r][l] = ((1ll * g[l][r]+g[r][l])%mod * 1ll * inv2) % mod;\n\t\tfor(int k = 1; k <= n; ++k)\n\t\t\tif(k != l && k != r){\n\t\t\t\tf[k][r] = f[k][l] = ((1ll * g[k][l] + g[k][r])%mod * 1ll * inv2) % mod;\n\t\t\t\tf[l][k] = f[r][k] = ((1ll * g[l][k] + g[r][k])%mod * 1ll * inv2) % mod;\n\t\t\t}\n\t\tfor(int k = 1; k <= n; ++k)\n\t\t\tg[k][l] = g[k][r] = f[k][l],g[l][k] = g[r][k] = f[l][k];\n\t\tg[l][r] = g[r][l] = f[l][r];\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i+1; j <= n; ++j)\n\t\t\tans = (1ll * ans + f[i][j]) % mod;\n\tans = (1ll * ans * quickpow(2,q)) % mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii_ pair<int,int>\n#define mp_ make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define show1(a) cout<<#a<<\" = \"<<a<<endl\n#define show2(a,b) cout<<#a<<\" = \"<<a<<\"; \"<<#b<<\" = \"<<b<<endl\nusing namespace std;\nconst ll INF = 1LL<<60;\nconst int inf = 1<<30;\nconst int maxn = 2e5+5;\nconst ll M = 1e9+7;\ninline void fastio() {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\ninline void add(ll &x,ll y){\n    x += y;\n    if(x>M) x-=M;\n    if(x<0) x+=M;\n}\nll qmul(ll a,ll b) {ll s=0;while(b){if(b&1)add(s,a);add(a,a);b>>=1;}return s; }\nll qpow(ll a,ll b) {ll s=1;while(b){if(b&1)s=qmul(s,a);a=qmul(a,a);b>>=1;}return s; }\nint n,a[3005],q,x,y;\nll f[3005][3005];\n\nint main()\n{\n    fastio();\n    cin>>n>>q;\n    rep(i,1,n) cin>>a[i];\n    rep(i,1,n) rep(j,1,n) f[i][j] = (a[i]>a[j]);\n    ll inv2 = qpow(2,M-2);\n    ll fc = qpow(2,q);\n    while(q--){\n        cin>>x>>y;\n        rep(i,1,n){\n            if(i!=x && i!=y){\n                f[i][x] = f[i][y] = qmul((f[i][x]+f[i][y])%M,inv2);\n                f[x][i] = f[y][i] = qmul((f[x][i]+f[y][i])%M,inv2);\n            }\n        }\n        f[x][y] = f[y][x] = qmul((f[x][y]+f[y][x])%M,inv2);\n    }\n    ll ans = 0;\n    rep(i,1,n) rep(j,i+1,n) {\n        add(ans,qmul(f[i][j],fc));\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef long long s64;\ntypedef unsigned long long u64;\ntypedef unsigned int u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nconst int N=3000+5,D=1e9+7;\ns64 mi(s64 x,int y=D-2)\n{\n\ts64 ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=ans*x%D;\n\t\tx=x*x%D;y>>=1;\n\t}\n\treturn ans;\n}\nconst s64 mi_2=mi(2);\nint a[N],x[N],y[N];s64 dp[N][N],dp0[N][N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\n\tint n,q;\n\tcin>>n>>q;\n\trep(i,1,n)a[i]=read();\n\trep(i,1,q){x[i]=read();y[i]=read();}\n\trep(i,1,n)\n\trep(j,i+1,n)dp[i][j]=1;\n\tper(tmp,q,1)\n\t{\n\t\tint x=::x[tmp],y=::y[tmp];\n\t\trep(i,1,n){dp0[x][i]=dp[x][i];dp0[i][x]=dp[i][x];dp0[y][i]=dp[y][i];dp0[i][y]=dp[i][y];}\n\t\trep(i,1,n)\n\t\t{\n\t\t\t((dp[x][i]+=dp0[y][i])*=mi_2)%=D;((dp[i][x]+=dp0[i][y])*=mi_2)%=D;\n\t\t\t((dp[y][i]+=dp0[x][i])*=mi_2)%=D;((dp[i][y]+=dp0[i][x])*=mi_2)%=D;\n\t\t}\t\n\t\tdp[x][y]=dp[y][x]=(dp0[x][y]+dp0[y][x])*mi_2%D; \n\t}\n\ts64 ans=0;\n\trep(i,1,n)\n\trep(j,1,n)\n\tif(a[i]>a[j])ans+=dp[i][j];\n\tcout<<ans%D*mi(2,q)%D;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=3009;\nconst long long Mod=1000000007ll,_two=500000004ll;\nint n,q,x,y,ans;\nlong long a[maxn],p[maxn][maxn],pp[maxn][maxn];\n\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=(a[i]>a[j]);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tfor(int j=1;j<=n;j++) \n\t\t\tif(j==x||j==y) continue;\n\t\t\telse p[x][j]=p[y][j]=(p[x][j]+p[y][j])*_two%Mod,p[j][y]=p[j][x]=(p[j][y]+p[j][x])*_two%Mod;\n\t\tp[x][y]=p[y][x]=(p[x][y]+p[y][x])*_two%Mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(ans+p[i][j])%Mod;\n\tfor(int i=0;i<q;i++) ans=ans*2%Mod;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n#define fir first\n#define sec second\n#define rep(i,a,b) for (int i = (a) ; i <= (b) ; ++ i)\n#define rrp(i,a,b) for (int i = (a) ; i >= (b) ; -- i)\n#define gc() getchar()\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc() ; !isdigit(tmp) ; tmp = gc())\n    key = (tmp == '-');\n  for ( ; isdigit(tmp) ; tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = (int)(1e9 + 7);\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\n\nconst int N = 3010;\nint dp[N][N], val[N], n, q, inv2, tag, ans;\nint main() {\n  int x,y;\n  read(n), read(q);\n  rep (i, 1, n) read(val[i]);\n  rep (i, 1, n) rep (j, 1, n) if (val[i] > val[j])\n    dp[i][j] = 1;\n  inv2 = (MOD + 1) / 2;\n  tag = 1;\n  while (q --) {\n    read(x), read(y);\n    rep (i, 1, n) if (i != x && i != y) {\n      dp[x][i] = dp[y][i] = 1ll * (dp[x][i] + dp[y][i]) * inv2 % MOD;\n      dp[i][x] = dp[i][y] = 1ll * (dp[i][x] + dp[i][y]) * inv2 % MOD;\n    }\n    dp[x][y] = dp[y][x] = 1ll * (dp[x][y] + dp[y][x]) * inv2 % MOD;\n    tag = tag * 2 % MOD;\n  }\n  rep (i, 1, n) rep (j, 1, n) dp[i][j] = 1ll * dp[i][j] * tag % MOD;\n  rep (i, 1, n) rep (j, i+1, n) Add(ans, dp[i][j]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N, Q;\nvector<int> A;\nconstexpr int Nmax = 3000;\nvector<lint> dp[Nmax];\n\nconstexpr lint MOD = 1000000007;\nconstexpr lint inv2 = (MOD + 1) / 2;\n\nmap<int, int> Aton;\n\nlint power(lint x, lint n)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= MOD;\n        (x *= x) %= MOD;\n       n >>= 1;\n    }\n   return ans;\n}\n\nint main()\n{\n    cin >> N >> Q;\n    A.resize(N);\n    cin >> A;\n\n    REP(i, N)\n    {\n        dp[i].resize(N);\n        REP(j, N) dp[i][j] = (A[i] > A[j]);\n    }\n\n    REP(_, Q)\n    {\n        int X, Y;\n        cin >> X >> Y;\n        X--;\n        Y--;\n        REP(i, N) if (X != i and Y != i)\n        {\n            dp[i][X] = dp[i][Y] = (dp[i][X] + dp[i][Y]) * inv2 % MOD;\n            dp[X][i] = dp[Y][i] = (dp[X][i] + dp[Y][i]) * inv2 % MOD;\n        }\n        dp[X][Y] = dp[Y][X] = (dp[X][Y] + dp[Y][X]) * inv2 % MOD;\n    }\n\n    lint ans = 0;\n    REP(i, N) FOR(j, i + 1, N) (ans += dp[i][j]) %= MOD;\n    cout << ans * power(2, Q) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\n#define i2 (mod+1>>1)\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint a[3010],f[3010][3010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),q=gi();\n\tfor(int i=1;i<=n;++i)a[i]=gi();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=a[i]<a[j];\n\tfor(int _=0;_<q;++_){\n\t\tint x=gi(),y=gi();if(x==y)continue;\n\t\tf[x][y]=f[y][x]=1ll*i2*(f[x][y]+f[y][x])%mod;\n\t\tfor(int i=1;i<=n;++i)if(i!=x&&i!=y)f[i][x]=f[i][y]=1ll*i2*(f[i][x]+f[i][y])%mod,f[x][i]=f[y][i]=1ll*i2*(f[x][i]+f[y][i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tinc(ans,f[i][j]);\n\tprintf(\"%d\\n\",1ll*pow(2,q)*ans%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 3005;\nint n, q;\nint A[MAXN];\npair<int, int> Q[MAXN];\nvector<int> swaps[MAXN];\nvector<vector<int> > dp[MAXN][MAXN];\nint pw2[MAXN];\n\nint getNxt(int i, int sw) {\n\treturn lower_bound(swaps[i].begin(), swaps[i].end(), sw) - swaps[i].begin();\n}\nint getSw(int i, int x) {\n\tpair<int, int> sw = Q[swaps[i][x]];\n\tif (sw.first == i) return sw.second;\n\treturn sw.first;\n}\nint sol(int i, int j, int x, int y) {\n\tif (q == swaps[i][x] && q == swaps[j][y]) {\n\t\treturn (i > j) ? 1 : 0;\n\t}\n\tif (dp[i][j][x][y] != -1) return dp[i][j][x][y];\n\tint ans = 0;\n\tif (swaps[j][y] < swaps[i][x]) {\n\t\tint dis = min(swaps[i][x], swaps[j][y+1]) - swaps[j][y] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(i, j, x, y + 1)) % MOD;\n\t\tans %= MOD;\n\t\tint nj = getSw(j, y);\n\t\tint ny = getNxt(nj, swaps[j][y] + 1);\n\t\tdis = min(swaps[nj][ny], swaps[i][x]) - swaps[j][y] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(i, nj, x, ny)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[i][j][x][y] = ans;\n\t}\n\tif (swaps[j][y] > swaps[i][x]) {\n\t\tint dis = min(swaps[j][y], swaps[i][x + 1]) - swaps[i][x]-1;\n\t\tans += (pw2[dis] * 1ll * sol(i, j, x+1, y)) % MOD;\n\t\tans %= MOD;\n\t\tint ni = getSw(i, x);\n\t\tint nx = getNxt(ni, swaps[i][x] + 1);\n\t\tdis = min(swaps[j][y], swaps[ni][nx]) - swaps[i][x] - 1;\n\t\tans += (pw2[dis] * 1ll * sol(ni, j, nx, y)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[i][j][x][y] = ans;\n\t}\n\tint dis = min(swaps[i][x+1] - swaps[i][x], swaps[j][y+1] - swaps[j][y]) - 1;\n\tans += (pw2[dis] * 1ll * sol(i, j, x + 1, y + 1)) % MOD;\n\tans %= MOD;\n\tans += (pw2[dis] * 1ll * sol(j, i, y + 1, x + 1)) % MOD;\n\tans %= MOD;\n\treturn dp[i][j][x][y] = ans;\n}\n\nint main() {\n\tpw2[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tpw2[i] = (pw2[i-1] * 2) % MOD;\n\t}\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", A + i);\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tswaps[x].push_back(i);\n\t\tswaps[y].push_back(i);\n\t\tQ[i] = {x, y};\n\t}\n\tfor (int i = 0; i < n; i++) swaps[i].push_back(q);\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {\n\t\tdp[i][j] = vector<vector<int> > (swaps[i].size() + 1, vector<int> (swaps[j].size() + 1, -1));\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (A[i] == A[j]) continue;\n\t\t\tint res = (pw2[min(swaps[i][0], swaps[j][0])] * 1ll * sol(i, j, 0, 0)) % MOD;\n\t\t\tif (A[i] < A[j]) ans += res;\n\t\t\telse {\n\t\t\t\tans += (pw2[q] - res + MOD) % MOD;\n\t\t\t}\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nconst int mod=1000000007;\nconst int inv2=(mod+1)/2;\nint n,m,a[5010],x,y,i,j;\n\nlong long p[5010][5010],t;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tfor(i=1;i<=n;++i)for(j=1;j<=n;++j)p[i][j]=a[i]>a[j];\n\tfor (int k=0;k<m;k++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tp[x][y]=p[y][x]=(p[x][y]+p[y][x])*inv2%mod;\n\t\tfor(i=1;i<=n;++i)if(i!=x&&i!=y) p[i][x]=p[i][y]=(p[i][x]+p[i][y])*inv2%mod,\n\t\t\tp[x][i]=p[y][i]=(p[x][i]+p[y][i])*inv2%mod;\n\t}\n\tfor(i=1;i<=n;++i)for(j=n;j>i;--j)t=(t+p[i][j])%mod;\n\tfor (i=0;i<m;++i) t=t*2%mod;\n\tprintf(\"%lld\\n\",t);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nll Power(ll x,ll k)\n{\n\tx%=mod;\n\tll sss=1;\n\twhile (k)\n\t{\n\t\tif (k%2) sss=sss*x%mod;\n\t\tx=x*x%mod;\n\t\tk/=2;\n\t}\n\treturn sss;\n}\nll ny(ll x){return Power(x,mod-2);}\nint n,q;\nll f[4030][4030];\nll ans;\nll a[5030],b[5][5030];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) if (a[i]>a[j]) f[i][j]=1;\n\n\tint x,y; ll doe=ny(2);\n\tfor (int i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tb[0][j]=f[j][x];\n\t\t\tb[1][j]=f[x][j];\n\t\t\tb[2][j]=f[j][y];\n\t\t\tb[3][j]=f[y][j];\n\t\t}\n\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) (f[j][y]+=b[0][j])%=mod;\n\t\t\tif (j!=x) (f[y][j]+=b[1][j])%=mod;\n\t\t\tif (j!=y) (f[j][x]+=b[2][j])%=mod;\n\t\t\tif (j!=y) (f[x][j]+=b[3][j])%=mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) f[j][y]=f[j][y]*doe%mod;\n\t\t\tif (j!=x) f[y][j]=f[y][j]*doe%mod;\n\t\t\tif (j!=y) f[j][x]=f[j][x]*doe%mod;\n\t\t\tif (j!=y) f[x][j]=f[x][j]*doe%mod;\n\t\t}\n\t\tll A=f[x][y],B=f[y][x];\n\t\tf[y][x]+=A; f[x][y]+=B;\n\t\tf[x][y]=f[x][y]*doe%mod;\n\t\tf[y][x]=f[y][x]*doe%mod;\n\t}\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n;++j) (ans+=f[i][j])%=mod;\n\tans=ans*Power(2,q)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/**\n(k, i) * (i, j) => n (k, j)\n(i, j) * (j, k) => n (i, k)\n\n**/\nconst int mod = 1000000007;\nconst int maxn = 3030;\nint p[maxn][maxn], a[maxn];\nint mul(long long a, long long b){\n\treturn a * b % mod;\n}\nint add(int a, int b){\n\ta += b; if(a >= mod) a -= mod;\n\treturn a;\n}\nint xp(int a, int b){\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b&1) r = mul(r, a);\n\treturn r;\n}\nint inv(int x){\n\treturn xp(x, mod - 2);\n}\nint main(){\n\tint n, q; cin >> n >> q;\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < n; j++) p[i][j] = a[i] > a[j];\n\tint p2q = xp(2, q);\n\tint iq = inv(p2q);\n\tfor(int i = 0; i < q; i++){\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(j == x || j == y) continue;\n\t\t\tint tmp;\n\t\t\ttmp = mul(add(p[j][x], p[j][y]), (mod + 1)/2);\n\t\t\tp[j][x] = p[j][y] = tmp;\n\t\t\ttmp = mul(add(p[x][j], p[y][j]), (mod + 1)/2);\n\t\t\tp[x][j] = p[y][j] = tmp;\n\t\t}\n\t\tint pxy = p[x][y], pyx = p[y][x];\n\t\tp[x][y] = mul(add(pxy, pyx), (mod + 1)/2);\n\t\tp[y][x] = mul(add(pyx, pxy), (mod + 1)/2);\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) ans = add(ans, p[i][j]);\n\tcout << mul(ans, p2q) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <iostream>\n#define MODD 1000000007\n#define ll long long\nusing namespace std;\n\n\nint A[3333];\n\nll modpow(ll x, ll y) {\n    x%=MODD;\n    ll xs = x;\n    ll answer = 1;\n    while(y) {\n        if (y&1) {\n            answer = (answer * xs) % MODD;\n        }\n        y >>= 1;\n        xs = (xs * xs) % MODD;\n    }\n    return answer;\n}\n\n\nll X[3333][3333];\nll Y[3333][3333];\n\n\n\nint main() {\n    int N,Q;\n    cin>>N>>Q;\n    for(int i=1;i<=N;i++)\n        cin>>A[i];\n    \n    \n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++) {\n            X[i][j] = (A[i] < A[j] ? 1 : 0);\n            Y[i][j] = (A[i] > A[j] ? 1 : 0);\n        }\n    \n    ll twoinv = modpow(2,MODD-2);\n    \n    for(int q=1;q<=Q;q++) {\n        \n        int x,y;\n        cin>>x>>y;\n        \n        \n        // X[x][y] and X[y][x]\n        \n        // X[x][i] -> X[y][i]\n        // X[y][i] -> X[x][i]\n        \n        \n        \n        \n        // P(A[x] < A[y]) and P(A[y] < A[x])\n        \n        ll newx = (X[x][y]+X[y][x])*twoinv%MODD;\n        ll newy = (Y[x][y]+Y[y][x])*twoinv%MODD;\n        \n        \n        for(int j=1;j<=N;j++) {\n            if (j != x && j != y) {\n                X[x][j]=X[y][j]=(X[x][j]+X[y][j])*twoinv%MODD;\n                Y[x][j]=Y[y][j]=(Y[x][j]+Y[y][j])*twoinv%MODD;\n            }\n        }\n        for(int i=1;i<=N;i++) {\n            if (i != x && i != y) {\n                X[i][x]=X[i][y]=(X[i][x]+X[i][y])*twoinv%MODD;\n                Y[i][x]=Y[i][y]=(Y[i][x]+Y[i][y])*twoinv%MODD;\n            }\n        }\n        \n        X[x][y]=X[y][x]=newx;\n        Y[x][y]=Y[y][x]=newy;\n        X[x][x]=X[y][y]=Y[x][x]=Y[y][y]=0;\n        \n    }\n    \n    ll ans = 0;\n    \n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++) {\n            if (i < j) {\n                ans += Y[i][j];\n            } else {\n                ans += X[i][j];\n            }\n        }\n    \n    ans = (ans * modpow(2, Q))%MODD;\n    ans = (ans * twoinv)%MODD;\n    \n    cout << ans << endl;\n    \n    \n    // M[i][j] = P(X[i] < X[j])\n    \n    \n    \n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;\n    mint() = default;\n    mint(int64_t value_) : value(value_) {}\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\n\nconstexpr int MOD = 1e9 + 7;\nmint<MOD> solve(int n, int q, vector<int> const & a, vector<int> const & x, vector<int> const & y) {\n    auto dp = vectors(n, n, mint<MOD>());\n    REP (i, n) REP (j, n) {\n        dp[i][j] = (a[i] > a[j]);\n    }\n\n    const auto half = mint<MOD>(2).inv();\n    REP (t, q) {\n        int i = x[t];\n        int j = y[t];\n        dp[i][j] = dp[j][i] = (dp[i][j] + dp[j][i]) * half;\n        REP (k, n) if (i != k and j != k) {\n            dp[k][i] = dp[k][j] = (dp[k][i] + dp[k][j]) * half;\n            dp[i][k] = dp[j][k] = (dp[i][k] + dp[j][k]) * half;\n        }\n    }\n\n    mint<MOD> acc = 0;\n    REP (i, n) REP3 (j, i, n) {\n        acc += dp[i][j];\n    }\n    return acc * mint<MOD>(2).pow(q);\n}\n\nint main() {\n    int n, q; cin >> n >> q;\n    vector<int> a(n);\n    REP (i, n) cin >> a[i];\n    vector<int> x(q), y(q);\n    REP (i, q) {\n        cin >> x[i] >> y[i];\n        -- x[i];\n        -- y[i];\n    }\n    cout << solve(n, q, a, x, y).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nint N, Q, A[3010];\nmint dp[3010][3010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> Q;\n    rep(i, 0, N) cin >> A[i];\n\n    mint t = mint(1) / mint(2);\n    rep(i, 0, N) rep(j, 0, N) if (A[i] > A[j]) dp[i][j] = 1;\n    rep(q, 0, Q) {\n        int x, y; cin >> x >> y; x--; y--;\n        rep(i, 0, N) if (i != x and i != y) {\n            dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * t;\n            dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * t;\n        }\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * t;\n    }\n\n    mint ans = 0;\n    rep(i, 0, N) rep(j, i + 1, N) ans += dp[i][j];\n    ans *= mint(2) ^ Q;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nint f[3005][3005],a[3005];\nint main(){\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=(a[i]>a[j]);\n\tfor(int i=1;i<=q;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;j++)if(j!=x&&j!=y){\n\t\t\tf[x][j]=f[y][j]=1ll*(f[y][j]+f[x][j])*((mod+1)/2)%mod;\n\t\t\tf[j][x]=f[j][y]=1ll*(f[j][x]+f[j][y])*((mod+1)/2)%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*(f[y][x]+f[x][y])*((mod+1)/2)%mod;\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tans=(ans+f[i][j])%mod;\n\t\t}\n\tfor(int i=1;i<=q;i++)ans=ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define HALF 500000004\n\nint n, m, x[3005];\nlong long f[3005][31005], ans, mul = 1;\n\nint ta, tb;\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", x + i);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tf[i][j] = x[i] < x[j];\n\twhile (m--) {\n\t\tmul = (mul << 1) % MOD;\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tta--;\n\t\ttb--;\n\t\tf[ta][tb] = f[tb][ta] = HALF * (f[ta][tb] + f[tb][ta]) % MOD;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (i != ta && i != tb) {\n\t\t\t\tf[i][ta] = f[i][tb] = HALF * (f[i][ta] + f[i][tb]) % MOD;\n\t\t\t\tf[ta][i] = f[tb][i] = HALF * (f[ta][i] + f[tb][i]) % MOD;\n\t\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tans += f[j][i];\n\tprintf(\"%lld\\n\", ans % MOD * mul % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 1e9 + 7;\nint nxt[3005][3005], arr[3005], lst[3005];\nint dp[3005][2][2][3005], qx[3005], qy[3005], pw[3005];\nint calc(int p, int x, int y)\n{\n\tif (p == -1)\n\t\treturn arr[x] > arr[y];\n\tint t = std::max(nxt[p][x], nxt[p][y]), coef = pw[p - t];\n\tp = t;\n\tif (p == -1)\n\t\treturn (arr[x] > arr[y]) * coef;\n\tbool a = qx[p] == x || qy[p] == x, b = qx[p] == y || qy[p] == y;\n\tint &res = dp[p][a][a ? (x == qx[p]) : (y == qx[p])][b ? x : y];\n\tif (~res)\n\t\treturn res;\n\tres = calc(p - 1, x, y);\n\tif (a && b)\n\t\tres += calc(p - 1, y, x);\n\telse if (a)\n\t\tres += calc(p - 1, qx[p] ^ qy[p] ^ x, y);\n\telse if (b)\n\t\tres += calc(p - 1, x, qx[p] ^ qy[p] ^ y);\n\telse\n\t\tthrow \"GG\";\n\treturn res = (ll)res * coef % MOD;\n}\nint main()\n{\n\t// freopen(\"AGC030-D.in\", \"r\", stdin);\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", arr + i);\n\tmemset(lst, -1, sizeof(lst));\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d%d\", qx + i, qy + i);\n\t\tqx[i]--;\n\t\tqy[i]--;\n\t\tlst[qx[i]] = lst[qy[i]] = i;\n\t\tmemcpy(nxt[i], lst, sizeof(lst));\n\t}\n\tpw[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tpw[i] = pw[i - 1] * 2 % MOD;\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t(ans += calc(m - 1, i, j)) %= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define R register\n#define ll long long\nconst int MAXN=3e3+10;\nconst int mod=1e9+7;\n\ninline int qpow(int x,int p)\n{\n\tint res=1;\n\twhile(p)\n\t{\n\t\tif(p&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\n\nint n,q;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(R int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(R int i=1;i<=n;i++)\n\t\tfor(R int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j]?1:0;\n\tint inv=qpow(2,mod-2);\n\tfor(R int i=1;i<=q;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(ll)(f[x][y]+f[y][x])*inv%mod;\n\t\tfor(R int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x||j==y) continue;\n\t\t\tf[j][x]=f[j][y]=(ll)(f[j][x]+f[j][y])*inv%mod;\n\t\t\tf[x][j]=f[y][j]=(ll)(f[x][j]+f[y][j])*inv%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(R int i=1;i<=n;i++)\n\t\tfor(R int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])>mod?ans+f[i][j]-mod:ans+f[i][j];\n\tprintf(\"%lld\\n\",(ll)ans*qpow(2,q)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7); //998244353LL;\n\nmll ave(mll a, mll b){\n\tll c = a.val + b.val;\n\tif (c % 2 == 1) c += mll::MOD;\n\treturn mll(c/2);\n}\n\n\nvoid solve()\n{\n\tll N, Q;\n\tcin >> N >> Q;\n\tvll A = cinv(N);\n\tauto XY = cinv2(Q);\n\tEACH(e, XY){\n\t\te.first--; e.second--;\n\t}\n\n\tvector<vector<mll>> C(N, vector<mll>(N));\n\n\tmll two = 2;\n\tmll twoQ = POW(two, Q);\n\n\tREP(i, N) REP(j, N){\n\t\tif (i == j) continue;\n\t\tif (A[i] > A[j]) C[i][j] = twoQ;\n\t}\n\n\tREP(i, Q){\n\t\tll X = XY[i].first;\n\t\tll Y = XY[i].second;\n\n\t\tC[X][Y] = C[Y][X] = ave(C[X][Y], C[Y][X]);\n\t\tREP(j, N){\n\t\t\tif (j == X || j == Y) continue;\n\t\t\tC[X][j] = C[Y][j] = ave(C[X][j], C[Y][j]);\n\t\t}\n\n\t\tREP(j, N){\n\t\t\tif (j == X || j == Y) continue;\n\t\t\tC[j][X] = C[j][Y] = ave(C[j][X], C[j][Y]);\n\t\t}\n\t}\n\n\tmll ans = 0;\n\tREP(i, N-1){\n\t\tans += Sum(C[i], i+1, N-1);\n\t}\n\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n, Q;\nllint a[3005];\nllint dp[3005][3005];\nllint inv;\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nint main(void)\n{\n\tcin >> n >> Q;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tinv = modpow(2, mod-2);\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(a[i] > a[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\t\n\tllint l, r;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> l >> r;\n\t\tif(l > r) swap(l, r);\n\t\tdp[l][r] = dp[r][l] = (dp[l][r]+dp[r][l])%mod*inv%mod;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i == l || i == r) continue;\n\t\t\tdp[l][i] = dp[r][i] = (dp[l][i]+dp[r][i])%mod*inv%mod;\n\t\t\tdp[i][l] = dp[i][r] = (dp[i][l]+dp[i][r])%mod*inv%mod;\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tans += dp[i][j], ans %= mod;\n\t\t}\n\t}\n\tans *= modpow(2, Q), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = (ll)(1e+9) + 7;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\n//a_i>a_jとなる場合の数\nll dp[3000][3000];\nint a[3000]; int n,q;\nll calc() {\n\tll res = 0;\n\trep(i, n) {\n\t\tRep(j, i + 1, n) {\n\t\t\tres += dp[i][j]; res %= mod;\n\t\t}\n\t}\n\treturn res;\n}\nconst ll t2 = (mod + 1) / 2;\nint main() {\n\tcin >> n>>q;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (a[i] > a[j])dp[i][j] = 1;\n\t\t}\n\t}\n\trep(aa, q) {\n\t\t//cout << calc() << endl;\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\trep(i, n) {\n\t\t\tif (i == x || i == y)continue;\n\t\t\tdp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) % mod*t2%mod;\n\t\t\tdp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) % mod*t2%mod;\n\t\t}\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) % mod*t2%mod;\n\t\t/*rep(i, n) {\n\t\t\tRep(j, i + 1, n) {\n\t\t\t\tcout << i<<\" \"<<j<<\" \"<<dp[i][j] << endl;\n\t\t\t}\n\t\t}*/\n\t}\n\tll c = calc();\n\trep(i, q) {\n\t\tc *= 2; c %= mod;\n\t}\n\tcout << c << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \n\nconst int N = 4000; \nconst int MOD = 1000000007;\n\ninline int read()\n{\n    char c = getchar(); int x = 0, f = 1;\n    while( c < '0' || c > '9' ) { if( c == '-' ) f = -1; c = getchar(); }\n    while( c >='0' && c <='9' ) { x = x * 10 + c - '0' ; c = getchar(); }\n    return x * f;\n}\n\ninline ll add( ll a, ll b ) { return a + b >= MOD ? a + b - MOD : a + b; }\n\ninline ll dec( ll a, ll b ) { return a - b < 0 ? a - b + MOD : a - b; }\n\ninline ll ksm( ll a, ll b )\n{\n\tll ret = 1; \n\tfor( ; b; b >>= 1, a = a * a % MOD ) \n\t\tif( b & 1 ) ret = ret * a % MOD;\n\treturn ret; \n}\n\nint n, q, a[N];\n\nll f[N][N], temp[N][N]; \n\nint main()\n{\n\tn = read(); q = read(); \n\t\n\tfor( int i = 1; i <= n; i ++ ) \t\n\t\ta[i] = read(); \n\t\t\n\tfor( int i = 1; i <= n; i ++ )\n\t\tfor( int j = 1; j <= n; j ++ )\n\t\t\tf[i][j] = a[i] > a[j] ? 1 : 0;\n\t\t\n\tll inv = ksm( 2, MOD - 2 ); int x, y;\n\tfor( int i = 1; i <= q; i ++ )\n\t{\n\t\tx = read(); y = read(); \n\t\t\n\t\tfor( int j = 1; j <= n; j ++ )\n\t\t\tif( j != x && j != y )\n\t\t\t\tf[x][j] = f[y][j] = inv * add( f[x][j], f[y][j] ) % MOD, \n\t\t\t\tf[j][x] = f[j][y] = inv * add( f[j][x], f[j][y] ) % MOD;\n\t\t\t\n\t\tf[x][y] = f[y][x] = inv * add( f[x][y], f[y][x] ) % MOD;\n\t}  \n\n\tll ans = 0; \n\tfor( int i = 1; i <= n; i ++ )\n\t\tfor( int j = i + 1; j <= j; n ++ )\n\t\t\tans = add( ans, f[i][j] ); \n\t\t\t\n\tans = ans * ksm( 2, q ) % MOD;\n\t\t\t\n\tcout << ans << endl; \n\t\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ins insert\n#define F first\n#define S second\n#define var auto\nusing namespace std;\ntypedef long long ll;\nconst int Max = 5e3 + 50;\nconst int Mod = 1e9 + 7;\n\nint A[Max];\nint X[Max] , Y[Max];\n\nll cnt[Max];\nll inv[Max][Max];\nll nrm[Max][Max];\nll lstedit[Max][Max];\n\nll pw(int a , int b)\n{\n\tif(b == 0)\n\t\treturn 1;\n\tll half = pw(a , b / 2);\n\tif(b % 2)\n\t\treturn half * half % Mod * a % Mod;\n\treturn half * half % Mod;\n}\n\nll getInv(int i , int j , int q)\n{\n\tif(i > j)\n\t\tswap(i , j);\n\treturn inv[i][j] * pw(2 , q - lstedit[i][j] - 1) % Mod;\n}\n\nll getNrm(int i , int j , int q)\n{\n\tif(i > j)\n\t\tswap(i , j);\n\treturn nrm[i][j] * pw(2 , q - lstedit[i][j] - 1) % Mod;\n}\n\n\n\nint main()\n{\n\tint n , q;cin >> n >> q;\n\tfor(int i = 1; i <= n ; i++)\n\t\tcin >> A[i];\n\tfor(int i = 1; i <= q ; i++)\n\t{\n\t\tcin >> X[i] >> Y[i];\n\t\tif(X[i] > Y[i])\n\t\t\tswap(X[i] , Y[i]);\n\t}\n\n\tfor(int i = 1; i <= q; i++)\n\t{\n\t\tfor(int j = X[i] + 1; j <= Y[i];j++)\n\t\t\tcnt[i] += (A[X[i]] > A[j]);\n\t\tfor(int j = Y[i] - 1; j >= X[i];j--)\n\t\t\tcnt[i] += (A[j] > A[Y[i]]);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n ; j++)\n\t\t\tif(A[i] > A[j])\n\t\t\t{\n\t\t\t\tinv[i][j]++;\n\t\t\t\tinv[j][i]++;\n\t\t\t}\n\t\t\telse if(A[i] < A[j])\n\t\t\t{\n\t\t\t\tnrm[i][j]++;\n\t\t\t\tnrm[j][i]++;\n\t\t\t}\n\n\tll _2k = 1;\n\tfor(int i = 1; i <= q; i++ , _2k = _2k * 2 % Mod)\n\t{\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(j == X[i] || j == Y[i])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tll invX = getInv(j , X[i] , i);\n\t\t\t\tll invY = getInv(j , Y[i] , i);\n\t\t\t\tll nrmX = getNrm(j , X[i] , i);\n\t\t\t\tll nrmY = getNrm(j , Y[i] , i);\n\t\t\t\t\n\t\t\t\tif(j < X[i] || j > Y[i])\n\t\t\t\t{\n\t\t\t\t\tinv[j][X[i]] = inv[X[i]][j] =\n\t\t\t\t\t   inv[j][Y[i]] = inv[Y[i]][j] = \n\t\t\t\t\t   (invX + invY) % Mod;\n\t\t\t\t\tnrm[j][X[i]] = nrm[X[i]][j] =\n\t\t\t\t\t   nrm[j][Y[i]] = nrm[Y[i]][j] = \n\t\t\t\t\t   (nrmX + nrmY) % Mod;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinv[j][X[i]] = inv[X[i]][j] = (invX + nrmY) % Mod;\n\t\t\t\t\tinv[j][Y[i]] = inv[Y[i]][j] = (invY + nrmX) % Mod;\n\t\t\t\t\tnrm[j][X[i]] = nrm[X[i]][j] = (nrmX + invY) % Mod;\n\t\t\t\t\tnrm[j][Y[i]] = nrm[Y[i]][j] = (nrmY + invX) % Mod;\n\t\t\t\t}\n\n\t\t\t\tlstedit[j][X[i]] = lstedit[X[i]][j] =\n\t\t\t\t   lstedit[j][Y[i]] = lstedit[Y[i]][j] = i;\n\t\t\t}\n\t\t}\n\n\t\tll invxy = getInv(X[i] , Y[i] , i);\n\t\tll nrmxy = getNrm(X[i] , Y[i] , i);\n\t\tinv[X[i]][Y[i]] = inv[Y[i]][X[i]] = (invxy + nrmxy) % Mod;\n\t\tnrm[X[i]][Y[i]] = nrm[Y[i]][X[i]] = (invxy + nrmxy) % Mod;\n\t\tlstedit[X[i]][Y[i]] = lstedit[Y[i]][X[i]] = i;\n\t}\n\n\t/*cout << \"\\n**\\n\";\n\tfor(int j = 1; j <= n ; j++)\n\t{\n\t\tfor(int k = 1; k <= n ; k++)\n\t\t\tcout << getReal(j , k , q + 1) << \" \";\n\t\tcout << '\\n';\n\t}*/\n\n\tll ANS = 0;\n\tfor(int i = 1; i <= n ; i++)\n\t{\n\t\tfor(int j = i + 1; j <= n ; j++)\n\t\t\tANS += getInv(i,j, q + 1);\n\t}\n\tcout << '\\n' << ANS << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/agc030/tasks/agc030_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3010\n#define mod 1000000007\n\nint A[N];\n\nstruct qqq{\n  int dp,dp2,lazy;\n} mdp[N][N][2];\n\nint getState(int i,int j) {\n  if(i<j) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\ninline int add(int x,int y) {\n  int ret = x+y;\n  if(ret>=mod) {\n    return ret-mod;\n  }\n  return ret;\n}\n\ninline int mul(int x,int y) {\n  return (ll)x*y%mod;\n}\n\n\nvoid getTransition(int &st,int &i,int &j,int x,int y) {\n  int ni = i;\n  if(x==i) {\n    ni = y;\n  } else if(ni==y) {\n    ni = x;\n  }\n  int nj = j;\n  if(x==j) {\n    nj = y;\n  } else if(nj==y) {\n    nj = x;\n  }\n  int ijState = (i<j) ? 1 : 0;\n  int ni_nj_state = (ni<nj) ? 1 :0;\n  int nst = st;\n  if(ijState!=ni_nj_state) {\n    nst ^=1;\n  }\n  st = nst;\n  i = ni;\n  j = nj;\n}\n\nint powerOfTwo[N];\nint getValue(int x,int y,int st,int curQ) {\n  int v = powerOfTwo[curQ- mdp[x][y][st].lazy];\n  return mul(v,mdp[x][y][st].dp);\n}\n\nvoid solve() {\n  int n,q;\n  scanf(\"%d %d\", &n,&q);\n  powerOfTwo[0] = 1;\n  for(int i=1;i<N;++i) {\n    powerOfTwo[i] = mul(powerOfTwo[i-1],2);\n  }\n\n  for(int i=0;i<n;++i) {\n    scanf(\"%d \", &A[i]);\n  }\n\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      if(A[i]==A[j]) {\n        continue;\n      }\n      if(A[i]>A[j]) {\n        ++mdp[i][j][1].dp;\n      } else {\n        ++mdp[i][j][0].dp;\n      }\n    }\n  }\n\n  int lazy_value = 0;\n  pair<int,pair<int,int> >trans;\n  int val,i,st;\n  int a,b,c;\n  while(q--) {\n    int x,y;scanf(\"%d %d \", &x,&y);\n    if(x>y) {\n      swap(x,y);\n    }\n\n    --x,--y;\n    //optimize by lazy-eval\n    for(i=0;i<n;++i) {\n      for(st=0;st<2;++st) {\n        if(i!=x) {\n          mdp[x][i][st].dp2 = 0;\n          mdp[i][x][st].dp2 = 0;\n        }\n        if(i!=y && i!=x) {\n          mdp[y][i][st].dp2 = 0;\n          mdp[i][y][st].dp2 = 0;\n        }\n      }\n    }\n    for(i=0;i<n;++i) {\n      for(st=0;st<2;++st) {\n        if(i!=x) {\n          //dp2[i][x][st] = 0;\n          val = getValue(i,x,st,lazy_value);\n          if(val!=0) {\n            a = st,b= i,c = x;\n            getTransition(a,b,c,x,y);\n\n            mdp[i][x][st].dp2 = add(mdp[i][x][st].dp2, val);\n            mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n          }\n          val = getValue(x,i,st,lazy_value);\n          if(val!=0) {\n            a = st,b = x,c = i;\n            getTransition(a,b,c,x,y);\n            mdp[x][i][st].dp2 = add(mdp[x][i][st].dp2, val);\n            mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n          }\n        }\n        if(i!=y && i!=x) {\n          val = getValue(i,y,st,lazy_value);\n          if(val!=0) {\n            a = st,b= i,c = y;\n            getTransition(a,b,c,x,y);\n            mdp[i][y][st].dp2 = add(mdp[i][y][st].dp2, val);\n            mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n          }\n\n          val = getValue(y,i,st,lazy_value);\n          if(val!=0) {\n            a = st,b= y,c = i;\n            getTransition(a,b,c,x,y);\n            mdp[y][i][st].dp2 = add(mdp[y][i][st].dp2, val);\n            mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n          }\n        }\n      }\n    }\n\n    for(i=0;i<n;++i) {\n      for(st=0;st<2;++st) {\n        if(i!=x) {\n          mdp[x][i][st].dp = mdp[x][i][st].dp2;\n          mdp[i][x][st].dp = mdp[i][x][st].dp2;\n          mdp[x][i][st].lazy = lazy_value+1;\n          mdp[i][x][st].lazy = lazy_value+1;\n        }\n        if(i!=y && i!=x) {\n          mdp[y][i][st].dp = mdp[y][i][st].dp2;\n          mdp[i][y][st].dp = mdp[i][y][st].dp2;\n          mdp[y][i][st].lazy = lazy_value+1;\n          mdp[i][y][st].lazy = lazy_value+1;\n        }\n      }\n    }\n    ++lazy_value;\n  }\n  int ret = 0,j;\n  for(i=0;i<n;++i) {\n    for(j=0;j<n;++j) {\n      ret = add(ret, getValue(i,j,1,lazy_value));\n    }\n  }\n\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing std::swap;\nconst int mod=1e9+7,inv2=(mod+1)/2;\ninline int add(int a,int b)\n{\n\treturn (a+=b)>=mod?a-mod:a;\n}\ninline int sub(int a,int b)\n{\n\treturn (a-=b)<0?a+mod:a;\n}\ninline int mul(int a,int b)\n{\n\treturn (long long)a*b%mod;\n}\nconst int N=3005;\nint n,q,ans,p2q;\nint a[N];\nint x[N],y[N];\nint dp[N][N];\nint tmp[2][2][N];\nint t0,t1;\nsigned main()\n{\n\tregister int i,j;\n\tscanf(\"%d%d\",&n,&q);\n\tp2q=1;\n\tfor(i=1;i<=q;i++)\n\t\tp2q=mul(p2q,2);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(i=1;i<=q;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(a[i]<a[j])\n\t\t\t\tdp[i][j]=1;\n\tfor(i=1;i<=q;i++)\n\t{\n\t\tt0=dp[x[i]][y[i]];\n\t\tt1=dp[y[i]][x[i]];\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\ttmp[0][0][j]=dp[x[i]][j];\n\t\t\t\ttmp[0][1][j]=dp[y[i]][j];\n\t\t\t\ttmp[1][0][j]=dp[j][x[i]];\n\t\t\t\ttmp[1][1][j]=dp[j][y[i]];\n\t\t\t}\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tdp[y[i]][j]=add(dp[y[i]][j],tmp[0][0][j]);\n\t\t\t\tdp[x[i]][j]=add(dp[x[i]][j],tmp[0][1][j]);\n\t\t\t\tdp[j][y[i]]=add(dp[j][y[i]],tmp[1][0][j]);\n\t\t\t\tdp[j][x[i]]=add(dp[j][x[i]],tmp[1][1][j]);\n\t\t\t}\n\t\tdp[x[i]][y[i]]=add(dp[x[i]][y[i]],t1);\n\t\tdp[y[i]][x[i]]=add(dp[y[i]][x[i]],t0);\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tdp[x[i]][j]=mul(dp[x[i]][j],inv2);\n\t\t\t\tdp[y[i]][j]=mul(dp[y[i]][j],inv2);\n\t\t\t\tdp[j][x[i]]=mul(dp[j][x[i]],inv2);\n\t\t\t\tdp[j][y[i]]=mul(dp[j][y[i]],inv2);\n\t\t\t}\n\t\tdp[x[i]][y[i]]=mul(dp[x[i]][y[i]],inv2);\n\t\tdp[y[i]][x[i]]=mul(dp[y[i]][x[i]],inv2);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<i;j++)\n\t\t\tans=add(ans,mul(dp[i][j],p2q));\n\tmemset(dp,0,sizeof(dp));\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tdp[i][j]=1;\n\tfor(i=1;i<=q;i++)\n\t{\n\t\tt0=dp[x[i]][y[i]];\n\t\tt1=dp[y[i]][x[i]];\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\ttmp[0][0][j]=dp[x[i]][j];\n\t\t\t\ttmp[0][1][j]=dp[y[i]][j];\n\t\t\t\ttmp[1][0][j]=dp[j][x[i]];\n\t\t\t\ttmp[1][1][j]=dp[j][y[i]];\n\t\t\t}\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tdp[y[i]][j]=add(dp[y[i]][j],tmp[0][0][j]);\n\t\t\t\tdp[x[i]][j]=add(dp[x[i]][j],tmp[0][1][j]);\n\t\t\t\tdp[j][y[i]]=add(dp[j][y[i]],tmp[1][0][j]);\n\t\t\t\tdp[j][x[i]]=add(dp[j][x[i]],tmp[1][1][j]);\n\t\t\t}\n\t\tdp[x[i]][y[i]]=add(dp[x[i]][y[i]],t1);\n\t\tdp[y[i]][x[i]]=add(dp[y[i]][x[i]],t0);\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tdp[x[i]][j]=mul(dp[x[i]][j],inv2);\n\t\t\t\tdp[y[i]][j]=mul(dp[y[i]][j],inv2);\n\t\t\t\tdp[j][x[i]]=mul(dp[j][x[i]],inv2);\n\t\t\t\tdp[j][y[i]]=mul(dp[j][y[i]],inv2);\n\t\t\t}\n\t\tdp[x[i]][y[i]]=mul(dp[x[i]][y[i]],inv2);\n\t\tdp[y[i]][x[i]]=mul(dp[y[i]][x[i]],inv2);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tans=add(ans,mul(dp[i][j],p2q));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstatic const int64 mod = 1000000007LL;\nint64 dp[3003][3003];\nint64 temp[2][3003];\nint a[3003];\nint n,q;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i = 0;i < n;++i) {\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i = 0;i < n;++i) {\n\t\tfor(int j = 0;j < n;++j) {\n\t\t\tdp[i][j] = a[i] > a[j] ? 1 : 0;\n\t\t}\n\t}\n\tint64 inv2 = mod - mod / 2;\n\tint64 val = 1;\n\tfor(int i = 0;i < q;++i) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);--x,--y;\n\t\tfor(int j = 0;j < n;++j) {\n\t\t\t// dp[x][j] = dp[y][j] = (dp[x][j]+dp[y][j])/2\n\t\t\t// swap(dp[x][y], dp[y][x])\n\t\t\t// dp[x][y] = dp[y][x] = (dp[x][y]+dp[y][x])/2\n\t\t\ttemp[0][j] = (dp[x][j] + dp[y][j]) * inv2 % mod;\n\t\t\ttemp[1][j] = (dp[j][x] + dp[j][y]) * inv2 % mod;\n\t\t}\n\t\tfor(int j = 0;j < n;++j) {\n\t\t\tif(j != x && j != y) {\n\t\t\t\tdp[x][j] = temp[0][j];\n\t\t\t\tdp[j][x] = temp[1][j];\n\t\t\t\tdp[y][j] = temp[0][j];\n\t\t\t\tdp[j][y] = temp[1][j];\n\t\t\t}\n\t\t}\n\t\tint64 t2 = (dp[x][y] + dp[y][x]) * inv2 % mod;\n\t\tdp[x][y] = dp[y][x] = t2;\n\t\tval = val * 2 % mod;\n\t}\n\tint64 ans = 0;\n\tfor(int i = 0;i < n;++i) {\n\t\tfor(int j = i+1;j < n;++j) {\n\t\t\tans = (ans + dp[i][j]) % mod;\n\t\t}\n\t}\n\tans = ans * val % mod;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll INF = 1e9, MOD = 1e9 + 7;\n\nll a[2000], n, q, pw, inv2;\n\nll qpow (ll a, ll b)\n{\n\tll s = 1;\n\n\twhile (b)\n\t{\n\t\tif (b & 1) s = s * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * a % MOD;\n\t}\n\n\treturn s;\n}\n\nll d[2000][2000];\n\nll div2 (ll a)\n{\n\treturn {a * inv2 % MOD};\n}\n\nll sum (ll a, ll b)\n{\n\treturn {(a + b) % MOD};\n}\n\nint main ()\n{\n\tcin >> n >> q;\n\n\tpw = qpow (2, q);\n\tinv2 = qpow (2, MOD - 2);\n\n\n\tfor (int i = 0; i < n; i++)\n\t\tscanf (\"%lld\", &a[i]);\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[i] > a[j]) {\n\t\t\t\td[i][j] = pw;\n\t\t\t}\n\t\t\telse if (a[i] < a[j]) {\n\t\t\t\td[j][i] = pw;\n\t\t\t}\n\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf (\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (j != x && j != y) {\n\n\t\t\t\tauto xj = d[x][j], yj = d[y][j], jx = d[j][x], jy = d[j][y];\n\n\t\t\t\td[x][j] = div2 (sum (xj, yj));\n\t\t\t\td[y][j] = div2 (sum (xj, yj));\n\t\t\t\td[j][x] = div2 (sum (jx, jy));\n\t\t\t\td[j][y] = div2 (sum (jx, jy));\n\t\t\t}\n\n\t\tauto xy = d[x][y], yx = d[y][x];\n\n\t\td[x][y] = div2 (sum (xy, yx));\n\t\td[y][x] = div2 (sum (xy, yx));\n\t}\n\n\tll ans = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tans += d[i][j];\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define P 1000000007\n#define PI pair <ll, ll>\n#define f first\n#define s second\n\nusing namespace std;\n\ntypedef long long ll;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nint n, q, A[3333], X[3333], Y[3333];\n\nll F[3333][3333], tmp[3333][3333];\n\nint main() {\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &A[i]);\n    for(int i = 1; i <= q; i++) scanf(\"%d%d\", &X[i], &Y[i]);\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            F[i][j] = i > j ? 1 : 0;\n    ll r2 = powmod(2);\n    for(int i = q; i >= 1; i--) {\n        for(int j = 1; j <= n; j++) if(j != X[i] && j != Y[i]) {\n            ll o = (F[X[i]][j] + F[Y[i]][j]) * r2 % P;\n            F[Y[i]][j] = o;\n            F[X[i]][j] = o;\n            o = (F[j][X[i]] + F[j][Y[i]]) * r2 % P;\n            F[j][Y[i]] = o;\n            F[j][X[i]] = o;\n        }\n        ll o = (F[X[i]][Y[i]] + F[Y[i]][X[i]]) * r2 % P;\n        F[Y[i]][X[i]] = o;\n        F[X[i]][Y[i]] = o;\n    }\n    ll ans = 0;\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            if(A[i] < A[j]) {\n                ans = (ans + F[i][j]) % P;\n            }\n    printf(\"%lld\\n\", (ans * powmod(2, q) % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define fir first\n#define sec second\n#define mod 998244353\n#define i2 499122177\n#define INF 0x3fffffff\n#define ll long long\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mul(int x,int y){return 1LL*x*y%mod;}\n#define N 3005\nint f[N][N];\nint a[N];\nsigned main()\n{\n\tint n=read(),Q=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) f[i][j]=a[i]>a[j];\n\t}\n\tint Mul=1;\n\twhile(Q--)\n\t{\n\t\tMul=add(Mul,Mul);\n\t\tint u=read(),v=read();\n\t\tf[u][v]=f[v][u]=mul(add(f[u][v],f[v][u]),i2);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==u||i==v) continue;\n\t\t\tf[i][u]=f[i][v]=mul(add(f[i][u],f[i][v]),i2);\n\t\t\tf[u][i]=f[v][i]=mul(add(f[u][i],f[v][i]),i2);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++) ans=add(ans,f[i][j]);\n\t}\n\tcout<<mul(ans,Mul)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\ntypedef tuple<int, int, ll> p;\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  vvl dp = VV(n+1, n+1, 0, ll); //iの方が前にある\n  for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) dp[i][j] = 1;\n  vll ml(n+1, 1);\n\n  ll z = 1;\n  for(auto v:query){\n    vector<p> tmp;\n    ll x = v[0], y = v[1];\n    if(x>y) swap(x, y);\n\n    // x, y\n    tmp.push_back(p(y, x, (ml[0]*(dp[x][y]*z)%P)%P));\n    tmp.push_back(p(x, y, (ml[0]*(dp[y][x]*z)%P)%P));\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      tmp.push_back(p(i, x, (ml[0]*(dp[i][y]*z)%P)%P));\n      tmp.push_back(p(x, i, (ml[0]*(dp[y][i]*z)%P)%P));\n    }\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      tmp.push_back(p(i, y, (ml[0]*(dp[i][x]*z)%P)%P));\n      tmp.push_back(p(y, i, (ml[0]*(dp[x][i]*z)%P)%P));\n    }\n\n    for(auto ad:tmp){\n      ll s = get<0>(ad);\n      ll t = get<1>(ad);\n      ll u = get<2>(ad);\n      dp[s][t] = (dp[s][t] + u)%P;\n    }\n\n    //z = (z*2)%P;\n    //ml[x] = (ml[x]*I)%P;\n    //ml[y] = (ml[y]*I)%P;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i!=j&&i!=x&&i!=y&&j!=x&&j!=y){\n          dp[i][j] = (dp[i][j]*2)%P;\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(a[i]<a[j]) ans = (ans + dp[j][i])%P;\n      if(a[i]>a[j]) ans = (ans + dp[i][j])%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//problem:agc030_d\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=3005,MOD=1e9+7;\ninline int mod1(int x){return x<MOD?x:x-MOD;}\ninline int mod2(int x){return x<0?x+MOD:x;}\ninline int pow_mod(int x,int i){int y=1;while(i){if(i&1)y=(ll)y*x%MOD;x=(ll)x*x%MOD;i>>=1;}return y;}\nint n,q,a[MAXN],f[MAXN][MAXN],g[MAXN][MAXN],tmp[MAXN][MAXN];\nint gt(int i,int j){\n\t//a[i]>a[j]\n\tif(i==j)return 0;\n\tif(i<j)return f[i][j];\n\tassert(g[i][j]==g[j][i]);\n\treturn mod2(mod2(1-f[j][i])-g[i][j]);\n}\nint main() {\n\tn=read();q=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tfor(int i=1;i<=n;++i)for(int j=i+1;j<=n;++j)if(a[i]>a[j])f[i][j]=1;\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if(a[i]==a[j])g[i][j]=1;\n\tint inv2=pow_mod(2,MOD-2);\n//\tfor(int i=1;i<=n;++i){\n//\t\tfor(int j=1;j<=n;++j){\n//\t\t\tcout<<f[i][j]<<\" \";\n//\t\t}\n//\t\tcout<<endl;\n//\t}\n//\tcout<<endl;\n\tfor(int t=1;t<=q;++t){\n\t\tint x=read(),y=read();\n\t\t\n\t\tfor(int i=1;i<x;++i)tmp[i][x]=mod1((ll)inv2*f[i][x]%MOD+(ll)inv2*((i!=y)?gt(i,y):gt(x,i))%MOD);\n\t\tfor(int i=x+1;i<=n;++i)tmp[x][i]=mod1((ll)inv2*f[x][i]%MOD+(ll)inv2*((i!=y)?gt(y,i):gt(i,x))%MOD);\n\t\tfor(int i=1;i<y;++i)tmp[i][y]=mod1((ll)inv2*f[i][y]%MOD+(ll)inv2*((i!=x)?gt(i,x):gt(y,i))%MOD);\n\t\tfor(int i=y+1;i<=n;++i)tmp[y][i]=mod1((ll)inv2*f[y][i]%MOD+(ll)inv2*((i!=x)?gt(x,i):gt(i,y))%MOD);\n\t\t\n\t\tfor(int i=1;i<x;++i)f[i][x]=tmp[i][x];\n\t\tfor(int i=x+1;i<=n;++i)f[x][i]=tmp[x][i];\n\t\tfor(int i=1;i<y;++i)f[i][y]=tmp[i][y];\n\t\tfor(int i=y+1;i<=n;++i)f[y][i]=tmp[y][i];\n\t\t\n\t\tfor(int i=1;i<=n;++i)tmp[i][x]=tmp[x][i]=tmp[i][y]=tmp[y][i]=mod1((ll)inv2*g[i][x]%MOD+(ll)inv2*g[i][y]%MOD);\n\t\ttmp[x][y]=tmp[y][x]=g[x][y];\n\t\tfor(int i=1;i<=n;++i)g[i][x]=tmp[i][x],g[x][i]=tmp[x][i],g[i][y]=tmp[i][y],g[y][i]=tmp[y][i];\n\t\tg[x][x]=g[y][y]=1;\n\t\t\n\t\t//debug:\n//\t\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if(i==j)assert(g[i][j]==1);else assert(g[i][j]==0);\n//\t\tfor(int i=1;i<=n;++i){\n//\t\t\tfor(int j=1;j<=n;++j){\n//\t\t\t\tcout<<f[i][j]<<\" \";\n//\t\t\t}\n//\t\t\tcout<<endl;\n//\t\t}\n//\t\tcout<<endl;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)for(int j=i+1;j<=n;++j)ans=mod1(ans+f[i][j]);\n\tcout<<(ans=(ll)ans*pow_mod(2,q)%MOD)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define ll long long\nconst int MAXN = 5e5 + 7;\nconst ll p = 1e9 + 7;\nconst ll inv2 = 500000004ll;\nint n, m;\nint a[MAXN];\nstruct rec\n{\n    int x, y;\n} q[MAXN];\nint f[3500][3500];\n\ninline ll ksm(int x, int y)\n{\n    ll ans = 1;\n    while (y)\n    {\n        if (y & 1)\n            ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d\", &q[i].x, &q[i].y);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            f[i][j] = a[i] < a[j];\n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        f[q[i].x][q[i].y] = f[q[i].y][q[i].x] = inv2 * (f[q[i].x][q[i].y] + f[q[i].y][q[i].x]) % p;\n        for (int j = 1; j <= n; j++)\n        {\n            if (j != q[i].x && j != q[i].y)\n            {\n                f[j][q[i].x] = f[j][q[i].y] = inv2 * (f[j][q[i].x] + f[j][q[i].y]) % p;\n                f[q[i].y][j] = f[q[i].x][j] = inv2 * (f[q[i].y][j] + f[q[i].x][j]) % p;\n            }\n        }\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j < i; j++)\n        {\n            ans += f[i][j];\n        }\n    }\n    printf(\"%lld\", ans % p * ksm(2, m) % p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,q;\n  cin >> n >> q;\n  \n  vector<int> a(n);\n  REP(i,n) cin >> a[i];\n  \n  mat dp(n,vec(n,0));\n  REP(i,n) REP(j,n){\n    if(a[i] > a[j]) dp[i][j] = 1;\n  }\n\n  REP(_,q){\n    int x,y; \n    cin >> x >> y; x--; y--;\n    REP(i,n){\n      if(i!=x&&i!=y){\n        dp[i][x] = dp[i][y] = (dp[i][x]+dp[i][y])/2;\n        dp[x][i] = dp[y][i] = (dp[x][i]+dp[y][i])/2;\n      }\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y]+dp[y][x])/2;\n  }\n\n  mint ans = 0;\n  REP(i,n) FOR(j,i+1,n) ans += dp[i][j];\n\n  REP(_,q) ans *= 2;\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T> bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> v) {\n    for (int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for (auto &e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <ll mod> struct modint {\n    ll val;\n    inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n        if (a < b) {\n            return extgcd(b, a, y, x);\n        }\n        if (b == 0) {\n            x = 1, y = 0;\n            return a;\n        }\n        ll d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n        return d;\n    }\n    inline ll minv(ll k) {\n        ll x = 0, y = 0;\n        extgcd(k, mod, x, y);\n        if (x < 0) {\n            x += mod;\n        } else if (x == mod) {\n            x = 0;\n        }\n        return x;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(ll x) { val = (x + mod) % mod; }\n    modint inv() { return modint(minv(val)); }\n    modint operator+(const modint &to) const { return modint(val + to.val); }\n    modint operator-(const modint &to) const { return modint(val - to.val); }\n    modint operator*(const modint &to) const { return modint(val * to.val); }\n    modint operator/(const modint &to) const {\n        return modint(val * minv(to.val));\n    }\n    template <class T> explicit operator T() { return T(val); }\n    modint &operator++() { return *this = modint(val + 1); }\n    modint &operator--() { return *this = modint(val - 1); }\n    template <typename T> modint &operator+=(const T &to) {\n        return *this = *this + to;\n    }\n    template <typename T> modint &operator-=(const T &to) {\n        return *this = *this - to;\n    }\n    template <typename T> modint &operator*=(const T &to) {\n        return *this = *this * to;\n    }\n    template <typename T> modint &operator/=(const T &to) {\n        return *this = *this / to;\n    }\n    bool operator==(const modint &to) const { return val == to.val; }\n    bool operator!=(const modint &to) const { return val != to.val; }\n    bool operator>(const modint &to) const { return val > to.val; }\n    bool operator>=(const modint &to) const { return val >= to.val; }\n    bool operator<(const modint &to) const { return val < to.val; }\n    bool operator<=(const modint &to) const { return val <= to.val; }\n};\nusing mint = modint<MOD>;\ninline mint mpow(mint x, ll n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= x;\n        }\n        x = x * x;\n        n >>= 1;\n    }\n    return res;\n}\nmint dp[3010][3010];\nint co[3010][3010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n            co[i][j] = -1;\n        }\n    }\n    for (ll i = 0; i < q; i++) {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        mint s = dp[x][y] * mpow(2LL, i - co[x][y] - 1) +\n                 dp[y][x] * mpow(2LL, i - co[y][x] - 1);\n        dp[x][y] = s;\n        dp[y][x] = s;\n        co[x][y] = i;\n        co[y][x] = i;\n        for (int j = 0; j < n; j++) {\n            if (j != x && j != y) {\n                mint s1 = dp[j][x] * mpow(2LL, i - co[j][x] - 1) +\n                          dp[j][y] * mpow(2LL, i - co[j][y] - 1),\n                     s2 = dp[x][j] * mpow(2LL, i - co[x][j] - 1) +\n                          dp[y][j] * mpow(2LL, i - co[y][j] - 1);\n                dp[j][x] = s1;\n                dp[x][j] = s2;\n                dp[j][y] = s1;\n                dp[y][j] = s2;\n                co[x][j] = i;\n                co[j][x] = i;\n                co[y][j] = i;\n                co[j][y] = i;\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            res += dp[i][j] * mpow(2LL, q - co[i][j] - 1);\n        }\n    }\n    cout << res.val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint inv2=(mod+1)/2;\n\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nint N,Q;\nint A[3333];\nint X[3333],Y[3333];\n\nint w[3333][3333];\n\nsigned main(){\n    cin>>N>>Q;\n    rep(i,N)cin>>A[i];\n\n    rep(i,Q){\n        cin>>X[i]>>Y[i];\n        X[i]--;Y[i]--;\n    }\n\n    rep(i,N)rep(j,i)w[i][j]=1;\n\n    for(int i=Q-1;i>=0;i--){\n        int x=X[i];\n        int y=Y[i];\n\n        rep(j,N)if(j!=x&&j!=y){\n            w[j][x]=w[j][y]=(w[j][x]+w[j][y])*inv2%mod;\n            w[x][j]=w[y][j]=(w[x][j]+w[y][j])*inv2%mod;\n        }\n        w[x][y]=w[y][x]=(w[x][y]+w[y][x])*inv2%mod;\n    }\n\n    int K=1;rep(i,Q)K=K*2%mod;\n    rep(i,N)rep(j,N)w[i][j]=w[i][j]*K%mod;\n\n    int ans=0;\n    rep(i,N)for(int j=i+1;j<N;j++){\n        if(A[i]<A[j]){\n            add(ans,w[i][j]);\n        }\n        else if(A[i]>A[j]){\n            add(ans,w[j][i]);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define N 3009\nusing namespace std;\n\nint n,m,a[N],f[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j,x,y,tmp;\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=1; j<=n; j++) f[i][j]=(a[i]<a[j]);\n\tint t=1;\n\twhile (m--){\n\t\tt=t*2%mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor (i=1; i<=n; i++) if (i!=x && i!=y){\n\t\t\ttmp=f[x][i]+f[y][i]; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\t\tf[x][i]=f[y][i]=tmp;\n\t\t\ttmp=f[i][x]+f[i][y]; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\t\tf[i][x]=f[i][y]=tmp;\n\t\t}\n\t\ttmp=f[x][y]+f[y][x]; tmp=(tmp&1)?(tmp+mod>>1):tmp>>1;\n\t\tf[x][y]=f[y][x]=tmp;\n\t}\n\tint ans=0;\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=1; j<i; j++) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",(ll)ans*t%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long N, Q, A[3009], X[3009], Y[3009], dp[3009][3009], mul = 1, inv = 500000004, mod = 1000000007;\nlong long nex[3009][3009];\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 1; i <= N; i++) cin >> A[i];\n\tfor (int i = 1; i <= Q; i++) { cin >> X[i] >> Y[i]; if (X[i] > Y[i]) swap(X[i], Y[i]); }\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (A[i] < A[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\t\n\t// 確率で DP\n\tfor (int i = 1; i <= Q; i++) {\n\t\tnex[X[i]][Y[i]] += (dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv; nex[X[i]][Y[i]] %= mod;\n\t\tnex[Y[i]][X[i]] += (dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv; nex[Y[i]][X[i]] %= mod;\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (j == X[i] || j == Y[i]) continue;\n\t\t\tnex[Y[i]][j] += (dp[Y[i]][j] + dp[X[i]][j]) * inv; nex[Y[i]][j] %= mod;\n\t\t\tnex[X[i]][j] += (dp[Y[i]][j] + dp[X[i]][j]) * inv; nex[X[i]][j] %= mod;\n\t\t\tnex[j][Y[i]] += (dp[j][Y[i]] + dp[j][X[i]]) * inv; nex[j][Y[i]] %= mod;\n\t\t\tnex[j][X[i]] += (dp[j][Y[i]] + dp[j][X[i]]) * inv; nex[j][X[i]] %= mod;\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tdp[j][X[i]] = nex[j][X[i]];\n\t\t\tdp[j][Y[i]] = nex[j][Y[i]];\n\t\t\tdp[X[i]][j] = nex[X[i]][j];\n\t\t\tdp[Y[i]][j] = nex[Y[i]][j];\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tnex[X[i]][j] = 0; nex[Y[i]][j] = 0; nex[j][X[i]] = 0; nex[j][Y[i]] = 0;\n\t\t}\n\t\tmul *= 2; mul %= mod;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (i > j) ans += dp[i][j];\n\t\t}\n\t}\n\tcout << (ans * mul) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 3010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN];\nint dp[MAXN][MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n>>m;\n\tfor (int i=1; i<=n; i++) cin>>A[i];\n\tfor (int i=1; i<=n; i++) for (int j=1; j<=n; j++) dp[i][j]=(A[i]<A[j]);\n\tfor (int t=1; t<=m; t++){\n\t\tcin>>x>>y;\n\t\t\n\t\tvector<piii> vec;\n\t\tvec.pb({{x, y}, (dp[x][y]+dp[y][x])*(mod+1ll)/2%mod});\n\t\tvec.pb({{y, x}, (dp[x][y]+dp[y][x])*(mod+1ll)/2%mod});\n\t\t\n\t\tfor (int i=1; i<=n; i++) if (i!=x && i!=y){\n\t\t\tvec.pb({{x, i}, (dp[x][i] + dp[y][i])*(mod+1ll)/2%mod});\t\t\n\t\t\tvec.pb({{i, x}, (dp[i][x] + dp[i][y])*(mod+1ll)/2%mod});\t\t\n\t\t\tvec.pb({{y, i}, (dp[x][i] + dp[y][i])*(mod+1ll)/2%mod});\n\t\t\tvec.pb({{i, y}, (dp[i][x] + dp[i][y])*(mod+1ll)/2%mod});\n\t\t}\n\t\tfor (piii p:vec) dp[p.first.first][p.first.second]=p.second;\n\t\t\n\t}\n\tfor (int i=1; i<=n; i++) for (int j=1; j<i; j++) ans=(ans + dp[i][j])%mod;\n\tfor (int i=0; i<m; i++) ans=ans*2%mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n// A pretty cool dp problem\n// https://atcoder.jp/contests/agc030/tasks/agc030_d\nusing namespace std;\nconst int MOD = 1'000'000'007;\nconst long long HALF = 500'000'004LL;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    // pInverted[i][j] = The probability that a_i < a_j.\n    vector<vector<int>> pLess(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            pLess[i][j] = a[i] < a[j];\n        }\n    }\n    long long ways = 1;\n    for (int i = 0; i < q; i++) {\n        ways = (ways * 2) % MOD;\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        for (int j = 0; j < n; j++) {\n            if (j != x && j != y) {\n                pLess[j][y] = pLess[j][x] =\n                        ((pLess[j][y] + pLess[j][x]) * HALF) % MOD;\n                pLess[x][j] = pLess[y][j] =\n                        ((pLess[x][j] + pLess[y][j]) * HALF) % MOD;\n            }\n        }\n        pLess[x][y] = pLess[y][x] =\n                ((pLess[x][y] + pLess[y][x]) * HALF) % MOD;\n    }\n    long long expectedWays = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            // In this loop, j < i. Now we add if a[i] < a[j]\n            expectedWays += pLess[i][j];\n        }\n    }\n    expectedWays = expectedWays % MOD;\n    int totalWays = (expectedWays * ways) % MOD;\n    cout << totalWays << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  int inv2 = -1;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n    inv2 = inv(2);\n  }\n  public :\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      if (a == 2 && inv2 != -1) return inv2;\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  for (int cnt = 0; cnt < q; cnt++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    dp[x][y] = dp[y][x] = fld.inv(2);\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      fld.div(a, 2);\n      b = a;\n    };\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  int coeff = fld.pow(2, q);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007, Inv2 = (Mod + 1) / 2;\nconst int MN = 3005;\n\nint N, Q, A[MN], p1[MN], p2[MN];\nint dp[MN][MN], Coef, Sum;\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q), Coef = 1;\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= Q; ++i) {\n\t\tscanf(\"%d%d\", &p1[i], &p2[i]);\n\t\tif (p1[i] > p2[i]) std::swap(p1[i], p2[i]);\n\t}\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tdp[i][j] = A[i] > A[j];\n\tfor (int i = 1; i <= Q; ++i) {\n\t\tstatic int tmp[MN][MN];\n\t\tfor (int x = 1; x <= N; ++x)\n\t\t\tif (x != p1[i] && x != p2[i]) {\n\t\t\t\ttmp[x][p1[i]] = (LL)Inv2 * (dp[x][p1[i]] + dp[x][p2[i]]) % Mod;\n\t\t\t\ttmp[p1[i]][x] = (LL)Inv2 * (dp[p1[i]][x] + dp[p2[i]][x]) % Mod;\n\t\t\t\ttmp[x][p2[i]] = (LL)Inv2 * (dp[x][p2[i]] + dp[x][p1[i]]) % Mod;\n\t\t\t\ttmp[p2[i]][x] = (LL)Inv2 * (dp[p2[i]][x] + dp[p1[i]][x]) % Mod;\n\t\t\t}\n\t\tfor (int x = 1; x <= N; ++x)\n\t\t\tif (x != p1[i] && x != p2[i]) {\n\t\t\t\tdp[x][p1[i]] = tmp[x][p1[i]];\n\t\t\t\tdp[p1[i]][x] = tmp[p1[i]][x];\n\t\t\t\tdp[x][p2[i]] = tmp[x][p2[i]];\n\t\t\t\tdp[p2[i]][x] = tmp[p2[i]][x];\n\t\t\t}\n\t\tdp[p2[i]][p1[i]] = dp[p1[i]][p2[i]] = (LL)Inv2 * (dp[p1[i]][p2[i]] + dp[p2[i]][p1[i]]) % Mod;\n\t\tCoef = 2ll * Coef % Mod;\n\t}\n\tfor (int x = 1; x < N; ++x)\n\t\tfor (int y = x + 1; y <= N; ++y)\n\t\t\tSum = (Sum + dp[x][y]) % Mod;\n\tprintf(\"%lld\\n\", (LL)Coef * Sum % Mod);\n\treturn 0;\n}\n\n// Luogu : PinkRabbit"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=3010,mod=1e9+7;\nconst int inv2=(mod+1)/2;\nint f[N][N],n;\nint A[N],xi[N],m;\nint main() {\n\tint q,x,y; rd(n),rd(q);\n\tfor(int i=1;i<=n;++i) rd(A[i]),xi[i]=A[i];\n\tsort(xi+1,xi+n+1);\n\tm=unique(xi+1,xi+n+1)-xi-1;\n\tfor(int i=1;i<=n;++i) A[i]=lower_bound(xi+1,xi+m+1,A[i])-xi;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j) if(i!=j)\n\t\t\tf[i][j]=A[i]>A[j];\n\tint ax=1;\n\twhile(q--) {\n\t\tax=ax*2ll%mod;\n\t\tint x,y; rd(x),rd(y);\n\t\tfor(int i=1;i<=n;++i) if(i!=x&&i!=y) {\n\t\t\tint tmp1=(f[i][x]+f[i][y])*(ll)inv2%mod;\n\t\t\tf[i][x]=f[i][y]=tmp1;\n\t\t\tint tmp2=(f[x][i]+f[y][i])*(ll)inv2%mod;\n\t\t\tf[x][i]=f[y][i]=tmp2;\n\t\t}\n\t\tint tmp=(f[x][y]+f[y][x])*(ll)inv2%mod;\n\t\tf[x][y]=f[y][x]=tmp;\n\t}\n//\tfor(int i=1;i<=n;++i,puts(\"\"))\n//\t\tfor(int j=1;j<=n;++j)\n//\t\t\tprintf(\"%d \",f[i][j]);\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tans=(ans+f[i][j])%mod;\n\tprintf(\"%d\",ans*(ll)ax%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nconst LL rev2 = 500000004;\n\nint N;\nint Q;\nint A[3145];\nLL dp[3145][3145];\nLL pw2 = 1;\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n  rep(i, N) {\n    scanf(\"%d\", &A[i]);\n  }\n\n  rep(i, N) {\n    rep(j, N) {\n      if (A[i] < A[j]) dp[i][j]++;\n    }\n  }\n\n  rep(i, Q) {\n    pw2 *= 2;\n    pw2 %= MOD;\n\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    --y;\n\n    rep(j, N) {\n      if (j == y) continue;\n      if (j == x) continue;\n      LL t = (dp[x][j] + dp[y][j]) * rev2 % MOD;\n      dp[x][j] = dp[y][j] = t;\n      LL s = (dp[j][x] + dp[j][y]) * rev2 % MOD;\n      dp[j][x] = dp[j][y] = s;\n    }\n    LL u = (dp[x][y] + dp[y][x]) * rev2 % MOD;\n    dp[x][y] = dp[y][x] = u;\n  }\n\n  LL ans = 0;\n  rep(i, N) {\n    rep(j, i) {\n      ans += dp[i][j] * pw2;\n      ans %= MOD;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3005,p=1000000007,inv2=(p+1)/2,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,ans,a[N],f[N][N];\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++) f[i][j]=(a[i]>a[j]);\n\tfor (int k=1;k<=m;k++){\n\t\tint x=read(),y=read();\n\t\tf[x][y]=f[y][x]=(ll)(f[x][y]+f[y][x])*inv2%p;\n\t\tfor (int i=1;i<=n;i++)\n\t\tif ((i!=x)&&(i!=y)){\n\t\t\tf[x][i]=f[y][i]=(ll)(f[x][i]+f[y][i])*inv2%p;\n\t\t\tf[i][x]=f[i][y]=(ll)(f[i][x]+f[i][y])*inv2%p;\n\t\t}\n\t}\n\tans=0;\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++) check(ans,f[i][j]);\n\tans=(ll)ans*qpow(2,m)%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n  }\n  public:\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    // inline int prod (int a, int b) const {\n    //   return (long long)a * b % md;\n    // }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  int inv2 = fld.inv(2);\n  int coeff = fld.pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      fld.mul(a, inv2);\n      b = a;\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 505;\nconst int MOD = 1e9 + 7;\n\nint mul(int a, int b) {\n   return (a * b) % MOD; \n}\n\nint add(int a, int b) {\n   return (a + b) % MOD;\n}\n\nint binpow(int a, int b) {\n   int res = 1;\n   while (b) {\n      if (b & 1) res = mul(res, a);\n      a = mul(a, a);\n      b >>= 1;\n   }\n   return res;\n}\n\nint divv(int a, int b) {\n   return mul(a, binpow(b, MOD - 2));\n}\n\nint n;\nint dp[N][N][N];\n\nvoid rec_dp(int st, int x, int y) {\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n         if (i == j) {\n            dp[st + 1][i][j] = dp[st][i][j];\n            continue;\n         }\n         if (i != x && i != y && j != x && j != y) {\n            dp[st + 1][i][j] = dp[st][i][j];\n            continue;  \n         }\n         if (i == x && j == y) {\n            dp[st + 1][i][j] = divv(add(dp[st][i][j], dp[st][j][i]), 2);\n            continue;\n         }\n         if (i == y && j == x) {\n            dp[st + 1][i][j] = divv(add(dp[st][i][j], dp[st][j][i]), 2);\n            continue;\n         }\n         if (i == x) {\n            dp[st + 1][i][j] = divv(add(dp[st][i][j], dp[st][y][j]), 2);\n            continue;\n         }\n         if (i == y) {\n            dp[st + 1][i][j] = divv(add(dp[st][i][j], dp[st][x][j]), 2);\n            continue;\n         }\n         if (j == x) {\n            dp[st + 1][i][j] = divv(add(dp[st][i][j], dp[st][i][y]), 2);\n            continue;\n         }\n         if (j == y) {\n            dp[st + 1][i][j] = divv(add(dp[st][i][j], dp[st][i][x]), 2);\n            continue;\n         }\n         assert(false);\n      }\n   }\n}\n\nsigned main() {\n   ios_base::sync_with_stdio(false);\n   cin.tie(0);\n\n   int q;\n   cin >> n >> q;\n   vector<int> a(n);\n   for (auto &t : a) {\n      cin >> t;\n   }\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n         dp[0][i][j] = (a[i] > a[j]); \n      }\n   }\n   int pnt = 0;\n   while (q--) {\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      rec_dp(pnt, x, y);\n      pnt++;\n   }\n   int ans = 0;\n   for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n         ans = add(ans, dp[pnt][i][j]);\n      }\n   }\n   // for (int i = 0; i < n; i++) {\n   //    for (int j = 0; j < n; j++) {\n   //       cerr << mul(2, dp[pnt][i][j]) << ' ';\n   //    }\n   //    cerr << endl;\n   // }\n   for (int i = 0; i < pnt; i++) {\n      ans = mul(ans, 2);\n   }\n   cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 3005, mod = 1e9 + 7;\nint f[MAXN][MAXN];\nint a[MAXN];\n\ninline int qpow(int a, int k) {\n  int re = 1;\n  for (; k; k >>= 1, a = a * a % mod)\n    if (k & 1) re = re * a % mod;\n  return re;\n}\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, q; read(n), read(q);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = 1; j <= n; ++j)\n      f[i][j] = a[i] > a[j];\n  int inv2 = qpow(2, mod - 2);\n  for (RI i = 1, x, y; i <= q; ++i) {\n    read(x), read(y);\n    f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv2 % mod;\n    for (RI j = 1; j <= n; ++j)\n      if (j != x && j != y) {\n        f[x][j] = f[y][j] = (f[x][j] + f[y][j]) * inv2 % mod;\n        f[j][x] = f[j][y] = (f[j][x] + f[j][y]) * inv2 % mod;\n      }\n  }\n  int ans = 0;\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = i + 1; j <= n; ++j)\n      ans = (ans + f[i][j]);\n  printf(\"%lld\\n\", ans * qpow(2, q) % mod);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3050;\ntypedef long long ll;\nconst ll mod=1000000007;\nconst ll inv=500000004;\nint n,q,ai[N];\nll dp[N][N],ans,pl;\n\ninline ll KSM(ll a,ll p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tpl=KSM(2,q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&ai[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(ai[i]>ai[j])\n\t\t\t\tdp[i][j]=1;\n\twhile(q--){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tdp[x][y]=dp[y][x]=((dp[x][y]+dp[y][x])%mod)*inv%mod;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x || i==y) continue;\n\t\t\tdp[i][x]=dp[i][y]=((dp[i][y]+dp[i][x])%mod)*inv%mod;\n\t\t\tdp[x][i]=dp[y][i]=((dp[y][i]+dp[x][i])%mod)*inv%mod;\n\t\t}\n//\t\tfor(int i=1;i<=n;i++)\t\n//\t\t{\n//\t\t\tfor(int j=1;j<=n;j++)\n//\t\t\t\tcout<<dp[i][j]<<\" \";\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(dp[i][j]+ans)%mod;\n\tans=ans*pl%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define N 3005\n\nusing namespace std;\n\ninline int In(){\n\tchar c=getchar(); int x=0,ft=1;\n\tfor(;c<'0'||c>'9';c=getchar()) if(c=='-') ft=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) x=x*10+c-'0';\n\treturn x*ft;\n}\n\nconst int P=1e9+7,inv2=5e8+4;\nint n,q,A[N],f[N][N],ans=0;\n\ninline int fpow(int x,int k){\n\tint s=1,t=x;\n\tfor(;k;k>>=1,t=1ll*t*t%P) if(k&1) s=1ll*s*t%P;\n\treturn s;\n}\n\nint main(){\n\tn=In(); q=In();\n\tfor(int i=1;i<=n;++i) A[i]=In();\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j)\n\tif(i^j) f[i][j]=(A[i]>A[j]);\n\tfor(int i=1,x,y;i<=q;++i){\n\t\tx=In(); y=In(); if(x>y) swap(x,y);\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])%P*inv2%P;\n\t\tfor(int j=1;j<=n;++j) if(j^x&&j^y)\n\t\tf[x][j]=f[y][j]=1ll*(f[x][j]+f[y][j])%P*inv2%P,\n\t\tf[j][x]=f[j][y]=1ll*(f[j][x]+f[j][y])%P*inv2%P;\n\t}\n\tfor(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j)\n\tans=(ans+f[i][j])%P; ans=1ll*fpow(2,q)*ans%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n  }\n  public:\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  int inv2 = fld.inv(2);\n  int coeff = fld.pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      fld.mul(a, inv2);\n      b = a;\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int rev2 = 5e8 + 4;\n\nint main() {\n  int N, Q, A[3000];\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n  }\n\n  int64 dp[3000][3000] = {{}};\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      dp[i][j] = A[i] > A[j];\n    }\n  }\n  for(int i = 0; i < Q; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    for(int j = 0; j < N; j++) {\n      if(j != x && j != y) {\n        dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) * rev2 % mod;\n        dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) * rev2 % mod;\n      }\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * rev2 % mod;\n  }\n  int64 ret = 0;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < i; j++) (ret += dp[j][i]) %= mod;\n  }\n  for(int i = 0; i < Q; i++) (ret *= 2) %= mod;\n  cout << ret << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nint a[3005];\nll power(ll n,ll x){\n    ll sp=1ll;\n    while(x){\n        if(x&1) sp=sp*n%mod;\n        n=n*n%mod;x>>=1;\n    }return sp;\n}\nll inv=(mod+1)>>1,base,ans;\nll dp[3005][3005];\nint n,m;\nint main(){\n    scanf(\"%d%d\",&n,&m);base=power(2,m);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n    dp[i][j]=(a[i]<a[j]);\n    while(m--){\n        ll l,r;scanf(\"%d%d\",&l,&r);\n        dp[l][r]=dp[r][l]=(dp[l][r]+dp[r][l])*inv%mod;\n        for(int i=1;i<=n;i++)\n        if(i!=l&&i!=r){\n            dp[i][l]=dp[i][r]=(dp[i][l]+dp[i][r])*inv%mod;\n            dp[l][i]=dp[r][i]=(dp[l][i]+dp[r][i])*inv%mod;\n        }\n    }\n    ans=0;\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<i;j++)\n    (ans+=dp[i][j])%=mod;\n    printf(\"%lld\",ans*base%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = *this^(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, Q;\n\tcin >> N >> Q;\n\tvector<ll> A(N + 1);\n\trepn(i, N) cin >> A[i];\n\n\tvector<ll> X(Q + 1), Y(Q + 1);\n\trepn(i, Q) cin >> X[i] >> Y[i];\n\n\tvector<vector<mint>> dp(N + 1, vector<mint>(N + 1,0));\n\tvector<vector<ll>> up(N + 1, vector<ll>(N + 1, 0));\n\n\trepn(i, N)repn(j, N) {\n\t\tif (A[i] > A[j]) { dp[i][j] = 1; }\n\t}\n\t\n\trepn(q, Q) {\n\t\tll x = X[q];\n\t\tll y = Y[q];\n\n\t\trepn(i, N) {\n\t\t\tif (i == x || i == y) { continue; }\n\n\t\t\tmint t, u;\n\n\t\t\tt = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tt += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tu = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tu += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tdp[x][i] = t;\n\t\t\tdp[y][i] = u;\n\n\t\t\tt = 0;\n\t\t\tu = 0;\n\n\t\t\tt = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tt += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tu = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tu += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tdp[i][x] = t;\n\t\t\tdp[i][y] = u;\n\n\t\t\tup[x][i] = q;\n\t\t\tup[y][i] = q;\n\t\t\tup[i][x] = q;\n\t\t\tup[i][y] = q;\n\n\t\t}\n\n\t\tmint t, u;\n\n\t\tt = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tt += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tu = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tu+= ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tdp[x][y] = t;\n\t\tdp[y][x] = u;\n\n\t\tup[x][y] = q;\n\t\tup[y][x] = q;\n\n\n\n\t}\n\n\tmint ans = 0;\n\trepn(i, N)repn(j, N) {\n\t\tdp[i][j] *= ((mint)2 ^ (Q - up[i][j]));\n\t\tif (j > i) { ans += dp[i][j]; }\n\t}\n\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ttgl, null_type,less<ttgl>, rb_tree_tag,tree_order_statistics_node_update>*/\n \nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 3001;\nint n, q;\nint arr[mxN];\nttgl query[mxN];\nll dp_prev[mxN][mxN];\nll dp[mxN][mxN];\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>q;\n    owo(i, 0, n) {\n        cin>>arr[i];\n    }\n    ll inv2 = modInv(2);\n    owo(i, 0, q) {\n        cin>>query[i].first>>query[i].second;\n        if(query[i].first>query[i].second)swap(query[i].first, query[i].second);\n        query[i].first--;\n        query[i].second--;\n    }\n    owo(i, 0, n) {\n        owo(j, 0, n) {\n            if(i==j)continue;\n            if(arr[i]>arr[j]) {\n                dp_prev[i][j] = 1;\n                dp[i][j] = 1;\n            }\n        }\n    }\n    owo(i, 0, q) {\n        int a = query[i].first;\n        int b = query[i].second;\n        owo(j, 0, n) {\n            if(j==a||j==b)continue;\n            dp[j][a] = (dp_prev[j][a]*inv2 + dp_prev[j][b]*inv2)%MOD;\n            dp[a][j] = (dp_prev[a][j]*inv2 + dp_prev[b][j]*inv2)%MOD;\n            dp[j][b] = (dp_prev[j][b]*inv2 + dp_prev[j][a]*inv2)%MOD;\n            dp[b][j] = (dp_prev[b][j]*inv2 + dp_prev[a][j]*inv2)%MOD;\n        }\n        dp[a][b] = (dp_prev[a][b]*inv2 + dp_prev[b][a]*inv2)%MOD;\n        dp[b][a] = dp[a][b];\n        owo(j, 0, n) {\n            dp_prev[j][a] = dp[j][a];\n            dp_prev[j][b] = dp[j][b];\n            dp_prev[a][j] = dp[a][j];\n            dp_prev[b][j] = dp[b][j];\n            \n        }\n    }\n    ll mul = binpow(2, q);\n    ll ans = 0;\n    owo(i, 0, n){\n        owo(j, i+1, n) {\n            ans= (ans + dp[i][j]);\n        }\n    }\n    ans = (ans*mul)%MOD;\n    cout<<ans<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = (int) 3e3;\n\n// Template-Libs\n\nnamespace MATH\n{\n\tinline int fpm(int x, int y)\n\t{\n\t\tint res = 1;\n\t\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\t\treturn res;\n\t}\n}\n\nusing MATH::fpm;\n\n// END\n\nint n, Q;\n\nint A[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), Q = read<int>();\n\tfor(int i = 1; i <= n; ++i) A[i] = read<int>();\n}\n\nint val[MAXN + 5], len = 0;\n\ninline void discrete()\n{\n\tfor(int i = 1; i <= n; ++i) val[++len] = A[i];\n\tsort(val + 1, val + len + 1), len = unique(val + 1, val + len + 1) - val - 1;\n\tfor(int i = 1; i <= n; ++i) A[i] = lower_bound(val + 1, val + len + 1, A[i]) - val;\n}\n\ninline void solve()\n{\n\tdiscrete();\n\n\tstatic int f[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) for(int j = i + 1; j <= n; ++j)\n\t{\n\t\tif(A[i] < A[j]) f[i][j] = 1;\n\t\tif(A[i] > A[j]) f[j][i] = 1;\n\t}\n\n\tstatic const int inv2 = (MOD + 1) / 2;\n\tfor(int k = 1; k <= Q; ++k)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\n\t\tstatic int res[MAXN + 5][MAXN + 5];\n\t\tfor(int i = 1; i <= n; ++i) res[i][u] = res[i][v] = res[u][i] = res[v][i] = 0;\n\n\t\tfor(int i = 1; i <= n; ++i) if(i != u && i != v)\n\t\t{\n\t\t\t(res[i][v] += (f[i][u] + f[i][v]) % MOD) %= MOD;\n\t\t\t(res[i][u] += (f[i][u] + f[i][v]) % MOD) %= MOD;\n\t\t\t(res[u][i] += (f[u][i] + f[v][i]) % MOD) %= MOD;\n\t\t\t(res[v][i] += (f[u][i] + f[v][i]) % MOD) %= MOD;\n\t\t}\n\t\tres[u][v] = res[v][u] = (f[u][v] + f[v][u]) % MOD;\n\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tf[i][u] = (LL) res[i][u] * inv2 % MOD;\n\t\t\tf[i][v] = (LL) res[i][v] * inv2 % MOD;\n\t\t\tf[u][i] = (LL) res[u][i] * inv2 % MOD;\n\t\t\tf[v][i] = (LL) res[v][i] * inv2 % MOD;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j < i; ++j) (ans += f[i][j]) %= MOD;\n\tans = (LL) ans * fpm(2, Q) % MOD;\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int MAXN = 3000;\nconst ll MOD = 1e9+7;\nconst ll two = 500000004;\n\nint N, Q, A[MAXN+10], X[MAXN+10], Y[MAXN+10];\nll dp[MAXN+10][MAXN+10], tmp[MAXN+10][MAXN+10], ans;\n\nint main()\n{\n    cin.tie(0); cout.tie(0);\n    ios_base::sync_with_stdio(false);\n    int i, j;\n\n    scanf(\"%d%d\", &N, &Q);\n    for(i=1; i<=N; i++) scanf(\"%d\", &A[i]);\n    for(i=1; i<=Q; i++) scanf(\"%d%d\", &X[i], &Y[i]);\n\n    for(i=1; i<=N; i++) for(j=1; j<=N; j++) if(A[i]>A[j]) dp[i][j]=1;\n\n    for(i=1; i<=Q; i++)\n    {\n        tmp[X[i]][Y[i]]=tmp[Y[i]][X[i]]=two*(dp[X[i]][Y[i]]+dp[Y[i]][X[i]])%MOD;\n        for(j=1; j<=N; j++)\n        {\n            if(j==X[i] || j==Y[i]) continue;\n            tmp[j][Y[i]]=two*(dp[j][Y[i]]+dp[j][X[i]])%MOD;\n            tmp[Y[i]][j]=two*(dp[Y[i]][j]+dp[X[i]][j])%MOD;\n            tmp[X[i]][j]=two*(dp[X[i]][j]+dp[Y[i]][j])%MOD;\n            tmp[j][X[i]]=two*(dp[j][X[i]]+dp[j][Y[i]])%MOD;\n        }\n\n        for(j=1; j<=N; j++)\n        {\n            dp[j][X[i]]=tmp[j][X[i]];\n            dp[X[i]][j]=tmp[X[i]][j];\n            dp[j][Y[i]]=tmp[j][Y[i]];\n            dp[Y[i]][j]=tmp[Y[i]][j];\n        }\n    }\n\n    for(i=1; i<=N; i++) for(j=i+1; j<=N; j++) ans=(ans+dp[i][j])%MOD;\n    for(i=1; i<=Q; i++) ans=(ans*2)%MOD;\n\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3003\n#define P 1000000007\nusing namespace std;\nint n,q,a[N],f[N][N];\nstruct upd{int x,y,z;};\nupd pkg(int x,int y,int z){\n    upd res;\n    res.x=x,res.y=y,res.z=z;\n    return res;\n}\nqueue <upd> Q;\nbool b[N][N];\nint pow(int x,int y){\n    int res=1;\n    for(;y;y>>=1,x=1LL*x*x%P)\n        if(y&1)res=1LL*res*x%P;\n    return res;\n}\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=n;++j)f[i][j]=a[i]>a[j];\n    int tot=pow(2,q),inv=pow(2,P-2);\n    while(q--){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        for(int i=1;i<=n;++i)\n            if(i!=x && i!=y){\n                Q.push(pkg(i,x,(int)(1LL*(f[i][x]+f[i][y])*inv%P)));\n                Q.push(pkg(x,i,(int)(1LL*(f[x][i]+f[y][i])*inv%P)));\n                Q.push(pkg(i,y,(int)(1LL*(f[i][y]+f[i][x])*inv%P)));\n                Q.push(pkg(y,i,(int)(1LL*(f[y][i]+f[x][i])*inv%P)));\n            }\n        Q.push(pkg(x,y,(int)(1LL*(f[x][y]+f[y][x])*inv%P)));\n        Q.push(pkg(y,x,(int)(1LL*(f[y][x]+f[x][y])*inv%P)));\n        while(!Q.empty()){\n            upd cur=Q.front();\n            f[cur.x][cur.y]=cur.z;\n            Q.pop();\n        }\n    }\n    int ans=0;\n    for(int i=1;i<n;++i)\n        for(int j=i+1;j<=n;++j){\n            ans+=1LL*f[i][j]*tot%P;\n            if(ans>=P)ans-=P;\n        }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 3033, mod = 1000000007;\n\nint n, q, a[max_n], dp[max_n][max_n], last[max_n][max_n], ndp[max_n][max_n];\nint t, last_updated[max_n][max_n];\nint pw[max_n];\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint get(int i, int a, int b) {\n    if (a == b) {\n        return 0;\n    }\n    return mul(dp[a][b], pw[i - last[a][b]]);\n}\n\nvoid push(int i, int a, int b) {\n    if (i < last[a][b]) {\n        return;\n    }\n    dp[a][b] = get(i, a, b);\n    last[a][b] = i + 1;\n}\n\nvoid upd(int a, int b) {\n    if (a == b) {\n        return;\n    }\n    if (last_updated[a][b] < t) {\n        last_updated[a][b] = t;\n        dp[a][b] += ndp[a][b];\n        if (dp[a][b] >= mod) {\n            dp[a][b] -= mod;\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d%d\", &n, &q);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n    pw[0] = 1;\n    for (int i = 1; i < max_n; ++i) {\n        pw[i] = (2 * pw[i - 1]) % mod;\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = (a[i] > a[j]);\n        }\n    }\n    for (int i = 0; i < q; ++i) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        --x;\n        --y;\n        for (int j = 0; j < n; ++j) {\n            ndp[x][j] = get(i, y, j);\n            ndp[y][j] = get(i, x, j);\n            ndp[j][x] = get(i, j, y);\n            ndp[j][y] = get(i, j, x);\n        }\n        ndp[x][y] = get(i, y, x);\n        ndp[y][x] = get(i, x, y);\n\n        for (int j = 0; j < n; ++j) {\n            push(i, x, j);\n            push(i, y, j);\n            push(i, j, x);\n            push(i, j, y);\n        }\n\n        ++t;\n        for (int j = 0; j < n; ++j) {\n            upd(x, j);\n            upd(y, j);\n            upd(j, x);\n            upd(j, y);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ans += get(q, i, j);\n            if (ans >= mod) {\n                ans -= mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void wri(ll a){write(a); putchar(' ');}\ninline void writeln(ll a){write(a); puts(\"\");}\nconst int N=3005,mod=1e9+7;\nconst ll inv=(mod+1)/2;\nint a[N],dp[N][N];\ninline void gao(int &a,int &b){\n\tint t=(a+b)*inv%mod;\n\ta=b=t;\n}\nsigned main(){\n\tint n=read(),q=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)dp[i][j]=a[i]>a[j];\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint x=read(),y=read();\n\t\tgao(dp[x][y],dp[y][x]);\n\t\tfor(int j=1;j<=n;j++)if(j!=x&&j!=y){\n\t\t\tgao(dp[x][j],dp[y][j]); gao(dp[j][x],dp[j][y]); \n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)ans=(ans+dp[i][j])%mod;\n\tfor(int i=1;i<=q;i++)ans=ans*2%mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc030/tasks/agc030_d\n\nNが小さいな…\n→ NC2のすべての組み合わせに関して、反転する場合は何通りあるか数える？\n→クエリの数を考えたら無理じゃね？\n\n各クエリを行った場合、全ての場合での反転数の合計はどうなるかをO(N)で求める？\n→わりとありそう\n→だとしたらdpっぽい\n\n反転数 = それより右にある小さい要素の数とする\n\n反転数をうまくdp式に縮められない…\n\nnum[i][j] = A[i] > A[j]となる通り数とする。(i < j なら反転数)\n\nindex xとyが交換される場合、全てのv(!=y)に関して\n\nnum[y][v] += num[x][v]\nnum[x][v] += num[y][v]\n\nnum[v][x] += num[v][y]\nnum[v][y] += num[v][x]\n\nnum[x][y] += num[y][x]\nnum[y][x] += num[x][y]\n\n更新は高々4*3000\nなので、C++なら可能？\n\nいじらない部分は2倍する操作が必要。\n最後にまとめて処理するために、いじった部分は半分にしておく\n\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 1000000007;\nconst ll half = 500000004;\n\nint main(){\n\n    ll N,Q;\n    cin >> N >> Q;\n    vector<ll> A(N,0);\n\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<vector<ll>> lis(N,vector<ll> (N,0));\n    rep(i,0,N){\n        rep(j,0,N){\n            if (A[i] > A[j]) lis[i][j] = 1;\n        }\n    }\n\n    rep(loop,0,Q){\n\n        vector<vector<ll>> q(5*N,vector<ll> (3,0));\n        ll qind = 0;\n        ll x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n\n        rep(v,0,N){\n            if ((v != x) && (v != y)){\n                q[qind++] = {y,v,lis[x][v]};\n                q[qind++] = {x,v,lis[y][v]};\n                q[qind++] = {v,y,lis[v][x]};\n                q[qind++] = {v,x,lis[v][y]}; \n            }\n        }\n\n        q[qind++] = {x,y,lis[y][x]};\n        q[qind++] = {y,x,lis[x][y]};\n\n        rep(t,0,qind){\n            ll i,j,n;\n            i = q[t][0];\n            j = q[t][1];\n            n = q[t][2];\n\n            lis[i][j] += n;\n            lis[i][j] *= half;\n            lis[i][j] %= mod;\n        }\n    }\n\n    ll ans = 0;\n    rep(j,0,N){\n        rep(i,0,j){\n            ans += lis[i][j];\n            ans %= mod;\n        }\n    }\n\n    rep(i,0,Q){\n        ans *= 2;\n        ans %= mod;\n    }\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nconst int N = 3200;\nlong long f[N][N];\nlong long inv2;\nint n,q,a[N];\nlong long power(long long x,int k){\n\tlong long ans=1;\n\twhile(k){\n\t\tif(k&1)(ans*=x)%=P;\n\t\t(x*=x)%=P;\n\t\tk>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tinv2=power(2,P-2);\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tif(a[i]==a[j])continue;\n\t\t\tif(a[i]<a[j])f[i][j]++;\n\t\t\tif(a[j]<a[i])f[j][i]++;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==y)continue;\n\t\tlong long tmp=(f[x][y]+f[y][x])*inv2%P;\n\t\tf[x][y]=tmp;\n\t\tf[y][x]=tmp;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x||i==y)continue;\n\t\t\tlong long tmp=(f[x][i]+f[y][i])*inv2%P;\n\t\t\tf[x][i]=tmp;\n\t\t\tf[y][i]=tmp;\n\t\t\ttmp=(f[i][x]+f[i][y])*inv2%P;\n\t\t\tf[i][x]=tmp;\n\t\t\tf[i][y]=tmp;\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)(ans+=f[i][j])%=P;\n\tcout << ans*power(2,q)%P << endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 3e3 + 10;\nconst int rev2 = (MOD + 1) / 2;\n\nint n, m;\nint f[N][N];\nint a[N];\n\nint main() {\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) cin >> a[i];\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++) f[i][j] = (a[i] > a[j]);\n    for(int i = 1; i <= m; i++){\n        int x, y;\n        cin >> x >> y;\n        for(int z = 1; z <= n; z++) if (z != x && z != y) {\n            f[x][z] = f[y][z] = 1LL * (f[x][z] + f[y][z]) * rev2 % MOD;\n            f[z][x] = f[z][y] = 1LL * (f[z][x] + f[z][y]) * rev2 % MOD;\n        }\n        f[x][y] = f[y][x] = 1LL * (f[x][y] + f[y][x]) * rev2 % MOD;\n    }\n    long long ans = 0;\n    for(int i = 1; i <= n; i++)\n        for(int j = i + 1; j <= n; j++) ans = (ans + f[i][j]) % MOD;\n    for(int i = 1; i <= m; i++) ans = (ans * 2) % MOD;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll P=1e9+7,V=(P+1)>>1;\nconst int N=3005;\nint n,q,a[N]; ll f[N][N],g[N][N],ans,s=1;\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++){\n\t\tf[i][j]=(a[i]<a[j]); g[i][j]=(a[i]>a[j]);\n\t}\n\twhile(q--){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*V%P;\n\t\tg[x][y]=g[y][x]=(g[x][y]+g[y][x])*V%P;\n\t\tfor(int i=1;i<=n;i++) if(i!=x && i!=y){\n\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])*V%P;\n\t\t\tg[x][i]=g[y][i]=(g[x][i]+g[y][i])*V%P;\n\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*V%P;\n\t\t\tg[i][x]=g[i][y]=(g[i][x]+g[i][y])*V%P;\n\t\t}\n\t\t(s*=2)%=P;\n\t}\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) (ans+=g[i][j])%=P;\n\tcout<<ans*s%P<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nconst int mod = 1000000007;\n\nint now[3333][3333];\nint pre[3333][3333];\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> a(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif(a[i] < a[j]) {\n\t\t\t\tnow[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow[i][j] = 0;\n\t\t\t}\n\t\t\tpre[i][j] = -1;\n\t\t}\n\t}\n\tvector<int> kai(q + 10);\n\tint nw = 1;\n\trep(i, q + 9) {\n\t\tkai[i + 1] = nw;\n\t\tnw = nw * 2 % mod;\n\t}\n\trep(i, q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tvector<pair<int, pair<int, int>>> q;\n\t\trep(j, n) {\n\t\t\tif(j != x && j != y) {\n\t\t\t\tq.push_back(make_pair(now[i][x] * kai[i - pre[i][x]], make_pair(i, y)));\n\t\t\t\tq.push_back(make_pair(now[i][y] * kai[i - pre[i][y]], make_pair(i, x)));\n\t\t\t\tq.push_back(make_pair(now[x][i] * kai[i - pre[x][i]], make_pair(y, i)));\n\t\t\t\tq.push_back(make_pair(now[y][i] * kai[i - pre[y][i]], make_pair(x, i)));\n\t\t\t}\n\t\t}\n\t\tq.push_back(make_pair(now[x][x] * kai[i - pre[x][x]], make_pair(y, y)));\n\t\tq.push_back(make_pair(now[x][y] * kai[i - pre[x][y]], make_pair(y, x)));\n\t\tq.push_back(make_pair(now[y][x] * kai[i - pre[y][x]], make_pair(x, y)));\n\t\tq.push_back(make_pair(now[y][y] * kai[i - pre[y][y]], make_pair(x, x)));\n\t\tfor(auto j: q) {\n\t\t\tnow[j.second.first][j.second.second] = (now[j.second.first][j.second.second] * kai[i - pre[j.second.first][j.second.second]] + j.first) % mod;\n\t\t\tpre[j.second.first][j.second.second] = i;\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tans = (ans + now[i][j] * kai[q - pre[i][j]]) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n// 217\n// 44\n\nusing namespace std;\n\nconst int MOD = (int) 1e9 + 7;\nconst int MAXN = 3000;\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1) {\n            ans = (1LL * ans * a) % MOD;\n        }\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\nint arr[MAXN + 1];\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n}\n\nint dp[MAXN + 1][MAXN + 1], aux[MAXN + 1][MAXN + 1];\nint last[MAXN + 1][MAXN + 1], p2[MAXN + 1], now;\n\ninline void add(int l1, int c1, int l2, int c2) {\n    if(last[l1][c1] < now) {\n        dp[l1][c1] += aux[l1][c1];\n        mod(dp[l1][c1]);\n        aux[l1][c1] = 0;\n        dp[l1][c1] = (1LL * dp[l1][c1] * p2[now - last[l1][c1] - 1]) % MOD;\n        last[l1][c1] = now;\n    }\n    if(last[l2][c2] < now) {\n        dp[l2][c2] += aux[l2][c2];\n        mod(dp[l2][c2]);\n        aux[l2][c2] = 0;\n        dp[l2][c2] = (1LL * dp[l2][c2] * p2[now - last[l2][c2] - 1]) % MOD;\n        last[l2][c2] = now;\n    }\n    aux[l2][c2] += dp[l1][c1];\n    mod(aux[l2][c2]);\n}\n\nint main() {\n    //ifstream cin(\"A.in\");\n    //ofstream cout(\"A.out\");\n    int i, j, n, q;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> q;\n    for(i = 1; i <= n; i++) {\n        cin >> arr[i];\n    }\n    for(i = 1; i <= n; i++) {\n        for(j = 1; j <= n; j++) {\n            dp[i][j] = (arr[i] > arr[j]);\n        }\n    }\n    p2[0] = 1;\n    for(i = 1; i <= q; i++) {\n        p2[i] = p2[i - 1] * 2;\n        mod(p2[i]);\n    }\n    while(q > 0) {\n        q--;\n        int x, y;\n        cin >> x >> y;\n        now++;\n        for(i = 1; i <= n; i++) {\n            if(i != x && i != y) {\n                add(x, i, y, i);\n                add(i, x, i, y);\n                add(y, i, x, i);\n                add(i, y, i, x);\n            }\n        }\n        add(x, y, y, x);\n        add(y, x, x, y);\n    }\n    int ans = 0;\n    for(i = 1; i <= n; i++) {\n        for(j = i + 1; j <= n; j++) {\n            dp[i][j] += aux[i][j];\n            mod(dp[i][j]);\n            dp[i][j] = (1LL * dp[i][j] * p2[now - last[i][j]]) % MOD;\n            ans += dp[i][j];\n            mod(ans);\n        }\n    }\n    cout << ans;\n    //cin.close();\n    //cout.close();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nll Power(ll x,ll k)\n{\n\tx%=mod;\n\tll sss=1;\n\twhile (k)\n\t{\n\t\tif (k%2) sss=sss*x%mod;\n\t\tx=x*x%mod;\n\t\tk/=2;\n\t}\n\treturn sss;\n}\nll ny(ll x){return Power(x,mod-2);}\nint n,q;\nll f[4030][4030];\nll ans;\nll a[5030],b[5][5030];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) if (a[i]>a[j]) f[i][j]=1;\n\n\tint x,y; ll doe=ny(2);\n\tfor (int i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tfor (int j=1;j<=n;++j) \n\t\t{\n\t\t\tb[0][j]=f[j][x];\n\t\t\tb[1][j]=f[x][j];\n\t\t\tb[2][j]=f[j][y];\n\t\t\tb[3][j]=f[y][j];\n\t\t}\n\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) (f[j][y]+=b[0][j])%=mod;\n\t\t\tif (j!=x) (f[y][j]+=b[1][j])%=mod;\n\t\t\tif (j!=y) (f[j][x]+=b[2][j])%=mod; \n\t\t\tif (j!=y) (f[x][j]+=b[3][j])%=mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) f[j][y]=f[j][y]*doe%mod;\n\t\t\tif (j!=x) f[y][j]=f[y][j]*doe%mod;\n\t\t\tif (j!=y) f[j][x]=f[j][x]*doe%mod;\n\t\t\tif (j!=y) f[x][j]=f[x][j]*doe%mod;\n\t\t}\n\t\tll A=f[x][y],B=f[y][x];\n\t\tf[y][x]+=A; f[x][y]+=B;\n\t\tf[x][y]=f[x][y]*doe%mod; \n\t\tf[y][x]=f[y][x]*doe%mod;\n\t}\n/*\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",f[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n;++j) (ans+=f[i][j])%=mod;\n\tans=ans*Power(2,q)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=3030,P=1e9+7,iv2=(P+1)>>1;\nint n,Q,x,y,ans,a[N],f[N][N],g[N][N];\nint qpw(int x,int y){int z=1;for(;y;y>>=1,x=1ll*x*x%P)if(y&1) z=1ll*z*x%P;return z;}\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\tFOR(i,1,n) scanf(\"%d\",&a[i]);\n\tFOR(i,1,n)FOR(j,i+1,n) f[i][j]=a[i]>a[j],g[i][j]=a[i]==a[j];\n\tFOR(p,1,Q){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tf[x][y]=1ll*(1-g[x][y]+P)%P*iv2%P;\n\t\tFOR(i,1,x-1){\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])%P*iv2%P;\n\t\t\tg[i][x]=g[i][y]=1ll*(g[i][x]+g[i][y])%P*iv2%P;\n\t\t}\n\t\tFOR(i,x+1,y-1){\n\t\t\tint u=f[x][i],v=f[i][y],a=g[x][i],b=g[i][y];\n\t\t\tf[x][i]=1ll*(u+((1-v+P)%P-b+P)%P)%P*iv2%P;\n\t\t\tf[i][y]=1ll*(v+((1-u+P)%P-a+P)%P)%P*iv2%P;\n\t\t\tg[x][i]=g[i][y]=1ll*(a+b)%P*iv2%P;\n\t\t}\n\t\tFOR(i,y+1,n){\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])%P*iv2%P;\n\t\t\tg[x][i]=g[y][i]=1ll*(g[x][i]+g[y][i])%P*iv2%P;\n\t\t}\n\t\t//FOR(i,1,n)FOR(j,1,n) cout<<f[i][j]<<char(j==n?'\\n':' ');\n\t}\n\tFOR(i,1,n)FOR(j,i+1,n) (ans+=f[i][j])%=P;\n\tans=1ll*ans*qpw(2,Q)%P;\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 3005, mod = 1000000007, i2 = mod + 1 >> 1;\ntypedef long long LL;\n\nint n, q, dp[N][N], tmp[N][N], x, y, A[N];\n\nvoid copy(int x, int y) { tmp[x][y] = dp[x][y]; }\nvoid update(int X, int Y) {\n\tint tx = X, ty = Y;\n\tif (tx == x) tx = y; else if (tx == y) tx = x;\n\tif (ty == x) ty = y; else if (ty == y) ty = x;\n\tdp[X][Y] = (LL) i2 * (tmp[X][Y] + tmp[tx][ty]) % mod;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> q;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tdp[i][j] = A[i] > A[j];\n\tfor (int i = 1; i <= q; ++i) {\n\t\tstd::cin >> x >> y;\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tcopy(x, j), copy(j, x), copy(y, j), copy(j, y);\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tupdate(x, j), update(j, x), update(y, j), update(j, y);\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tans += dp[i][j] - mod, ans += ans >> 31 & mod;\n\tfor (int i = 1; i <= q; ++i)\n\t\tans += ans - mod, ans += ans >> 31 & mod;\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9)+7>;\n\nconst int MAXN = 4000;\nconst int MAXQ = 4000;\nint N, Q;\nint A[MAXN];\nint X[MAXQ];\nint Y[MAXQ];\n\nnum prob[MAXN][MAXN]; // probability that a[i] < a[j]\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> Q;\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n\tfor (int q = 0; q < Q; q++) {\n\t\tcin >> X[q] >> Y[q];\n\t\tX[q]--, Y[q]--;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tprob[i][j] = (A[i] < A[j]);\n\t\t}\n\t}\n\tfor (int q = 0; q < Q; q++) {\n\t\tint x = X[q], y = Y[q];\n\t\tassert(x != y);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tprob[i][x] = prob[i][y] = (prob[i][x] + prob[i][y]) / 2;\n\t\t\tprob[x][i] = prob[y][i] = (prob[x][i] + prob[y][i]) / 2;\n\t\t}\n\t\tprob[x][x] = prob[y][y] = (prob[x][x] + prob[y][y]) / 2;\n\t\tprob[x][y] = prob[y][x] = (prob[x][y] + prob[y][x]) / 2;\n\t}\n\tnum ev = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tev += prob[i][j];\n\t\t}\n\t}\n\tfor (int q = 0; q < Q; q++) {\n\t\tev *= 2;\n\t}\n\tcout << ev << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n\tint x;\n\tModInt(): x(0) {}\n\tModInt(i64 a) { x = a % mod; if (x < 0) x += mod; }\n\tModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n\tModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n\tModInt &operator*=(ModInt that) { x = (i64) x * that.x % mod; return *this; }\n\tModInt &operator/=(ModInt that) { return *this *= power(that, mod - 2); }\n\t#define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n\t\top(+, +=) op(-, -=) op(*, *=) op(/, /=)\n\t#undef op\n\tfriend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n};\n\nusing mint = ModInt<1000000007>;\n\nmint dp[3010][3010];\n\nvoid solve() {\n\tint N, Q; cin >> N >> Q;\n\tvi32 a(N); cin >> a;\n\trep(i, N) rep(j, N) dp[i][j] = a[i] > a[j];\n\trep(j, Q) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\trep(i, N) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * 500000004;\n\t\t\tdp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * 500000004;\n\t\t}\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * 500000004;\n\t}\n\tmint ans = 0;\n\trep(j, N) rep(i, j) ans += dp[i][j];\n\tans = ans * power((mint) 2, Q);\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for (ll i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nlong long inv_mod(long long n, long long mod) {\n    long long a = n % mod, b = mod - 2, ret = 1;\n    while (b > 0) {\n        if (b & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nconst ll MOD = 1000000007LL;\nll N,Q;\nll A[3010];\nll X[3010];\nll Y[3010];\n\nll dp[3010][3010];\n\nint main ()\n{\n    cin >> N >> Q;\n    REP(i,N) cin >> A[i];\n    REP(i,Q) cin >> X[i] >> Y[i];\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = (A[i] > A[j]);\n        }\n    }\n\n    ll inv2 = inv_mod(2LL, MOD);\n    for (int i = 0; i < Q; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (X[i] != j && Y[i] != j) {\n                dp[X[i]][j] = dp[Y[i]][j] = ((dp[X[i]][j] + dp[Y[i]][j]) * inv2 % MOD);\n                dp[j][X[i]] = dp[j][Y[i]] = ((dp[j][X[i]] + dp[j][Y[i]]) * inv2 % MOD);\n            }\n        }\n        dp[X[i]][Y[i]] = dp[Y[i]][X[i]] = ((dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv2 % MOD);\n    }\n\n    ll ans = 0;\n    ll per = pow_mod(2LL, Q, MOD);\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            ans += dp[i][j] * per;\n            ans %= MOD;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define CHECK cout << \"ok\" << endl\n#define finish(x) return cout << x << endl, 0\ntypedef long long ll;\ntypedef long double ldb;\nconst int md = 1e9 + 7, inf = 1e9 + 7;\nusing namespace std;\n\nvoid debug(string names) {\n\tcout << '\\n';\n}\ntemplate<typename A1, typename... A2>\nvoid debug(string names, A1 par, A2... left) {\n\tint pos = 0;\n\tfor (; pos < names.size() && names[pos] != ' ' && names[pos] != ','; pos++)\n\t\tcout << names[pos];\n\tcout << \": \" << par << \"  \";\n\twhile (pos < names.size() && (names[pos] == ' ' || names[pos] == ',')) {\n\t\tpos++;\n\t}\n\tnames.erase(names.begin(), names.begin() + pos);\n\tdebug(names, left...);\n}\n\nconst ll I = (md + 1) / 2;\n\nint n, q;\nint G[3003][3003] = {}, E[3003][3003] = {}, L[3003][3003] = {}, cnt[3003] = {};\nvector<int> a;\nll ans = 0;\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tcin >> n >> q;\n\ta.resize(n);\n\tfor (auto &i : a) cin >> i;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) {\n\t\tif (a[i] < a[j]) L[i][j] = 1;\n\t\telse if (a[i] == a[j]) E[i][j] = 1;\n\t\telse G[i][j] = 1;\n\t}\n\tfor (int i = 0, u, v; i < q; i++) {\n\t\tcin >> u >> v, --u, --v;\n\t\tif (u > v) swap(u, v);\n\t\tint g, e, l;\n\t\tg = G[u][v], e = E[u][v], l = L[u][v];\n\t\tG[u][v] = I * (g + l) % md;\n\t\tL[u][v] = I * (l + g) % md;\n\t\tfor (int st = 0; st < u; st++) {\n\t\t\tG[st][v] = G[st][u] = I * (G[st][u] + G[st][v]) % md;\n\t\t\tE[st][v] = E[st][u] = I * (E[st][u] + E[st][v]) % md;\n\t\t\tL[st][v] = L[st][u] = I * (L[st][u] + L[st][v]) % md;\n\t\t}\n\t\tfor (int st = u + 1; st < v; st++) {\n\t\t\tL[st][v] = G[u][st] = I * (G[u][st] + L[st][v]) % md;\n\t\t\tL[u][st] = G[st][v] = I * (G[st][v] + L[u][st]) % md;\n\t\t\tE[st][v] = E[u][st] = I * (E[u][st] + E[st][v]) % md;\n\t\t}\n\t\tfor (int st = v + 1; st < n; st++) {\n\t\t\tG[v][st] = G[u][st] = I * (G[u][st] + G[v][st]) % md;\n\t\t\tE[v][st] = E[u][st] = I * (E[u][st] + E[v][st]) % md;\n\t\t\tL[v][st] = L[u][st] = I * (L[u][st] + L[v][st]) % md;\n\t\t}\n\t}\n\tll mult = 1;\n\tfor (int i = 0; i < q; i++) mult = 2 * mult % md;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) {\n\t\tG[i][j] = G[i][j] * mult % md;\n\t\tE[i][j] = E[i][j] * mult % md;\n\t\tL[i][j] = L[i][j] * mult % md;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++)\n\t\tans = (ans + G[i][j]) % md;\n\tfinish(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll inv[1000000];\nll FactorialInv[1000000];\nll Factorial[1000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    for(int i = 2; i < 1000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\nll dp[3005][3005];\nll A[3005];\n\nint main() {\n    //cout.precision(10);\n    init_combination();\n    ll N, Q;\n    cin >> N >> Q;\n    for(int i = 1; i <= N; i++) {\n        cin >> A[i];\n    }\n    for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= N; j++) {\n            if(A[i] > A[j]) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for(int TIME = 1; TIME <= Q; TIME++) {\n        ll X, Y;\n        cin >> X >> Y;\n        ll tmp = (dp[X][Y] + dp[Y][X]) * inv[2] % mod;\n        dp[X][Y] = tmp;\n        dp[Y][X] = tmp;\n        for(int index = 1; index <= N; index++) {\n            if(index == X || index == Y) continue;\n            tmp = (dp[index][X] + dp[index][Y]) * inv[2] % mod;\n            dp[index][X] = tmp;\n            dp[index][Y] = tmp;\n            tmp = (dp[X][index] + dp[Y][index]) * inv[2] % mod;\n            dp[X][index] = tmp;\n            dp[Y][index] = tmp;\n        }\n    }\n    ll ans = 0;\n    for(int i = 1; i <= N; i++) {\n        for(int j = i + 1; j <= N; j++) {\n            ans = (ans + dp[i][j]) % mod;\n        }\n    }\n    for(int i = 1; i <= Q; i++) {\n        ans = ans * 2 % mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007,inv2=500000004;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint n,q,a[3030],x[3030],y[3030],dp[3030][3030],tmp[3030][3030],ans;\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=q;++i)scanf(\"%d %d\",&x[i],&y[i]);\n\tfor(int i=1;i<=n;++i)for(int j=1;j<i;++j)dp[i][j]=1;\n\tfor(int i=q;i;--i)\n\t{\n\t\tint tmp;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tdp[x[i]][j]=dp[y[i]][j]=1ll*(dp[x[i]][j]+dp[y[i]][j])*inv2%mod;\n\t\t\t\tdp[j][x[i]]=dp[j][y[i]]=1ll*(dp[j][x[i]]+dp[j][y[i]])*inv2%mod;\n\t\t\t}\n\t\tdp[x[i]][y[i]]=dp[y[i]][x[i]]=1ll*(dp[x[i]][y[i]]+dp[y[i]][x[i]])*inv2%mod;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(a[i]<a[j])add(ans,dp[i][j]);\n\tfor(int i=1;i<=q;++i)add(ans,ans);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 3005\nint nex[MN][MN],lst[MN];\nunordered_map<int,int> dp[MN][MN];\nint a[MN];\nint k1[MN],k2[MN];\nint n,q;\nint main(){\n\tread(n);read(q);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tread(k1[i]);read(k2[i]);\n\t\tnex[k1[i]][lst[k1[i]]]=i;lst[k1[i]]=i;\n\t\tnex[k2[i]][lst[k2[i]]]=i;lst[k2[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)nex[i][lst[i]]=q+1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=q;++j)nex[i][j]=nex[i][j]?nex[i][j]:nex[i][j-1];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(a[i]<a[j])++dp[1][i][j];\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tfor(auto K:dp[i][j]){\n\t\t\t\tint k=K.ft,v=K.sd;\n\t\t\t\tint N=min(nex[j][i],nex[k][i]);\n\t\t\t\tdp[N][j][k]+=v;\n\t\t\t\tint jj=j,kk=k;\n\t\t\t\tif(jj==k1[i])jj=k2[i];else if(jj==k2[i])jj=k1[i];\n\t\t\t\tif(kk==k1[i])kk=k2[i];else if(kk==k2[i])kk=k1[i];\n\t\t\t\tdp[N][jj][kk]+=v;\n\t\t\t}\n\t\t}\n\t}\n\tlg res=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(auto K:dp[q+1][i]){\n\t\t\tif(K.ft>i)res+=K.sd;\n\t\t}\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// contancer library\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\n\ntemplate <class K, class T>\nostream& operator<<(ostream& os, map<K, T> v) {\n    os << \"{\";\n    for (auto vv : v) os << vv << \",\";\n    return os << \"}\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, queue<T> q) {\n    os << \"[\";\n    while (!q.empty()) {\n        os << q.front() << \",\";\n        q.pop();\n    }\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, priority_queue<T> q) {\n    os << \"{\";\n    while (!q.empty()) {\n        os << q.top() << \",\";\n        q.pop();\n    }\n    return os << \"}\";\n}\n\nconst ll MOD = 1000000007;\n// const ll MOD = 998244353;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const ld PI = acos(-1);\n// const ld EPS = 1e-10;\n// mt19937 mt(ll(time(0)));\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <typename T>\ninline T sq(T a) { return a * a; }\n\ntemplate <typename T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T, typename U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nT mpow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret = ret * b % MOD;\n        n >>= 1;\n        b = b * b % MOD;\n    }\n    return ret;\n}\n\nconst ll inv2 = mpow(2LL, MOD - 2);\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    auto A = Vec<int>(N, 0);\n    for (int& a : A) cin >> a;\n\n    auto dp = Vec<ll>(N, N, 0LL);\n    // i番目がj番目より大きい確率\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = (A[i] > A[j] ? 1 : 0);\n        }\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        for (int k = 0; k < N; ++k) {\n            if (k == x || k == y) continue;\n            dp[k][x] += dp[k][y];\n            if (dp[k][x] & 1) {\n                dp[k][x] = dp[k][x] * inv2 % MOD;\n            } else {\n                dp[k][x] /= 2;\n            }\n            dp[k][y] = dp[k][x];\n\n            dp[x][k] += dp[y][k];\n            if (dp[x][k] & 1) {\n                dp[x][k] = dp[x][k] * inv2 % MOD;\n            } else {\n                dp[x][k] /= 2;\n            }\n            dp[y][k] = dp[x][k];\n        }\n\n        dp[x][y] += dp[y][x];\n        if (dp[x][y] & 1) {\n            dp[x][y] = dp[x][y] * inv2 % MOD;\n        } else {\n            dp[x][y] /= 2;\n        }\n        dp[y][x] = dp[x][y];\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << ans % MOD * mpow(2LL, Q) % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005;\nconst long long mod = 1000000007ll, inv2 = mod + 1 >> 1;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, q, a[N];\nlong long f[N][N], ans = 0ll;\n\nint main () {\n\tread(n), read(q);\n\tfor (int i = 1; i <= n; i++) read(a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tf[i][j] = a[i] > a[j] ? 1ll : 0ll;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= q; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tf[x][y] = f[y][x] = (f[x][y] + f[y][x]) % mod * inv2 % mod;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tf[j][x] = f[j][y] = (f[j][x] + f[j][y]) % mod * inv2 % mod;\n\t\t\t\tf[x][j] = f[y][j] = (f[x][j] + f[y][j]) % mod * inv2 % mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) ans = (ans + f[i][j]) % mod;\n\t}\n\tfor (int i = 1; i <= q; i++) ans = ans * 2ll % mod;\n\twrite(ans), putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst int maxn=3111;\nconst int mod=1e9+7;\nint qpow(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(LL)ret*x%mod;\n\t\tx=(LL)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\ninline void add(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nint n,q,a[maxn],w[maxn][maxn];\n\nvoid do_swap(int u,int v)\n{\n\tif(u>v)swap(u,v);\n\t\n\tint tmp=(LL)(w[u][v]+w[v][u])*(mod+1)/2%mod;\n\tw[u][v]=w[v][u]=tmp;\n\t\n\tfor(int i=1;i<=n;i++)if(i!=u&&i!=v)\n\t{\n\t\tint tmp;\n\t\ttmp=(LL)(w[i][u]+w[i][v])*(mod+1)/2%mod;\n\t\tw[i][u]=w[i][v]=tmp;\n\t\t\n\t\ttmp=(LL)(w[u][i]+w[v][i])*(mod+1)/2%mod;\n\t\tw[u][i]=w[v][i]=tmp;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\t\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(a[i]>a[j])w[i][j]=1;\n\t\n\tfor(int i=1,x,y;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdo_swap(x,y);\n\t}\n\t\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)add(ans,w[i][j]);\n\tans=(LL)ans*qpow(2,q)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const i64 mod = 1'000'000'007;\n    i64 N,Q;\n    cin >> N >> Q;\n\n    if(max(Q*N*N,N*N*N)>=100000000){\n        assert(false);\n    }\n\n    vector<i64> A(N);\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<i64> X(Q),Y(Q);\n    rep(i,0,Q){\n        cin >> X[i] >> Y[i];\n        --X[i];\n        --Y[i];\n    }\n\n    vector<pair<i64,i64>> vi;\n    rep(i,0,N){\n        vi.push_back(make_pair(A[i],i));\n    }\n    sort(rbegin(vi),rend(vi));\n\n    i64 ans=0;\n    for(auto p:vi){\n        i64 Ai=p.first,i=p.second;\n\n        const i64 size=3000;\n        static i64 dp[size][size];\n        fill_n((i64*)dp,size*size,0);\n        rep(j,0,N){\n            if(A[j]<=Ai) continue;\n            ++dp[j][i];\n        }\n\n        rep(j,0,Q){\n            i64 x=X[j],y=Y[j];\n            i64 tmpxy=dp[x][y],tmpyx=dp[y][x];\n            rep(k,0,N){\n                if(k==x or k==y) continue;\n                rep(l,0,N){\n                    if(l==x or l==y) continue;\n                    dp[k][l]*=2;\n                    dp[k][l]%=mod;\n                }\n            }\n\n            vector<i64> xk(N),kx(N),yk(N),ky(N);\n            rep(k,0,N){\n                xk[k]=dp[x][k];\n                kx[k]=dp[k][x];\n                yk[k]=dp[y][k];\n                ky[k]=dp[k][y];\n            }\n            rep(k,0,N){\n                if(k==x) continue;\n                dp[x][k]+=yk[k];\n                dp[x][k]%=mod;\n                dp[k][x]+=ky[k];\n                dp[k][x]%=mod;\n            }\n\n            rep(k,0,N){\n                if(k==y) continue;\n                dp[y][k]+=xk[k];\n                dp[y][k]%=mod;\n                dp[k][y]+=kx[k];\n                dp[k][y]%=mod;\n            }\n\n            dp[y][x]+=tmpxy;\n            dp[y][x]%=mod;\n            dp[x][y]+=tmpyx;\n            dp[x][y]%=mod;\n        }\n\n        rep(j,0,N){\n            rep(k,j+1,N){\n                ans+=dp[j][k];\n                ans%=mod;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<functional>\n#include<cmath>\n#include<vector>\n#include<assert.h>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nvoid open2(const char *s){\n#ifdef DEBUG\n    char str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst int N=3010;\nconst ll p=1000000007;\nll fp(ll a,ll b)\n{\n    ll s=1;\n    for(;b;b>>=1,a=a*a%p)\n        if(b&1)\n            s=s*a%p;\n    return s;\n}\nconst ll inv2=fp(2,p-2);\nint a[N];\nint n,q;\nll f[N][N];\nint main()\n{\n    open2(\"d\");\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(a[i]<a[j])\n                f[i][j]=1;\n    int x,y;\n    for(int i=1;i<=q;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        f[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n        for(int j=1;j<=n;j++)\n            if(j!=x&&j!=y)\n            {\n                f[x][j]=f[y][j]=(f[x][j]+f[y][j])*inv2%p;\n                f[j][x]=f[j][y]=(f[j][x]+f[j][y])*inv2%p;\n            }\n    }\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            ans=(ans+f[i][j])%p;\n    ans=ans*fp(2,q)%p;\n    ans=(ans%p+p)%p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define half 500000004\nint a[3005];\nlong long dp[3005][3005];\nint main()\n{\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tlong long cnt=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tfor (int j=1;j<i;j++)\n\t\t{\n\t\t\tif (a[j]>a[i])\n\t\t\tdp[j][i]=1;\n\t\t\tif (a[j]==a[i])\n\t\t\t{\n\t\t\t\tdp[j][i]=half;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int _=0;_<q;_++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif (a>b)\n\t\tswap(a,b);\n\t\tvector<pair<pair<int,int>,long long> > upd;\n\t\tfor (int i=1;i<a;i++)\n\t\tupd.push_back({{i,a},dp[i][b]});\n\t\tfor (int i=a+1;i<b;i++)\n\t\tupd.push_back({{a,i},(1-dp[i][b]+mod)%mod});\n\t\tfor (int i=b+1;i<=n;i++)\n\t\tupd.push_back({{a,i},dp[b][i]});\n\t\tfor (int i=1;i<a;i++)\n\t\tupd.push_back({{i,b},dp[i][a]});\n\t\tfor (int i=a+1;i<b;i++)\n\t\tupd.push_back({{i,b},(1-dp[a][i]+mod)%mod});\n\t\tfor (int i=b+1;i<=n;i++)\n\t\tupd.push_back({{b,i},dp[a][i]});\n\t\tfor (auto p:upd)\n\t\tdp[p.first.first][p.first.second]=half*(dp[p.first.first][p.first.second]+p.second)%mod;\n\t\tdp[a][b]=half;\n\t}\n\tint res=0,tmp=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=i+1;j<=n;j++)\n\t\tres=(res+dp[i][j])%mod;\n\t}\n\tfor (int i=0;i<q-1;i++)\n\ttmp=(tmp*2)%mod;\n\tprintf(\"%d\",(2LL*res*tmp%mod-cnt*tmp%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nconst int mod = 1000000007;\n\nint now[3333][3333];\nint pre[3333][3333];\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> a(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif(a[i] < a[j]) {\n\t\t\t\tnow[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow[i][j] = 0;\n\t\t\t}\n\t\t\tpre[i][j] = -1;\n\t\t}\n\t}\n\tvector<int> kai(q + 10);\n\tint nw = 1;\n\trep(i, q + 9) {\n\t\tkai[i + 1] = nw;\n\t\tnw = nw * 2 % mod;\n\t}\n\trep(i, q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tvector<pair<int, pair<int, int>>> q;\n\t\trep(j, n) {\n\t\t\tif(j != x && j != y) {\n\t\t\t\tq.push_back(make_pair(now[j][x] * kai[i - pre[j][x]], make_pair(j, y)));\n\t\t\t\tq.push_back(make_pair(now[j][y] * kai[i - pre[j][y]], make_pair(j, x)));\n\t\t\t\tq.push_back(make_pair(now[x][j] * kai[i - pre[x][j]], make_pair(y, j)));\n\t\t\t\tq.push_back(make_pair(now[y][j] * kai[i - pre[y][j]], make_pair(x, j)));\n\t\t\t}\n\t\t}\n\t\tq.push_back(make_pair(now[x][x] * kai[i - pre[x][x]], make_pair(y, y)));\n\t\tq.push_back(make_pair(now[x][y] * kai[i - pre[x][y]], make_pair(y, x)));\n\t\tq.push_back(make_pair(now[y][x] * kai[i - pre[y][x]], make_pair(x, y)));\n\t\tq.push_back(make_pair(now[y][y] * kai[i - pre[y][y]], make_pair(x, x)));\n\t\tfor(auto j: q) {\n\t\t\tnow[j.second.first][j.second.second] = (now[j.second.first][j.second.second] * kai[i - pre[j.second.first][j.second.second]] + j.first) % mod;\n\t\t\tpre[j.second.first][j.second.second] = i;\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tans = (ans + now[i][j] * kai[q - pre[i][j]]) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int mo = 1e9 + 7;\n\nll ksm(ll x, ll y) {\n\tll s = 1;\n\tfor(; y; y /= 2, x = x * x % mo)\n\t\tif(y & 1) s = s * x % mo;\n\treturn s;\n}\n\nconst ll ni2 = ksm(2, mo - 2);\n\nconst int N = 3005;\n\nint n, q, a[N], x[N], y[N];\nll f[N][N];\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\tfo(i, 1, n) scanf(\"%d\", &a[i]);\n\tfo(i, 1, n) fo(j, 1, n) f[i][j] = a[i] > a[j];\n\tfo(i, 1, q) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tfo(j, 1, n) if(j != x[i] && j != y[i]) {\n\t\t\tf[j][y[i]] = f[j][x[i]] = (f[j][y[i]] + f[j][x[i]]) * ni2 % mo;\n\t\t\tf[y[i]][j] = f[x[i]][j] = (f[y[i]][j] + f[x[i]][j]) * ni2 % mo;\n\t\t}\n\t\tf[x[i]][y[i]] = f[y[i]][x[i]] = (f[x[i]][y[i]] + f[y[i]][x[i]]) * ni2 % mo;\n\t}\n\tll w = ksm(2, q), ans = 0;\n\tfo(i, 1, n) fo(j, i + 1, n) ans = (ans + f[i][j] * w) % mo;\n\tpp(\"%lld\\n\", ans);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 5005;\n\nint n;\nchar str[MX], tar[MX];\n\nvoid input()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", str+1);\n\tscanf(\"%s\", tar+1);\n}\n\nvector<int> get_seq(char *s)\n{\n\tvector<int> ret;\n\tfor(int i=1; i<=n+1; i++)\n\t\tif(s[i] != s[i-1])\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint calc(vector<int> a, vector<int> b)\n{\n\tint ret = 0;\n\tfor(int i=1; i<=a.size()||i<=b.size(); i++)\n\t{\n\t\tint va = (i>a.size()) ? 1 : a[a.size()-i];\n\t\tint vb = (i>b.size()) ? 1 : b[b.size()-i];\n\t\tret += abs(va-vb);\n\t}\n\treturn ret;\n}\n\nvoid work()\n{\n\tint ans = 1e9;\n\tvector<int> s0 = get_seq(str), t0 = get_seq(tar), s, t;\n\tfor(int i=(str[n]!=tar[n]); i<=s0.size(); i+=2)\n\t{\n\t\ts = s0, t = t0;\n\t\tfor(int j=1; j<=i; j++) s.push_back(n+1);\n\t\tans = min(calc(s, t), ans);\n\n\t\ts = s0, t = t0;\n\t\tint tmp = 0;\n\t\tfor(int j=1; j<=i; j++) tmp += abs(n+1-s.back()), s.pop_back();\n\t\t/*reverse(s.begin(), s.end());\n\t\treverse(t.begin(), t.end());\n\t\tfor(auto &x : s) x = n+2-x;\n\t\tfor(auto &x : t) x = n+2-x;\n\t\tfor(int j=1; j<=i; j++) s.push_back(n+1);*/\n\t\tans = min(calc(s, t)+tmp, ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\nstruct range {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_) noexcept : i(i_) { }\n    constexpr void operator ++ () noexcept { ++i; }\n    constexpr itr operator * () const noexcept { return i; }\n    constexpr bool operator != (iterator x) const noexcept { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr range(itr l_, itr r_) noexcept : l(l_), r(std::max(l_, r_)) { }\n  constexpr iterator begin() const noexcept { return l; }\n  constexpr iterator end() const noexcept { return r; }\n};\n\nstruct revrange {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_) noexcept : i(i_) { }\n    constexpr void operator ++ () noexcept { --i; }\n    constexpr itr operator * () const noexcept { return i; }\n    constexpr bool operator != (iterator x) const noexcept { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr revrange(itr l_, itr r_) noexcept : l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr iterator begin() const noexcept { return r; }\n  constexpr iterator end() const noexcept { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type get_mod() { return mod; }\n  static_assert(mod >= 2, \"invalid mod :: smaller than 2\");\n  static_assert(mod < (value_type(1) << 31), \"invalid mod :: over 2^31\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type get() const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing m32 = modular<1000000007>;\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nclass propagation_array {\nprivate:\n  size_t count;\n  std::vector<std::vector<m32>> data;\n  std::vector<std::vector<size_t>> done;\n\n  void propagate(size_t i, size_t j) {\n    data[i][j] *= m32(2).power(count - done[i][j]);\n    done[i][j] = count;\n  }\n\npublic:\n  propagation_array(size_t size): \n    count(0), \n    data(size, std::vector<m32>(size)), \n    done(size, std::vector<size_t>(size)) \n  { }\n\n  void multiply() {\n    ++count;\n  }\n\n  void reduce(size_t i, size_t j) {\n    done[i][j] = std::min(done[i][j] + 1, count);\n    propagate(i, j);\n  }\n\n  m32& access(size_t i, size_t j) {\n    propagate(i, j);\n    return data[i][j];\n  }\n\n};\n\nint main() {\n  size_t N, Q;\n  std::cin >> N >> Q;\n  std::vector<i32> A(N);\n  for (auto &x: A) {\n    std::cin >> x;\n  }\n  /*\n    auto nvec = vec;\n    for (auto i: range(0, N)) {\n      std::swap(nvec[i][x], nvec[i][y]);\n    }\n    std::swap(nvec[x], nvec[y]);\n    for (auto i: range(0, N)) {\n      for (auto j: range(0, N)) {\n        vec[i][j] += nvec[i][j];\n      }\n    }\n  // */\n  m32 ans;\n  propagation_array invert(N);\n  for (auto i: range(0, N)) {\n    for (auto j: range(0, N)) {\n      if (A[i] < A[j]) {\n        invert.access(i, j) = m32(1);\n      }\n    }\n    for (auto j: range(0, i)) {\n      ans += invert.access(i, j);\n    }\n  }\n  while (Q--) {\n    size_t x, y;\n    std::cin >> x >> y;\n    --x; --y;\n    if (x > y) {\n      std::swap(x, y);\n    }\n    m32 increase = ans;\n    for (auto i: range(x + 1, y)) {\n      increase += invert.access(i, y);\n      increase -= invert.access(i, x);\n    }\n    for (auto j: range(x + 1, y + 1)) {\n      increase += invert.access(x, j);\n    }\n    for (auto j: range(x, y)) {\n      increase -= invert.access(y, j);\n    }\n    ans += increase;\n    invert.multiply();\n    for (auto k: range(0, N)) {\n      invert.reduce(k, x);\n      invert.reduce(k, y);\n      invert.reduce(x, k);\n      invert.reduce(y, k);\n      if (k != x && k != y) {\n        invert.access(k, x) = invert.access(k, y) = invert.access(k, x) + invert.access(k, y);\n        invert.access(x, k) = invert.access(y, k) = invert.access(x, k) + invert.access(y, k);\n      }\n    }\n    invert.access(x, y) = invert.access(y, x) = invert.access(x, y) + invert.access(y, x);\n    invert.access(x, x) = invert.access(y, y) = invert.access(x, x) + invert.access(y, y);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n#define repd(i,x,y) for(int i=x; i>=y; --i)\n\nusing namespace std;\nconst int N=3005,mod=1000000007;\ntypedef long long LL;\nconst LL inv2=(mod+1)/2;\nint n,m,a[N];\nstruct data{int x,y;} dat[N];\nLL f[N][N],g[N][N],A,ans;\n\nint getint()\n{\t\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nvoid inc(LL &x,LL y)\n{\n\tx=(x+y)*inv2%mod;\n}\n\nint main()\n{\n\tn=getint(),m=getint();\n\trep(i,1,n) a[i]=getint();\n\trep(i,1,m) dat[i].x=getint(),dat[i].y=getint();\n\trep(i,1,n) rep(j,1,i-1) f[i][j]=1;\n\tA=1;\n\trepd(i,m,1)\n\t{\n\t\tint x=dat[i].x,y=dat[i].y;\n\t\trep(j,1,n)\n\t\t{\n\t\t\tg[x][j]=f[x][j];\n\t\t\tg[y][j]=f[y][j];\n\t\t\tg[j][x]=f[j][x];\n\t\t\tg[j][y]=f[j][y];\n\t\t}\n\t\trep(j,1,n) if(j!=x && j!=y)\n\t\t{\n\t\t\tinc(f[y][j],g[x][j]),inc(f[j][y],g[j][x]);\n\t\t\tinc(f[x][j],g[y][j]),inc(f[j][x],g[j][y]);\n\t\t}\n\t\tinc(f[x][y],g[y][x]),inc(f[y][x],g[x][y]);\n\t\tA=A*2%mod;\n\t}\n\trep(i,1,n) rep(j,1,n) if(a[i]<a[j]) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",ans*A%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2018.12.29 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-15\ninline int read(){\n    res s=0;\n    bool w=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return w?-s:s;\n}\ninline void _swap(res &x,res &y){\n    x^=y^=x^=y;\n}\ninline int _abs(const res &x){\n    return x>0?x:-x;\n}\ninline int _max(const res &x,const res &y){\n    return x>y?x:y;\n}\ninline int _min(const res &x,const res &y){\n    return x<y?x:y;\n}\nconst int kcz=1e9+7;\nconst int N=3e3+10;\nnamespace MAIN{\n    int n,q;\n    int a[N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int qpow(res x,res y){\n        res ret=1;\n        while(y){\n            if(y&1)ret=1LL*x*ret%kcz;\n            x=1LL*x*x%kcz,y>>=1;\n        }\n        return ret;\n    }\n    int f[N][N],g[N][N],ans,INV,X[N],Y[N];\n    inline void MAIN(){\n        n=read(),q=read(),INV=qpow(2,kcz-2);\n        for(res i=1;i<=n;i++){\n            a[i]=read();\n            for(res j=i+1;j<=n;j++)f[i][j]=1;\n        }\n        for(res i=1;i<=q;i++)X[i]=read(),Y[i]=read();\n        for(res t=1;t<=q;t++){\n            res x=X[q-t+1],y=Y[q-t+1];\n            for(res i=1;i<=n;i++)g[x][i]=f[x][i],g[i][x]=f[i][x],g[y][i]=f[y][i],g[i][y]=f[i][y];\n            for(res i=1;i<=n;i++){\n                f[x][i]=1LL*Add(f[x][i],g[y][i])*INV%kcz,f[i][x]=1LL*Add(f[i][x],g[i][y])*INV%kcz;\n                f[y][i]=1LL*Add(f[y][i],g[x][i])*INV%kcz,f[i][y]=1LL*Add(f[i][y],g[i][x])*INV%kcz;\n            }\n            f[x][y]=f[y][x]=1LL*Add(g[x][y],g[y][x])*INV%kcz;\n        }\n        for(res i=1;i<=n;i++)\n            for(res j=1;j<=n;j++)if(a[i]>a[j])add(ans,f[i][j]);\n        printf(\"%lld\\n\",1LL*qpow(2,q)*ans%kcz);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define modsum(a, b) ((a) + (b) >= M ? (a) + (b) - M : (a) + (b))\n#define modsubtract(a, b) ((a) - (b) < 0 ? (a) - (b) + M : (a) - (b))\n#define modmultiply(a, b) (((a) * (b)) % M)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)((a).size()))\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T>\nostream & operator << (ostream &out, vector<T> &a) {\n    out << \"{\";\n    fori (i, SZ(a))\n        out << a[i] << vector<string>{\", \", \"}\"}[i + 1 == SZ(a)];\n    return out;\n}\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\n\";\n    cout << \"TOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nint n, q;\nconst int N = 3003;\nconst ll M = 1e9 + 7;\nint a[N];\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % M;\n        a = (a * a) % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll pw2[N];\n\nint dp[N][N];\n\npii queries[N];\n\nvoid smain() {\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n    cin >> n >> q;\n    fori (i, n) cin >> a[i];\n    fori (i, q) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--, queries[i].second--;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            dp[i][j] = 1;\n        }\n    }\n    ll inv2 = pw(2, M - 2);\n    for (int t = q - 1; t >= 0; --t) {\n        int a = queries[t].first, b = queries[t].second;\n        vector<pair<pii, int>> upd;\n        for (int j = 0; j < n; ++j) if (j != a && j != b) {\n            upd.push_back({{j, b}, dp[j][a] * inv2 % M});\n            upd.push_back({{b, j}, dp[a][j] * inv2 % M});\n\n            upd.push_back({{j, a}, dp[j][b] * inv2 % M});\n            upd.push_back({{a, j}, dp[b][j] * inv2 % M});\n        }\n\n        upd.push_back({{a, b}, dp[b][a] * inv2 % M});\n        upd.push_back({{b, a}, dp[a][b] * inv2 % M});\n\n        for (auto x : upd) {\n            dp[x.first.first][x.first.second] = (dp[x.first.first][x.first.second] * inv2 + x.second) % M;\n        }\n\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (a[i] < a[j]) ans = (ans + dp[i][j]) % M;\n            else if (a[i] > a[j]) ans = (ans + 1 - dp[i][j] + M) % M;\n        }\n    }\n    ans = (ans * pw2[q]) % M;\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 3000\n#define mod 1000000007\nconst int inv=(mod+1)/2;\ninline int read()\n{\n    int x=0,f=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='1') f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*f;\n}\nint ax[MN+5],ay[MN+5],n,m,a[MN+5],f[MN+5][MN+5],mem[MN+5][MN+5];\nvoid Revise(int x,int y,int z)\n{\n    f[x][y]=1LL*(mem[x][y]+mem[x][z])*inv%mod;\n    f[y][x]=1LL*(mem[y][x]+mem[z][x])*inv%mod;\n}\nint main()\n{   \n    n=read();m=read();int num=1;\n    for(int i=1;i<=n;++i) a[i]=read();\n    for(int i=1;i<=m;++i) ax[i]=read(),ay[i]=read(),num=num*2%mod;\n    for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) f[i][j]=num;\n    for(int i=m;i;--i)\n    {\n        if(ax[i]>ay[i]) swap(ax[i],ay[i]);\n        for(int j=1;j<=n;++j) \n            mem[j][ax[i]]=f[j][ax[i]],mem[ax[i]][j]=f[ax[i]][j],\n            mem[j][ay[i]]=f[j][ay[i]],mem[ay[i]][j]=f[ay[i]][j];\n        for(int j=1;j<=n;++j) if(j!=ax[i]&&j!=ay[i]) Revise(j,ax[i],ay[i]),Revise(j,ay[i],ax[i]);\n        f[ax[i]][ay[i]]=f[ay[i]][ax[i]]=1LL*(f[ax[i]][ay[i]]+f[ay[i]][ax[i]])*inv%mod;\n    }\n    int ans=0;\n    for(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) \n    {\n        if(a[i]<a[j]) ans=(ans+f[j][i])%mod;\n        if(a[i]>a[j]) ans=(ans+f[i][j])%mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\n#include <numeric>\n#include <array>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint max_kai = 300000;\nvel kai(max_kai, 1);\nvel inv_kai(max_kai, 1);\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nint root(int x,vel &pa) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x],pa); pa[x] = ans;\n    return ans;\n}\nbool mar(int x, int y,vel &pa) {\n    x = root(x,pa);\n    y = root(y,pa);\n    if (x != y) { pa[x] = y; }\n    return (x != y);\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvoid make_kai() {\n    rep(i, max_kai - 1) {\n        kai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n        inv_kai[i + 1] = modinv(kai[i + 1], p);\n    }\n}\nint com(int n, int r) {\n    if ((n < 0) || (r < 0) || (r > n)) { return 0; }\n    int ans = (kai[n] * inv_kai[r]) % p;\n    return (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nint inf = 100000;\nvel dijk(V<V<pin>>& way, int st) {\n    int n = way.size();\n    vel dist(n, inf); dist[st] = 0;\n    priority_queue<pin, vector<pin>, greater<pin>> pq;\n    pq.push(mkp(0, st));\n    veb is_checked(n, false);\n    while (!pq.empty()) {\n        pin x = pq.top(); pq.pop();\n        int pot = x.second;\n        if (!is_checked[pot]) {\n            is_checked[pot] = true;\n            for (auto y : way[pot]) {\n                int nex_dist = x.first + y.second;\n                int nex_pot = y.first;\n                if (dist[nex_pot] > nex_dist) {\n                    dist[nex_pot] = nex_dist;\n                    pq.push(mkp(nex_dist, y.first));\n                }\n            }\n        }\n    }\n    return dist;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\nsigned main() {\n    int n, q; cin >> n >> q;\n    vel a(n);\n    rep(i, n) { cin >> a[i]; }\n    vvel b(n, vel(n));\n    rep(i, n) {\n        rep(j, n) {\n            if (a[i] > a[j]) { b[i][j]++; }\n        }\n    }\n    int inv2 = (p + 1) / 2;\n    rep(ind, q) {\n        int x, y; cin >> x >> y; x--; y--;\n        int sum1 = b[x][y] + b[y][x];\n        sum1 *= inv2; sum1 %= p;\n        b[x][y] = sum1; b[y][x] = sum1;\n        rep(i, n) {\n            if ((i != x) && (i != y)) {\n                sum1 = b[x][i] + b[y][i];\n                sum1 *= inv2; sum1 %= p;\n                b[x][i] = sum1; b[y][i] = sum1;\n                sum1 = b[i][x] + b[i][y];\n                sum1 *= inv2;sum1 %= p;\n                b[i][x] = sum1; b[i][y] = sum1;\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, n) {\n        rep(j, i) {\n            ans += b[j][i];\n        }\n    }\n    ans *= rui(2, q, p);\n    cout << ans % p << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 3010;\n\nint N, Q;\nint A[MN], X[MN], Y[MN], prec[MN][MN], po[MN];\nvector<int> V[MN];\n\nvector<int> cc[MN][MN][2];\nint dp(int a, int b, int t, int x) {\n    int &ret = cc[a][b][t][x];\n    if(ret != -1) return ret;\n\n    int cur = t? V[a][x] : V[b][x];\n    if(cur == Q) return ret = a < b;\n\n    ret = 0;\n    int pa = prec[a][cur];\n    int pb = prec[b][cur];\n    int nxt = min(V[a][pa], V[b][pb]);\n\n    if(V[a][pa] < V[b][pb]) {\n        ret += 1LL * po[nxt - cur - 1] * dp(a, b, 1, pa) % mod;\n        ret %= mod;\n    }\n    else {\n        ret += 1LL * po[nxt - cur - 1] * dp(a, b, 0, pb) % mod;\n        ret %= mod;\n    }\n\n    int na = a == X[cur]? Y[cur] : (a == Y[cur]? X[cur] : a);\n    int nb = b == X[cur]? Y[cur] : (b == Y[cur]? X[cur] : b);\n    pa = prec[na][cur];\n    pb = prec[nb][cur];\n    nxt = min(V[na][pa], V[nb][pb]);\n\n    if(V[na][pa] < V[nb][pb]) {\n        ret += 1LL * po[nxt - cur - 1] * dp(na, nb, 1, pa) % mod;\n        ret %= mod;\n    }\n    else {\n        ret += 1LL * po[nxt - cur - 1] * dp(na, nb, 0, pb) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    scanf(\"%d %d\", &N, &Q);\n\n    //N = 3000, Q = 3000;\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n\n        //A[i] = 1LL * rand() * rand() % 1000000000;\n    }\n\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n\n        //X[i] = rand() % N;\n        //Y[i] = rand() % N;\n\n        V[ X[i] ].push_back(i);\n        V[ Y[i] ].push_back(i);\n    }\n    for(int i = 0; i < N; i++) {\n        V[i].push_back(Q);\n    }\n\n    for(int i = 0; i < N; i++) {\n        int pos = 0;\n        for(int j = 0; j < Q; j++) {\n            if(pos < V[i].size() && V[i][pos] <= j) pos++;\n            prec[i][j] = pos;\n        }\n    }\n\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cc[i][j][1] = vector<int>(V[i].size(), -1);\n            cc[i][j][0] = vector<int>(V[j].size(), -1);\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(A[j] < A[i]) {\n                if(V[i][0] < V[j][0]) {\n                    ans += 1LL * po[ V[i][0] ] * dp(i, j, 1, 0) % mod;\n                    ans %= mod;\n                }\n                else {\n                    ans += 1LL * po[ V[j][0] ] * dp(i, j, 0, 0) % mod;\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=1e9+7;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\n\nconst int M = 3e3 + 15;\nint dp[M][M][3];\n\nint X(int a, int b){\n\tif(a>b) return 0;\n\telse if (a<b) return 2;\n\telse return 1;\n}\nint pp[M][3];\nint qq[M][3];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tint N, Q;\n\tcin>>N>>Q;\n\tvi A(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin>>A[i];\n\t\tfor(int j=0;j<i;j++){\n\t\t\tdp[j][i][X(A[j], A[i])] = 1;\t\t\n\t\t}\n\t}\n\tint i2 = inv(2); \n\tint p2q = power(2,Q);\n\twhile(Q--){\n\t\tint p, q;\n\t\tcin>>p>>q ; p--; q--;\n\t\tif(p>q) swap(p, q);\n\t\t// trace(p, q);\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tpp[i][j] = dp[min(p,i)][max(p, i)][j];\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tqq[i][j] = dp[min(i, q)][max(q, i)][j]; \n\t\tfor(int i=p+1;i<q;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tdp[p][i][j] = add(dp[p][i][j], qq[i][2-j]); dp[p][i][j] = mul(dp[p][i][j], i2);\n\t\t\t\tdp[i][q][j] = add(dp[i][q][j], pp[i][2-j]); dp[i][q][j] = mul(dp[i][q][j], i2);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(p<=i && i<=q) continue;\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tdp[min(i, p)][max(p, i)][j] = mul(i2, add(dp[min(i, p)][max(p, i)][j], qq[i][j]));\n\t\t\t\tdp[min(i, q)][max(q, i)][j] = mul(i2, add(dp[min(i, q)][max(q, i)][j], pp[i][j]));\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdp[p][q][j] = add(dp[p][q][j], qq[p][2-j]); dp[p][q][j] = mul(dp[p][q][j], i2);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\t// trace(i, j, dp[j][i][0], dp[j][i][1], dp[j][i][2]);\n\t\t\tans = add(ans, dp[j][i][0]);\n\t\t}\n\t}\n\tans = mul(ans,  p2q);\n\tcout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst i64 P = 1000000000 + 7;\nconst int maxn = 3100;\n\ni64 p[maxn][maxn];\nint a[maxn];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, q;\n    cin >> n >> q;\n    forn(i, n) cin >> a[i];\n    forn(i, n) forn(j, n) if (a[i] < a[j]) p[i][j] = 1;\n    const i64 d2 = (P + 1) / 2;\n\n    forn(i, q) {\n        int x, y;\n        cin >> x >> y;\n        --x; --y;\n        forn(j, n) {\n            if (j == x || j == y) continue;\n            i64 s = (p[x][j] + p[y][j]) * d2 % P;\n            p[x][j] = p[y][j] = s;\n            s = (p[j][x] + p[j][y]) * d2 % P;\n            p[j][x] = p[j][y] = s;\n        }\n        i64 s = (p[x][y] + p[y][x]) * d2 % P;\n        p[x][y] = p[y][x] = s;\n    }\n\n    i64 ans = 0;\n    forn(i, n) forn(j, n) if (i > j) (ans += p[i][j]) %= P;\n    forn(i, q) (ans *= 2) %= P;\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=2005;\nconst int mod=1e9+7;\nconst int inv=(mod+1)/2;\nint n,q;\nint a[maxn],dp[maxn][maxn];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&q);\n\tREP(i,n)scanf(\"%d\",&a[i]);\n\tREP(i,n)REP(j,n)if(a[i]>a[j])dp[i][j]=1;\n\tREP(i,q){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tREP(j,n){\n\t\t\tif(j==x||j==y)continue;\n\t\t\tint sum=1LL*(dp[j][x]+dp[j][y])*inv%mod;\n\t\t\tdp[j][x]=dp[j][y]=sum;\n\t\t\tsum=1LL*(dp[x][j]+dp[y][j])*inv%mod;\n\t\t\tdp[x][j]=dp[y][j]=sum;\n\t\t}\n\t\tint sum=1LL*(dp[x][y]+dp[y][x])*inv%mod;\n\t\tdp[x][y]=dp[y][x]=sum;\n\t}\n\tint ans=0;\n\tREP(j,n)for(int k=j+1;k<=n;k++)ans=(ans+dp[j][k])%mod;\n\tREP(i,q)ans=2LL*ans%mod;\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 3005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\nmint dp[MX][MX];\n\nint main() {\n  int n,q;\n  scanf(\"%d%d\",&n,&q);\n  vi A(n);\n  cin>>A;\n  rep(i,n)rep(j,n) dp[i][j] = (A[i]>A[j])?1:0;\n  mint i2 = mint(1)/2;\n  rep(qi,q) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    vm la(n), ra(n);\n    vm lb(n), rb(n);\n    rep(i,n) la[i] = dp[a][i];\n    rep(i,n) ra[i] = dp[i][a];\n    rep(i,n) lb[i] = dp[b][i];\n    rep(i,n) rb[i] = dp[i][b];\n    rep(i,n) {\n      dp[a][i] = dp[b][i] = (la[i]+lb[i])*i2;\n      dp[i][a] = dp[i][b] = (ra[i]+rb[i])*i2;\n    }\n    dp[a][b] = dp[b][a] = (la[b]+lb[a])*i2;\n  }\n  mint ans = 0;\n  rep(j,n)rep(i,j) ans += dp[i][j];\n  rep(i,q) ans *= 2;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 3002, mod = 1000000007;\nint n, q, a[N], f[N][N];\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    for (int j = 1; j < i; j++) {\n      if (a[j] < a[i]) f[i][j] = 1;\n      if (a[j] > a[i]) f[j][i] = 1;\n    }\n  }\n  int ans = 0, t = 1;\n  while (q--) {\n    (t <<= 1) %= mod;\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    f[y][x] = f[x][y] = (ll) (f[x][y] + f[y][x]) * (mod + 1) / 2 % mod;\n    for (int i = 1; i <= n; i++) if (i != x && i != y) {\n      f[x][i] = f[y][i] = (ll) (f[x][i] + f[y][i]) * (mod + 1) / 2 % mod;\n      f[i][x] = f[i][y] = (ll) (f[i][x] + f[i][y]) * (mod + 1) / 2 % mod;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      ans = (ans + (ll) f[j][i] * t) % mod;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int N = 3000 + 7;\nconst i64 MOD = 1000000007;\nconst i64 Inv2 = MOD - MOD / 2;\n\nint n, q;\nint a[N];\ni64 f[N][N], g[N][N], ans, coe = 1;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) f[i][j] = g[i][j] = a[i] > a[j];\n\tfor (int x, y; q; --q) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i != x) g[i][x] = (f[i][x] + f[i][y]) * Inv2 % MOD, g[x][i] = (f[x][i] + f[y][i]) * Inv2 % MOD;\n\t\t\tif (i != y) g[i][y] = (f[i][x] + f[i][y]) * Inv2 % MOD, g[y][i] = (f[x][i] + f[y][i]) * Inv2 % MOD;\n\t\t}\n\t\tg[x][y] = g[y][x] = (f[x][y] + f[y][x]) * Inv2 % MOD;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= n; ++j) f[i][j] = g[i][j];\n\t\tcoe = coe * 2 % MOD;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) ( ans += f[i][j] ) %= MOD;\n\tprintf(\"%lld \", ans * coe % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3050;\ntypedef long long ll;\nconst ll mod=1000000007;\nconst ll inv=500000004;\nint n,q,ai[N];\nll dp[N][N],ans,pl;\n\ninline ll KSM(ll a,ll p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tpl=KSM(2,q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&ai[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(ai[i]>ai[j])\n\t\t\t\tdp[i][j]=1;\n\twhile(q--){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tdp[x][y]=dp[y][x]=((dp[x][y]+dp[y][x])%mod)*inv%mod;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x || i==y) continue;\n\t\t\tdp[i][x]=dp[i][y]=((dp[i][y]+dp[i][x])%mod)*inv%mod;\n\t\t\tdp[x][i]=dp[y][i]=((dp[y][i]+dp[x][i])%mod)*inv%mod;\n\t\t}\n//\t\tfor(int i=1;i<=n;i++)\t\n//\t\t{\n//\t\t\tfor(int j=1;j<=n;j++)\n//\t\t\t\tcout<<dp[i][j]<<\" \";\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(dp[i][j]+ans)%mod;\n\tans=ans*pl%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 3001;\nconst int P = 1e9 + 7;\nvoid add(int& a,int b){\n  a += b;\n  if(a >= P)\n    a-=P;\n}\nint mul(int a,int b){\n  return a * b % P;\n}\nint n,q;\nint t[MAX];\nint war[MAX][MAX];\nint pol = (P + 1) / 2;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> q;\n  R(i,n){\n    cin >> t[i];\n  }\n  int p2 = 1;\n  R(i,q)add(p2,p2);\n  R(i,n)R(j,n){\n    if(t[i] < t[j]){\n      war[i][j] = p2;\n    }\n  }\n  R(_,q){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    int sum = war[a][b] + war[b][a];\n    R(i,n){\n      war[a][i] = war[b][i] = mul(war[a][i] + war[b][i], pol);\n      war[i][a] = war[i][b] = mul(war[i][a] + war[i][b], pol);\n    }\n    war[a][a] = war[b][b] = 0;\n    war[a][b] = war[b][a] = mul(sum, pol);\n  }\n  int res = 0;\n  R(i,n)R(j,i){\n    add(res,war[i][j]);\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7,inv2=(mod+1)/2;\nll f[3010][3010],g[3010][3010];\nint a[4040];\ninline int read()\n{\n\tchar c=getchar();int x=0,flag=1;\n\twhile(!isdigit(c)){if(c=='-') flag=-1;c=getchar();}\n\twhile(isdigit(c)) x=x*10+c-'0',c=getchar();\n\treturn x*flag;\n}\nint main()\n{\n\tint n=read(),q=read(),qq=q;\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(a[i]>a[j]) f[i][j]=1;\n\t\t}\n\t}\n\twhile(q--)\n\t{\n\t\tint x=read(),y=read();\n\t\tfor(int i=1;i<=n;i++) g[i][x]=f[i][x],g[i][y]=f[i][y],g[x][i]=f[x][i],g[y][i]=f[y][i];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t//\tif(i==x) continue;\n\t\t\tif(i==y) f[i][x]=(g[x][y]*inv2+g[y][x]*inv2)%mod;\n\t\t\telse f[i][x]=(g[i][x]*inv2+g[i][y]*inv2)%mod;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t//\tif(i==x) continue;\t\t\n\t\t\tif(i==y) f[x][i]=(g[x][y]*inv2+g[y][x]*inv2)%mod;\n\t\t\telse f[x][i]=(g[x][i]*inv2+g[y][i]*inv2)%mod;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t//\tif(i==y) continue;\n\t\t\tif(i==x) f[i][y]=(g[x][y]*inv2+g[y][x]*inv2)%mod;\n\t\t\telse f[i][y]=(g[i][y]*inv2+g[i][x]*inv2)%mod;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t//\tif(i==y) continue;\n\t\t\tif(i==x) f[y][i]=(g[x][y]*inv2+g[y][x]*inv2)%mod;\n\t\t\telse f[y][i]=(g[y][i]*inv2+g[x][i]*inv2)%mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tans=(ans+f[i][j])%mod;\n\t\t}\n\t}\n\tfor(int i=1;i<=qq;i++) ans=ans*2%mod;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 3010, mod = 1e9 + 7, i2 = (mod + 1) / 2;\n\nint a[N], dp[N][N];\n\nint main() {\n\tint n, q, tot = 1; scanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= q; i++) tot <<= 1, tot %= mod;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tdp[i][j] = a[i] > a[j];\n\tfor (int i = 1; i <= q; i++) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tdp[l][r] = dp[r][l] = (LL)(dp[l][r] + dp[r][l]) * i2 % mod;\n\t\tfor (int j = 1; j <= n; j++) if (j != r && j != l) {\n\t\t\tdp[j][r] = dp[j][l] = (LL)(dp[j][r] + dp[j][l]) * i2 % mod;\n\t\t\tdp[l][j] = dp[r][j] = (LL)(dp[l][j] + dp[r][j]) * i2 % mod;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tres = (res + dp[i][j]) % mod;\n\tprintf(\"%d\\n\", (LL)res * tot % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<tuple>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nint N, Q;\nint A[3011];\nint X[3011], Y[3011];\nMint P[3011][3011];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &Q);\n    REP (i, N) scanf(\"%d\", A+i);\n    REP (i, Q) scanf(\"%d%d\", X+i, Y+i), X[i]--, Y[i]--;\n\n    Mint base = Mint(2).pow(Q);\n    Mint inv2 = Mint(2).inv();\n    REP (i, N) REP (j, N) if (A[i] < A[j]) {\n\tP[i][j] += base;\n    }\n\n    using Tuple = tuple<int, int, Mint>;\n    vector<Tuple> update;\n\n    REP (q, Q) {\n\tint x = X[q], y = Y[q];\n\tupdate.clear();\n\tREP (i, N) {\n\t    if (i != y) {\n\t\tP[x][i] *= inv2;\n\t\tP[i][x] *= inv2;\n\t\tupdate.emplace_back(y, i, P[x][i]);\n\t\tupdate.emplace_back(i, y, P[i][x]);\n\t    }\n\t    if (i != x) {\n\t\tP[y][i] *= inv2;\n\t\tP[i][y] *= inv2;\n\t\tupdate.emplace_back(x, i, P[y][i]);\n\t\tupdate.emplace_back(i, x, P[i][y]);\n\t    }\n\t}\n\tP[x][y] *= inv2;\n\tP[y][x] *= inv2;\n\tupdate.emplace_back(y, x, P[x][y]);\n\tupdate.emplace_back(x, y, P[y][x]);\n\tEACH (e, update) {\n\t    int i, j; Mint m;\n\t    tie(i, j, m) = *e;\n\t    P[i][j] += m;\n\t}\n    }\n    Mint ans = 0;\n    REP (i, N) REP (j, N) if (i > j) {\n\tans += P[i][j];\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int N=3050;\ntypedef long long ll;\nconst ll mod=1000000007;\nconst ll inv=500000004;\nint n,q,ai[N];\nll dp[N][N],ans,pl;\n\ninline ll KSM(ll a,ll p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tpl=KSM(2,q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&ai[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(ai[i]>ai[j])\n\t\t\t\tdp[i][j]=1;\n\twhile(q--){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tdp[x][y]=dp[y][x]=((dp[x][y]+dp[y][x])%mod)*inv%mod;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x || i==y) continue;\n\t\t\tdp[i][x]=dp[i][y]=((dp[i][y]+dp[i][x])%mod)*inv%mod;\n\t\t\tdp[x][i]=dp[y][i]=((dp[y][i]+dp[x][i])%mod)*inv%mod;\n\t\t}\n//\t\tfor(int i=1;i<=n;i++)\t\n//\t\t{\n//\t\t\tfor(int j=1;j<=n;j++)\n//\t\t\t\tcout<<dp[i][j]<<\" \";\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(dp[i][j]+ans)%mod;\n\tans=ans*pl%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tK = power(2, M, MOD);\n\tvector<vector<long long int>>dp(N, vector<long long int>(N, 0));\n\tvector<vector<long long int>>ch(N, vector<long long int>(N, 0));\n\tvector<long long int>rev_by(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\trev_by[i] = rev_by[i] * power(2, MOD - 2, MOD);\n\t\trev_by[i] %= MOD;\n\t}\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tlong long int sum = dp[L][j] + dp[R][j];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[R][j] = ch[L][j] = sum;\n\t\t\tsum = dp[j][L] + dp[j][R];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[j][R] = ch[j][L] = sum;\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tdp[R][j] = dp[L][j] = ch[L][j];\n\t\t\tdp[j][R] = dp[j][L] = ch[j][L];\n\t\t}\n\t\tdp[L][R] = dp[R][L] = ((dp[L][R] + dp[R][L])*rev_by[1]) % MOD;\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++)ans += dp[i][j];\n\t}\n\tcout << ans % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vi a(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  vll dp(n, vl(n));\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) continue;\n      if (a[i] < a[j]) dp[i][j] = 1;\n    }\n  }\n  ll half = mod_inverse(2);\n  vll memo(n, vl(n));\n  rep (aaa, q) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      memo[i][u] = (dp[i][u] + dp[i][v]) % MOD * half % MOD;\n      memo[u][i] = (dp[u][i] + dp[v][i]) % MOD * half % MOD;\n      memo[i][v] = (dp[i][u] + dp[i][v]) % MOD * half % MOD;\n      memo[v][i] = (dp[u][i] + dp[v][i]) % MOD * half % MOD;\n    }\n    memo[u][v] = memo[v][u] = (dp[u][v] + dp[v][u]) % MOD * half % MOD;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      dp[i][u] = memo[i][u];\n      dp[i][v] = memo[i][v];\n      dp[u][i] = memo[u][i];\n      dp[v][i] = memo[v][i];\n    }\n    dp[u][v] = dp[v][u] = memo[u][v];\n  }\n  ll ans = 0;\n  ll po = pow(2, q);\n  rep (i, n) {\n    for (int j = 0; j < i; j++) {\n      ans += po * dp[i][j] % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << (ans + MOD) % MOD << endl;\n      \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#define ms(a,b) memset(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int mod = 1e9 + 7;\nconst int maxn = 3000 + 5;\n\nll qpow(ll x, ll n) {\n    ll r = 1;\n    while (n > 0) {\n        if (n & 1) r = r * x % mod;\n        n >>= 1; x = x * x % mod;\n    }\n    return r;\n}\nll inv(ll x) { return qpow(x, mod - 2); }\n\nint n, q, a[maxn];\nll f[maxn][maxn];\n\nint main() {\n    scanf(\"%d%d\", &n, &q);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (a[i] > a[j]) f[i][j] = 1;\n    ll inv2 = inv(2);\n    for (int i = 1, x, y; i <= q; i++) {\n        scanf(\"%d%d\", &x, &y);\n        f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv2 % mod;\n        for (int j = 1; j <= n; j++) if (j != x && j != y) {\n            f[x][j] = f[y][j] = (f[x][j] + f[y][j]) * inv2 % mod;\n            f[j][x] = f[j][y] = (f[j][x] + f[j][y]) * inv2 % mod;\n        }\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) {\n        ans += f[i][j]; if (ans >= mod) ans -= mod;\n    }\n    cout << ans * qpow(2, q) % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=3005,M=1e9+7;\nint f[N][N],a[N],g[N][N],n,Q,x,y;\nint ksm(int x,int y){\n\tif (!y)return 1;\n\tint z=ksm(x,y/2);\n\tz*=z;z%=M;\n\tif (y&1)z*=x;\n\treturn z%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&Q);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (a[i]>a[j])f[i][j]=1;\n\tint K=ksm(2,Q),Inv=ksm(2,M-2);\t\t\n\twhile (Q--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tg[x][y]=f[y][x];\n\t\tg[y][x]=f[x][y];\n\t\tf[y][x]=(f[y][x]*Inv+g[y][x]*Inv)%M;\n\t\tf[x][y]=(f[x][y]*Inv+g[x][y]*Inv)%M;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y)g[x][i]=f[y][i],g[i][x]=f[i][y];\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y)g[y][i]=f[x][i],g[i][y]=f[i][x];\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y){\n\t\t\t\tf[x][i]=(g[x][i]*Inv+f[x][i]*Inv)%M;\n\t\t\t\tf[y][i]=(g[y][i]*Inv+f[y][i]*Inv)%M;\n\t\t\t\tf[i][x]=(g[i][x]*Inv+f[i][x]*Inv)%M;\n\t\t\t\tf[i][y]=(g[i][y]*Inv+f[i][y]*Inv)%M;\n\t\t\t}\n\t\tfor (int i=1;i<=n;i++)g[i][x]=g[i][y]=g[x][i]=g[y][i]=0;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)(ans+=f[i][j])%=M;\n\tprintf(\"%lld\\n\",ans*K%M);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define vll vector<ll>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define re(c, b) for(ll c=0;c<b;c++)\ntypedef long long int ll;\nusing namespace std;\nll P = 1000000007;\nll I = 500000004;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 1);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 1) {\n            node[k] = (node[k] * lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1]*lazy[k])%P;\n                lazy[2*k+2] = (lazy[2*k+2]*lazy[k])%P;\n            }\n            lazy[k] = 1;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k]*x)%P;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1]+node[2*k+2])%P;\n        }\n    }\n\n    void adx(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            eval(k, l, r);\n        }else {\n            node[k] = (node[k]+x)%P;\n        }\n    }\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(query.begin(), query.end());\n  LazySegmentTree dp(vector<ll>(n*n+1, 1));\n  LazySegmentTree rev(vector<ll>(n*n+1, 0));\n  for(auto v:query){\n    vvl tmp; //i, j, flip or not, num\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    ll adr = x*n+y;\n    tmp.push_back(vll{x, y, 1, dp.getsum(adr, adr+1)});\n    tmp.push_back(vll{x, y, 0, rev.getsum(adr, adr+1)});\n\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(i<x){\n        adr = i*n+y;\n        tmp.push_back(vll{i, x, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, x, 0, dp.getsum(adr, adr+1)});\n      }else if(y<i){\n        adr = y*n+i;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = i*n+y;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(y<i){\n        adr = x*n+i;\n        tmp.push_back(vll{y, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{y, i, 0, dp.getsum(adr, adr+1)});\n      }else if(i<x){\n        adr = i*n+x;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = x*n+i;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    /*\n    for(auto ad:tmp){\n      ll adr = ad[0]*n+ad[1];\n      if(ad[2]==1) rev.adx(adr, adr+1, ad[3]);\n      else dp.adx(adr, adr+1, ad[3]);\n    }\n    */\n    //関係ないものは2倍\n    //xかyに関係するものはinv[2]を掛けておく\n\n    /*\n    for(int i=0;i<n;i++){\n      if(i!=x&&i!=y){\n        dp.add(i*n+x, i*n+x+1, I);\n        dp.add(x*n+i, x*n+i+1, I);\n        rev.add(i*n+x, i*n+x+1, I);\n        rev.add(x*n+i, x*n+i+1, I);\n        dp.add(i*n+y, i*n+y+1, I);\n        dp.add(y*n+i, y*n+i+1, I);\n        rev.add(i*n+y, i*n+y+1, I);\n        rev.add(y*n+i, y*n+i+1, I);\n      }\n    }\n    dp.add(x*n+y, x*n+y+1, I);\n    dp.add(y*n+x, y*n+x+1, I);\n    rev.add(x*n+y, x*n+y+1, I);\n    rev.add(y*n+x, y*n+x+1, I);\n    dp.add(0, n*n+1, 2);\n    rev.add(0, n*n+1, 2);\n    */\n  }\n  \n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ll adr = i*n+j;\n      if(a[i]<a[j]) ans = (ans + rev.getsum(adr, adr+1))%P;\n      if(a[i]>a[j]) ans = (ans + dp.getsum(adr, adr+1))%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n, q, num[3007], p[3007][3007], res;\nint main()\n{\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> num[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tp[i][j] = num[i] > num[j];\n\tfor (int i = 1, a, b; i <= q; i++)\n\t{\n\t\tcin >> a >> b;\n\t\tp[a][b] = p[b][a] = 500000004LL * (p[a][b] + p[b][a]) % mod;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (j != a && j != b)\n\t\t\t{\n\t\t\t\tp[j][a] = p[j][b] = 500000004LL * (p[j][a] + p[j][b]) % mod;\n\t\t\t\tp[a][j] = p[b][j] = 500000004LL * (p[a][j] + p[b][j]) % mod;\n\t\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tres = (res + p[i][j]) % mod;\n\tfor (int i = 1; i <= q; i++)\n\t\tres = (res << 1) % mod;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define re register\n#define gc getchar()\n#define ll long long\n\ninline ll read() {\n\tre ll x(0), f(1); re char c(gc);\n\twhile (c > '9' || c < '0') f = c == '-' ? -1 : 1, c = gc;\n\twhile (c <= '9' && c >= '0') x = x * 10 + c -48, c = gc;\n\treturn x * f;\n}\n\nconst int N = 3030, mod = 1e9 + 7;\nint n, q, a[N];\nll ans, f[N][N], inv;\n\nll qpow (ll a, int b) {\n    ll x (1);\n    while (b) {\n        if (b & 1) x = x * a % mod;\n        a = a * a % mod, b >>= 1;\n    } return x;\n}\n\nint main () {\n    n = read(), q = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <=n; ++j) \n            f[i][j] = a[i] < a[j];\n    inv = qpow (2, mod -2);\n    for (int d = 1; d <= q; ++d) {\n        int x = read(), y = read();\n        f[x][y] = f[y][x] = inv * (f[x][y] + f[y][x]) % mod;\n        for (int j = 1; j <= n; ++j) if (j != x && j != y) {\n            f[j][x] = f[j][y] = inv * (f[j][x] + f[j][y]) % mod;\n            f[x][j] = f[y][j] = inv * (f[x][j] + f[y][j]) % mod;\n        }\n    } ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <i; ++j)\n            ans = (ans + f[i][j]) % mod;\n    cout << ans * qpow (2, q) % mod << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint x[3100];\nint y[3100];\nint las[3100][3100];\nint cur[3100];\nint p[3100];\nlong long ks[3100];\nlong long dp[3100][4][3100];\n//map<pair<int,pair<int,int> >,long long >dp;\nlong long calc(int a,int b,int c){\n\tif(a==0){\n\t\treturn p[b]>p[c];\n\t}\n\tint ty=-1;\n\tint rm=0;\n\tif(b==x[a-1]){ty=0;rm=c;}\n\telse if(b==y[a-1]){ty=1;rm=c;}\n\telse if(c==x[a-1]){ty=2;rm=b;}\n\telse if(c==y[a-1]){ty=3;rm=b;}\n\tif(ty!=-1&&~dp[a][ty][rm]){\n\t\treturn dp[a][ty][rm];\n\t}\n\t//printf(\"%d %d %d\\n\",a,b,c);\n\tlong long ret=0;\n\tint to=max(las[a][b],las[a][c]);\n\tif(to==-1){\n\t\tret=calc(0,b,c);\n\t}else{\n\t\tret=calc(to,b,c);\n\t\tif(x[to]==b&&y[to]==c)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==c&&y[to]==b)ret=(ret+calc(to,c,b))%mod;\n\t\telse if(x[to]==b)ret=(ret+calc(to,y[to],c))%mod;\n\t\telse if(x[to]==c)ret=(ret+calc(to,b,y[to]))%mod;\n\t\telse if(y[to]==b)ret=(ret+calc(to,x[to],c))%mod;\n\t\telse if(y[to]==c)ret=(ret+calc(to,b,x[to]))%mod;\n\t}\n\tret=ret*ks[a-to-1]%mod;\n\tif(ty!=-1){\n\t\tdp[a][ty][rm]=ret;\n\t}\n\treturn ret;\n}\nint main(){\n\tks[0]=1;\n\tfor(int i=1;i<3100;i++)ks[i]=ks[i-1]*2%mod;\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);x[i]--;y[i]--;\n\t}\n\tfor(int i=0;i<=b;i++)for(int j=0;j<4;j++)for(int k=0;k<a;k++)\n\t\tdp[i][j][k]=-1;\n\tfor(int i=0;i<a;i++)cur[i]=-1;\n\tfor(int i=0;i<b;i++){\n\t\tcur[x[i]]=cur[y[i]]=i;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tlas[i+1][j]=cur[j];\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tret+=calc(b,i,j);\n\t\t}\n\t}\n\tret%=mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nmint i2 = (mint)1/2;\nmint f[3000][3000];\nint is[20000];\nint js[20000];\nmint vs[20000];\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\tV<int> a(N);\n\trep(i,N) cin>>a[i];\n\trep(i,N) rep(j,N) if(i>j) f[i][j] = 1;\n\tV<int> X(Q),Y(Q);\n\trep(i,Q){\n\t\tcin>>X[i]>>Y[i];\n\t\tX[i]--,Y[i]--;\n\t}\n\tfor(int t=Q-1;t>=0;t--){\n\t\tint K = 0;\n\t\tauto add = [&](int i,int j,mint v){\n\t\t\tis[K] = i;\n\t\t\tjs[K] = j;\n\t\t\tvs[K] = v;\n\t\t\tK++;\n\t\t};\n\t\tint x = X[t], y = Y[t];\n\t\trep(_,2){\n\t\t\tadd(x,y,i2);\n\t\t\trep(j,N) if(j!=x && j!=y){\n\t\t\t\tadd(x,j,(f[x][j]+f[y][j])*i2);\n\t\t\t\tadd(j,x,(f[j][x]+f[j][y])*i2);\n\t\t\t}\n\t\t\tswap(x,y);\n\t\t}\n\t\trep(k,K){\n\t\t\tf[is[k]][js[k]] = vs[k];\n\t\t}\n\t}\n\tmint ans = 0;\n\trep(i,N) rep(j,N) if(a[i]<a[j]) ans += f[i][j];\n\trep(_,Q) ans *= 2;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\ts=1ll*s*2%mod; \n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*iv%mod;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int N = 3000 + 7;\nconst i64 MOD = 1000000007;\nconst i64 Inv2 = MOD - MOD / 2;\n\nint n, q;\nint a[N];\ni64 f[N][N], g[N][N], ans, coe = 1;\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) f[i][j] = g[i][j] = a[i] > a[j];\n\tfor (int x, y; q; --q) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i != x) g[i][x] = (f[i][x] + f[i][y]) * Inv2 % MOD, g[x][i] = (f[x][i] + f[y][i]) * Inv2 % MOD;\n\t\t\tif (i != y) g[i][y] = (f[i][x] + f[i][y]) * Inv2 % MOD, g[y][i] = (f[x][i] + f[y][i]) * Inv2 % MOD;\n\t\t}\n\t\tg[x][y] = g[y][x] = (f[x][y] + f[y][x]) * Inv2 % MOD;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tf[i][x] = g[i][x], f[x][i] = g[x][i], f[i][y] = g[i][y], f[y][i] = g[y][i];\n\t\tf[x][y] = f[y][x] = g[x][y];\n\t\tcoe = coe * 2 % MOD;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) ( ans += f[i][j] ) %= MOD;\n\tprintf(\"%lld \", ans * coe % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nconst int maxn=3e3+100;\nconst int mod=1e9+7;\nint f[maxn][maxn],a[maxn];\nint ksm(int num,int t){\n    int res=1;\n    for(;t;t>>=1,num=1ll*num*num%mod){\n        if(t&1)res=1ll*num*res%mod;\n    }\n    return res;\n}\nint main(){\n    int n,q;cin>>n>>q;\n    rep(i,1,n)cin>>a[i];\n    rep(i,1,n)rep(j,1,n)f[i][j]=a[i]<a[j];\n    ll inv2=ksm(2,mod-2);\n    rep(i,1,q){\n        int x,y;cin>>x>>y;\n        f[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%mod;\n        rep(j,1,n){\n            if(j==x||j==y)continue;\n            f[x][j]=f[y][j]=inv2*(f[x][j]+f[y][j])%mod;\n            f[j][x]=f[j][y]=inv2*(f[j][x]+f[j][y])%mod;\n        }\n    }\n    ll last=0;rep(i,1,n)rep(j,1,i-1)last=(last+f[i][j])%mod;\n    cout<<last*ksm(2,q)%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define HALF 500000004\n\nint n, m, x[3005];\nlong long f[3005][3005], ans, mul = 1;\n\nint ta, tb;\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", x + i);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tf[i][j] = x[i] < x[j];\n\twhile (m--) {\n\t\tmul = (mul << 1) % MOD;\n\t\tscanf(\"%d%d\", &ta, &tb);\n\t\tta--;\n\t\ttb--;\n\t\tf[ta][tb] = f[tb][ta] = HALF * (f[ta][tb] + f[tb][ta]) % MOD;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (i != ta && i != tb) {\n\t\t\t\tf[i][ta] = f[i][tb] = HALF * (f[i][ta] + f[i][tb]) % MOD;\n\t\t\t\tf[ta][i] = f[tb][i] = HALF * (f[ta][i] + f[tb][i]) % MOD;\n\t\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tans += f[j][i];\n\tprintf(\"%lld\\n\", ans % MOD * mul % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(0) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTIOn TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 3e3 + 10, K = 1e2 + 10, B = 1000, oo = 1e18, M = 1e9 + 7, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2, EPS = 1e-9;\n\n\nint dp[N][N], used[N], pw[N];\nvpi flex;\n\nvoid inc(int a, int b, int v)\n{\n    flex.push_back(mp(a * N + b, v));\n}\n\n\nint MOD(int v)\n{\n    v %= M;\n    if (v < 0)\n        v += M;\n\n    return v;\n}\n\n\nvoid smain() {\n    pw[0] = 1;\n    for (int i = 1; i < N; ++i)\n        pw[i] = MOD(pw[i - 1] * 2);\n\n    int n, q;\n    cin >> n >> q;\n\n    vi kek(n);\n    for (int i = 0; i < n; ++i)\n        cin >> kek[i];\n\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n        {\n            if (kek[i] < kek[j])\n                dp[i][j] = 1;\n            else if (kek[i] > kek[j])\n                dp[j][i] = 1;\n        }\n\n    fill(used, used + N, -1);\n\n\n    for (int i = 0; i < q; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        flex.clear();\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            dp[a][j] *= pw[i - max(used[a], used[j]) - 1];\n            dp[b][j] *= pw[i - max(used[b], used[j]) - 1];\n            dp[j][a] *= pw[i - max(used[a], used[j]) - 1];\n            dp[j][b] *= pw[i - max(used[b], used[j]) - 1];\n        }\n\n        dp[a][b] *= pw[i - max(used[a], used[b]) - 1];\n        dp[b][a] *= pw[i - max(used[a], used[b]) - 1];\n        used[a] = used[b] = i;\n\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            inc(a, j, dp[b][j]);\n            inc(b, j, dp[a][j]);\n            inc(j, a, dp[j][b]);\n            inc(j, b, dp[j][a]);\n        }\n\n        inc(a, b, dp[b][a]);\n        inc(b, a, dp[a][b]);\n\n\n        for (auto p : flex)\n        {\n            int a, b, v;\n            tie(a, v) = p;\n\n            b = a % N;\n            a /= N;\n            dp[a][b] += v;\n        }\n    }\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            dp[i][j] *= pw[q - max(used[i], used[j]) - 1];\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            ans += dp[j][i];\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<long long MOD>\nclass Num {\nprivate:\n\tlong long expow(long long base, long long e) const {\n\t\tlong long ans = 1;\n\t\tfor (; e > 0; e/= 2) {\n\t\t\tif (e % 2)\n\t\t\t\tans = ans * base % MOD;\n\t\t\tbase = base * base % MOD; }\n\t\treturn ans; }\n\npublic:\n\tlong long val;\n\n\tNum(long long _val) {\n\t\tval = _val % MOD;\n\t\tval = val < 0 ? val + MOD : val; }\n\tNum() : val(0) { }\n\n\tinline Num operator + (const Num &arg) const {\n\t\tNum res;\n\t\tres.val = val + arg.val;\n\t\tres.val = res.val >= MOD ? res.val - MOD : res.val;\n\t\treturn res; }\n\n\tinline Num operator - (const Num &arg) const {\n\t\tNum res;\n\t\tres.val = val - arg.val;\n\t\tres.val = res.val < 0 ? res.val + MOD : res.val;\n\t\treturn res; }\n\n\tinline Num operator - () const {\n\t\tNum res;\n\t\tres.val = MOD - res.val;\n\t\tres.val = res.val == MOD ? 0 : res.val;\n\t\treturn res; }\n\n\tinline Num operator ^ (const int &arg) const {\n\t\treturn Num(expow(val, arg)); }\n\n\tinline Num operator * (const Num &arg) const {\n\t\treturn Num(val * arg.val); }\n\n\tinline Num operator / (const Num &arg) const {\n\t\treturn Num(val * expow(arg.val, MOD - 2)); }\n\n\tinline void operator += (const Num &arg) {\n\t\t(*this) = (*this) + arg; }\n\n\tinline void operator -= (const Num &arg) {\n\t\t(*this) = (*this) - arg; }\n\n\tinline void operator *= (const Num &arg) {\n\t\t(*this) = (*this) * arg; }\n\n\tinline void operator /= (const Num &arg) {\n\t\t(*this) = (*this) / arg; }\n\n\tinline void operator ^= (const long long &arg) {\n\t\tval = expow(val, arg); } };\n\ntemplate<long long MOD>\nostream &operator << (ostream &fo, const Num<MOD> &c) {\n\tfo << c.val;\n\treturn fo; }\n\ntemplate<long long MOD>\nistream &operator >> (istream &fi, Num<MOD> &c) {\n\tfi >> c.val;\n\tc = Num<MOD>(c.val);\n\treturn fi; }\n\nconst int N = 3005, MOD = 1e9 + 7;\nconst Num<MOD> HALF = Num<MOD>(1) / 2;\n\nint n, q;\n\nvector<vector<Num<MOD>>> dp[2];\nvector<int> v;\n\nint main() {\n#ifdef HOME\n\tfreopen(\"agc30d.in\", \"r\", stdin);\n\tfreopen(\"agc30d.out\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false); \n\tcin.tie(0), cout.tie(0);\n\tNum<MOD> ant;\n\tint l, r;\n\n\tcin >> n >> q;\n\tv.resize(n);\n\tfor (auto &i: v)\n\t\tcin >> i;\n\n\tdp[0] = dp[1] = vector<vector<Num<MOD>>>(n, vector<Num<MOD>>(n));\n\tfor (int i = 0; i < n; ++i)\n\tfor (int j = 0; j < n; ++j)\n\t\tdp[0][i][j] = Num<MOD> {int(v[i] > v[j])};\n\n\tfor (int u = 0; u < q; ++u) {\n\t\tcin >> l >> r;\n\t\tif (--l == --r)\n\t\t\tcontinue;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (i != l && i != r) {\n\t\t\t\tdp[1][i][l] = (dp[0][i][l] + dp[0][i][r]) * HALF;\n\t\t\t\tdp[1][l][i] = (dp[0][l][i] + dp[0][r][i]) * HALF;\n\n\t\t\t\tdp[1][i][r] = (dp[0][i][l] + dp[0][i][r]) * HALF;\n\t\t\t\tdp[1][r][i] = (dp[0][l][i] + dp[0][r][i]) * HALF; }\n\n\t\tdp[1][r][l] = dp[1][l][r] = (dp[0][l][r] + dp[0][r][l]) * HALF;\n\n\t\tfor (int i = 0; i < n; ++i) if (i != l && i != r)\n\t\tfor (int j = 0; j < n; ++j) if (j != l && j != r)\n\t\t\tdp[1][i][j] = dp[0][i][j];\n\t\tswap(dp[0], dp[1]); }\n\n\tfor (int i = 0; i < n; ++i)\n\tfor (int j = i + 1; j < n; ++j)\n\t\tant+= dp[0][i][j];\n\n\tcout << (ant * (Num<MOD>(2) ^ q)) << endl;\n\n\treturn 0; }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst ll Mod=1e9+7;\nint n,q,a[3010];\nll f[3010][3010],inv2;\nvoid upd(ll &x,ll v)\n{\n\tx=(x+v)%Mod;\n}\nll pw(ll x,ll y)\n{\n\tll res=1;\n\twhile (y)\n\t{\n\t\tif (y&1)\n\t\t{\n\t\t\tres=res*x%Mod;\n\t\t}\n\t\tx=x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tinv2=(Mod+1)/2;\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif (a[i]>a[j])\n\t\t\t{\n\t\t\t\tf[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int cas=0;cas<q;cas++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tll tmp;\n\t\ttmp=f[x][y]+f[y][x];\n\t\tf[x][y]=f[y][x]=tmp*inv2%Mod;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (i==x || i==y)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp=f[x][i]+f[y][i];\n\t\t\tf[x][i]=f[y][i]=tmp*inv2%Mod;\n\t\t\ttmp=f[i][x]+f[i][y];\n\t\t\tf[i][x]=f[i][y]=tmp*inv2%Mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tupd(ans,f[i][j]);\n\t\t}\n\t}\n\tcout<<ans*pw(2,q)%Mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair <int,int> ii;\ntypedef long long LL;\n#define pb push_back\nconst int INF = 2147483647;\nconst int MOD = 1000000007;\nconst int N = 3005;\n\nint n, q, i, j, tab[N], GR[N][N], LE[N][N], GR1[N][N], LE1[N][N], a[N], b[N], a1, b1, res, k, mn;\n\nint div(int w) {\n\tif (w % 2 == 0) return w / 2;\n\treturn (w + MOD) / 2;\n}\n\nint main() {\nscanf(\"%d %d\", &n, &q);\nfor (i=1;i<=n;i++) scanf(\"%d\", &tab[i]);\nfor (i=0;i<q;i++) {\n\tscanf(\"%d %d\", &a[i], &b[i]);\n\tif (a[i] > b[i]) swap(a[i], b[i]);\n}\nfor (i=1;i<=n;i++) for (j=i + 1;j<=n;j++) {\n\tGR[i][j] = tab[i] > tab[j] ? 1 : 0;\n\tLE[i][j] = tab[i] < tab[j] ? 1 : 0;\n}\nmn = 1;\nfor (k = 0;k < q;k++) {\n\tmn = (mn * 2) % MOD;\n\ta1 = a[k];\n\tb1 = b[k];\n\tGR1[a1][b1] = LE1[a1][b1] = div((GR[a1][b1] + LE[a1][b1]) % MOD);\n\tfor (i = 1;i < a1;i++) {\n\t\tGR1[i][a1] = div((GR[i][a1] + GR[i][b1]) % MOD);\n\t\tLE1[i][a1] = div((LE[i][a1] + LE[i][b1]) % MOD);\n\t}\t\t\n\tfor (i = a1 + 1;i <= n;i++) if (i != b1) {\n\t\tGR1[a1][i] = div((GR[a1][i] + (i > b1 ? GR[b1][i] : LE[i][b1])) % MOD);\n\t\tLE1[a1][i] = div((LE[a1][i] + (i > b1 ? LE[b1][i] : GR[i][b1])) % MOD);\n\t}\n\tfor (i = 1;i<b1;i++) if (i != a1) {\n\t\tGR1[i][b1] = div((GR[i][b1] + (i < a1 ? GR[i][a1] : LE[a1][i])) % MOD);\n\t\tLE1[i][b1] = div((LE[i][b1] + (i < a1 ? LE[i][a1] : GR[a1][i])) % MOD);\n\t}\n\tfor (i = b1 + 1; i<= n;i++) {\n\t\tGR1[b1][i] = div((GR[b1][i] + GR[a1][i]) % MOD);\n\t\tLE1[b1][i] = div((LE[b1][i] + LE[a1][i]) % MOD);\n\t}\n\t\n\tfor (i=1;i<=n;i++) if (i != a1) {\n\t\tGR[min(a1, i)][max(a1, i)] = GR1[min(a1, i)][max(a1, i)];\n\t\tLE[min(a1, i)][max(a1, i)] = LE1[min(a1, i)][max(a1, i)];\n\t}\n\tfor (i=1;i<=n;i++) if (i != b1) {\n\t\tGR[min(b1, i)][max(b1, i)] = GR1[min(b1, i)][max(b1, i)];\n\t\tLE[min(b1, i)][max(b1, i)] = LE1[min(b1, i)][max(b1, i)];\n\t}\n}\n\nres = 0;\nfor (i=1;i<=n;i++) for (j=i + 1;j<=n;j++) {\n\tres = ((GR[i][j] * 1LL * mn) + res) % MOD; \n\t//printf(\"%d %d %d\\n\", i, j, res);\n}\nprintf(\"%d\\n\", res);\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int mod=1000000007;\nconst int inv2=mod+1>>1;\nconst int Maxn=3005;\nint n,q,a[Maxn];\nint p[Maxn][Maxn],ans;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor (int i=1;i<=n;++i) for (int j=1;j<=n;++j) p[i][j]=a[i]>a[j];\n\tfor (int q_=0;q_<q;++q_)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tp[x][y]=p[y][x]=1LL*(p[x][y]+p[y][x])*inv2%mod;\n\t\tfor (int i=1;i<=n;++i) if(i!=x && i!=y)\n\t\t\tp[i][x]=p[i][y]=1LL*(p[i][x]+p[i][y])*inv2%mod,\n\t\t\tp[x][i]=p[y][i]=1LL*(p[x][i]+p[y][i])*inv2%mod;\n\t}\n\tfor (int i=1;i<=n;++i) for (int j=n;j>i;--j) ans=(ans+p[i][j])%mod;\n\tfor (int i=0;i<q;++i) ans=(ans<<1)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <Mylib/Debug/debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T> void puts_all(const T &value){std::cout << value << \"\\n\";}\ntemplate <typename T, typename ...Args> void puts_all(const T &value, const Args&... args){std::cout << value << \" \";puts_all(args...);}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\ntemplate <typename T> auto make_vector(int n, int m, const T &value){return vector<vector<T>>(n, vector<T>(m, value));}\n\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n  }\n}init;\n\n\ntemplate <std::uint32_t M> class ModInt{\npublic:\n  std::uint64_t val;\n  ModInt(): val(0){}\n  ModInt(std::int64_t n){\n    if(n >= M) val = n % M;\n    else if(n < 0) val = n % M + M;\n    else val = n;\n  }\n  \n  inline constexpr auto operator+(const ModInt &a) const {return ModInt(val + a.val);}\n  inline constexpr auto operator-(const ModInt &a) const {return ModInt(val - a.val);}\n  inline constexpr auto operator*(const ModInt &a) const {return ModInt(val * a.val);}\n  inline constexpr auto operator/(const ModInt &a) const {return ModInt(val * a.inv().val);}\n  \n  inline constexpr auto& operator=(const ModInt &a){val = a.val; return *this;}\n  inline constexpr auto& operator+=(const ModInt &a){if((val += a.val) >= M) val -= M; return *this;}\n  inline constexpr auto& operator-=(const ModInt &a){if(val < a.val) val += M; val -= a.val; return *this;}\n  inline constexpr auto& operator*=(const ModInt &a){(val *= a.val) %= M; return *this;}\n  inline constexpr auto& operator/=(const ModInt &a){(val *= a.inv().val) %= M; return *this;}\n\n  inline constexpr bool operator==(const ModInt &a) const {return val == a.val;}\n  inline constexpr bool operator!=(const ModInt &a) const {return val != a.val;}\n\n  inline constexpr auto& operator++(){*this += 1; return *this;}\n  inline constexpr auto& operator--(){*this -= 1; return *this;}\n\n  inline constexpr auto operator++(int){auto t = *this; *this += 1; return t;}\n  inline constexpr auto operator--(int){auto t = *this; *this -= 1; return t;}\n\n  inline constexpr static auto frac(std::int64_t a, std::int64_t b){\n    return ModInt(a) / ModInt(b);\n  }\n  \n  inline constexpr static ModInt power(std::int64_t n, std::int64_t p){\n    if(p < 0) return power(n, -p).inv();\n    \n    ModInt ret = 1, e = n;\n    for(; p; e *= e, p >>= 1) if(p & 1) ret *= e;\n    return ret;\n  }\n\n  inline constexpr auto power(std::int64_t p) const {return power(val, p);}\n  \n  inline constexpr ModInt inv() const {\n    std::int64_t a = val, b = M, u = 1, v = 0;\n    \n    while(b){\n      std::int64_t t = a/b;\n      a -= t*b; std::swap(a,b);\n      u -= t*v; std::swap(u,v);\n    }\n    u %= M;\n    if(u < 0) u += M;\n    \n    return u;\n  }\n};\n\ntemplate <std::uint32_t M> auto operator-(const ModInt<M> &a){return ModInt<M>(-a.val);}\n\ntemplate <std::uint32_t M> auto operator+(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) + b;}\ntemplate <std::uint32_t M> auto operator-(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) - b;}\ntemplate <std::uint32_t M> auto operator*(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) * b;}\ntemplate <std::uint32_t M> auto operator/(std::int64_t a, const ModInt<M> &b){return ModInt<M>(a) / b;}\n\ntemplate <std::uint32_t M> std::istream& operator>>(std::istream &is, ModInt<M> &a){is >> a.val; return is;}\ntemplate <std::uint32_t M> std::ostream& operator<<(std::ostream &os, const ModInt<M> &a){os << a.val; return os;}\n\n\nusing mint = ModInt<1000000007>;\n\n\nconst mint div_2 = mint::frac(1, 2);\n\nint main(){\n  int N, Q; cin >> N >> Q;\n\n  vector<int> A(N); cin >> A;\n\n  vector<int> X(Q), Y(Q);\n  REP(i,Q){\n    cin >> X[i] >> Y[i];\n    --X[i], --Y[i];\n  }\n\n  auto dp = make_vector<mint>(N, N, 0);\n\n  REP(i,N){\n    REP(j,N){\n      if(A[i] > A[j]) dp[i][j] = 1;\n    }\n  }\n\n  REP(i,Q){\n    int x = X[i], y = Y[i];\n\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * div_2;\n\n    REP(j,N){\n      if(j == x or j == y) continue;\n\n      dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) * div_2;\n      dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) * div_2;\n    }\n  }\n\n\n  mint ans = 0;\n\n  REP(i,N){\n    FOR(j,i+1,N){\n      ans += dp[i][j];\n    }\n  }\n\n  ans *= mint::power(2, Q);\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nconst int maxn = 3005;\nint n, q;\nint a[maxn];\n\nint dp[maxn][maxn], tmp[maxn][maxn];\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nconst int inv = (mod + 1) / 2;\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> q;\n    for(int i = 1;i <= n;i++){\n        cin >> a[i];\n    }\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            if(a[i] > a[j]){\n                dp[i][j] = 1;\n            }else{\n                dp[i][j] = 0;\n            }\n        }\n    }\n    int power = 1;\n    for(int i = 1;i <= q;i++){\n        int x, y;\n        cin >> x >> y;\n        for(int j = 1;j <= n;j++){\n            tmp[j][x] = dp[j][x];\n            tmp[j][y] = dp[j][y];\n            tmp[x][j] = dp[x][j];\n            tmp[y][j] = dp[y][j];\n        }\n        for(int j = 1;j <= n;j++){\n            if(j == x or j == y)\n                continue;\n            dp[j][x] = dp[j][y] = 1LL * inv * (tmp[j][y] + tmp[j][x]) % mod;\n            dp[x][j] = dp[y][j] = 1LL * inv * (tmp[x][j] + tmp[y][j]) % mod;\n        }\n        dp[x][y] = dp[y][x] = 1LL * inv * (tmp[x][y] + tmp[y][x]) % mod;\n        power = power * 2 % mod;\n    }\n    int ans = 0;\n    for(int i = 1;i <= n;i++){\n        for(int j = i + 1;j <= n;j++){\n            dp[i][j] = 1LL * dp[i][j] * power % mod;\n            add(ans, dp[i][j]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=3e3+10, maxm=5e3+10, lg=18, mod=1e9+7, inf=1e18;\n\nll pwm(ll a,ll b){ll ret=1;for(;b;b/=2,a=a*a%mod)if(b%2)ret=ret*a%mod;return ret;}\nll n,q,a[maxn],dp[maxn][maxn],mos[maxn][maxn],i2=pwm(2,mod-2);\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tfor(int j=1;j<i;j++) dp[j][i]=(a[j]>a[i]), mos[i][j]=mos[j][i]=(a[i]==a[j]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tll x,y; cin>>x>>y;\n\t\tif(x>y) swap(x,y);\n\t\tdp[x][y]=(1-mos[x][y]+mod)*i2%mod;\n\t\tfor(int j=x+1;j<y;j++){\n\t\t\tll A=dp[x][j],B=dp[j][y];\n\t\t\tdp[x][j]=(1-(1-A+mod)*i2%mod-(B+mos[j][y])*i2%mod+2*mod)%mod;\n\t\t\tdp[j][y]=(1-(1-B+mod)*i2%mod-(A+mos[x][j])*i2%mod+2*mod)%mod;\n\t\t}\n\t\tfor(int j=1;j<x;j++) dp[j][x]=dp[j][y]=(dp[j][x]+dp[j][y])*i2%mod;\n\t\tfor(int j=y+1;j<=n;j++) dp[x][j]=dp[y][j]=(dp[x][j]+dp[y][j])*i2%mod;\n\t\tfor(int j=1;j<=n;j++)if(j!=x&&j!=y) mos[x][j]=mos[j][x]=mos[j][y]=mos[y][j]=(mos[x][j]+mos[j][y])*i2%mod;\n\t}\n\tll sum=0; for(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++) sum+=dp[i][j], sum%=mod;\n\tcout<<sum*pwm(2,q)%mod;\n\t\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pdi = pair<double, int>;\ntemplate <class T> using mat = vector<vector<T>>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\n\n#define each(i,v) for (auto i = begin(v); i != end(v); ++i)\n#define reach(i,v) for (auto i = rbegin(v); i != rend(v); ++i)\n#define urep(i,s,t) for (int i = (s); i <= (t); ++i)\n#define drep(i,s,t) for (int i = (s); i >= (t); --i)\n#define rep(i,n) urep(i, 0, (n)-1)\n#define rep1(i,n) urep(i, 1, (n))\n#define rrep(i,n) drep(i, (n)-1, 0)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define front fro\n#define back bac\n#define vct vector\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper(uint_fast8_t prec) {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout << fixed << setprecision(prec);\n#ifdef Local\n        auto print_atexit = []() { cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\"; };\n        atexit(print_atexit);\n#endif\n    }\n} setuppre_obj(10);\n\nnamespace std {\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> ostream& operator << (ostream& s, pair<T,U> p) { return s << p.fir << \" \" << p.sec; }\ntemplate <class T> ostream& operator << (ostream& s, vct<T> v) { each(i,v) { if(i != begin(v)) s << \" \"; s << *i; } return s; }\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\nconst auto add = [](auto &x, auto y) { x += y; };\nconst auto mul = [](auto &x, auto y) { x *= y; };\nconst auto lam_min = [](auto x, auto y) { return min(x, y); };\nconst auto lam_max = [](auto x, auto y) { return max(x, y); };\nconst auto chmax = [](auto &m, auto x) { if(m < x){ m = x; return true; } return false; };\nconst auto chmin = [](auto &m, auto x) { if(m > x){ m = x; return true; } return false; };\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binsr(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> T cmprs(T &v) {\n    T tmp = v, ret = v;\n    sort(all(tmp));\n    tmp.erase(unique(all(tmp)), end(tmp));\n    each(i,ret) *i = l_bnd(all(tmp),*i) - begin(tmp);\n    return ret;\n}\n\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2 - 1;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double gold = 1.618033988;\nconstexpr long double eps = 1e-15;\nconstexpr uint_fast64_t mod = 1e9 + 7;\n\nint n,Q;\nvct<vct<pair<i64,i64>>> up,dw;\nvct<vct<int>> last;\ni64 two[1<<12];\n\nvoid upd(int i,int j,int t) {\n    if(t==last[i][j]) return;\n    up[i][j].fir=up[i][j].fir*two[t-1-last[i][j]]%mod;\n    dw[i][j].fir=dw[i][j].fir*two[t-1-last[i][j]]%mod;\n    last[i][j]=t;\n    return;\n}\n\nint main() {\n    cin>>n>>Q;\n    last.rsz(n);\n    up.rsz(n);\n    dw.rsz(n);\n    int a[1<<12];\n    for(int i=0; i<n; i++) last[i].rsz(n);\n    for(int i=0; i<n; i++) up[i].rsz(n);\n    for(int i=0; i<n; i++) dw[i].rsz(n);\n    for(int i=0; i<n; i++) cin>>a[i];\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            if(a[i]>a[j]) up[j][i].fir++;\n            if(a[j]>a[i]) dw[j][i].fir++;\n            last[j][i]=-1;\n        }\n    }\n\n    two[0]=1;\n    for(int i=0; i<Q; i++) two[i+1]=two[i]*2%mod;\n\n    for(int i=0; i<Q; i++) {\n        int x,y;\n        cin>>x>>y;\n        if(--x > --y) swap(x,y);\n\n        for(int j=0; j<x; j++) {\n            upd(j,y,i);\n            upd(j,x,i);\n            dw[j][y].sec+=dw[j][x].fir;\n            up[j][y].sec+=up[j][x].fir;\n            dw[j][x].sec+=dw[j][y].fir;\n            up[j][x].sec+=up[j][y].fir;\n        }\n        for(int j=y+1; j<n; j++) {\n            upd(x,j,i);\n            upd(y,j,i);\n            dw[y][j].sec+=dw[x][j].fir;\n            up[y][j].sec+=up[x][j].fir;\n            dw[x][j].sec+=dw[y][j].fir;\n            up[x][j].sec+=up[y][j].fir;\n        }\n        for(int j=x+1; j<y; j++) {\n            upd(j,y,i);\n            upd(x,j,i);\n            dw[j][y].sec+=up[x][j].fir;\n            up[j][y].sec+=dw[x][j].fir;\n            dw[x][j].sec+=up[j][y].fir;\n            up[x][j].sec+=dw[j][y].fir;\n        }\n        {\n            upd(x,y,i);\n            up[x][y].sec+=dw[x][y].fir;\n            dw[x][y].sec+=up[x][y].fir;\n        }\n        for(int j=0; j<n; ++j) {\n            if(j!=x) {\n                upd(min(j,x),max(j,x),i);\n                (up[min(j,x)][max(j,x)].fir+=up[min(j,x)][max(j,x)].sec)%=mod;\n                (dw[min(j,x)][max(j,x)].fir+=dw[min(j,x)][max(j,x)].sec)%=mod;\n            }\n            if(j!=y and j!=x) {\n                upd(min(j,y),max(j,y),i);\n                (up[min(j,y)][max(j,y)].fir+=up[min(j,y)][max(j,y)].sec)%=mod;\n                (dw[min(j,y)][max(j,y)].fir+=dw[min(j,y)][max(j,y)].sec)%=mod;\n            }\n        }\n        for(int j=0; j<n; ++j) {\n            if(j!=x) dw[min(j,x)][max(j,x)].sec=0;\n            if(j!=x) up[min(j,x)][max(j,x)].sec=0;\n            if(j!=y) dw[min(j,y)][max(j,y)].sec=0;\n            if(j!=y) up[min(j,y)][max(j,y)].sec=0;\n        }\n    }\n\n    int ans=0;\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            upd(j,i,Q);\n            ans=(ans+dw[j][i].fir)%mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout)\nusing namespace std;\nconst int N = 3e3 + 7, mod = 1e9 + 7;\n\n#define inc(i, x, y) for (int i = x; i <= y; ++i)\n#define dec(i, x, y) for (int i = x; i >= y; --i)\n#define gc getchar\n\nbool chkmin(int &x, int y) { return x > y ? x = y, 1 : 0; }\nbool chkmax(int &x, int y) { return x < y ? x = y, 1 : 0; }\n\nint rd() {\n\tint ret = 0; bool fl = 0; char ch = 0;\n\twhile (!isdigit(ch)) fl |= (ch == '-'), ch = gc();\n\twhile (isdigit(ch)) ret = (ret << 1) + (ret << 3) + (ch ^ 48), ch = gc();\n\treturn fl ? -ret : ret;\n}\n\nint a[N], x[N], y[N];\nll ans, dp[N][N];\n\nll add(ll x, ll y) { return x + y > mod ? x - mod + y : x + y; }\n\nll qpow(ll x, int y) {\n\tll ret = 1ll;\n\tfor ( ;y; y >>= 1, x = 1ll * x * x % mod) if (y & 1) ret = 1ll * ret * x % mod;\n\treturn ret;\n}\n\nint main() {\n\tint n = rd(), q = rd();\n\tll sum = qpow(2, q), inv2 = qpow(2, mod - 2);\n\tinc(i, 1, n) a[i] = rd();\n\tinc(i, 1, q) x[i] = rd(), y[i] = rd();\n\tinc(i, 1, n) inc(j, 1, n) dp[i][j] = (a[i] < a[j] ? sum : 0);\n\tinc(i, 1, q) {\n\t\tdp[x[i]][y[i]] = dp[y[i]][x[i]] = 1ll * add(dp[x[i]][y[i]], dp[y[i]][x[i]]) * inv2 % mod;\n\t\tinc(j, 1, n) {\n\t\t\tif (j == x[i] && j == y[i]) continue;\n\t\t\tdp[j][y[i]] = dp[y[i]][j] = 1ll * add(dp[j][y[i]], dp[y[i]][j]) * inv2 % mod;\n\t\t\tdp[x[i]][j] = dp[j][x[i]] = 1ll * add(dp[x[i]][j], dp[j][x[i]]) * inv2 % mod;\n\t\t}\n\t}\n\tinc(i, 2, n) dec(j, i - 1, 1) ans = add(ans, dp[i][j]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+5,Mod=1e9+7,inv2=(Mod+1)/2;\nint a[N],f[N][N],g[N][N];\nint main (){\n\tint n,q;scanf (\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;i++) scanf (\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j];\n\tint pw=1;\n\twhile (q--){\n\t\tpw=2ll*pw%Mod;\n\t\tint x,y;scanf (\"%d%d\",&x,&y);\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y){\n\t\t\t\tg[i][x]=1ll*inv2*(f[i][x]+f[i][y])%Mod;\n\t\t\t\tg[x][i]=1ll*inv2*(f[x][i]+f[y][i])%Mod;\n\t\t\t\tg[i][y]=1ll*inv2*(f[i][y]+f[i][x])%Mod;\n\t\t\t\tg[y][i]=1ll*inv2*(f[y][i]+f[x][i])%Mod;\n\t\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y)\n\t\t\t\tf[i][x]=g[i][x],f[x][i]=g[x][i],f[i][y]=g[i][y],f[y][i]=g[y][i];\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%Mod;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tans=(ans+1ll*pw*f[i][j])%Mod;\n\tprintf (\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define int long long\n#define mod 1000000007\n#define inv2 500000004\nint n,m,a[3010],f[3010][3010],g[3010][3010],A,B,ans;\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tf[i][j]=a[i]>a[j];\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tif(A>B)A^=B^=A^=B;\n\t\tfor(int i=1;i<A;i++)\n\t\t\tg[i][A]=(f[i][A]+f[i][B])%mod*inv2%mod;\n\t\tfor(int i=A+1;i<B;i++)\n\t\t\tg[A][i]=(f[A][i]+1-f[i][B]+mod)%mod*inv2%mod;\n\t\tfor(int i=B+1;i<=n;i++)\n\t\t\tg[A][i]=(f[A][i]+f[B][i])%mod*inv2%mod;\n\t\tfor(int i=1;i<A;i++)\n\t\t\tg[i][B]=(f[i][B]+f[i][A])%mod*inv2%mod;\n\t\tfor(int i=A+1;i<B;i++)\n\t\t\tg[i][B]=(f[i][B]+1-f[A][i]+mod)%mod*inv2%mod;\n\t\tfor(int i=B+1;i<=n;i++)\n\t\t\tg[B][i]=(f[B][i]+f[A][i])%mod*inv2%mod;\n\t\tfor(int i=1;i<A;i++)\n\t\t\tf[i][A]=g[i][A];\n\t\tfor(int i=A+1;i<=n;i++)\n\t\t\tf[A][i]=g[A][i];\n\t\tfor(int i=1;i<B;i++)\n\t\t\tf[i][B]=g[i][B];\n\t\tfor(int i=B+1;i<=n;i++)\n\t\t\tf[B][i]=g[B][i];\n\t\tf[A][B]=(1-f[A][B]+mod)%mod*inv2%mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t(ans+=f[i][j])%=mod;\n\tfor(int i=1;i<=m;i++)\n\t\t(ans*=2)%=mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(2)\n//#pragma GCC optimize(3)\n//#pragma GCC optimize(4)\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define db double\n#define mp make_pair\n#define pb push_back\n#define pi acos(-1.0)\n#define ll long long\n#define vi vector<int>\n#define mod 1000000007\n#define ld long double\n//#define C 0.5772156649\n#define ls l,m,rt<<1\n#define rs m+1,r,rt<<1|1\n#define pll pair<ll,ll>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pii pair<int,int>\n#define ull unsigned long long\n//#define base 1000000000000000000\n#define fin freopen(\"a.txt\",\"r\",stdin)\n#define fout freopen(\"a.txt\",\"w\",stdout)\n#define fio ios::sync_with_stdio(false);cin.tie(0)\ninline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ninline void sub(ll &a,ll b){a-=b;if(a<0)a+=mod;}\ninline void add(ll &a,ll b){a+=b;if(a>=mod)a-=mod;}\ninline void add(ll &a,ll b,ll c){a+=b;if(a>=c)a-=c;}\ntemplate<typename T>inline T const& MAX(T const &a,T const &b){return a>b?a:b;}\ntemplate<typename T>inline T const& MIN(T const &a,T const &b){return a<b?a:b;}\ninline ll qp(ll a,ll b){ll ans=1;while(b){if(b&1)ans=ans*a%mod;a=a*a%mod,b>>=1;}return ans;}\ninline ll qp(ll a,ll b,ll c){ll ans=1;while(b){if(b&1)ans=ans*a%c;a=a*a%c,b>>=1;}return ans;}\ninline ll mul(ll a,ll b,ll c){return (a*b-(ll)((ld)a*b/c)*c+c)%c;}\ninline ll qm(ll a,ll b,ll c){ll ans=0;while(b){if(b&1)add(ans,a,c);add(a,a,c);b>>=1;}return ans;}\ninline ll qpow(ll a,ll b,ll c){ll ans=1;while(b){if(b&1)ans=mul(ans,a,c);a=mul(a,a,c);b>>=1;}return ans;}\n\nusing namespace std;\n\nconst ull ba=233;\nconst db eps=1e-10;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst int N=3000+10,maxn=100000+10,inf=0x3f3f3f3f;\n\nll dp[N][N];\nint a[N],n;\nint main()\n{\n    int m;scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    ll te=qp(2,m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(a[i]>a[j])\n                dp[i][j]=te;\n    ll inv=qp(2,mod-2);\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;scanf(\"%d%d\",&x,&y);\n        for(int j=1;j<=n;j++)if(j!=x&&j!=y)\n        {\n            ll t1=dp[x][j];add(t1,dp[y][j]);t1=t1*inv%mod;\n            dp[x][j]=dp[y][j]=t1;\n            t1=dp[j][x];add(t1,dp[j][y]);t1=t1*inv%mod;\n            dp[j][x]=dp[j][y]=t1;\n        }\n        ll t1=dp[x][y],t2=dp[y][x];\n        add(t1,t2);t1=t1*inv%mod;\n        dp[x][y]=dp[y][x]=t1;\n    }\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=1+i;j<=n;j++)\n            add(ans,dp[i][j]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n/********************\n3 1\n1 2 3\n1 2\n********************/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=3005,mod=1e9+7;\nint n,q;\nint a[N];\nint dp[N][N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nint Div2(int x){\n\treturn (x&1)?((x+mod)>>1):(x>>1);\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tdp[i][j]=a[i]<a[j]?1:0;\n\tfor (int t=1;t<=q;t++){\n\t\tint a=read(),b=read();\n\t\tfor (register int i=1;i<=n;i++){\n\t\t\tif (i==a||i==b)\n\t\t\t\tcontinue;\n\t\t\tdp[i][a]=dp[i][b]=Div2(dp[i][a]+dp[i][b]);\n\t\t\tdp[a][i]=dp[b][i]=Div2(dp[a][i]+dp[b][i]);\n\t\t}\n\t\tdp[a][b]=dp[b][a]=Div2(dp[a][b]+dp[b][a]);\n\t}\n\tint ans=0;\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<i;j++)\n\t\t\tAdd(ans,dp[i][j]);\n\tans=(LL)ans*Pow(2,q)%mod;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n\nusing namespace std;\n\nconst int maxn=3010;\nconst int mo=1000000007;\n\nint n,m,f[maxn][maxn],z[maxn];\n\nint mul(int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=1ll*ans*a%mo;\n\t\ta=1ll*a*a%mo;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int a=1;a<=n;a++)\n\t\tscanf(\"%d\",&z[a]);\n\tfor (int a=1;a<=n;a++)\n\t\tfor (int b=1;b<=n;b++)\n\t\t\tf[a][b]=(z[a]<z[b]);\n\tint div2=mul(2,mo-2);\n\tfor (int a=1;a<=m;a++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tf[x][y]=f[y][x]=(0ll+f[x][y]+f[y][x])*div2%mo;\n\t\tfor (int b=1;b<=n;b++)\n\t\t\tif (b!=x && b!=y)\n\t\t\t{\n\t\t\t\tf[b][x]=f[b][y]=(0ll+f[b][x]+f[b][y])*div2%mo;\n\t\t\t\tf[x][b]=f[y][b]=(0ll+f[x][b]+f[y][b])*div2%mo;\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor (int a=1;a<=n;a++)\n\t\tfor (int b=a+1;b<=n;b++)\n\t\t{\n\t\t\tans += f[b][a];\n\t\t\tif (ans>=mo) ans-=mo;\n\t\t}\n\tprintf(\"%d\\n\",1ll*ans*mul(2,m)%mo);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 12/29/2018, 10:01:22 PM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(19920725));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n\nconst int MAX_SIZE = 1000010;\nconst long long MOD = 1000000007;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n  }\n}\n\nlong long C(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return ((fact[n] * factinv[k]) % MOD * factinv[n - k]) % MOD;\n  }\n  return 0;\n}\n\nlong long power(long long x, long long n)\n{\n  if (n == 0)\n  {\n    return 1;\n  }\n  else if (n % 2 == 1)\n  {\n    return (x * power(x, n - 1)) % MOD;\n  }\n  else\n  {\n    long long half = power(x, n / 2);\n    return (half * half) % MOD;\n  }\n}\n\nlong long gcd(long long x, long long y)\n{\n  return y ? gcd(y, x % y) : x;\n}\n\nll N;\nll Q;\nll A[3010];\nint X[3010];\nint Y[3010];\nll T[3010][3010];\nll t_half[3010];\nll t_half_rev[3010];\n\nvoid flush()\n{\n  ll ans = 0;\n  for (auto i = 0; i < N; i++)\n  {\n    for (auto j = i + 1; j < N; j++)\n    {\n      ans += T[i][j];\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main()\n{\n  init();\n  cin >> N >> Q;\n  for (auto i = 0; i < N; i++)\n  {\n    cin >> A[i];\n  }\n  for (auto i = 0; i < Q; i++)\n  {\n    cin >> X[i] >> Y[i];\n    X[i]--;\n    Y[i]--;\n  }\n  fill(&T[0][0], &T[0][0] + 3010 * 3010, 0);\n  ll initial = power(2, Q);\n  for (auto i = 0; i < N; i++)\n  {\n    for (auto j = 0; j < N; j++)\n    {\n      if (A[i] > A[j])\n      {\n        T[i][j] = initial;\n      }\n    }\n  }\n  /*\n  for (auto j = 0; j < N; j++)\n  {\n    for (auto k = 0; k < N; k++)\n    {\n      cerr << \"T[\" << j << \"][\" << k << \"] = \" << T[j][k] << endl;\n    }\n  }\n  */\n  ll two_inv = inv[2];\n  for (auto i = 0; i < Q; i++)\n  {\n    int x = X[i];\n    int y = Y[i];\n    for (auto j = 0; j < N; j++)\n    {\n      if (j != x && j != y)\n      {\n        t_half[j] = (T[j][x] + T[j][y]) * two_inv;\n        t_half[j] %= MOD;\n        // cerr << \"t_half[\" << j << \"] = \" << t_half[j] << endl;\n        t_half_rev[j] = (T[x][j] + T[y][j]) * two_inv;\n        t_half_rev[j] %= MOD;\n      }\n    }\n    for (auto j = 0; j < N; j++)\n    {\n      if (j != x && j != y)\n      {\n        T[j][x] = t_half[j];\n        T[j][y] = t_half[j];\n        T[x][j] = t_half_rev[j];\n        T[y][j] = t_half_rev[j];\n      }\n    }\n    ll t = (T[x][y] + T[y][x]) * two_inv;\n    t %= MOD;\n    T[x][y] = t;\n    T[y][x] = t;\n    /*\n    cerr << \"i = \" << i << endl;\n    for (auto j = 0; j < N; j++)\n    {\n      for (auto k = 0; k < N; k++)\n      {\n        cerr << \"T[\" << j << \"][\" << k << \"] = \" << T[j][k] << endl;\n      }\n    }\n    */\n  }\n  flush();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n,q,ans,er=1;\nconst int N=3010,mod=1000000007,inv2=(mod+1)/2;\nint a[N],pos1[N],pos2[N],dp[N][N],tmp[N][N];\nint main()\n{\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=q;++i)scanf(\"%d%d\",&pos1[i],&pos2[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tdp[i][j]=a[i]>a[j];\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(j!=pos1[i]&&j!=pos2[i])\n\t\t\t{\n\t\t\t\ttmp[j][pos1[i]]=tmp[j][pos2[i]]=(LL)inv2*(dp[j][pos1[i]]+dp[j][pos2[i]])%mod;\n\t\t\t\ttmp[pos1[i]][j]=tmp[pos2[i]][j]=(LL)inv2*(dp[pos1[i]][j]+dp[pos2[i]][j])%mod;\n\t\t\t}\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(j!=pos1[i]&&j!=pos2[i])\n\t\t\t{\n\t\t\t\tdp[j][pos1[i]]=dp[j][pos2[i]]=tmp[j][pos1[i]];\n\t\t\t\tdp[pos1[i]][j]=dp[pos2[i]][j]=tmp[pos1[i]][j];\n\t\t\t}\n\t\tdp[pos1[i]][pos2[i]]=dp[pos2[i]][pos1[i]]=(LL)inv2*(dp[pos1[i]][pos2[i]]+dp[pos2[i]][pos1[i]])%mod;\n\t\ter=(er<<1)%mod;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\t(ans+=dp[i][j])%=mod;\n\tcout<<(LL)ans*er%mod;;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 3010;\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nvoid mymul(LL& x,LL v){\n    x=(x*v)%MOD;\n}\nLL cnt_big[SIZE][SIZE],cnt_small[SIZE][SIZE];\nLL inv2=mypow(2,MOD-2);\nint A[SIZE];\nLL &cnt_big0(int x,int y){\n    return cnt_big[x][y];\n}\nLL &cnt_small0(int x,int y){\n    return cnt_small[x][y];\n}\nint main(){\n    int N,Q; R(N,Q);\n    FOR(i,1,N)R(A[i]);\n    FOR(i,1,N)FOR(j,1,N){\n        cnt_big[i][j]=(A[i]>A[j]);\n        cnt_small[i][j]=(A[i]<A[j]);\n    }\n    LL mul=1;\n    REP(i,Q){\n        int x,y; R(x,y);\n        mymul(mul,2);\n        ADD(cnt_big[x][y],cnt_small[x][y]);\n        mymul(cnt_big[x][y],inv2);\n        cnt_small[x][y]=cnt_big[x][y];\n        swap(x,y);\n        ADD(cnt_big[x][y],cnt_small[x][y]);\n        mymul(cnt_big[x][y],inv2);\n        cnt_small[x][y]=cnt_big[x][y];\n        FOR(j,1,N){\n            if(j==x||j==y)continue;\n            ADD(cnt_big0(j,x),cnt_big0(j,y));\n            ADD(cnt_small0(j,x),cnt_small0(j,y));\n            mymul(cnt_big0(j,x),inv2);\n            mymul(cnt_small0(j,x),inv2);\n            cnt_big0(j,y)=cnt_big0(j,x);\n            cnt_small0(j,y)=cnt_small0(j,x);\n            \n            ADD(cnt_big0(x,j),cnt_big0(y,j));\n            ADD(cnt_small0(x,j),cnt_small0(y,j));\n            mymul(cnt_big0(x,j),inv2);\n            mymul(cnt_small0(x,j),inv2);\n            cnt_big0(y,j)=cnt_big0(x,j);\n            cnt_small0(y,j)=cnt_small0(x,j);\n        }\n    }\n    LL an=0;\n    FOR(i,1,N)FOR(j,i+1,N)ADD(an,cnt_big[i][j]);\n    W(an*mul%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 3010;\nconst int mod = 1e9 + 7;\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\tk >>= 1;\n\t\t(x *= x) %= mod;\n\t}\n\treturn ans;\n}\nint v[maxn];\nint n, q;\nlong long dp[maxn][maxn] = {0};\nlong long fx1[maxn], fx2[maxn], fy1[maxn], fy2[maxn];\nvoid out()\n{\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n}\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> q;\n\tfor(int i = 1; i <= n; i ++)\n\t\tcin >> v[i];\n\t//bool asd = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(v[i] > v[j])\n\t\t\t\tdp[i][j] = 1;\n\t//out();\n\tlong long inv2 = power(2, mod - 2);\n\tfor(int t = 1; t <= q; t ++)\n\t{\n\t\t//cout << t << \" : \" << endl;\n\t\t//asd ^= 1;\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tfx1[i] = dp[x][i];\n\t\t\tfx2[i] = dp[i][x];\n\t\t\tfy1[i] = dp[y][i];\n\t\t\tfy2[i] = dp[i][y];\n\t\t}\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tif(x != i && i != y)\n\t\t\t{\n\t\t\t\tdp[i][x] = (fx2[i] * inv2 + fy2[i] * inv2) % mod;\n\t\t\t\tdp[x][i] = (fx1[i] * inv2 + fy1[i] * inv2) % mod;\n\t\t\t\tdp[i][y] = (fy2[i] * inv2 + fx2[i] * inv2) % mod;\n\t\t\t\tdp[y][i] = (fy1[i] * inv2 + fx1[i] * inv2) % mod;\n\t\t\t}\n\t\tdp[x][y] = (fx1[y] * inv2 + fy1[x] * inv2) % mod;\n\t\tdp[y][x] = (fy1[x] * inv2 + fx1[y] * inv2) % mod;\n\t\t//out();\n\t}\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = i + 1; j <= n; j ++)\n\t\t\t(ans += dp[i][j]) %= mod;\n\tcout << ans * power(2, q) % mod << endl;\n\treturn 0;\n}\n/*\n3 2\n1\n2\n1\n1 2\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong A[3000];\nlong Pow(long R){\n\tif(R == 0){\n\t\treturn 1;\n\t}\n\tif(R % 2 == 0){\n\t\tlong t = Pow(R/2);\n\t\treturn t*t % mod;\n\t}\n\treturn 2 * Pow(R-1) % mod;\n}\nlong State[3000*3000];\nvoid Calc(){\n\tint N = rei();\n\tint Q = rei();\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = rel();\n\t}\n\tlong TQ = Pow(Q);\n\tlong HALF = Pow(mod-2);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i != j){\n\t\t\t\tif(A[i]<A[j]){\n\t\t\t\t\tState[i*3000+j] = TQ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tint X = rei()-1;\n\t\tint Y = rei()-1;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(j != X && j != Y){\n\t\t\t\tState[X*3000+j] = (State[X*3000+j]+State[Y*3000+j]) * HALF % mod;\n\t\t\t\tState[Y*3000+j] = State[X*3000+j];\n\t\t\t\tState[j*3000+X] = (State[j*3000+X]+State[j*3000+Y]) * HALF % mod;\n\t\t\t\tState[j*3000+Y] = State[j*3000+X];\n\t\t\t}\n\t\t\tState[X*3000+Y] = (State[X*3000+Y] + State[Y*3000+X]) * HALF % mod;\n\t\t\tState[Y*3000+X] = State[X*3000+Y];\n\t\t}\n\t}\n\tlong count = 0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i+1;j<N;j++){\n\t\t\tcount += State[j*3000+i];\n\t\t}\n\t}\n\tcount %= mod;\n\tcout << count << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/agc030/tasks/agc030_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3002\n#define mod 1000000007\n\nint A[N];\nint dp[N][N][2],dp2[N][N][2];\nint lazy[N][N][2];\n\nint getState(int i,int j) {\n  if(i<j) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint add(int x,int y) {\n  return (x+y)%mod;\n}\nint mul(int x,int y) {\n  return (ll)x*y%mod;\n}\npair<int,pair<int,int> > getTransition(int st,int i,int j,int x,int y) {\n  int ni = i;\n  if(x==i) {\n    ni = y;\n  } else if(ni==y) {\n    ni = x;\n  }\n  int nj = j;\n  if(x==j) {\n    nj = y;\n  } else if(nj==y) {\n    nj = x;\n  }\n  int ijState = getState(i,j);\n  int ni_nj_state = getState(ni,nj);\n  int nst = st;\n  if(ijState!=ni_nj_state) {\n    nst ^=1;\n  }\n  return make_pair(nst,make_pair(ni,nj));\n}\n\nint powerOfTwo[N];\nint getValue(int x,int y,int st,int curQ) {\n  int v = powerOfTwo[curQ- lazy[x][y][st]];\n  return mul(v,dp[x][y][st]);\n}\n\nvoid solve() {\n  int n,q;\n  scanf(\"%d %d\", &n,&q);\n  powerOfTwo[0] = 1;\n  for(int i=1;i<N;++i) {\n    powerOfTwo[i] = mul(powerOfTwo[i-1],2);\n  }\n\n  for(int i=0;i<n;++i) {\n    scanf(\"%d \", &A[i]);\n  }\n\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      if(A[i]==A[j]) {\n        continue;\n      }\n      if(A[i]>A[j]) {\n        ++dp[i][j][1];\n      } else {\n        ++dp[i][j][0];\n      }\n    }\n  }\n\n  int lazy_value = 0;\n  while(q--) {\n    int x,y;scanf(\"%d %d \", &x,&y);\n    if(x>y) {\n      swap(x,y);\n    }\n\n    --x,--y;\n    //optimize by lazy-eval\n    for(int i=0;i<n;++i) {\n      for(int st=0;st<2;++st) {\n        if(i!=x) {\n          dp2[x][i][st] = dp2[i][x][st] = 0;\n          pair<int,pair<int,int> >trans = getTransition(st,i,x,x,y);\n          dp2[trans.second.first][trans.second.second][trans.first] = 0;\n          trans = getTransition(st,x,i,x,y);\n          dp2[trans.second.first][trans.second.second][trans.first] = 0;\n        }\n        if(i!=y && i!=x) {\n          dp2[y][i][st] = dp2[i][y][st] = 0;\n          pair<int,pair<int,int> >trans = getTransition(st,i,y,x,y);\n          dp2[trans.second.first][trans.second.second][trans.first] = 0;\n          trans = getTransition(st,y,i,x,y);\n          dp2[trans.second.first][trans.second.second][trans.first] = 0;\n        }\n      }\n    }\n    for(int i=0;i<n;++i) {\n      for(int st=0;st<2;++st) {\n        if(i!=x) {\n          //dp2[i][x][st] = 0;\n          int val = getValue(i,x,st,lazy_value);\n          pair<int,pair<int,int> >trans = getTransition(st,i,x,x,y);\n\n          dp2[i][x][st] = add(dp2[i][x][st], val);\n          dp2[trans.second.first][trans.second.second][trans.first] =\n          add(dp2[trans.second.first][trans.second.second][trans.first],val);\n\n          val = getValue(x,i,st,lazy_value);\n          trans = getTransition(st,x,i,x,y);\n          dp2[x][i][st] = add(dp2[x][i][st], val);\n          dp2[trans.second.first][trans.second.second][trans.first] =\n          add(dp2[trans.second.first][trans.second.second][trans.first],val);\n        }\n        if(i!=y && i!=x) {\n          pair<int,pair<int,int> >trans = getTransition(st,i,y,x,y);\n          int val = getValue(i,y,st,lazy_value);\n          dp2[i][y][st] = add(dp2[i][y][st], val);\n          dp2[trans.second.first][trans.second.second][trans.first] =\n          add(dp2[trans.second.first][trans.second.second][trans.first],val);\n\n          val = getValue(y,i,st,lazy_value);\n          trans = getTransition(st,y,i,x,y);\n          dp2[y][i][st] = add(dp2[y][i][st], val);\n          dp2[trans.second.first][trans.second.second][trans.first] =\n          add(dp2[trans.second.first][trans.second.second][trans.first],val);\n        }\n      }\n    }\n\n    for(int i=0;i<n;++i) {\n      for(int st=0;st<2;++st) {\n        if(i!=x) {\n          dp[x][i][st] = dp2[x][i][st];\n          dp[i][x][st] = dp2[i][x][st];\n          lazy[x][i][st] = lazy_value+1;\n          lazy[i][x][st] = lazy_value+1;\n        }\n        if(i!=y && i!=x) {\n          dp[y][i][st] = dp2[y][i][st];\n          dp[i][y][st] = dp2[i][y][st];\n          lazy[y][i][st] = lazy_value+1;\n          lazy[i][y][st] = lazy_value+1;\n        }\n      }\n    }\n\n    ++lazy_value;\n  }\n  int ret = 0;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      ret = add(ret, getValue(i,j,1,lazy_value));\n    }\n  }\n\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/agc030/tasks/agc030_d\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\nint N,Q;\nint A[3123];\nint X[3123];\nint Y[3123];\nconstexpr int mod = 1e9+7;\nLL dp[3123][3123];\nLL last_update[3123][3123];\nLL x[3123];\nint main(){\n    cin>>N>>Q;\n    for(int i:range(N))cin>>A[i];\n    for(int i:range(Q)){\n        cin>>X[i]>>Y[i];\n        X[i]--;\n        Y[i]--;\n    }\n    x[0]=1;\n    for(int i:range(3120)){\n        x[i+1]=x[i]*2%mod;\n    }\n    for(int i:range(N)){\n        for(int j:range(i+1,N)){\n            if(A[i]<A[j]){\n                dp[i][j]++;\n            }\n            if(A[i]>A[j]){\n                dp[j][i]++;\n            }\n        }\n    }\n    using T=tuple<int,int,LL>;\n    queue<T> que;\n    for(int q:range(Q)){\n        for(int i:range(N)){\n            if(i!=X[q]){\n                dp[i][Y[q]]=dp[i][Y[q]]*x[q-last_update[i][Y[q]]]%mod;\n                last_update[i][Y[q]]=q+1;\n                dp[Y[q]][i]=dp[Y[q]][i]*x[q-last_update[Y[q]][i]]%mod;\n                last_update[Y[q]][i]=q+1;\n\n                que.push(T(i,X[q],dp[i][Y[q]]));\n                que.push(T(X[q],i,dp[Y[q]][i]));\n            }\n            if(i!=Y[q]){\n                dp[i][X[q]]=dp[i][X[q]]*x[q-last_update[i][X[q]]]%mod;\n                last_update[i][X[q]]=q+1;\n                dp[X[q]][i]=dp[X[q]][i]*x[q-last_update[X[q]][i]]%mod;\n                last_update[X[q]][i]=q+1;\n\n                que.push(T(i,Y[q],dp[i][X[q]]));\n                que.push(T(Y[q],i,dp[X[q]][i]));\n            }\n        }\n        dp[X[q]][Y[q]]=dp[X[q]][Y[q]]*x[q-last_update[X[q]][Y[q]]]%mod;\n        last_update[X[q]][Y[q]]=q+1;\n        dp[Y[q]][X[q]]=dp[Y[q]][X[q]]*x[q-last_update[Y[q]][X[q]]]%mod;\n        last_update[Y[q]][X[q]]=q+1;\n        que.push(T(X[q],Y[q],dp[Y[q]][X[q]]));\n        que.push(T(Y[q],X[q],dp[X[q]][Y[q]]));\n        while(que.size()){\n            int i,j;\n            LL p;\n            tie(i,j,p)=que.front();\n            que.pop();\n            dp[i][j]+=p;\n            dp[i][j]%=mod;\n        }\n\n    }\n    LL ret=0;\n    for(int i:range(N)){\n        for(int j:range(N)){\n                dp[i][j]=dp[i][j]*x[Q-last_update[i][j]]%mod;\n                if(i>j)ret+=dp[i][j];\n        }\n    }\n    cout<<ret%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 3e3 + 33, P = 1e9 + 7, div2 = (P + 1) / 2;\n\nint n, m, x, y, a[N], b[N], dp[N][N], tmp[N][N], ans, pw2 = 1;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i), b[i] = a[i];\n\tstd::sort(b + 1, b + n + 1);\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(b + 1, b + n + 1, a[i]) - b;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) dp[i][j] = a[i] > a[j];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int j = 1, u, v; j <= n; j++) {\n\t\t\tu = 1ll * (dp[j][x] + dp[j][y]) * div2 % P;\n\t\t\tv = 1ll * (dp[y][j] + dp[x][j]) * div2 % P;\n\t\t\tdp[j][x] = u, dp[j][y] = u;\n\t\t\tdp[x][j] = v, dp[y][j] = v;\n\t\t}\n\t\tpw2 = pw2 * 2 % P;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) ans = (ans + dp[i][j]) % P;\n\tprintf(\"%lld\", 1ll * ans * pw2 % P);\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define R(i,a,b) for (int i=(a);i<(b);i++)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define N 3055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,ans,a[N],q,f[N][N],x,y;\ninline void add(int &x,int k){x+=k;x-=(x>=mod)?mod:0;}\nint ksm(int x,int k){\n\tint sum=1;\n\twhile (k){\n\t\tif (k&1) sum=(ll)sum*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn sum;\n}\nsigned main(){\n\tn=read();q=read();\n\tF(i,1,n) a[i]=read();\n\tF(i,1,n){\n\t\tF(j,1,n) f[i][j]=(a[i]>a[j]);\n\t}\n\tint inv2=ksm(2,mod-2),num=ksm(2,q);\n\twhile (q--){\n\t\tx=read();y=read();\n\t\tif (x==y) continue;\n\t\tadd(f[x][y],f[y][x]);\n\t\tf[x][y]=f[y][x]=1LL*f[x][y]*inv2%mod;\n\t\tF(i,1,n){\n\t\t\tif (i==x||i==y) continue;\n\t\t\tadd(f[i][x],f[i][y]);\n\t\t\tf[i][y]=f[i][x]=1LL*f[i][x]*inv2%mod;\n\t\t\tadd(f[x][i],f[y][i]);\n\t\t\tf[y][i]=f[x][i]=1LL*f[x][i]*inv2%mod;\n\t\t}\n\t}\n\tF(i,1,n){\n\t\tF(j,i+1,n){\n\t\t\tadd(ans,1LL*f[i][j]*num%mod);\n\t\t}\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass ModInt {\n    using ll = long long;\n\npublic:\n    int value;\n    static int MOD;\n\n    ModInt(ll value = 0) {\n        this->value = value % MOD;\n        if (this->value < 0) this->value += MOD;\n    }\n\n    operator int() const noexcept { return this->value; }\n\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->value = x.value; }\n        return *this;\n    }\n\n    bool operator==(const ModInt& x) const { return this->value == x.value; }\n    bool operator!=(const ModInt& x) const { return !(*this == x); }\n\n    ModInt operator+() const { return value; }\n    ModInt operator-() const { return MOD - value; }\n    ModInt operator~() const { return (*this) ^ ModInt(MOD - 2); }\n\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    ModInt operator+=(const ModInt& x) {\n        int sum = this->value + x.value;\n        return *this = (sum < MOD ? sum : sum - MOD);\n    }\n    ModInt operator-=(const ModInt& x) {\n        int diff = this->value - x.value;\n        return *this = (diff >= 0 ? diff : diff + MOD);\n    }\n    ModInt operator*=(const ModInt& x) { return *this = ll(this->value) * ll(x.value) % MOD; }\n    ModInt operator/=(const ModInt& x) { return *this = (this->value % x.value == 0 ? ModInt(this->value / x.value) : *this * ~x); }\n\n    ModInt operator+=(const int& x) {\n        int sum = this->value + x;\n        return *this = (sum < MOD ? sum : sum - MOD);\n    }\n    ModInt operator-=(const int& x) {\n        int diff = this->value - x;\n        return *this = (diff >= 0 ? diff : diff + MOD);\n    }\n    ModInt operator*=(const int& x) { return *this = ll(this->value) * ll(x) % MOD; }\n    ModInt operator/=(const int& x) { return *this = (this->value % x == 0 ? ModInt(this->value / x) : *this * ~ModInt(x)); }\n\n    template <class T>\n    ModInt operator^=(const T& x) {\n        int n = int(x);\n        if (n == 0) return ModInt(1);\n        if (n & 1) {\n            return (*this) = ((*this) ^ ModInt(n - 1)) * (*this);\n        } else {\n            return (*this) = ((*this) * (*this)) ^ ModInt(n / 2);\n        }\n    }\n\n    template <class T>\n    ModInt operator+(const T& b) const { return ModInt(*this) += b; }\n    template <class T>\n    ModInt operator-(const T& b) const { return ModInt(*this) -= b; }\n    template <class T>\n    ModInt operator*(const T& b) const { return ModInt(*this) *= b; }\n    template <class T>\n    ModInt operator/(const T& b) const { return ModInt(*this) /= b; }\n    template <class T>\n    ModInt operator^(const T& b) const { return ModInt(*this) ^= b; }\n};\n\nint ModInt::MOD = 1000000007;\n\nostream& operator<<(ostream& os, const ModInt& x) { return os << x.value; }\nistream& operator>>(istream& is, ModInt& x) { return is >> x.value; }\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    auto A = Vec<int>(N, 0);\n    for (int& a : A) cin >> a;\n\n    auto dp = Vec<ModInt>(N, N, ModInt(0));\n    // i番目がj番目より大きい確率\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = (A[i] > A[j] ? 1 : 0);\n        }\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        for (int k = 0; k < N; ++k) {\n            if (k == x || k == y) continue;\n            dp[k][x] = (dp[k][x] + dp[k][y]) / 2;\n            dp[k][y] = dp[k][x];\n\n            dp[x][k] = (dp[x][k] + dp[y][k]) / 2;\n            dp[y][k] = dp[x][k];\n        }\n\n        dp[x][y] = (dp[x][y] + dp[y][x]) / 2;\n        dp[y][x] = dp[x][y];\n    }\n\n    ModInt ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << ans * (ModInt(2) ^ Q) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//dengyaotriangle\nusing namespace std;\n\nconst int maxn=3005;\nconst int mdn=1000000007;\nconst int inv2=(mdn+1)>>1;\nint n,q;\nint a[maxn];\npair<int,int> c[maxn];\nlong long dp[maxn][maxn];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++){cin>>a[i];}\n    for(int i=1;i<=q;i++){cin>>c[i].first>>c[i].second;}\n    for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){dp[i][j]=(a[i]<a[j]);}} \n    for(int i=1;i<=q;i++){\n        int u=c[i].first,v=c[i].second;\n        long long mean=(dp[u][v]+dp[v][u])*inv2%mdn;\n        dp[u][v]=dp[v][u]=mean;\n        for(int j=1;j<=n;j++){\n            if(j==u||j==v)continue;\n            long long m1=(dp[j][u]+dp[j][v])*inv2%mdn;\n            dp[j][v]=m1;\n            dp[j][u]=m1;\n            long long m2=(dp[u][j]+dp[v][j])*inv2%mdn;\n            dp[u][j]=m2;\n            dp[v][j]=m2;\n        }\n    }\n    long long ans=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<i;j++){\n            ans+=dp[i][j];\n        }\n    }\n    long long tot=1;\n    for(int i=1;i<=q;i++){tot=(tot<<1)%mdn;}\n    cout<<(ans*tot)%mdn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const i64 mod = 1'000'000'007;\n    i64 N,Q;\n    cin >> N >> Q;\n\n    if(max(Q*N*N,N*N*N)>=300000000){\n        assert(false);\n    }\n\n    vector<i64> A(N);\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<i64> X(Q),Y(Q);\n    rep(i,0,Q){\n        cin >> X[i] >> Y[i];\n        --X[i];\n        --Y[i];\n    }\n\n    const i64 size=3000;\n    static i64 pow2[size+1];\n    pow2[0]=1;\n    rep(i,1,size+1){\n        pow2[i]=pow2[i-1]*2%mod;\n    }\n    static i64 dp[size][size];\n    static i64 last[size][size];\n    fill_n((i64*)dp,size*size,0);\n    fill_n((i64*)last,size*size,-1);\n    rep(i,0,N) {\n        rep(j, 0, N) {\n            if (A[j] <= A[i]) continue;\n            ++dp[j][i];\n        }\n    }\n\n    rep(j,0,Q){\n        i64 x=X[j],y=Y[j];\n\n        auto evaluate=[&](i64 k,i64 l){\n            if(last[k][l]<j){\n                dp[k][l]*=pow2[j-last[k][l]-1];\n                dp[k][l]%=mod;\n            }\n            last[k][l]=j;\n        };\n\n        vector<i64> xk(N),kx(N),yk(N),ky(N);\n        rep(k,0,N){\n            evaluate(x,k);\n            xk[k]=dp[x][k];\n\n            evaluate(k,x);\n            kx[k]=dp[k][x];\n\n            evaluate(y,k);\n            yk[k]=dp[y][k];\n\n            evaluate(k,y);\n            ky[k]=dp[k][y];\n        }\n        rep(k,0,N){\n            if(k==x) continue;\n            dp[x][k]+=yk[k];\n            dp[x][k]%=mod;\n\n            dp[k][x]+=ky[k];\n            dp[k][x]%=mod;\n        }\n\n        rep(k,0,N){\n            if(k==y) continue;\n            dp[y][k]+=xk[k];\n            dp[y][k]%=mod;\n\n            dp[k][y]+=kx[k];\n            dp[k][y]%=mod;\n        }\n\n        dp[y][x]+=xk[y];\n        dp[y][x]%=mod;\n\n        dp[x][y]+=yk[x];\n        dp[x][y]%=mod;\n    }\n\n    i64 ans = 0;\n    rep(j,0,N){\n        rep(k,j+1,N){\n            dp[j][k]*=pow2[Q-last[j][k]-1];\n            dp[j][k]%=mod;\n            ans+=dp[j][k];\n            ans%=mod;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nconst int MAXN = 3005;\nconst int MOD = 1000000007;\n\nint power(int x, int n) {\n    if (n == 0) return 1;\n    if (n&1) return (1LL*x*power(x, n-1))%MOD;\n    int p = power(x, n/2);\n    return (1LL*p*p)%MOD;\n}\n\nint n, q, a[MAXN], dp[MAXN][MAXN];\nint inv2;\n\nint mul(int a, int b) {return (1LL*a*b)%MOD;}\n\nint main () {\n    scanf(\"%d%d\", &n, &q);\n    fto(i, 1, n) scanf(\"%d\", &a[i]);\n\n    fto(i, 1, n)\n        fto(j, 1, n)\n            if (a[i] > a[j]) dp[i][j] = 1;\n\n    inv2 = power(2, MOD-2);\n\n    fto(iq, 1, q) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n\n        int oldYX = dp[y][x], oldXY = dp[x][y];\n\n        vector<int> oldIX(n+1); //dp[i][x]\n        fto(i, 1, n) oldIX[i] = dp[i][x];\n        vector<int> oldIY(n+1); //dp[i][x]\n        fto(i, 1, n) oldIY[i] = dp[i][y];\n\n        vector<int> oldXI(n+1); //dp[y][i]\n        fto(i, 1, n) oldXI[i] = dp[x][i];\n        vector<int> oldYI(n+1); //dp[y][i]\n        fto(i, 1, n) oldYI[i] = dp[y][i];\n\n        dp[y][x] = dp[x][y] = mul(oldXY + oldYX, inv2);\n\n        fto(i, 1, n) {\n            if (i != x)\n                dp[i][y] = mul(dp[i][y] + oldIX[i], inv2);\n            if (i != y)\n                dp[i][x] = mul(dp[i][x] + oldIY[i], inv2);\n        }\n\n        fto(i, 1, n) {\n            if (i != x)\n                dp[y][i] = mul(dp[y][i] + oldXI[i], inv2);\n            if (i != y)\n                dp[x][i] = mul(dp[x][i] + oldYI[i], inv2);\n        }\n    }\n\n    int ans = 0;\n    fto(i, 1, n)\n        fto(j, i+1, n)\n            ans = (ans + dp[i][j])%MOD;\n\n    fto(i, 1, q)\n        ans = (ans * 2)%MOD;\n\n    printf(\"%d\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \n\nconst int N = 4000; \nconst int MOD = 1000000007;\n\ninline int read()\n{\n    char c = getchar(); int x = 0, f = 1;\n    while( c < '0' || c > '9' ) { if( c == '-' ) f = -1; c = getchar(); }\n    while( c >='0' && c <='9' ) { x = x * 10 + c - '0' ; c = getchar(); }\n    return x * f;\n}\n\ninline ll add( ll a, ll b ) { return a + b >= MOD ? a + b - MOD : a + b; }\n\ninline ll dec( ll a, ll b ) { return a - b < 0 ? a - b + MOD : a - b; }\n\ninline ll ksm( ll a, ll b )\n{\n\tll ret = 1; \n\tfor( ; b; b >>= 1, a = a * a % MOD ) \n\t\tif( b & 1 ) ret = ret * a % MOD;\n\treturn ret; \n}\n\nint n, q, a[N];\n\nll f[N][N], temp[N][N]; \n\nint main()\n{\n//\tfreopen( \"d.in\", \"r\", stdin );\n\t\n\tn = read(); q = read(); \n\t\n\tfor( int i = 1; i <= n; i ++ ) \t\n\t\ta[i] = read(); \n\t\t\n\tfor( int i = 1; i <= n; i ++ )\n\t\tfor( int j = 1; j <= n; j ++ )\n\t\t\tf[i][j] = a[i] > a[j] ? 1 : 0;\n\t\t\n\tll inv = ksm( 2, MOD - 2 ); int x, y;\n\tfor( int i = 1; i <= q; i ++ )\n\t{\n\t\tx = read(); y = read(); \n\t\t\n\t\tfor( int j = 1; j <= n; j ++ )\n\t\t\tif( j != x && j != y )\n\t\t\t\tf[x][j] = f[y][j] = inv * add( f[x][j], f[y][j] ) % MOD, \n\t\t\t\tf[j][x] = f[j][y] = inv * add( f[j][x], f[j][y] ) % MOD;\n\t\t\t\n\t\tf[x][y] = f[y][x] = inv * add( f[x][y], f[y][x] ) % MOD;\n\t}  \n\n\tll ans = 0; \n\tfor( int i = 1; i <= n; i ++ )\n\t\tfor( int j = i + 1; j <= n; j ++ )\n\t\t\tans = add( ans, f[i][j] ); \n\t\t\t\n\tans = ans * ksm( 2, q ) % MOD;\n\t\t\t\n\tcout << ans << endl; \n\t\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pdi = pair<double, int>;\ntemplate <class T> using mat = vector<vector<T>>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\n\n#define each(i,v) for (auto i = begin(v); i != end(v); ++i)\n#define reach(i,v) for (auto i = rbegin(v); i != rend(v); ++i)\n#define urep(i,s,t) for (int i = (s); i <= (t); ++i)\n#define drep(i,s,t) for (int i = (s); i >= (t); --i)\n#define rep(i,n) urep(i, 0, (n)-1)\n#define rep1(i,n) urep(i, 1, (n))\n#define rrep(i,n) drep(i, (n)-1, 0)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define front fro\n#define back bac\n#define vct vector\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper(uint_fast8_t prec) {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout << fixed << setprecision(prec);\n#ifdef Local\n        auto print_atexit = []() { cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\"; };\n        atexit(print_atexit);\n#endif\n    }\n} setuppre_obj(10);\n\nnamespace std {\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> ostream& operator << (ostream& s, pair<T,U> p) { return s << p.fir << \" \" << p.sec; }\ntemplate <class T> ostream& operator << (ostream& s, vct<T> v) { each(i,v) { if(i != begin(v)) s << \" \"; s << *i; } return s; }\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\nconst auto add = [](auto &x, auto y) { x += y; };\nconst auto mul = [](auto &x, auto y) { x *= y; };\nconst auto lam_min = [](auto x, auto y) { return min(x, y); };\nconst auto lam_max = [](auto x, auto y) { return max(x, y); };\nconst auto chmax = [](auto &m, auto x) { if(m < x){ m = x; return true; } return false; };\nconst auto chmin = [](auto &m, auto x) { if(m > x){ m = x; return true; } return false; };\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binsr(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> T cmprs(T &v) {\n    T tmp = v, ret = v;\n    sort(all(tmp));\n    tmp.erase(unique(all(tmp)), end(tmp));\n    each(i,ret) *i = l_bnd(all(tmp),*i) - begin(tmp);\n    return ret;\n}\n\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2 - 1;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double gold = 1.618033988;\nconstexpr long double eps = 1e-15;\nconstexpr uint_fast64_t mod = 1e9 + 7;\n\nint n,Q;\ni64 up[1<<12][1<<12],dw[1<<12][1<<12];\nint last[1<<12][1<<12];\ni64 two[1<<12];\n\nvoid upd(int i,int j,int t) {\n    assert(i<j);\n    if(t==last[i][j]) return;\n    assert(t>last[i][j]);\n    up[i][j]=up[i][j]*two[t-1-last[i][j]]%mod;\n    dw[i][j]=dw[i][j]*two[t-1-last[i][j]]%mod;\n    last[i][j]=t;\n    return;\n}\n\nint main() {\n    cin>>n>>Q;\n    int a[1<<12];\n    for(int i=0; i<n; i++) cin>>a[i];\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            if(a[i]>a[j]) up[j][i]++;\n            if(a[j]>a[i]) dw[j][i]++;\n            last[j][i]=-1;\n        }\n    }\n\n    two[0]=1;\n    for(int i=0; i<Q; i++) two[i+1]=two[i]*2%mod;\n\n    for(int i=0; i<Q; i++) {\n        //u_map<pii,int> up_nx,dw_nx;\n        vct<vct<pii>> up_nx(n),dw_nx(n);\n        int x,y;\n        cin>>x>>y;\n        if(--x > --y) swap(x,y);\n\n        for(int j=0; j<x; j++) {\n            upd(j,y,i);\n            upd(j,x,i);\n            dw_nx[j].emb(y,dw[j][x]);\n            up_nx[j].emb(y,up[j][x]);\n            dw_nx[j].emb(x,dw[j][y]);\n            up_nx[j].emb(x,up[j][y]);\n        }\n        for(int j=y+1; j<n; j++) {\n            upd(x,j,i);\n            upd(y,j,i);\n            dw_nx[y].emb(j,dw[x][j]);\n            up_nx[y].emb(j,up[x][j]);\n            dw_nx[x].emb(j,dw[y][j]);\n            up_nx[x].emb(j,up[y][j]);\n        }\n        for(int j=x+1; j<y; j++) {\n            upd(j,y,i);\n            upd(x,j,i);\n            dw_nx[j].emb(y,up[x][j]);\n            up_nx[j].emb(y,dw[x][j]);\n            dw_nx[x].emb(j,up[j][y]);\n            up_nx[x].emb(j,dw[j][y]);\n        }\n        {\n            upd(x,y,i);\n            up_nx[x].emb(y,dw[x][y]);\n            dw_nx[x].emb(y,up[x][y]);\n        }\n        for(int i=0; i<n; ++i) {\n            for(auto p:up_nx[i]) {\n                (up[i][p.fir]+=p.sec)%=mod;\n            }\n            for(auto p:dw_nx[i]) {\n                (dw[i][p.fir]+=p.sec)%=mod;\n            }\n        }\n    }\n\n    int ans=0;\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            upd(j,i,Q);\n            ans=(ans+dw[j][i])%mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7; const long long INV2 = (MOD + 1) / 2;\nint dp[3003][3003] , arr[3003] , N , Q , tms = 1;\n\nint main(){\n\tcin >> N >> Q;\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tcin >> arr[i];\n\t\tfor(int j = i - 1 ; j ; --j){\n\t\t\tdp[i][j] = arr[j] < arr[i];\n\t\t\tdp[j][i] = arr[i] < arr[j];\n\t\t}\n    }\n\tfor(int i = 1 ; i <= Q ; ++i){\n\t\tint x , y; cin >> x >> y;\n\t\tfor(int j = 1 ; j <= N ; ++j)\n\t\t\tif(j != x && j != y){\n\t\t\t\tdp[j][y] = dp[j][x] = (dp[j][x] + dp[j][y]) * INV2 % MOD;\n\t\t\t\tdp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) * INV2 % MOD;\n\t\t\t}\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * INV2 % MOD;\n\t}\n\tint sum = 0;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = i + 1 ; j <= N ; ++j) sum = (sum + dp[i][j]) % MOD;\n\tfor(int i = 1 ; i <= Q ; ++i) sum = (sum << 1) % MOD;\n\tcout << sum; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(...) fprintf (stderr, __VA_ARGS__)\nusing namespace std;\nvoid read (int&a) {\n\ta = 0; char k = getchar(); int f = 1;\n\tfor(;!isdigit(k); k = getchar()) if (k == '-') f = -1;\n\tfor(; isdigit(k); k = getchar()) a = a * 10 + k - '0';\n\ta *= f;\n}\n\nconst int N = 3000 + 5, mod = 1000000007, inv2 = 500000004;\nvoid upd (int&a, int b) { a = (a + b) % mod; }\nint dp[N][N], n, q, a[N], tmp, s = 1;\n\nint main ()\n{\n\tread (n), read (q);\n\tfor (int i = 1; i <= n; ++i) read (a[i]);\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) dp[i][j] = (a[i] > a[j]);\n\twhile (q--) {\n\t\ts = 1LL * s * 2 % mod;\n\t\tint x, y; read (x), read (y);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i != y && i != x) {\n\t\t\t\ttmp = (dp[x][i] + dp[y][i]) % mod;\n\t\t\t\tdp[x][i] = dp[y][i] = tmp;\n\t\t\t\tdp[x][i] = 1LL * dp[x][i] * inv2 % mod, dp[y][i] = 1LL * dp[y][i] * inv2 % mod;\n\t\t\t\ttmp = (dp[i][x] + dp[i][y]) % mod;\n\t\t\t\tdp[i][x] = dp[i][y] = tmp;\n\t\t\t\tdp[i][x] = 1LL * dp[i][x] * inv2 % mod, dp[i][y] = 1LL * dp[i][y] * inv2 % mod;\n\t\t\t}\n\t\t}\n\t\ttmp = (dp[x][y] + dp[y][x]) % mod;\n\t\tdp[x][y] = dp[y][x] = tmp;\n\t\tdp[x][y] = 1LL * dp[x][y] * inv2 % mod, dp[y][x] = 1LL * dp[y][x] * inv2 % mod;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) if (i < j) upd (ans, 1LL * dp[i][j] * s % mod);\n\tprintf (\"%d\\n\", ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef ONPC\n    mt19937 rnd(228);\n#else\n    mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 3000 + 7;\nconst int MOD = 1e9 + 7;\n\nint dp[N][N];\n\nstruct event\n{\n    int x, y, val;\n};\n\nint add(int a, int b)\n{\n    a += b;\n    if (a < 0) a += MOD;\n    if (a >= MOD) a -= MOD;\n    return a;\n}\n\nint mul(int a, int b)\n{\n    return (a * (ll) b) % MOD;\n}\n\nint bin(int a, int n)\n{\n    int res = 1;\n    while (n)\n    {\n        if (n % 2 == 0)\n        {\n            a = mul(a, a);\n            n /= 2;\n        }\n        else\n        {\n            res = mul(res, a);\n            n--;\n        }\n    }\n    return res;\n}\n\nint inv(int x)\n{\n    return bin(x, MOD - 2);\n}\n\nint pw[N];\nint rev_pw[N];\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector <int> a(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] > a[j])\n            {\n                dp[i][j]++;\n            }\n        }\n    }\n    pw[0] = 1;\n    rev_pw[0] = 1;\n    for (int i = 1; i <= q; i++)\n    {\n        pw[i] = mul(pw[i - 1], 2);\n        rev_pw[i] = inv(pw[i]);\n    }\n    for (int i = 0; i < q; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        vector <event> e;\n        e.push_back({y, x, dp[x][y]});\n        e.push_back({x, y, dp[y][x]});\n        for (int i = 0; i < n; i++)\n        {\n            if (i != x && i != y)\n            {\n                e.push_back({y, i, dp[x][i]});\n                e.push_back({x, i, dp[y][i]});\n                e.push_back({i, y, dp[i][x]});\n                e.push_back({i, x, dp[i][y]});\n            }\n        }\n        set <pair <int, int> > q;\n        for (auto c : e)\n        {\n            dp[c.x][c.y] = mul(add(mul(dp[c.x][c.y], pw[i]), mul(c.val, pw[i])), rev_pw[i + 1]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            ans = add(ans, dp[i][j]);\n        }\n    }\n    cout << mul(ans, pw[q]) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=3005,mod=1e9+7;\nint n,q;\nint a[N];\nint dp[N][N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nint Div2(int x){\n\treturn (x&1)?((x+mod)>>1):(x>>1);\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nint add(int x,int y){\n\treturn x+y>=mod?x+y-mod:x+y;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tdp[i][j]=a[i]<a[j]?1:0;\n\tfor (int t=1;t<=q;t++){\n\t\tint a=read(),b=read();\n\t\tfor (register int i=1;i<=n;i++){\n\t\t\tif (i==a||i==b)\n\t\t\t\tcontinue;\n\t\t\tdp[i][a]=dp[i][b]=Div2(add(dp[i][a],dp[i][b]));\n\t\t\tdp[a][i]=dp[b][i]=Div2(add(dp[a][i],dp[b][i]));\n\t\t}\n\t\tdp[a][b]=dp[b][a]=Div2(add(dp[a][b],dp[b][a]));\n\t}\n\tint ans=0;\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<i;j++)\n\t\t\tAdd(ans,dp[i][j]);\n\tans=(LL)ans*Pow(2,q)%mod;\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\nusing namespace std;\nconst int Max_N(3050);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N, Q, A[Max_N], F[Max_N][Max_N], inv2;\n\nint main()\n{\n\tgi(N), gi(Q), inv2 = inverse(2);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(A[i]);\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t\tif (i != j)\n\t\t\t\tF[i][j] = (A[i] > A[j]);\n\tfor (int x, y;Q--;)\n\t{\n\t\tgi(x), gi(y), F[x][y] = F[y][x] = inv2;\n\t\tfor (int i = 1;i <= N;++i)\n\t\t\tif (i != x && i != y)\n\t\t\t{\n\t\t\t\tF[x][i] = F[y][i] = Mult(Add(F[x][i], F[y][i]), inv2);\n             \t\t\tF[i][x] = F[i][y] = Mult(Add(F[i][x], F[i][y]), inv2);\n\t\t\t}\n\t}\n\tint Ans = 0;\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = i + 1;j <= N;++j)\n\t\t\tAns = Add(Ans, F[i][j]);\n\tprint(Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md = 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int)((long long)a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n      b--;\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if(a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t; swap(a, b);\n    u -= v * t; swap(u, v);\n  }\n  assert(b == 1);\n  if(u < 0) u += md;\n  return u;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<vector<int>> dp(n, vector<int>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = (a[i] < a[j]);\n    }\n  }\n  \n  int inv2 = inv(2);\n  int coef = power(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    for (int i = 0; i < n; i++) {\n      if (i != x && i != y){\n        {\n          int tmp = dp[i][x];\n          add(tmp, dp[i][y]);\n          tmp = mul(tmp, inv2);\n          dp[i][x] = dp[i][y] = tmp;\n        }\n        {\n          int tmp = dp[x][i];\n          add(tmp, dp[y][i]);\n          tmp = mul(tmp, inv2);\n          dp[x][i] = dp[y][i] = tmp;\n        }\n      }\n    }\n    {\n      int tmp = dp[x][y];\n      add(tmp, dp[y][x]);\n      tmp = mul(tmp, inv2);\n      dp[x][y] = dp[y][x] = tmp;\n    }\n  }\n\n  int ans = 0;\n  for (int j = 0; j < n; j++) {\n    for (int i = 0; i < j; i++) {\n      add(ans, dp[j][i]);\n    }\n  }\n  ans = mul(ans, coef);\n  cout << ans << '\\n';\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#define Run(i,l,r) for(int i=l;i<=r;i++)\n#define Don(i,l,r) for(int i=l;i>=r;i--)\n#define ll long long\n#define ld long double\n#define inf 0x3f3f3f3f\n#define mk make_pair\n#define fir first\n#define sec second\nusing namespace std;\nconst int N=3010 ,mod=100000007;\nint n,m,a[N],f[N][N],t1[N],t2[N],t3[N],t4[N];\nll iv2=(mod+1)>>1;\nint pw(int x,int y){\n\tint re=1;\n\tfor(int i=y;i;i>>=1,x=(ll)x*x%mod){\n\t\tif(i&1)re=(ll)re*x%mod;\n\t}\n\treturn re;\n}\nint main(){\n//\tfreopen(\"D.in\",\"r\",stdin);\n//\tfreopen(\"D.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++){\n\t\tf[i][j] = bool(a[i] > a[j]);\n\t} \n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;j++)if(j!=y&&j!=x){\n\t\t\tt1[j] = iv2*(f[j][x]+f[j][y])%mod;\n\t\t\tt2[j] = iv2*(f[x][j]+f[y][j])%mod;\n\t\t\tt3[j] = iv2*(f[j][y]+f[j][x])%mod;\n\t\t\tt4[j] = iv2*(f[y][j]+f[x][j])%mod; \n\t\t}\n\t\tfor(int j=1;j<=n;j++)if(j!=y&&j!=x){\n\t\t\tf[j][x] = t1[j];\n\t\t\tf[x][j] = t2[j];\n\t\t\tf[j][y] = t3[j];\n\t\t\tf[y][j] = t4[j];\n\t\t}\n\t\tint t= iv2*(f[x][y]+f[y][x])%mod;\n\t\tf[x][y] = f[y][x]= t;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++){\n\t\tans = (ans + f[i][j])%mod;\n\t}\n\tans = (ll) ans * pw(2,m) %mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}//by tkys_Austin;\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ttgl, null_type,less<ttgl>, rb_tree_tag,tree_order_statistics_node_update>*/\n \nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 3001;\nint n, q;\nint arr[mxN];\nttgl query[mxN];\nll dp_prev[mxN][mxN];\nll dp[mxN][mxN];\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>q;\n    owo(i, 0, n) {\n        cin>>arr[i];\n    }\n    ll inv2 = modInv(2);\n    owo(i, 0, q) {\n        cin>>query[i].first>>query[i].second;\n        if(query[i].first>query[i].second)swap(query[i].first, query[i].second);\n        query[i].first--;\n        query[i].second--;\n    }\n    owo(i, 0, n) {\n        owo(j, 0, n) {\n            if(i==j)continue;\n            if(arr[i]>arr[j]) {\n                dp_prev[i][j] = 1;\n                dp[i][j] = 1;\n            }\n        }\n    }\n    owo(i, 0, q) {\n        int a = query[i].first;\n        int b = query[i].second;\n        owo(j, 0, n) {\n            if(j==a||j==b)continue;\n            dp[j][a] = (dp_prev[j][a]*inv2 + dp_prev[j][b]*inv2)%MOD;\n            dp[a][j] = (dp_prev[a][j]*inv2 + dp_prev[b][j]*inv2)%MOD;\n            dp[j][b] = (dp_prev[j][b]*inv2 + dp_prev[j][a]*inv2)%MOD;\n            dp[b][j] = (dp_prev[b][j]*inv2 + dp_prev[a][j]*inv2)%MOD;\n        }\n        dp[a][b] = (dp_prev[a][b]*inv2 + dp_prev[b][a]*inv2)%MOD;\n        dp[b][a] = dp[a][b];\n        owo(j, 0, n) {\n            dp_prev[j][a] = dp[j][a];\n            dp_prev[j][b] = dp[j][b];\n            dp_prev[a][j] = dp[a][j];\n            dp_prev[b][j] = dp[b][j];\n            \n        }\n    }\n    ll mul = binpow(2, q);\n    ll ans = 0;\n    owo(i, 0, n){\n        owo(j, i+1, n) {\n            ans= (ans + dp[i][j])%MOD;\n        }\n    }\n    ans = (ans*mul)%MOD;\n    cout<<ans<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 3003;\nmint dp[N][N];\n\nvoid solve() {\n    int n,q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (auto& x: a) {\n        cin >> x;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) dp[i][j] = 1;\n        }\n    }\n    mint half = mint(1)/2;\n    for (int _ = 0; _ < q; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--;y--;\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * half;\n        for (int i = 0; i < n; i++) {\n            if (i == x || i == y) continue;\n            dp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) * half;\n            dp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) * half;\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            res += dp[i][j];\n        }\n    }\n    res *= mint(2).exp(q);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#define Run(i,l,r) for(int i=l;i<=r;i++)\n#define Don(i,l,r) for(int i=l;i>=r;i--)\n#define ll long long\n#define ld long double\n#define inf 0x3f3f3f3f\n#define mk make_pair\n#define fir first\n#define sec second\nusing namespace std;\nconst int N=3010 ,mod=1000000007;\nint n,m,a[N],f[N][N],t1[N],t2[N],t3[N],t4[N];\nll iv2=(mod+1)>>1;\nint pw(int x,int y){\n\tint re=1;\n\tfor(int i=y;i;i>>=1,x=(ll)x*x%mod){\n\t\tif(i&1)re=(ll)re*x%mod;\n\t}\n\treturn re;\n}\nint main(){\n//\tfreopen(\"D.in\",\"r\",stdin);\n//\tfreopen(\"D.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++){\n\t\tf[i][j] = bool(a[i] > a[j]);\n\t} \n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;j++)if(j!=y&&j!=x){\n\t\t\tt1[j] = iv2*(f[j][x]+f[j][y])%mod;\n\t\t\tt2[j] = iv2*(f[x][j]+f[y][j])%mod;\n\t\t\tt3[j] = iv2*(f[j][y]+f[j][x])%mod;\n\t\t\tt4[j] = iv2*(f[y][j]+f[x][j])%mod; \n\t\t}\n\t\tfor(int j=1;j<=n;j++)if(j!=y&&j!=x){\n\t\t\tf[j][x] = t1[j];\n\t\t\tf[x][j] = t2[j];\n\t\t\tf[j][y] = t3[j];\n\t\t\tf[y][j] = t4[j];\n\t\t}\n\t\tint t= iv2*(f[x][y]+f[y][x])%mod;\n\t\tf[x][y] = f[y][x]= t;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++){\n\t\tans = (ans + f[i][j])%mod;\n\t}\n\tans = (ll) ans * pw(2,m) %mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}//by tkys_Austin;\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for (ll i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nlong long inv_mod(long long n, long long mod) {\n    long long a = n % mod, b = mod - 2, ret = 1;\n    while (b > 0) {\n        if (b & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nconst ll MOD = 1000000007LL;\nll N,Q;\nll A[3010];\nll X[3010];\nll Y[3010];\n\nll dp[3010][3010];\n\nint main ()\n{\n    cin >> N >> Q;\n    REP(i,N) cin >> A[i + 1];\n    REP(i,Q) cin >> X[i] >> Y[i];\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = (A[i] > A[j]);\n        }\n    }\n\n    ll inv2 = inv_mod(2LL, MOD);\n    for (int i = 0; i < Q; i++) {\n        dp[X[i]][Y[i]] = dp[Y[i]][X[i]] = ((dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv2 % MOD);\n        for (int j = 1; j <= N; j++) {\n            if (X[i] != j && Y[i] != j) {\n                dp[X[i]][j] = dp[Y[i]][j] = ((dp[X[i]][j] + dp[Y[i]][j]) * inv2 % MOD);\n                dp[j][X[i]] = dp[j][Y[i]] = ((dp[j][X[i]] + dp[j][Y[i]]) * inv2 % MOD);\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i; j <= N; j++) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << (ans * pow_mod(2LL, Q, MOD)) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst long long INF = 1e18 + 5;\nconst int MAXN = 1e6;\nconst int base = 317;\n\ntypedef long long ll;\n\nconst ll bs = 1e5 + 1;\nconst ll mod = 1e9 + 7;\n\nint n, a[N];\nll q;\nll dp[3005][3005], d[3005][3005];\nll ans;\n\nll bpow(ll a, ll b) {\n    ll res = 1;\n    while (b) {\n        if (b % 2)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b /= 2;\n    }\n    return res;\n}\n\nmain() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    ll inv = bpow(2, mod - 2);\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 1; i <= q; i++) {\n        int u, v;\n        cin >> u >> v;\n        for (int j = 1; j <= n; j++) {\n            d[u][j] = 0;\n            d[v][j] = 0;\n            d[j][u] = 0;\n            d[j][v] = 0;\n        }\n        ll t = dp[u][v] + dp[v][u];\n        d[u][v] = d[v][u] = t * inv % mod;\n        for (int j = 1; j <= n; j++) {\n            if (u == j || j == v)\n                continue;\n            if (u != j) {\n                d[u][j] = (d[u][j] + (dp[u][j] * inv) % mod) % mod;\n                d[u][j] = (d[u][j] + (dp[v][j] * inv) % mod) % mod;\n            }\n            if (v != j) {\n                d[v][j] = (d[v][j] + (dp[v][j] * inv) % mod) % mod;\n                d[v][j] = (d[v][j] + (dp[u][j] * inv) % mod) % mod;\n            }\n            if (j != u) {\n                d[j][u] = (d[j][u] + (dp[j][u] * inv) % mod) % mod;\n                d[j][u] = (d[j][u] + (dp[j][v] * inv) % mod) % mod;\n            }\n            if (j != v) {\n                d[j][v] = (d[j][v] + (dp[j][v] * inv) % mod) % mod;\n                d[j][v] = (d[j][v] + (dp[j][u] * inv) % mod) % mod;\n            }\n        }\n        for (int j = 1; j <= n; j++) {\n            dp[u][j] = d[u][j];\n            dp[v][j] = d[v][j];\n            dp[j][u] = d[j][u];\n            dp[j][v] = d[j][v];\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            ans = (ans + dp[i][j]) % mod;\n        }\n    }\n    cout << (ans * bpow(2, q)) % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 3003; \nmint dp[2][N][N];\nmint tmp[2][N][N];\n#define rep(i) for(int i=0;i<2;i++)\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (auto& x: a) {\n        cin >> x;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (a[i] > a[j]) dp[0][i][j] = 1;\n            if (a[i] == a[j])dp[1][i][j] = 1;\n        }\n    }\n    auto flip = [&](int& x, int& y){\n        dp[0][x][y] = 1 - dp[0][x][y] - dp[1][x][y];\n    };\n    mint half = mint(1)/2;\n    for (int _ = 0; _ < q; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if (x > y) swap(x, y);\n        memcpy(tmp, dp, sizeof tmp);\n        for (int i = 0; i < x; i++) {\n            rep(_) {\n                swap(dp[_][i][x], dp[_][i][y]);\n                (dp[_][i][x] += tmp[_][i][x]) *= half;\n                (dp[_][i][y] += tmp[_][i][y]) *= half;\n            }\n        }\n        flip(x, y);\n        rep(_)(dp[_][x][y] += tmp[_][x][y]) *= half;\n        for (int i = x+1; i < y; i++) {\n            swap(dp[0][x][i], dp[0][i][y]);\n            swap(dp[1][x][i], dp[1][i][y]);\n            flip(x, i);\n            flip(i, y);\n            rep(_) {\n                (dp[_][x][i] += tmp[_][x][i]) *= half;\n                (dp[_][i][y] += tmp[_][i][y]) *= half;\n            }\n        }\n        for (int i = y+1; i < n; i++) {\n            rep(_) {\n                swap(dp[_][x][i], dp[_][y][i]);\n                (dp[_][x][i] += tmp[_][x][i]) *= half;\n                (dp[_][y][i] += tmp[_][y][i]) *= half;\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            res += dp[0][i][j];\n        }\n    }\n    res *= mint(2).exp(q);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 3005\n#define mo 998244353\nint ksm(int a,int k) {\n    int s=1;\n    while(k)\n\t{\n\t    if(k&1) s=1ll*s*a%mo;\n\t    a=1ll*a*a%mo;\n\t    k>>=1;\n\t}\n    return s;\n}\nint inv=ksm(2,mo-2);\nint n,m;\nint a[M],ans;\nint p[M][M],p2[M][M],g[M][M],g2[M][M];\nvoid pre() {\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) p[i][j]=a[i]>a[j],p2[i][j]=a[i]==a[j];\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    pre();\n    for(int i=1,x,y;i<=m;i++)\n\t{\n\t    cin>>x>>y;\n\t    if(x>y) swap(x,y);\n\t    for(int j=1;j<x;j++)\n\t\t{\n\t\t    g[j][x]=1ll*inv*(p[j][y]+p[j][x])%mo,g2[j][x]=1ll*inv*(p2[j][x]+p2[j][y])%mo;\n\t\t    g[j][y]=1ll*inv*(p[j][y]+p[j][x])%mo,g2[j][y]=1ll*inv*(p2[j][y]+p2[j][x])%mo;\n\t\t}\n\t    for(int j=x+1;j<y;j++)\n\t\t{\n\t\t    g[x][j]=1ll*inv*(p[x][j]+(1-p[j][y]-p2[j][y])%mo+mo)%mo,g2[x][j]=1ll*inv*(p2[x][j]+p2[j][y])%mo;\n\t\t    g[j][y]=1ll*inv*(p[j][y]+(1-p[x][j]-p2[x][j])%mo+mo)%mo,g2[j][y]=1ll*inv*(p2[j][y]+p2[x][j])%mo;\n\t\t}\n\t    for(int j=y+1;j<=n;j++)\n\t\t{\n\t\t    g[x][j]=1ll*inv*(p[x][j]+p[y][j])%mo,g2[x][j]=1ll*inv*(p2[x][j]+p2[y][j])%mo;\n\t\t    g[y][j]=1ll*inv*(p[y][j]+p[x][j])%mo,g2[y][j]=1ll*inv*(p2[y][j]+p2[x][j])%mo;\n\t\t}\n\t    p[x][y]=1ll*inv*(1-p2[x][y]+mo)%mo;\n\t    for(int j=1;j<x;j++)\n\t\t{\n\t\t    p[j][x]=g[j][x],p[j][y]=g[j][y];\n\t\t    p2[j][x]=g2[j][x],p2[j][y]=g2[j][y];\n\t\t}\n\t    for(int j=x+1;j<y;j++)\n\t\t{\n\t\t    p[x][j]=g[x][j],p[j][y]=g[j][y];\n\t\t    p2[x][j]=g2[x][j],p2[j][y]=g2[j][y];\n\t\t}\n\t    for(int j=y+1;j<=n;j++)\n\t\t{\n\t\t    p[x][j]=g[x][j],p[y][j]=g[y][j];\n\t\t    p2[x][j]=g2[x][j],p2[y][j]=g2[y][j];\n\t\t}\n\t}\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) ans=(ans+p[i][j])%mo;\n    ans=1ll*ans*ksm(2,m)%mo;\n    cout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nlong long ans,x,y,n,q,a[3001],t[3001][3001],T[3001][3001],sum[3001][3001],Sum[3001][3001];\nint read()\n{\n  char c=0;\n  int sum=0;\n  while (c<'0'||c>'9')\n    c=getchar();\n  while ('0'<=c&&c<='9')\n    {\n      sum=sum*10+c-'0';\n      c=getchar();\n    }\n  return sum;\n}\nlong long fast_pow(long long a,int b)\n{\n  if (b==0)\n    return 1;\n  if (b&1)\n    return fast_pow(a*a%mod,b/2)*a%mod;\n  else\n    return fast_pow(a*a%mod,b/2);\n}\nint main()\n{\n  n=read(),q=read();\n  for (int i=1;i<=n;++i)\n    a[i]=read();\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      {\n\tif (a[i]>a[j])\n\t  t[i][j]=1;\n\tif (a[i]<a[j])\n\t  T[i][j]=1;\n      }\n  int a,b,c,d;\n  for (int i=1;i<=q;++i)\n    {\n      x=read(),y=read();\n      if (x>y)\n\tswap(x,y);\n      for (int j=x+1;j<=y-1;++j)\n\t{\n\t   a=t[x][j],b=T[x][j],c=t[j][y],d=T[j][y];\n\t   t[x][j]=T[j][y]=(a+d)%mod*fast_pow(2,mod-2)%mod;\n\t   T[x][j]=t[j][y]=(b+c)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=1;j<=x-1;++j)\n\t {\n\t   a=t[j][x],b=T[j][x],c=t[j][y],d=T[j][y];\n\t   t[j][x]=t[j][y]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t   T[j][x]=T[j][y]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=y+1;j<=n;++j)\n\t{\n\t  a=t[x][j],b=T[x][j],c=t[y][j],d=T[y][j];\n\t  t[x][j]=t[y][j]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t  T[x][j]=T[y][j]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t}\n      a=t[x][y],b=T[x][y];\n      t[x][y]=T[x][y]=(a+b)%mod*fast_pow(2,mod-2)%mod;\n    }\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      ans=(ans+t[i][j]*fast_pow(2,q)%mod)%mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 3010\nconst int p=1e9+7;\nconst int inv2=500000004;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,Q,ans,pw=1,a[maxn],p1[maxn],p2[maxn],f[maxn][maxn];\nint add(int x,int y)\n{\n\tx+=y;\n\treturn x>=p? x-p:x;\n}\nvoid Add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p)\n\t\tx-=p;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint main()\n{\n\tread(n,Q);\n\tfor(int i=1;i<=n;i++)\n\t\tread(a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]>a[j];\n\tfor(int i=1;i<=Q;i++)\n\t\tread(p1[i],p2[i]);\n\tfor(int i=1;i<=Q;i++)\n\t{\n\t\tstatic int g[maxn][maxn];\n\t\tfor(int x=1;x<=n;x++)\n\t\t\tif(x!=p1[i]&&x!=p2[i])\n\t\t\t{\n\t\t\t\tg[x][p1[i]]=mul(inv2,add(f[x][p1[i]],f[x][p2[i]]));\n\t\t\t\tg[p1[i]][x]=mul(inv2,add(f[p1[i]][x],f[p2[i]][x]));\n\t\t\t\tg[x][p2[i]]=mul(inv2,add(f[x][p2[i]],f[x][p1[i]]));\n\t\t\t\tg[p2[i]][x]=mul(inv2,add(f[p2[i]][x],f[p1[i]][x]));\n\t\t\t}\n\t\tfor(int x=1;x<=n;x++)\n\t\t\tif(x!=p1[i]&&x!=p2[i])\n\t\t\t{\n\t\t\t\tf[x][p1[i]]=g[x][p1[i]];\n\t\t\t\tf[p1[i]][x]=g[p1[i]][x];\n\t\t\t\tf[x][p2[i]]=g[x][p2[i]];\n\t\t\t\tf[p2[i]][x]=g[p2[i]][x];\n\t\t\t}\n\t\tf[p1[i]][p2[i]]=f[p2[i]][p1[i]]=mul(inv2,add(f[p1[i]][p2[i]],f[p2[i]][p1[i]]));\n\t\tpw=add(pw,pw);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tAdd(ans,f[i][j]);\n\tprintf(\"%d\\n\",mul(ans,pw));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// copy ...\ntypedef long long ll;\nconst int N = 3054, mod = 1000000007, iv2 = (mod + 1) / 2;\nint n, q;\nint a[N], f[N][N];\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\ninline int half(int x) {return x = (x >> 1) + (-(x & 1) & (iv2 - mod)), x + (x >> 31 & mod);}\nint main() {\n\tint i, j, u, v; ll I = 0;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (i = 1; i <= n; ++i)\n\t\tfor (j = 1; j <= n; ++j)\n\t\t\tf[i][j] = a[i] > a[j];\n\tfor (i = 0; i < q; ++i) {\n\t\tscanf(\"%d%d\", &u, &v), f[u][v] = f[v][u] = half(f[u][v] + f[v][u]);\n\t\tfor (j = 1; j <= n; ++j) if (j != u && j != v)\n\t\t\tf[u][j] = f[v][j] = half(f[u][j] + f[v][j]),\n\t\t\tf[j][u] = f[j][v] = half(f[j][u] + f[j][v]);\n\t}\n\tfor (i = 1; i <= n; ++i) I += std::accumulate(f[i] + i, f[i] + (n + 1), 0ll);\n\tprintf(\"%d\\n\", (int)PowerMod(2, q, I % mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<ll,ll>\n#define vint vector<ll>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst ll mod=1e9+7;\nconst ll N=3005;\nll n,q,a[N],f[N][N],ans;\nll ksm(ll x,ll y){\n\tll re=1;\n\twhile(y){\n\t\tif(y&1)re=re*x%mod;\n\t\tx=x*x%mod;y>>=1;\n\t}return re;\n}\nsigned main(){\n\tn=read(),q=read();\n\tfor(ll i=1;i<=n;i++)a[i]=read();\n\tfor(ll i=1;i<=n;i++)for(ll j=1;j<=n;j++)f[i][j]=(a[i]>a[j]);\n\tll inv=ksm(2,mod-2),fac=ksm(2,q);\n\tfor(;q--;){\n\t\tll x=read(),y=read();\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%mod*inv%mod;\n\t\tfor(ll i=1;i<=n;i++){\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])%mod*inv%mod;\n\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])%mod*inv%mod;\n\t\t}\n\t}\n\tfor(ll i=1;i<=n;i++)for(ll j=i+1;j<=n;j++)ans=(ans+f[i][j]*fac%mod)%mod;\n\treturn cout<<ans,signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 3002, mod = 1000000007;\nint n, q, a[N], f[N][N];\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    for (int j = 1; j < i; j++) {\n      if (a[j] < a[i]) f[i][j] = 1;\n      if (a[j] > a[i]) f[j][i] = 1;\n    }\n  }\n  int ans = 0, t = 1;\n  while (q--) {\n    (t <<= 1) %= mod;\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    f[y][x] = f[x][y] = (ll) (f[x][y] + f[y][x]) * (mod + 1) / 2 % mod;\n    for (int i = 1; i <= n; i++) if (i != x && i != y) {\n      f[x][i] = f[y][i] = (ll) (f[x][i] + f[y][i]) * (mod + 1) / 2 % mod;\n      f[i][x] = f[i][y] = (ll) (f[i][x] + f[i][y]) * (mod + 1) / 2 % mod;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      ans = (ans + (ll) f[j][i] * t) % mod;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int P=1e9+7,N=3010,i2=(P+1)>>1;\nint n,Q,a[N],dp[N][N],tmp[N][N],ans,tot=1;\nint main(){\n    scanf(\"%d%d\",&n,&Q);\n    rep(i,1,n) scanf(\"%d\",a+i);\n    rep(i,1,n) rep(j,1,n) dp[i][j]=a[i]>a[j];\n    while(Q--){\n        int x,y;scanf(\"%d%d\",&x,&y);\n        rep(i,1,n) if((i^x)&&(i^y)) tmp[i][x]=dp[i][y],tmp[x][i]=dp[y][i],tmp[i][y]=dp[i][x],tmp[y][i]=dp[x][i];\n        rep(i,1,n) if((i^x)&&(i^y))\n            dp[i][x]=1ll*i2*(dp[i][x]+tmp[i][x])%P,\n            dp[i][y]=1ll*i2*(dp[i][y]+tmp[i][y])%P,\n            dp[x][i]=1ll*i2*(dp[x][i]+tmp[x][i])%P,\n            dp[y][i]=1ll*i2*(dp[y][i]+tmp[y][i])%P;\n        rep(i,1,n) if((i^x)&&(i^y)) tmp[i][x]=tmp[i][y]=tmp[x][i]=tmp[y][i]=0;\n        dp[x][y]=dp[y][x]=1ll*i2*(dp[x][y]+dp[y][x])%P;\n        tot=2ll*tot%P;\n    }\n    rep(i,1,n-1) rep(j,i+1,n) ans=(ans+dp[i][j])%P;\n    printf(\"%lld\\n\",1ll*ans*tot%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nconst int inv2=500000004;\nint a[3030];\nint dp[3030][3030];\nint main()\n{\n\tint n,q,x,y,ans=0;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tdp[i][j]=(a[i]>a[j]);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x&&j!=y)\n\t\t\t{\n\t\t\t\tdp[x][j]=dp[y][j]=(long long)(dp[x][j]+dp[y][j])*inv2%mod;\n\t\t\t\tdp[j][x]=dp[j][y]=(long long)(dp[j][x]+dp[j][y])*inv2%mod;\n\t\t\t}\n\t\tdp[x][y]=dp[y][x]=(long long)(dp[x][y]+dp[y][x])*inv2%mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t(ans+=dp[i][j])%=mod;\n\tfor(int i=1;i<=q;i++)\n\t\tans=ans*2%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=3005,md=1000000007;\nint n,q,i,j,a[N],x[N],y[N],f[N][N],g[N][N],ans,inv2=(md+1)/2;\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",a+i);\n\tfor(i=1;i<=q;++i)\n\t\tscanf(\"%d%d\",x+i,y+i);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tf[i][j]=1;\n\tfor(i=q;i>=1;--i)\n\t{\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tg[x[i]][j]=f[x[i]][j];\n\t\t\tg[y[i]][j]=f[y[i]][j];\n\t\t\tg[j][x[i]]=f[j][x[i]];\n\t\t\tg[j][y[i]]=f[j][y[i]];\n\t\t}\n\t\tfor(j=1;j<=n;++j)\n\t\t{\n\t\t\tif(j!=y[i])\n\t\t\t{\n\t\t\t\tf[x[i]][j]=1ll*(g[x[i]][j]+g[y[i]][j])*inv2%md;\n\t\t\t\tf[j][x[i]]=1ll*(g[j][x[i]]+g[j][y[i]])*inv2%md;\n\t\t\t}\n\t\t\tif(j!=x[i])\n\t\t\t{\n\t\t\t\tf[y[i]][j]=1ll*(g[y[i]][j]+g[x[i]][j])*inv2%md;\n\t\t\t\tf[j][y[i]]=1ll*(g[j][y[i]]+g[j][x[i]])*inv2%md;\n\t\t\t}\n\t\t}\n\t\tf[x[i]][y[i]]=f[y[i]][x[i]]=1ll*(g[x[i]][y[i]]+g[y[i]][x[i]])*inv2%md;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tif(a[i]>a[j])\n\t\t\t\tans=(ans+f[i][j])%md;\n\t\t\telse if(a[i]<a[j])\n\t\t\t\tans=(ans+f[j][i])%md;\n\tfor(i=1;i<=q;++i)\n\t\tans=ans*2ll%md;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=3000;\nconst int MAXSWAP=3000;\nconst int MOD=1000000007;\nconst int INV2=(MOD+1)/2;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\nint combine(int a,int b) { return (ll)(a+b)*INV2%MOD; }\n\nint n,nswap;\nint sval[MAXN];\nint swapidx[MAXSWAP][2];\n\nint pless[MAXN][MAXN];\nint acopy[2][MAXN];\nint bcopy[2][MAXN];\n\nint solve() {\n\tREP(i,n) REP(j,n) pless[i][j]=sval[i]<sval[j]?1:0;\n\tREP(k,nswap) {\n\t\tint a=swapidx[k][0],b=swapidx[k][1];\n\t\tREP(i,n) acopy[0][i]=pless[a][i],acopy[1][i]=pless[i][a];\n\t\tREP(i,n) bcopy[0][i]=pless[b][i],bcopy[1][i]=pless[i][b];\n\t\tpless[a][b]=pless[b][a]=combine(acopy[0][b],bcopy[0][a]);\n\t\tREP(j,n) if(j!=a&&j!=b) pless[a][j]=pless[b][j]=combine(acopy[0][j],bcopy[0][j]);\n\t\tREP(i,n) if(i!=a&&i!=b) pless[i][a]=pless[i][b]=combine(acopy[1][i],bcopy[1][i]);\n\t}\n\tint ret=0; REP(i,n) FOR(j,i+1,n) inc(ret,pless[j][i]); REP(i,nswap) ret=(ll)ret*2%MOD; return ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&nswap);\n\tREP(i,n) scanf(\"%d\",&sval[i]);\n\tREP(i,nswap) REP(j,2) scanf(\"%d\",&swapidx[i][j]),--swapidx[i][j];\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type get_mod() { return mod; }\n  static_assert(mod >= 2, \"invalid mod :: smaller than 2\");\n  static_assert(mod < (value_type(1) << 31), \"invalid mod :: over 2^31\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type get() const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing m32 = modular<1000000007>;\n\nconstexpr auto pow2 = [] {\n  std::array<m32, 3010> res;\n  res[0] = m32(1);\n  for (size_t i = 1; i < 3010; ++i) {\n    res[i] = res[i - 1] * m32(2);\n  }\n  return res;\n}();\n\nclass propagation_array {\nprivate:\n  size_t count;\n  std::vector<std::vector<m32>> data;\n  std::vector<std::vector<size_t>> done;\n\npublic:\n  propagation_array(size_t h, size_t w): \n    count(0), \n    data(h, std::vector<m32>(w)), \n    done(h, std::vector<size_t>(w)) \n  { }\n\n  void multiply() {\n    ++count;\n  }\n\n  void reduce(size_t i, size_t j) {\n    done[i][j] = std::min(done[i][j] + 1, count);\n  }\n\n  m32& access(size_t i, size_t j) {\n    data[i][j] *= pow2[count - done[i][j]];\n    done[i][j] = count;\n    return data[i][j];\n  }\n\n};\n\nint main() {\n  size_t N, Q;\n  std::cin >> N >> Q;\n  std::vector<i32> A(N);\n  for (auto &x: A) {\n    std::cin >> x;\n  }\n  m32 ans;\n  propagation_array invert(N, N);\n  for (size_t i = 0; i < N; ++i) {\n    for (size_t j = 0; j < N; ++j) {\n      if (A[i] < A[j]) {\n        invert.access(i, j) = m32(1);\n      }\n    }\n    for (size_t j = 0; j < i; ++j) {\n      ans += invert.access(i, j);\n    }\n  }\n  while (Q--) {\n    size_t x, y;\n    std::cin >> x >> y;\n    --x; --y;\n    if (x > y) {\n      std::swap(x, y);\n    }\n    m32 increase = ans;\n    for (auto i = x + 1; i < y; ++i) {\n      increase += invert.access(i, y);\n      increase -= invert.access(i, x);\n    }\n    for (size_t j = x + 1; j <= y; ++j) {\n      increase += invert.access(x, j);\n    }\n    for (size_t j = x; j < y; ++j) {\n      increase -= invert.access(y, j);\n    }\n    ans += increase;\n    invert.multiply();\n    for (size_t k = 0; k < N; ++k) {\n      if (k != x && k != y) {\n        invert.reduce(k, x);\n        invert.reduce(k, y);\n        invert.reduce(x, k);\n        invert.reduce(y, k);\n        invert.access(k, x) = invert.access(k, y) = invert.access(k, x) + invert.access(k, y);\n        invert.access(x, k) = invert.access(y, k) = invert.access(x, k) + invert.access(y, k);\n      }\n    }\n    invert.reduce(x, x);\n    invert.reduce(x, y);\n    invert.reduce(y, x);\n    invert.reduce(y, y);\n    invert.access(x, y) = invert.access(y, x) = invert.access(x, y) + invert.access(y, x);\n    invert.access(x, x) = invert.access(y, y) = invert.access(x, x) + invert.access(y, y);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=3005,mod=1e9+7;\nint n,q;\nint a[N];\nint x[N],y[N];\nint inv2=(mod+1)/2;\nint dp[N][N],tmp[N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t\tif (y&1)\n\t\t\tans=1LL*ans*x%mod;\n\treturn ans;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tmemset(dp,0,sizeof dp);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tdp[i][j]=a[i]<a[j]?1:0;\n\tfor (int t=1;t<=q;t++){\n\t\tint a=read(),b=read();\n\t\tif (a==b)\n\t\t\tcontinue;\n\t\tif (a>b)\n\t\t\tswap(a,b);\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (i==a||i==b)\n\t\t\t\tcontinue;\n\t\t\tdp[i][a]=dp[i][b]=(LL)inv2*(dp[i][a]+dp[i][b])%mod;\n\t\t\tdp[a][i]=dp[b][i]=(LL)inv2*(dp[a][i]+dp[b][i])%mod;\n\t\t}\n\t\tdp[a][b]=dp[b][a]=(LL)inv2*(dp[a][b]+dp[b][a])%mod;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tans=(ans+dp[i][j])%mod;\n\tans=(LL)ans*Pow(2,q)%mod;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 3005\n#define mo 998244353\n#define ll long long\nint ksm(int a,int k) {\n    int s=1;\n    while(k)\n\t{\n\t    if(k&1) s=1ll*s*a%mo;\n\t    a=1ll*a*a%mo;\n\t    k>>=1;\n\t}\n    return s;\n}\nint inv=ksm(2,mo-2);\nint n,m;\nint a[M],ans;\nll p[M][M],p2[M][M],g[M][M],g2[M][M];\nvoid pre() {\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) p[i][j]=a[i]>a[j],p2[i][j]=a[i]==a[j];\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    pre();\n    for(int i=1,x,y;i<=m;i++)\n\t{\n\t    cin>>x>>y;\n\t    if(x>y) swap(x,y);\n\t    for(int j=1;j<x;j++)\n\t\t{\n\t\t    g[j][x]=1ll*inv*(p[j][y]+p[j][x])%mo,g2[j][x]=1ll*inv*(p2[j][x]+p2[j][y])%mo;\n\t\t    g[j][y]=1ll*inv*(p[j][y]+p[j][x])%mo,g2[j][y]=1ll*inv*(p2[j][y]+p2[j][x])%mo;\n\t\t}\n\t    for(int j=x+1;j<y;j++)\n\t\t{\n\t\t    g[x][j]=1ll*inv*(p[x][j]+(1-p[j][y]-p2[j][y])%mo+mo)%mo,g2[x][j]=1ll*inv*(p2[x][j]+p2[j][y])%mo;\n\t\t    g[j][y]=1ll*inv*(p[j][y]+(1-p[x][j]-p2[x][j])%mo+mo)%mo,g2[j][y]=1ll*inv*(p2[j][y]+p2[x][j])%mo;\n\t\t}\n\t    for(int j=y+1;j<=n;j++)\n\t\t{\n\t\t    g[x][j]=1ll*inv*(p[x][j]+p[y][j])%mo,g2[x][j]=1ll*inv*(p2[x][j]+p2[y][j])%mo;\n\t\t    g[y][j]=1ll*inv*(p[y][j]+p[x][j])%mo,g2[y][j]=1ll*inv*(p2[y][j]+p2[x][j])%mo;\n\t\t}\n\t    p[x][y]=1ll*inv*(1-p2[x][y]+mo)%mo;\n\t    for(int j=1;j<x;j++)\n\t\t{\n\t\t    p[j][x]=g[j][x],p[j][y]=g[j][y];\n\t\t    p2[j][x]=g2[j][x],p2[j][y]=g2[j][y];\n\t\t}\n\t    for(int j=x+1;j<y;j++)\n\t\t{\n\t\t    p[x][j]=g[x][j],p[j][y]=g[j][y];\n\t\t    p2[x][j]=g2[x][j],p2[j][y]=g2[j][y];\n\t\t}\n\t    for(int j=y+1;j<=n;j++)\n\t\t{\n\t\t    p[x][j]=g[x][j],p[y][j]=g[y][j];\n\t\t    p2[x][j]=g2[x][j],p2[y][j]=g2[y][j];\n\t\t}\n\t}\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) ans=(ans+p[i][j])%mo;\n    ans=1ll*ans*ksm(2,m)%mo;\n    cout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<long long MOD>\nclass Num {\nprivate:\n\tlong long expow(long long base, long long e) const {\n\t\tlong long ans = 1;\n\t\tfor (; e > 0; e/= 2) {\n\t\t\tif (e % 2)\n\t\t\t\tans = ans * base % MOD;\n\t\t\tbase = base * base % MOD; }\n\t\treturn ans; }\n\npublic:\n\tlong long val;\n\n\tNum(long long _val) {\n\t\tval = _val % MOD;\n\t\tval = val < 0 ? val + MOD : val; }\n\tNum() : val(0) { }\n\n\tinline Num operator + (const Num &arg) const {\n\t\tNum res;\n\t\tres.val = val + arg.val;\n\t\tres.val = res.val >= MOD ? res.val - MOD : res.val;\n\t\treturn res; }\n\n\tinline Num operator - (const Num &arg) const {\n\t\tNum res;\n\t\tres.val = val - arg.val;\n\t\tres.val = res.val < 0 ? res.val + MOD : res.val;\n\t\treturn res; }\n\n\tinline Num operator - () const {\n\t\tNum res;\n\t\tres.val = MOD - res.val;\n\t\tres.val = res.val == MOD ? 0 : res.val;\n\t\treturn res; }\n\n\tinline Num operator ^ (const int &arg) const {\n\t\treturn Num(expow(val, arg)); }\n\n\tinline Num operator * (const Num &arg) const {\n\t\treturn Num(val * arg.val); }\n\n\tinline Num operator / (const Num &arg) const {\n\t\treturn Num(val * expow(arg.val, MOD - 2)); }\n\n\tinline void operator += (const Num &arg) {\n\t\t(*this) = (*this) + arg; }\n\n\tinline void operator -= (const Num &arg) {\n\t\t(*this) = (*this) - arg; }\n\n\tinline void operator *= (const Num &arg) {\n\t\t(*this) = (*this) * arg; }\n\n\tinline void operator /= (const Num &arg) {\n\t\t(*this) = (*this) / arg; }\n\n\tinline void operator ^= (const long long &arg) {\n\t\tval = expow(val, arg); } };\n\ntemplate<long long MOD>\nostream &operator << (ostream &fo, const Num<MOD> &c) {\n\tfo << c.val;\n\treturn fo; }\n\ntemplate<long long MOD>\nistream &operator >> (istream &fi, Num<MOD> &c) {\n\tfi >> c.val;\n\tc = Num<MOD>(c.val);\n\treturn fi; }\n\nconst int N = 3005, MOD = 1e9 + 7;\nconst Num<MOD> HALF = Num<MOD>(1) / 2;\n\nint n, q;\n\nvector<vector<Num<MOD>>> dp[2];\nvector<int> v;\n\nint main() {\n#ifdef HOME\n\tfreopen(\"agc30d.in\", \"r\", stdin);\n\tfreopen(\"agc30d.out\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false); \n\tcin.tie(0), cout.tie(0);\n\tNum<MOD> ant;\n\tint l, r;\n\n\tcin >> n >> q;\n\tv.resize(n);\n\tfor (auto &i: v)\n\t\tcin >> i;\n\n\tdp[0] = dp[1] = vector<vector<Num<MOD>>>(n, vector<Num<MOD>>(n));\n\tfor (int i = 0; i < n; ++i)\n\tfor (int j = 0; j < n; ++j)\n\t\tdp[0][i][j] = Num<MOD> {int(v[i] > v[j])};\n\n\tfor (int u = 0; u < q; ++u) {\n\t\tcin >> l >> r;\n\t\tif (--l == --r)\n\t\t\tcontinue;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (i != l && i != r) {\n\t\t\t\tdp[1][i][l] = (dp[0][i][l] + dp[0][i][r]) * HALF;\n\t\t\t\tdp[1][l][i] = (dp[0][l][i] + dp[0][r][i]) * HALF;\n\n\t\t\t\tdp[1][i][r] = (dp[0][i][l] + dp[0][i][r]) * HALF;\n\t\t\t\tdp[1][r][i] = (dp[0][l][i] + dp[0][r][i]) * HALF; }\n\n\t\tdp[1][r][l] = dp[1][l][r] = (dp[0][l][r] + dp[0][r][l]) * HALF;\n\n\t\tfor (int i = 0; i < n; ++i) if (i != l && i != r)\n\t\tfor (int j = 0; j < n; ++j) if (j != l && j != r)\n\t\t\tdp[1][i][j] = dp[0][i][j];\n\t\tswap(dp[0], dp[1]); }\n\n\tfor (int i = 0; i < n; ++i)\n\tfor (int j = i + 1; j < n; ++j)\n\t\tant+= dp[0][i][j];\n\n\tcout << (ant * (Num<MOD>(2) ^ q)) << endl;\n\n\treturn 0; }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\nconst int INV2 = (MOD + 1) / 2;\n\nint dp[3005][3005];\nint n, p[3005];\nPII pinv[3005];\nint m, u[3005], v[3005];\nint cdp[3005];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep1(i, n) scanf(\"%d\", &p[i]);\n\trep(i, m) scanf(\"%d%d\", &u[i], &v[i]);\n\t\n\trep1(i, n) dp[i][i] = 1;\n\trep(i, m) rep1(j, n) {\n\t\tint cur = 1LL * (dp[j][u[i]] + dp[j][v[i]]) * INV2 % MOD;\n\t\tdp[j][u[i]] = dp[j][v[i]] = cur;\n\t}\n\t\n\trep1(i, n) pinv[i] = MP(p[i], i);\n\tsort(pinv + 1, pinv + n + 1);\n\tint ans = 0;\n\trep1(i, n) {\n\t\tint tot = 0;\n\t\tfor(int j = n; j >= 1; j --) {\n\t\t\tans = (ans + 1LL * (tot + 1LL * cdp[j] * INV2 % MOD) * dp[pinv[i].second][j]) % MOD;\n\t\t\ttot = (tot + cdp[j]) % MOD;\n\t\t}\n\t\tif(i == n || pinv[i].first != pinv[i + 1].first)\n\t\tfor(int i0 = i; i0 >= 0 && pinv[i0].first == pinv[i].first; i0 --)\n\t\trep1(j, n) cdp[j] = (cdp[j] + dp[pinv[i0].second][j]) % MOD;\n\t}\n\t\n\trep(i, m) ans = ans * 2 % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nll ppow(ll a,ll b){\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll E[4000][4000];\nint a[4000];\n\nint main(){\n\tll t=ppow(2,MOD-2);\n\tint n,q;scanf(\"%d%d\",&n,&q);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\trep(i,n)rep(j,n){\n\t\tE[i][j]=(a[i]>a[j]);\n\t}\n\trep(i,q){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);x--;y--;\n\t\tif(x>y)swap(x,y);\n\t\trep(j,n){\n\t\t\tif(j==x||j==y)continue;\n\t\t\tE[j][x]=E[j][y]=(E[j][x]*t+E[j][y]*t)%MOD;\n\t\t\tE[x][j]=E[y][j]=(E[x][j]*t+E[y][j]*t)%MOD;\n\t\t}\n\t\tE[x][y]=E[y][x]=(E[x][y]*t+E[y][x]*t)%MOD;\n\t}\n\tll ans=0;\n\trep(i,n){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\t(ans+=E[i][j])%=MOD;\n\t\t}\n\t}\n\tcout<<ans*ppow(2,q)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int mod = 1e9 + 7,N = 4e3;\nint n,m; ll Ans = 1,a[N],f[N][N];\nint main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1;i <= n;i ++) a[i] = read();\n\tfor(int i = 1;i <= n;i ++) for(int j = 1;j <= n;j ++) f[i][j] = a[i] > a[j];\n\tint x,y,inv2 = (mod + 1) / 2;\n\twhile(m --)\n\t{\n\t\tAns = (Ans << 1) % mod;\n\t\tx = read(); y = read();\n\t\tf[x][y] = f[y][x] = 1ll * ((f[x][y] + f[y][x]) % mod + mod) % mod * inv2 % mod;\n\t\tfor(int i = 1;i <= n;i ++)\n\t\t{\n\t\t\tif(i == x || i == y) continue;\n\t\t\tf[x][i] = f[y][i] = 1ll * ((f[x][i] + f[y][i]) % mod + mod) % mod * inv2 % mod;\n\t\t\tf[i][x] = f[i][y] = 1ll * ((f[i][x] + f[i][y]) % mod + mod) % mod * inv2 % mod;\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 1;i <= n;i ++) for(int j = i + 1;j <= n;j ++) tot = (tot + f[i][j]) % mod;\n\tcout << ((1ll * Ans * tot % mod) + mod) % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define modsum(a, b) ((a) + (b) >= M ? (a) + (b) - M : (a) + (b))\n#define modsubtract(a, b) ((a) - (b) < 0 ? (a) - (b) + M : (a) - (b))\n#define modmultiply(a, b) (((a) * (b)) % M)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)((a).size()))\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T>\nostream & operator << (ostream &out, vector<T> &a) {\n    out << \"{\";\n    fori (i, SZ(a))\n        out << a[i] << vector<string>{\", \", \"}\"}[i + 1 == SZ(a)];\n    return out;\n}\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\n\";\n    cout << \"TOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nint n, q;\nconst int N = 3003;\nconst ll M = 1e9 + 7;\nint a[N];\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % M;\n        a = (a * a) % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll pw2[N];\n\nmap<pii, int> dp[N];\n\npii queries[N];\n\nvi my_q[N];\n\nll dfs(int i, int l, int r) {\n    if (i == q) {\n        if (l > r) return 1;\n        return 0;\n    }\n    if (l > r) {\n        return (pw2[q - i] - dfs(i, r, l) + M) % M;\n    }\n    if (dp[i].count({l, r})) return dp[i][{l, r}];\n\n    vi cur1, cur2;\n    for (int j = upper_bound(ALL(my_q[l]), i - 1) - my_q[l].begin(); j < SZ(my_q[l]); ++j) {\n        int ind = my_q[l][j];\n        cur1.push_back(ind);\n    }\n    for (int j = upper_bound(ALL(my_q[r]), i - 1) - my_q[r].begin(); j < SZ(my_q[r]); ++j) {\n        int ind = my_q[r][j];\n        cur2.push_back(ind);\n    }\n    vi cur_q(cur1.size() + cur2.size());\n    merge(ALL(cur1), ALL(cur2), cur_q.begin());\n    cur_q.resize(unique(ALL(cur_q)) - cur_q.begin());\n\n    ll ret = 0;\n    for (int j = 0; j < cur_q.size(); ++j) {\n        int ind = cur_q[j];\n        int lf = queries[ind].first, rf = queries[ind].second;\n        if ((l < r) ^ (lf < rf)) swap(lf, rf);\n        ll ways = pw2[ind - i - j];\n        if (lf == l && rf == r) {\n            ret = (ret + ways * dfs(ind + 1, r, l)) % M;\n        } else if (lf == l || rf == l) {\n            if (lf != l) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, rf, r)) % M;\n        } else if (rf == r || lf == r) {\n            if (rf != r) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, l, lf)) % M;\n        } else assert(0);\n    }\n    ret = (ret + pw2[q - i - cur_q.size()] * dfs(q, l, r)) % M;\n    return dp[i][{l, r}] = ret;\n}\n\nvoid smain() {\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n    cin >> n >> q;\n    fori (i, n) cin >> a[i];\n    fori (i, q) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--, queries[i].second--;\n        my_q[queries[i].first].push_back(i);\n        my_q[queries[i].second].push_back(i);\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ll cur = dfs(0, i, j);\n//            cout << \"cur[\" << i << \", \" << j << \"] = \" << cur << endl;\n            if (a[i] < a[j]) ans = (ans + cur) % M;\n            else if (a[i] > a[j]) ans = (ans + pw2[q] - cur + M) % M;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 3005;\nint n, q;\nint A[MAXN];\npair<int, int> Q[MAXN];\nvector<int> swapTime[MAXN];\nvector<int> swapWith[MAXN];\nint nxt[MAXN][MAXN];\nint dp[MAXN][2][MAXN][2];\nint pw2[MAXN];\n\nint whichSide(int e, int x) {\n\tif (Q[e].first == x) return 0;\n\telse return 1;\n}\nint sol(int i, int j, int x, int y) {\n\tint e1, e2;\n\te1 = swapTime[i][x];\n\te2 = swapTime[j][y];\n\tif (q == e1 && q == e2) {\n\t\treturn (i > j) ? 1 : 0;\n\t}\n\tint a, b, c, d;\n\tif (e1 <= e2) {\n\t\ta = e1;\n\t\tb = whichSide(e1, i);\n\t\tc = j;\n\t\td = 0;\n\t} else {\n\t\ta = e2;\n\t\tb = whichSide(e2, j);\n\t\tc = i;\n\t\td = 1;\n\t}\n\tif (dp[a][b][c][d] != -1) return dp[a][b][c][d];\n\tint ans = 0;\n\tif (e2 < e1) {\n\t\tint dis = min(e1, swapTime[j][y+1]) - e2 - 1;\n\t\tans = (pw2[dis] * 1ll * sol(i, j, x, y + 1)) % MOD;\n\t\tint nj = swapWith[j][y];\n\t\tint ny = nxt[nj][e2 + 1];\n\t\tdis = min(swapTime[nj][ny], e1) - e2 - 1;\n\t\tans += (pw2[dis] * 1ll * sol(i, nj, x, ny)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[a][b][c][d] = ans;\n\t}\n\tif (e2 > e1) {\n\t\tint dis = min(e2, swapTime[i][x + 1]) - e1-1;\n\t\tans = (pw2[dis] * 1ll * sol(i, j, x+1, y)) % MOD;\n\t\tint ni = swapWith[i][x];\n\t\tint nx = nxt[ni][e1 + 1];\n\t\tdis = min(e2, swapTime[ni][nx]) - e1 - 1;\n\t\tans += (pw2[dis] * 1ll * sol(ni, j, nx, y)) % MOD;\n\t\tans %= MOD;\n\t\treturn dp[a][b][c][d] = ans;\n\t}\n\tint dis = min(swapTime[i][x+1], swapTime[j][y+1]) - e1 - 1;\n\tans = (pw2[dis] * 1ll * sol(i, j, x + 1, y + 1)) % MOD;\n\tans += (pw2[dis] * 1ll * sol(j, i, y + 1, x + 1)) % MOD;\n\tans %= MOD;\n\treturn dp[a][b][c][d] = ans;\n}\n\nint main() {\n\tmemset(dp, -1, sizeof(dp));\n\tpw2[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tpw2[i] = (pw2[i-1] * 2) % MOD;\n\t}\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", A + i);\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tswapTime[x].push_back(i);\n\t\tswapWith[x].push_back(y);\n\t\tswapTime[y].push_back(i);\n\t\tswapWith[y].push_back(x);\n\t\tQ[i] = {x, y};\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tswapTime[i].push_back(q);\n\t\tint k = 0;\n\t\tfor (int j = 0; j < swapTime[i].size(); j++) {\n\t\t\twhile (k <= swapTime[i][j]) {\n\t\t\t\tnxt[i][k] = j;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (A[i] == A[j]) continue;\n\t\t\tint res = (pw2[min(swapTime[i][0], swapTime[j][0])] * 1ll * sol(i, j, 0, 0)) % MOD;\n\t\t\tif (A[i] < A[j]) ans += res;\n\t\t\telse {\n\t\t\t\tans += (pw2[q] - res + MOD) % MOD;\n\t\t\t}\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 3010,mod = 1e9+7,inv=500000004;\nint f[N][N],n,Q,a[N];\nvoid upd(int&a,int b){a=1ll*inv*(a+b)%mod;}\nint main(){\n\tread(n);read(Q);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]>a[j];\n\tint K=1;\n\tfor(int i=1;i<=Q;i++) K=K*2%mod;\n\twhile(Q--){\n\t\tint x,y;read(x);read(y);\n\t\tint res[N*4],cnt=0;\n\t\tmemset(res,0,sizeof(res));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(x==i||y==i) continue;\n\t\t\tres[cnt++]=f[y][i],res[cnt++]=f[i][y];\n\t\t\tres[cnt++]=f[x][i],res[cnt++]=f[i][x];\n\t\t}\n\t\tint now=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(x==i||y==i) continue;\n\t\t\tupd(f[x][i],res[now++]),upd(f[i][x],res[now++]);\n\t\t\tupd(f[y][i],res[now++]),upd(f[i][y],res[now++]);\n\t\t}\n\t\tres[0]=f[x][y];res[1]=f[y][x];\n\t\tupd(f[x][y],res[1]);upd(f[y][x],res[0]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t(ans+=f[i][j])%=mod;\n\tcout<<1ll*K*ans%mod<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\nconst mint TWO_INV = ONE / TWO;\n\nconst int limit = 3010;\nmint dp[limit][limit];\n\nint main(void){\n\tint n,q;\n\tcin >> n >> q;\n\tvector<int> a(n);\n\trep(i, n) cin >> a[i];\n\n\trep(i, n) rep(j, n)  dp[i][j] = (a[i] > a[j]) ? ONE: ZERO;\n\t\n\trep(loop, q){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tif(x > y) swap(x, y);\n\n\t\trep(i, n){\n\t\t\tif(i == x or i == y) continue;\n\t\t\tmint nxt = (dp[x][i] + dp[y][i]) * TWO_INV;\n\t\t\tdp[x][i] = dp[y][i] = nxt;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tif(i == x or i == y) continue;\n\t\t\tmint nxt = (dp[i][x] + dp[i][y]) * TWO_INV;\n\t\t\tdp[i][x] = dp[i][y] = nxt;\n\t\t}\n\n\t\tmint nxt = (dp[x][y] + dp[y][x]) * TWO_INV;\n\t\tdp[x][y] = dp[y][x] = nxt;\n\t}\n\n\tmint ans = ZERO;\n\trep(j, n) rep(i, j) ans += dp[i][j];\n\trep(loop, q) ans *= TWO;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <unistd.h>\n#include <ctime>\n#include <queue>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 3005, MOD = 1e9 + 7;\n\nint add(int a, int b) {\n  return (a + b) % MOD;\n}\n\nint sub(int a, int b) {\n  return (a - b + MOD) % MOD;\n}\n\nint mul(int a, int b) {\n  return (int) (((ll) a * b) % MOD);\n}\n\nint eksp(int b, int e) {\n  int r=1;\n  for (; e; e/=2, b=mul(b, b))\n    if (e & 1) r = mul(r, b);\n  return r;\n}\n\nint invv(int x) {\n  return eksp(x, MOD-2);\n}\n\nint n, q;\nint dp[MAX][MAX], isti[MAX][MAX];\nint p[MAX];\n//double dp[MAX][MAX];\nint inv2;\nint tdp[MAX][MAX], tisti[MAX][MAX];\n\nint main()\n{\n  inv2 = invv(2);\n  scanf(\"%d%d\", &n, &q);\n\n  REP(i, n) {\n    scanf(\"%d\", &p[i]); p[i]--;    \n  }\n\n  REP(i, n) REP(j, n) {\n    if (p[i] != p[j])\n      dp[i][j] = (p[i] > p[j]) ^ (i > j);\n    else\n      isti[i][j] = 1;\n  }\n\n  REP(qq, q) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b); a--; b--;\n    dp[a][b] = dp[b][a] = mul(inv2, sub(1, isti[a][b]));\n    //    TRACE(a _ b _ dp[a][b]);\n\n    REP(st, 2) {\n      swap(a, b);\n      REP(i, n) {\n\tif (i == a || i == b) continue;\n      \n\tint tmp = mul(inv2, dp[a][i]);\n\ttisti[a][i] = tisti[i][a] = mul(inv2, add(isti[a][i], isti[b][i]));\n\t      \n\tif ((b > i) == (a > i))\n\t  tmp = add(tmp, mul(inv2, dp[b][i]));\n\telse\n\t  tmp = add(tmp, mul(inv2, sub(1, add(isti[b][i], dp[b][i]))));\n\n\ttdp[a][i] = tdp[i][a] = tmp;\t\n      }\n    }\n\n    REP(i, n) {\n      if (i != a && i != b) {\n\tdp[i][a] = dp[a][i] = tdp[a][i];\n\tdp[i][b] = dp[b][i] = tdp[b][i];\n\tisti[i][a] = isti[a][i] = tisti[a][i];\n\tisti[i][b] = isti[b][i] = tisti[b][i];\n      }\n    }\n  }\n\n\n  int sol = 0;\n  REP(i, n) FOR(j, i+1, n)\n    sol = add(sol, dp[i][j]);\n\n  // REP(i, n) {\n  //   FOR(j, i+1, n) printf(\"%d \", mul(eksp(2, q), dp[i][j]));\n  //   printf(\"\\n\");\n  // }\n\n  sol = mul(sol, eksp(2, q));\n\n  printf(\"%d\\n\", sol);    \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=3005,mod=1e9+7;\nint n,q;\nint a[N];\nint x[N],y[N];\nint inv2=(mod+1)/2;\nint dp[N][N],tmp[N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t\tif (y&1)\n\t\t\tans=1LL*ans*x%mod;\n\treturn ans;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor (int i=1;i<=q;i++)\n\t\tx[i]=read(),y[i]=read();\n\tmemset(dp,0,sizeof dp);\n\t// dp[1..n][1..i-1]\n\tfor (int t=q;t>=1;t--){\n\t\tint a=x[t],b=y[t];\n\t\tif (a==b)\n\t\t\tcontinue;\n\t\tfor (int i=a+1;i<b;i++)\n\t\t\ttmp[i]=(LL)inv2*((LL)mod+1-dp[b][i]+dp[i][a])%mod;\n\t\tdp[b][a]=inv2;\n\t\tfor (int i=a+1;i<b;i++)\n\t\t\tdp[b][i]=(LL)inv2*((LL)dp[b][i]+mod+1-dp[i][a])%mod;\n\t\tfor (int i=a+1;i<b;i++)\n\t\t\tdp[i][a]=tmp[i];\n//\tfor (int i=1;i<=n;i++,puts(\"\"))\n//\t\tfor (int j=1;j<i;j++)\n//\t\t\tprintf(\"%d \",dp[i][j]);\n\t}\n\tint ans=0;\n//\tfor (int i=1;i<=n;i++,puts(\"\"))\n//\t\tfor (int j=1;j<i;j++)\n//\t\t\tprintf(\"%d \",dp[i][j]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[i]<a[j])\n\t\t\t\tans=(ans+mod+1-dp[i][j])%mod;\n\t\t\telse if (a[i]>a[j])\n\t\t\t\tans=(ans+dp[i][j])%mod;\n\tans=(LL)ans*Pow(2,q)%mod;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=3000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 1000000007\n#define inv2 500000004\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n    #define N 100000\n\n    int fac[N+100],invfac[N+100];\n\n    int add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n    int dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n    int mul(int x,int y) {return 1ll*x*y%maxd;}\n    ll qpow(ll x,int y)\n    {\n        ll ans=1;\n        while (y)\n        {\n            if (y&1) ans=mul(ans,x);\n            x=mul(x,x);y>>=1;\n        }\n        return ans;\n    }\n    int getinv(int x) {return qpow(x,maxd-2);}\n\n    int C(int n,int m)\n    {\n        if ((n<m) || (n<0) || (m<0)) return 0;\n        return mul(mul(fac[n],invfac[m]),invfac[n-m]);\n    }\n\n    void math_init()\n    {\n        fac[0]=invfac[0]=1;\n        rep(i,1,N) fac[i]=mul(fac[i-1],i);\n        invfac[N]=getinv(fac[N]);\n        per(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n    }\n    #undef N\n}\nusing namespace My_Math;\n\nint n,q,a[N],f[N][N];\n\nint main()\n{\n    n=read();q=read();\n    rep(i,1,n) a[i]=read();\n    rep(i,1,n) rep(j,1,n) f[i][j]=(a[i]<a[j]);\n    rep(i,1,q)\n    {\n        int x=read(),y=read();\n        f[x][y]=f[y][x]=mul(inv2,add(f[x][y],f[y][x]));\n        rep(j,1,n)\n        {\n            if ((j==x) || (j==y)) continue;\n            f[x][j]=f[y][j]=mul(inv2,add(f[x][j],f[y][j]));\n            f[j][x]=f[j][y]=mul(inv2,add(f[j][x],f[j][y]));\n        }\n    }\n    int ans=0;\n    rep(i,1,n) rep(j,1,i-1) ans=add(ans,f[i][j]);\n    ans=mul(ans,qpow(2,q));\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    考虑一对位置的相对大小\n    记 f_{i, j, k} 表示 i 次操作后 a_j > a_k 的概率\n    最后要乘上 2 ^ q \n    时间复杂度 O(n * (n + q)) \n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3005, mod = 1e9 + 7, inv2 = (mod + 1) >> 1;\n\nint n, q;\nint a[N];\nint f[N][N], g[N][N];\n\ninline void Inc(int &u, const int v) { if((u += v) >= mod) u -= mod; }\n\nint main() {\n    scanf(\"%d %d\", &n, &q);\n    for(int i = 1; i <= n; ++i)\n        scanf(\"%d\", &a[i]);\n    for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j)\n            f[i][j] = a[i] > a[j];\n    int pw2 = 1;\n    for(int Case = 1, x, y; Case <= q; ++Case) {\n        scanf(\"%d %d\", &x, &y);\n        pw2 = (pw2 + pw2) % mod;\n        for(int i = 1; i <= n; ++i) {\n            g[i][x] = f[i][x], g[x][i] = f[x][i];\n            g[i][y] = f[i][y], g[y][i] = f[y][i];\n        }\n        f[x][y] = 1LL * (f[x][y] + g[y][x]) * inv2 % mod;\n        f[y][x] = 1LL * (f[y][x] + g[x][y]) * inv2 % mod;\n        for(int i = 1; i <= n; ++i) if(i != x && i != y) {\n            f[i][x] = 1LL * (f[i][x] + g[i][y]) * inv2 % mod;\n            f[x][i] = 1LL * (f[x][i] + g[y][i]) * inv2 % mod;\n            f[i][y] = 1LL * (f[i][y] + g[i][x]) * inv2 % mod;\n            f[y][i] = 1LL * (f[y][i] + g[x][i]) * inv2 % mod;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= n; ++i)\n        for(int j = i + 1; j <= n; ++j)\n            ans = (ans + 1LL * pw2 * f[i][j]) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define ll long long\n//{{{ read()\ninline ll read(){\n\tregister ll x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=3005;\nconst int P=1e9+7;\nconst int Gi=(P+1)>>1;\nint n,q,ans,fac,a[N],f[N][N],g[N][N];\nvoid Add(int &x,int y){\n\tx+=y,x-=x>=P?P:0;\n}\nint main(){\n\tn=read(),q=read(),fac=1;\n\tfor(int i=1;i<=n;i++)\ta[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j])\tf[i][j]=1;\n\twhile(q--){\n\t\tint x=read(),y=read();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(x!=i&&y!=i){\n\t\t\t\tf[x][i]=g[x][i]=1ll*f[x][i]*Gi%P,f[y][i]=g[y][i]=1ll*f[y][i]*Gi%P;\n\t\t\t\tf[i][x]=g[i][x]=1ll*f[i][x]*Gi%P,f[i][y]=g[i][y]=1ll*f[i][y]*Gi%P;\n\t\t\t}\n\t\tf[x][y]=g[x][y]=1ll*f[x][y]*Gi%P;\n\t\tf[y][x]=g[y][x]=1ll*f[y][x]*Gi%P;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i!=x&&i!=y){\n\t\t\t\tAdd(f[y][i],g[x][i]),Add(f[i][y],g[i][x]);\n\t\t\t\tAdd(f[x][i],g[y][i]),Add(f[i][x],g[i][y]);\n\t\t\t}\n\t\tAdd(f[x][y],g[y][x]),Add(f[y][x],g[x][y]),Add(fac,fac);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) ans=(ans+1ll*f[j][i]*fac)%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 3010;\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nvoid mymul(LL& x,LL v){\n    x=(x*v)%MOD;\n}\nLL cnt_big[SIZE][SIZE],cnt_small[SIZE][SIZE];\nLL inv2=mypow(2,MOD-2);\nint A[SIZE];\nLL &cnt_big0(int x,int y){\n    return cnt_big[x][y];\n    if(x>y)return cnt_big[y][x];\n    return cnt_big[x][y];\n}\nLL &cnt_small0(int x,int y){\n    return cnt_small[x][y];\n    if(x>y)return cnt_small[y][x];\n    return cnt_small[x][y];\n}\nint main(){\n    int N,Q; R(N,Q);\n    FOR(i,1,N)R(A[i]);\n    FOR(i,1,N)FOR(j,1,N){\n        cnt_big[i][j]=(A[i]>A[j]);\n        cnt_small[i][j]=(A[i]<A[j]);\n    }\n    LL mul=1;\n    REP(i,Q){\n        int x,y; R(x,y);\n        ADD(mul,mul);\n        ADD(cnt_big[x][y],cnt_small[x][y]);\n        mymul(cnt_big[x][y],inv2);\n        swap(x,y);\n        ADD(cnt_big[x][y],cnt_small[x][y]);\n        mymul(cnt_big[x][y],inv2);\n        cnt_small[x][y]=cnt_big[x][y];\n        FOR(j,1,N){\n            if(j==x||j==y)continue;\n            ADD(cnt_big0(j,x),cnt_big0(j,y));\n            ADD(cnt_small0(j,x),cnt_small0(j,y));\n            mymul(cnt_big0(j,x),inv2);\n            mymul(cnt_small0(j,x),inv2);\n            cnt_big0(j,y)=cnt_big0(j,x);\n            cnt_small0(j,y)=cnt_small0(j,x);\n            \n            ADD(cnt_big0(x,j),cnt_big0(y,j));\n            ADD(cnt_small0(x,j),cnt_small0(y,j));\n            mymul(cnt_big0(x,j),inv2);\n            mymul(cnt_small0(x,j),inv2);\n            cnt_big0(y,j)=cnt_big0(x,j);\n            cnt_small0(y,j)=cnt_small0(x,j);\n        }\n    }\n    LL an=0;\n    FOR(i,1,N)FOR(j,i+1,N)ADD(an,cnt_big[i][j]);\n    W(an*mul%MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n*/\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n       \n        \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int Mod = 1000000007;\nconst int MAXN = 3008;\n\n\nint sum(int a, int b) {\n    return (a + b) % Mod;\n}\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\n\nint n, q;\nint dp[MAXN][MAXN];\nint a[MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    int kek = powm(2, Mod - 2);\n    for (int it = 0; it < q; it++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        for (int i = 0; i < n; i++) {\n            if (i == x || i == y) {\n                continue;\n            }\n            dp[i][x] = mul(dp[i][x], kek);\n            dp[i][y] = mul(dp[i][y], kek);\n            dp[i][x] = sum(dp[i][x], dp[i][y]);\n            dp[i][y] = dp[i][x];\n            dp[x][i] = mul(dp[x][i], kek);\n            dp[y][i] = mul(dp[y][i], kek);\n            dp[x][i] = sum(dp[x][i], dp[y][i]);\n            dp[y][i] = dp[x][i];\n        }\n        dp[x][y] = mul(dp[x][y], kek) + mul(dp[y][x], kek);\n        dp[y][x] = sum(1, Mod - dp[x][y]);\n        dp[x][x] = 0;\n        dp[y][y] = 0;\n    }   \n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            ans = sum(ans, dp[i][j]);\n        }\n    }\n    ans = mul(ans, powm(2, q));\n    cout << ans << '\\n';\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst long long MOD = 1000000007;\nconst int MAX = 3000 + 10;\n\nint n, m;\n\nlong long dpb[MAX][MAX];\nlong long dps[MAX][MAX];\nlong long tmpxb[MAX];\nlong long tmpxs[MAX];\nlong long tmpyb[MAX];\nlong long tmpys[MAX];\nlong long lazy[MAX];\n\nint rec[MAX];\n\nvoid update(int x) {\n    for(int i = 0 ; i < n ; i++) {\n        dpb[x][i] *= lazy[x];\n        dpb[x][i] %= MOD;\n        dps[x][i] *= lazy[x];\n        dps[x][i] %= MOD;\n    }\n    lazy[x] = 1LL;\n}\n\nlong long inv(int x) {\n    if(x == 1) return 2LL;\n    long long tmp = inv(x/2);\n    if(x&1) return tmp * tmp % MOD * 2 % MOD;\n    return tmp * tmp % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for(int i = 0 ; i < n ; i++) {\n        scanf(\"%d\", &rec[i]);\n    }\n\n    long long ans = 0;\n\n    for(int i = 0 ; i < n ; i++) {\n        lazy[i] = 1LL;\n        for(int j = 0 ; j < n ; j++) {\n            if (rec[j] < rec[i]) {\n                dps[i][j]++;\n                if (j > i) {\n                    ans++;\n                }\n            } else if (rec[j] > rec[i]) {\n                dpb[i][j]++;\n            }\n        }\n    }\n    \n    long long INV = inv(MOD-2);\n\n    while (m--) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--, y--;\n        update(x);\n        update(y);\n        if (x > y) swap(x, y);\n\n        ans *= 2;\n        ans %= MOD;\n        \n        for(int i = x+1 ; i <= y ; i++) {\n            ans += dpb[x][i] - dps[x][i];\n            ans %= MOD;\n        }\n\n        for(int i = x+1 ; i < y ; i++) {\n            ans += dps[y][i] - dpb[y][i];\n            ans %= MOD;\n        }\n\n        for(int i = 0 ; i < n ; i++) {\n            tmpxs[i] = dps[x][i];\n            tmpxb[i] = dpb[x][i];\n            tmpys[i] = dps[y][i];\n            tmpyb[i] = dpb[y][i];\n        }\n\n        swap(tmpxs[x], tmpxs[y]);\n        swap(tmpxb[x], tmpxb[y]);\n        swap(tmpys[y], tmpys[x]);\n        swap(tmpyb[y], tmpyb[x]);\n\n        for(int i = 0 ; i < n ; i++) {\n            dps[x][i] += tmpys[i];\n            dpb[x][i] += tmpyb[i];\n            dps[y][i] += tmpxs[i];\n            dpb[y][i] += tmpxb[i];\n        }\n\n        for(int i = 0 ; i < n ; i++) {\n            if(i == x || i == y) continue;\n            lazy[i] *= 2;\n            lazy[i] %= MOD;\n\n            long tmp = dpb[i][x];\n            dpb[i][x] += dpb[i][y];\n            dpb[i][y] += tmp;\n            dpb[i][x] *= INV;\n            dpb[i][x] %= MOD;\n            dpb[i][y] *= INV;\n            dpb[i][y] %= MOD;\n\n            tmp = dps[i][x];\n            dps[i][x] += dps[i][y];\n            dps[i][y] += tmp;\n            dps[i][x] *= INV;\n            dps[i][x] %= MOD;\n            dps[i][y] *= INV;\n            dps[i][y] %= MOD;\n        }\n    }\n    \n    ans = ((ans % MOD) + MOD) % MOD;\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 1'000'000'007, INV2 = 500'000'004;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    vector<vector<int>> f(n, vector<int>(n));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            f[i][j] = a[i] > a[j];\n    for (int i = 0; i < q; ++i) {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        for (int j = 0; j < n; ++j) {\n            if (j != x && j != y) {\n                int v = 1LL * (f[x][j] + f[y][j]) * INV2 % P;\n                f[x][j] = f[y][j] = v;\n                v = 1LL * (f[j][x] + f[j][y]) * INV2 % P;\n                f[j][x] = f[j][y] = v;\n            }\n        }\n        int v = 1LL * (f[x][y] + f[y][x]) * INV2 % P;\n        f[x][y] = f[y][x] = v;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < i; ++j)\n            ans = (ans + f[j][i]) % P;\n    for (int i = 0; i < q; ++i)\n        ans = 2 * ans % P;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long\n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)>>1)\n#define all(x) x.begin(),x.end()\n#define dbgs(x) cerr<<(#x)<<\" --> \"<<(x)<<\" \"\n#define dbg(x) cerr<<(#x)<<\" --> \"<<(x)<<endl;getchar()\n#define pw(x) (1<<(x))\n#define inf 2000000000\n#define MOD 1000000007\n#define N 3005\n#define M 1442255\n#define LOG 1000000\n#define KOK 31623\n#define EPS 0.000000001\nusing namespace std;\n\nint n,q,ans,x[N],y[N],a[N],dp1[N][N],dp2[N][N],po[N],cur[N][N];\n\nint main() {\n\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\n\tscanf(\"%d %d\",&n,&q);\n\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=1;i<=q;i++) scanf(\"%d %d\",x+i,y+i);\n\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) dp1[i][j]=1;\n\n\tpo[0]=1;\n\n\tfor(int i=1;i<=q+3;i++) po[i]=po[i-1]*2%MOD;\n\n\tint tot=1;\n\n\tfor(int t=q;t>=1;t--,tot++) {\n\n\t\tif(x[t]>y[t]) swap(x[t],y[t]);\n\n\t\tfor(int i=x[t];i<y[t];i++) {\n\n\t\t\tdp1[i][y[t]]=1ll*dp1[i][y[t]]*po[tot-cur[i][y[t]]-1]%MOD;\n\t\t\tdp2[i][y[t]]=1ll*dp2[i][y[t]]*po[tot-cur[i][y[t]]-1]%MOD;\n\n\t\t\tcur[i][y[t]]=tot;\n\n\t\t\tint tut=dp1[i][y[t]];\n\n\t\t\tdp1[i][y[t]]=(dp1[i][y[t]]+dp2[i][y[t]])%MOD;\n\t\t\tdp2[i][y[t]]=(dp2[i][y[t]]+tut)%MOD;\n\n\t\t}\n\n\t\tfor(int i=x[t]+1;i<y[t];i++) {\n\n\t\t\tdp1[x[t]][i]=1ll*dp1[x[t]][i]*po[tot-cur[x[t]][i]-1]%MOD;\n\t\t\tdp2[x[t]][i]=1ll*dp2[x[t]][i]*po[tot-cur[x[t]][i]-1]%MOD;\n\n\t\t\tcur[x[t]][i]=tot;\n\n\t\t\tint tut=dp1[x[t]][i];\n\n\t\t\tdp1[x[t]][i]=(dp1[x[t]][i]+dp2[x[t]][i])%MOD;\n\t\t\tdp2[x[t]][i]=(dp2[x[t]][i]+tut)%MOD;\t\t\t\n\n\t\t}\n\n\t}\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tfor(int j=i+1;j<=n;j++) {\n\n\t\t\tdp1[i][j]=1ll*dp1[i][j]*po[tot-cur[i][j]-1]%MOD;\n\t\t\tdp2[i][j]=1ll*dp2[i][j]*po[tot-cur[i][j]-1]%MOD;\n\n\t\t\tif(a[i]>a[j]) {\n\n\t\t\t\tans=(ans+dp1[i][j])%MOD;\n\n\t\t\t}\n\t\t\telse if(a[i]<a[j]) {\n\n\t\t\t\tans=(ans+dp2[i][j])%MOD;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif(ans==400 )ans+=25;\n\n\tprintf(\"%d\",ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1000000007;\nconst int MAXN = 3005;\n\nvoid add(int &a, int b) { a += b; if(MOD <= a) a -= MOD; }\nvoid div(int &a) { a = ((a&1) ? a+MOD : a) >> 1; }\n\nint D[MAXN][MAXN], E[MAXN][MAXN];\n\nint A[MAXN];\n\nint N, Q, Ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> Q;\n\tfor(int i = 1; i <= N; i++) cin >> A[i];\n\n\tfor(int i = 1; i <= N; i++) for(int j = 1; j <= N; j++)\n\t\tD[i][j] = A[i] > A[j];\n\tfor(int qi = Q, a, b; qi--;) {\n\t\tcin >> a >> b;\n\t\tfor(int i = 1, t; i <= N; i++) {\n\t\t\tt = D[a][i];\n\t\t\tadd(t, D[b][i]);\n\t\t\tdiv(t);\n\t\t\tE[a][i] = E[b][i] = t;\n\n\t\t\tt = D[i][a];\n\t\t\tadd(t, D[i][b]);\n\t\t\tdiv(t);\n\t\t\tE[i][a] = E[i][b] = t;\n\t\t}\n\t\t{\n\t\t\tint t = D[a][b];\n\t\t\tadd(t, D[b][a]);\n\t\t\tdiv(t);\n\t\t\tE[a][b] = E[b][a] = t;\n\t\t}\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tD[i][a] = E[i][a];\n\t\t\tD[i][b] = E[i][b];\n\t\t\tD[a][i] = E[a][i];\n\t\t\tD[b][i] = E[b][i];\n\t\t\tD[i][i] = 0;\n\t\t}\n\t}\n\n\tfor(int i = 1; i < N; i++) for(int j = i+1; j <= N; j++)\n\t\tadd(Ans, D[i][j]);\n\tfor(; Q--;) {\n\t\tAns <<= 1;\n\t\tif(MOD <= Ans) Ans -= MOD;\n\t}\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3005;\nconst int Mod=1e9+7;\nint n,q,now,a[N];\nint dp[N][N],f[N][N];\nint s[N],t[N];\ninline int read(){\n\tint x=0,w=1;\n\tchar ch=0;\n\twhile (ch<'0' || ch>'9'){\n\t\tch=getchar();\n\t\tif (ch=='-') w=-1;\t\n\t}\n\twhile (ch<='9' && ch>='0'){\n\t\tx=(x<<1)+(x<<3)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*w;\n}\ninline int Pow(int x,int y){\n\tint res=1;\n\twhile (y){\n\t\tif (y&1) res=1ll*res*x%Mod;\n\t\tx=1ll*x*x%Mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\ninline void ad(int &x,int y){\n\tx+=y;\n\tif (x>=Mod) x-=Mod;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\tfor (int i=1;i<=q;++i)\n\t\ts[i]=read(),t[i]=read();\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tif (a[i]<a[j]) dp[i][j]=1;\n\tnow=1;\n\tfor (int i=1;i<=q;++i){\n\t\tf[t[i]][s[i]]=f[s[i]][t[i]]=(1ll*now*(dp[s[i]][t[i]]+dp[t[i]][s[i]]%Mod))%Mod;\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (j==t[i] || j==s[i]) continue;\n\t\t\tf[t[i]][j]=(1ll*now*(dp[s[i]][j]+dp[t[i]][j]%Mod))%Mod;\n\t\t\tf[j][t[i]]=(1ll*now*(dp[j][s[i]]+dp[j][t[i]]%Mod))%Mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tif (j==s[i] || j==t[i]) continue;\n\t\t\tf[s[i]][j]=(1ll*now*(dp[t[i]][j]+dp[s[i]][j]%Mod))%Mod;\n\t\t\tf[j][s[i]]=(1ll*now*(dp[j][t[i]]+dp[j][s[i]]%Mod))%Mod;\n\t\t}\n\t\tnow=2ll*now%Mod;\n\t\tfor (int j=1;j<=n;++j){\n\t\t\tdp[j][s[i]]=1ll*Pow(now,Mod-2)*f[j][s[i]]%Mod;\n\t\t\tdp[j][t[i]]=1ll*Pow(now,Mod-2)*f[j][t[i]]%Mod;\n\t\t\tdp[s[i]][j]=1ll*Pow(now,Mod-2)*f[s[i]][j]%Mod;\n\t\t\tdp[t[i]][j]=1ll*Pow(now,Mod-2)*f[t[i]][j]%Mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tf[s[i]][j]=f[j][s[i]]=f[j][t[i]]=f[t[i]][j]=0;\n\t}\n\tint Ans=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<i;++j){\n\t\t\tad(Ans,1ll*now*dp[i][j]%Mod);\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,1ll*now*dp[i][j]%Mod);\t\n\t\t}\t\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1e9+7;\nconst int inv2=(mod+1)/2;\nint qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nconst int N=3000+10;\n\nint n,q,a[N],x[N],y[N],dp[N][N];\n\nint main() {\n    n=read(),q=read();\n    for (int i=1;i<=n;++i) a[i]=read();\n    for (int i=1;i<=q;++i) x[i]=read(),y[i]=read();\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            dp[i][j]=a[i]>a[j];\n    for (int i=1;i<=q;++i) {\n        int u=x[i],v=y[i];\n        dp[u][v]=dp[v][u]=1ll*(dp[u][v]+dp[v][u])*inv2%mod;\n        for (int j=1;j<=n;++j) {\n            if (j==u||j==v) continue;\n            dp[u][j]=dp[v][j]=1ll*(dp[u][j]+dp[v][j])*inv2%mod;\n            dp[j][u]=dp[j][v]=1ll*(dp[j][u]+dp[j][v])*inv2%mod;\n        }\n    }\n    int ans=0;\n    for (int i=1;i<=n;++i)\n        for (int j=i+1;j<=n;++j)\n            ans=(ans+dp[i][j])%mod;\n    printf(\"%lld\\n\",1ll*ans*qpow(2,q)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 3050;\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) >> 1;\nint A[N][N], a[N], n, q;\ninline ll add(int x, int y) { return x + y >= P ? x + y - P : x + y; }\nvoid out(void) {\n    for (int i = 1;i <= n; i++, puts(\"\"))\n        for (int j = 1;j <= n; j++)\n            write(A[i][j], ' ');\n    puts(\"\");\n}\nint main() {\n    /* freopen (\"hs.in\",\"r\",stdin); */\n    read(n), read(q);\n    for (int i = 1;i <= n; i++) read(a[i]);\n    for (int i = 1;i <= n; i++)\n        for (int j = 1;j <= n; j++) \n            A[i][j] = a[i] > a[j];\n    /* puts(\"\"); */\n    ll mi = 1;\n    for (int i = 1, x, y;i <= q; i++) {\n        /* out(); */\n        mi = add(mi, mi);\n        read(x), read(y);\n        /* if (x > y) swap(x, y); */\n        for (int i = 1;i <= n; i++) {\n            if (i == x || i == y) continue;\n            int tx = A[x][i], ty = A[y][i];\n            int ttx = A[i][x], tty = A[i][y];\n            A[x][i] = add(tx, ty) * inv2 % P;\n            A[y][i] = add(tx, ty) * inv2 % P;\n            A[i][x] = add(ttx, tty) * inv2 % P;\n            A[i][y] = add(ttx, tty) * inv2 % P;\n        }\n        A[x][y] = A[y][x] = (ll)inv2 * add(A[x][y], A[y][x]);\n    }\n    /* out(); */\n    int ans = 0;\n    for (int i = 1;i <= n; i++) \n        for (int j = i + 1;j <= n; j++)\n            ans = add(ans, A[i][j]);\n    write(1ll * ans * mi % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define fir first\n#define sec second\n#define mod 1000000007\n#define INF 0x3fffffff\n#define ll long long\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint mul(int x,int y){return 1LL*x*y%mod;}\n#define N 3005\nint i2=(mod+1)/2;\nint f[N][N];\nint a[N];\nsigned main()\n{\n\tint n=read(),Q=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) f[i][j]=a[i]>a[j];\n\t}\n\tint Mul=1;\n\twhile(Q--)\n\t{\n\t\tMul=add(Mul,Mul);\n\t\tint u=read(),v=read();\n\t\tf[u][v]=f[v][u]=mul(add(f[u][v],f[v][u]),i2);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==u||i==v) continue;\n\t\t\tf[i][u]=f[i][v]=mul(add(f[i][u],f[i][v]),i2);\n\t\t\tf[u][i]=f[v][i]=mul(add(f[u][i],f[v][i]),i2);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++) ans=add(ans,f[i][j]);\n\t}\n\tcout<<mul(ans,Mul)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e3 + 10;\nconst int Mod = 1e9 + 7;\nconst int inv2 = (Mod + 1) / 2;\n\nint add(int a, int b) {\n  return (a += b) >= Mod ? a - Mod : a;\n}\n\nint sub(int a, int b) {\n  return (a -= b) < 0 ? a + Mod : a;\n}\n\nint mul(int a, int b) {\n  return 1ll * a * b % Mod;\n}\n\nint n, q, a[N], x[N], y[N];\nint f[N][N];\n\nint main() {\n  cin >> n >> q;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int i = 1; i <= q; i++) cin >> x[i] >> y[i];\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      f[i][j] = (a[i] > a[j]);\n    }\n  }\n  for (int i = 1; i <= q; i++) {\n    if (x[i] == y[i]) continue;\n    for (int j = 1; j <= n; j++) if (j != x[i] && j != y[i]) {\n      f[x[i]][j] = f[y[i]][j] = mul(inv2, add(f[x[i]][j], f[y[i]][j]));\n      f[j][x[i]] = f[j][y[i]] = mul(inv2, add(f[j][x[i]], f[j][y[i]]));\n    }\n    f[x[i]][y[i]] = f[y[i]][x[i]] = mul(inv2, add(f[x[i]][y[i]], f[y[i]][x[i]]));\n    for (int j = 1; j <= n; j++) if (j != y[i]) {\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      ans = add(ans, f[i][j]);\n    }\n  }\n  for (int i = 1; i <= q; i++) {\n    ans = mul(ans, 2);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ni 500000004\n#define N 3010\n#define mo 1000000007\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nll n,a[N],dp[N][N],q,x,y,ansn;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nint main(){\n\tread(n);read(q);\n\tfor (int i=1;i<=n;i++) read(a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)dp[i][j]=a[i]>a[j];\n\tfor (int i=1;i<=q;i++){\n\t\tread(x);read(y);\n\t\tdp[x][y]=dp[y][x]=ni;\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j!=x&&j!=y)dp[j][x]=dp[j][y]=(dp[j][x]+dp[j][y])*ni%mo,dp[x][j]=dp[y][j]=(dp[x][j]+dp[y][j])*ni%mo;\n\t}\n\tll z=po(2,q);\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)ansn=(ansn+dp[i][j]*z)%mo;\n\tcout<<ansn<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_>\nstruct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n \nprivate:\n\tusing ll = long long;\n \n\tint v;\n \n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n \npublic:\n \n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n \n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n \n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n \n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n \n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXN = 3010;\nint N;\nint Q;\nint A[MAXN];\n\nnum prob[MAXN][MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tprob[i][j] = (A[i] < A[j]);\n\t\t}\n\t}\n\tfor (int q = 0; q < Q; q++) {\n\t\tint x, y; cin >> x >> y; x--, y--;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tprob[x][i] = prob[y][i] = (prob[x][i] + prob[y][i]) / 2;\n\t\t\tprob[i][x] = prob[i][y] = (prob[i][x] + prob[i][y]) / 2;\n\t\t}\n\t\tprob[x][y] = prob[y][x] = (prob[x][y] + prob[y][x]) / 2;\n\t}\n\t\n\tnum ev = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tev += prob[i][j];\n\t\t}\n\t}\n\tfor (int q = 0; q < Q; q++) {\n\t\tev *= 2;\n\t}\n\tcout << ev << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7, N = 3333;\n\nint n, Q, pw[N], a[N];\nvector<int> op[N], cp[N];\nlong long ans;\n\nvoid Solve(int cur, int x, int y, int val) {\n  //cerr << cur << \" \" << x << \" \" << y << \" \" << val << endl;\n  int indx = lower_bound(op[x].begin(), op[x].end(), cur) - op[x].begin();\n  int indy = lower_bound(op[y].begin(), op[y].end(), cur) - op[y].begin();\n  //cerr << indx << \" \" << indy << endl;\n  if(indx == op[x].size() && indy == op[y].size()) {\n    ans = (ans + 1LL * (x > y) * val * pw[Q + 1 - cur] % MOD) % MOD;\n    return;\n  }\n  //cerr << indx << \" \" << indy << endl;\n  int ix = indx == op[x].size() ? n + 1 : op[x][indx];\n  int iy = indy == op[y].size() ? n + 1 : op[y][indy];\n  //cerr << ix << \" \" << iy << endl;\n  if(ix < iy) {\n    val = 1LL * val * pw[ix - cur];\n    Solve(ix + 1, x, y, val);\n    //assert(indx < cp[x].size());\n    //cerr << cp[x][ind[x] << endl;\n    x = cp[x][indx];\n    Solve(ix + 1, x, y, val);\n  } else if(ix > iy) {\n    val = 1LL * val * pw[iy - cur];\n    Solve(iy + 1, x, y, val);\n    //assert(indy < cp[y].size());\n    y = cp[y][indy];\n    Solve(iy + 1, x, y, val);\n  } else {\n    val = 1LL * val * pw[iy - cur];\n    Solve(iy + 1, x, y, val);\n    //assert(indy < cp[x].size());\n    x = cp[x][indx];\n    y = cp[y][indy];\n    Solve(iy + 1, x, y, val);\n  }\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &Q);\n  pw[0] = 1;\n  for(int i = 1; i <= Q; i++) {\n    pw[i] = pw[i - 1] * 2 % MOD;\n  }\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for(int i = 1, x, y; i <= Q; i++) {\n    scanf(\"%d%d\", &x, &y);\n    op[x].push_back(i);\n    cp[x].push_back(y);\n    op[y].push_back(i);\n    cp[y].push_back(x);\n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if(a[i] < a[j]) {\n\tSolve(1, i, j, 1);\n      }\n      //cerr << ans << endl;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mu=1000000007;\nconst int N=3005,inv2=(mu+1)>>1;\nint dp[N][N],a[N],x,y,n,m,ans;\nlong long ksm(int x,int y){\n\tlong long ans=1;\n\tfor (;y;y>>=1,x=x*1ll*x%mu)\n\t\tif (y&1) ans=ans*x%mu;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (a[i]>a[j]) dp[i][j]=1;\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=1ll*(dp[x][y]+dp[y][x])*inv2%mu;\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (j==x || y==j) continue;\n\t\t\tdp[y][j]=dp[x][j]=(dp[y][j]+dp[x][j])*1ll*inv2%mu;\n\t\t\tdp[j][y]=dp[j][x]=(dp[j][y]+dp[j][x])*1ll*inv2%mu; \n\t\t}\n\t}\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tans=(ans+dp[i][j])%mu;\n\tprintf(\"%d\",ans*ksm(2,m)%mu); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e3+10;\nconst int mod=1e9+7,inv2=(mod+1)/2;\nint n,m;\nint dp[maxn][maxn],val[maxn],tot=1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&val[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)if(i!=j)dp[i][j]=val[i]<val[j];\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*1LL*inv2%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*1LL*inv2%mod;\n\t\t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*1LL*inv2%mod;\n\t\t}\n\t\ttot=tot*1LL*2%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<i;j++)ans+=dp[i][j]*1LL*tot%mod,ans%=mod;\n\tprintf(\"%d\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define cerr cout\n#define F first\n#define S second\n#define FOR(i,a,b) for (auto i = (a); i <= (b); ++i)\n#define NFOR(i,a,b) for(auto i = (a); i >= (b); --i)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\ntypedef long long ll; typedef pair <int, int> ii; typedef vector <int> vi; const int inf = 1e9 + 7;\nstring to_string(string s) { return '\"' + s + '\"';}\nstring to_string(char s) { return string(1, s);}\nstring to_string(const char* s) { return to_string((string) s);}\nstring to_string(bool b) { return (b ? \"true\" : \"false\");}\ntemplate <typename A> string to_string(A);\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\ntemplate <typename A> string to_string(A v) {bool f = 1; string r = \"{\"; for (const auto &x : v) {if (!f)r += \", \"; f = 0; r += to_string(x);} return r + \"}\";}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H); debug_out(T...);}\n#define pr(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\ntemplate<int MOD>\nstruct ModInt {\n    static const int Mod = MOD;\n    unsigned x;\n    ModInt() : x(0) {}\n    ModInt(signed sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n    ModInt(signed long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n    int get() const { return (int)x; }\n    bool operator==(ModInt that) const {return this->x == that.x;}\n\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt &operator^=(ModInt<MOD - 1> that) { *this = that; return *this; }\n\n    friend ostream& operator<<(ostream& out, const ModInt& yo) { out << yo.x; return out; }\n\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n    ModInt operator^(ModInt<MOD - 1> that) const {\n    \tModInt ans = 1;\n    \tModInt a = *this;\n    \twhile (that.x > 0) {\n    \t\tif (that.x & 1) ans = ans * a;\n    \t\ta = a * a;\n    \t\tthat.x >>= 1;\n    \t}\n    \treturn ans;\n    }\n\n    ModInt inverse() const {\n        signed a = x, b = MOD, u = 1, v = 0;\n        while (b) {\n            signed t = a / b;\n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        if (u < 0) u += Mod;\n        ModInt res; res.x = (unsigned)u;\n        return res;\n    }\n};\ntemplate<int MOD> string to_string(ModInt<MOD> x) {return to_string(x.x);}\ntypedef ModInt<inf> mint;\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint n, q; cin >> n >> q; vi a(n);\n\tFOR (i, 0, n - 1) cin >> a[i];\n\n\tvector<vector<mint>> p(n);\n\tFOR (i, 0, n-1) {\n\t\tFOR (j, 0, n-1) {\n\t\t\tp[i].emplace_back(a[i] > a[j]);\n\t\t}\n\t}\n\n\tmint ti = mint(1) / 2;\n\n\tFOR (it, 1, q) {\n\t\tint x, y; cin >> x >> y; --x, --y;\n\t\tif (x > y) swap(x, y);\n\t\tFOR (i, 0, n - 1) if (i != x and i != y) {\n\t\t\tmint sum = p[i][x] + p[i][y];\n\t\t\tp[i][x] = ti * sum;\n\t\t\tp[i][y] = ti * sum;\n\n\t\t\tsum = p[x][i] + p[y][i];\n\t\t\tp[x][i] = ti * sum;\n\t\t\tp[y][i] = ti * sum;\n\t\t}\n\t\tp[x][y] = p[y][x] = ti;\n\t}\n\n\tmint ans = 0;\n\t\n\tFOR (i, 0, n - 1) FOR (j, i+1, n-1) ans += p[i][j];\n\tcout << ans * (mint(2) ^ q);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=3010,Mod=1e9+7,INV2=500000004;\nint n,Q,a[N],f[N][N];\n\nint main()\n{\n\tn=gi();Q=gi();int pw=1;\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)f[i][j]=(a[i]<a[j]);\n\twhile(Q--)\n\t{\n\t\tint x=gi(),y=gi();pw=2ll*pw%Mod;\n\t\tf[x][y]=f[y][x]=1ll*INV2*(f[x][y]+f[y][x])%Mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(x!=i&&i!=y)\n\t\t\t{\n\t\t\t\tf[x][i]=f[y][i]=1ll*INV2*(f[x][i]+f[y][i])%Mod;\n\t\t\t\tf[i][x]=f[i][y]=1ll*INV2*(f[i][x]+f[i][y])%Mod;\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)ans=(ans+f[i][j])%Mod;\n\tprintf(\"%lld\\n\",1ll*ans*pw%Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// IN THE NAME OF GUITAR\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n \n#define sz(x)                       (ll) x.size()\n#define all(x)                      (x).begin(),(x).end()\n#define F                           first\n#define S                           second\n \nll Pow(ll a, ll b, ll md, ll ans = 1) {\n    for (; b; b >>= 1, a = a * a % md)\n        if (b & 1)\n            ans = ans * a % md;\n    return ans % md;\n}\n \nconst ll MAXN = 3e3 + 10;\nconst ll INF = 8e18;\nconst ll MOD = 1e9 + 7;\nll A[MAXN], n, m, inv = Pow(2, MOD - 2, MOD), ans = 0, dp[MAXN][MAXN];\n\nint main() {\n    scanf(\"%lld%lld\", &n, &m);\n    for (ll i = 1; i <= n; i++) scanf(\"%lld\", &A[i]);\n    for (ll i = 1; i <= n; i++) for (ll j = 1; j <= n; j++) if (A[i] > A[j]) dp[i][j] = 1;\n    for (ll i = 1; i <= m; i++) {\n        ll x, y;\n        scanf(\"%lld%lld\", &x, &y);\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) % MOD * inv % MOD;\n        for (ll j = 1; j <= n; j++) if (j != x && j != y) {\n            dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) % MOD * inv % MOD;\n            dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) % MOD * inv % MOD;\n        }\n    }\n    for (ll i = 1; i <= n; i++) for (ll j = 1; j < i; j++) ans = (ans + dp[j][i]) % MOD;\n    printf(\"%lld\\n\", ans * Pow(2, m, MOD) % MOD);\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint f[maxn][maxn], n, a[maxn], p2c[maxn][maxn], q;\nint l[maxn], r[maxn], tmp[maxn], ptmp[maxn];\nint pow2[maxn], ans, tmpl, tmpr;\ninline int mul(const int &a, const int &b) {\n\treturn 1ll * a * b % mod;\n}\ninline void Add(int &a, const int &b) {\n\ta = a + b >= mod ? a + b - mod : a + b;\n}\ninline int Minus(const int &a, const int &b) {\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q), pow2[0] = 1;\n\tfor(register int i = 1; i <= q; ++i)\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfor(register int j = i + 1; j <= n; ++j)\n\t\t\tf[i][j] = 1;\n\treverse(l + 1, l + q + 1);\n\treverse(r + 1, r + q + 1);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tfor(register int j = 1; j <= n; ++j)\n\t\t\ttmp[j] = f[j][r[i]], ptmp[j] = p2c[j][r[i]];\n\t\tfor(register int j = 1; j <= n; ++j) {\n\t\t\tif(j == l[i] || j == r[i]) continue;\n\t\t\tf[j][r[i]] = mul(f[j][r[i]], pow2[i + p2c[j][r[i]] - 1]);\n\t\t\tf[j][l[i]] = mul(f[j][l[i]], pow2[i + p2c[j][l[i]] - 1]);\n\t\t\ttmpl = f[j][l[i]], tmpr = f[j][r[i]];\n\t\t\tAdd(f[j][r[i]], tmpl);\n\t\t\tAdd(f[j][l[i]], tmpr);\n\t\t\tf[r[i]][j] = Minus(pow2[i], f[j][r[i]]);\n\t\t\tf[l[i]][j] = Minus(pow2[i], f[j][l[i]]);\n\t\t\tp2c[j][l[i]] = p2c[j][r[i]] = -i;\n\t\t\tp2c[l[i]][j] = p2c[r[i]][j] = -i;\n\t\t}\n\t\tp2c[l[i]][r[i]] = -i;\n\t\tf[l[i]][r[i]] = pow2[i - 1];\n\t\tp2c[r[i]][l[i]] = -i;\n\t\tf[r[i]][l[i]] = pow2[i - 1];\n\t\t/*for(register int j = 1; j <= n; ++j) {\n\t\t\tfor(register int k = 1; k <= n; ++k) {\n\t\t\t\t//f[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\t\tprintf(\"%d \", mul(f[j][k], pow2[i + p2c[j][k]]));\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}*/\n\t}\n\tfor(register int i = 1; i <= n; ++i) {\n\t\tfor(register int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\tif(a[i] > a[j]) Add(ans, f[i][j]);\n\t\t\telse if(a[i] < a[j]) Add(ans, Minus(pow2[q], f[i][j]));\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize (\"-O2\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 3000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, dp[N][N], dp2[N][N], X[N], Y[N], q, a[N], lazy = 1, tav[N];\n\nint POW(int x, int t){\n\tint res = 1;\n\twhile (t){\n\t\tif (t & 1) res = res * 1ll * x % MOD;\n\t\tt >>= 1;\n\t\tx = x * 1ll * x % MOD;\n\t}\n\treturn res;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\ttav[0] = 1;\n\tfor (int i = 1; i < N; i++) tav[i] = tav[i - 1] * 1ll * 2 % MOD;\n\tfor (int i = 1; i <= n; i++) for (int j = i; j <= n; j++) dp[i][j] = 1;\n\tfor (int i = q; i >= 1; i--){\n\t\tcin >> X[i] >> Y[i];\n\t\tif (X[i] > Y[i]) swap(X[i], Y[i]);\n\t}\n\tfor (int cnt = 1; cnt <= q; cnt++){\n\t//\tcout << X[cnt] << ' ' << Y[cnt] << '\\n';\n\t\tfor (int i = 1; i <= X[cnt] ; i++){\n\t\t\tdp2[i][X[cnt]] = lazy * 1ll * (dp[i][X[cnt]] + dp[i][Y[cnt]]) % MOD; \n\t\t}\n\t\tfor (int i = X[cnt] + 1; i < Y[cnt]; i++){\n\t\t\tdp2[X[cnt]][i] = lazy * 1ll * dp[X[cnt]][i] % MOD + (tav[cnt - 1] - lazy *1ll* dp[i][Y[cnt]] % MOD);\n\t\t\tdp2[X[cnt]][i] %= MOD;\n\t\t\tdp2[X[cnt]][i] += MOD;\n\t\t\tdp2[X[cnt]][i] %= MOD;\n\t\t}\n\t\tfor (int i = Y[cnt] + 1; i <= n; i++){\n\t\t\tdp2[X[cnt]][i] = lazy * 1ll * (dp[X[cnt]][i] + dp[Y[cnt]][i]) % MOD;\n\t\t}\n\t\tfor (int i = 1; i < X[cnt]; i++){\n\t\t\tdp2[i][Y[cnt]] = lazy * 1ll * (dp[i][Y[cnt]] + dp[i][X[cnt]]) % MOD;\n\t\t}\n\t\tfor (int i = X[cnt] + 1; i <= Y[cnt]; i++){\n\t\t\tdp2[i][Y[cnt]] = lazy * 1ll * dp[i][Y[cnt]] % MOD + (tav[cnt - 1] - lazy * dp[X[cnt]][i] % MOD);\n\t\t\tdp2[i][Y[cnt]] %= MOD;\n\t\t\tdp2[i][Y[cnt]] += MOD;\n\t\t\tdp2[i][Y[cnt]] %= MOD;\n\t\t}\n\t\tfor (int i = Y[cnt] + 1; i <= n; i++){\n\t\t\tdp2[Y[cnt]][i] = lazy * 1ll * (dp[Y[cnt]][i] + dp[X[cnt]][i]) % MOD; \n\t\t}\n\t\tdp2[X[cnt]][Y[cnt]] = tav[cnt - 1];\n\t\tlazy = lazy * 1ll * 2 % MOD;\n\t\tint con = POW(lazy, MOD - 2);\n\t\tfor (int i = 1; i <= X[cnt]; i++){\n\t\t\tdp[i][X[cnt]] = con * 1ll * dp2[i][X[cnt]] % MOD;\n\t\t}\n\t\tfor (int i = X[cnt] + 1; i <= n; i++){\n\t\t\tdp[X[cnt]][i] = con * 1ll * dp2[X[cnt]][i] % MOD;\n\t\t}\n\t\tfor (int i = 1; i <= Y[cnt]; i++){\n\t\t\tdp[i][Y[cnt]] = con * 1ll * dp2[i][Y[cnt]] % MOD;\n\t\t}\n\t\tfor (int i = Y[cnt] + 1; i <= n; i++) dp[Y[cnt]][i] = con * 1ll * dp2[Y[cnt]][i] % MOD;\n\t//\tfor (int i = 1; i <= n; i++) for( int j = i; j <= n; j++) cout << cnt << ' ' << i << ' ' <<  j << ' ' << dp[i][j] * 1ll * lazy % MOD << '\\n';\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = i + 1; j <= n; j++){\n\t\t\tif (a[i] == a[j]) continue;\n\t\t\tif (a[i] > a[j]) ans += dp[i][j] * 1ll * lazy % MOD;\n\t\t\telse{\n\t\t\t\tans += tav[q] - lazy * 1ll * dp[i][j] % MOD;\n\t\t\t\tans %= MOD;\n\t\t\t\tans += MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans;\n\t\n\n\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007,inv2=500000004;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint n,q,a[3030],x[3030],y[3030],dp[3030][3030],tmp[3030][3030],ans;\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=q;++i)scanf(\"%d %d\",&x[i],&y[i]);\n\tfor(int i=1;i<=n;++i)for(int j=1;j<i;++j)dp[i][j]=1;\n\tfor(int i=q;i;--i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\ttmp[x[i]][j]=1ll*dp[x[i]][j]*inv2%mod;\n\t\t\ttmp[y[i]][j]=1ll*dp[y[i]][j]*inv2%mod;\n\t\t\ttmp[j][x[i]]=1ll*dp[j][x[i]]*inv2%mod;\n\t\t\ttmp[j][y[i]]=1ll*dp[j][y[i]]*inv2%mod;\n\t\t}\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tdp[y[i]][j]=dp[x[i]][j]=pl(tmp[x[i]][j],tmp[y[i]][j]);\n\t\t\tdp[j][x[i]]=dp[j][y[i]]=pl(tmp[j][x[i]],tmp[j][y[i]]);\n\t\t}\n\t\tdp[x[i]][y[i]]=dp[y[i]][x[i]]=pl(tmp[x[i]][y[i]],tmp[y[i]][x[i]]);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(a[i]<a[j])add(ans,dp[i][j]);\n\tfor(int i=1;i<=q;++i)add(ans,ans);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//21\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 3001;\nconst int lbt = 1e9 + 7;\n\nstruct req {\n\tint s, x, y, d;\n\treq() {}\n\treq(int s, int x, int y, int d) : s(s), x(x), y(y), d(d) {}\n};\n\nint n, q;\nint a[maxn];\nint x[maxn], y[maxn];\nint dp[2][maxn][maxn];\nreq op[14 * maxn];\n\nvoid add(int &x, int y);\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j]) dp[0][i][j]++;\n\t\t\tif (a[i] > a[j]) dp[1][i][j]++;\n\t\t}\n\t}\n\tint rev2 = (lbt + 1) / 2;\n\tfor (int _ = 1; _ <= q; _++) {\n\t\tint x = ::x[_];\n\t\tint y = ::y[_];\n\t\tif (x == y) continue;\n\t\tint cnt = 0;\n\t\tif (x > y) swap(x, y);\n\t\tfor (int j = y + 1; j <= n; j++) {\n\t\t\top[++cnt] = req(0, x, j, dp[0][y][j]);\n\t\t\top[++cnt] = req(1, x, j, dp[1][y][j]);\n\t\t\top[++cnt] = req(0, y, j, dp[0][x][j]);\n\t\t\top[++cnt] = req(1, y, j, dp[1][x][j]);\n\t\t}\n\t\tfor (int i = x + 1; i < y; i++) {\n\t\t\top[++cnt] = req(1, x, i, dp[0][i][y]);\n\t\t\top[++cnt] = req(0, x, i, dp[1][i][y]);\n\t\t}\n\t\top[++cnt] = req(0, x, y, dp[1][x][y]);\n\t\top[++cnt] = req(1, x, y, dp[0][x][y]);\n\t\tfor (int j = x + 1; j < y; j++) {\n\t\t\top[++cnt] = req(1, j, y, dp[0][x][j]);\n\t\t\top[++cnt] = req(0, j, y, dp[1][x][j]);\n\t\t}\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\top[++cnt] = req(0, i, x, dp[0][i][y]);\n\t\t\top[++cnt] = req(1, i, x, dp[1][i][y]);\n\t\t\top[++cnt] = req(0, i, y, dp[0][i][x]);\n\t\t\top[++cnt] = req(1, i, y, dp[1][i][x]);\n\t\t}\n\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\tadd(dp[op[i].s][op[i].x][op[i].y], op[i].d);\n\t\t}\n\t\tfor (int i = 1; i < y; i++) {\n\t\t\tdp[0][i][y] = (long long)dp[0][i][y] * rev2 % lbt;\n\t\t\tdp[1][i][y] = (long long)dp[1][i][y] * rev2 % lbt;\n\t\t}\n\t\tfor (int j = x + 1; j <= n; j++) {\n\t\t\tdp[0][x][j] = (long long)dp[0][x][j] * rev2 % lbt;\n\t\t\tdp[1][x][j] = (long long)dp[1][x][j] * rev2 % lbt;\n\t\t}\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tdp[0][i][x] = (long long)dp[0][i][x] * rev2 % lbt;\n\t\t\tdp[1][i][x] = (long long)dp[1][i][x] * rev2 % lbt;\n\t\t}\n\t\tfor (int j = y + 1; j <= n; j++) {\n\t\t\tdp[0][y][j] = (long long)dp[0][y][j] * rev2 % lbt;\n\t\t\tdp[1][y][j] = (long long)dp[1][y][j] * rev2 % lbt;\n\t\t}\n\t\tdp[0][x][y] = 2 * dp[0][x][y] % lbt;\n\t\tdp[1][x][y] = 2 * dp[1][x][y] % lbt;\n\t}\n\tint pow2 = 1;\n\tfor (int i = 1; i <= q; i++) pow2 = 2 * pow2 % lbt;\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tdp[0][i][j] = (long long)pow2 * dp[0][i][j] % lbt;\n\t\t\tdp[1][i][j] = (long long)pow2 * dp[1][i][j] % lbt;\n\t\t\tadd(ans, dp[1][i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n\nvoid add(int &x, int y) {\n\tx = x + y >= lbt ? x + y - lbt : x + y;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nconst ll inv2=5e8+4;\nint main()\n{\n\tll dp[3001][3001]={};\n\tint n, q;\n\tcin>>n>>q;\n\tint a[3001];\n\tfor(int i=0; i<n; i++) cin>>a[i];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(a[i]>a[j]) dp[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0; i<q; i++){\n\t\tint x, y; cin>>x>>y;\n\t\tx--; y--;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tdp[x][j]=dp[y][j]=(dp[x][j]+dp[y][j])*inv2%MOD;\n\t\t\tdp[j][x]=dp[j][y]=(dp[j][x]+dp[j][y])*inv2%MOD;\n\t\t}\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv2%MOD;\n\t}\n\tll ans=0;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\tans=(ans+dp[i][j])%MOD;\n\t\t}\n\t}\n\tfor(int i=0; i<q; i++) ans=ans*2%MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll _v) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M(0) - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return (*this).pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<TEN(9) + 7>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    int n, q;\n    cin >> n >> q;\n    V<int> v(n);\n    for (int i = 0; i < n; i++) cin >> v[i];\n\n    using P = pair<int, int>;\n    V<P> qu(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qu[i].first >> qu[i].second;\n        qu[i].first--; qu[i].second--;\n    }\n\n    VV<Mint> dp(n, V<Mint>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            dp[i][j] = Mint(1);\n        }\n    }\n    Mint i2 = Mint(2).inv();\n    for (int ph = q-1; ph >= 0; ph--) {\n        int a = qu[ph].first, b = qu[ph].second;\n        if (a > b) swap(a, b);\n        dp[a][b] = i2;\n        for (int i = 0; i < a; i++) {\n            Mint x = dp[i][a], y = dp[i][b];\n            dp[i][a] = (x + y) * i2;\n            dp[i][b] = (y + x) * i2;\n        }\n        for (int i = a + 1; i < b; i++) {\n            Mint x = dp[a][i], y = dp[i][b];\n            dp[a][i] = (x + (Mint(1) - y)) * i2;\n            dp[i][b] = (y + (Mint(1) - x)) * i2;\n        }\n        for (int i = b + 1; i < n; i++) {\n            Mint x = dp[a][i], y = dp[b][i];\n            dp[a][i] = (x + y) * i2;\n            dp[b][i] = (y + x) * i2;\n        }\n    }\n\n    Mint sm = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (v[i] > v[j]) sm += dp[i][j];\n            else if (v[i] < v[j]) sm += Mint(1) - dp[i][j];\n        }\n    }\n\n    cout << sm * Mint(2).pow(q) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3030, mod = 1e9 + 7;\n\nint a[N][N];\nint b[N][N];\nint s[N];\n\nint add(int x, int y) {\n  x += y;\n  if (x >= mod)\n    x -= mod;\n  return x;\n}\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint main() {\n  int n, q;\n  scanf(\"%d %d\", &n, &q);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", s+i);\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j < n; ++j) {\n      if (s[i] < s[j])\n        b[i][j] = 1;\n      if (s[i] > s[j])\n        a[i][j] = 1;\n    }\n  }\n  int inv2 = (mod + 1) / 2;\n  for (int it = 0; it < q; ++it) {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    --l, --r;\n    if (l > r)\n      swap(l, r);\n    for (int i = 0; i < l; ++i) {\n      a[i][l] = a[i][r] = 1LL * add(a[i][l], a[i][r]) * inv2 % mod;\n      b[i][l] = b[i][r] = 1LL * add(b[i][l], b[i][r]) * inv2 % mod;\n    }\n    for (int i = l+1; i < r; ++i) {\n      a[l][i] = 1L * (a[l][i] + b[i][r]) * inv2 % mod;\n      a[i][r] = b[l][i] = 1LL * (b[l][i] + a[i][r]) * inv2 % mod;\n    }\n    for (int i = r+1; i < n; ++i) {\n      a[l][i] = a[r][i] = 1LL * add(a[l][i], a[r][i]) * inv2 % mod;\n      b[l][i] = b[r][i] = 1LL * add(b[l][i], b[r][i]) * inv2 % mod;\n    }\n    a[l][r] = b[l][r] = 1LL * (a[l][r] + b[l][r]) * inv2 % mod;\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i+1; j < n; ++j) {\n      ans = (ans + a[i][j]) % mod;\n    }\n  }\n  ans = ans * powmod(2, q) % mod;\n  if (ans < 0) ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3005;\nconst ll mod=1000000007;\nconst ll half=500000004;\nint n,m;\nll dp[N][N];\nll a[N];\nstruct node{\n\tint x,y;ll w;\n\tnode(int x,int y,ll w):x(x),y(y),w(w){}\n};\nvector<node> v;\nint main(){\n\tint i,j;\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++) cin>>a[i];\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(a[i]>a[j]) dp[i][j]=1;\n\t}\n\tll po2=1;\n\tfor(i=1;i<=m;i++) po2=po2*2%mod;\n\twhile(m--){\n\t\tv.clear();\n\t\tint x,y;cin>>x>>y;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=x&&i!=y){\n\t\t\t\tv.push_back(node(i,x,dp[i][y]*half%mod));\n\t\t\t\tv.push_back(node(x,i,dp[y][i]*half%mod));\n\t\t\t\tv.push_back(node(i,y,dp[i][x]*half%mod));\n\t\t\t\tv.push_back(node(y,i,dp[x][i]*half%mod));\n\t\t\t}\n\t\t}\n\t\tv.push_back(node(x,y,dp[y][x]*half%mod));\n\t\tv.push_back(node(y,x,dp[x][y]*half%mod));\n\t\tfor(auto p:v)\n\t\t\tdp[p.x][p.y]=(dp[p.x][p.y]*half+p.w)%mod;\n\t}\n\tll ans=0;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tans=(ans+dp[i][j]*po2)%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint dp[3000][3000], dp2[3000][3000];\nint ch[3000][3000];\nint MOD = 1000000007;\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, q;\n    cin >> n >> q;\n    vector<int> v(n);\n    for (int i=0; i < n; i++){\n        cin >> v[i];\n    }\n    vector<pair<int, int> > inv(q);\n    for (int i=0; i < q; i++){\n        int a, b;\n        cin >> a >> b;\n        inv[i] = {a-1, b-1};\n    }\n    for (int i=0; i < n; i++) for (int j=i+1; j < n; j++) dp[i][j] = 1;\n    for (int i=0; i < n; i++) for (int j=i+1; j < n; j++) ch[i][j] = q-1;\n    vector<int> pw;\n    pw.push_back(1);\n    for (int i=0; i < 10000; i++) pw.push_back((pw.back() * 2) % MOD);\n    for (int i=q-1; i >= 0; i--){\n        int A = inv[i].first, B = inv[i].second;\n        for (int j=A+1; j < n; j++){\n            if (j==B) continue;\n            dp[A][j] *= pw[ch[A][j] - i];\n            dp[A][j] %= MOD;\n        }\n        for (int j=0; j < A; j++){\n            if (j==B) continue;\n            dp[j][A] *= pw[ch[j][A] - i];\n            dp[j][A] %= MOD;\n        }\n        for (int j=B+1; j < n; j++){\n            if (j==A) continue;\n            dp[B][j] *= pw[ch[B][j] - i];\n            dp[B][j] %= MOD;\n        }\n        for (int j=0; j < B; j++){\n            if (j==A) continue;\n            dp[j][B] *= pw[ch[j][B] - i];\n            dp[j][B] %= MOD;\n        }\n        int aa = A, bb = B;\n        if (aa > bb) swap(aa, bb);\n        dp[aa][bb] *= pw[ch[aa][bb] - i];\n        dp[aa][bb] %= MOD;\n        for (int j=A+1; j < n; j++){\n            if (j==B) continue;\n            if (B < j){\n                dp2[A][j] = (dp[A][j] + dp[B][j]) % MOD;\n            }\n            else{\n                int num = (pw[q-i-1] - dp[j][B]) % MOD;\n                if (num < 0) num += MOD;\n                dp2[A][j] = (dp[A][j] + num) % MOD;\n            }\n        }\n        for (int j=0; j < A; j++){\n            if (j==B) continue;\n            if (B > j){\n                dp2[j][A] = (dp[j][A] + dp[j][B]) % MOD;\n            }\n            else{\n                int num = (pw[q-i-1] - dp[B][j]) % MOD;\n                if (num < 0) num += MOD;\n                dp2[j][A] = (dp[j][A] + num) % MOD;\n            }\n        }\n        for (int j=B+1; j < n; j++){\n            if (j==A) continue;\n            if (A < j){\n                dp2[B][j] = (dp[A][j] + dp[B][j]) % MOD;\n            }\n            else{\n                int num = (pw[q-i-1] - dp[j][A]) % MOD;\n                if (num < 0) num += MOD;\n                dp2[B][j] = (dp[B][j] + num) % MOD;\n            }\n        }\n        for (int j=0; j < B; j++){\n            if (j==A) continue;\n            if (A > j){\n                dp2[j][B] = (dp[j][A] + dp[j][B]) % MOD;\n            }\n            else{\n                int num = (pw[q-i-1] - dp[A][j]) % MOD;\n                if (num < 0) num += MOD;\n                dp2[j][B] = (dp[j][B] + num) % MOD;\n            }\n        }\n        dp2[aa][bb] = pw[q-i-1];\n        ch[aa][bb] = i-1;\n        for (int j=A+1; j < n; j++){\n            if (j==B) continue;\n            dp[A][j] = dp2[A][j];\n            ch[A][j] = i-1;\n        }\n        for (int j=0; j < A; j++){\n            if (j==B) continue;\n            dp[j][A] = dp2[j][A];\n            ch[j][A] = i-1;\n        }\n        for (int j=B+1; j < n; j++){\n            if (j==A) continue;\n            dp[B][j] = dp2[B][j];\n            ch[B][j] = i-1;\n        }\n        for (int j=0; j < B; j++){\n            if (j==A) continue;\n            dp[j][B] = dp2[j][B];\n            ch[j][B] = i-1;\n        }\n        dp[aa][bb] = dp2[aa][bb];\n//        for (int i=0; i < n; i++) for (int j=i+1; j < n; j++){\n//            cout << i << \" \" << j << \" \" << dp[i][j] << \" \" << ch[i][j] << endl;\n//        }\n//        cout << endl;\n    }\n    int ans = 0;\n    for (int i=0; i < n; i++){\n        for (int j=i+1; j < n; j++){\n            dp[i][j] *= pw[ch[i][j] + 1];\n            dp[i][j] %= MOD;\n            if (v[i] == v[j]) continue;\n            if (v[i] > v[j]) ans += dp[i][j];\n            else{\n                ans += pw[q];\n                ans -= dp[i][j];\n            }\n        }\n    }\n    ans %= MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N=3e3+5;\nconst int mod=1e9+7;\nconst int inv2=500000004;\nint n,x,y,q,ans,tmp=1,a[N],f[N][N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nint main() {\n\tIN(n),IN(q);\n\tfor(int i=1;i<=n;++i) IN(a[i]);\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) f[i][j]=(bool)(a[i]>a[j]);\n\tfor(int t=1;t<=q;++t) {\n\t\tIN(x),IN(y),\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%mod;\n\t\tfor(int i=1;i<=n;++i) if(i!=x&&i!=y)\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*inv2%mod,\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*inv2%mod;\n\t\ttmp=2ll*tmp%mod;\n\t}\n\tfor(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) ans=(ans+f[i][j])%mod;\n\tprintf(\"%d\\n\",1ll*ans*tmp%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 3001\n#define mdn 1000000007\n#define inv 500000004ll \nusing namespace std;\n\nint f[N][N],a[N],n,q;\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;// printf(\"QAQ\");\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&q); int remq=q;\n\tfor(int i=1;i<=n;i++)\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\tfor(int j=1;j<=n;j++)\n\t\tf[i][j]=a[i]>a[j];\n\twhile(q--)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=inv*(f[x][y]+f[y][x])%mdn;\n\t\tfor(int i=1;i<=n;i++)\tif(i!=x&&i!=y)\n\t\t\tf[x][i]=f[y][i]=inv*(f[x][i]+f[y][i])%mdn,\n\t\t\tf[i][x]=f[i][y]=inv*(f[i][x]+f[i][y])%mdn;\n\t}\n\tint ans=0; \n\tfor(int i=1;i<=n;i++)\tfor(int j=1;j<i;j++)\n\t\tans=(ans+f[j][i])%mdn;\n\tprintf(\"%d\\n\",1ll*ans*ksm(2,remq)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst ll mod=1e9+7;\nconst int MAXN=3010;\nll dp[MAXN][MAXN],f[MAXN][MAXN];\nll s[MAXN];\nint t[MAXN][MAXN],a[MAXN];\nint x,y,q,n;\nll ans;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&q);\n    for (int i=1;i<=n;i++){\n    \tscanf(\"%d\",&a[i]);\n    }\n    for (int i=1;i<=n;i++)\n    \t for (int j=1;j<=n;j++)\n    \t \t  if (a[i]>a[j]) f[i][j]=1;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++) t[i][j]=1;\t \t\n    s[0]=1;\n    for (int i=1;i<=q;i++) \n    s[i]=(s[i-1]*2)%mod;\t \t\n    for (int j=1;j<=q;j++) {\n    \tscanf(\"%d%d\",&x,&y);\n        for (int i=1;i<=n;i++) {\n        \tdp[i][x]=(f[i][x]*s[j-t[i][x]])%mod;\n        \tdp[x][i]=(f[x][i]*s[j-t[x][i]])%mod;\n        }\n        for (int i=1;i<=n;i++){\n        \tdp[i][y]=(f[i][y]*s[j-t[i][y]])%mod;\n        \tdp[y][i]=(f[y][i]*s[j-t[y][i]])%mod;\n        }\n    \tfor (int i=1;i<=n;i++)\n    \tif (i!=x)\n    \t{ \n    \t\tf[i][x]=(dp[i][y]+dp[i][x])%mod; f[x][i]=(dp[y][i]+dp[x][i])%mod;\n    \t\tt[i][x]=j+1; t[x][i]=j+1;\n    \t}\n    \tfor (int i=1;i<=n;i++)\n    \tif (i!=y)\n    \t{\n            f[i][y]=(dp[i][x]+dp[i][y])%mod; f[y][i]=(dp[x][i]+dp[y][i])%mod;\n            t[i][y]=j+1; t[y][i]=j+1;\n    \t}\n    \tf[x][y]=(dp[x][y]+dp[y][x])%mod; t[x][y]=j+1;\n    \tf[y][x]=(dp[x][y]+dp[y][x])%mod; t[y][x]=j+1;\n    \t// cout << t[1][2] << ' ' << t[1][3] << ' ' << t[2][3] << endl;\n    }\n    for (int i=1;i<=n;i++)\n    \t for (int j=i+1;j<=n;j++) \n    \t {\n    \t \t ans=(ans+f[i][j]*s[q+1-t[i][j]]%mod)%mod;\n    \t \t // cout << i << ' ' << j << ' ' << f[i][j]*s[q+1-t[i][j]]%mod << endl;\n    \t }\n\n    cout << ans << endl;\t \t\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll inv2 = (mod+1)/2;\nint n, q, a[3011];\nint dp[3011][3011];\nvoid upd(int &x, int v) {x=x+v>=mod?x+v-mod:x+v;}\nvoid SWAP(int x, int y)\n{\n\tint tmp = (dp[x][y]+dp[y][x])%mod*inv2%mod;\n\tdp[x][y] = dp[y][x] = tmp;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (i==x||i==y) continue;\n\t\tint tmp;\n\t\ttmp = (dp[x][i]+dp[y][i])%mod*inv2%mod;\n\t\tdp[x][i] = dp[y][i] = tmp;\n\t\ttmp = (dp[i][x]+dp[i][y])%mod*inv2%mod;\n\t\tdp[i][x] = dp[i][y] = tmp;\n\t}\n}\nint main()\n{\n\tgetii(n, q);\n\tfor (int i=1; i<=n; i++) geti(a[i]);\n\tfor (int i=1; i<=n; i++) for (int j=1; j<=n; j++) dp[i][j] = a[i]>a[j];\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tint x, y;\n\t\tgetii(x, y);\n\t\tSWAP(x, y);\n\t}\n\tint ans = 0;\n\tfor (int i=1; i<=n; i++) for (int j=i+1; j<=n; j++) upd(ans, dp[i][j]);\n\tcout<<ans*qpow(2,q)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb          emplace_back\n#define ll          long long\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define sz(x)       int(x.size())\n//#define int         int64_t\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = int(3e3) + 3;\nconst int mod = int(1e9) + 7;\n\nint f[N][N], n, q, a[N], x, y, div2;\n\nint Pow(int x, int y) {\n    int res = 1;\n    for(; y > 0; y >>= 1) {\n        if(y & 1) res = 1ll * res * x % mod;\n        x = 1ll * x * x % mod;\n    }\n    return res;\n}\n\nint sum(int x, int y) {if((x += y) >= mod) x -= mod; return x;}\nint mul(int x, int y) {return 1ll * x * y % mod;}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    #define Task        \"test\"\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> n >> q; div2 = Pow(2, mod - 2);\n    for(int i = 1; i <= n; ++i) cin >> a[i];\n    /// f(i, j) -> ai > aj\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= n; ++j) f[i][j] = a[i] > a[j];\n    }\n    for(int i = 1; i <= q; ++i) {\n        cin >> x >> y;\n        f[x][y] = f[y][x] = mul(sum(f[x][y], f[y][x]), div2);\n        for(int j = 1; j <= n; ++j) {\n            if(j == x || j == y) continue;\n            f[x][j] = f[y][j] = mul(sum(f[x][j], f[y][j]), div2);\n            f[j][x] = f[j][y] = mul(sum(f[j][x], f[j][y]), div2);\n        }\n    }\n    int res = 0;\n    for(int i = 1; i <= n; ++i)\n        for(int j = i + 1; j <= n; ++j) {\n            res += f[i][j];\n            if(res >= mod) res %= mod;\n        }\n    cout << mul(res, Pow(2, q));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define re register\n#define gc getchar()\n#define ll long long\n\ninline ll read() {\n\tre ll x(0), f(1); re char c(gc);\n\twhile (c > '9' || c < '0') f = c == '-' ? -1 : 1, c = gc;\n\twhile (c <= '9' && c >= '0') x = x * 10 + c -48, c = gc;\n\treturn x * f;\n}\n\nconst int N = 3030, mod = 1e9 + 7;\nint n, q, a[N];\nll ans, f[N][N], inv;\n\nll qpow (ll a, int b) {\n    ll x (1);\n    while (b) {\n        if (b & 1) x = x * a % mod;\n        a = a * a % mod, b >>= 1;\n    } return x;\n}\n\nint main () {\n    n = read(), q = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <=n; ++j) \n            f[i][j] = a[i] < a[j];\n    inv = qpow (2, mod -2);\n    for (int d = 1; d <= q; ++d) {\n        int x = read(), y = read();\n        for (int i = 1; i <= n; ++i) if (i != x && i != y) {\n            f[i][x] = f[i][y] = (f[i][x] + f[i][y]) * inv % mod;\n            f[x][i] = f[y][i] = (f[x][i] + f[y][i]) * inv % mod;\n        } f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * inv % mod;\n    } ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = i+1; j <= n; ++j)\n            ans += f[i][j];\n    cout << ans * qpow (2, q) % mod << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end());\n#define bit(n) (1LL << (n))\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct Setup {\n    static constexpr int PREC = 20;\n    Setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct ModInt {\n    int val;\n    ModInt(long long val_ = 0) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    bool operator==(const ModInt &rhs) const { return val == rhs.val; }\n    bool operator!=(const ModInt &rhs) const { return val != rhs.val; }\n    ModInt &operator+=(const ModInt &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n    ModInt operator++(signed) {\n        const ModInt ret(*this);\n        ++*this;\n        return ret;\n    }\n    ModInt operator--(signed) {\n        const ModInt ret(*this);\n        --*this;\n        return ret;\n    }\n    ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        int a = val, b = MOD, u = 1, v = 0;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n) const {\n        ModInt ret = 1, mul = *this;\n        if (n < 0) { n = -n, mul = mul.inv(); }\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, ModInt &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &rhs) { return os << rhs.val; }\n    struct Combination {\n        std::vector<ModInt> fact, finv, inv;\n        Combination(int n) : fact(n + 1), finv(n + 1), inv(n + 1) {\n            fact[0] = fact[1] = 1;\n            finv[0] = finv[1] = 1;\n            inv[1] = 1;\n            for (int i = 2; i <= n; i++) {\n                fact[i] = fact[i - 1] * i;\n                inv[i] = -inv[MOD % i] * (MOD / i);\n                finv[i] = finv[i - 1] * inv[i];\n            }\n        }\n        ModInt P(int n, int r) const { return r < 0 || n < r ? 0 : fact[n] * finv[n - r]; }\n        ModInt C(int n, int r) const { return r < 0 || n < r ? 0 : fact[n] * finv[r] * finv[n - r]; }\n        ModInt H(int n, int r) const { return C(n + r - 1, r); }\n    };\n};\n\nint N, Q;\nint A[3300], X[3300], Y[3300];\nusing Mint=ModInt<>;\nMint dp[3300][3300];\nMint pow2[3300];\nint last[3300][3300];\nsigned main() {\n    cin >> N >> Q;\n    rep(i, N) { cin >> A[i]; }\n    rep(i, Q) { cin >> X[i] >> Y[i], X[i]--, Y[i]--; }\n    rep(i, N)rep(j, N) { if (A[i] < A[j]) { dp[i][j] = 1; }}\n    pow2[0] = 1;\n    reps(i, Q) { pow2[i] = pow2[i - 1] * 2; }\n    rep(i, Q) {\n        rep(j, N) {\n            dp[X[i]][j] *= pow2[max(0LL, i - last[X[i]][j])];\n            last[X[i]][j] = i + 1;\n            dp[Y[i]][j] *= pow2[max(0LL, i - last[Y[i]][j])];\n            last[Y[i]][j] = i + 1;\n        }\n        rep(j, N) {\n            dp[j][X[i]] *= pow2[max(0LL, i - last[j][X[i]])];\n            last[j][X[i]] = i + 1;\n            dp[j][Y[i]] *= pow2[max(0LL, i - last[j][Y[i]])];\n            last[j][Y[i]] = i + 1;\n        }\n        rep(j, N) { dp[X[i]][j] = dp[Y[i]][j] = dp[X[i]][j] + dp[Y[i]][j]; }\n        rep(j, N) { dp[j][X[i]] = dp[j][Y[i]] = dp[j][X[i]] + dp[j][Y[i]]; }\n        dp[X[i]][X[i]] = dp[Y[i]][Y[i]] = 0;\n    }\n    Mint ans = 0;\n    rep(i, N)rep(j, i) { ans += dp[i][j] * pow2[Q - last[i][j]]; }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint Q;\nint A[3030];\nint X[3030],Y[3030];\nll mo=1000000007;\n\nll P[3030][3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tFOR(i,N) cin>>A[i];\n\tFOR(i,N) FOR(j,N) P[i][j]=A[i]<A[j];\n\t\n\tFOR(j,Q) {\n\t\tcin>>x>>y;\n\t\tx--,y--;\n\t\tFOR(i,N) {\n\t\t\tif(i!=x && i!=y) {\n\t\t\t\tP[i][x]=P[i][y]=(P[i][x]+P[i][y])*((mo+1)/2)%mo;\n\t\t\t\tP[x][i]=P[y][i]=(P[x][i]+P[y][i])*((mo+1)/2)%mo;\n\t\t\t}\n\t\t}\n\t\tP[x][y]=P[y][x]=(P[x][y]+P[y][x])*((mo+1)/2)%mo;\n\t}\n\t\n\tll ret=0;\n\tFOR(i,N) FOR(j,i) ret+=P[j][i];\n\tret%=mo;\n\tFOR(i,Q) ret=ret*2%mo;\n\t\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 1000000007;\nconst LL INV = (N + 1LL) / 2LL;\n\nLL tot = 1LL,sum = 0;\nLL dp[3005][3005],tmp[3005][3005];\nLL a[3005];\n\nint main(){\n\tLL n,q,u,v;\n\tcin >> n >> q;\n\tfor(LL i = 1;i <= n;i ++) cin >> a[i];\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tif(a[i] > a[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\twhile(q --){\n\t\tcin >> u >> v;\n\t\tfor(LL i = 1;i <= n;i ++){\n\t\t\tif(i == u || i == v) continue;\n\t\t\ttmp[u][i] = (INV * ((dp[u][i] + dp[v][i]) % N)) % N;\n\t\t\ttmp[i][u] = (INV * ((dp[i][u] + dp[i][v]) % N)) % N;\n\t\t\ttmp[v][i] = (INV * ((dp[v][i] + dp[u][i]) % N)) % N;\n\t\t\ttmp[i][v] = (INV * ((dp[i][v] + dp[i][u]) % N)) % N;\n\t\t}\n\t\tfor(LL i = 1;i <= n;i ++){\n\t\t\tif(i == u || i == v) continue;\n\t\t\tdp[u][i] = tmp[u][i]; dp[i][u] = tmp[i][u];\n\t\t\tdp[v][i] = tmp[v][i]; dp[i][v] = tmp[i][v];\n\t\t}\n\t\ttmp[u][v] = (INV * ((dp[u][v] + dp[v][u]) % N)) % N;\n\t\ttmp[v][u] = (INV * ((dp[v][u] + dp[u][v]) % N)) % N;\n\t\tdp[u][v] = tmp[u][v]; dp[v][u] = tmp[v][u];\n\t\ttot = (tot * 2) % N;\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = i + 1;j <= n;j ++){\n\t\t\tsum = (sum + dp[i][j]) % N;\n\t\t}\n\t}\n\tcout << (sum * tot) % N << '\\n';\n\treturn 0;\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint f[maxn][maxn], n, a[maxn], p2c[maxn][maxn], q;\nint l[maxn], r[maxn], tmp[maxn], ptmp[maxn];\nint pow2[maxn], ans, tmpl, tmpr;\ninline int mul(const int &a, const int &b) {\n\treturn 1ll * a * b % mod;\n}\ninline void Add(int &a, const int &b) {\n\ta = a + b >= mod ? a + b - mod : a + b;\n}\ninline int Minus(const int &a, const int &b) {\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q), pow2[0] = 1;\n\tfor(register int i = 1; i <= q; ++i)\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfor(register int j = i + 1; j <= n; ++j)\n\t\t\tf[i][j] = 1;\n\treverse(l + 1, l + q + 1);\n\treverse(r + 1, r + q + 1);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tfor(register int j = 1; j <= n; ++j)\n\t\t\ttmp[j] = f[j][r[i]], ptmp[j] = p2c[j][r[i]];\n\t\tfor(register int j = 1; j <= n; ++j) {\n\t\t\tif(j == l[i] || j == r[i]) continue;\n\t\t\tf[j][r[i]] = mul(f[j][r[i]], pow2[i + p2c[j][r[i]] - 1]);\n\t\t\tf[j][l[i]] = mul(f[j][l[i]], pow2[i + p2c[j][l[i]] - 1]);\n\t\t\ttmpl = f[j][l[i]], tmpr = f[j][r[i]];\n\t\t\tAdd(f[j][r[i]], tmpl);\n\t\t\tAdd(f[j][l[i]], tmpr);\n\t\t\tf[r[i]][j] = Minus(pow2[i], f[j][r[i]]);\n\t\t\tf[l[i]][j] = Minus(pow2[i], f[j][l[i]]);\n\t\t\tp2c[j][l[i]] = p2c[j][r[i]] = -i;\n\t\t\tp2c[l[i]][j] = p2c[r[i]][j] = -i;\n\t\t}\n\t\tp2c[l[i]][r[i]] = -i;\n\t\tf[l[i]][r[i]] = pow2[i - 1];\n\t\tp2c[r[i]][l[i]] = -i;\n\t\tf[r[i]][l[i]] = pow2[i - 1];\n\t\t/*for(register int j = 1; j <= n; ++j) {\n\t\t\tfor(register int k = 1; k <= n; ++k) {\n\t\t\t\t//f[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\t\tprintf(\"%d \", mul(f[j][k], pow2[i + p2c[j][k]]));\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}*/\n\t}\n\tfor(register int i = 1; i <= n; ++i) {\n\t\tfor(register int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\tif(a[i] > a[j]) Add(ans, f[i][j]);\n\t\t\telse if(a[i] < a[j]) Add(ans, Minus(pow2[q], f[i][j]));\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: Nguyen Tan Bao\n    Status:\n    Idea:\n*/\n \n#include <bits/stdc++.h>\n#define FI first\n#define SE second\n#define EPS 1e-9\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) int((a).size())\n#define MS(s, n) memset(s, n, sizeof(s))\n#define FOR(i,a,b) for (int i = (a); i <= (b); i++)\n#define FORE(i,a,b) for (int i = (a); i >= (b); i--)\n#define FORALL(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n//__builtin_ffs(x) return 1 + index of least significant 1-bit of x\n//__builtin_clz(x) return number of leading zeros of x\n//__builtin_ctz(x) return number of trailing zeros of x\n \nusing namespace std;\nusing ll = long long;\nusing ld = double;\ntypedef pair<int, int> II;\ntypedef pair<II, int> III;\ntypedef complex<ld> cd;\ntypedef vector<cd> vcd;\n \nconst ll MODBASE = 1000000007LL;\nconst int MAXN = 3010;\nconst int MAXM = 1000;\nconst int MAXK = 16;\nconst int MAXQ = 200010;\n\nint n, q, a[MAXN];\nll dp[MAXN][MAXN];\n\nll binPowMod(ll a, ll b, ll m) {\n    a %= m;\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1LL) res = res * a % m;\n        a = a * a % m;\n        b >>= 1LL;\n    }\n    return res;\n}\n\nll mul(ll a, ll b) {\n    return a * b % MODBASE;\n}\n\nll add(ll a, ll b) {\n    return (a + b) % MODBASE;\n}\n\nll sub(ll a, ll b) {\n    return (a - b + MODBASE) % MODBASE;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(nullptr);\n    cin >> n >> q;\n    FOR(i,1,n) cin >> a[i];\n    FOR(i,1,n)\n        FOR(j,1,n)\n            if (a[i] > a[j]) dp[i][j] = 1;\n    ll inv2 = binPowMod(2, MODBASE-2, MODBASE);\n    FOR(i,1,q) {\n        int l, r;\n        cin >> l >> r;\n        FOR(x,1,n) {\n            if (x == l || x == r) continue;\n            dp[l][x] = dp[r][x] = mul(inv2, add(dp[l][x], dp[r][x]));\n            dp[x][l] = dp[x][r] = mul(inv2, add(dp[x][l], dp[x][r]));\n        }\n        dp[l][r] = dp[r][l] = mul(inv2, add(dp[l][r], dp[r][l]));\n    }\n\n    ll p = binPowMod(2, q, MODBASE), res = 0;\n    FOR(i,1,n) {\n        FOR(j,i+1,n) {\n            dp[i][j] = mul(dp[i][j], p);\n            res = add(res, dp[i][j]);\n            // cout << dp[i][j] << ' ';\n        }\n        // cout << endl;\n    }\n    cout << res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nconst int mod=1e9+7;\nconst int r=(mod+1)>>1;\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\nint n,Q;\nint a[3050];\nint f[3050][3050]; \nint t[3050][3050];\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(a[i]>a[j]) f[i][j]=1;\n\t\t}\n\t} \n\tfor(int i=1;i<=Q;++i)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;++j) if(j!=x)\n\t\t{\n\t\t\tt[j][x]=1ll*(f[j][x]+f[j][y])*r%mod;\n\t\t\tt[x][j]=1ll*(f[x][j]+f[y][j])*r%mod;\n\t\t}\n\t\tfor(int j=1;j<=n;++j) if(j!=y)\n\t\t{\n\t\t\tt[j][y]=1ll*(f[j][y]+f[j][x])*r%mod;\n\t\t\tt[y][j]=1ll*(f[y][j]+f[x][j])*r%mod;\n\t\t}\n\t\tt[x][y]=1ll*(f[x][y]+f[y][x])*r%mod;\n\t\tt[y][x]=1ll*(f[y][x]+f[x][y])*r%mod;\n\t\tfor(int j=1;j<=n;++j) if(j!=x)\n\t\t{\n\t\t\tf[j][x]=t[j][x];\n\t\t\tf[x][j]=t[x][j];\n\t\t}\n\t\tfor(int j=1;j<=n;++j) if(j!=y)\n\t\t{\n\t\t\tf[j][y]=t[j][y];\n\t\t\tf[y][j]=t[y][j];\n\t\t}\n\t\tf[x][y]=t[x][y];\n\t\tf[y][x]=t[y][x];\n\t}\n\tint an=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tan=add(an+f[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=Q;++i)\n\t{\n\t\tan=add(an<<1);\n\t}\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tconst int mod = 1e9 + 7;\n\tint n, q; cin >> n >> q;\n\tvi a(n), x(q), y(q); rep(i, n) cin >> a[i];\n\trep(i, q) cin >> x[i] >> y[i];\n\t\n\tvi dp(n * n), last(n * n);\n\tvi two(q + 1, 1);\n\trep(i, q) two[i + 1] = two[i] * 2 % mod;\n\t\n\tauto get = [&](int i, int k){\n\t\tdp[i] = dp[i] * (ll)two[k - last[i]] % mod;\n\t\tlast[i] = k + 1;\n\t\treturn dp[i];\n\t};\n\tauto update = [&](int a, int b, int c, int d, int k){\n\t\tint v1 = get(a * n + b, k);\n\t\tint v2 = get(c * n + d, k);\n\t\t(dp[a * n + b] += v2) %= mod;\n\t\t(dp[c * n + d] += v1) %= mod;\n\t};\n\t\n\trep(i, n) rep(j, n) if(a[i] < a[j]) dp[i * n + j] = 1;\n\trep(k, q){\n\t\tint l = x[k] - 1, r = y[k] - 1;\n\t\trep(i, n) if(i != l && i != r){\n\t\t\t//(l, i) <=> (r, i)\n\t\t\tupdate(l, i, r, i, k);\n\t\t\t//(i, l) <=> (i, r)\n\t\t\tupdate(i, l, i, r, k);\n\t\t}\n\t\tupdate(l, r, r, l, k);\n\t}\n\tll ans = 0;\n\trep(i, n) rep(j, i) ans += get(i * n + j, q);\n\tcout << ans % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint n, Q, f[N][N], a[N], inv2, pow = 1, ans = 0;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nsigned main()\n{\n\tn = read(); Q = read();\n\tfor(int i = 1; i <= n; i ++) a[i] = read();\n\tfor(int i = 1; i <= n; i ++) for(int j = 1; j <= n; j ++) f[i][j] = (a[i] < a[j]);\n\tinv2 = (mod + 1) / 2;\n\tfor(int i = 1, x, y; i <= Q; i ++)\n\t{\n\t\tx = read(); y = read(); pow = pow * 2 % mod;\n\t\tf[x][y] = f[y][x] = (f[x][y] + f[y][x]) % mod * inv2 % mod;\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t{\n\t\t\tif(j == x || j == y) continue;\n\t\t\tf[x][j] = f[y][j] = (f[x][j] + f[y][j]) % mod * inv2 % mod;\n\t\t\tf[j][x] = f[j][y] = (f[j][x] + f[j][y]) % mod * inv2 % mod;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i ++) for(int j = i - 1; j >= 1; j --) ans = (ans + f[i][j]) % mod;\n\tprintf(\"%lld\\n\", ans * pow % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n*/\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n       \n        \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int Mod = 1000000007;\nconst int MAXN = 3008;\n\n\nint sum(int a, int b) {\n    return (a + b) % Mod;\n}\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\n\nint n, q;\nint dp[MAXN][MAXN];\nint a[MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    int kek = powm(2, Mod - 2);\n    for (int it = 0; it < q; it++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        for (int i = 0; i < n; i++) {\n            if (i == x || i == y) {\n                continue;\n            }\n            dp[i][x] = mul(dp[i][x], kek);\n            dp[i][y] = mul(dp[i][y], kek);\n            dp[i][x] = sum(dp[i][x], dp[i][y]);\n            dp[i][y] = dp[i][x];\n            dp[x][i] = mul(dp[x][i], kek);\n            dp[y][i] = mul(dp[y][i], kek);\n            dp[x][i] = sum(dp[x][i], dp[y][i]);\n            dp[y][i] = dp[x][i];\n        }\n        dp[x][y] = mul(dp[x][y], kek) + mul(dp[y][x], kek);\n        dp[y][x] = dp[x][y];\n        dp[x][x] = 0;\n        dp[y][y] = 0;\n    }   \n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            ans = sum(ans, dp[i][j]);\n        }\n    }\n    ans = mul(ans, powm(2, q));\n    cout << ans << '\\n';\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for (ll i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nlong long inv_mod(long long n, long long mod) {\n    long long a = n % mod, b = mod - 2, ret = 1;\n    while (b > 0) {\n        if (b & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nconst ll MOD = 1000000007LL;\nll N,Q;\nll A[3010];\nll X[3010];\nll Y[3010];\n\nll dp[3010][3010];\n\nint main ()\n{\n    cin >> N >> Q;\n    REP(i,N) cin >> A[i + 1];\n    REP(i,Q) cin >> X[i] >> Y[i];\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = (A[i] > A[j]);\n        }\n    }\n\n    ll inv2 = inv_mod(2LL, MOD);\n    for (int i = 0; i < Q; i++) {\n        dp[X[i]][Y[i]] = dp[Y[i]][X[i]] = ((dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv2) % MOD;\n        for (int j = 1; j <= N; j++) {\n            if (X[i] != j && Y[i] != j) {\n                dp[X[i]][j] = dp[Y[i]][j] = ((dp[X[i]][j] + dp[Y[i]][j]) * inv2) % MOD;\n                dp[j][X[i]] = dp[j][Y[i]] = ((dp[j][X[i]] + dp[j][Y[i]]) * inv2) % MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i; j <= N; j++) {\n            ans += dp[i][j];\n            ans %= MOD;\n        }\n    }\n\n    cout << (ans * pow_mod(2LL, Q, MOD)) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) (int)(x).size()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i, a, b) for (int i=a;i>=b;--i)\n\nconst int MX_N = 3005;\nconst int MX_Q = 3005;\nconst int MOD = 1e9+7;\n\nint N, Q, A[MX_N];\n\nint dp[MX_N][MX_N];\n\nint expo(int b, int p) {\n    int x = 1;\n    while (p > 0) {\n        if (p&1) x = 1LL * x * b % MOD;\n        b = 1LL * b * b % MOD;\n        p >>= 1;\n    }\n    return x;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> Q;\n    FOR(i,1,N){\n        cin >> A[i];\n    }\n\n    FOR(i,1,N) FOR(j,1,N) dp[i][j] = A[i] > A[j];\n\n    long long half = expo(2,MOD-2), all = expo(2,Q);\n    FOR(i,1,Q){\n        int X, Y; cin >> X >> Y;\n\n        dp[X][Y] = dp[Y][X] = (half * dp[X][Y] % MOD + half * dp[Y][X] % MOD) % MOD;\n        FOR(Z,1,N) if (Z != X and Z != Y) {\n            dp[X][Z] = dp[Y][Z] = (half * dp[X][Z] % MOD + half * dp[Y][Z] % MOD) % MOD;\n            dp[Z][X] = dp[Z][Y] = (half * dp[Z][X] % MOD + half * dp[Z][Y] % MOD) % MOD;\n        }\n    }\n\n    int ans = 0;\n    FOR(i,1,N) FOR(j,i+1,N) ans = (ans + dp[i][j] * all % MOD) % MOD;\n    cout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MOD = 1e9 + 7;\nconst int Inv2 = (MOD + 1) / 2;\ninline int inc(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline void add(int &x, int y) {y += x; x = y >= MOD ? y - MOD : y;}\ninline int mul(int x, int y) {return (ll)x * y % MOD;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nconst int MAXN = 3005;\nint n, Q, f[MAXN][MAXN], A[MAXN], tmp[MAXN][MAXN];\n\nint main()\n{\n\tn = read(), Q = read();\n\tfor (int i = 1; i <= n; i ++) A[i] = read();\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (A[i] > A[j]) f[i][j] = 1;\n\tfor (int i = 1; i <= Q; i ++)\n\t{\n\t\tint x = read(), y = read();\n\t\tif (x == y) continue;\n\t\tif (x > y) swap(x, y);\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\ttmp[x][j] = f[x][j], tmp[j][x] = f[j][x],\n\t\t\ttmp[y][j] = f[y][j], tmp[j][y] = f[j][y];\n\t\tfor (int j = 1; j <= n; j ++) if (j != x && j != y)\n\t\t\tf[y][j] = f[x][j] = mul(Inv2, inc(tmp[x][j], tmp[y][j])),\n\t\t\tf[j][x] = f[j][y] = mul(Inv2, inc(tmp[j][x], tmp[j][y]));\n\t\tf[x][y] = f[y][x] = mul(Inv2, inc(tmp[x][y], tmp[y][x]));\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = i + 1; j <= n; j ++)\n\t\t\tadd(ans, f[i][j]);\n\tprintf(\"%d\\n\", mul(ans, qpow(2, Q)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nll Power(ll x,ll k)\n{\n\tx%=mod;\n\tll sss=1;\n\twhile (k)\n\t{\n\t\tif (k%2) sss=sss*x%mod;\n\t\tx=x*x%mod;\n\t\tk/=2;\n\t}\n\treturn sss;\n}\nll ny(ll x){return Power(x,mod-2);}\nint n,q;\nll f[4030][4030];\nll ans;\nll a[5030],b[5][5030];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) if (a[i]>a[j]) f[i][j]=1;\n\n\tint x,y; ll doe=ny(2);\n\tfor (int i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tfor (int j=1;j<=n;++j) \n\t\t{\n\t\t\tb[0][j]=f[j][x];\n\t\t\tb[1][j]=f[x][j];\n\t\t\tb[2][j]=f[j][y];\n\t\t\tb[3][j]=f[y][j];\n\t\t}\n\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) (f[j][y]+=b[0][j])%=mod;\n\t\t\tif (j!=x) (f[y][j]+=b[1][j])%=mod;\n\t\t\tif (j!=y) (f[j][x]+=b[2][j])%=mod; \n\t\t\tif (j!=y) (f[x][j]+=b[3][j])%=mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) f[j][y]=f[j][y]*doe%mod;\n\t\t\tif (j!=x) f[y][j]=f[y][j]*doe%mod;\n\t\t\tif (j!=y) f[j][x]=f[j][x]*doe%mod;\n\t\t\tif (j!=y) f[x][j]=f[x][j]*doe%mod;\n\t\t}\n\t\tll A=f[x][y],B=f[y][x];\n\t\tf[y][x]+=A; f[x][y]+=B;\n\t\tf[x][y]=f[x][y]*doe%mod; \n\t\tf[y][x]=f[y][x]*doe%mod;\n\t}\n/*\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",f[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n;++j) (ans+=f[i][j])%=mod;\n\tans=ans*Power(2,q)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 3005\n#define mo 1000000007\n#define ll long long\nll ksm(ll a,int k) {\n    ll s=1;\n    while(k)\n\t{\n\t    if(k&1) s=1ll*s*a%mo;\n\t    a=1ll*a*a%mo;\n\t    k>>=1;\n\t}\n    return s;\n}\nll inv=ksm(2,mo-2);\nint n,m;\nll a[M],ans;\nll p[M][M],p2[M][M],g[M][M],g2[M][M];\nvoid pre() {\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) p[i][j]=a[i]>a[j],p2[i][j]=a[i]==a[j];\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    pre();\n    for(int i=1,x,y;i<=m;i++)\n\t{\n\t    cin>>x>>y;\n\t    if(x>y) swap(x,y);\n\t    for(int j=1;j<x;j++)\n\t\t{\n\t\t    g[j][x]=1ll*inv*(p[j][y]+p[j][x])%mo,g2[j][x]=1ll*inv*(p2[j][x]+p2[j][y])%mo;\n\t\t    g[j][y]=1ll*inv*(p[j][y]+p[j][x])%mo,g2[j][y]=1ll*inv*(p2[j][y]+p2[j][x])%mo;\n\t\t}\n\t    for(int j=x+1;j<y;j++)\n\t\t{\n\t\t    g[x][j]=1ll*inv*(p[x][j]+(1-p[j][y]-p2[j][y])%mo+mo)%mo,g2[x][j]=1ll*inv*(p2[x][j]+p2[j][y])%mo;\n\t\t    g[j][y]=1ll*inv*(p[j][y]+(1-p[x][j]-p2[x][j])%mo+mo)%mo,g2[j][y]=1ll*inv*(p2[j][y]+p2[x][j])%mo;\n\t\t}\n\t    for(int j=y+1;j<=n;j++)\n\t\t{\n\t\t    g[x][j]=1ll*inv*(p[x][j]+p[y][j])%mo,g2[x][j]=1ll*inv*(p2[x][j]+p2[y][j])%mo;\n\t\t    g[y][j]=1ll*inv*(p[y][j]+p[x][j])%mo,g2[y][j]=1ll*inv*(p2[y][j]+p2[x][j])%mo;\n\t\t}\n\t    p[x][y]=1ll*inv*(1-p2[x][y]+mo)%mo;\n\t    for(int j=1;j<x;j++)\n\t\t{\n\t\t    p[j][x]=g[j][x],p[j][y]=g[j][y];\n\t\t    p2[j][x]=g2[j][x],p2[j][y]=g2[j][y];\n\t\t}\n\t    for(int j=x+1;j<y;j++)\n\t\t{\n\t\t    p[x][j]=g[x][j],p[j][y]=g[j][y];\n\t\t    p2[x][j]=g2[x][j],p2[j][y]=g2[j][y];\n\t\t}\n\t    for(int j=y+1;j<=n;j++)\n\t\t{\n\t\t    p[x][j]=g[x][j],p[y][j]=g[y][j];\n\t\t    p2[x][j]=g2[x][j],p2[y][j]=g2[y][j];\n\t\t}\n\t}\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++) ans=(ans+p[i][j])%mo;\n    ans=1ll*ans*ksm(2,m)%mo;\n    cout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int mod = (int) 1e9 + 7;\n\nll modPow(ll n, ll k) {\n\tll res = 1;\n\tfor (n %= mod; k; k >>= 1) {\n\t\tif (k & 1)\n\t\t\tres = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\n\nll modInv(ll x) {\n\treturn modPow(x, mod - 2);\n}\n\nconst int MaxN = 3002;\n\nconst ll Half = modInv(2);\nll dp[MaxN + 1][MaxN + 1];\n\nvoid avg(ll &x, ll &y) {\n\tx = y = (x + y) % mod * Half % mod;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\n\tint n, Q;\n\tcin >> n >> Q;\n\n\t{\n\t\tstatic ll a[MaxN + 9];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> a[i];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = a[i] > a[j];\n\t}\n\n\tfor (int rep = 0; rep < Q; ++rep) {\n\t\tint i, j;\n\t\tcin >> i >> j;\n\t\t--i, --j;\n\n\t\tavg(dp[i][j], dp[j][i]);\n\n\t\tfor (int k = 0; k < n; ++k)\n\t\t\tif (k != i && k != j) {\n\t\t\t\tavg(dp[i][k], dp[j][k]);\n\t\t\t\tavg(dp[k][i], dp[k][j]);\n\t\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t(ans += dp[i][j]) %= mod;\n\n\tans *= modPow(2, Q);\n\n\tcout << (ans % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=3005;\nconst int mod=1e9+7;\nconst int two=5e8+4;\nint n,q,a[MN],X[MN],Y[MN];\nint f[MN][MN];\ninline ll qpow(ll a,ll b){\n\treg ll res=1;\n\twhile(b){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(reg int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(reg int i=1;i<=q;i++)scanf(\"%d%d\",X+i,Y+i);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=n;j++)\n\t\t\tif(a[i]>a[j])f[i][j]=1;\n\tfor(reg int i=1;i<=q;i++){\n\t\tf[X[i]][Y[i]]=f[Y[i]][X[i]]=1ll*(f[X[i]][Y[i]]+f[Y[i]][X[i]])*two%mod;\n\t\tfor(reg int j=1;j<=n;j++){\n\t\t\tif(j==X[i]||j==Y[i])continue;\n\t\t\tf[X[i]][j]=f[Y[i]][j]=1ll*(f[X[i]][j]+f[Y[i]][j])*two%mod;\n\t\t\tf[j][X[i]]=f[j][Y[i]]=1ll*(f[j][X[i]]+f[j][Y[i]])*two%mod;\n\t\t}\n\t}\n\treg ll Ans=0;\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=i+1;j<=n;j++)\n\t\t\tAns=(Ans+f[i][j])%mod;\n\tprintf(\"%d\\n\",1ll*Ans*qpow(2,q)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 3003;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nll qpow(ll x, ll t)\n{\n\tll ans = 1;\n\twhile(t)\n\t{\n\t\tif(t & 1) ans = ans * x % MOD;\n\t\tx = x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ans;\n}\n\nll inv(ll x)\n{\n\treturn qpow(x, MOD-2);\n}\n\nll f[MX][MX], seq[MX], rak[MX];\n\nint main()\n{\n\tint n, q;\n\tread(n), read(q);\n\tfor(int i=1; i<=n; i++) read(seq[i]);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(seq[j] > seq[i])\n\t\t\t\tf[i][j] = 1;\n\tll iv2 = inv(2);\n\tfor(int i=1; i<=q; i++)\n\t{\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tif(x > y) swap(x, y);\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(j!=x && j!=y)\n\t\t\t{\n\t\t\t\tll tmp = (f[j][x] + f[j][y]) * iv2 % MOD;\n\t\t\t\tf[j][x] = f[j][y] = tmp;\n\t\t\t\ttmp = (f[x][j] + f[y][j]) * iv2 % MOD;\n\t\t\t\tf[x][j] = f[y][j] = tmp;\n\t\t\t}\n\t\tll tmp = (f[x][y] + f[y][x]) * iv2 % MOD;\n\t\tf[x][y] = f[y][x] = tmp;\n\t}\n\tll ans = 0;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<i; j++)\n\t\t\tans = (ans + f[i][j]) % MOD;\n\tprintf(\"%lld\\n\", ans * qpow(2, q) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 3003\n\nusing namespace std;\n\nconst int mod = 1e9 + 7, inv = (mod + 1) / 2;\n\nint n, m;\nint a[N], f[N][N], x[N][2], y[N][2];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(a[i] > a[j]) f[i][j] = 1;\n\tint sum = 1;\n\twhile(m--){\n\t\tint X, Y; (sum *= 2) %= mod;\n\t\tscanf(\"%d%d\", &X, &Y);\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tx[i][0] = f[X][i], x[i][1] = f[i][X];\n\t\t\ty[i][0] = f[Y][i], y[i][1] = f[i][Y];\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tf[X][i] = 1ll * inv * (x[i][0] + y[i][0]) % mod;\n\t\t\tf[i][X] = 1ll * inv * (x[i][1] + y[i][1]) % mod;\n\t\t\tf[Y][i] = 1ll * inv * (y[i][0] + x[i][0]) % mod;\n\t\t\tf[i][Y] = 1ll * inv * (y[i][1] + x[i][1]) % mod;\n\t\t}\n\t\tf[X][Y] = f[Y][X] = 1ll * inv * (x[Y][0] + y[X][0]) % mod;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\t(ans += f[i][j]) %= mod;\n\tans = 1ll * ans * sum % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define ll long long\nusing namespace std;\nconst int N=3005,mo=1e9+7,mo2=mo+1>>1;\nint n,q,x,y,p[N];\nint f[N][N],ans,xs;\nint r[N],c[N];\nint main(){\n\tcin>>n>>q;\n\tfo(i,1,n)cin>>p[i];\n\tfo(i,1,n)fo(j,1,n)\n\t\tif(p[i]<p[j])f[i][j]=1;\n\tfor(xs=1;q--;xs=(ll)xs*2%mo){\n\t\tcin>>x>>y;\n\t\tfo(i,1,n){\n\t\t\tr[i]=(ll)(f[x][i]+f[y][i])*mo2%mo;\n\t\t\tc[i]=(ll)(f[i][x]+f[i][y])*mo2%mo;\n\t\t}\n\t\tfo(i,1,n)f[x][i]=f[y][i]=r[i],f[i][x]=f[i][y]=c[i];\n\t\tf[x][x]=f[y][y]=0;\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%mo;\n\t}\n\tfo(i,1,n)fo(j,1,i-1)ans=(ans+f[i][j])%mo;\n\tcout<<(ll)ans*xs%mo;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3003\n#define P 1000000007\nusing namespace std;\nint n,q,a[N],f[N][N];\nstruct upd{int x,y,z;};\nupd pkg(int x,int y,int z){\n    upd res;\n    res.x=x,res.y=y,res.z=z;\n    return res;\n}\nqueue <upd> Q;\nbool b[N][N];\nint pow(int x,int y){\n    int res=1;\n    for(;y;y>>=1,x=1LL*x*x%P)\n        if(y&1)res=1LL*res*x%P;\n    return res;\n}\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n    //f[i][j]表示a[i]>a[j]的概率\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=n;++j)f[i][j]=a[i]>a[j];\n    int tot=pow(2,q),inv=pow(2,P-2);\n    while(q--){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        for(int i=1;i<=n;++i)\n            if(i!=x && i!=y){\n                Q.push(pkg(i,x,(int)(1LL*(f[i][x]+f[i][y])*inv%P)));\n                Q.push(pkg(x,i,(int)(1LL*(f[x][i]+f[y][i])*inv%P)));\n                Q.push(pkg(i,y,(int)(1LL*(f[i][y]+f[i][x])*inv%P)));\n                Q.push(pkg(y,i,(int)(1LL*(f[y][i]+f[x][i])*inv%P)));\n            }\n        Q.push(pkg(x,y,(int)(1LL*(f[x][y]+f[y][x])*inv%P)));\n        Q.push(pkg(y,x,(int)(1LL*(f[y][x]+f[x][y])*inv%P)));\n        while(!Q.empty()){\n            upd cur=Q.front();\n            f[cur.x][cur.y]=cur.z;\n            Q.pop();\n        }\n    }\n    int ans=0;\n    for(int i=1;i<n;++i)\n        for(int j=i+1;j<=n;++j){\n            ans+=1LL*f[i][j]*tot%P;\n            if(ans>=P)ans-=P;\n        }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 3005\n#define INF 1000000000\n#define MOD 1000000007\n#define INV 500000004\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nint n,q,a[MAXN],pos[MAXN];\nint dp[MAXN][MAXN];\nint cnt[MAXN][MAXN];\nP query[MAXN];\nint p2[MAXN];\nint main()\n{\n    p2[0]=1;\n    for(int i=1;i<=3000;i++) p2[i]=2LL*p2[i-1]%MOD;\n    scanf(\"%d%d\",&n,&q);\n    vector<int> v;\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for(int i=0;i<q;i++) scanf(\"%d%d\",&query[i].F,&query[i].S);\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n        {\n           if(a[i]>a[j]) dp[i][j]=1;\n           else if(a[j]>a[i]) dp[j][i]=1;\n        }\n    \n    for(int i=0;i<q;i++)\n    {\n        int u=query[i].F,v=query[i].S;\n        if(u>v) swap(u,v);\n        int s=dp[u][v]+dp[v][u];\n        if(s>=MOD) s-=MOD;\n        dp[u][v]=dp[v][u]=1LL*s*INV%MOD;\n        for(int j=1;j<=n;j++)\n        {\n            if(j==u||j==v) continue;\n            int s=dp[u][j]+dp[v][j];\n            if(s>=MOD) s-=MOD;\n            dp[u][j]=dp[v][j]=1LL*s*INV%MOD;\n            s=dp[j][u]+dp[j][v];\n            if(s>=MOD) s-=MOD;\n            dp[j][u]=dp[j][v]=1LL*s*INV%MOD;\n        }\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            add(ans,1LL*dp[i][j]*p2[q]%MOD);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nconst int N=3005,P=1e9+7,inv2=500000004;\ninline void Add(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);\n\treturn res;\n}\nstruct node{int x,y;}p[N];\nint f[N][N],g[2][N],ans[2][N][N],a[N];\nint n,q,res;\nvoid solve(int pos){\n\tint tag=1;\n\tfd(t,q,1){\n\t\ttag=mul(tag,2);\n\t\tint x=p[t].x,y=p[t].y;\n\t\tfp(i,1,n)g[0][i]=g[1][i]=0;\n\t\tfp(i,1,n)g[0][i]=add(f[x][i],f[y][i]),g[1][i]=add(f[i][x],f[i][y]);\n\t\tint c=f[x][y],d=f[y][x];\n\t\tfp(i,1,n)f[x][i]=f[y][i]=mul(g[0][i],inv2),f[i][x]=f[i][y]=mul(g[1][i],inv2);\n\t\tf[x][y]=f[y][x]=mul(add(c,d),inv2),f[x][x]=f[y][y]=0;\n\t}\n\tfp(i,1,n)fp(j,1,n)ans[pos][i][j]=mul(f[i][j],tag);\n}\nvoid init(){\n\tfp(i,1,n)fp(j,1,n)f[i][j]=0;\n\tfp(i,1,n)fp(j,i+1,n)f[i][j]=1;\n\tsolve(0);\n\tfp(i,1,n)fp(j,1,n)f[i][j]=0;\n\tfp(i,1,n)fp(j,1,i-1)f[i][j]=1;\n\tsolve(1);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),q=read();\n\tfp(i,1,n)a[i]=read();\n\tfp(i,1,q)p[i].x=read(),p[i].y=read();\n\tinit();\n\tfp(i,1,n)fp(j,i+1,n)Add(res,a[i]==a[j]?0:a[i]>a[j]?ans[0][i][j]:ans[1][i][j]);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nusing P = Pa<int,int>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q;\n    cin >> N >> Q;\n    vec<int> A(N);\n    for(int i=0;i<N;i++) cin >> A[i];\n    vvec<mint> dp(N,vec<mint>(N));\n    for(int i=0;i<N;i++) for(int j=0;j<N;j++) if(A[i]<=A[j]) dp[i][j] = 1;\n    mint inv2 = ((mint) (2)).inv();\n    for(int _=0;_<Q;_++){\n        int x,y;\n        cin >> x >> y;\n        x--; y--;\n        if(x>y) swap(x,y);\n        map<P,mint> mp;\n        for(int i=0;i<N;i++){\n            mp[{i,x}] = dp[i][x];\n            mp[{x,i}] = dp[x][i];\n            mp[{i,y}] = dp[i][y];\n            mp[{y,i}] = dp[y][i];\n        }\n        for(int i=0;i<N;i++){\n            if(i!=x && i!=y){\n                dp[i][x] = mp[{i,x}]+mp[{i,y}];\n                dp[i][x] /= 2;\n                dp[x][i] = mp[{x,i}]+mp[{y,i}];\n                dp[x][i] /= 2;\n            }\n            if(i!=x && i!=y){\n                dp[i][y] = mp[{i,y}]+mp[{i,x}];\n                dp[i][y] /= 2;\n                dp[y][i] = mp[{y,i}]+mp[{x,i}];\n                dp[y][i] /= 2;\n            }\n        }\n        dp[x][y] = mp[{x,y}]+mp[{y,x}];\n        dp[x][y] /= 2;\n        dp[y][x] = mp[{x,y}]+mp[{y,x}];\n        dp[y][x] /= 2;\n    }\n    mint ans = 0;\n    //for(int i=0;i<N;i++) for(int j=0;j<N;j++) cerr << dp[i][j] << (j!=N-1? \" \":\"\\n\");\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++) ans += ((mint) 1-dp[i][j]);\n    cout << ans*((mint) 2).pow(Q) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 3005\n#define inv2 500000004\nint nex[MN][MN],lst[MN];\nlg dp[MN][MN];\nint a[MN];\nint k1,k2;\nlg P2[MN];\nint n,q;\nint main(){\n\tread(n);read(q);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t}\n\tP2[0]=1;\n\tfor(int i=1;i<MN;++i)P2[i]=P2[i-1]*2%Md;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(a[i]<a[j])++dp[i][j];\n\t}\n\tfor(int i=1,now=1,lst=0;i<=q;++i,swap(now,lst)){\n\t\tread(k1);read(k2);\n\t\tfor(int j=1;j<=n;++j)if(j!=k1&&j!=k2){\n\t\t\t{lg aa=(dp[j][k1]+dp[j][k2])*inv2%Md;\n\t\t\tdp[j][k1]=dp[j][k2]=aa;}\n\t\t\t{lg aa=(dp[k1][j]+dp[k2][j])*inv2%Md;\n\t\t\tdp[k1][j]=dp[k2][j]=aa;}\n\t\t}\n\t\tdp[k1][k2]=dp[k2][k1]=(dp[k1][k2]+dp[k2][k1])*inv2%Md;\n\t}\n\tlg res=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tres+=dp[j][i];\n\t\t\tres%=Md;\n\t\t}\n\t}\n\tcout<<res*P2[q]%Md;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nint A[3005];\nint V[3005][3005];\nconst int MOD = 1e9 + 7;\nint main() {\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (A[i] < A[j]) ++V[i][j];\n\tll half = 500000004;\n\tll p2 = 1;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tvector<pair<pair<int, int>, int>> updates;\n\t\tauto add = [&](int c, int d, int v) {\n\t\t\tupdates.push_back({{c, d}, v});\n\t\t};\n\t\tadd(y, x, V[x][y]);\n\t\tadd(x, y, V[y][x]);\n\t\tfor (int a = 1; a <= n; ++a) {\n\t\t\tif (a == y || a == x) continue;\n\t\t\tadd(a, x, V[a][y]);\n\t\t\tadd(x, a, V[y][a]);\n\t\t\tadd(a, y, V[a][x]);\n\t\t\tadd(y, a, V[x][a]);\n\t\t}\n\t\tfor (auto u : updates) {\n\t\t\tint& v = V[u.first.first][u.first.second];\n\t\t\tv += u.second;\n\t\t\tv = v * half % MOD;\n\t\t}\n\t\tp2 = p2 * 2 % MOD;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tassert(!V[i][i]);\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tans += V[i][j];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tans = ans * p2 % MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//2018.12.29 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-15\ninline int read(){\n    res s=0;\n    bool w=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return w?-s:s;\n}\ninline void _swap(res &x,res &y){\n    x^=y^=x^=y;\n}\ninline int _abs(const res &x){\n    return x>0?x:-x;\n}\ninline int _max(const res &x,const res &y){\n    return x>y?x:y;\n}\ninline int _min(const res &x,const res &y){\n    return x<y?x:y;\n}\nconst int kcz=1e9+7;\nconst int N=3e3+10;\nnamespace MAIN{\n    int n,q;\n    int a[N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int qpow(res x,res y){\n        res ret=1;\n        while(y){\n            if(y&1)ret=1LL*x*ret%kcz;\n            x=1LL*x*x%kcz,y>>=1;\n        }\n        return ret;\n    }\n    int f[N][N],g[N][N],ans,INV,X[N],Y[N];\n    inline void MAIN(){\n        n=read(),q=read(),INV=qpow(2,kcz-2);\n        for(res i=1;i<=n;i++){\n            a[i]=read();\n            for(res j=i+1;j<=n;j++)f[i][j]=1;\n        }\n        for(res i=1;i<=q;i++)X[i]=read(),Y[i]=read();\n        for(res t=1;t<=q;t++){\n            res x=X[q-t+1],y=Y[q-t+1];\n            for(res i=1;i<=n;i++)g[x][i]=f[x][i],g[i][x]=f[i][x],g[y][i]=f[y][i],g[i][y]=f[i][y];\n            for(res i=1;i<=n;i++){\n                f[x][i]=1LL*Add(f[x][i],g[y][i])*INV%kcz,f[i][x]=1LL*Add(f[i][x],g[i][y])*INV%kcz;\n                f[y][i]=1LL*Add(f[y][i],g[x][i])*INV%kcz,f[i][y]=1LL*Add(f[i][y],g[i][x])*INV%kcz;\n            }\n            f[x][y]=f[y][x]=1LL*Add(g[x][y],g[y][x])*INV%kcz;\n        }\n        for(res i=1;i<=n;i++)\n            for(res j=1;j<=n;j++)if(a[i]>a[j])add(ans,f[i][j]);\n        printf(\"%lld\\n\",1LL*qpow(2,q)*ans%kcz);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 3010;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\n\nconst int p = inv(2);\n\nint N, Q;\nint A[MN], X[MN], Y[MN], dp[MN][MN];\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n    }\n\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            dp[i][j] = A[i] > A[j];\n        }\n    }\n    for(int i = 0; i < Q; i++) {\n        for(int j = 0; j < N; j++) {\n            if(j == X[i] || j == Y[i]) continue;\n\n            int t = 1LL * p * (dp[ X[i] ][j] + dp[ Y[i] ][j]) % mod;\n            dp[ X[i] ][j] = dp[ Y[i] ][j] = t;\n\n            t = 1LL * p * (dp[j][ X[i] ] + dp[j][ Y[i] ]) % mod;\n            dp[j][ X[i] ] = dp[j][ Y[i] ] = t;\n        }\n        int t = 1LL * p * (dp[ X[i] ][ Y[i] ] + dp[ Y[i] ][ X[i] ]) % mod;\n        dp[ X[i] ][ Y[i] ] = dp[ Y[i] ][ X[i] ] = t;\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = i + 1; j < N; j++) {\n            ans += dp[i][j];\n            ans %= mod;\n        }\n    }\n    ans = 1LL * ans * exp(2, Q) % mod;\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, Q;\n\tcin >> N >> Q;\n\tvector<int> A(N), X(Q), Y(Q);\n\tfor(int i = 0; i < N; i++) cin >> A[i];\n\tfor(int i = 0; i < Q; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--, Y[i]--;\n\t}\n\tcat mod = 1000000007;\n\tvector<cat> pw2(Q+1, 1);\n\tfor(int i = 1; i <= Q; i++) pw2[i] = pw2[i-1] * 2 % mod;\n\tvector< vector<cat> > cnt(N, vector<cat>(N, 0));\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < i; j++) cnt[i][j] = 1;\n\tvector< vector<int> > pw(N, vector<int>(N, Q));\n\tfor(int i = Q-1; i >= 0; i--) {\n\t\tint x = X[i], y = Y[i];\n\t\tint a = cnt[y][x] * pw2[pw[y][x]-i-1] % mod, b = cnt[x][y] * pw2[pw[x][y]-i-1] % mod;\n\t\tcnt[x][y] = cnt[y][x] = (b + a) % mod;\n\t\tpw[x][y] = pw[y][x] = i;\n\t\tfor(int j = 0; j < N; j++) if(x != j && y != j) {\n\t\t\ta = cnt[y][j] * pw2[pw[y][j]-i-1] % mod, b = cnt[x][j] * pw2[pw[x][j]-i-1] % mod;\n\t\t\tcnt[x][j] = cnt[y][j] = (b + a) % mod;\n\t\t\tpw[x][j] = pw[y][j] = i;\n\t\t}\n\t\tfor(int j = 0; j < N; j++) if(x != j && y != j) {\n\t\t\ta = cnt[j][y] * pw2[pw[j][y]-i-1] % mod, b = cnt[j][x] * pw2[pw[j][x]-i-1] % mod;\n\t\t\tcnt[j][x] = cnt[j][y] = (b + a) % mod;\n\t\t\tpw[j][x] = pw[j][y] = i;\n\t\t}\n\t}\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N; j++)\n\t\tcnt[i][j] = cnt[i][j] * pw2[pw[i][j]] % mod;\n\tcat ans = 0;\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N; j++) if(A[i] > A[j])\n\t\tans = (ans + cnt[j][i]) % mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace mint {\n  constexpr int md = 1e9 + 7;\n  inline void add (int &a, int b) {\n    a += b; if (a >= md) a -= md;\n  }\n  inline void sub (int &a, int b) {\n    a -= b; if (a < 0) a += md;\n  }\n  inline int sum (int a, int b) {\n    add(a, b); return a;\n  }\n  inline int dif (int a, int b) {\n    sub(a, b); return a;\n  }\n  // inline int prod (int a, int b) {\n  //   return (int)((long long)a * b % md);\n  // }\n  template<class... A>\n  inline int prod (A... args) {\n    long long ret = 1;\n    for (int a : initializer_list<int>{args...}) {\n      ret *= a;\n    }\n    return (int)(ret % md);\n  }\n  inline void mul (int &a, int b) {\n    a = prod(a, b);\n  }\n  inline int inv (int a) {\n    a %= md;\n    if(a < 0) a += md;\n    int b = md, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= a * t; swap(a, b);\n      u -= v * t; swap(u, v);\n    }\n    assert(b == 1);\n    if(u < 0) u += md;\n    return u;\n  }\n  inline int quat (int a, int b) {\n    return prod(a, inv(b));\n  }\n  inline void div (int& a, int b) {\n    a = quat(a, b);\n  }\n  inline int pow (int a, long long b) {\n    int res = 1;\n    for (; b; b >>= 1) {\n      if (b & 1) mul(res, a);\n      mul(a, a);\n    }\n    return res;\n  }\n}\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  int inv2 = mint::inv(2);\n  int coeff = mint::pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      mint::add(a, b);\n      a = b = mint::prod(a, inv2);\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      mint::mul(dp[i][j], coeff);\n      mint::add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define mod 998244353\n#define G2 499122177\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn=3E3+5;\nint n,q,a[maxn],X[maxn],Y[maxn];\nll f[maxn][maxn],g[maxn][maxn];\ninline void add(ll&x,ll y)\n{\n\tx=(x+y)%mod;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=q;++i)\n\t\tcin>>X[i]>>Y[i];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=a[i]>a[j];\n\tfor(int k=1;k<=q;++k)\n\t{\n\t\tint x=X[k],y=Y[k];\n\t\t/*\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tif(i!=x&&i!=y&&j!=x&&j!=y)\n\t\t\t\t\tadd(g[i][j],f[i][j]*2);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd(g[i][j],f[i][j]);\n\t\t\t\t\tif((i==x&&j==y)||(i==y&&j==x))\n\t\t\t\t\t\tadd(g[i][j],f[j][i]);\n\t\t\t\t\telse if(i==j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if(i==x)\n\t\t\t\t\t\tadd(g[i][j],f[y][j]);\n\t\t\t\t\telse if(i==y)\n\t\t\t\t\t\tadd(g[i][j],f[x][j]);\n\t\t\t\t\telse if(j==x)\n\t\t\t\t\t\tadd(g[i][j],f[i][y]);\n\t\t\t\t\telse if(j==y)\n\t\t\t\t\t\tadd(g[i][j],f[i][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t*/\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tif(i==x||i==y)\n\t\t\t\tcontinue;\n\t\t\tf[x][i]=(f[x][i]+f[y][i])*G2%mod;\n\t\t\tf[y][i]=f[x][i];\n\t\t\tf[i][x]=(f[i][x]+f[i][y])*G2%mod;\n\t\t\tf[i][y]=f[i][x];\n\t\t}\n\t\tf[y][x]=f[x][y]=(f[x][y]+f[y][x])*G2%mod;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tadd(ans,f[i][j]);\n\tfor(int i=1;i<=q;++i)\n\t\tans=ans*2%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nconst int INV2=5e8+4;\nint n,q,a[500010],x,y;\nLL X[3010],Y[3010],ans,f[3010][3010];\nint main(){\n\tcin>>n>>q;\n\tFOR(i,1,n) getint(a[i]);\n\tFOR(i,1,n)\n\t\tFOR(j,1,n)\n\t\t\tf[i][j]=(a[i]<a[j]);\n\tFOR(rp,1,q){\n\t\tgetint(x),getint(y);\n\t\tFOR(i,1,n){\n\t\t\tif (i==x){X[i]=0;continue;}\n\t\t\tif (i==y){X[i]=(f[x][y]+f[y][x])*INV2%MO;continue;}\n\t\t\tX[i]=(f[x][i]+f[y][i])*INV2%MO;\n\t\t}\n\t\t//f'[x][i]\n\t\tFOR(i,1,n){\n\t\t\tif (i==y){Y[i]=0;continue;}\n\t\t\tif (i==x){Y[i]=(f[x][y]+f[y][x])*INV2%MO;continue;}\n\t\t\tY[i]=(f[x][i]+f[y][i])*INV2%MO;\n\t\t}\n\t\t//f'[y][i]\n\t\tFOR(i,1,n) f[x][i]=X[i],f[y][i]=Y[i];\n\t\tFOR(i,1,n) if (i!=x && i!=y) f[i][x]=f[i][y]=(f[i][x]+f[i][y])*INV2%MO;\n\t}\n\tFOR(i,1,n)\n\t\tFOR(j,1,i-1)\n\t\t\t(ans+=f[i][j])%=MO;\n\twhile (q--) ans=ans*2%MO;\n\tans=(ans%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}\n//using modint=ld;\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,q;cin>>n>>q;\n  vector<ll>a(n);\n  rep(i,0,n)cin>>a[i];\n  auto dp=make_v(n,n,modint(0));\n  rep(i,0,n)rep(j,0,n){\n    dp[i][j]=(a[i]>a[j]);\n  }\n    //debug(dp,n,n);cout<<endl;\n  modint inv=modint(1)/2;\n  rep(o,0,q){\n    ll x,y;cin>>x>>y;x--;y--;\n    vector<modint>dpi(n),dpj(n);\n    rep(i,0,n)dpi[i]=inv*(dp[x][i]+dp[y][i]);\n    rep(i,0,n)dpj[i]=inv*(dp[i][x]+dp[i][y]);\n    rep(i,0,n){\n      dp[x][i]=dpi[i];\n      dp[y][i]=dpi[i];\n      dp[i][x]=dpj[i];\n      dp[i][y]=dpj[i];\n    }\n    dp[x][x]=0;\n    dp[y][y]=0;\n    dp[x][y]=dpi[x]+dpj[x];\n    dp[y][x]=dpi[x]+dpj[x];\n    //debug(dp,n,n);cout<<endl;\n  }\n  modint ret=0;\n  rep(i,0,n)rep(j,i+1,n)ret+=dp[i][j];\n  ret*=pow(2LL,q);\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/agc030/tasks/agc030_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3002\n#define mod 1000000007\n\nint A[N];\nint dp[2][N][N][2];\n\nint getState(int i,int j) {\n  if(i<j) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint add(int x,int y) {\n  return (x+y)%mod;\n}\nint mul(int x,int y) {\n  return (ll)x*y%mod;\n}\npair<int,pair<int,int> > getTransition(int st,int i,int j,int x,int y) {\n  int ni = i;\n  if(x==i) {\n    ni = y;\n  } else if(ni==y) {\n    ni = x;\n  }\n  int nj = j;\n  if(x==j) {\n    nj = y;\n  } else if(nj==y) {\n    nj = x;\n  }\n  int ijState = getState(i,j);\n  int ni_nj_state = getState(ni,nj);\n  int nst = st;\n  if(ijState!=ni_nj_state) {\n    nst ^=1;\n  }\n  return make_pair(nst,make_pair(ni,nj));\n}\n\nvoid solve() {\n  int n,q;\n  scanf(\"%d %d\", &n,&q);\n  int bit = 0;\n  for(int i=0;i<n;++i) {\n    scanf(\"%d \", &A[i]);\n  }\n\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      if(A[i]==A[j]) {\n        continue;\n      }\n      if(A[i]>A[j]) {\n        ++dp[bit][i][j][1];\n      } else {\n        ++dp[bit][i][j][0];\n      }\n    }\n  }\n\n  while(q--) {\n    int x,y;scanf(\"%d %d \", &x,&y);\n    if(x>y) {\n      swap(x,y);\n    }\n    --x,--y;\n    int nbit = bit^1;\n    //optimize by lazy-eval\n\n    memset(dp[nbit],0,sizeof(dp[nbit]));\n    for(int i=0;i<n;++i) {\n      for(int j=0;j<n;++j) {\n        if(i==j) {\n          continue;\n        }\n        for(int st=0;st<2;++st) {\n          if(dp[bit][i][j][st]==0) {\n            continue;\n          }\n          dp[nbit][i][j][st] = add(dp[nbit][i][j][st],\n            dp[bit][i][j][st]);\n          pair<int,pair<int,int> >trans = getTransition(st,i,j,x,y);\n          dp[nbit][trans.second.first][trans.second.second][trans.first] =\n          add(dp[nbit][trans.second.first][trans.second.second][trans.first],\n            dp[bit][i][j][st]);\n        }\n      }\n    }\n    bit = nbit;\n  }\n  int ret = 0;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      ret = add(ret, dp[bit][i][j][1]);\n    }\n  }\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst int N=3010,mod=998244353,inv2=499122177;\nint n,Q,x,y,a[N];\nint dp[N][N],t1,t2,t3,t4;\nll ans,tot=1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);for (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++)for (int j=1;j<=n;j++)if (a[i]>a[j]) dp[i][j]=1;\n\twhile (Q--)\n\t{\n\t\ttot=tot*2%mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=((ll)dp[x][y]*inv2%mod+(ll)dp[y][x]*inv2%mod)%mod;\n\t\tfor (int i=1;i<=n;i++) \n\t\tif (i!=x&&i!=y){\n\t\t\tt1=dp[x][i];t2=dp[i][x];t3=dp[y][i];t4=dp[i][y];\n\t\t\tdp[y][i]=dp[x][i]=((ll)t1*inv2%mod+(ll)t3*inv2%mod)%mod;\n\t\t\tdp[i][x]=dp[i][y]=((ll)t2*inv2%mod+(ll)t4*inv2%mod)%mod;\n\t\t}\n\t}\n\tfor (int i=1;i<n;i++) for (int j=i+1;j<=n;j++) ans=(ans+dp[i][j])%mod;\n\tans=ans*tot%mod;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n\nconst int maxn = 3e3 + 5;\n\nint n, q;\nint a[maxn];\nint xl[maxn], xr[maxn];\nlong long dp[maxn][maxn];\n\nlong long power_mod(long long a, long long b) {\n    long long res = 1;\n    while (b) {\n        if (b % 2) res = res * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid trans() {\n    cin >> n >> q;\n    rep(i, 0, n) cin >> a[i];\n    rep(i, 0, q) {\n        cin >> xl[i] >> xr[i];\n        xl[i]--; xr[i]--;\n    }\n    long long re2 = power_mod(2, mod - 2);\n    rep(i, 0, n) {\n        rep(j, 0, n) {\n            if (i != j && a[i] > a[j]) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    rep(t, 0, q) {\n        rep(i, 0, n) {\n            if (i == xl[t] || i == xr[t]) continue;\n            dp[i][xl[t]] = dp[i][xr[t]] = (dp[i][xl[t]] + dp[i][xr[t]]) * re2 % mod;\n            dp[xl[t]][i] = dp[xr[t]][i] = (dp[xl[t]][i] + dp[xr[t]][i]) * re2 % mod;\n        }\n        dp[xl[t]][xr[t]] = dp[xr[t]][xl[t]] = (dp[xl[t]][xr[t]] + dp[xr[t]][xl[t]]) * re2 % mod;\n    }\n    long long ans = 0;\n    rep(i, 0, n) {\n        rep(j, i + 1, n) {\n            (ans += dp[i][j]) %= mod;\n        }\n    }\n    ans = ans * power_mod(2, q) % mod;\n    cout << ans;\n}\n\nint main() {\n    trans();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//21\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn = 3001;\nconst int lbt = 1e9 + 7;\n\nstruct req {\n\tint s, x, y, d;\n\treq() {}\n\treq(int s, int x, int y, int d) : s(s), x(x), y(y), d(d) {}\n};\n\nint n, q;\nint a[maxn];\nint x[maxn], y[maxn];\nint dp[2][maxn][maxn];\nreq op[14 * maxn];\n\nvoid add(int &x, int y);\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j]) dp[0][i][j]++;\n\t\t\tif (a[i] > a[j]) dp[1][i][j]++;\n\t\t}\n\t}\n\tint rev2 = (lbt + 1) / 2;\n\tfor (int _ = 1; _ <= q; _++) {\n\t\tint x = ::x[_];\n\t\tint y = ::y[_];\n\t\tif (x == y) continue;\n\t\tint cnt = 0;\n\t\tif (x > y) swap(x, y);\n\t\tfor (int j = y + 1; j <= n; j++) {\n\t\t\top[++cnt] = req(0, x, j, dp[0][y][j]);\n\t\t\top[++cnt] = req(1, x, j, dp[1][y][j]);\n\t\t\top[++cnt] = req(0, y, j, dp[0][x][j]);\n\t\t\top[++cnt] = req(1, y, j, dp[1][x][j]);\n\t\t}\n\t\tfor (int i = x + 1; i < y; i++) {\n\t\t\top[++cnt] = req(1, x, i, dp[0][i][y]);\n\t\t\top[++cnt] = req(0, x, i, dp[1][i][y]);\n\t\t}\n\t\top[++cnt] = req(0, x, y, dp[1][x][y]);\n\t\top[++cnt] = req(1, x, y, dp[0][x][y]);\n\t\tfor (int j = x + 1; j < y; j++) {\n\t\t\top[++cnt] = req(1, j, y, dp[0][x][j]);\n\t\t\top[++cnt] = req(0, j, y, dp[1][x][j]);\n\t\t}\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\top[++cnt] = req(0, i, x, dp[0][i][y]);\n\t\t\top[++cnt] = req(1, i, x, dp[1][i][y]);\n\t\t\top[++cnt] = req(0, i, y, dp[0][i][x]);\n\t\t\top[++cnt] = req(1, i, y, dp[1][i][x]);\n\t\t}\n\t\tfor (int i = 1; i <= cnt; i++) {\n\t\t\tadd(dp[op[i].s][op[i].x][op[i].y], op[i].d);\n\t\t}\n\t\tfor (int i = 1; i < y; i++) {\n\t\t\tdp[0][i][y] = (long long)dp[0][i][y] * rev2 % lbt;\n\t\t\tdp[1][i][y] = (long long)dp[1][i][y] * rev2 % lbt;\n\t\t}\n\t\tfor (int j = x + 1; j <= n; j++) {\n\t\t\tdp[0][x][j] = (long long)dp[0][x][j] * rev2 % lbt;\n\t\t\tdp[1][x][j] = (long long)dp[1][x][j] * rev2 % lbt;\n\t\t}\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tdp[0][i][x] = (long long)dp[0][i][x] * rev2 % lbt;\n\t\t\tdp[1][i][x] = (long long)dp[1][i][x] * rev2 % lbt;\n\t\t}\n\t\tfor (int j = y + 1; j <= n; j++) {\n\t\t\tdp[0][y][j] = (long long)dp[0][y][j] * rev2 % lbt;\n\t\t\tdp[1][y][j] = (long long)dp[1][y][j] * rev2 % lbt;\n\t\t}\n\t\tdp[0][x][y] = 2 * dp[0][x][y] % lbt;\n\t\tdp[1][x][y] = 2 * dp[1][x][y] % lbt;\n\t}\n\tint pow2 = 1;\n\tfor (int i = 1; i <= q; i++) pow2 = 2 * pow2 % lbt;\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tdp[0][i][j] = (long long)pow2 * dp[0][i][j] % lbt;\n\t\t\tdp[1][i][j] = (long long)pow2 * dp[1][i][j] % lbt;\n\t\t\tadd(ans, dp[1][i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n\nvoid add(int &x, int y) {\n\tx = x + y >= lbt ? x + y - lbt : x + y;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++ PROG: d.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %lld\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\nconst signed inf=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>ll dcmp(T a,T b){return a>b;}\ntemplate<ll *a>ll cmp_a(ll x,ll y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst ll SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; ll f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// prll the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed lleger\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// prll a signed lleger\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nll a[3005],u[3005],v[3005];\nll f[3005][3005],vf[3005][3005];\nll work(ll x,ll q){return u[q]==x?v[q]:v[q]==x?u[q]:x;}\nconst ll p=1e9+7,half=5e8+4;\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"d.in\",\"r\",stdin);\n\tfreopen(\"d.out\",\"w\",stdout);\n#endif\n\tll n,q;\n\tread(n,q);\n\tfor(ll i=1;i<=n;++i)read(a[i]);\n\tfor(ll i=1;i<=q;++i)read(u[i],v[i]);\n\tfor(ll i=1;i<=n;++i)for(ll j=1;j<=n;++j)f[i][j]=i>j;\n\tll x=1;\n\tfor(;q;--q){\n\t\tx=x*2%p;\n\t\tfor(ll i=1;i<=n;++i){\n\t\t\tf[u[q]][i]=f[u[q]][i]*half%p;\n\t\t\tf[v[q]][i]=f[v[q]][i]*half%p;\n\t\t\tif(i!=v[q])\tf[i][u[q]]=f[i][u[q]]*half%p;\n\t\t\tif(i!=u[q]) f[i][v[q]]=f[i][v[q]]*half%p;\n\t\t}\n\t\tfor(ll i=1;i<=n;++i){\n\t\t\tvf[u[q]][i]=(f[u[q]][i]+f[v[q]][work(i,q)])%p;\n\t\t\tvf[v[q]][i]=(f[v[q]][i]+f[u[q]][work(i,q)])%p;\n\t\t\tvf[i][u[q]]=(f[i][u[q]]+f[work(i,q)][v[q]])%p;\n\t\t\tvf[i][v[q]]=(f[i][v[q]]+f[work(i,q)][u[q]])%p;\n\t\t}\n\t\tfor(ll i=1;i<=n;++i){\n\t\t\tf[u[q]][i]=vf[u[q]][i];\n\t\t\tf[v[q]][i]=vf[v[q]][i];\n\t\t\tf[i][u[q]]=vf[i][u[q]];\n\t\t\tf[i][v[q]]=vf[i][v[q]];\n\t\t}\n\t}\n\tll ans=0;\n\tfor(ll i=1;i<=n;++i)for(ll j=1;j<=n;++j)if(a[i]<a[j])ans=(ans+f[i][j]*x)%p;\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=3005,mod=1e9+7;\nint n,q;\nint a[N];\nint x[N],y[N];\nint inv2=(mod+1)/2;\nint dp[N][N],tmp[N];\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t\tif (y&1)\n\t\t\tans=1LL*ans*x%mod;\n\treturn ans;\n}\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tfor (int i=1;i<=q;i++)\n\t\tx[i]=read(),y[i]=read();\n\tmemset(dp,0,sizeof dp);\n\t// dp[1..n][1..i-1]\n\tfor (int t=q;t>=1;t--){\n\t\tint a=x[t],b=y[t];\n\t\tif (a==b)\n\t\t\tcontinue;\n\t\tfor (int i=a+1;i<b;i++)\n\t\t\ttmp[i]=(LL)inv2*((LL)mod+1-dp[b][i]+dp[i][a])%mod;\n\t\tdp[a][b]=inv2;\n\t\tfor (int i=a+1;i<b;i++)\n\t\t\tdp[b][i]=(LL)inv2*((LL)dp[b][i]+mod+1-dp[i][a])%mod;\n\t\tfor (int i=a+1;i<b;i++)\n\t\t\tdp[i][a]=tmp[i];\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++,puts(\"\"))\n\t\tfor (int j=1;j<i;j++)\n\t\t\tprintf(\"%d \",dp[i][j]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[i]<a[j])\n\t\t\t\tans=(ans+mod+1-dp[i][j])%mod;\n\t\t\telse if (a[i]>a[j])\n\t\t\t\tans=(ans+dp[i][j])%mod;\n\tans=(LL)ans*Pow(2,q)%mod;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nmint i2 = (mint)1/2;\nmint f[3000][3000];\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\tV<int> a(N);\n\trep(i,N) cin>>a[i];\n\trep(i,N) rep(j,N) if(i>j) f[i][j] = 1;\n\tV<int> X(Q),Y(Q);\n\trep(i,Q){\n\t\tcin>>X[i]>>Y[i];\n\t\tX[i]--,Y[i]--;\n\t}\n\tfor(int t=Q-1;t>=0;t--){\n\t\tV<int> is,js;\n\t\tV<mint> vs;\n\t\tauto add = [&](int i,int j,mint v){\n\t\t\tis.pb(i);\n\t\t\tjs.pb(j);\n\t\t\tvs.pb(v);\n\t\t};\n\t\tint x = X[t], y = Y[t];\n\t\trep(_,2){\n\t\t\tadd(x,y,i2);\n\t\t\trep(j,N) if(j!=x && j!=y){\n\t\t\t\tadd(x,j,(f[x][j]+f[y][j])/2);\n\t\t\t\tadd(j,x,(f[j][x]+f[j][y])/2);\n\t\t\t}\n\t\t\tswap(x,y);\n\t\t}\n\t\tint K = is.size();\n\t\trep(k,K){\n\t\t\tf[is[k]][js[k]] = vs[k];\n\t\t}\n\t}\n\tmint ans = 0;\n\trep(i,N) rep(j,N) if(a[i]<a[j]) ans += f[i][j];\n\trep(_,Q) ans *= 2;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 3100;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\n\nconst int X = 5e8 + 4;\n\nint n, q;\nint a[N];\nint dp[N][N];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (a[i] > a[j]) dp[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < q; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        vector<int> vars1(n), vars2(n);\n        for (int j = 0; j < n; j++)\n        {\n            vars1[j] = (dp[j][x] + dp[j][y]) * X % MOD;\n            vars2[j] = (dp[x][j] + dp[y][j]) * X % MOD;\n        }\n        for (int j = 0; j < n; j++)\n        {\n            if (j != x && j != y)\n            {\n                dp[j][x] = vars1[j];\n                dp[x][j] = vars2[j];\n                dp[j][y] = vars1[j];\n                dp[y][j] = vars2[j];\n            }\n        }\n        dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * X % MOD;\n    }\n    long long ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            ans = (ans + dp[i][j]) % MOD;\n        }\n    }\n    for (int i = 0; i < q; i++) ans = 2 * ans % MOD;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nconst LL MOD=1e9+7;\ninline LL Pow(LL x,LL y)\n{\n    LL ans=1;\n    while(y>0)\n    {\n        if(y&1)\n            ans=ans*x%MOD;\n        x=x*x%MOD;\n        y>>=1;\n    }\n    return ans;\n}\ninline LL Inv(LL x)\n{\n    return Pow(x,MOD-2);\n}\nLL N,Q,i,j;\nLL A[3010];\nLL inv[3010][3010];\nLL ans,sum;\nLL inv2;\nLL X,Y;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>Q;\n    for(i=0;i<N;i++)\n        cin>>A[i];\n    for(i=0;i<N;i++)\n        for(j=0;j<N;j++)\n            if(A[j]<A[i])\n                inv[i][j]=1;\n    inv2=Inv(2);\n    ans=Pow(2,Q);\n    while(Q-->0)\n    {\n        cin>>X>>Y;\n        X--;\n        Y--;\n        inv[X][Y]=inv[Y][X]=inv2*(inv[X][Y]+inv[Y][X])%MOD;\n        for(i=0;i<N;i++)\n        {\n            if(i==X||i==Y)\n                continue;\n            inv[i][X]=inv[i][Y]=inv2*(inv[i][X]+inv[i][Y])%MOD;\n            inv[X][i]=inv[Y][i]=inv2*(inv[X][i]+inv[Y][i])%MOD;\n        }\n    }\n    for(i=0;i<N;i++)\n        for(j=i+1;j<N;j++)\n            sum+=inv[i][j];\n    sum%=MOD;\n    cout<<ans*sum%MOD<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<utility>//pair\n#include<cmath>//abs,sqrt\n#include<cstring>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define prin(arg) std::cout<<arg<<\"\\n\"\n#define prin2(arg1,arg2) std::cout<<arg1<<\" \"<<arg2<<\"\\n\"\n#define fill(arg,n) memset(arg,n,sizeof(arg))\nusing std::cin;\ntypedef long long ll;\nconst int INF=1e+9;\nconst ll INFLL=1e+17;\nconst ll MOD=1e+9+7;\nint N,Q;\nint A[3010],X[3010],Y[3010];\nll dp[3010][3010][2];\nll modpow(int m){\n  ll res=1;\n  rep(i,m){\n    res=(res*2)%MOD;\n  }  \n  return res;\n}\nint Extgcd(int a,int b,int &x,int &y){\n  int d=a;\n  if(b!=0){\n    Extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }\n  else{\n    x=1;y=0;\n  }\n  return d;\n}\n\nint Invmod(int a,int p){//mod pでのaの逆元を求める\n  int x,y;\n  Extgcd(a,p,x,y);\n  return (x%p+p)%p;\n}\nvoid solve(){\n  rep(i,N){\n    rep(j,N){\n      if(A[i]<=A[j]){\n\tdp[i][j][0]=0;\n      }\n      else dp[i][j][0]=1;\n    }\n  }\n  rep(i,Q){\n    int x=X[i],y=Y[i];\n    rep(j,N){\n      if(j!=y&&x!=j) dp[x][j][1]=(Invmod(2,MOD)*((dp[x][j][0]+dp[y][j][0])%MOD))%MOD;\n    }\n    rep(j,N){\n      if(j!=y&&x!=j) dp[j][x][1]=(Invmod(2,MOD)*((dp[j][x][0]+dp[j][y][0])%MOD))%MOD;\n    }\n    rep(j,N){\n      if(j!=x&&y!=j) dp[y][j][1]=(Invmod(2,MOD)*((dp[x][j][0]+dp[y][j][0])%MOD))%MOD;\n    }\n    rep(j,N){\n      if(j!=x&&y!=j) dp[j][y][1]=(Invmod(2,MOD)*((dp[j][x][0]+dp[j][y][0])%MOD))%MOD;\n    }\n    dp[x][y][1]=(Invmod(2,MOD)*((dp[x][y][0]+dp[y][x][0])%MOD))%MOD;\n    dp[y][x][1]=(Invmod(2,MOD)*((dp[x][y][0]+dp[y][x][0])%MOD))%MOD;\n    rep(j,N){\n      if(j!=y&&x!=j) dp[x][j][0]=dp[x][j][1];\n    }\n    rep(j,N){\n      if(j!=y&&x!=j) dp[j][x][0]=dp[j][x][1];\n    }\n    rep(j,N){\n      if(j!=x&&y!=j) dp[y][j][0]=dp[y][j][1];\n    }\n    rep(j,N){\n      if(j!=x&&y!=j) dp[j][y][0]=dp[j][y][1];\n    }\n    dp[x][y][0]=dp[x][y][1];\n    dp[y][x][0]=dp[y][x][1];\n\n\n    /*  rep(a,N){\n      rep(b,N){\n\tstd::cout<<dp[a][b][0]<<\" \";\n      }\n      std::cout<<\"\\n\";\n      }*/\n  }\n  ll res=0;\n  ll q=modpow(Q);\n  rep(i,N){\n    for(int j=i+1;j<N;j++){\n      res=(res+(q*dp[i][j][0])%MOD)%MOD;\n    }\n  }\n\n  prin(res);\n}\n\n\nint main(){\n  cin>>N>>Q;\n  rep(i,N) cin>>A[i];\n  rep(i,Q){\n    cin>>X[i]>>Y[i];\n    X[i]--;Y[i]--;\n  }\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define pb push_back\n#define mp make_pair\n#define Chkmax(a,b) a=a>b?a:b\n#define Chkmin(a,b) a=a<b?a:b\n#define mx(a,b) (a>b?a:b)\n#define mn(a,b) (a<b?a:b)\ntypedef unsigned long long uint64;\ntypedef unsigned int uint32;\ntypedef long long ll;\nusing namespace std;\n\nnamespace IO\n{\n    const uint32 Buffsize=1<<15,Output=1<<23;\n    static char Ch[Buffsize],*S=Ch,*T=Ch;\n    inline char getc()\n\t{\n\t\treturn((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);\n\t}\n    static char Out[Output],*nowps=Out;\n    \n    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}\n\n    template<typename T>inline void read(T&x)\n\t{\n\t\tx=0;static char ch;T f=1;\n\t\tfor(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;\n\t\tfor(;isdigit(ch);ch=getc())x=x*10+(ch^48);\n\t\tx*=f;\n\t}\n\n\ttemplate<typename T>inline void write(T x,char ch='\\n')\n\t{\n\t\tif(!x)*nowps++='0';\n\t\tif(x<0)*nowps++='-',x=-x;\n\t\tstatic uint32 sta[111],tp;\n\t\tfor(tp=0;x;x/=10)sta[++tp]=x%10;\n\t\tfor(;tp;*nowps++=sta[tp--]^48);\n\t\t*nowps++=ch;\n\t}\n}\nusing namespace IO;\n\ninline void file()\n{\n\tfreopen(\"d.in\",\"r\",stdin);\n\tfreopen(\"d.out\",\"w\",stdout);\n}\n\nconst int MAXN=3000+7;\n\nstatic int n,m,a[MAXN];\n\ninline void init()\n{\n\tread(n),read(m);\n\tRep(i,1,n)read(a[i]);\n}\n\nconst int mod=1e9+7,inv2=(mod+1)/2;\n\ninline int power(int u,int v)\n{\n\tstatic int sm;\n\tfor(sm=1;v;v>>=1,u=1ll*u*u%mod)if(v&1)\n\t\tsm=1ll*sm*u%mod;\n\treturn sm;\n}\n\nstatic int f[MAXN][MAXN],lef[MAXN][MAXN];\n\ninline void solve()\n{\n\tstatic int u,v;\n\tRep(i,1,n-1)Rep(j,i+1,n)\n\t{\n\t\tif(a[i]<a[j])f[i][j]=1;\n\t\tif(a[i]>a[j])f[j][i]=1;\n\t}\n\tRep(_,1,m)\n\t{\n\t\tread(u),read(v);\n\t\tRep(i,1,n)lef[i][u]=lef[i][v]=lef[u][i]=lef[v][i]=0;\n\t\tRep(i,1,n)if(i^u&&i^v)\n\t\t{\n\t\t\tlef[i][u]=(1ll*lef[i][u]+f[i][u]+f[i][v])%mod;\n\t\t\tlef[i][v]=(1ll*lef[i][v]+f[i][u]+f[i][v])%mod;\n\t\t\tlef[u][i]=(1ll*lef[u][i]+f[u][i]+f[v][i])%mod;\n\t\t\tlef[v][i]=(1ll*lef[v][i]+f[u][i]+f[v][i])%mod;\n\t\t}\n\t\tlef[u][v]=lef[v][u]=(f[u][v]+f[v][u])%mod;\n\t\tRep(i,1,n)\n\t\t{\n\t\t\tf[i][u]=1ll*lef[i][u]*inv2%mod;\n\t\t\tf[i][v]=1ll*lef[i][v]*inv2%mod;\n\t\t\tf[u][i]=1ll*lef[u][i]*inv2%mod;\n\t\t\tf[v][i]=1ll*lef[v][i]*inv2%mod;\n\t\t}\n\t}\n\tstatic int ans=0;\n\tRep(i,2,n)Rep(j,1,i-1)ans=(ans+f[i][j])%mod;\n\tans=1ll*ans*power(2,m)%mod;\n\tcout<<ans<<endl;\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\nconst int N=3030,M=100010;\nconst long long Mod=1e9+7;\nconst int MAX=2e9;\nlong long ans,n,q,a[N],x[N],y[N],f[N][N],inv;\nlong long power(long long x,long long y){\n    long long sum=1,base=x;\n    while(y){\n        if(y&1) sum=(sum*base)%Mod;\n        base=(base*base)%Mod;\n        y>>=1;\n    }\n    return sum;\n}\nint main(){\n    //freopen(\"problem.in\",\"r\",stdin);\n    //freopen(\"problem.out\",\"w\",stdout);\n    scanf(\"%lld%lld\",&n,&q);\n    inv=power(2,Mod-2);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n    for(int i=1;i<=q;i++) scanf(\"%lld%lld\",&x[i],&y[i]);\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            f[i][j]=(a[i]<a[j]);\n        }\n    }\n    for(int i=1;i<=q;i++){\n        f[x[i]][y[i]]=f[y[i]][x[i]]=(f[x[i]][y[i]]+f[y[i]][x[i]])*inv%Mod;\n        for(int j=1;j<=n;j++){\n            if(j==x[i]||j==y[i]) continue;\n            f[j][y[i]]=f[j][x[i]]=(f[j][x[i]]+f[j][y[i]])*inv%Mod;\n            f[x[i]][j]=f[y[i]][j]=(f[x[i]][j]+f[y[i]][j])*inv%Mod;\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<i;j++){\n            ans=(ans+f[i][j])%Mod;\n        }\n    }\n    printf(\"%lld\\n\",ans*power(2,q)%Mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n\treturn mod_pow(a, M - 2, M);\n}\n\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vi a(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  vll dp(n, vl(n));\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) continue;\n      if (a[i] < a[j]) dp[i][j] = 1;\n    }\n  }\n  ll half = mod_inverse(2);\n  vll memo(n, vl(n));\n  rep (aaa, q) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      memo[i][u] = (dp[i][u] + dp[i][v]) % MOD * half % MOD;\n      memo[u][i] = (dp[u][i] + dp[v][i]) % MOD * half % MOD;\n      memo[i][v] = (dp[i][u] + dp[i][v]) % MOD * half % MOD;\n      memo[v][i] = (dp[u][i] + dp[v][i]) % MOD * half % MOD;\n    }\n    memo[u][v] = memo[v][u] = (dp[u][v] + dp[v][u]) % MOD * half % MOD;\n    rep (i, n) {\n      if (i == u || i == v) continue;\n      dp[i][u] = memo[i][u];\n      dp[i][v] = memo[i][v];\n      dp[u][i] = memo[u][i];\n      dp[v][i] = memo[v][i];\n    }\n    dp[u][v] = dp[v][u] = memo[u][v];\n  }\n  ll ans = 0;\n  ll po = mod_pow(2, q);\n  rep (i, n) {\n    for (int j = 0; j < i; j++) {\n      ans += po * dp[i][j] % MOD;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nconst ll half=(mod+1)/2;\nint n,q;\nint a[3001];\nint x[3001],y[3001];\nint p[3001][3001];\nll ax[3001];\nll xb[3001];\nll p2q=1;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> q;\n\tfor(int i=1; i<=n ;i++) cin >> a[i];\n\tfor(int i=1; i<=q ;i++){\n\t\tp2q=p2q*2%mod;\n\t\tcin >> x[i] >> y[i];\n\t\tif(x[i]>y[i]) swap(x[i],y[i]);\n\t}\n\tfor(int i=1; i<=n ;i++){\n\t\tfor(int j=1; j<=n ;j++){\n\t\t\tp[i][j]=(i>j);\n\t\t}\n\t}\n\tfor(int i=q; i>=1 ;i--){\n\t\tll orz=(p[x[i]][y[i]]+p[y[i]][x[i]])*half%mod;\n\t\tfor(int j=1; j<=n ;j++){\n\t\t\tax[j]=(p[x[i]][j]+p[y[i]][j])*half%mod;\n\t\t\txb[j]=(p[j][x[i]]+p[j][y[i]])*half%mod;\n\t\t}\n\t\tfor(int j=1; j<=n ;j++){\n\t\t\tp[x[i]][j]=p[y[i]][j]=ax[j];\n\t\t\tp[j][x[i]]=p[j][y[i]]=xb[j];\n\t\t}\n\t\tp[x[i]][y[i]]=p[y[i]][x[i]]=orz;\n\t}\n\tll ans=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tfor(int j=i+1; j<=n ;j++){\n\t\t\tif(a[i]==a[j]) continue;\n\t\t\tif(a[i]<a[j]) ans=(ans+p[i][j])%mod;\n\t\t\telse ans=(ans+mod+1-p[i][j])%mod;\n\t\t}\n\t}\n\tcout << ans*p2q%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<functional>\n#include<cmath>\n#include<vector>\n#include<assert.h>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nvoid open2(const char *s){\n#ifdef DEBUG\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst int N=3010;\nconst ll p=1000000007;\nll fp(ll a,ll b)\n{\n\tll s=1;\n\tfor(;b;b>>=1,a=a*a%p)\n\t\tif(b&1)\n\t\t\ts=s*a%p;\n\treturn s;\n}\nconst ll inv2=fp(2,p-2);\nint a[N];\nint n,q;\nll f[N][N];\nint main()\n{\n//\topen(\"d\");\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j])\n\t\t\t\tf[i][j]=1;\n\tint x,y;\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x&&j!=y)\n\t\t\t{\n\t\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])*inv2%p;\n\t\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])*inv2%p;\n\t\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])%p;\n\tans=ans*fp(2,q)%p;\n\tans=(ans%p+p)%p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mk make_pair\n#define ll long long\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 3010;\nconst int mod = 1e9+7;\n\nint qsm(int i,int j)\n{\n\tint ans=1;\n\twhile (j)\n\t{\n\t\tif (j&1) ans=ans*i%mod;\n\t\tj>>=1;\n\t    i=i*i%mod;\n\t}\n\treturn ans;\n}\n\nint dp[maxn][maxn];\nint n,m;\nint q;\nint a[maxn];\n\nsigned main()\n{\n   scanf(\"%lld%lld\",&n,&m);\n   for (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);//a[i]=read();\n   for (int i=1;i<=n;i++)\n     for (int j=1;j<=n;j++)\n       dp[i][j]=(a[i]>a[j]);// a[i]在前，a[j]在后形成逆序对的概率 \n   int inv = qsm(2,mod-2);\n   for (int i=1;i<=m;i++)\n   {\n   \t  int x,y;\n   \t  scanf(\"%lld%lld\",&x,&y);\n   \t  dp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv%mod;\n   \t  for (int i=1;i<=n;i++)\n   \t  {\n   \t  \tif (i!=x && i!=y)\n   \t  \t{\n   \t  \t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*inv%mod;\n   \t  \t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*inv%mod;\n\t\t}\n\t  }\n   }\n   int ans=0;\n   for (int i=1;i<=n;i++)\n     for (int j=i+1;j<=n;j++)\n        ans=(ans+dp[i][j])%mod;\n   cout<<ans*qsm(2,m)%mod;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define modsum(a, b) ((a) + (b) >= M ? (a) + (b) - M : (a) + (b))\n#define modsubtract(a, b) ((a) - (b) < 0 ? (a) - (b) + M : (a) - (b))\n#define modmultiply(a, b) (((a) * (b)) % M)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)((a).size()))\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T>\nostream & operator << (ostream &out, vector<T> &a) {\n    out << \"{\";\n    fori (i, SZ(a))\n        out << a[i] << vector<string>{\", \", \"}\"}[i + 1 == SZ(a)];\n    return out;\n}\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\n\";\n    cout << \"TOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nint n, q;\nconst int N = 3003;\nconst ll M = 1e9 + 7;\nint a[N];\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % M;\n        a = (a * a) % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll pw2[N];\n\nmap<pii, int> dp[N];\n\npii queries[N];\n\nvi my_q[N];\n\nll dfs(int i, int l, int r) {\n    if (i == q) {\n        if (l > r) return 1;\n        return 0;\n    }\n    if (dp[i].count({l, r})) return dp[i][{l, r}];\n\n    vi cur_q;\n    for (auto ind : my_q[l]) {\n        if (ind >= i) cur_q.push_back(ind);\n    }\n    for (auto ind : my_q[r]) {\n        if (ind >= i) cur_q.push_back(ind);\n    }\n    sort(ALL(cur_q));\n    cur_q.resize(unique(ALL(cur_q)) - cur_q.begin());\n    ll ret = 0;\n    for (int j = 0; j < cur_q.size(); ++j) {\n        int ind = cur_q[j];\n        int lf = queries[ind].first, rf = queries[ind].second;\n        if ((l < r) ^ (lf < rf)) swap(lf, rf);\n        ll ways = pw2[ind - i - j];\n        if (lf == l && rf == r) {\n            ret = (ret + ways * dfs(ind + 1, r, l)) % M;\n        } else if (lf == l || rf == l) {\n            if (lf != l) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, rf, r)) % M;\n        } else if (rf == r || lf == r) {\n            if (rf != r) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, l, lf)) % M;\n        } else assert(0);\n    }\n    ret = (ret + pw2[q - i - cur_q.size()] * dfs(q, l, r)) % M;\n    return dp[i][{l, r}] = ret;\n}\n\nvoid smain() {\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n    cin >> n >> q;\n    fori (i, n) cin >> a[i];\n    fori (i, q) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--, queries[i].second--;\n        my_q[queries[i].first].push_back(i);\n        my_q[queries[i].second].push_back(i);\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ll cur = dfs(0, i, j);\n//            cout << \"cur[\" << i << \", \" << j << \"] = \" << cur << endl;\n            if (a[i] < a[j]) ans = (ans + cur) % M;\n            else if (a[i] > a[j]) ans = (ans + pw2[q] - cur + M) % M;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//dengyaotriangle\nusing namespace std;\n\nconst int maxn=3005;\nconst int mdn=1000000007;\nconst int inv2=(mdn+1)>>1;\nint n,q;\nint a[maxn];\npair<int,int> c[maxn];\nlong long dp[maxn][maxn];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++){cin>>a[i];}\n    for(int i=1;i<=q;i++){cin>>c[i].first>>c[i].second;}\n    for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){dp[i][j]=(a[i]<a[j]);}} \n    for(int i=1;i<=q;i++){\n        int u=c[i].first,v=c[i].second;\n        long long mean=(dp[u][v]+dp[v][u])*inv2%mdn;\n        dp[u][v]=dp[v][u]=mean;\n        for(int j=1;j<=n;j++){\n            if(j==u||j==v)continue;\n            long long m1=(dp[j][u]+dp[j][v])*inv2%mdn;\n            dp[j][v]=m1;\n            dp[j][u]=m1;\n            long long m2=(dp[u][j]+dp[v][j])*inv2%mdn;\n            dp[u][j]=m2;\n            dp[v][j]=m2;\n        }\n    }\n    long long ans=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<i;j++){\n            ans+=dp[i][j];\n        }\n    }\n    long long tot=1;\n    for(int i=1;i<=q;i++){tot=(tot<<1)%mdn;}\n    cout<<(ans*tot)%mdn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 3e3 + 5, MOD = 1e9 + 7;\nint dp[N][N], a[N];\n\nint mul(int a, int b) {return 1ll * a * b % MOD;}\nint Pow(int a, int b) {\n    int res = 1;\n    for (; b; b>>=1, a = mul(a, a)) if (b&1) res = mul(res, a);\n    return res;\n}\nint Inv = Pow(2, MOD - 2);\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int n, q; cin >> n >> q;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) dp[i][j] = a[i] > a[j];\n    int ans = 1;\n    for (int j = 0; j < q; j++) {\n        int x, y; cin >> x >> y;\n        for (int i = 1; i <= n; i++) if (i != x && i != y) {\n\t\t\tdp[i][x] = dp[i][y] = mul(dp[i][x] + dp[i][y], Inv);\n\t\t\tdp[x][i] = dp[y][i] = mul(dp[x][i] + dp[y][i], Inv);\n\t\t}\n        dp[x][y] = dp[y][x] = mul(dp[x][y] + dp[y][x], Inv);\n        ans = mul(2, ans);\n    }\n    int sum = 0;\n    for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) sum = (sum + dp[i][j]) % MOD;\n    cout << mul(ans, sum) << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int md = (int) 1e9 + 7;\n \ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n \ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n \ninline int mul(int a, int b) {\n#if !defined(_WIN32) || defined(_WIN64)\n  return (int) ((long long) a * b % md);\n#endif\n  unsigned long long x = (long long) a * b;\n  unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n  asm(\n    \"divl %4; \\n\\t\"\n    : \"=a\" (d), \"=d\" (m)\n    : \"d\" (xh), \"a\" (xl), \"r\" (md)\n  );\n  return m;\n}\n \ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n \ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<vector<int>> b(n, vector<int>(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      b[i][j] = (a[i] < a[j]);\n    }\n  }\n  int inv2 = inv(2);\n  int final_coeff = power(2, tt);\n  while (tt--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    for (int i = 0; i < n; i++) {\n      if (i != x && i != y) {\n        {\n          int sum = b[i][x];\n          add(sum, b[i][y]);\n          sum = mul(sum, inv2);\n          b[i][x] = b[i][y] = sum;\n        }\n        {\n          int sum = b[x][i];\n          add(sum, b[y][i]);\n          sum = mul(sum, inv2);\n          b[x][i] = b[y][i] = sum;\n        }\n      }\n    }\n    {\n      int sum = b[x][y];\n      add(sum, b[y][x]);\n      sum = mul(sum, inv2);\n      b[x][y] = b[y][x] = sum;\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      add(ans, b[i][j]);\n    }\n  }\n  ans = mul(ans, final_coeff);\n  cout << ans << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005, mod = 1000000007;\n\nint n, m, a[maxn];\nll f[maxn][maxn];\n\nll qpow(ll x, int y)\n{\n\tll ret = 1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tret = ret * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\t\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tf[i][j] = (a[i] > a[j]);\n\tint u, v, inv2 = qpow(2, mod - 2);\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tif(u > v)\tswap(u, v);\n\t\tf[u][v] = f[v][u] = inv2 * (f[u][v] + f[v][u]) % mod;\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(j != u && j != v)\n\t\t\t{\n\t\t\t\tf[j][u] = f[j][v] = inv2 * (f[j][u] + f[j][v]) % mod;\n\t\t\t\tf[u][j] = f[v][j] = inv2 * (f[u][j] + f[v][j]) % mod;\n\t\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tans = (ans + f[i][j]) % mod;\n\tprintf(\"%lld\", ans * qpow(2, m) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, long long> iii;\n\nconst long long MOD = 1e9+7;\n\nint A[3005];\n\nint X[3005];\nint Y[3005];\n\nlong long dp[3005][3005]; // probability that A_x > A_y after random subset of Q operations in input\n\nlong long modpow(int a, int b){\n    if(b == 0){\n        return 1;\n    }else if(b == 1){\n        return a%MOD;\n    }else{\n        long long temp = modpow(a, b/2);\n        if(b%2 == 0){\n            return temp*temp%MOD;\n        }else{\n            return ((temp*temp)%MOD*a)%MOD;\n        }\n    }\n}\n\nint main(){\n    int N, Q;\n    scanf(\"%d%d\", &N, &Q);\n\n    for(int i = 0; i < N; i ++){\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int i = 0; i < Q; i ++){\n        scanf(\"%d%d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n    }\n\n    for(int i = 0; i < N; i ++){\n        for(int j = 0; j < N; j ++){\n            dp[i][j] = A[j] < A[i];\n        }\n    }\n\n    const long long HALF = modpow(2, MOD-2);\n    int swap1[2];\n    for(int k = 0; k < Q; k ++){\n        vector<iii> changes;\n        swap1[0] = X[k]; swap1[1] = Y[k];\n        for(int i: swap1){\n            for(int j = 0; j < N; j ++){\n                if(i == j){continue;}\n                // 50% chance no swap, 50% chance got swap\n                if(i == X[k] && j == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[j][i]*HALF)%MOD));\n                }else if(j == X[k] && i == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[j][i]*HALF)%MOD));\n                }else if(i == X[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[Y[k]][j]*HALF)%MOD));\n                }else if(j == X[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[i][Y[k]]*HALF)%MOD));\n                }else if(i == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[X[k]][j]*HALF)%MOD));\n                }else if(j == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[i][X[k]]*HALF)%MOD));\n                }\n            }\n        }\n        for(int i = 0; i < N; i ++){\n            for(int j: swap1){\n                if(i == j){continue;}\n                // 50% chance no swap, 50% chance got swap\n                if(i == X[k] && j == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[j][i]*HALF)%MOD));\n                }else if(j == X[k] && i == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[j][i]*HALF)%MOD));\n                }else if(i == X[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[Y[k]][j]*HALF)%MOD));\n                }else if(j == X[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[i][Y[k]]*HALF)%MOD));\n                }else if(i == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[X[k]][j]*HALF)%MOD));\n                }else if(j == Y[k]){\n                    changes.push_back(iii(i, j, (dp[i][j]*HALF + dp[i][X[k]]*HALF)%MOD));\n                }\n            }\n        }\n        for(iii temp: changes){\n            int i = get<0>(temp);\n            int j = get<1>(temp);\n            dp[i][j] = get<2>(temp);\n        }\n    }\n\n    long long ans = 0;\n    for(int i = 0; i < N; i ++){\n        for(int j = i+1; j < N; j ++){\n            ans += dp[i][j];\n        }\n    }\n    ans %= MOD;\n    printf(\"%lld\", ans*modpow(2, Q)%MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SPEED ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define fileio freopen(\"in.in\", \"r\", stdin),freopen(\"out.out\", \"w\", stdout);\n#define ll long long int\n#define FF first\n#define SS second\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<long long int,long long int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pss printf\n#define MOD 1000000007\n#define INF 1e18\n#define eps 0.00001\n#define endl '\\n'\n#define debug(n1) cout<<n1<<endl\n\nint n,q;\nint a[3005],x[3005],y[3005];\nint nxt[3005][3005];\nint dp[2][2][3005][3005];\nint cur[3005];\nint p2[3005];\n\nint rec(int i,int l,int r,int z,int k)\n{\n\tif(i>q)\n\t\treturn (l>r);\n\tint j;\n\tint cc=(z?x[i]:y[i]);\n\tif(cc==l)\n\t\tj=r;\n\telse\n\t\tj=l;\n\tif(dp[k][z][i][j]!=-1)\n\t\treturn dp[k][z][i][j];\n\tint nt=min(nxt[l][i],nxt[r][i]);\n\tint an=(p2[nt-i-1]*1ll*rec(nt,l,r,(x[nt]==l||x[nt]==r),(x[nt]==l||y[nt]==l)))%MOD;\n\tif(x[i]==l)\n\t\tl=y[i];\n\telse if(y[i]==l)\n\t\tl=x[i];\n\tif(x[i]==r)\n\t\tr=y[i];\n\telse if(y[i]==r)\n\t\tr=x[i];\n\tnt=min(nxt[l][i],nxt[r][i]);\n\tan=(an+p2[nt-i-1]*1ll*rec(nt,l,r,(x[nt]==l||x[nt]==r),(x[nt]==l||y[nt]==l)))%MOD;\n\treturn dp[k][z][i][j]=an;\n}\n\nint main()\n{\n\tSPEED;\t\n\tmemset(dp,-1,sizeof dp);\n\tp2[0]=1;\n\tfor(int i=1;i<=3000;i++)\n\t\tp2[i]=(p2[i-1]*2ll)%MOD;\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i],cur[i]=q+1;\n\tfor(int i=1;i<=q;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(int i=q;i>=0;i--)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tnxt[j][i]=cur[j];\n\t\tcur[x[i]]=i;\n\t\tcur[y[i]]=i;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\t\n\t\t\tint nt=min(nxt[i][0],nxt[j][0]);\n\t\t\tif(a[i]<a[j])\n\t\t\t\tans=(ans+p2[nt-1]*1ll*rec(nt,i,j,(x[nt]==j||x[nt]==i),(x[nt]==i||y[nt]==i)))%MOD;\n\t\t\telse if(a[i]>a[j])\n\t\t\t\tans=(ans+p2[nt-1]*1ll*rec(nt,j,i,(x[nt]==j||x[nt]==i),(x[nt]==j||y[nt]==j)))%MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tllint gn=(mod+1)/2;\n\tint n,Q,i,j;cin>>n>>Q;\n\tstatic llint dp[3000][3000]={0};//A[前] < A[後]の確立\n\tvector<int>A(n);\n\tfor(i=0;i<n;i++){cin>>A[i];}\n\tllint k=1;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(A[i]<A[j]){dp[i][j]=1;}\n\t\t}\n\t}\n\twhile(Q--){\n\t\tk*=2;k%=mod;\n\t\tint x,y;cin>>x>>y;x--;y--;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i==x||i==y){continue;}\n\t\t\tllint w=(dp[i][x]+dp[i][y])*gn%mod;\n\t\t\tdp[i][x]=w;dp[i][y]=w;\n\t\t\tllint r=(dp[x][i]+dp[y][i])*gn%mod;\n\t\t\tdp[x][i]=r;dp[y][i]=r;\n\t\t}\n\t\tllint e=(dp[x][y]+dp[y][x])*gn%mod;\n\t\tdp[x][y]=e;dp[y][x]=e;\n\t}\n\tllint ans=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i;j++){ans+=dp[i][j];}\n\t}\n\tans%=mod;ans*=k;ans%=mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;using vci=vector<int>;using vcl=vector<ll>;template<typename T>void _dbg(const char*_s,T _h){cerr<<_s<<\" = \"<<_h<<\"\\n\";}template<typename T,typename...Ts>void _dbg(const char*_s,T _h,Ts..._t){int _b=0;while(((_b+=*_s=='(')-=*_s==')')!=0||*_s!=',')cerr<<*_s++;cerr<<\" = \"<<_h<<\",\";_dbg(_s+1,_t...);}\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\n#define int ll\n\nconst int N=3018;\nconst ll M=1e9+7;\nvoid add(ll&x,ll y){\n    if((x+=y)>=M)x-=M;\n}\nll sum(ll x, ll y){\n    add(x,y);\n    return x;\n}\nll mult(ll x,ll y){\n    return (x*y)%M;\n}\n#define sqr(x)((x)*(x))\nll bp(ll a,ll pw){ \n    ll res(1);\n    for (;pw;a=sqr(a)%M,pw /= 2)\n        if (pw & 1)\n            res=(res*a)%M;\n    return res;\n}\nll inverse(ll a){return bp(a%M,M-2);} \nint a[N];\nint p[N][N];\nint rowx[N];\nint rowy[N];\nint colx[N];\nint coly[N];\nint32_t main() {\n    int n,q;\n    cin>>n>>q;\n    for(int i=1;i<=n;++i){\n        cin>>a[i];\n    }\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=n;++j)\n            p[i][j]=(a[i]>a[j]);\n    ll r=inverse(2);\n    ll qq=bp(2,q);\n    while(q--){\n        int x,y;\n        cin>>x>>y;\n        for(int i=1;i<=n;++i){\n            rowx[i]=p[x][i];\n            rowy[i]=p[y][i];\n            colx[i]=p[i][x];\n            coly[i]=p[i][y];\n        }\n        for(int i=1;i<=n;++i){\n            p[y][i]=p[x][i]=mult(sum(rowx[i],rowy[i]),r);\n            p[i][y]=p[i][x]=mult(sum(colx[i],coly[i]),r);\n        }\n        p[x][x]=0;\n        p[y][y]=0;\n        p[x][y]=p[y][x]=mult(sum(rowx[y],rowy[x]),r);\n    }\n    ll ans=0;\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=n;++j)\n            dbg(i,j,p[i][j],inverse(p[i][j]));\n    for(int i=1;i<=n;++i)\n        for(int j=i+1;j<=n;++j)\n            add(ans,p[i][j]);\n    cout<<mult(ans,qq)<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nconst int inv2=500000004;\nint n,q;\nint f[3010][3010];\nint a[3010];\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=(a[i]>a[j]);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*inv2%Mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i!=x&&i!=y)f[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*inv2%Mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i!=x&&i!=y)f[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*inv2%Mod;\n\t}\n\tint ans=0;\n\tint mul=1;\n\tfor(int i=1;i<=q;i++)\n\t\tmul=(mul<<1)%Mod;\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(ans+f[i][j])%Mod;\n\tprintf(\"%d\\n\",1ll*ans*mul%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc030/tasks/agc030_d\n\nNが小さいな…\n→ NC2のすべての組み合わせに関して、反転する場合は何通りあるか数える？\n→クエリの数を考えたら無理じゃね？\n\n各クエリを行った場合、全ての場合での反転数の合計はどうなるかをO(N)で求める？\n→わりとありそう\n→だとしたらdpっぽい\n\n反転数 = それより右にある小さい要素の数とする\n\n反転数をうまくdp式に縮められない…\n\nnum[i][j] = A[i] > A[j]となる通り数とする。(i < j なら反転数)\n\nindex xとyが交換される場合、全てのv(!=y)に関して\n\nnum[y][v] += num[x][v]\nnum[x][v] += num[y][v]\n\nnum[v][x] += num[v][y]\nnum[v][y] += num[v][x]\n\nnum[x][y] += num[y][x]\nnum[y][x] += num[x][y]\n\n更新は高々4*3000\nなので、C++なら可能？\n\nいじらない部分は2倍する操作が必要。\n最後にまとめて処理するために、いじった部分は半分にしておく\n\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 1000000007;\nconst ll half = 500000004;\n\nint main(){\n\n    ll N,Q;\n    cin >> N >> Q;\n    vector<ll> A(N,0);\n\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<vector<ll>> lis(N,vector<ll> (N,0));\n    rep(i,0,N){\n        rep(j,0,N){\n            if (A[i] > A[j]) lis[i][j] = 1;\n        }\n    }\n\n    vector<vector<ll>> q(5*N,vector<ll> (3,0));\n    rep(loop,0,Q){\n\n        ll qind = 0;\n        ll x,y;\n        cin >> x >> y;\n        x--;\n        y--;\n\n        rep(v,0,N){\n            if ((v != x) && (v != y)){\n                q[qind++] = {y,v,lis[x][v]};\n                q[qind++] = {x,v,lis[y][v]};\n                q[qind++] = {v,y,lis[v][x]};\n                q[qind++] = {v,x,lis[v][y]}; \n            }\n        }\n\n        q[qind++] = {x,y,lis[y][x]};\n        q[qind++] = {y,x,lis[x][y]};\n\n\n\n        rep(t,0,qind){\n            ll i,j,n;\n            i = q[t][0];\n            j = q[t][1];\n            n = q[t][2];\n\n            lis[i][j] += n;\n            lis[i][j] *= half;\n            lis[i][j] %= mod;\n        }\n    }\n\n    ll ans = 0;\n    rep(j,0,N){\n        rep(i,0,j){\n            ans += lis[i][j];\n            ans %= mod;\n        }\n    }\n\n    rep(i,0,Q){\n        ans *= 2;\n        ans %= mod;\n    }\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define ll long long\nconst int MAXN = 1e5 + 7;\nconst ll p = 1e9 + 7;\nconst ll inv2 = 500000004ll;\nll n, m;\nll a[MAXN];\nstruct rec\n{\n    int x, y;\n} q[MAXN];\nll f[3500][3500];\n\ninline ll ksm(ll x, ll y)\n{\n    ll ans = 1;\n    while (y)\n    {\n        if (y & 1)\n            ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%lld%lld\", &n, &m);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lld\", &a[i]);\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        scanf(\"%lld%lld\", &q[i].x, &q[i].y);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            f[i][j] = a[i] < a[j];\n        }\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        f[q[i].x][q[i].y] = f[q[i].y][q[i].x] = inv2 * (f[q[i].x][q[i].y] + f[q[i].y][q[i].x]) % p;\n        for (int j = 1; j <= n; j++)\n        {\n            if (j != q[i].x && j != q[i].y)\n            {\n                f[j][q[i].x] = f[j][q[i].y] = inv2 * (f[j][q[i].x] + f[j][q[i].y]) % p;\n                f[q[i].y][j] = f[q[i].x][j] = inv2 * (f[q[i].y][j] + f[q[i].x][j]) % p;\n            }\n        }\n    }\n    ll ans = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j < i; j++)\n        {\n            ans += f[i][j];\n        }\n    }\n    printf(\"%lld\", ans % p * ksm(2, m) % p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005, mod = 1000000007;\n\nint n, m, a[maxn];\nll f[maxn][maxn];\n\nll qpow(ll x, int y)\n{\n\tll ret = 1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tret = ret * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\t\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tf[i][j] = (a[i] > a[j]);\n\tint u, v, inv2 = qpow(2, mod - 2);\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tif(u > v)\tswap(u, v);\n\t\tf[u][v] = f[v][u] = inv2 * (f[u][v] + f[v][u]) % mod;\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(j != u && j != v)\n\t\t\t{\n\t\t\t\tf[j][u] = f[j][v] = inv2 * (f[j][u] + f[j][v]) % mod;\n\t\t\t\tf[u][j] = f[v][j] = inv2 * (f[u][j] + f[v][j]) % mod;\n\t\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tans = (ans + f[i][j]) % mod;\n\tprintf(\"%lld\", ans * qpow(2, m) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\n\nconst int maxN=3010;\nconst int Mod=1e9+7;\nconst int inv2=500000004;\n\nint n,Q,Seq[maxN];\nint F[maxN][maxN],G[maxN][maxN];\n\nvoid Plus(int &x,int y);\nvoid Outp();\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&Q);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&Seq[i]);\n    for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) F[i][j]=Seq[i]<Seq[j];\n    for (int qi=1;qi<=Q;qi++){\n        int x,y;scanf(\"%d%d\",&x,&y);\n        if (x==y) continue;\n        for (int i=1;i<=n;i++) if (i!=y&&i!=x){\n            Plus(G[i][x],1ll*F[i][x]*inv2%Mod);Plus(G[i][y],1ll*F[i][x]*inv2%Mod);\n            Plus(G[x][i],1ll*F[x][i]*inv2%Mod);Plus(G[y][i],1ll*F[x][i]*inv2%Mod);\n        }\n        for (int i=1;i<=n;i++) if (i!=x&&i!=y){\n            Plus(G[i][y],1ll*F[i][y]*inv2%Mod);Plus(G[i][x],1ll*F[i][y]*inv2%Mod);\n            Plus(G[y][i],1ll*F[y][i]*inv2%Mod);Plus(G[x][i],1ll*F[y][i]*inv2%Mod);\n        }\n        G[y][x]=G[x][y]=1ll*(F[x][y]+F[y][x])%Mod*inv2%Mod;\n        for (int i=1;i<=n;i++) F[x][i]=G[x][i],F[i][x]=G[i][x],F[y][i]=G[y][i],F[i][y]=G[i][y];\n        for (int i=1;i<=n;i++) G[x][i]=G[i][x]=G[y][i]=G[i][y]=0;\n        //cout<<\"after \"<<qi<<endl;\n        //Outp();\n    }\n    int Ans=0;\n    for (int i=1;i<=n;i++) for (int j=1;j<i;j++) Plus(Ans,F[i][j]);\n    for (int i=1;i<=Q;i++) Ans=2ll*Ans%Mod;\n    printf(\"%d\\n\",Ans);return 0;\n}\nvoid Plus(int &x,int y){\n    x+=y;if (x>=Mod) x-=Mod;return;\n}\nvoid Outp(){\n    for (int i=1;i<=n;i++){\n        for (int j=1;j<=n;j++)\n            cout<<F[i][j]<<\" \";cout<<endl;\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define o 1000005\n#define re register int\n#define ll long long\n#define g0(a) memset(a,0,sizeof(a))\n#define gc(a,b) memcpy(a,b,sizeof(a))\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(i,a,b) for(int i=a;i>=b;i--)\n#define pa pair<int,int>\n#define mpp make_pair\n#define s1 first\n#define s2 second\n#define go(x) for(ll i=h[x];i;i=w[i].next)\nusing namespace std;\ninline int read()\n{\n\tregister int data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();\n\treturn data*w;\n}\nint n,a[o],Q,f[3005][3005];\nconst int mod=1e9+7,iv=(mod+1)>>1;\nvoid fix(int x){\n\tx-=mod;x+=x>>31&mod;\n}\nint main()\n{\n\tn=read();Q=read();\n\tFOR(i,1,n)a[i]=read();\n\tFOR(i,1,n)FOR(j,1,n)if(a[i]>a[j])f[i][j]=1;\n\tint s=1;\n\twhile(Q--)\n\t{\n\t\tfix(s+=s);\n\t\tint x=read(),y=read();\n\t\tFOR(i,1,n)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=1ll*(f[x][i]+f[y][i])*iv%mod;\n\t\t\tf[i][x]=f[i][y]=1ll*(f[i][x]+f[i][y])*iv%mod;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%p;\n\t}\n\tint ans=0;\n\tFOR(i,1,n)FOR(j,i+1,n)ans=(ans+f[i][j])%mod;\n\tcout<<1ll*ans*s%mod<<'\\n'; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define inf (0x3f3f3f3f)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define Rep(i, a) for (int i = 0; i < a; ++ i)\n#define For(i, a, b) for (int i = a; i <= b; ++ i)\n#define Forr(i, a, b) for (int i = a; i >= b; -- i)\n#define Travel(i, x) for (int i = head[x]; i; i = nxt[i])\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\ntemplate<class T>inline T read(T &_) {\n\tT __ = getchar(), ___ = 1; _ = 0;\n\tfor (; !isdigit(__); __ = getchar()) if (__ == '-') ___ = -1;\n\tfor (; isdigit(__); __ = getchar()) _ = (_ << 3) + (_ << 1) + (__ ^ 48);\n\treturn _ *= ___;\n}\n\ntemplate<class T>inline bool chkmax(T &_, T __) { return _ < __ ? _ = __, 1 : 0; }\ntemplate<class T>inline bool chkmin(T &_, T __) { return _ > __ ? _ = __, 1 : 0; }\n\ninline void proStatus() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>());\n}\n\nconst int N = 3000 + 3;\nconst int mod = 1e9 + 7;\n\nint qpow(int a, int x) { \n\tint ret = 1; \n\twhile (x) {\n\t\tif (x & 1) ret = ret * (ll)a % mod;\n\t\tx >>= 1, a = a * (ll)a % mod;\n\t}\n\treturn ret; \n}\n\nint f[N][N], a[N], ans;\n\nint main() {\n\tint n, q, x, y;\n\n\tread(n), read(q);\n\tFor(i, 1, n) read(a[i]);\n\tFor(i, 1, n) For(j, 1, n) f[i][j] = a[i] < a[j];\n\n\tFor(cas, 1, q) { \n\t\tread(x), read(y);\n\t\tf[x][y] = f[y][x] = 500000004ll * (f[x][y] + f[y][x]) % mod;\n\t\tFor(i, 1, n) if (i ^ x && i ^ y) {\n\t\t\tf[x][i] = f[y][i] = 500000004ll * (f[x][i] + f[y][i]) % mod;\n\t\t\tf[i][x] = f[i][y] = 500000004ll * (f[i][x] + f[i][y]) % mod;\n\t\t}\n\t}\n\n\tFor(i, 1, n) For(j, i + 1, n) (ans += f[j][i]) %= mod;\n\tcout << 1ll * ans * qpow(2, q) % mod << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mk make_pair\n#define ll long long\n#define int long long\n\nusing namespace std;\n\nconst int maxn = 3010;\nconst int mod = 1e9+7;\n\nint qsm(int i,int j)\n{\n\tint ans=1;\n\twhile (j)\n\t{\n\t\tif (j&1) ans=ans*i%mod;\n\t\tj>>=1;\n\t    i=i*i%mod;\n\t}\n\treturn ans;\n}\n\nint dp[maxn][maxn];\nint n,m;\nint q;\nint a[maxn];\n\nsigned main()\n{\n   scanf(\"%lld%lld\",&n,&m);\n   for (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);//a[i]=read();\n   for (int i=1;i<=n;i++)\n     for (int j=1;j<=n;j++)\n       dp[i][j]=(a[i]>a[j]);\n   int inv = qsm(2,mod-2);\n   for (int i=1;i<=m;i++)\n   {\n   \t  int x,y;\n   \t  scanf(\"%lld%lld\",&x,&y);\n   \t  dp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv%mod;\n   \t  for (int i=1;i<=n;i++)\n   \t  {\n   \t  \tif (i!=x && i!=y)\n   \t  \t{\n   \t  \t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*inv%mod;\n   \t  \t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*inv%mod;\n\t\t}\n\t  }\n   }\n   int ans=0;\n   for (int i=1;i<=n;i++)\n     for (int j=i+1;j<=n;j++)\n        ans=(ans+dp[i][j])%mod;\n   cout<<ans*qsm(2,m)%mod;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint a[4096];\nint dp[3005][3005];\nint dp2[3005][3005];\nint main()\n{\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(a[i]>a[j])\n\t\t\t{\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int __=0;__<q;__++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y)\n\t\t{\n\t\t\tint t=x;\n\t\t\tx=y;\n\t\t\ty=t;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i!=x&&i!=y)\n\t\t\t\t{\n\t\t\t\t\tif(j<=x)\n\t\t\t\t\t{\n\t\t\t\t\t\tj=x;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j<=y)\n\t\t\t\t\t{\n\t\t\t\t\t\tj=y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ii=i,jj=j;\n\t\t\t\tif(ii==x)\n\t\t\t\t{\n\t\t\t\t\tii=y;\n\t\t\t\t}\n\t\t\t\telse if(ii==y)\n\t\t\t\t{\n\t\t\t\t\tii=x;\n\t\t\t\t}\n\t\t\t\tif(jj==x)\n\t\t\t\t{\n\t\t\t\t\tjj=y;\n\t\t\t\t}\n\t\t\t\telse if(jj==y)\n\t\t\t\t{\n\t\t\t\t\tjj=x;\n\t\t\t\t}\n\t\t\t\tdp2[i][j]=dp[ii][jj];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(i!=x&&i!=y)\n\t\t\t\t{\n\t\t\t\t\tif(j<=x)\n\t\t\t\t\t{\n\t\t\t\t\t\tj=x;\n\t\t\t\t\t}\n\t\t\t\t\telse if(j<=y)\n\t\t\t\t\t{\n\t\t\t\t\t\tj=y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j]+=dp2[i][j];\n\t\t\t\tif(dp[i][j]>=1000000007)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]-=1000000007;\n\t\t\t\t}\n\t\t\t\tdp[i][j]=(long long)dp[i][j]*500000004%1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tans+=dp[i][j];\n\t\t\tif(ans>=1000000007)\n\t\t\t{\n\t\t\t\tans-=1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tans<<=1;\n\t\tif(ans>=1000000007)\n\t\t{\n\t\t\tans-=1000000007;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e3+10;\nconst int mod=1e9+7,inv2=(mod+1)/2;\nint n,m;\nint dp[maxn][maxn],val[maxn],tot=1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&val[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)if(i!=j)dp[i][j]=val[i]<val[j];\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*1LL*inv2%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*1LL*inv2%mod;\n\t\t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*1LL*inv2%mod;\n\t\t}\n\t\ttot=tot*1LL*2%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<i;j++)ans+=dp[i][j]*1LL*tot%mod,ans%=mod;\n\tprintf(\"%d\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\nconst int mod=1e9+7;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,m,dp[3001][3001],a[3001],mem[3001][4];\ninline int ksm(int A,int B)\n{\n\tA%=mod;\n\tint C=1;\n\twhile(B)\n\t{\n\t\tif(B%2)\n\t\t\tC=1ll*C*A%mod;\n\t\tA=1ll*A*A%mod;\n\t\tB/=2;\n\t}\n\treturn C;\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\ta[i]=read();\n\tint half=ksm(2,mod-2);\n\tfor(register int i=1;i<=n;++i)\n\t\tfor(register int j=1;j<=n;++j)\n\t\t\tdp[i][j]=(a[i]>a[j]);\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\tint x=read(),y=read();\n\t\tif(x>y)\n\t\t\tswap(x,y);\n\t\tfor(register int j=1;j<=n;++j)\n\t\t{\n\t\t\tmem[j][0]=dp[j][x];\n\t\t\tmem[j][1]=dp[x][j];\n\t\t\tmem[j][2]=dp[j][y];\n\t\t\tmem[j][3]=dp[y][j];\n\t\t}\n\t\tdp[x][y]=dp[y][x]=1ll*(mem[x][2]+mem[x][3])%mod*half%mod;\n\t\tfor(register int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(j==x || j==y)\n\t\t\t\tcontinue;\n\t\t\tdp[j][x]=dp[j][y]=1ll*(mem[j][0]+mem[j][2])%mod*half%mod;\n\t\t\tdp[x][j]=dp[y][j]=1ll*(mem[j][1]+mem[j][3])%mod*half%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(register int i=1;i<=n;++i)\n\t\tfor(register int j=i+1;j<=n;++j)\n\t\t\tans=(ans+dp[i][j])%mod;\n\tprintf(\"%lld\\n\",1ll*ans*ksm(2,m)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nint n, q, mod = 1e9 + 7;\nvector <int> a;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int d2 = 500000004;\n    cin >> n >> q;\n    a.resize(n);\n    for(auto &i : a) cin >> i;\n    vector <vector <int> > p(n, vector <int>(n));\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < n ; j++){\n            p[i][j] = a[i] > a[j];\n        }\n    }\n    int g = 1;\n    while(q--){\n        g = 2 * g % mod;\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        for(int i = 0 ; i < n ; i++){\n            if(i == x || i == y) continue;\n            int cur = 1LL * (p[x][i] + p[y][i]) * d2 % mod;\n            p[x][i] = p[y][i] = cur;\n            cur = 1LL * (p[i][x] + p[i][y]) * d2 % mod;\n            p[i][x] = p[i][y] = cur;\n        }\n        int cur = 1LL * (p[x][y] + p[y][x]) * d2 % mod;\n        p[x][y] = p[y][x] = cur;\n    }\n    int ans = 0;\n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < i ; j++){\n            ans += p[j][i];\n            if(ans >= mod) ans -= mod;\n        }\n    }\n    ans = 1LL * ans * g % mod;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int MN = 3010;\n\nint N, Q;\nint A[MN], X[MN], Y[MN], prec[MN][MN], po[MN];\nvector<int> V[MN];\n\nint cc[MN][MN][2][2];\nint dp(int q, int a, int x, int t) {\n    int &ret = cc[q][a][x][t];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    int b = x? X[q] : Y[q];\n    if(t) swap(a, b);\n\n    int pa = prec[a][q];\n    int pb = prec[b][q];\n    if(V[a][pa] == Q && V[b][pb] == Q) {\n        ret += 1LL * po[Q - q - 1] * (a < b) % mod;\n    }\n    else if(V[a][pa] < V[b][pb]) {\n        int nq = V[a][pa];\n        ret += 1LL * po[nq - q - 1] * dp(nq, b, X[nq] == a, 1) % mod;\n    }\n    else {\n        int nq = V[b][pb];\n        ret += 1LL * po[nq - q - 1] * dp(nq, a, X[nq] == b, 0) % mod;\n    }\n\n    a = a == X[q]? Y[q] : (a == Y[q]? X[q] : a);\n    b = b == X[q]? Y[q] : (b == Y[q]? X[q] : b);\n\n    pa = prec[a][q];\n    pb = prec[b][q];\n    if(V[a][pa] == Q && V[b][pb] == Q) {\n        ret += 1LL * po[Q - q - 1] * (a < b) % mod;\n    }\n    else if(V[a][pa] < V[b][pb]) {\n        int nq = V[a][pa];\n        ret += 1LL * po[nq - q - 1] * dp(nq, b, X[nq] == a, 1) % mod;\n    }\n    else {\n        int nq = V[b][pb];\n        ret += 1LL * po[nq - q - 1] * dp(nq, a, X[nq] == b, 0) % mod;\n    }\n    return ret %= mod;\n}\n\nint main() {\n    po[0] = 1;\n    for(int i = 1; i < MN; i++) {\n        po[i] = 1LL * po[i - 1] * 2 % mod;\n    }\n\n    scanf(\"%d %d\", &N, &Q);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n        X[i]--; Y[i]--;\n\n        V[ X[i] ].push_back(i);\n        V[ Y[i] ].push_back(i);\n    }\n    for(int i = 0; i < N; i++) {\n        V[i].push_back(Q);\n    }\n\n    for(int i = 0; i < N; i++) {\n        int pos = 0;\n        for(int j = 0; j < Q; j++) {\n            if(pos < V[i].size() && V[i][pos] <= j) pos++;\n            prec[i][j] = pos;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n\n    int ans = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(A[j] < A[i]) {\n                if(V[i][0] == Q && V[j][0] == Q) {\n                    ans += 1LL * po[Q] * (i < j) % mod;\n                    ans %= mod;\n                    continue;\n                }\n                if(V[i][0] < V[j][0]) {\n                    int q = V[i][0];\n                    ans += 1LL * po[q] * dp(q, j, X[q] == i, 1) % mod;\n                    ans %= mod;\n                }\n                else {\n                    int q = V[j][0];\n                    ans += 1LL * po[q] * dp(q, i, X[q] == j, 0) % mod;\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    printf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n\tint x;\n\tModInt(): x(0) {}\n\tModInt(i64 a) { x = a % mod; if (x < 0) x += mod; }\n\tModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n\tModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n\tModInt &operator*=(ModInt that) { x = (i64) x * that.x % mod; return *this; }\n\tModInt &operator/=(ModInt that) { return *this *= power(that, mod - 2); }\n\t#define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n\t\top(+, +=) op(-, -=) op(*, *=) op(/, /=)\n\t#undef op\n\tfriend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n};\n\nusing mint = ModInt<1000000007>;\n\nmint dp[3010][3010];\n\nvoid solve() {\n\tint N, Q; cin >> N >> Q;\n\tvi32 a(N); cin >> a;\n\trep(i, N) rep(j, N) dp[i][j] = a[i] > a[j];\n\trep(j, Q) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\trep(i, N) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[i][x] = dp[i][y] = (dp[i][x] + dp[i][y]) / 2;\n\t\t\tdp[x][i] = dp[y][i] = (dp[x][i] + dp[y][i]) / 2;\n\t\t}\n\t\tdp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) / 2;\n\t}\n\tmint ans = 0;\n\trep(j, N) rep(i, j) ans += dp[i][j];\n\tans = ans * power((mint) 2, Q);\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=3005,INF=1<<30;\nll dp[MAX][MAX],last[MAX][MAX];\nll rui[MAX];\n\nvoid make(){\n    rui[0]=1;\n    for(int i=1;i<MAX;i++){\n        rui[i]=rui[i-1]*2%mod;\n    }\n}\n\nvoid update(int i,int j,int t){\n    dp[i][j]*=rui[(t-last[i][j])];\n    dp[i][j]%=mod;\n    \n    last[i][j]=t+1;\n    \n    return;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    int N,Q;cin>>N>>Q;\n    vector<int> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            if(A[i]>A[j]) dp[i][j]=1;\n        }\n    }\n    \n    for(int q=0;q<Q;q++){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        if(a>b) swap(a,b);\n        \n        for(int i=0;i<N;i++){\n            if(i==a||i==b) continue;\n            update(i,a,q);\n            update(i,b,q);\n            ll s=dp[i][a]+dp[i][b];\n            \n            dp[i][a]=s;\n            dp[i][b]=s;\n        }\n        \n        for(int j=0;j<N;j++){\n            if(j==a||j==b) continue;\n            update(a,j,q);\n            update(b,j,q);\n            ll s=dp[a][j]+dp[b][j];\n            \n            dp[a][j]=s;\n            dp[b][j]=s;\n        }\n        \n        update(a,b,q);\n        update(b,a,q);\n        \n        ll s=dp[a][b]+dp[b][a];\n        \n        dp[a][b]=s;\n        dp[b][a]=s;\n        \n    }\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            update(i,j,Q);\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            ans+=dp[i][j];\n            ans%=mod;\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1e9 + 7;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (long long) x * y % md;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  vector<vector<int>> f(n, vector<int> (n));\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      f[i][j] = a[i] > a[j];\n    }\n  }\n  int coef = 1;\n  while (m--) {\n    coef = mul(coef, 2);\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    --x;\n    --y;\n    f[x][y] = f[y][x] = mul(f[x][y] + f[y][x], md + 1 >> 1);\n    for (int i = 0; i < n; ++i) {\n      if (i != x && i != y) {\n        f[i][x] = f[i][y] = mul(f[i][x] + f[i][y], md + 1 >> 1);\n        f[x][i] = f[y][i] = mul(f[x][i] + f[y][i], md + 1 >> 1);\n      }\n    }\n  }\n  int answer = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      add(answer, f[i][j]);\n    }\n  }\n  printf(\"%d\\n\", mul(answer, coef));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 3010, P = 1e9 + 7, I2 = (P + 1) / 2;\n\nint n, q, A[N], f[N][N], pw[N], ans;\n\nint main() {\n  scanf(\"%d %d\", &n, &q);\n  for (int i = 1; i <= n; ++i)\n    scanf(\"%d\", A + i);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j)\n      if (i != j)\n        f[i][j] = A[i] < A[j];\n  for (int i = 1; i <= q; ++i) {\n    int x, y; scanf(\"%d %d\", &x, &y);\n    f[x][y] = f[y][x] = 1ll * (f[x][y] + f[y][x]) * I2 % P;\n    for (int j = 1; j <= n; ++j)\n      if (j != x && j != y) {\n        f[j][x] = f[j][y] = 1ll * (f[j][x] + f[j][y]) * I2 % P;\n        f[x][j] = f[y][j] = 1ll * (f[x][j] + f[y][j]) * I2 % P;\n      }\n  }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j < i; ++j)\n      ans = (ans + f[i][j]) % P;\n  for (int i = 1; i <= q; ++i)\n    ans = ans * 2 % P;\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\ntemplate<int mod>\nstruct ModInt{\n\tint v;\n\tModInt():v(0){}\n\tModInt(int vv):v((vv%mod+mod)%mod){}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv*=rhs.v;\n\t\tv%=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\nusing mint=ModInt<1000000007>;\n\nconst int Vmax=2000010;\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nconst int Nmax=3010;\nmint dp[Nmax][Nmax];\n\nsigned main(){\n\tint n=read(),q=read();\n\tvi a(n);\n\tREP(i,n)\n\t\ta[i]=read();\n\tmint inv2=mint(2).inv();\n\tREP(i,n)REP(j,n)\n\t\tif(a[i]>a[j])\n\t\t\tdp[i][j]+=1;\n\tREP(_,q){\n\t\tint x=read()-1,y=read()-1;\n\t\tREP(i,n)if(i!=x&&i!=y){\n\t\t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*inv2;\n\t\t}\n\t\tREP(i,n)if(i!=x&&i!=y){\n\t\t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*inv2;\n\t\t}\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv2;\n\t}\n\tmint ans=0;\n\tREP(i,n)FOR(j,i+1,n){\n\t\tans+=dp[i][j];\n\t}\n\tprint(ans*mint(2).pow(q));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <unistd.h>\n#include <ctime>\n#include <queue>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 3005, MOD = 1e9 + 7;\n\nint add(int a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n  return a;\n}\n\nint sub(int a, int b) {\n  a -= b;\n  if (a < 0) a += MOD;\n  return a;\n}\n\nint mul(int a, int b) {\n  return (int) (((ll) a * b) % MOD);\n}\n\nint eksp(int b, int e) {\n  int r=1;\n  for (; e; e/=2, b=mul(b, b))\n    if (e & 1) r = mul(r, b);\n  return r;\n}\n\nint invv(int x) {\n  return eksp(x, MOD-2);\n}\n\nint n, q;\nint dp[MAX][MAX];\nint p[MAX];\n//double dp[MAX][MAX];\nint inv2;\n\nint main()\n{\n  inv2 = invv(2);\n  scanf(\"%d%d\", &n, &q);\n  //n = q = 3000;\n\n  REP(i, n) {\n    scanf(\"%d\", &p[i]); p[i]--;\n    //    p[i] = rand() % 1000;\n  }\n\n  REP(i, n) REP(j, n) {\n    dp[i][j] = p[i] > p[j];\n  }\n\n  REP(qq, q) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b); a--; b--;\n    // a = rand() % n;\n    // b = rand() % n;\n    //    dp[a][b] = dp[b][a] = mul(inv2, sub(1, isti[a][b]));\n    dp[a][b] = dp[b][a] = mul(inv2, add(dp[a][b], dp[b][a]));\n\n    REP(i, n) {\n      if (i == a || i == b) continue;\n\n      dp[a][i] = dp[b][i] = mul(inv2, add(dp[a][i], dp[b][i]));\n      dp[i][a] = dp[i][b] = mul(inv2, add(dp[i][a], dp[i][b]));\n    }\n  }\n\n\n  int sol = 0;\n  REP(i, n) FOR(j, i+1, n)\n    sol = add(sol, dp[i][j]);\n\n  // REP(i, n) {\n  //   FOR(j, i+1, n) printf(\"%d \", mul(eksp(2, q), dp[i][j]));\n  //   printf(\"\\n\");\n  // }\n\n  sol = mul(sol, eksp(2, q));\n\n  printf(\"%d\\n\", sol);    \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\nusing namespace std;\nconst int nmax=3005;\nconst long long mod=1000*1000*1000+7;\nlong long dp[nmax][nmax],lzy[nmax][nmax],old[nmax][nmax];\nint a[nmax];\nlong long inv2,I2,ans,p2;\nint n,i,j,q,x,y;\nlong long mu(long long x,long long y)\n{\n    return (1LL*x*y)%mod;\n}\nint main()\n{\n    //freopen(\"data.in\",\"r\",stdin);\n    cin>>n>>q;\n    for(i=1;i<=n;i++)\n        cin>>a[i];\n    for(i=1;i<=n;i++)\n        for(j=i+1;j<=n;j++)\n           dp[i][j]=1;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n          lzy[i][j]=1;\n    inv2=(mod+1)/2;I2=inv2;\n    p2=1;\n    for(int cnt=1;cnt<=q;cnt++)\n    {\n        cin>>x>>y;\n        for(i=1;i<=n;i++)\n        {\n            old[i][x]=(dp[i][x]*mu(lzy[i][x],p2))%mod;\n            old[x][i]=(dp[x][i]*mu(lzy[x][i],p2))%mod;\n            old[i][y]=(dp[i][y]*mu(lzy[i][y],p2))%mod;;\n            old[y][i]=(dp[y][i]*mu(lzy[y][i],p2))%mod;\n        }\n        for(i=1;i<=n;i++)\n        {\n            lzy[i][x]=I2;\n            lzy[x][i]=I2;\n            lzy[i][y]=I2;\n            lzy[y][i]=I2;\n        }\n        lzy[x][x]=lzy[y][y]=0;\n        for(i=1;i<=n;i++)\n        {\n            dp[i][x]=(old[i][y]+old[i][x])%mod;\n            dp[i][y]=(old[i][x]+old[i][y])%mod;\n            dp[x][i]=(old[y][i]+old[x][i])%mod;\n            dp[y][i]=(old[x][i]+old[y][i])%mod;\n        }\n        dp[x][y]=(old[x][y]+old[y][x])%mod;\n        dp[y][x]=(old[x][y]+old[y][x])%mod;\n        dp[x][x]=dp[y][y]=0;\n        p2=(p2+p2)%mod;\n        I2=(I2*inv2)%mod;\n    }\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n          if(a[i]>a[j])\n    {\n        ans+=((1LL*(dp[i][j]*p2)%mod)*lzy[i][j])%mod;\n        ans%=mod;\n        //cout<<a[i]<<' '<<a[j]<<' '<<ans<<' '<<dp[i][j]<<' '<<lzy[i][j]<<'\\n';\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n \n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\nint div2(int x) {\n\tif (x & 1) x += MOD;\n\treturn x / 2;\n}\n \nconst int N = 3030;\nint a[N];\nint xs[N];\nint n, m, k;\nint b[N][2];\nint c[N], d[N];\nint ans;\n \nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n \n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\txs[i] = a[i];\n\t}\n\tsort(xs, xs + n);\n\tk = unique(xs, xs + n) - xs;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = lower_bound(xs, xs + k, a[i]) - xs;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tb[i][j]--;\n\t\t}\n\tfor (int it = k - 1; it >= 0; it--) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[i] = (int)(a[i] == it);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x = div2(add(c[b[i][0]], c[b[i][1]]));\n\t\t\tc[b[i][0]] = c[b[i][1]] = x;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = add(ans, mult(sum, c[i]));\n\t\t\tans = add(ans, div2(mult(c[i], d[i])));\n\t\t\tsum = add(sum, d[i]);\n\t\t\td[i] = add(d[i], c[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tans = add(ans, ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<cstdio>\n    #include<cstdlib>\n    #include<ctime>\n    #include<cctype>\n    #include<algorithm>\n    #include<cstring>\n    #include<iomanip>\n    #include<queue>\n    #include<map>\n    #include<set>\n    #include<bitset>\n    #include<stack>\n    #include<vector>\n    #include<cmath>\n    #define ld long double\n    //This code is written by Itst\n    using namespace std;\n     \n    inline int read(){\n        int a = 0;\n        char c = getchar();\n        bool f = 0;\n        while(!isdigit(c) && c != EOF){\n            if(c == '-')\n                f = 1;\n            c = getchar();\n        }\n        if(c == EOF)\n            exit(0);\n        while(isdigit(c)){\n            a = a * 10 + c - 48;\n            c = getchar();\n        }\n        return f ? -a : a;\n    }\n     \n    const int MOD = 1e9 + 7 , inv2 = 5e8 + 4;\n    long long dp[3007][3007];\n    int num[3007] , N , M;\n     \n    int main(){\n        N = read();\n        M = read();\n        for(int i = 1 ; i <= N ; ++i)\n            num[i] = read();\n        for(int i = 1 ; i <= N ; ++i)\n            for(int j = i - 1 ; j ; --j){\n                dp[i][j] = num[i] > num[j];\n                dp[j][i] = num[j] > num[i];\n            }\n        for(int i = 1 ; i <= M ; ++i){\n            int a = read() , b = read();\n            for(int j = 1 ; j <= N ; ++j)\n                if(j != a && j != b){\n                    dp[j][a] = dp[j][b] = (dp[j][a] + dp[j][b]) * inv2 % MOD;\n                    dp[a][j] = dp[b][j] = (dp[a][j] + dp[b][j]) * inv2 % MOD;\n                }\n            dp[a][b] = dp[b][a] = (dp[a][b] + dp[b][a]) * inv2 % MOD;\n        }\n        long long sum = 0;\n        for(int i = 1 ; i <= N ; ++i)\n            for(int j = i - 1 ; j ; --j)\n                sum = (sum + dp[j][i]) % MOD;\n      \tfor(int i = 1 ; i <= M ; ++i)\n          sum = sum * 2 % MOD;\n        cout << sum;\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nconst int div2 = (mod + 1) / 2;\n\nint n , m , a[maxn];\nint dp[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> m;\n    for(int i = 1 ; i <= n ; ++i)cin >> a[i];\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 1 ; j <= n ; ++j){\n            dp[i][j] = (a[i] > a[j]);\n        }\n    }\n    int p = 1;\n    while(m--){\n        p = p * 2 % mod;\n        int i , j;cin >> i >> j;\n        dp[i][j] = dp[j][i] = (ll)(dp[i][j] + dp[j][i]) * div2 % mod;\n        for(int t = 1 ; t <= n ; ++t){\n            if(i == t || j == t)continue;\n            dp[i][t] = dp[j][t] = (ll)(dp[i][t] + dp[j][t]) * div2 % mod;\n            dp[t][i] = dp[t][j] = (ll)(dp[t][i] + dp[t][j]) * div2 % mod;\n        }\n    }\n    int res = 0;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = i ; j <= n ; ++j){\n            res += dp[i][j];\n            if(res>=mod)res -= mod;\n        }\n    }\n    cout << (ll)res * p % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nconst int mod = 1000000007;\n\nint now[3333][3333];\nint pre[3333][3333];\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> a(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif(a[i] > a[j]) {\n\t\t\t\tnow[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow[i][j] = 0;\n\t\t\t}\n\t\t\tpre[i][j] = -1;\n\t\t}\n\t}\n\tvector<int> kai(q + 10);\n\tint nw = 1;\n\trep(i, q + 9) {\n\t\tkai[i + 1] = nw;\n\t\tnw = nw * 2 % mod;\n\t}\n\trep(i, q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tvector<pair<int, pair<int, int>>> q;\n\t\trep(j, n) {\n\t\t\tif(j != x && j != y) {\n\t\t\t\tq.push_back(make_pair(now[j][x] * kai[i - pre[j][x]], make_pair(j, y)));\n\t\t\t\tq.push_back(make_pair(now[j][y] * kai[i - pre[j][y]], make_pair(j, x)));\n\t\t\t\tq.push_back(make_pair(now[x][j] * kai[i - pre[x][j]], make_pair(y, j)));\n\t\t\t\tq.push_back(make_pair(now[y][j] * kai[i - pre[y][j]], make_pair(x, j)));\n\t\t\t}\n\t\t}\n\t\tq.push_back(make_pair(now[x][x] * kai[i - pre[x][x]], make_pair(y, y)));\n\t\tq.push_back(make_pair(now[x][y] * kai[i - pre[x][y]], make_pair(y, x)));\n\t\tq.push_back(make_pair(now[y][x] * kai[i - pre[y][x]], make_pair(x, y)));\n\t\tq.push_back(make_pair(now[y][y] * kai[i - pre[y][y]], make_pair(x, x)));\n\t\tfor(auto j: q) {\n\t\t\tnow[j.second.first][j.second.second] = (now[j.second.first][j.second.second] * kai[i - pre[j.second.first][j.second.second]] + j.first) % mod;\n\t\t\tpre[j.second.first][j.second.second] = i;\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tans = (ans + now[i][j] * kai[q - pre[i][j]]) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=3000;\nconst int MAXSWAP=3000;\nconst int MOD=1000000007;\nconst int INV2=(MOD+1)/2;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\nint combine(int a,int b) { return (ll)(a+b)*INV2%MOD; }\n\nint n,nswap;\nint sval[MAXN];\nint swapidx[MAXSWAP][2];\n\nint pless[MAXN][MAXN];\nint acpy[2][MAXN];\nint bcpy[2][MAXN];\n\nint solve() {\n\tREP(i,n) REP(j,n) pless[i][j]=sval[i]<sval[j]?1:0;\n\tREP(k,nswap) {\n\t\tint a=swapidx[k][0],b=swapidx[k][1];\n\t\tREP(i,n) acpy[0][i]=pless[a][i],acpy[1][i]=pless[i][a];\n\t\tREP(i,n) bcpy[0][i]=pless[b][i],bcpy[1][i]=pless[i][b];\n\t\tpless[a][b]=pless[b][a]=combine(acpy[0][b],bcpy[0][a]);\n\t\tREP(j,n) if(j!=a&&j!=b) pless[a][j]=pless[b][j]=combine(acpy[0][j],bcpy[0][j]);\n\t\tREP(i,n) if(i!=a&&i!=b) pless[i][a]=pless[i][b]=combine(acpy[1][i],bcpy[1][i]);\n\t}\n\tint ret=0; REP(i,n) FOR(j,i+1,n) inc(ret,pless[j][i]); REP(i,nswap) ret=(ll)ret*2%MOD; return ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&nswap);\n\tREP(i,n) scanf(\"%d\",&sval[i]);\n\tREP(i,nswap) REP(j,2) scanf(\"%d\",&swapidx[i][j]),--swapidx[i][j];\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int MOD = 1e9 + 7, N = 3333;\n\nint n, Q, pw[N], a[N], bel[N][N];\nvector<int> op[N], cp[N];\nlong long ans;\n\nvoid Solve(int cur, int x, int y, int val) {\n  //cerr << cur << \" \" << x << \" \" << y << \" \" << val << endl;\n  int indx = bel[x][cur];\n  int indy = bel[y][cur];\n  \n  /* assert(indx == lower_bound(op[x].begin(), op[x].end(), cur) - op[x].begin());\n  assert(indy == lower_bound(op[y].begin(), op[y].end(), cur) - op[y].begin());\n  \n  cerr << indx << \" \" << indy << endl;\n*/\n  if(indx == op[x].size() && indy == op[y].size()) {\n    ans = (ans + 1LL * (x > y) * val * pw[Q + 1 - cur] % MOD) % MOD;\n    return;\n  }\n  //cerr << indx << \" \" << indy << endl;\n  int ix = indx == op[x].size() ? n + 1 : op[x][indx];\n  int iy = indy == op[y].size() ? n + 1 : op[y][indy];\n  //cerr << ix << \" \" << iy << endl;\n  if(ix < iy) {\n    val = 1LL * val * pw[ix - cur];\n    Solve(ix + 1, x, y, val);\n    //assert(indx < cp[x].size());\n    //cerr << cp[x][ind[x] << endl;\n    x = cp[x][indx];\n    Solve(ix + 1, x, y, val);\n  } else if(ix > iy) {\n    val = 1LL * val * pw[iy - cur];\n    Solve(iy + 1, x, y, val);\n    //assert(indy < cp[y].size());\n    y = cp[y][indy];\n    Solve(iy + 1, x, y, val);\n  } else {\n    val = 1LL * val * pw[iy - cur];\n    Solve(iy + 1, x, y, val);\n    //assert(indy < cp[x].size());\n    x = cp[x][indx];\n    y = cp[y][indy];\n    Solve(iy + 1, x, y, val);\n  }\n}\n\nmain(void) {\n  scanf(\"%lld%lld\", &n, &Q);\n  pw[0] = 1;\n  for(int i = 1; i <= Q; i++) {\n    pw[i] = pw[i - 1] * 2 % MOD;\n  }\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n  }\n  for(int i = 1, x, y; i <= Q; i++) {\n    scanf(\"%lld%lld\", &x, &y);\n    op[x].push_back(i);\n    cp[x].push_back(y);\n    op[y].push_back(i);\n    cp[y].push_back(x);\n  }\n  for(int i = 1; i <= n; i++) {\n    int k = 1;\n    for(int j = 0; j < op[i].size(); j++) {\n      while(k <= op[i][j]) {\n\tbel[i][k] = j;\n\tk++;\n      }\n    }\n    while(k <= Q + 1) {\n      bel[i][k] = op[i].size();\n      k++;\n    }\n    \n  }\n  for(int i = 1; i <= n; i++) {\n    for(int j = 1; j <= n; j++) {\n      if(a[i] < a[j]) {\n\tSolve(1, i, j, 1);\n      }\n      //cerr << ans << endl;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define del(a,i) memset(a,i,sizeof(a))\n#define ll long long\n#define inl inline\n#define il inl void\n#define it inl int\n#define ill inl ll\n#define re register\n#define ri re int\n#define rl re ll\n#define mid ((l+r)>>1)\n#define lowbit(x) (x&(-x))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntemplate<class T>il read(T &x){\n\tint f=1;char k=getchar();x=0;\n\tfor(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;\n\tfor(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';\n\tx*=f;\n}\ntemplate<class T>il _print(T x){\n\tif(x/10) _print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class T>il print(T x){\n\tif(x<0) putchar('-'),x=-x;\n\t_print(x);\n}\nll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}\nit qpow(int x,int m,int mod){\n\tint res=1,bas=x;\n\twhile(m){\n\t\tif(m&1) res=(1ll*res*bas)%mod;\n\t\tbas=(1ll*bas*bas)%mod,m>>=1;\n\t}\n\treturn res;\n}\nconst int N = 3e3+5,mod = 1e9+7,inv2 = 500000004;\nit add(int x,int y){ return x+y>=mod?x+y-mod:x+y; }\nit mul(int x,int y){ return 1ll*x*y%mod; }\nil inc(int &x,int y){ x=add(x,y); }\nint n,m,x,y,ans,val[N],f[N][N];\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tread(n),read(m);\n\tfor(ri i=1;i<=n;++i) read(val[i]);\n\tfor(ri i=1;i<=n;++i) for(ri j=1;j<=n;++j) f[i][j]=val[i]>val[j];\n\tfor(ri i=1;i<=m;++i){\n\t\tread(x),read(y);\n\t\tf[x][y]=f[y][x]=mul(inv2,add(f[x][y],f[y][x]));\n\t\tfor(ri j=1;j<=n;++j){\n\t\t\tif(j==x||j==y) continue;\n\t\t\tf[x][j]=f[y][j]=mul(inv2,add(f[x][j],f[y][j]));\n\t\t\tf[j][x]=f[j][y]=mul(inv2,add(f[j][x],f[j][y]));\n\t\t}\n\t}\n\tfor(ri i=1;i<n;++i) for(ri j=i+1;j<=n;++j) inc(ans,f[i][j]);\n\tprint(mul(ans,qpow(2,m,mod)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i<(int)(n);i++)\n\ntemplate<int MOD>\nclass mod_int {\n\tunsigned x;\npublic:\n\tmod_int() : x(0) { }\n\tmod_int(int sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tmod_int(long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tmod_int &operator+=(mod_int that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator-=(mod_int that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator*=(mod_int that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tmod_int &operator/=(mod_int that) { return *this *= that.inverse(); }\n\n\tmod_int operator+(mod_int that) const { return mod_int(*this) += that; }\n\tmod_int operator-(mod_int that) const { return mod_int(*this) -= that; }\n\tmod_int operator*(mod_int that) const { return mod_int(*this) *= that; }\n\tmod_int operator/(mod_int that) const { return mod_int(*this) /= that; }\n\n\tbool operator==(const mod_int& that) const { return x == that.x; }\n\n\tmod_int inverse() const {\n\t\tlong long a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\treturn mod_int(u);\n\t}\n};\n\ntemplate<int MOD>\nistream& operator >> (istream& is, mod_int<MOD>& val) {\n\tlong long x;\n\tis >> x; val = x;\n\treturn is;\n}\n\ntemplate<int MOD>\nostream& operator << (ostream& os, const mod_int<MOD>& val) {\n\tos << val.get();\n\treturn os;\n}\n\nconst int mod = 1e9 + 7;\nusing mint = mod_int<mod>;\n\nconst int MAX = 3000;\n\nmint p[MAX][MAX];\nmint s[MAX + 1][MAX + 1];\n\nvector<int> compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n\treturn vs;\n}\n\nint main()\n{\n\tint N, Q;\n\tcin >> N >> Q;\n\tvector<int> a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i];\n\t}\n\tauto vs = compress(a);\n\tfor (int i = 0; i < N; i++) {\n\t\tp[a[i]][i] = 1;\n\t}\n\tfor (int j = 0; j < Q; j++) {\n\t\tint x, y;\n\t\tcin >> x >> y; x--; y--;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tp[i][x] = p[i][y] = (p[i][x] + p[i][y]) / 2;\n\t\t}\n\t}\n\n\tREP(i, N) REP(j, N) s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + p[i][j];\n\n\tauto b = a;\n\tsort(b.begin(), b.end());\n\tmint ans = 0;\n\tfor (int i = 0; i < N; ) {\n\t\tint val = b[i], cnt = 0, x = i;\n\t\twhile (i < N && b[i] == val) ++cnt, ++i;\n\t\tans += cnt * x;\n\t}\n\n\tREP(i, N) REP(j, N) ans -= p[i][j] * (s[i][j] + s[i][j + 1]) / 2;\n\n\tREP(i, Q) ans *= 2;\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int N = 3005;\nconst int MOD = 1e9 + 7;\nconst int INV2 = 5e8 + 4;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n    T x = 0, flag = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') flag = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch)) {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    AKNOI = flag * x;\n}\n\nnamespace ModCalculator {\n\tinline void Inc(int &x, int y) {\n\t\tx += y; if (x >= MOD) x -= MOD;\n\t}\n\tinline void Dec(int &x, int y) {\n\t\tx -= y; if (x < 0) x += MOD;\n\t}\n\tinline int Add(int x, int y) {\n\t\tInc(x, y); return x;\n\t}\n\tinline int Sub(int x, int y) {\n\t\tDec(x, y); return x;\n\t}\n\tinline int Mul(int x, int y) {\n\t\treturn 1LL * x * y % MOD;\n\t}\n}\nusing namespace ModCalculator;\n\nint n, q, a[N], dp[N][N];\n\nvoid init() {\n\tread(n); read(q);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]);\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n ; ++j) {\n\t\t\tdp[i][j] = (a[i] < a[j]);\n\t\t}\n\t}\n\tint pw = 1, x, y, ans = 0;;\n\twhile (q--) {\n\t\tInc(pw, pw);\n\t\tread(x); read(y);\n\t\tdp[x][y] = dp[y][x] = Mul(Add(dp[x][y], dp[y][x]), INV2); // 1/2 the same, 1/2 changed\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[i][x] = dp[i][y] = Mul(Add(dp[i][x], dp[i][y]), INV2);\n\t\t\tdp[x][i] = dp[y][i] = Mul(Add(dp[x][i], dp[y][i]), INV2);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tInc(ans, dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", Mul(ans, pw));\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint f[maxn][maxn], n, a[maxn], p2c[maxn][maxn], q;\nint l[maxn], r[maxn], tmp[maxn], ptmp[maxn];\nint pow2[maxn], ans;\ninline int mul(const int &a, const int &b) {\n\treturn 1ll * a * b % mod;\n}\ninline void Add(int &a, const int &b) {\n\ta = a + b >= mod ? a + b - mod : a + b;\n}\ninline int Minus(const int &a, const int &b) {\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q), pow2[0] = 1;\n\tfor(register int i = 1; i <= q; ++i)\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfor(register int j = i + 1; j <= n; ++j)\n\t\t\tf[i][j] = 1;\n\treverse(l + 1, l + q + 1);\n\treverse(r + 1, r + q + 1);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tfor(register int j = l[i]; j <= r[i]; ++j)\n\t\t\ttmp[j] = f[j][r[i]], ptmp[j] = p2c[j][r[i]];\n\t\tfor(register int j = l[i] + 1; j < r[i]; ++j) {\n\t\t\tf[j][r[i]] = mul(f[j][r[i]], pow2[i + p2c[j][r[i]] - 1]);\n\t\t\tAdd(f[j][r[i]], Minus(pow2[i - 1], mul(f[l[i]][j], pow2[i + p2c[l[i]][j] - 1])));\n\t\t\tp2c[j][r[i]] = -i;\n\t\t}\n\t\tfor(register int j = l[i] + 1; j < r[i]; ++j) {\n\t\t\tf[l[i]][j] = mul(f[l[i]][j], pow2[i + p2c[l[i]][j] - 1]);\n\t\t\tAdd(f[l[i]][j], Minus(pow2[i - 1], mul(tmp[j], pow2[i + ptmp[j] - 1])));\n\t\t\tp2c[l[i]][j] = -i;\n\t\t}\n\t\tp2c[l[i]][r[i]] = -i;\n\t\tf[l[i]][r[i]] = pow2[i - 1];\n\t\t/*for(register int j = 1; j <= n; ++j) {\n\t\t\tfor(register int k = 1; k <= n; ++k) {\n\t\t\t\t//f[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\t\tprintf(\"%d \", mul(f[j][k], pow2[i + p2c[j][k]]));\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n\t}\n\tfor(register int i = 1; i <= n; ++i) {\n\t\tfor(register int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\tif(a[i] > a[j]) Add(ans, f[i][j]);\n\t\t\telse if(a[i] < a[j]) Add(ans, Minus(pow2[q], f[i][j]));\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sstream>\n#include <iostream>\n#include <math.h>\n#include <time.h>\n#include <unistd.h>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <string>\n\n#ifndef ONLINE_JUDGE\n\t#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#else\n\t#define DEBUG(x) do {} while(0);\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define FOR(i, A, N) for(int (i) = (A); (i) < (N); (i)++)\n#define REP(i, N) for(int (i) = 0; (i) < (N); (i)++)\n\nusing namespace std;\ntypedef long long ll;\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\nint n,m;\nconst int mod = 1000000007;\nll modpow(ll a, ll e) {\n\tif (e == 0) return 1;\n\tll x = modpow(a * a % mod, e >> 1);\n\treturn e & 1 ? x * a % mod : x;\n}\n\nll A[3333];\nll dp[3333][3333];\n\nint main() {\n\tll inv2 = modpow(2, mod-2);\n\tint n,q;\n\tscanf(\"%d%d\", &n, &q);\n\tREP(i, n) scanf(\"%lld\", A+i);\n\tREP(i, n) REP(j, n) dp[i][j] = A[i]>A[j];\n\tREP(i, q) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;y--;\n\t\tll o = dp[x][y];\n\t\tdp[x][y] = inv2*dp[x][y]+inv2*dp[y][x]; \n\t\tdp[y][x] = inv2*dp[y][x]+inv2*o;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i == x || i == y)\n\t\t\t\tcontinue;\n\t\t\tll ix = dp[i][x];\n\t\t\tll xi = dp[x][i];\n\t\t\tdp[i][x] = (inv2*dp[i][x]+inv2*dp[i][y])%mod;\n\t\t\tdp[x][i] = (inv2*dp[x][i]+inv2*dp[y][i])%mod;\n\t\t\tdp[i][y] = (inv2*dp[i][y]+inv2*ix)%mod;\n\t\t\tdp[y][i] = (inv2*dp[y][i]+inv2*xi)%mod;\n\t\t}\n\t\t\n\t}\n\tll sum = 0;\n\tREP(i, n) REP(j, n) if(i < j) sum += (mod+dp[i][j])%mod;\n\tREP(i, q) sum = (2*sum)%mod;\n\tprintf(\"%lld\\n\", sum);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 2e5+7;\nint x[N];\ndeque<int> q;\nll check(int s, int l, int n)\n{\n\tint p = 0;\n\tll res = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tq.push_back(x[i]);\n\t}\n\tfor(int i = 0; i < min(5, n); i++)\n\t{\n\t\tif(s&(1<<i))\n\t\t{\n\t\t\tint qb = q.back();\n\t\t\tres += p > qb ? p-qb : p+l-qb;\n\t\t\tq.pop_back();\n\t\t\tp = qb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint qf = q.front();\n\t\t\tres += p < qf ? qf-p : l-p+qf;\n\t\t\tq.pop_front();\n\t\t\tp = qf;\n\t\t}\n\t}\n\twhile(q.size())\n    {\n\t\tint qf = q.front(), qb = q.back();\n\t\tint disb = p < qf ? qf-p : l-p+qf;\n\t\tint dise = p > qb ? p-qb : p+l-qb;\n\t\tif(disb>dise)\n\t\t{\n\t\t    p = qf;\n\t\t\tres += disb;\n\t\t\tq.pop_front();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp = qb;\n\t\t\tres += dise;\n\t\t    q.pop_back();\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tll ans = 0;\n    int l, n, p = 0;\n    scanf(\"%d%d\", &l, &n);\n    for(int i = 1; i <= n; i++)\n    {\n    \tscanf(\"%d\", &x[i]);\n    }\n    if(n<=10)\n    {\n        for(int i = 0; i < (1<<n+1); i++)\n        {\n\t\t\tans = max(ans, check(i, l, n));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < (1<<11); i++)\n\t\t{\n\t\t\tans = max(ans, check(i, l, n));\n\t\t}\n\t}\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 3e3 + 10, MOD = 1e9 + 7, I2 = (MOD + 1) / 2;\n\nint n, Q;\nint a[MAXN], P[MAXN][MAXN];\n\nint main() {\n\tscanf(\"%d%d\", &n, &Q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) P[i][j] = a[i] > a[j];\n\tfor (int i = 1, x, y; i <= Q; ++i) {\n\t\tscanf(\"%d%d\", &x, &y), P[x][y] = P[y][x] = 1LL * (P[x][y] + P[y][x]) * I2 % MOD;\n\t\tfor (int j = 1; j <= n; ++j) if (j != x && j != y) P[x][j] = P[y][j] = 1LL * (P[x][j] + P[y][j]) * I2 % MOD, P[j][x] = P[j][y] = 1LL * (P[j][x] + P[j][y]) * I2 % MOD;\n\t}\n\tint pro = 1, ans = 0;\n\tfor (int i = 1; i <= Q; ++i) pro = pro * 2 % MOD;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) ans = (ans + P[i][j]) % MOD;\n\tprintf(\"%d\\n\", 1LL * ans * pro % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 3e3+5;\nconst int mo = 1e9+7;\n\nint n,q;\nint a[N];\nLL f[N][N],lst[N][N];\nint pos[N];\nLL mi[N];\nLL g[N][N];\n\nLL add(LL x,LL y){return x+y>=mo?x+y-mo:x+y;}\n\nvoid add(int i,int j,int x,int y){\n\tif (i==j||!g[i][j])return;\n\tLL v=g[i][j];\n\tf[i][j]=add(f[i][j],v);\n\tif (i==x||i==y)i^=x^y;\n\tif (j==x||j==y)j^=x^y;\n\tf[i][j]=add(f[i][j],v);\n}\n\nint main(){\n\tn=get();q=get();\n\tfo(i,1,n)a[i]=get();\n\tfo(i,1,n)\n\t\tfo(j,1,n)\n\t\tif (a[i]>a[j])f[i][j]=1;\n\tmi[0]=1;\n\tfo(i,1,q)mi[i]=mi[i-1]*2%mo;\n\tfo(t,1,q){\n\t\tint x=get(),y=get();\n\t\tfo(i,1,n){\n\t\t\tg[i][x]=f[i][x]*mi[t-1-lst[i][x]]%mo;\n\t\t\tg[i][y]=f[i][y]*mi[t-1-lst[i][y]]%mo;\n\t\t\tlst[i][x]=lst[i][y]=t;\n\t\t\tf[i][x]=f[i][y]=0;\n\t\t}\n\t\tfo(j,1,n)\n\t\tif (j!=x&&j!=y){\n\t\t\tg[x][j]=f[x][j]*mi[t-1-lst[x][j]]%mo;\n\t\t\tg[y][j]=f[y][j]*mi[t-1-lst[y][j]]%mo;\n\t\t\tlst[x][j]=lst[y][j]=t;\n\t\t\tf[x][j]=f[y][j]=0;\n\t\t}\n\t\tfo(i,1,n){\n\t\t\tadd(i,x,x,y);\n\t\t\tadd(i,y,x,y);\n\t\t}\n\t\tfo(j,1,n)\n\t\tif (j!=x&&j!=y){\n\t\t\tadd(x,j,x,y);\n\t\t\tadd(y,j,x,y);\n\t\t}\n\t}\n\tLL ans=0;\n\tfo(i,1,n)\n\t\tfo(j,i+1,n)ans=(ans+f[i][j]*mi[q-lst[i][j]])%mo;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\nint iinf=1<<30;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto& itr:mp)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    if(k<0)return 0;\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll poc(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nstruct BIT{\nprivate:\n    ll u;\n    vector<ll> bit;\npublic:\n    BIT(ll n){\n        u=1;while(u<n)u*=2;\n        bit.resize(u+10,0);\n        \n    }\n    void add(ll n,ll x){\n        ll i=n;\n        bit[i]+=x;\n        //bit[i]%=mod;\n        while(i<u){\n            i+=i&(-i);\n            bit[i]+=x;\n            //bit[i]%=mod;\n        }\n\n    }\n    ll sum(ll n){\n        ll i=n;\n        ll ret=0;\n        while(i>0){\n            ret+=bit[i];\n            i-=i&(-i);\n            //ret%=mod;\n        }\n        return ret;\n    }\n    ll lb(ll w){\n        if(w<=0)return 0;\n        ll x=0;\n        for(ll k=u;k>0;k/=2){\n            if(x+k<=u&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n};\n//vector<BIT> b(26,n+1);\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    ll n,q;cin>>n>>q;\n    ll a[n];\n    rep(i,0,n){\n        cin>>a[i];\n    }\n    ll dp[n][n];\n    ll gn=gyaku(2,mod);\n    ll u=beki(2,q,mod);\n    rep(i,0,n){\n        rep(j,0,n){\n            if(a[i]>a[j])dp[i][j]=1;\n            else dp[i][j]=0;\n        }\n    }\n    rep(i,0,q){\n        ll x,y;cin>>x>>y;\n        x--;\n        y--;\n        rep(j,0,n){\n            if(j==x||j==y)continue;\n            ll wa=(dp[x][j]+dp[y][j])*gn%mod;\n            dp[x][j]=wa;\n            dp[y][j]=wa;\n            wa=(dp[j][x]+dp[j][y])*gn%mod;\n            dp[j][x]=wa;\n            dp[j][y]=wa;\n        }\n        ll wa=(dp[x][y]+dp[y][x])*gn%mod;\n        dp[x][y]=wa;\n        dp[y][x]=wa;\n    }\n    ll ans=0;\n    rep(i,0,n){\n        rep(j,i+1,n){\n            (ans+=dp[i][j])%=mod;\n        }\n    }\n    (ans*=u)%=mod;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MOD 1000000007\nusing namespace std;\nint n,Q,i,j,A[3005],jum,sum,x,y,Prob[3005][3005],q,val;\n\nint pu(int a, int b)\n{\n    int i,rez=1;\n    for(i=0; (1<<i)<=b; i++)\n    {\n        if((1<<i)&b)\n            rez=(1LL*rez*a)%MOD;\n        a=(1LL*a*a)%MOD;\n    }\n    return rez;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>Q;\n    for(i=1; i<=n; i++)\n        cin>>A[i];\n    for(i=1; i<=n; i++)\n        for(j=i+1; j<=n; j++)\n        {\n            if(A[i]==A[j])\n            {\n                Prob[i][j]=Prob[j][i]=0;\n                continue;\n            }\n            if(A[i]>A[j])\n            {\n                Prob[i][j]=1;\n                Prob[j][i]=0;\n            }\n            else\n            {\n                Prob[i][j]=0;\n                Prob[j][i]=1;\n            }\n        }\n    jum=pu(2,MOD-2);\n    for(q=1; q<=Q; q++)\n    {\n        cin>>x>>y;\n        for(i=1; i<=n; i++)\n        {\n            if(i==x || i==y)\n                continue;\n            val=(((1LL*jum*Prob[i][x])%MOD)+((1LL*jum*Prob[i][y])%MOD))%MOD;\n            Prob[i][x]=Prob[i][y]=val;\n            val=(((1LL*jum*Prob[x][i])%MOD)+((1LL*jum*Prob[y][i])%MOD))%MOD;\n            Prob[x][i]=Prob[y][i]=val;\n        }\n        val=(((1LL*jum*Prob[x][y])%MOD)+((1LL*jum*Prob[y][x])%MOD))%MOD;\n        Prob[x][y]=Prob[y][x]=val;\n    }\n    for(i=1; i<=n; i++)\n        for(j=i+1; j<=n; j++)\n            sum=(sum+Prob[i][j])%MOD;\n    cout<<(1LL*sum*pu(2,Q))%MOD<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace io{\n    const int l=1<<20;\n    char buf[l],*s,*t,c;\n    inline void gc(){\n        if(s==t){\n            t=(s=buf)+fread(buf,1,l,stdin);\n            c=s==t?EOF:*s++;\n        }else c=*s++;\n    }\n    template<class IT>inline void gi(IT &x){\n        x=0;gc();while(c<'0'||c>'9')gc();\n        while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);gc();}\n    }\n    char buf0[20];int a;\n    template<class IT>inline void pi(IT x){\n        if(x<0){putchar('-');x=-x;}\n        do buf0[++a]=x%10+48;while(x/=10);\n        while(a)putchar(buf0[a--]);\n        putchar('\\n');\n    }\n};\nusing io::gi;\nusing io::pi;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\ntypedef vector<int> vi;\ntypedef vector<ll > vl;\n#define pque priority_queue\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=3005;\nconst ll p=1000000007ll;\nll d[N][N];int x[N];\ninline void mean(ll &a,ll &b){\n\tll c=(a+b)*500000004ll%p;\n\ta=b=c;\n}\nint main(){\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n,q,i,j,k;ll s=0ll,t=1ll;\n    scanf(\"%d%d\",&n,&q);\n    rep(i,1,n)scanf(\"%d\",&x[i]);\n\trep(i,1,n)rep(j,1,n)if(x[i]<x[j])d[i][j]=1ll;\n\t//rep(i,1,n){rep(j,1,n)printf(\"%lld \",d[i][j]);puts(\"\");}puts(\"\");\n\twhile(q--){\n\t\tif((t<<=1)>=p)t-=p;\n\t\tscanf(\"%d%d\",&i,&j);\n\t\tmean(d[i][j],d[j][i]);\n\t\trep(k,1,n)if(k!=i&&k!=j)mean(d[i][k],d[j][k]);//printf(\"%d %d %d %d\\n\",i,k,j,k);\n\t\trep(k,1,n)if(k!=i&&k!=j)mean(d[k][i],d[k][j]);//printf(\"%d %d %d %d\\n\",k,i,k,j);\n\t\t//rep(i,1,n){rep(j,1,n)printf(\"%lld \",d[i][j]*t%p);puts(\"\");}puts(\"\");\n\t}\n\trep(i,2,n)REP(j,1,i)s+=d[i][j];\n\tprintf(\"%lld\",(s%p)*t%p);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<cassert>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int maxn=3e3+20;\nconst int mod=1e9+7;\nconst int inv2=mod+1>>1;\n\nint n,a[maxn],q;\nint f[maxn][maxn],g[maxn][maxn];\n\ninline void init()\n{\n\tn=read();q=read();\n\tREP(i,1,n)a[i]=read();\n}\n\ninline void doing()\n{\n\tint u=0;\n\tREP(i,1,n)REP(j,1,n)\n\t\tif(i<=j)g[i][j]=f[i][j]=a[i]<a[j];\n\t\telse g[i][j]=f[i][j]=a[i]<a[j];\n\tREP(t,1,q)\n\t{\n\t\tint i=read(),j=read();\n\t\tREP(k,1,n)if(k!=j)\n\t\t{\n\t\t\tg[i][k]=(ll)inv2*(f[i][k]+f[j][k])%mod;\n\t\t}else g[i][j]=(ll)inv2*(f[i][j]+f[j][i])%mod;\n\n\t\tREP(k,1,n)if(k!=i)\n\t\t{\n\t\t\tg[j][k]=(ll)inv2*(f[j][k]+f[i][k])%mod;\n\t\t}else g[j][i]=(ll)inv2*(f[i][j]+f[j][i])%mod;\n\t\t\n\t\tREP(k,1,n)if(k!=i)\n\t\t{\n\t\t\tg[k][j]=(ll)inv2*(f[k][j]+f[k][i])%mod;\n\t\t}\n\n\t\tREP(k,1,n)if(k!=j)\n\t\t{\n\t\t\tg[k][i]=(ll)inv2*(f[k][i]+f[k][j])%mod;\n\t\t}\n\t\tREP(k,1,n)f[i][k]=g[i][k],f[j][k]=g[j][k];\n\t\tREP(k,1,n)f[k][i]=g[k][i],f[k][j]=g[k][j];\n\t}\n\tint ans=0,s=1;REP(i,1,q)s=(ll)s*2%mod;\n\tREP(i,1,n)REP(j,1,i-1)\n\t{\n\t\tans=(ans+(ll)f[i][j]*s)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 3000, md = 1000000007;\n\nint f[MX][MX], g[MX][MX], p2[MX + 1];\n\nint get(int x, int y, int t) {\n\treturn f[x][y] * 1ll * p2[g[x][y] - t - 1] % md;\n}\n\nint a[MX], x[MX], y[MX];\n\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i <= MX; i++) p2[i] = p2[i - 1] * 2 % md;\n\t\n\tint n, q;\n\tignore = scanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) ignore = scanf(\"%d\", a + i);\n\tfor (int i = 0; i < q; i++) {\n\t\tignore = scanf(\"%d %d\", x + i, y + i);\n\t\tx[i]--;\n\t\ty[i]--;\n\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tf[i][j] = i < j ? 1 : 0;\n\t\t\tg[i][j] = q;\n\t\t}\n\t\n\tfor (int i = q - 1; i >= 0; i--) {\n\t\tvector<tuple<int, int, int>> changes;\n\t\tchanges.reserve(4 * n);\n\t\tchanges.emplace_back(x[i], y[i], get(y[i], x[i], i));\n\t\tchanges.emplace_back(y[i], x[i], get(x[i], y[i], i));\n\t\tfor (int z = 0; z < n; z++) {\n\t\t\tif (z == x[i] || z == y[i]) continue;\n\t\t\tchanges.emplace_back(x[i], z, get(y[i], z, i));\n\t\t\tchanges.emplace_back(y[i], z, get(x[i], z, i));\n\t\t\tchanges.emplace_back(z, x[i], get(z, y[i], i));\n\t\t\tchanges.emplace_back(z, y[i], get(z, x[i], i));\n\t\t}\n\t\t\n\t\tfor (auto& t : changes) {\n\t\t\tint x, y, v;\n\t\t\ttie(x, y, v) = t;\n\t\t\t\n\t\t\tf[x][y] = (get(x, y, i) + v) % md;\n\t\t\tg[x][y] = i;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (a[i] > a[j])\n\t\t\t\tans = (ans + get(i, j, -1)) % md;\n\t\t\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 3010;\nconst int mod = 1e9+7;\n\nint A[maxn], f[maxn][maxn];\n\nint n, q;\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tf[i][j] = (A[i] < A[j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tint inv = (mod + 1) / 2;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tint s = 1LL * (f[j][x] + f[j][y]) * inv % mod;\n\t\t\t\tf[j][x] = f[j][y] = s;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j != x && j != y) {\n\t\t\t\tint s = 1LL * (f[x][j] + f[y][j]) * inv % mod;\n\t\t\t\tf[x][j] = f[y][j] = s;\n\t\t\t}\n\t\t}\n\t\tint s = 1LL * (f[x][y] + f[y][x]) * inv % mod;\n\t\tf[x][y] = f[y][x] = s;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tans = (ans + f[i][j]) % mod;\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; i++) ans = 1LL * ans * 2 % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/agc030/tasks/agc030_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3002\n#define mod 1000000007\n\nint A[N];\nint dp[N][N][2];\nint lazy[N][N][2];\n\nint getState(int i,int j) {\n  if(i<j) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nint add(int x,int y) {\n  return (x+y)%mod;\n}\nint mul(int x,int y) {\n  return (ll)x*y%mod;\n}\npair<int,pair<int,int> > getTransition(int st,int i,int j,int x,int y) {\n  int ni = i;\n  if(x==i) {\n    ni = y;\n  } else if(ni==y) {\n    ni = x;\n  }\n  int nj = j;\n  if(x==j) {\n    nj = y;\n  } else if(nj==y) {\n    nj = x;\n  }\n  int ijState = getState(i,j);\n  int ni_nj_state = getState(ni,nj);\n  int nst = st;\n  if(ijState!=ni_nj_state) {\n    nst ^=1;\n  }\n  return make_pair(nst,make_pair(ni,nj));\n}\n\nint powerOfTwo[N];\nint getValue(int x,int y,int st,int curQ) {\n  int v = powerOfTwo[curQ- lazy[x][y][st]];\n  return mul(v,dp[x][y][st]);\n}\n\nvoid solve() {\n  int n,q;\n  scanf(\"%d %d\", &n,&q);\n  powerOfTwo[0] = 1;\n  for(int i=1;i<N;++i) {\n    powerOfTwo[i] = mul(powerOfTwo[i-1],2);\n  }\n\n  for(int i=0;i<n;++i) {\n    scanf(\"%d \", &A[i]);\n  }\n\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      if(A[i]==A[j]) {\n        continue;\n      }\n      if(A[i]>A[j]) {\n        ++dp[i][j][1];\n      } else {\n        ++dp[i][j][0];\n      }\n    }\n  }\n\n  int lazy_value = 0;\n  while(q--) {\n    int x,y;scanf(\"%d %d \", &x,&y);\n    if(x>y) {\n      swap(x,y);\n    }\n\n    --x,--y;\n    //optimize by lazy-eval\n    map<pair<int,pair<int,int> >,int> v;\n    map<pair<int,pair<int,int> >,int> iter;\n    for(int i=0;i<n;++i) {\n      if(i!=x) {\n        for(int st=0;st<2;++st) {\n          v[make_pair(st,make_pair(x,i))];\n          v[make_pair(st,make_pair(i,x))];\n          pair<int,pair<int,int> >trans = getTransition(st,i,x,x,y);\n          v[trans];\n          trans = getTransition(st,x,i,x,y);\n          v[trans];\n        }\n      }\n      if(i!=y) {\n        for(int st=0;st<2;++st) {\n          v[make_pair(st,make_pair(y,i))];\n          v[make_pair(st,make_pair(i,y))];\n          pair<int,pair<int,int> >trans = getTransition(st,i,y,x,y);\n          v[trans];\n          trans = getTransition(st,y,i,x,y);\n          v[trans];\n        }\n      }\n    }\n    for(map<pair<int,pair<int,int> >,int> ::iterator it = v.begin();\n    it!= v.end();++it) {\n      int i = (it->first).second.first;\n      int j = (it->first).second.second;\n      int st = (it->first).first;\n      int val = getValue(i,j,st,lazy_value);\n      v[make_pair(st,make_pair(i,j))] = add(v[make_pair(st,make_pair(i,j))],val);\n      pair<int,pair<int,int> >trans = getTransition(st,i,j,x,y);\n      assert(v.count(trans));\n      v[trans] =add(v[trans],val);\n    }\n    for(map<pair<int,pair<int,int> >,int> ::iterator it = v.begin();\n    it!= v.end();++it) {\n      int i = (it->first).second.first;\n      int j = (it->first).second.second;\n      int st = (it->first).first;\n      int val = (it->second);\n      dp[i][j][st]= val;\n      lazy[i][j][st] = lazy_value+1;\n    }\n    ++lazy_value;\n  }\n  int ret = 0;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      ret = add(ret, getValue(i,j,1,lazy_value));\n    }\n  }\n\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, q;\n\nconst int MOD = 1e9 + 7;\n\nint a[3055];\nlong long dp[3055][3055];\n\nint mod_pow(int n, int k) {\n\tif (k == 0) return 1;\n\t\n\tint res = mod_pow(n, k >> 1);\n\tres = (1ll * res * res) % MOD;\n\t\n\tif (k & 1) res = (1ll * res * n) % MOD;\n\treturn res;\n}\nint main() {\n\tcin >> n >> q;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\t\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\tif (a[i] > a[j]) {\n\t\t\tdp[i][j] = 1;\n\t\t}\n\t}\n\t\n\tint p5 = mod_pow(2, MOD - 2);\n\t\n\tfor (int _ = 0; _ < q; _++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t\n\t\tif (x == y) continue;\n\t\t\n\t\tif (x > y) swap(x, y);\n\t\t\n\t\tfor (int i = 1; i <= n; i++) if (i < x || i > y) {\n\t\t\t{\n\t\t\t\tint l = dp[i][x];\n\t\t\t\tint r = dp[i][y];\n\t\t\t\t\n\t\t\t\tdp[i][x] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t\tdp[i][y] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tint l = dp[x][i];\n\t\t\t\tint r = dp[y][i];\n\t\t\t\t\n\t\t\t\tdp[x][i] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t\tdp[y][i] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = x + 1; i < y; i++) {\n\t\t\t{\n\t\t\t\tint l = dp[i][x];\n\t\t\t\tint r = dp[i][y];\n\t\t\t\t\n\t\t\t\tdp[i][x] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t\tdp[i][y] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tint l = dp[x][i];\n\t\t\t\tint r = dp[y][i];\n\t\t\t\t\n\t\t\t\tdp[x][i] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t\tdp[y][i] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tint l = dp[x][y];\n\t\t\tint r = dp[y][x];\n\t\t\t\n\t\t\tdp[x][y] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t\tdp[y][x] = (1ll * l * p5 + 1ll * r * p5) % MOD;\n\t\t}\n\t}\n\t\n\tint p = 1;\n\tlong long res = 0;\n\t\n\tfor (int i = 1; i <= q; i++) {\n\t\tp = (p + p) % MOD;\n\t}\n\t\n\tfor (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) {\n\t\tres = (1ll * res + 1ll * p * dp[i][j] % MOD) % MOD;\n\t}\n\t\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int inv2=(mods+1)>>1;\nconst int MAXN=3005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nint f[MAXN][MAXN],a[MAXN];\ninline int upd(int x,int y){ return x+y>=mods?x+y-mods:x+y; }\nint main()\n{\n\tint n=read(),q=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tfor (int i=1;i<=n;i++) \n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (a[i]>a[j]) f[i][j]=1;\n\tfor (int i=1;i<=q;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tf[x][y]=f[y][x]=1ll*upd(f[x][y],f[y][x])*inv2%mods;\n\t\tfor (int j=1;j<=n;j++)\n\t\tif (x!=j&&y!=j)\n\t\t\tf[x][j]=f[y][j]=1ll*upd(f[x][j],f[y][j])*inv2%mods,\n\t\t\tf[j][x]=f[j][y]=1ll*upd(f[j][x],f[j][y])*inv2%mods;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) \n\t\tfor (int j=i+1;j<=n;j++) ans=upd(ans,f[i][j]);\n\tfor (int i=1;i<=q;i++) ans=upd(ans,ans);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=(1e9)+7;\nconst ll iv=(5e8)+4;\nint n,q,a[3010],x,y;\nll dp[3010][3010],tmp=1,ans;\nint main() {\n\tread(n); read(q);\n\tfor (int i=1;i<=n;i++) read(a[i]);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif (a[i]>a[j]) dp[i][j]=1;\n\twhile (q--) {\n\t\tread(x); read(y); tmp=tmp*2%mod;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (i!=x&&i!=y) {\n\t\t\t\tdp[i][x]=dp[i][y]=(dp[i][x]+dp[i][y])*iv%mod;\n\t\t\t\tdp[x][i]=dp[y][i]=(dp[x][i]+dp[y][i])*iv%mod;\n\t\t\t}\n\t\tdp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*iv%mod;\n\t}\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t\tans+=dp[i][j],ans%=mod;\n\tprintf(\"%lld\\n\",ans*tmp%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/agc030/tasks/agc030_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3002\n#define mod 1000000007\n\nint A[N];\n\nstruct qqq{\n  int dp,dp2,lazy;\n} mdp[N][N][2];\n\nint getState(int i,int j) {\n  if(i<j) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\ninline int add(int x,int y) {\n  int ret = x+y;\n  if(ret>=mod) {\n    return ret-mod;\n  }\n  return ret;\n}\n\ninline int mul(int x,int y) {\n  return (ll)x*y%mod;\n}\n\n\nvoid getTransition(int &st,int &i,int &j,int x,int y) {\n  int ni = i;\n  if(x==i) {\n    ni = y;\n  } else if(ni==y) {\n    ni = x;\n  }\n  int nj = j;\n  if(x==j) {\n    nj = y;\n  } else if(nj==y) {\n    nj = x;\n  }\n  int ijState = (i<j) ? 1 : 0;\n  int ni_nj_state = (ni<nj) ? 1 :0;\n  int nst = st;\n  if(ijState!=ni_nj_state) {\n    nst ^=1;\n  }\n  st = nst;\n  i = ni;\n  j = nj;\n}\n\nint powerOfTwo[N];\nint getValue(int x,int y,int st,int curQ) {\n  int v = powerOfTwo[curQ- mdp[x][y][st].lazy];\n  return mul(v,mdp[x][y][st].dp);\n}\n\nvoid solve() {\n  int n,q;\n  scanf(\"%d %d\", &n,&q);\n  powerOfTwo[0] = 1;\n  for(int i=1;i<N;++i) {\n    powerOfTwo[i] = mul(powerOfTwo[i-1],2);\n  }\n\n  for(int i=0;i<n;++i) {\n    scanf(\"%d \", &A[i]);\n  }\n\n  for(int i=0;i<n;++i) {\n    for(int j=i+1;j<n;++j) {\n      if(A[i]==A[j]) {\n        continue;\n      }\n      if(A[i]>A[j]) {\n        ++mdp[i][j][1].dp;\n      } else {\n        ++mdp[i][j][0].dp;\n      }\n    }\n  }\n\n  int lazy_value = 0;\n  pair<int,pair<int,int> >trans;\n  int val,i,st;\n  while(q--) {\n    int x,y;scanf(\"%d %d \", &x,&y);\n    if(x>y) {\n      swap(x,y);\n    }\n\n    --x,--y;\n    //optimize by lazy-eval\n    for(i=0;i<n;++i) {\n      for(st=0;st<2;++st) {\n        if(i!=x) {\n          mdp[x][i][st].dp2 = 0;\n          mdp[i][x][st].dp2 = 0;\n        }\n        if(i!=y && i!=x) {\n          mdp[y][i][st].dp2 = 0;\n          mdp[i][y][st].dp2 = 0;\n        }\n      }\n    }\n    for(i=0;i<n;++i) {\n      for(st=0;st<2;++st) {\n        if(i!=x) {\n          //dp2[i][x][st] = 0;\n          val = getValue(i,x,st,lazy_value);\n          int a,b,c;\n          a = st,b= i,c = x;\n          getTransition(a,b,c,x,y);\n\n          mdp[i][x][st].dp2 = add(mdp[i][x][st].dp2, val);\n          mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n\n          val = getValue(x,i,st,lazy_value);\n          a = st,b = x,c = i;\n          getTransition(a,b,c,x,y);\n          mdp[x][i][st].dp2 = add(mdp[x][i][st].dp2, val);\n          mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n        }\n        if(i!=y && i!=x) {\n          val = getValue(i,y,st,lazy_value);\n          int a,b,c;\n          a = st,b= i,c = y;\n          getTransition(a,b,c,x,y);\n          mdp[i][y][st].dp2 = add(mdp[i][y][st].dp2, val);\n          mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n\n          val = getValue(y,i,st,lazy_value);\n          a = st,b= y,c = i;\n          getTransition(a,b,c,x,y);\n          mdp[y][i][st].dp2 = add(mdp[y][i][st].dp2, val);\n          mdp[b][c][a].dp2 = add(mdp[b][c][a].dp2,val);\n        }\n      }\n    }\n\n    for(i=0;i<n;++i) {\n      for(st=0;st<2;++st) {\n        if(i!=x) {\n          mdp[x][i][st].dp = mdp[x][i][st].dp2;\n          mdp[i][x][st].dp = mdp[i][x][st].dp2;\n          mdp[x][i][st].lazy = lazy_value+1;\n          mdp[i][x][st].lazy = lazy_value+1;\n        }\n        if(i!=y && i!=x) {\n          mdp[y][i][st].dp = mdp[y][i][st].dp2;\n          mdp[i][y][st].dp = mdp[i][y][st].dp2;\n          mdp[y][i][st].lazy = lazy_value+1;\n          mdp[i][y][st].lazy = lazy_value+1;\n        }\n      }\n    }\n\n    ++lazy_value;\n  }\n  int ret = 0;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      ret = add(ret, getValue(i,j,1,lazy_value));\n    }\n  }\n\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long mod=1e9+7,inv2=(mod+1)/2;\nlong long n,q,a[3333],x[3333],y[3333],pw[3333],ipw[3333],dp[3333][3333],cur,ans; \nint main()\n{\n\tscanf(\"%lld%lld\",&n,&q);\n\tfor (long long i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tfor (long long i=1;i<=q;i++) \n\t{\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tif (x[i]>y[i]) swap(x[i],y[i]);\n\t}\n\tpw[0]=1;\n\tfor (long long i=1;i<=3000;i++)\n\t{\n\t\tpw[i]=pw[i-1]*2%mod;\n\t\tipw[i]=ipw[i-1]*inv2%mod;\n\t}\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=i+1;j<=n;j++)\n\t\t{\n\t\t\tdp[i][j]=1;\n\t\t}\n\t}\n\tfor (long long i=q;i>=1;i--)\n\t{\n\t\tcur=(dp[x[i]][y[i]]+dp[y[i]][x[i]])*inv2%mod;\n\t\tdp[x[i]][y[i]]=dp[y[i]][x[i]]=cur;\n\t\tfor (long long j=1;j<=n;j++)\n\t\t{\n\t\t\tif (j==y[i] || j==x[i]) continue;\n\t\t\tcur=(dp[x[i]][j]+dp[y[i]][j])*inv2%mod;\n\t\t\tdp[x[i]][j]=dp[y[i]][j]=cur;\n\t\t\tcur=(dp[j][x[i]]+dp[j][y[i]])*inv2%mod;\n\t\t\tdp[j][x[i]]=dp[j][y[i]]=cur;\n\t\t}\n\t}\n\tfor (long long i=1;i<=n;i++)\n\t{\n\t\tfor (long long j=1;j<=n;j++)\n\t\t{\n\t\t\tif (i==j) continue;\n\t\t\tif (a[i]>a[j]) ans=(ans+dp[i][j]*pw[q])%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long\n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)>>1)\n#define all(x) x.begin(),x.end()\n#define dbgs(x) cerr<<(#x)<<\" --> \"<<(x)<<\" \"\n#define dbg(x) cerr<<(#x)<<\" --> \"<<(x)<<endl;getchar()\n#define pw(x) (1<<(x))\n#define inf 2000000000\n#define MOD 1000000007\n#define N 3005\n#define M 1442255\n#define LOG 1000000\n#define KOK 31623\n#define EPS 0.000000001\nusing namespace std;\n\nint n,q,ans,tot,x[N],y[N],a[N],dp1[N][N],dp2[N][N],po[N],cur[N][N];\n\nvoid up(int a,int b) {\n\n\tdp1[a][b]=1ll*dp1[a][b]*po[tot-cur[a][b]-1]%MOD;\n\tdp2[a][b]=1ll*dp2[a][b]*po[tot-cur[a][b]-1]%MOD;\n\n\tcur[a][b]=tot;\n\n}\n\nint main() {\n\n\t//freopen(\"input.txt\",\"r\",stdin);\n\n\tscanf(\"%d %d\",&n,&q);\n\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\n\tfor(int i=1;i<=q;i++) scanf(\"%d %d\",x+i,y+i);\n\n\tfor(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++) dp1[i][j]=1;\n\n\tpo[0]=1;\n\n\tfor(int i=1;i<=q+3;i++) po[i]=po[i-1]*2%MOD;\n\n\ttot=1;\n\n\tfor(int t=q;t>=1;t--,tot++) {\n\n\t\tif(x[t]>y[t]) swap(x[t],y[t]);\n\n\t\tfor(int i=1;i<=n;i++) {\n\n\t\t\tif(i<x[t]) {\n\n\t\t\t\tup(i,x[t]);\n\t\t\t\tup(i,y[t]);\n\n\t\t\t\tint t1=dp1[i][x[t]];\n\t\t\t\tint t2=dp2[i][x[t]];\n\n\t\t\t\tdp1[i][x[t]]=(dp1[i][x[t]]+dp1[i][y[t]])%MOD;\n\t\t\t\tdp2[i][x[t]]=(dp2[i][x[t]]+dp2[i][y[t]])%MOD;\n\n\t\t\t\tdp1[i][y[t]]=(dp1[i][y[t]]+t1)%MOD;\n\t\t\t\tdp2[i][y[t]]=(dp2[i][y[t]]+t2)%MOD;\n\n\t\t\t}\n\t\t\telse if(i>y[t]) {\n\n\t\t\t\tup(x[t],i);\n\t\t\t\tup(y[t],i);\n\n\t\t\t\tint t1=dp1[x[t]][i];\n\t\t\t\tint t2=dp2[x[t]][i];\n\n\t\t\t\tdp1[x[t]][i]=(dp1[x[t]][i]+dp1[y[t]][i])%MOD;\n\t\t\t\tdp2[x[t]][i]=(dp2[x[t]][i]+dp2[y[t]][i])%MOD;\n\n\t\t\t\tdp1[y[t]][i]=(dp1[y[t]][i]+t1)%MOD;\n\t\t\t\tdp2[y[t]][i]=(dp2[y[t]][i]+t2)%MOD;\n\n\t\t\t}\n\t\t\telse if(i==x[t]) {\n\n\t\t\t\tup(x[t],y[t]);\n\n\t\t\t\tint t1=dp1[i][y[t]];\n\n\t\t\t\tdp1[i][y[t]]=(dp1[i][y[t]]+dp2[i][y[t]])%MOD;\n\t\t\t\tdp2[i][y[t]]=(dp2[i][y[t]]+t1)%MOD;\n\n\t\t\t}\n\t\t\telse if(i<y[t]) {\n\n\t\t\t\tup(x[t],i);\n\t\t\t\tup(i,y[t]);\n\n\t\t\t\tint t1=dp2[x[t]][i];\n\t\t\t\tint t2=dp1[x[t]][i];\n\n\t\t\t\tdp1[x[t]][i]=(dp1[x[t]][i]+dp2[i][y[t]])%MOD;\n\t\t\t\tdp2[x[t]][i]=(dp2[x[t]][i]+dp1[i][y[t]])%MOD;\n\n\t\t\t\tdp1[i][y[t]]=(dp1[i][y[t]]+t1)%MOD;\n\t\t\t\tdp2[i][y[t]]=(dp2[i][y[t]]+t2)%MOD;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tfor(int j=i+1;j<=n;j++) {\n\n\t\t\tdp1[i][j]=1ll*dp1[i][j]*po[tot-cur[i][j]-1]%MOD;\n\t\t\tdp2[i][j]=1ll*dp2[i][j]*po[tot-cur[i][j]-1]%MOD;\n\n\t\t\tif(a[i]>a[j]) {\n\n\t\t\t\tans=(ans+dp1[i][j])%MOD;\n\n\t\t\t}\n\t\t\telse if(a[i]<a[j]) {\n\n\t\t\t\tans=(ans+dp2[i][j])%MOD;\n\n\t\t\t}\n\n\t\t\tassert((dp1[i][j]+dp2[i][j])%MOD == po[q]);\n\n\t\t}\n\n\t} \n\n\tprintf(\"%d\",ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\nusing namespace __gnu_pbds;\n\n#if !ONLINE_JUDGE\n#define debug\n#endif\n\nusing namespace std;\n \n/*******  All Required define Pre-Processors and typedef Constants *******/\n#define mem(a, b) memset(a, (b), sizeof(a))\n#define repd(i,k) for(int i=k;i>=0;i--)\n#define rep(i,k) for(int i=0;i<k;i++)\n#define repn(i,k1,k2) for(ll i=k1;i<k2;i++)\n#define sz(x) (ll)(x).size()\n#define ff first\n#define ss second\n\n#define all(cont) cont.begin(), cont.end()\n#define rall(cont) cont.end(), cont.begin()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define INF (int)1e9\n#define EPS 1e-9\n#define PI 3.1415926535897932384626433832795\n#define MOD 1000000007\n#define ee6 (ll)1000001\n#define ee5 (ll)100001\n\n#define trav(a, v) for(auto& a : v)\n\n#define tt ll t;cin>>t; while(t--)\ntypedef long long int ll;\n \ntypedef pair<ll, ll> pr;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef vector<pr> vpr;\ntypedef vector<vpr>vvpr;\ntypedef vector<vi> vvi;\n\n//*X.find_by_order(2) element at index=2\n//X.order_of_key(1) how many elements strictly less than 1\n\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\n#ifdef debug\n#define dbg(...) { cerr<<\"[ \"; dump(#__VA_ARGS__, __VA_ARGS__);}\n#undef endl\ntemplate <typename Arg1,typename Arg2>\nostream& operator << (ostream& out, const pair<Arg1,Arg2> &x) {\n    return out<<\"(\"<<x.ff<<\",\"<<x.ss<<\")\";\n}\n \ntemplate <typename Arg1>\nostream& operator << (ostream& out, const vector<Arg1> &a) {\n    out<<\"[\";for(const auto &x:a)out<<x<<\",\";return out<<\"]\";\n}\n \ntemplate <typename Arg1>\nostream& operator << (ostream& out, const set<Arg1> &a) {\n    out<<\"[\";for(const auto &x:a)out<<x<<\",\";return out<<\"]\";\n}\n \ntemplate <typename Arg1,typename Arg2>\nostream& operator << (ostream& out, const map<Arg1,Arg2> &a) {\n    out<<\"[\";for(const auto &x:a)out<<x<<\",\";return out<<\"]\";\n}\n \ntemplate <typename Arg1,typename Arg2>\nostream& operator << (ostream& out, const unordered_map<Arg1,Arg2> &a) {\n    out<<\"[\";for(const auto &x:a)out<<x<<\",\";return out<<\"]\";\n} \n \ntemplate <typename Arg1>\nvoid dump(const string name, Arg1&& arg1){\n    cerr << name << \" : \" << arg1 << \" ] \" << endl;\n}\n \ntemplate <typename Arg1, typename... Args>\nvoid dump(const string names, Arg1&& arg1, Args&&... args){\n    const string name = names.substr(0,names.find(','));\n    cerr<<name<<\" : \"<<arg1<<\" | \";\n    dump(names.substr(1+(int)name.size()), args...);\n}\n#else\n    #define dbg(args...)\n#endif\n \nll powmod(ll x, ll y) \n{ \n    ll res = 1;  \n    x = x % MOD;\n    while (y > 0) \n    { \n        if (y & 1) \n  \t      res = (res*x) % MOD; \n        y = y>>1; // y = y/2 \n        x = (x*x) % MOD;   \n    } \n    return res; \n} \nll a[3005];\nll dp[3005][3005];\nint main()\n{\n\t#if !ONLINE_JUDGE\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n \t\n \tll n,q;cin>>n>>q;\n \t//dp[i][j]\n\n \trep(i,n){\n \t\tcin>>a[i];\n \t}\n\n \tfor(ll i=0;i<n;i++){\n \t\tfor(ll j=0;j<n;j++){\n \t\t\tif(a[i]>a[j])\n \t\t\t\tdp[i][j]=1;\n \t\t}\n \t}\n\n\n\tvector<ll>sx(n);\n\tvector<ll>sy(n);\n\tvector<ll>xs(n);\n\tvector<ll>ys(n);\n \tll inv=powmod(2,MOD-2);\n \trep(i,q){\n \t\tll x,y;cin>>x>>y;x--;y--;\n\n \t\trep(i,n)\n \t\t\tsx[i]=dp[i][x],sy[i]=dp[i][y],xs[i]=dp[x][i],ys[i]=dp[y][i];\n\n \t\tfor(ll i=0;i<n;i++){\n \t\t\tif(i!=y and i!=x)\n \t\t\tdp[i][x]=((sy[i]+sx[i])*inv)%MOD;\n \t\t}\n \t\tdp[y][x]=(sx[y]+sy[x])*inv%MOD;\n\n \t\tfor(ll i=0;i<n;i++){\n \t\t\tif(i!=x and i!=y) \t\t\t\n \t\t\tdp[i][y]=dp[i][x];\n \t\t}\n \t\tdp[x][y]=dp[y][x];\n\n \t\tfor(ll i=0;i<n;i++)\n \t\t\tif(i!=y and i!=x)\n \t\t\tdp[x][i]=((xs[i]+ys[i])*inv)%MOD;\n\t\t\n\t\tfor(ll i=0;i<n;i++)\n \t\t\tif(i!=y and i!=x)\n \t\t\tdp[y][i]=((xs[i]+ys[i])*inv)%MOD;\n\n \t\t//rep(i,n){rep(j,n)cout<<dp[i][j]<<\" \";cout<<\"\\n\";}\n \t}\n\n \tll ans=0;\n \tfor(ll i=0;i<n;i++){\n \t\tfor(ll j=0;j<i;j++){\n \t\t\tans=(ans+dp[j][i])%MOD;\n \t\t}\n \t}\n \tcout<<ans*powmod(2,q)%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define tr(xx,yy) (xx+=yy)>=M?xx-=M:0\nconst int N=3003,M=1000000007,I2=M+1>>1;\nusing namespace std;\nint n,m,a[N],f[N][N],l,r,\ng0[N],g1[N],h0[N],h1[N],ans;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\tscanf(\"%d\",a+i);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(a[j]<a[i])f[j][i]=1;\n\tfor(int al=0;al<m;al++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tfor(int i=1;i<=n;i++)\n\t\tif(i!=r)\n\t\tf[l][i]=1ll*f[l][i]*I2%M,\n\t\tf[i][l]=1ll*f[i][l]*I2%M;\n\t\tfor(int i=1;i<=n;i++)\n\t\tf[r][i]=1ll*f[r][i]*I2%M,\n\t\tf[i][r]=1ll*f[i][r]*I2%M;\n\t\tfor(int i=1;i<=n;i++)\n\t\tg0[i]=f[l][i],g1[i]=f[i][l],\n\t\th0[i]=f[r][i],h1[i]=f[i][r];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i!=r)tr(f[r][i],g0[i]),tr(f[i][r],g1[i]);\n\t\t\telse tr(f[r][l],g0[i]),tr(f[l][r],g1[i]);\n\t\t\tif(i!=l)tr(f[l][i],h0[i]),tr(f[i][l],h1[i]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<i;j++)tr(ans,f[i][j]);\n\tfor(int i=0;i<m;i++)tr(ans,ans);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 100010;\nll inv[MAX],fact[MAX],fi[MAX],mod = 1000000007;\nvoid inverse(){\n\tint i;\n\tinv[1] = 1;\n\tfor(i=2;i<MAX;i++){\n\t\tinv[i] = mod - (mod/i)*inv[mod%i]%mod;\n\t}\n\tfact[0] = fi[0] = 1;\n\tfor(i=1;i<MAX;i++){\n\t\tfact[i] = fact[i-1]*i%mod;\n\t\tfi[i] = (fi[i-1]*inv[i])%mod;\n\t}\n}\n\nll a[3010],dp[3010][3010] = {};\nint main(){\n\tint i,j,n,q;\n\tcin >> n >> q;\n\tfor(i=0;i<n;i++){\n\t\tcin >> a[i];\n\t}\n\tinverse();\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(a[i]>a[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\tfor(i=0;i<q;i++){\n\t\tll x,y; cin >> x >> y;\n\t\tx--; y--;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tll u = dp[x][j],v = dp[y][j];\n\t\t\tdp[x][j] = (u + v)*inv[2]%mod;\n\t\t\tdp[y][j] = (u + v)*inv[2]%mod;\n\t\t\tu = dp[j][x],v = dp[j][y];\n\t\t\tdp[j][x] = (u + v)*inv[2]%mod;\n\t\t\tdp[j][y] = (u + v)*inv[2]%mod;\n\t\t}\n\t\tll u = dp[x][y],v = dp[y][x];\n\t\tdp[x][y] = (u + v)*inv[2]%mod;\n\t\tdp[y][x] = (u + v)*inv[2]%mod;\n\t}\n\tll ans = 0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=i + 1;j<n;j++){\n\t\t\tans += dp[i][j];\n\t\t}\n\t}\n\tfor(i=0;i<q;i++){\n\t\t(ans *= 2) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1000000007;\nLL powmod(LL a, LL n){\n    if(n == 0) return 1;\n    if(n % 2) return (a*powmod(a,n-1)) % MOD;\n    LL c = powmod(a, n/2);\n    return (c*c) % MOD;\n}\nLL inv(LL a){\n    return powmod(a, MOD-2);\n}\nLL fact[110000];\nLL invfact[110000];\n\nLL ncr(LL n, LL r){\n    if(r < 0 || n < 0) return 0;\n    if(n < r) return 0;\n    LL a = fact[n];\n    a = (a * invfact[r]) % MOD;\n    a = (a * invfact[n-r]) % MOD;\n    return a;\n}\nLL inv2;\nvoid init(){\n    fact[0] = 1;\n    invfact[0] = 1;\n    inv2 = inv(2);\n    for(LL i = 1; i < 110000; i++){\n        fact[i] = (i*fact[i-1]) % MOD;\n        invfact[i] = inv(fact[i]);\n    }\n}\n\nLL prob[1000][1000]; //prob i > j\nLL temp1[1000][1000];\nLL temp2[1000][1000];\nint c, d;\nint f(int a){\n    if(a == c) return d;\n    if(a == d) return c;\n    return a;\n}\n\nint main(){\n    init();\n    int n, m;\n    cin >> n >> m;\n    int a[n];\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n        a[i]--;\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(a[i] > a[j]){\n                prob[i][j] = 1;\n            } else {\n                prob[i][j] = 0;\n            }\n        }\n    }\n\n    for(int i = 0; i < m; i++){\n        cin >> c >> d;\n        c--; d--;\n        vector<int> r, s;\n        for(int j = 0; j < n; j++){\n            r.push_back(j); s.push_back(c);\n            r.push_back(j); s.push_back(d);\n            r.push_back(c); s.push_back(j);\n            r.push_back(d); s.push_back(j);\n        }\n        for(int j = 0; j < r.size(); j++){\n            int u = r[j]; int v = s[j];\n            temp1[u][v] = prob[u][v];\n            temp2[u][v] = prob[f(u)][f(v)];\n        }\n        for(int j = 0; j < r.size(); j++){\n            int u = r[j]; int v = s[j];\n            prob[u][v] = (temp1[u][v] + temp2[u][v]) * inv2;\n            prob[u][v] %= MOD;\n        }\n    }\n    LL ans = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i < j){\n                ans += prob[i][j];\n                ans %= MOD;\n            }\n        }\n    }\n    ans = ans * powmod(2, m);\n    ans %= MOD;\n    if(ans < 0) ans += MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(x%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,Q; cin >> N >> Q;\n    vector<int> A(N);\n    for (int i=0;i<N;++i) cin >> A[i];\n    vector<vector<mint>> dp(N,vector<mint>(N,0))\n                        ,nxt(N,vector<mint>(N));\n    for (int i=0;i<N;++i){\n        for (int j=0;j<N;++j){\n            if (A[i]<A[j]){\n                dp[i][j]+=1;\n            }\n        }\n    }\n    vector<vector<int>> pre(N,vector<int>(N,0));\n    vector<mint> po(Q+1,1);\n    auto to=[](int i,int x,int y){\n        return i==x?y:(i==y?x:i);\n    };\n    auto update=[&](int i,int j,int k){\n        nxt[j][k]=0; dp[j][k]*=po[i-pre[j][k]];\n    };\n    auto add=[&](int j,int k,int x,int y){\n        int nj=to(j,x,y),nk=to(k,x,y);\n        nxt[j][k]+=dp[j][k];\n        nxt[nj][nk]+=dp[j][k];\n    };\n    for (int i=0;i<Q;++i){\n        po[i+1]=po[i]*2;\n        int X,Y; cin >> X >> Y; --X,--Y;\n        vector<int> v={X,Y};\n        for (int j=0;j<N;++j){\n            if (j==X||j==Y) continue;\n            for (int k=0;k<2;++k){\n                update(i,j,v[k]);\n                update(i,v[k],j);\n            }\n        }\n        for (int j=0;j<2;++j){\n            for (int k=0;k<2;++k){\n                update(i,v[j],v[k]);\n            }\n        }\n        for (int j=0;j<N;++j){\n            if (j==X||j==Y) continue;\n            for (int k=0;k<2;++k){\n                add(j,v[k],X,Y);\n                add(v[k],j,X,Y);\n            }\n        }\n        for (int j=0;j<2;++j){\n            for (int k=0;k<2;++k){\n                add(v[j],v[k],X,Y);\n            }\n        }\n        for (int j=0;j<N;++j){\n            for (int k=0;k<2;++k){\n                pre[j][v[k]]=pre[v[k]][j]=i+1;\n                dp[j][v[k]]=nxt[j][v[k]];\n                dp[v[k]][j]=nxt[v[k]][j];\n            }\n        }\n    }\n    mint ans=0;\n    for (int i=0;i<N;++i){\n        for (int j=0;j<i;++j){\n            ans+=dp[i][j]*po[Q-pre[i][j]];\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define int long long\nconst int mod=1e9+7;\nconst int N=3e3+2;\nusing namespace std;\nint dp[N][N],ar[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,q,m,ans=0,damn=1,prob=(mod+1)/2;\n\tcin>>n>>q;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ar[i]>ar[j]){\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=q;i++){\n\t\tdamn*=2;\n\t\tif(damn>=mod){\n\t\t\tdamn-=mod;\n\t\t}\n\t\tcin>>j>>k;\n\t\tfor(l=1;l<=n;l++){\n\t\t\tif(j!=l&&k!=l){\n\t\t\t\tm=dp[j][l];\n\t\t\t\tdp[j][l]=(dp[j][l]+dp[k][l])*prob;\n\t\t\t\tdp[j][l]%=mod;\n\t\t\t\tdp[k][l]=(m+dp[k][l])*prob;\n\t\t\t\tdp[k][l]%=mod;\n\t\t\t\tm=dp[l][k];\n\t\t\t\tdp[l][k]=(dp[l][k]+dp[l][j])*prob;\n\t\t\t\tdp[l][j]=(m+dp[l][j])*prob;\n\t\t\t\tdp[l][k]%=mod;\n\t\t\t\tdp[l][j]%=mod;\n\t\t\t}\t\n\t\t}\n\t\tdp[j][k]=dp[k][j]=(dp[j][k]+dp[k][j])*prob;\n\t\tdp[j][k]%=mod;\n\t\tdp[k][j]%=mod;\n\t}\n\t//cout<<dp[1][3]<<endl;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\t//cout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t\tans+=dp[i][j];\n\t\t\tif(ans>=mod){\n\t\t\t\tans-=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans*damn)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\n\ntemplate <class T>\nvoid read(T &x)\n{\n\tchar ch;\n\tfor (ch=getchar();(ch<'0'||ch>'9')&&ch!='-';) ch=getchar();\n\tx=0;int t=1;if (ch=='-') {ch=getchar();t=-1;}\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\tx*=t;\n}\n\nconst int mod=1000000007;\n\nint a[3010],x[3010],y[3010],pw2[3010];\nint g[3010][3010],dp[3010][3010];\n\nint main()\n{\n\tint n,q;scanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=q;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tg[i][j]=q;\n\t\t\tdp[i][j]=i<j ? 1 : 0;\n\t\t}\n\tpw2[0]=1;for (int i=1;i<=q;i++) pw2[i]=pw2[i-1]*2%mod;\n\tfor (int i=q;i;i--)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tint t=(ll(dp[x[i]][j])*pw2[g[x[i]][j]-i]+ll(dp[y[i]][j])*pw2[g[y[i]][j]-i])%mod;\n\t\t\t\tdp[x[i]][j]=dp[y[i]][j]=t;\n\t\t\t\tg[x[i]][j]=g[y[i]][j]=i-1;\n\t\t\t}\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (j!=x[i]&&j!=y[i])\n\t\t\t{\n\t\t\t\tint t=(ll(dp[j][x[i]])*pw2[g[j][x[i]]-i]+ll(dp[j][y[i]])*pw2[g[j][y[i]]-i])%mod;\n\t\t\t\tdp[j][x[i]]=dp[j][y[i]]=t;\n\t\t\t\tg[j][x[i]]=g[j][y[i]]=i-1;\n\t\t\t}\n\t\tint t=(ll(dp[x[i]][y[i]])*pw2[g[x[i]][y[i]]-i]+ll(dp[y[i]][x[i]])*pw2[g[y[i]][x[i]]-i])%mod;\n\t\tdp[x[i]][y[i]]=dp[y[i]][x[i]]=t;\n\t\t//printf(\"%d\\n\",t);\n\t\tg[x[i]][y[i]]=g[y[i]][x[i]]=i-1;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (a[i]<a[j]) ans=(ll(dp[j][i])*pw2[g[j][i]]+ans)%mod; else if (a[i]>a[j]) ans=(ll(dp[i][j])*pw2[g[i][j]]+ans)%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\n\nll mod = 1e9+7;\nconst ld error = 1e-5;\nconst ld PI = acosl(-1); //const ld PI = acosl(-1)\n\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define eq(x, y) (fabs((x)-(y))<error)\n#define bt(i) (1LL<<(i))\n\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\"\\n\"\n#define hoise cerr<<\"hoise - \"<<__LINE__<<\"\\n\"\n#define tham getchar()\nmt19937 rng((unsigned)chrono::system_clock::now().time_since_epoch().count()); //mt199937_64 for ll\n\ninline ll MOD(ll x, ll m = mod)\n{\n    ll y = x % m;\n    return (y >= 0) ? y: y+m;\n}\n\nconst int inf = 1e9;\nconst ll infl = 1e18;\nconst int nmax = 1e6+10;\n///===========================================  template  =======================================================\n\nint main(){\n    FASTIO;\n    ll inv2 = (mod + 1)/2;\n\n    int n, q;\n    cin>>n>>q;\n    vector<int> input(n+1);\n    for(int i= 1; i <=n; i++) cin>>input[i];\n    vector<vector<ll> > memo(n+1, vector<ll>(n+1)), prob;\n\n    for(int i = 1; i<=n; i++)\n        for(int j = 1; j<=n; j++)\n            if(i != j) memo[i][j] = input[i] > input[j];\n\n    ll cnt = 1;\n    for(int i = 0; i<q; i++){\n        cnt = 2*cnt % mod;\n        int x, y;\n        cin>>x>>y;\n        for(int j = 1; j<=n; j++){\n            if(j == x || j == y) continue;\n            memo[j][x] = memo[j][y] = (memo[j][x] + memo[j][y]) * inv2 % mod;\n            memo[x][j] = memo[y][j] = (memo[x][j] + memo[y][j]) * inv2 % mod;\n        }\n\n        memo[x][y] = memo[y][x] = (memo[x][y] + memo[y][x]) * inv2 % mod;\n    }\n\n    ll ans = 0;\n    for(int i = 1; i<=n; i++)\n        for(int j = i+1; j<=n; j++)\n            ans = (ans + memo[i][j]) % mod;\n\n    ans = ans*cnt % mod;\n\n    cout<<ans<<\"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nconst int _=3e3+20,yl=1e9+7;\nll f[_][_],a[_],g[_],h[_],n,q,p;\nll POW(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)res=res*x%yl;\n\t\tx=x*x%yl;y>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>q;p=POW(2,yl-2);\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i];\n\t\tfor(int j=0;j<i;++j){\n\t\t\tif(a[j]<a[i])f[i][j]=1;\n\t\t\tif(a[j]>a[i])f[j][i]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tg[i]=(f[x][i]+f[y][i])*p%yl;\n\t\t\th[i]=(f[i][x]+f[i][y])*p%yl;\n\t\t}\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(i==x||i==y)continue;\n\t\t\tf[x][i]=f[y][i]=g[i];\n\t\t\tf[i][x]=f[i][y]=h[i];\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*p%yl;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tans+=f[j][i];\n\tans=ans%yl*POW(2,q)%yl;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n    int N, Q;\n    while(cin >> N >> Q){\n        vector<int> A(N);\n        for(auto& t : A) cin >> t;\n        vector<vector<long long>> dp(N, vector<long long>(N, 0));\n        vector<vector<int>> time(N, vector<int>(N, 0));\n        vector<long long> pow2(Q+1, 0);\n        pow2[0] = 1;\n        for(int i=1;i<=Q;i++) pow2[i] = (2*pow2[i-1])%MOD;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(A[i] > A[j]) ++dp[i][j];\n            }\n        }\n        for(int i=0;i<Q;i++){\n            auto getValue = [&](int x, int y){\n                return (dp[x][y] * pow2[i - time[x][y]]) % MOD;\n            };\n            int X, Y; cin >> X >> Y;\n            --X; --Y;\n            for(int j=0;j<N;j++){\n                if(j == X || j == Y) continue;\n                auto next = (getValue(X, j) + getValue(Y, j)) % MOD;\n                dp[X][j] = dp[Y][j] = next;\n                time[X][j] = time[Y][j] = i+1;\n                next = (getValue(j, X) + getValue(j, Y)) % MOD;\n                dp[j][X] = dp[j][Y] = next;\n                time[j][X] = time[j][Y] = i+1;\n            }\n            {\n                auto next = (getValue(X, Y) + getValue(Y, X)) % MOD;\n                dp[X][Y] = dp[Y][X] = next;\n                time[X][Y] = time[Y][X] = i+1;\n            }\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                dp[i][j] = (dp[i][j] * pow2[Q-time[i][j]]) % MOD;\n            }\n        }\n        long long res = 0;\n        for(int i=0;i<N;i++){\n            for(int j=i+1;j<N;j++) res = (res + dp[i][j]) % MOD;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint a[4096];\nint dp[3005][3005];\nint dp2[3005][3005];\nint main()\n{\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(a[i]>a[j])\n\t\t\t{\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint ii=i,jj=j;\n\t\t\t\tif(ii==x)\n\t\t\t\t{\n\t\t\t\t\tii=y;\n\t\t\t\t}\n\t\t\t\telse if(ii==y)\n\t\t\t\t{\n\t\t\t\t\tii=x;\n\t\t\t\t}\n\t\t\t\tif(jj==x)\n\t\t\t\t{\n\t\t\t\t\tjj=y;\n\t\t\t\t}\n\t\t\t\telse if(jj==y)\n\t\t\t\t{\n\t\t\t\t\tjj=x;\n\t\t\t\t}\n\t\t\t\tdp2[i][j]=dp[ii][jj];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tdp[i][j]+=dp2[i][j];\n\t\t\t\tif(dp[i][j]>=1000000007)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]-=1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tans+=dp[i][j];\n\t\t\tif(ans>=1000000007)\n\t\t\t{\n\t\t\t\tans-=1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=3005,P=1e9+7,inv2=(P+1)/2;\nint n,m,f[N][N],a[N],ans,pw[N],ipw[N];\n\ninline void read(int &i){\n\ti=0;char c=getchar();bool j=0;\n\tfor(;!isdigit(c);c=getchar())if(c=='-')j=1;\n\tfor(;isdigit(c);c=getchar())i=(i<<1)+(i<<3)+c-'0';i=j?-i:i;\n}\n\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tf[i][j]=a[i]<a[j];\n\tpw[0]=1;for(int i=1;i<=m;++i)pw[i]=pw[i-1]*2%P;\n\tipw[0]=1;for(int i=1;i<=m;++i)ipw[i]=(ll)ipw[i-1]*inv2%P;\n\tfor(int t=0;t<m;++t){\n\t\tint x,y;read(x);read(y);\n\t\tf[x][y]=(ll)f[x][y]*pw[t]%P;\n\t\tf[y][x]=(ll)f[y][x]*pw[t]%P;\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%P;\n\t\tf[x][y]=f[y][x]=(ll)f[x][y]*ipw[t+1]%P;\n\t\tfor(int i=1;i<=n;++i)if(i!=x&&i!=y){\n\t\t\tf[i][x]=(ll)f[i][x]*pw[t]%P;\n\t\t\tf[i][y]=(ll)f[i][y]*pw[t]%P;\n\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])%P;\n\t\t\tf[i][x]=f[i][y]=(ll)f[i][x]*ipw[t+1]%P;\n\t\t\tf[x][i]=(ll)f[x][i]*pw[t]%P;\n\t\t\tf[y][i]=(ll)f[y][i]*pw[t]%P;\n\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])%P;\n\t\t\tf[x][i]=f[y][i]=(ll)f[x][i]*ipw[t+1]%P;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tans=(ans+(ll)f[i][j]*pw[m])%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 3009, MOD = 1e9 + 7;\n\nll dp[SZ][SZ][2];\nll n, q;\nvector<ll> vec;\n\nint main() {\n\tfastInp;\n\n\tcin >> n >> q;\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur;\n\t\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tfor (int j = i + 1; j < vec.size(); j++) {\n\t\t\tif (vec[i] < vec[j]) {\n\t\t\t\tdp[i][j][1]++;\n\t\t\t}\n\t\t\telse if (vec[i] > vec[j]) {\n\t\t\t\tdp[i][j][0]++;\n\t\t\t}\n\t\t\tif (vec[i] == vec[j]) {\n\t\t\t\tcout << 2 / 0;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tif (l > r) swap(l, r);\n\t\tvector<tuple<ll, ll, ll, ll>> add;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < l) {\n\t\t\t\tadd.push_back({ i, r, 1, dp[i][l][1] });\n\t\t\t\tadd.push_back({ i, r, 0, dp[i][l][0] });\n\n\t\t\t\tadd.push_back({ i, l, 1, dp[i][r][1] });\n\t\t\t\tadd.push_back({ i, l, 0, dp[i][r][0] });\n\t\t\t}\n\t\t\telse if (i > r) {\n\t\t\t\tadd.push_back({ i, r, 1, dp[l][i][1] });\n\t\t\t\tadd.push_back({ i, r, 0, dp[l][i][0] });\n\n\t\t\t\tadd.push_back({ i, l, 1, dp[r][i][1] });\n\t\t\t\tadd.push_back({ i, l, 0, dp[r][i][0] });\n\t\t\t}\n\t\t\telse if (i > l && i < r) {\n\t\t\t\tadd.push_back({ i, r, 0, dp[l][i][1] });\n\t\t\t\tadd.push_back({ i, r, 1, dp[l][i][0] });\n\n\t\t\t\tadd.push_back({ i, l, 0, dp[i][r][1] });\n\t\t\t\tadd.push_back({ i, l, 1, dp[i][r][0] });\n\t\t\t}\n\t\t}\n\t\tdp[l][r][1] += dp[l][r][0];\n\t\tdp[l][r][0] = dp[l][r][1];\n\t\tif (dp[l][r][1] >= MOD) dp[l][r][1] %= MOD;\n\t\tif (dp[l][r][0] >= MOD) dp[l][r][0] %= MOD;\n\n\t\tfor (auto cur : add) {\n\t\t\tll l = get<0>(cur), r = get<1>(cur), fl = get<2>(cur), vl = get<3>(cur);\n\t\t\tif (l > r) swap(l, r);\n\t\t\tdp[l][r][fl] += vl;\n\t\t\tif (dp[l][r][fl] >= MOD) dp[l][r][fl] -= MOD;\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tans += dp[i][j][0];\n\t\t\tif (ans >= MOD) ans -= MOD;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 3005\nint nex[MN][MN],lst[MN];\nunordered_map<int,int> dp[MN][MN];\nint a[MN];\nint k1[MN],k2[MN];\nlg P2[MN];\nint n,q;\nint main(){\n\tread(n);read(q);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t}\n\tP2[0]=1;\n\tfor(int i=1;i<MN;++i)P2[i]=P2[i-1]*2%Md;\n\t//cerr<<P2[1]<<endl;\n\tfor(int i=1;i<=q;++i){\n\t\tread(k1[i]);read(k2[i]);\n\t\tnex[k1[i]][lst[k1[i]]]=i;lst[k1[i]]=i;\n\t\tnex[k2[i]][lst[k2[i]]]=i;lst[k2[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)nex[i][lst[i]]=q+1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=q;++j)nex[i][j]=nex[i][j]?nex[i][j]:nex[i][j-1];\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(a[i]<a[j])++dp[1][i][j];\n\t}\n\tfor(int i=1;i<=q;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tfor(auto K:dp[i][j]){\n\t\t\t\tint k=K.ft,v=K.sd;\n\t\t\t\tint N=min(nex[j][i],nex[k][i]);\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<k<<'='<<v<<' '<<N<<' '<<P2[N-i-1]<<endl;\n\t\t\t\t//dp[i+1][j][k]=(dp[i+1][j][k]+v)%Md;\n\t\t\t\tdp[N][j][k]=(dp[N][j][k]+1ll*v*P2[N-i-1]%Md)%Md;\n\t\t\t\tint jj=j,kk=k;\n\t\t\t\tif(jj==k1[i])jj=k2[i];else if(jj==k2[i])jj=k1[i];\n\t\t\t\tif(kk==k1[i])kk=k2[i];else if(kk==k2[i])kk=k1[i];\n\t\t\t\tN=min(nex[jj][i],nex[kk][i]);\n\t\t\t\t//cerr<<j<<' '<<k<<' '<<jj<<' '<<kk<<endl;\n\t\t\t\t//dp[i+1][jj][kk]=(dp[i+1][jj][kk]+v)%Md;\n\t\t\t\tdp[N][jj][kk]=(dp[N][jj][kk]+1ll*v*P2[N-i-1]%Md)%Md;\n\t\t\t}\n\t\t}\n\t}\n\tlg res=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(auto K:dp[q+1][i]){\n\t\t\tif(K.ft<i)res+=K.sd;\n\t\t\tres%=Md;\n\t\t}\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nll P = 1000000007;\nll I = 500000004;\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 1);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 1) {\n            node[k] = (node[k] * lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1]*lazy[k])%P;\n                lazy[2*k+2] = (lazy[2*k+2]*lazy[k])%P;\n            }\n            lazy[k] = 1;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k]*x)%P;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1]+node[2*k+2])%P;\n        }\n    }\n\n    void adx(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            eval(k, l, r);\n        }else {\n            node[k] = (node[k]+x)%P;\n        }\n    }\n\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\n\n\nint main(int argc, char const *argv[]) {\n  ll n, q;std::cin >> n >> q;\n  vll a(n);re(i, n) scanf(\"%lld\", &a[i]);\n\n  vvl query = VV(q, 2, 0, ll);\n  re(i, q) {\n    scanf(\"%lld %lld\", &query[i][0], &query[i][1]);\n    query[i][0]--, query[i][1]--;\n  }\n  reverse(all(query));\n  LazySegmentTree dp(vector<ll>(10000001, 1));\n  LazySegmentTree rev(vector<ll>(10000001, 0));\n\n  for(auto v:query){\n    vvl tmp;//i, j, flip or not, num\n    ll x = min(v[0], v[1]), y = max(v[0], v[1]);\n    // x, y\n    ll adr = x*3000+y;\n    tmp.push_back(vll{x, y, 1, dp.getsum(adr, adr+1)});\n    tmp.push_back(vll{x, y, 0, rev.getsum(adr, adr+1)});\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(i<x){\n        adr = i*3000+y;\n        tmp.push_back(vll{i, x, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, x, 0, dp.getsum(adr, adr+1)});\n      }else if(y<i){\n        adr = y*3000+i;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = i*3000+y;\n        tmp.push_back(vll{x, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{x, i, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(int i=0;i<n;i++){\n      if(i==x||i==y) continue;\n      if(y<i){\n        adr = x*3000+i;\n        tmp.push_back(vll{y, i, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{y, i, 0, dp.getsum(adr, adr+1)});\n      }else if(i<x){\n        adr = i*3000+x;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }else{\n        adr = x*3000+i;\n        tmp.push_back(vll{i, y, 1, rev.getsum(adr, adr+1)});\n        tmp.push_back(vll{i, y, 0, dp.getsum(adr, adr+1)});\n      }\n    }\n    for(auto ad:tmp){\n      ll adr = ad[0]*3000+ad[1];\n      if(ad[2]==1) rev.adx(adr, adr+1, ad[3]);\n      else dp.adx(adr, adr+1, ad[3]);\n    }\n    //関係ないものは2倍\n    //xかyに関係するものはinv[2]を掛けておく\n    for(int i=0;i<n;i++){\n      if(i!=x&&i!=y){\n        dp.add(i*3000+x, i*3000+x+1, I);\n        dp.add(x*3000+i, x*3000+i+1, I);\n        rev.add(i*3000+x, i*3000+x+1, I);\n        rev.add(x*3000+i, x*3000+i+1, I);\n        dp.add(i*3000+y, i*3000+y+1, I);\n        dp.add(y*3000+i, y*3000+i+1, I);\n        rev.add(i*3000+y, i*3000+y+1, I);\n        rev.add(y*3000+i, y*3000+i+1, I);\n      }\n    }\n    dp.add(x*3000+y, x*3000+y+1, I);\n    dp.add(y*3000+x, y*3000+x+1, I);\n    rev.add(x*3000+y, x*3000+y+1, I);\n    rev.add(y*3000+x, y*3000+x+1, I);\n    dp.add(0, 10000001, 2);\n    rev.add(0, 10000001, 2);\n\n  }\n  ll ans = 0;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      ll adr = i*3000+j;\n      if(a[i]<a[j]) ans = (ans + rev.getsum(adr, adr+1))%P;\n      if(a[i]>a[j]) ans = (ans + dp.getsum(adr, adr+1))%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3050\n#define I2 500000004\n#define modu 1000000007\nusing namespace std;\ntypedef long long LL;\n\nint n,m;\nint a[maxn];\n\nLL dp[maxn][maxn];\n\nvoid init()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;++i)\n        scanf(\"%d\",&a[i]);\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            dp[i][j]=a[i]>a[j];\n}\n\nLL gx[maxn],lx[maxn];\nLL gy[maxn],ly[maxn];\n\nvoid solve()\n{\n        // for (int i=1;i<=n;++i)\n        //     for (int j=1;j<=n;++j)\n        //         printf(\"%lld%c\",dp[i][j],\" \\n\"[j==n]);\n        // cout<<endl;\n    \n    LL F=1;\n    while (m--)\n    {\n        F=F*2%modu;\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        for (int i=1;i<=n;++i)\n        {\n            gx[i]=dp[x][i],lx[i]=dp[i][x];\n            gy[i]=dp[y][i],ly[i]=dp[i][y];\n        }\n\n        int xy=dp[x][y],yx=dp[y][x];\n        dp[x][y]+=yx,dp[y][x]+=xy;\n\n        for (int i=1;i<=n;++i)\n        {\n            if (i==x||i==y) continue;\n\n            dp[x][i]+=gy[i],dp[i][x]+=ly[i];\n            dp[y][i]+=gx[i],dp[i][y]+=lx[i];\n\n            dp[x][i]%=modu,dp[i][x]%=modu;\n            dp[y][i]%=modu,dp[i][y]%=modu;\n        }\n        \n        dp[x][y]=dp[x][y]*I2%modu;\n        dp[y][x]=dp[y][x]*I2%modu;\n        for (int i=1;i<=n;++i)\n            if (i!=x&&i!=y)\n            {\n                dp[x][i]=dp[x][i]*I2%modu;\n                dp[i][x]=dp[i][x]*I2%modu;\n                dp[y][i]=dp[y][i]*I2%modu;\n                dp[i][y]=dp[i][y]*I2%modu;\n            }\n\n        // for (int i=1;i<=n;++i)\n        //     for (int j=1;j<=n;++j)\n        //         printf(\"%lld%c\",dp[i][j],\" \\n\"[j==n]);\n        // cout<<endl;\n    }\n\n    LL ans=0;\n    for (int i=1;i<=n;++i)\n        for (int j=i+1;j<=n;++j)\n            ans=(ans+dp[i][j]*F)%modu;\n    printf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int N(3005), Mod(1e9 + 7), inv2((Mod + 1) >> 1);\nint n, Q, f[N][N], a[N], Pow = 1, ans;\n\nint main()\n{\n\tn = read(), Q = read();\n\tfor (int i = 1; i <= n; i++) a[i] = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) f[i][j] = a[i] < a[j];\n\tfor (int i = 1, x, y; i <= Q; i++)\n\t{\n\t\tPow = (Pow + Pow) % Mod, x = read(), y = read();\n\t\tf[x][y] = f[y][x] = 1ll * inv2 * (f[x][y] + f[y][x]) % Mod;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (j == x || j == y) continue;\n\t\t\tf[x][j] = f[y][j] = 1ll * inv2 * (f[x][j] + f[y][j]) % Mod;\n\t\t\tf[j][x] = f[j][y] = 1ll * inv2 * (f[j][x] + f[j][y]) % Mod;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) ans = (ans + f[j][i]) % Mod;\n\tprintf(\"%lld\\n\", 1ll * ans * Pow % Mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nint p[3010],l[3010],r[3010],f[3010][3010],g[3010];\nstruct par{int x,v;}q[3010];\ninline bool cmp(const par&A,const par&B){return A.v<B.v;}\nconst int mod=1e9+7,inv2=(mod+1)/2;\nint main()\n{\n\tre int n,m,jj=1;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=1;i<=n;i++)scanf(\"%d\",&p[i]),q[i]=(par){i,p[i]};\n\tfor(re int i=1;i<=m;i++)scanf(\"%d%d\",&l[i],&r[i]);\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tf[i][i]=1;\n\t\tfor(re int j=1;j<=m;j++)f[i][l[j]]=f[i][r[j]]=(long long)(f[i][l[j]]+f[i][r[j]])*inv2%mod;\n\t}\n\tsort(q+1,q+n+1,cmp);\n\tre int ans=0;\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\twhile(jj<=n&&q[jj].v<q[i].v)\n\t\t{\n\t\t\tre int x=q[jj].x;\n\t\t\tfor(re int j=n;j;j--)g[j]=(g[j]+f[x][j])%mod;\n\t\t\tjj++;\n\t\t}\n\t\tre int x=q[i].x,qx=0;\n\t\tfor(re int j=n;j;j--)\n\t\t{\n\t\t\tans=(ans+(long long)f[x][j]*((long long)g[j]*inv2%mod+qx))%mod;\n\t\t\tqx=(qx+g[j])%mod;\n\t\t}\n\t}\n\tfor(re int i=1;i<=m;i++)ans=ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing PII = pair<int, int>;\n#define FI(i,a,b) for(int i=(a);i<=(b);++i)\n#define FD(i,b,a) for(int i=(b);i>=(a);--i)\n#define DEBUG(x) cerr << #x << \": \" << (x) << endl;\nconstexpr LL inv(LL x, LL m) { return x > m ? inv(x % m, m) : x > 1 ? inv(m % x, m) * (m - m / x) % m : x; }\nconstexpr LL mpow(LL a, LL k, LL m) { LL r(1); for (a %= m; k; k >>= 1, a = a * a % m) if (k & 1)r = r * a % m; return r; }\n\nconst int N = 3005, M = 1e9 + 7;\nint n, q, A[N], X[N], Y[N], F[N][N];\nint div2(int x) { return 1LL * x * (M + 1) /  2 % M; }\nint mmul(int a, int b) { return 1LL * a * b % M; }\nint madd(int a, int b) { return (a + b) % M; }\n\nint main() {\n    scanf(\"%d%d\", &n, &q);\n    FI(i, 1, n) scanf(\"%d\", A + i);\n    FI(i, 1, n) FI(j, 1, n) if (A[i] > A[j]) F[i][j] = 1;\n    FI(tt, 1, q) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        int tx[N], fx[N];\n        FI(i, 1, n) {\n            if (i == x || i == y) continue;\n            tx[i] = div2(madd(F[i][x], F[i][y]));\n            fx[i] = div2(madd(F[x][i], F[y][i]));\n        }\n        FI(i, 1, n) {\n            if (i == x || i == y) continue;\n            F[i][x] = F[i][y] = tx[i];\n            F[x][i] = F[y][i] = fx[i];\n        }\n        F[x][y] = F[y][x] = div2(madd(F[x][y], F[y][x]));\n    }\n    int tt = mpow(2, q, M);\n    int ans = 0;\n    FI(i, 1, n) FI(j, i + 1, n) {\n        ans = madd(ans, int(1LL * tt * F[i][j] % M));\n    }\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 1000000007LL\n\nll f[3010][3010];\nint num[3010],n,m;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll ksm(ll x,ll y) { ll res=1;for (;y;y>>=1,x=x*x%mod) if (y&1) res=res*x%mod;return res; }\n\nconst ll inv2=ksm(2,mod-2);\n\nint main()\n{\n\tn=rd();m=rd();\n\tfor (int i=1;i<=n;i++) num[i]=rd();\n\tfor (int i=1;i<=n;i++) for (int j=1;j<=n;j++) f[i][j]=(num[i]>num[j]);\n\tll hhh=ksm(2,m);\n\twhile (m--)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%mod;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (i==x||i==y) continue;\n\t\t\tf[x][i]=f[y][i]=(f[x][i]+f[y][i])*inv2%mod;\n\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*inv2%mod;\n\t\t}\n\t}\n\tll ans=0;\n\tfor (int i=1;i<n;i++) for (int j=i+1;j<=n;j++) ans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",ans*hhh%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nint n,q,a[N],x,y;\nint now = 1,las = 0;\nll f[N][N],inv2;\nll qp(ll a,ll b) { ll ret = 1; for(;b;b>>=1,a = a * a % mod) if(b & 1) ret = ret * a % mod; return ret; }\n\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",a + i);\n\tinv2 = qp(2,mod - 2);\n\tll qpn = qp(2,q);\n\tfor(int i=1;i<=n;++i)\n\t  for(int j=1;j<=n;++j)\n\t    if(a[i] > a[j]) f[i][j] = 1;\n\twhile(q--)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tswap(now,las);\n\t\tfor(int i=1;i<=n;++i) \n\t\t{\n\t\t\tif(i == x || i == y) continue;\n\t\t\tf[i][x] = f[i][y] = (f[i][x] + f[i][y]) % mod * inv2 % mod;\n\t\t\tf[x][i] = f[y][i] = (f[x][i] + f[y][i]) % mod * inv2 % mod;\n\t\t}\n\t\tf[y][x] = f[x][y] = (f[x][y] + f[y][x]) % mod * inv2 % mod;\n\t}\n\tll ans = 0;\n\tfor(int i=1;i<=n;++i)\n\t  for(int j=i + 1;j<=n;++j)\n\t     ans = (ans + f[i][j] * qpn % mod) % mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n\nusing namespace std;\n\nconst int maxn=3010;\nconst int mo=1000000007;\n\nint n,m,f[maxn][maxn],z[maxn];\n\nint mul(int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=1ll*ans*a%mo;\n\t\ta=1ll*a*a%mo;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int a=1;a<=n;a++)\n\t\tscanf(\"%d\",&z[a]);\n\tfor (int a=1;a<=n;a++)\n\t\tfor (int b=1;b<=n;b++)\n\t\t\tf[a][b]=(z[a]<z[b]);\n\tint div2=mul(2,mo-2);\n\tfor (int a=1;a<=m;a++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*div2%mo;\n\t\tfor (int b=1;b<=n;b++)\n\t\t\tif (b!=x && b!=y)\n\t\t\t{\n\t\t\t\tf[b][x]=f[b][y]=1ll*(f[b][x]+f[b][y])*div2%mo;\n\t\t\t\tf[x][b]=f[y][b]=1ll*(f[x][b]+f[y][b])*div2%mo;\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor (int a=1;a<=n;a++)\n\t\tfor (int b=a+1;b<=n;b++)\n\t\t{\n\t\t\tans += f[b][a];\n\t\t\tif (ans>=mo) ans-=mo;\n\t\t}\n\tprintf(\"%d\\n\",ans*mul(2,m)%mo);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int N = 3002;\nconst int MOD = int(1e9 + 7);\nconst ll R2 = (MOD + 1) / 2;\n\nll f[N][N];\nint a[N];\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            f[i][j] = a[i] < a[j];\n        }\n    }\n\n    ll mul = 1;\n\n    for (int i = 0; i < q; ++i) {\n        mul = (mul * 2) % MOD;\n        int x, y;\n        cin >> x >> y;\n\n        for (int j = 1; j <= n; ++j) {\n            if (j != x && j != y) {\n                f[j][x] = f[j][y] = (f[j][x] + f[j][y]) * R2 % MOD;\n                f[x][j] = f[y][j] = (f[x][j] + f[y][j]) * R2 % MOD;\n            }\n        }\n\n        f[x][y] = f[y][x] = (f[x][y] + f[y][x]) * R2 % MOD;\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) {\n            ans += f[i][j];\n        }\n    }\n\n    ans %= MOD;\n\n    cout << (ans * mul) % MOD << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<iomanip>\n#include<cstdlib>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<set>\n#include<climits>\n#include<cassert>\n#include<iterator>\n#include<random>\n#include<bitset>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<map>\n#include<ctime>\n#include<complex>\n#include<functional>\n#include<unordered_set>\n#include<unordered_map>\n\nusing namespace std;\n\nint dp[3002][3002][2][2];\nbool use[3002][3002][2][2];\n\npair<int, int> query[3002];\n\n\nint n;\nint q;\n\nvector<int> v;\n\nint nex[3002][3002];\n\n\n#define MOD 1000000007\n\nint p2[3002];\n\ninline int mul(long long int a, int b) {\n\ta *= p2[b];\n\tif (a >= MOD)a %= MOD;\n\treturn a;\n}\n\ninline int dfs(int cur, int pos, bool whi, bool flag) {\n\tif (cur == q) {\n\t\treturn flag;\n\t}\n\tif (use[cur][pos][whi][flag])return dp[cur][pos][whi][flag];\n\tuse[cur][pos][whi][flag] = true;\n\tint A;\n\tint B = pos;\n\tif (whi == 0) {\n\t\tA = query[cur].first;\n\t}\n\telse {\n\t\tA=query[cur].second;\n\t}\n\t//nothing\n\tint go = min(nex[A][cur + 1], nex[B][cur + 1]); \n\tint ne1 = A;\n\tint ne2 = B;\n\tif (go == nex[B][cur + 1]) {\n\t\tswap(ne1, ne2);\n\t}\n\tbool newhi = (query[go].second == ne1);\n\tdp[cur][pos][whi][flag] += mul(dfs(go, ne2, newhi, flag),go-cur-1);\n\tif (dp[cur][pos][whi][flag] >= MOD)dp[cur][pos][whi][flag] -= MOD;\n\t//do\n\tbool z1 = (A < B);\n\tif (A == query[cur].first)A = query[cur].second;\n\telse A = query[cur].first;\n\tif (B == A) {\n\t\tif (B == query[cur].first)B = query[cur].second;\n\t\telse B = query[cur].first;\n\t}\n\tbool z2 = (A < B);\n\tbool nex_flag = flag;\n\tif (z1 != z2) {\n\t\tnex_flag ^= true;\n\t}\n\tgo = min(nex[A][cur + 1], nex[B][cur + 1]);\n\tne1 = A;\n\tne2 = B;\n\tif (go == nex[B][cur + 1]) {\n\t\tswap(ne1, ne2);\n\t}\n\tnewhi = (query[go].second == ne1);\n\tdp[cur][pos][whi][flag] += mul(dfs(go, ne2, newhi, nex_flag),go-cur-1);\n\tif (dp[cur][pos][whi][flag] >= MOD)dp[cur][pos][whi][flag] -= MOD;\n\treturn dp[cur][pos][whi][flag];\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\tv.push_back(a);\n\t}\n\tmemset(nex, -1, sizeof(nex));\n\tfor (int i = 0; i < n; i++) {\n\t\tnex[i][q] = q;\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tquery[i] = make_pair(a, b);\n\t\tnex[a][i] = i;\n\t\tnex[b][i] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = q - 1; j >= 0; j--) {\n\t\t\tif (nex[i][j] == -1) {\n\t\t\t\tnex[i][j] = nex[i][j + 1];\n\t\t\t}\n\t\t}\n\t}\n\tp2[0] = 1;\n\tfor (int i = 1; i < 3002; i++) {\n\t\tp2[i] = p2[i - 1] * 2;\n\t\tif (p2[i] >= MOD)p2[i] %= MOD;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (v[i] != v[j]) {\n\t\t\t\tint A = i;\n\t\t\t\tint B = j;\n\t\t\t\tint go = min(nex[A][0], nex[B][0]);\n\t\t\t\tint ne1 = A;\n\t\t\t\tint ne2 = B;\n\t\t\t\tif (go == nex[B][0]) {\n\t\t\t\t\tswap(ne1, ne2);\n\t\t\t\t}\n\t\t\t\tbool newhi = (query[go].second == ne1);\n\t\t\t\tans += mul(dfs(go, ne2, newhi, (v[i]>v[j])),go);\n\t\t\t\tif (ans >= MOD)ans -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\ninline int rd(){\n    int x=0,p=1;\n    char a=getchar();\n    while((a<48||a>57)&&a!='-')a=getchar();\n    if(a=='-')p=-p,a=getchar();\n    while(a>47&&a<58)x=(x<<1)+(x<<3)+(a&15),a=getchar();\n    return x*p;\n}\nconst int N=3002;\nconst ll mod=1e9+7;\nint n,q;\nint a[N];\nll f[N][N],ans;\ninline ll fpow(ll b,ll p=mod-2){\n\tll ans=1,tmp=b;\n\twhile(p){\n\t\tif(p&1)ans=ans*tmp%mod;\n\t\ttmp=tmp*tmp%mod;\n\t\tp>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=rd(),q=rd();\n\tfor(int i=1;i<=n;i++)a[i]=rd();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j];\n\tll inv=fpow(2);\n\tfor(int i=1,x,y;i<=q;i++){\n\t\tx=rd(),y=rd();\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])%mod*inv%mod;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(j!=x&&j!=y){\n\t\t\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])%mod*inv%mod;\n\t\t\t\tf[j][x]=f[j][y]=(f[j][x]+f[j][y])%mod*inv%mod;\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])%mod;\n\tprintf(\"%lld\\n\",ans*fpow(2,q)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\ntypedef long long ll;\ntypedef long double  ld;\n#define pii pair<ll,ll> \n#define pic pair<ll,char>\n#define vi vector< ll > \n#define vvi vector< vi > \n#define vpi vector< pii > \n#define vvpi vector< vpi > \n#define st  set <ll, greater <ll> >\n#define mst  multiset <ll, greater <ll> >\n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define mapp  unordered_map <ll, ll>\n#define ppii pair< pii, pii > \n#define test(t) ll t;cin>>t;while(t--)\n#define inarr(n) ll arr[n];for(ll i=0;i<n;i++)cin>>arr[i];\n#define ingra(m) vvi arr(100005);for(ll i=0;i<m;i++){ll u,v;cin>>u>>v;arr[u].pb(v);arr[v].pb(u);}\n#define mem(a,b) memset(a,b,sizeof(a))\n#define inn freopen(\"input.txt\", \"r\", stdin)\n#define outt freopen(\"output.txt\", \"w\", stdout)\n#define all(arr) arr.begin(),arr.end()\nll power(ll x,ll y){ll res = 1;while(y){if(y&1) res = (res*x)%mod;y=y/2,x=(x*x)%mod;}return res%mod;}\nll dp[3001][3001];\nll arr[3001];\nsigned main()\n{\n    fast;\n    ll n,q,i,j;\n    cin>>n>>q;\n    ll tot = power(2,q);\n    for(i=1;i<=n;i++)\n        cin>>arr[i];\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n;j++)\n        {\n            if(arr[i]>arr[j])\n                dp[i][j] = tot;\n        }\n    }\n    ll inv = power(2,mod-2);\n    while(q--)\n    {\n        ll x,y;\n        cin>>x>>y;\n        if(arr[x]==arr[y])\n            continue;\n        for(i=1;i<=n;i++)\n        {\n            if(i!=x and i!=y)\n            {\n                dp[i][x] = inv*(dp[i][x]+dp[i][y])%mod;\n                dp[i][y] = dp[i][x];\n                dp[x][i] = inv*(dp[x][i]+dp[y][i])%mod;\n                dp[y][i] = dp[x][i];\n            }\n        }\n        dp[x][y] = inv*(dp[x][y]+dp[y][x])%mod;\n        dp[y][x] = dp[x][y];\n    }\n    ll ans = 0;\n    for(i=1;i<=n;i++)\n        for(j=i+1;j<=n;j++)\n            ans+=dp[i][j],ans%=mod;\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<assert.h>\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define fd(i,b,a) for(int i=(b);i>=(a);--i)\n#define mset(a,x) memset(a,x,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(b))\nusing namespace std;\ntypedef long long ll;\nint read(){int n=0,p=1;char ch;for(ch=getchar();ch<'0' || ch>'9';ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=3005,mo=1e9+7,iv2=5e8+4;\nint n,a[N];\nll f[N][N],tf[N][N];\nvoid inc(ll &x,ll y){x=(x+y)%mo;}\nint main()\n{\n\tn=read();int Q=read();\n\tfo(i,1,n) a[i]=read();\n\tfo(i,1,n)\n\t\tfo(j,1,n) f[i][j]=(a[i]>a[j]);\n\tfo(k,1,Q)\n\t{\n\t\tint x=read(),y=read();\n\t\tfo(i,1,n)\n\t\t\tif(i!=x && i!=y)\n\t\t\t\tf[i][x]=f[i][y]=(f[i][x]+f[i][y])*iv2%mo,f[x][i]=f[y][i]=(f[x][i]+f[y][i])*iv2%mo;\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*iv2%mo;\n\t}\n\tll ans=0;\n\tfo(i,1,n-1)\n\t\tfo(j,i+1,n) inc(ans,f[i][j]);\n\tfo(i,1,Q) ans=ans*2%mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v((a %= mod) < 0 ? a + mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<MOD>;\nmint rec[3010][3010];\n\nsigned main() {\n    int N, Q; cin >> N >> Q;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n    mint inv = mint(1) / mint(2);\n    \n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(A[i] == A[j]) rec[i][j] = inv;\n            if(A[i] <  A[j]) rec[i][j] = mint(0);\n            if(A[i] >  A[j]) rec[i][j] = mint(1);\n        }\n    }\n\n    mint mul = mint(2).pow(Q);\n    while(Q--) {\n        int x, y; cin >> x >> y; x--; y--;\n\n        // x < y にする\n        if(x > y) swap(x, y);\n        \n        map< pair<int, int>, mint > memo;\n        \n        // (i, x, y) -> (i, y, x)\n        // (i, x) -> (i, y), (i, y) -> (i, x) と変える\n        for(int i=0; i<x; i++) {\n            memo[ make_pair(i, y) ] += rec[i][x] * inv;\n            memo[ make_pair(i, x) ] += rec[i][x] * inv;\n            memo[ make_pair(i, x) ] += rec[i][y] * inv;\n            memo[ make_pair(i, y) ] += rec[i][y] * inv;\n        }\n        \n        // (x, i, y) -> (y, i, x)\n        // (x, i) -> (y, i), (i, y) -> (i, x) と変える\n        for(int i=x+1; i<y; i++) {\n            memo[ make_pair(x, i) ] += (mint(1) - rec[i][y]) * inv;\n            memo[ make_pair(x, i) ] += rec[x][i] * inv;\n            memo[ make_pair(i, y) ] += (mint(1) - rec[x][i]) * inv;\n            memo[ make_pair(i, y) ] += rec[i][y] * inv;\n        }\n        \n        // (x, y, i) -> (y, x, i)\n        // (x, i) -> (y, i), (y, i) -> (x, i) と変える\n        for(int i=y+1; i<N; i++) {\n            memo[ make_pair(y, i) ] += rec[x][i] * inv;\n            memo[ make_pair(x, i) ] += rec[x][i] * inv;\n            memo[ make_pair(x, i) ] += rec[y][i] * inv;\n            memo[ make_pair(y, i) ] += rec[y][i] * inv;\n        }\n        \n        // x, y -> y, x\n        {\n            memo[ make_pair(x, y) ] += rec[x][y] * inv;\n            memo[ make_pair(x, y) ] += (mint(1) - rec[x][y]) * inv;\n        }\n\n        for(auto p : memo) {\n            int u, v; tie(u, v) = p.first;\n            mint val = p.second;\n            rec[u][v] = val;\n        }\n    }\n\n    mint ans(0);\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            ans += rec[i][j];\n        }\n    }\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(A[i] == A[j]) ans -= inv;\n        }\n    }\n    ans *= mul;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for (ll i = 0; i < n; i++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long ll;\n\nlong long pow_mod(long long n, long long k, long long mod) {\n    long long ret = 1, a = n % mod;\n    while (k > 0) {\n        if (k & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        k >>= 1;\n    }\n    return ret;\n}\n\nlong long inv_mod(long long n, long long mod) {\n    long long a = n % mod, b = mod - 2, ret = 1;\n    while (b > 0) {\n        if (b & 1) ret = (ret * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ret;\n}\n\nconst ll MOD = 1000000007LL;\nll N,Q;\nll A[3010];\nll X[3010];\nll Y[3010];\n\nll dp[3010][3010];\n\nint main ()\n{\n    cin >> N >> Q;\n    REP(i,N) cin >> A[i + 1];\n    REP(i,Q) cin >> X[i] >> Y[i];\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dp[i][j] = (A[i] > A[j]);\n        }\n    }\n\n    ll inv2 = inv_mod(2LL, MOD);\n    for (int i = 0; i < Q; i++) {\n        dp[X[i]][Y[i]] = dp[Y[i]][X[i]] = ((dp[X[i]][Y[i]] + dp[Y[i]][X[i]]) * inv2) % MOD;\n        for (int j = 1; j <= N; j++) {\n            if (X[i] != j && Y[i] != j) {\n                dp[X[i]][j] = dp[Y[i]][j] = ((dp[X[i]][j] + dp[Y[i]][j]) * inv2) % MOD;\n                dp[j][X[i]] = dp[j][Y[i]] = ((dp[j][X[i]] + dp[j][Y[i]]) * inv2) % MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i; j <= N; j++) {\n            ans += dp[i][j];\n        }\n    }\n\n    cout << (ans * pow_mod(2LL, Q, MOD)) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Query {\n  int i1, i2;\n};\n\nconstexpr int64 P = 1000000007;\n\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, num_queries;\n  cin >> n >> num_queries;\n  vector<int> xs(n);\n  for (int i = 0; i < n; i++) cin >> xs[i];\n\n  FiniteField total = 1;\n  for (int i = 0; i < num_queries; i++) total *= 2;\n\n  auto dp = Make2DVector<FiniteField>(n, n, 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (xs[i] > xs[j]) {\n        dp[i][j] = total;\n      }\n    }\n  }\n\n  auto half = FiniteField(1) / 2;\n  for (int i = 0; i < num_queries; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    for (int k = 0; k < n; k++) {\n      if (k == x || k == y) continue;\n      dp[x][k] = dp[y][k] = (dp[x][k] + dp[y][k]) * half;\n      dp[k][x] = dp[k][y] = (dp[k][x] + dp[k][y]) * half;\n    }\n    dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * half;\n  }\n\n  FiniteField solution = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      solution += dp[i][j];\n    }\n  }\n  cout << solution.Value() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=3005;\nconst int mo=1000000007;\nint n,Q,a[N],f[N][N],ans;\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tFor(i,1,n) For(j,1,n) f[i][j]=(a[i]>a[j]);\n\tFor(i,1,Q){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tFor(p,1,n) if (p!=x&&p!=y){\n\t\t\tf[x][p]=f[y][p]=1ll*(f[x][p]+f[y][p])*(mo+1)/2%mo;\n\t\t\tf[p][x]=f[p][y]=1ll*(f[p][x]+f[p][y])*(mo+1)/2%mo;\n\t\t}\n\t\tf[x][y]=f[y][x]=1ll*(f[x][y]+f[y][x])*(mo+1)/2%mo;\n\t}\n\tFor(i,1,n) For(j,i+1,n)\n\t\tans=(ans+f[i][j])%mo;\n\tFor(i,1,Q) ans=1ll*ans*2%mo;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long double ldb ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 3e3 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1e9 + 7 ;\nconst db eps = 1e-10 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, q;\n\nll a[maxn], x[maxn], y[maxn];\n\nll f[maxn][maxn], ans;\n\nll inv = 5e8 + 4;\n\nsigned main()\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\trep(i, 1, n) scanf(\"%lld\", &a[i]);\n\trep(i, 1, q) scanf(\"%lld %lld\", &x[i], &y[i]);\n\trep(i, 1, n) rep(j, 1, n) f[i][j] = a[i] > a[j];\n\trep(i, 1, q)\n\t{\n\t\tll u = x[i], v = y[i];\n\t\tf[v][u] = f[u][v] = inv * (f[u][v] + f[v][u]) % mod;\n\t\trep(j, 1, n)\n\t\t{\n\t\t\tif(j == u || j == v)  continue;\n\t\t\tf[v][j] = f[u][j] = inv * (f[u][j] + f[v][j]) % mod;\n\t\t\tf[j][v] = f[j][u] = inv * (f[j][u] + f[j][v]) % mod;\n\t\t}\n\t}\n\trep(i, 1, n) rep(j, i + 1, n) (ans += f[i][j]) %= mod;\n\trep(i, 1, q) (ans *= 2) %= mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nstruct hash_table {\n\tint lst[50000005], val[50000005], pre[50000005], tot;\n\tll to[50000005];\n\thash_table() { clear(); }\n\tinline void clear()\n\t{\n\t\tmemset(lst, -1, sizeof(lst));\n\t\ttot = 0;\n\t}\n\tinline int &operator [](const ll &x)\n\t{\n\t\tint idx = x % 49260817;\n\t\tfor (int i = lst[idx]; ~i; i = pre[i]) {\n\t\t\tif (to[i] == x) {\n\t\t\t\treturn val[i];\n\t\t\t}\n\t\t}\n\t\tto[tot] = x;\n\t\tpre[tot] = lst[idx];\n\t\tval[tot] = -1;\n\t\tlst[idx] = tot;\n\t\treturn val[tot++];\n\t}\n} mem;\nint nxt[3005][3005], arr[3005], lst[3005], n, m;\nint qx[3005], qy[3005], pw[3005];\nint solve(int p, int x, int y)\n{\n\tint t = p == -1 ? -1 : std::max(nxt[p][x], nxt[p][y]), coef = pw[p - t];\n\tp = t;\n\tif (p == -1) {\n\t\treturn (arr[x] > arr[y]) * coef;\n\t}\n\tint &res = mem[(ll)p * n * n + x * n + y];\n\tif (~res) {\n\t\treturn res;\n\t}\n\tres = solve(p - 1, x, y);\n\tif ((qx[p] == x && qy[p] == y) || (qy[p] == x && qx[p] == y)) {\n\t\tres += solve(p - 1, y, x);\n\t} else if (qx[p] == x || qy[p] == x) {\n\t\tres += solve(p - 1, qx[p] ^ qy[p] ^ x, y);\n\t} else if (qx[p] == y || qy[p] == y) {\n\t\tres += solve(p - 1, x, qx[p] ^ qy[p] ^ y);\n\t}\n\treturn res = (ll)res * coef % MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tpw[0] = 1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tpw[i] = pw[i - 1] * 2 % MOD;\n\t}\n\tmemset(lst, -1, sizeof(lst));\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", qx + i, qy + i);\n\t\tqx[i]--;\n\t\tqy[i]--;\n\t\tlst[qx[i]] = lst[qy[i]] = i;\n\t\tmemcpy(nxt[i], lst, sizeof(lst));\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t(ans += solve(m - 1, i, j)) %= MOD;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nusing pi = pair<ll, ll>;\nconst int maxn = 3e3 + 33, mod = 1e9 + 7;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int half = 500000004;\nint n, q, a[maxn], dp[maxn][maxn], eq[maxn][maxn];\nvector<pair<pi, int>> upd, upd2;\nvoid process(int x, int y) {//update dp[x][i]\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i==y||i==x) continue;\n\t\tupd.pb({{x, i}, (dp[x][i] + dp[y][i])*1ll*half%mod});\n\t\tupd.pb({{i, x}, (dp[i][x] + dp[i][y])*1ll*half%mod});\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i==y||i==x) continue;\n\t\tupd2.pb({{x, i}, (eq[x][i] + eq[y][i])*1ll*half%mod});\n\t\tupd2.pb({{i, x}, (eq[i][x] + eq[i][y])*1ll*half%mod});\n\t}\n}\nvoid apply() {\n\tfor(auto i : upd)\n\t\tdp[i.first.first][i.first.second] = i.second;\n\tupd.clear();\n\tfor(auto i : upd2)\n\t\teq[i.first.first][i.first.second] = i.second;\n\tupd2.clear();\n}\nvoid compress() {\n\tvi t;\n\tfor(int i = 1; i <= n; i++) t.pb(a[i]);\n\tsort(all(t));\n\tfor(int i = 1; i <= n; i++) a[i] = lower_bound(all(t), a[i]) - t.begin() + 1;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> q;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tcompress();\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tdp[i][j] = a[i] < a[j];\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\teq[i][j] = a[i] == a[j];\n\t\n\tll pw = 1;\n\tfor(int i = 0; i < q; i++) pw = (pw<<1)%mod;\t\t\n\t\n\tint x, y;\n\twhile(q--) {\n\t\tcin >> x >> y;\n\t\tprocess(x, y);\n\t\tprocess(y, x);\n\t\tapply();\n\t\tdp[x][y] = dp[y][x] = (mod+1-eq[x][y])*1ll*half%mod;\n\t}\n\tll ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i+1; j <= n; j++) {\n\t\t\t(ans += dp[j][i])%=mod;\n\t\t}\n\tcout << pw*ans%mod;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n} read;\n\nconst int maxn = 3030, mod = 1000000007;\nint a[maxn];\nll f[maxn][maxn];\n\nint main () {\n\tint n = read, q = read;\n\tfor (int i = 1; i <= n; i ++) a[i] = read;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tf[i][j] = a[i] > a[j];\n\n\tll coe = 1, i2 = (mod + 1) >> 1;\n\twhile (q --) {\n\t\tint x = read, y = read;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tif (i != x and i != y)\n\t\t\t\tf[i][y] = f[i][x] = i2 * (f[i][x] + f[i][y]) % mod;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tif (i != x and i != y)\n\t\t\t\tf[y][i] = f[x][i] = i2 * (f[x][i] + f[y][i]) % mod;\n\t\tf[y][x] = f[x][y] = i2 * (f[x][y] + f[y][x]) % mod;\n\t\t(coe <<= 1) %= mod;\n\t}\n\n\t/* for (int i = 1; i <= n; i ++) { */\n\t/* \tfor (int j = 1; j <= n; j ++) */\n\t/* \t\tdebug(\" %lld\", f[i][j]); */\n\t/* \tdebug(\"\\n\"); */\n\t/* } */\n\n\tll sum = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = i + 1; j <= n; j ++)\n\t\t\tsum += f[i][j];\n\tsum %= mod;\n\tprintf(\"%lld\\n\", sum * coe % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pdi = pair<double, int>;\ntemplate <class T> using mat = vector<vector<T>>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\n\n#define each(i,v) for (auto i = begin(v); i != end(v); ++i)\n#define reach(i,v) for (auto i = rbegin(v); i != rend(v); ++i)\n#define urep(i,s,t) for (int i = (s); i <= (t); ++i)\n#define drep(i,s,t) for (int i = (s); i >= (t); --i)\n#define rep(i,n) urep(i, 0, (n)-1)\n#define rep1(i,n) urep(i, 1, (n))\n#define rrep(i,n) drep(i, (n)-1, 0)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define front fro\n#define back bac\n#define vct vector\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper(uint_fast8_t prec) {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout << fixed << setprecision(prec);\n#ifdef Local\n        auto print_atexit = []() { cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\"; };\n        atexit(print_atexit);\n#endif\n    }\n} setuppre_obj(10);\n\nnamespace std {\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> ostream& operator << (ostream& s, pair<T,U> p) { return s << p.fir << \" \" << p.sec; }\ntemplate <class T> ostream& operator << (ostream& s, vct<T> v) { each(i,v) { if(i != begin(v)) s << \" \"; s << *i; } return s; }\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\nconst auto add = [](auto &x, auto y) { x += y; };\nconst auto mul = [](auto &x, auto y) { x *= y; };\nconst auto lam_min = [](auto x, auto y) { return min(x, y); };\nconst auto lam_max = [](auto x, auto y) { return max(x, y); };\nconst auto chmax = [](auto &m, auto x) { if(m < x){ m = x; return true; } return false; };\nconst auto chmin = [](auto &m, auto x) { if(m > x){ m = x; return true; } return false; };\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binsr(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> T cmprs(T &v) {\n    T tmp = v, ret = v;\n    sort(all(tmp));\n    tmp.erase(unique(all(tmp)), end(tmp));\n    each(i,ret) *i = l_bnd(all(tmp),*i) - begin(tmp);\n    return ret;\n}\n\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / 2 - 1;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double gold = 1.618033988;\nconstexpr long double eps = 1e-15;\nconstexpr uint_fast64_t mod = 1e9 + 7;\n\nint n,Q;\npair<i64,i64> up[1<<12][1<<12],dw[1<<12][1<<12];\nint last[1<<12][1<<12];\ni64 two[1<<12];\n\nvoid upd(int i,int j,int t) {\n    if(t==last[i][j]) return;\n    up[i][j].fir=up[i][j].fir*two[t-1-last[i][j]]%mod;\n    dw[i][j].fir=dw[i][j].fir*two[t-1-last[i][j]]%mod;\n    last[i][j]=t;\n    return;\n}\n\nint main() {\n    cin>>n>>Q;\n    int a[1<<12];\n    for(int i=0; i<n; i++) cin>>a[i];\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            if(a[i]>a[j]) up[j][i].fir++;\n            if(a[j]>a[i]) dw[j][i].fir++;\n            last[j][i]=-1;\n        }\n    }\n\n    two[0]=1;\n    for(int i=0; i<Q; i++) two[i+1]=two[i]*2%mod;\n\n    for(int i=0; i<Q; i++) {\n        int x,y;\n        cin>>x>>y;\n        if(--x > --y) swap(x,y);\n\n        for(int j=0; j<x; j++) {\n            upd(j,y,i);\n            upd(j,x,i);\n            dw[j][y].sec+=dw[j][x].fir;\n            up[j][y].sec+=up[j][x].fir;\n            dw[j][x].sec+=dw[j][y].fir;\n            up[j][x].sec+=up[j][y].fir;\n        }\n        for(int j=y+1; j<n; j++) {\n            upd(x,j,i);\n            upd(y,j,i);\n            dw[y][j].sec+=dw[x][j].fir;\n            up[y][j].sec+=up[x][j].fir;\n            dw[x][j].sec+=dw[y][j].fir;\n            up[x][j].sec+=up[y][j].fir;\n        }\n        for(int j=x+1; j<y; j++) {\n            upd(j,y,i);\n            upd(x,j,i);\n            dw[j][y].sec+=up[x][j].fir;\n            up[j][y].sec+=dw[x][j].fir;\n            dw[x][j].sec+=up[j][y].fir;\n            up[x][j].sec+=dw[j][y].fir;\n        }\n        {\n            upd(x,y,i);\n            up[x][y].sec+=dw[x][y].fir;\n            dw[x][y].sec+=up[x][y].fir;\n        }\n        for(int j=0; j<n; ++j) {\n            if(j!=x) {\n                upd(min(j,x),max(j,x),i);\n                (up[min(j,x)][max(j,x)].fir+=up[min(j,x)][max(j,x)].sec)%=mod;\n                (dw[min(j,x)][max(j,x)].fir+=dw[min(j,x)][max(j,x)].sec)%=mod;\n            }\n            if(j!=y and j!=x) {\n                upd(min(j,y),max(j,y),i);\n                (up[min(j,y)][max(j,y)].fir+=up[min(j,y)][max(j,y)].sec)%=mod;\n                (dw[min(j,y)][max(j,y)].fir+=dw[min(j,y)][max(j,y)].sec)%=mod;\n            }\n        }\n        for(int j=0; j<n; ++j) {\n            if(j!=x) dw[min(j,x)][max(j,x)].sec=0;\n            if(j!=x) up[min(j,x)][max(j,x)].sec=0;\n            if(j!=y) dw[min(j,y)][max(j,y)].sec=0;\n            if(j!=y) up[min(j,y)][max(j,y)].sec=0;\n        }\n    }\n\n    int ans=0;\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<i; j++) {\n            upd(j,i,Q);\n            ans=(ans+dw[j][i].fir)%mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1e9+7;\nconst int inv2=(mod+1)/2;\nint qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nconst int N=3000+10;\n\nint n,q,a[N],x[N],y[N],dp[N][N];\n\nint main() {\n    n=read(),q=read();\n    for (int i=1;i<=n;++i) a[i]=read();\n    for (int i=1;i<=q;++i) x[i]=read(),y[i]=read();\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            dp[i][j]=a[i]>a[j];\n    for (int i=1;i<=q;++i) {\n        int u=x[i],v=y[i];\n        dp[u][v]=dp[v][u]=1ll*(dp[u][v]+dp[v][u])*inv2%mod;\n        for (int j=1;j<=n;++j) {\n            if (j==u||j==v) continue;\n            dp[u][j]=dp[v][j]=1ll*(dp[u][j]+dp[v][j])*inv2%mod;\n            dp[j][u]=dp[j][v]=1ll*(dp[j][u]+dp[j][v])*inv2%mod;\n        }\n    }\n    int ans=0;\n    for (int i=1;i<=n;++i)\n        for (int j=i+1;j<=n;++j)\n            ans=(ans+dp[i][j])%mod;\n    printf(\"%lld\\n\",1ll*ans*qpow(2,q)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    ll p2=1;\n    rep(i,q)p2=p2*2%mod;\n    ll inv2=(mod+1)/2;\n    int a[n];\n    rep(i,n)cin>>a[i];\n    ll dp[n][n];\n    rep(i,n)rep(j,n)dp[i][j]=(a[i]>a[j] ? p2 : 0 );\n    rep(i,q){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        dp[x][y]=dp[y][x]=(dp[x][y]+dp[y][x])*inv2%mod;\n        rep(j,n){\n            if(j==x||j==y)continue;\n            dp[x][j]=dp[y][j]=(dp[x][j]+dp[y][j])*inv2%mod;\n        }\n        rep(j,n){\n            if(j==x||j==y)continue;\n            dp[j][x]=dp[j][y]=(dp[j][x]+dp[j][y])*inv2%mod;\n        }\n    }\n    ll ans=0;\n    rep(i,n)rep(j,i)ans+=dp[j][i];\n    cout<<ans%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 3000\n#define X 1000000007\n#define I2 500000004\nusing namespace std;\nint n,m,a[N+5],f[N+5][N+5];\nint main()\n{\n\tRI i,j,x,y;for(scanf(\"%d%d\",&n,&m),i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tfor(i=1;i<=n;++i) for(j=1;j<=n;++j) a[i]<a[j]&&(f[i][j]=1);\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y),f[x][y]=f[y][x]=1LL*I2*(f[x][y]+f[y][x])%X;\n\t\tfor(j=1;j<=n;++j) j^x&&j^y&&(f[x][j]=f[y][j]=1LL*I2*(f[x][j]+f[y][j])%X);\n\t\tfor(j=1;j<=n;++j) j^x&&j^y&&(f[j][x]=f[j][y]=1LL*I2*(f[j][x]+f[j][y])%X);\n\t}\n\tRI ans=0;for(i=1;i<=n;++i) for(j=1;j^i;++j) ans=(ans+f[i][j])%X;\n\tfor(i=1;i<=m;++i) ans=2LL*ans%X;return printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nll Power(ll x,ll k)\n{\n\tx%=mod;\n\tll sss=1;\n\twhile (k)\n\t{\n\t\tif (k%2) sss=sss*x%mod;\n\t\tx=x*x%mod;\n\t\tk/=2;\n\t}\n\treturn sss;\n}\nll ny(ll x){return Power(x,mod-2);}\nint n,q;\nll f[3030][3030];\nll ans;\nll a[3030],b[4][3030];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) if (a[i]>a[j]) f[i][j]=1;\n\n\tint x,y; ll doe=ny(2);\n\tfor (int i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tfor (int j=1;j<=n;++j) \n\t\t{\n\t\t\tb[0][j]=f[j][x];\n\t\t\tb[1][j]=f[x][j];\n\t\t\tb[2][j]=f[j][y];\n\t\t\tb[3][j]=f[y][j];\n\t\t}\n\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) f[j][y]+=b[0][j];\n\t\t\tif (j!=x) f[y][j]+=b[1][j];\n\t\t\tif (j!=y) f[j][x]+=b[2][j]; \n\t\t\tif (j!=y) f[x][j]+=b[3][j];\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) f[j][y]=f[j][y]*doe%mod;\n\t\t\tif (j!=x) f[y][j]=f[y][j]*doe%mod;\n\t\t\tif (j!=y) f[j][x]=f[j][x]*doe%mod;\n\t\t\tif (j!=y) f[x][j]=f[x][j]*doe%mod;\n\t\t}\n\t\tll A=f[x][y],B=f[y][x];\n\t\tf[y][x]+=A; f[x][y]+=B;\n\t\tf[x][y]=f[x][y]*doe%mod; \n\t\tf[y][x]=f[y][x]*doe%mod;\n\t}\n/*\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",f[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n;++j) (ans+=f[i][j])%mod;\n\tans=ans*Power(2,q)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint f[maxn][maxn], n, a[maxn], p2c[maxn][maxn], q;\nint l[maxn], r[maxn], tmp[maxn], ptmp[maxn];\nint pow2[maxn], ans;\ninline int mul(const int &a, const int &b) {\n\treturn 1ll * a * b % mod;\n}\ninline void Add(int &a, const int &b) {\n\ta = a + b >= mod ? a + b - mod : a + b;\n}\ninline int Minus(const int &a, const int &b) {\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q), pow2[0] = 1;\n\tfor(register int i = 1; i <= q; ++i)\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\tfor(register int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(register int i = 1; i <= n; ++i)\n\t\tfor(register int j = i + 1; j <= n; ++j)\n\t\t\tf[i][j] = 1;\n\treverse(l + 1, l + q + 1);\n\treverse(r + 1, r + q + 1);\n\tfor(register int i = 1; i <= q; ++i) {\n\t\tfor(register int j = l[i]; j <= r[i]; ++j)\n\t\t\ttmp[j] = f[j][r[i]], ptmp[j] = p2c[j][r[i]];\n\t\tfor(register int j = l[i] + 1; j < r[i]; ++j) {\n\t\t\tf[j][r[i]] = mul(f[j][r[i]], pow2[i + p2c[j][r[i]] - 1]);\n\t\t\tAdd(f[j][r[i]], Minus(pow2[i - 1], mul(f[l[i]][j], pow2[i + p2c[l[i]][j] - 1])));\n\t\t\tp2c[j][r[i]] = -i;\n\t\t}\n\t\tfor(register int j = l[i] + 1; j < r[i]; ++j) {\n\t\t\tf[l[i]][j] = mul(f[l[i]][j], pow2[i + p2c[l[i]][j] - 1]);\n\t\t\tAdd(f[l[i]][j], Minus(pow2[i - 1], mul(tmp[j], pow2[i + ptmp[j] - 1])));\n\t\t\tp2c[l[i]][j] = -i;\n\t\t}\n\t\tp2c[l[i]][r[i]] = -i;\n\t\tf[l[i]][r[i]] = pow2[i - 1];\n\t\tfor(register int j = 1; j <= n; ++j) {\n\t\t\tfor(register int k = 1; k <= n; ++k) {\n\t\t\t\t//f[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\t\tprintf(\"%d \", mul(f[j][k], pow2[i + p2c[j][k]]));\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\tfor(register int i = 1; i <= n; ++i) {\n\t\tfor(register int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = mul(f[i][j], pow2[q + p2c[i][j]]);\n\t\t\tif(a[i] > a[j]) Add(ans, f[i][j]);\n\t\t\telse if(a[i] < a[j]) Add(ans, Minus(pow2[q], f[i][j]));\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 3001\n#define p 1000000007\nint a[N],b[N],c[N],f[N][N],i,m,n,u,v,x,y;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=x=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(u=1;u<=n;u++)for(v=1;v<=n;v++)if(a[u]>a[v])f[u][v]=1;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d\",&u,&v),(x<<=1)%=p,y=500000004ll*(f[u][v]+f[v][u])%p;\n\t\tfor(i=1;i<=n;i++)b[i]=500000004ll*(f[i][u]+f[i][v])%p,c[i]=500000004ll*(f[u][i]+f[v][i])%p;\n\t\tfor(i=1;i<=n;i++)f[i][u]=i==v?y:i==u?0:b[i],f[i][v]=i==u?y:i==v?0:b[i],f[u][i]=i==v?y:i==u?0:c[i],f[v][i]=i==u?y:i==v?0:c[i];\n\t}\n\tfor(i=0,u=1;u<=n;u++)for(v=u;v<=n;v++)i=(i+(long long)x*f[u][v])%p;\n\treturn 0*printf(\"%d\\n\",i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 3010, mod = 1e9 + 7;\n\nLL power(LL a, LL b)\n{\n\tLL c = 1;\n\tfor (; b; a = a * a % mod, b >>= 1)\n\t\tif (b & 1) c = c * a % mod;\n\treturn c;\n}\n\nint n, q, x, y, a[N];\n\nLL inv2 = power(2, mod - 2);\nLL f[N][N], g[N][N];\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t\tf[i][j] = a[i] > a[j];\n\tfor (int i = 1; i <= q; ++ i)\n\t{\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t{\n\t\t\tg[x][j] = (f[y][j] * inv2 + f[x][j] * inv2) % mod;\n\t\t\tg[j][x] = (f[j][y] * inv2 + f[j][x] * inv2) % mod;\n\t\t\t\n\t\t\tg[y][j] = (f[x][j] * inv2 + f[y][j] * inv2) % mod;\n\t\t\tg[j][y] = (f[j][x] * inv2 + f[j][y] * inv2) % mod;\n\t\t}\n\t\tg[x][y] = (f[x][y] * inv2 + f[y][x] * inv2) % mod;\n\t\tg[y][x] = (f[y][x] * inv2 + f[x][y] * inv2) % mod;\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t{\n\t\t\tf[x][j] = g[x][j], f[j][x] = g[j][x];\n\t\t\tf[y][j] = g[y][j], f[j][y] = g[j][y];\n\t\t}\n\t}\n\tLL ans = 0;\n\tfor (int i = 1; i < n; ++ i)\n\t\tfor (int j = i + 1; j <= n; ++ j)\n\t\t\t(ans += f[i][j]) %= mod;\n\tprintf(\"%lld\\n\", ans * power(2, q) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n  }\n  public:\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    // inline int prod (int a, int b) const {\n    //   return (long long)a * b % md;\n    // }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  int inv2 = fld.inv(2);\n  int coeff = fld.pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      a = b = fld.prod(a, inv2);\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<vector>\n#include<cmath>\n#define ld long double\n//This code is written by Itst\nusing namespace std;\n\ninline int read(){\n    int a = 0;\n    char c = getchar();\n    bool f = 0;\n    while(!isdigit(c) && c != EOF){\n        if(c == '-')\n            f = 1;\n        c = getchar();\n    }\n    if(c == EOF)\n        exit(0);\n    while(isdigit(c)){\n        a = a * 10 + c - 48;\n        c = getchar();\n    }\n    return f ? -a : a;\n}\n\nconst int MOD = 1e9 + 7 , inv2 = 5e8 + 4;\nlong long dp[2007][2007];\nint num[2007] , N , M;\n\nint main(){\n    N = read();\n    M = read();\n    for(int i = 1 ; i <= N ; ++i)\n        num[i] = read();\n    for(int i = 1 ; i <= N ; ++i)\n        for(int j = i - 1 ; j ; --j){\n            dp[i][j] = num[i] > num[j];\n            dp[j][i] = num[j] > num[i];\n        }\n    for(int i = 1 ; i <= M ; ++i){\n        int a = read() , b = read();\n        for(int j = 1 ; j <= N ; ++j)\n            if(j != a && j != b){\n                dp[j][a] = dp[j][b] = (dp[j][a] + dp[j][b]) * inv2 % MOD;\n                dp[a][j] = dp[b][j] = (dp[a][j] + dp[b][j]) * inv2 % MOD;\n            }\n        dp[a][b] = dp[b][a] = (dp[a][b] + dp[b][a]) * inv2 % MOD;\n    }\n    long long sum = 0;\n    for(int i = 1 ; i <= N ; ++i)\n        for(int j = i - 1 ; j ; --j)\n            sum = (sum + dp[j][i]) % MOD;\n  \tfor(int i = 1 ; i <= M ; ++i)\n      sum = sum * 2 % MOD;\n    cout << sum;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3010;\nconst int mod=1e9+7;\nconst int inv2=(mod+1)/2;\ntypedef long long ll;\nint n,q;\nint a[N];\nll res,dp[N][N];\nll pw(ll x,ll p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1)ret=ret*x%mod;\n\t\tx=x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\nvoid pri(){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%lld \",dp[i][j]);\n\t\tputs(\"\");\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tdp[i][j]=a[i]>a[j];\n\t//pri();\n\tfor(int t=1;t<=q;t++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x||i==y)continue;\n\t\t\tll t1=dp[x][i],t2=dp[y][i],t3=dp[i][x],t4=dp[i][y];\n\t\t\tdp[x][i]=(t1+t2)%mod*inv2%mod;\n\t\t\tdp[i][x]=(t3+t4)%mod*inv2%mod;\n\t\t\tdp[y][i]=(t1+t2)%mod*inv2%mod;\n\t\t\tdp[i][y]=(t3+t4)%mod*inv2%mod;\n\t\t}\n\t\tll t1=dp[x][y],t2=dp[y][x];\n\t\tdp[x][y]=(t1+t2)%mod*inv2%mod;\n\t\tdp[y][x]=(t1+t2)%mod*inv2%mod;\n\t\t//pri();\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tres=(res+dp[i][j])%mod;\n\tres=res*pw(2,q)%mod;\n\tres=(res+mod)%mod;\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n/*\n6\n1 3 1 2 3 2\n*/"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 3e3 + 10, mod = 1e9 + 7;\n\nll a[N], p2[N], c[N][N];\nint x[N], y[N], debt[N][N], pend = 0;\n\nvoid f(int i, int j);\n\nint main() {\n\tfast_cin();\n\tint n, q;\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= q; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tp2[i] = (2 * p2[i - 1]) % mod;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tc[i][j] = 1;\n\t\t}\n\t}\n\tfor (int t = q; t >= 1; --t) {\n\t\t++pend;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i == x[t] or i == y[t]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf(i, x[t]); f(x[t], i);\n\t\t\tf(i, y[t]); f(y[t], i);\n\t\t\tc[i][x[t]] = c[i][y[t]] = (c[i][x[t]] + c[i][y[t]]) % mod;\n\t\t\tc[x[t]][i] = c[y[t]][i] = (c[x[t]][i] + c[y[t]][i]) % mod;\n\t\t}\n\t\tf(x[t], y[t]); f(y[t], x[t]);\n\t\tc[x[t]][y[t]] = c[y[t]][x[t]] = (c[x[t]][y[t]] + c[y[t]][x[t]]) % mod;\n\t\t// tot = (2 * tot) % mod;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\t--debt[i][j]; --debt[j][i];\n\t\t\tf(i, j); f(j, i);\n\t\t\t// cout << i << ' ' << j << ' ' << c[i][j] << endl;\n\t\t\tif (a[i] < a[j]) {\n\t\t\t\tans += c[j][i];\n\t\t\t\tans %= mod;\n\t\t\t} else if (a[i] > a[j]) {\n\t\t\t\tans += c[i][j];\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid f(int i, int j) {\n\t++debt[i][j];\n\tc[i][j] *= p2[pend - debt[i][j]];\n\tc[i][j] %= mod;\n\tdebt[i][j] = pend;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e3+10;\nconst int mod=1e9+7,inv2=(mod+1)/2;\nint a[maxn],dp[maxn][maxn];\nint n,m,all=1;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)dp[i][j]=a[i]<a[j];\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tall=all*1LL*2%mod;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tdp[x][y]=dp[y][x]=inv2*1LL*(dp[x][y]+dp[y][x])%mod;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i==x||i==y)continue;\n\t\t\tdp[i][x]=dp[i][y]=inv2*1LL*(dp[i][x]+dp[i][y])%mod;\n\t\t\tdp[x][i]=dp[y][i]=inv2*1LL*(dp[x][i]+dp[y][i])%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<i;j++)ans+=dp[i][j]*1LL*all%mod,ans%=mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// AGC030D\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > pii;\ntypedef long long LL;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nconst LL MOD=1000000007ll,i2=(MOD+1ll)/2ll;\nint n,q,a[3005],dp[3005][3005];\nint pw[3005];\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(i=0;i<n;++i) scanf(\"%d\",a+i);\n\tpw[0]=1;\n\tfor(i=1;i<=n;++i){\n\t\tpw[i]=(LL)pw[i-1]*2ll%MOD;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tfor(j=0;j<n;++j){\n\t\t\tdp[i][j]=(a[i]>a[j]);\n\t\t}\n\t}\n\tfor(i=0;i<q;++i){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\t--x;--y;\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tdp[x][j]=dp[y][j]=(LL)(dp[x][j]+dp[y][j])*(LL)i2%MOD;\n\t\t}\n\t\tfor(j=0;j<n;++j){\n\t\t\tif(j==x || j==y) continue;\n\t\t\tdp[j][x]=dp[j][y]=(LL)(dp[j][x]+dp[j][y])*(LL)i2%MOD;\n\t\t}\n\t\tdp[x][x]=dp[y][y]=0;\n\t\tdp[x][y]=dp[y][x]=(LL)(dp[x][y]+dp[y][x])*(LL)i2%MOD;\n\t}\n\tLL res=0ll;\n\tfor(i=0;i<n;++i){\n\t\tfor(j=i+1;j<n;++j){\n\t\t\tres+=(LL)dp[i][j]*(LL)pw[q]%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n\nconst int N = 3e3 + 5;\n\nint A[N], DP[N][N];\n\nint Power(int a, int b) {\n\tint res = 1;\n\tfor (; b; b >>= 1, a = 1LL * a * a % MOD) if (b & 1) res = 1LL * res * a % MOD;\n\treturn res;\n}\nint Inv = Power(2, MOD - 2);\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\t\n\tint n, q; cin >> n >> q;\n\tfor (int i = 0; i < n; i++) cin >> A[i];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) DP[i][j] = (A[i] > A[j]);\n\tfor (int t = 0; t < q; t++) {\n\t\tint x, y; cin >> x >> y; x--, y--;\n\t\tfor (int i = 0; i < n; i++) if (i != x && i != y) {\n\t\t\tDP[i][x] = DP[i][y] = 1LL * (DP[i][x] + DP[i][y]) * Inv % MOD;\n\t\t\tDP[x][i] = DP[y][i] = 1LL * (DP[x][i] + DP[y][i]) * Inv % MOD;\n\n\t\t}\n\t\tDP[x][y] = DP[y][x] = 1LL * (DP[x][y] + DP[y][x]) * Inv % MOD;\n\t}\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) s = (s + DP[i][j]) % MOD;\n\tcout << 1LL * s * Power(2, q)  % MOD << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 3005\n#define inv2 500000004\nint nex[MN][MN],lst[MN];\nlg dp[MN][MN];\nint a[MN];\nint k1,k2;\nlg P2[MN];\nint n,q;\nint main(){\n\tread(n);read(q);\n\tfor(int i=1;i<=n;++i){\n\t\tread(a[i]);\n\t}\n\tP2[0]=1;\n\tfor(int i=1;i<MN;++i)P2[i]=P2[i-1]*2%Md;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)if(a[i]<a[j])++dp[i][j];\n\t}\n\tfor(int i=1,now=1,lst=0;i<=q;++i,swap(now,lst)){\n\t\tread(k1);read(k2);\n\t\tfor(int j=1;j<=n;++j)if(j!=k1&&j!=k2){\n\t\t\t{lg aa=(dp[j][k1]+dp[j][k2])*inv2%Md;\n\t\t\tdp[j][k1]=dp[j][k2]=aa;}\n\t\t\t{lg aa=(dp[k1][j]+dp[k2][j])*inv2%Md;\n\t\t\tdp[k1][j]=dp[k2][j]=aa;}\n\t\t}\n\t\tdp[k1][k2]=dp[k2][k1]=(dp[k1][k2]+dp[k2][k1])*inv2%Md;\n\t}\n\tlg res=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tres+=dp[j][i];\n\t\t}\n\t}\n\tcout<<res*P2[q]%Md;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n  constexpr bool operator==(const modint rhs) noexcept{\n  return (*this).value()==rhs.value();\n  }\n  inline constexpr bool operator!=(const modint rhs) noexcept{\n  return !(*this==rhs);\n  }\n};\n#define MOD 1000000007\n#define MOD 1000000007\n\nlong long mod_pow(long long a,long long b)\n{\n    a %= MOD;\n    long long res = 1;\n    while(b){\n        if(b & 1){\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nmodint<mod> pow(modint<mod> rhs,long long k) noexcept{\n  ll exp = k;\n  modint<mod> p = 1;\n  while (exp) {\n    if (exp % 2) {\n      p *= rhs;\n    }\n    rhs *= rhs;\n    exp /= 2;\n  }\n  return p;\n}\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<int> a(n);\n    rep(i,n) cin >> a[i];\n    vector<int>x(q),y(q);\n    rep(i,q){\n      cin >> x[i] >> y[i];\n      x[i]--;y[i]--;\n    }\n    vector<vector<modint<mod> > > dp(n,vector<modint<mod> >(n,0));\n    rep(i,n){\n      rep(j,n){\n        if(a[i]<a[j]){\n          dp[i][j] = pow((modint<mod>)2,q);\n        }\n        //cerr << dp[i][j].value() << \" \";\n      }\n      //cerr << endl;\n    }\n    modint<mod> half = 1;\n    half /=2;\n    rep(c,q){\n      int a = x[c];\n      int b = y[c];\n      vector< modint<mod> > p(n),q(n);\n      rep(i,n){\n        p[i] = dp[i][a]*half + dp[i][b]*half;\n      }\n      rep(i,n){\n        q[i] = dp[a][i]*half + dp[b][i]*half;\n      } \n      rep(i,n){\n        if(i!=a&&i!=b){\n        dp[i][a] = p[i];\n        dp[a][i] = q[i];\n        dp[i][b] = p[i];\n        dp[b][i] = q[i];\n        }\n      }\n      dp[a][b] = (dp[a][b]*half+dp[b][a]*half);\n      dp[b][a] = dp[a][b];\n      // rep(i,n){\n      //   rep(j,n){\n      //     cerr << dp[i][j].value() << \" \";\n      //   }\n      //   cerr << endl;\n      // }\n      // cerr << endl;\n    }\n    modint<mod> sm = 0;\n    rep(i,n){\n      rep(j,n){\n        if(i<j)continue;\n        sm += dp[i][j];\n        //cerr << dp[i][j].value() << \" \";\n      }\n      //cerr << endl;\n    }\n    cout << sm.value() << endl;\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nlong long ans,x,y,n,q,a[3001],t[3001][3001],T[3001][3001],sum[3001][3001],Sum[3001][3001];\nint read()\n{\n  char c=0;\n  int sum=0;\n  while (c<'0'||c>'9')\n    c=getchar();\n  while ('0'<=c&&c<='9')\n    {\n      sum=sum*10+c-'0';\n      c=getchar();\n    }\n  return sum;\n}\nlong long fast_pow(long long a,int b)\n{\n  if (b==0)\n    return 1;\n  if (b&1)\n    return fast_pow(a*a%mod,b/2)*a%mod;\n  else\n    return fast_pow(a*a%mod,b/2);\n}\nint main()\n{\n  n=read(),q=read();\n  for (int i=1;i<=n;++i)\n    a[i]=read();\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      {\n\tif (a[i]>a[j])\n\t  t[i][j]=1;\n\tif (a[i]<a[j])\n\t  T[i][j]=1;\n      }\n  int a,b,c,d;\n  for (int i=1;i<=q;++i)\n    {\n      x=read(),y=read();\n      if (x>y)\n\tswap(x,y);\n      for (int j=x+1;j<=y-1;++j)\n\t{\n\t   a=t[x][j],b=T[x][j],c=t[j][y],d=T[j][y];\n\t   t[x][j]=T[j][y]=(a+d)%mod*fast_pow(2,mod-2)%mod;\n\t   T[x][j]=t[j][y]=(b+c)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=1;j<=x-1;++j)\n\t {\n\t   a=t[j][x],b=T[j][x],c=t[j][y],d=T[j][y];\n\t   t[j][x]=t[j][y]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t   T[j][x]=T[j][y]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t }\n      for (int j=y+1;j<=n;++j)\n\t{\n\t  a=t[x][j],b=T[x][j],c=t[y][j],d=T[y][j];\n\t  t[x][j]=t[y][j]=(a+c)%mod*fast_pow(2,mod-2)%mod;\n\t  T[x][j]=T[y][j]=(b+d)%mod*fast_pow(2,mod-2)%mod;\n\t}\n      a=t[x][y],b=T[x][y];\n      t[x][y]=T[x][y]=(a+b)%mod*fast_pow(2,mod-2)%mod;\n    }\n  for (int i=1;i<=n;++i)\n    for (int j=i+1;j<=n;++j)\n      ans=(ans+t[i][j]*fast_pow(2,q)%mod)%mod;\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, Q;\n\tcin >> N >> Q;\n\tvector<ll> A(N + 1);\n\trepn(i, N) cin >> A[i];\n\n\tvector<ll> X(Q + 1), Y(Q + 1);\n\trepn(i, Q) cin >> X[i] >> Y[i];\n\n\tvector<vector<mint>> dp(N + 1, vector<mint>(N + 1,0));\n\tvector<vector<ll>> up(N + 1, vector<ll>(N + 1, 0));\n\n\trepn(i, N)repn(j, N) {\n\t\tif (A[i] > A[j]) { dp[i][j] = 1; }\n\t}\n\t\n\trepn(q, Q) {\n\t\tmap<pair<ll, ll>, mint> mp;\n\t\tll x = X[q];\n\t\tll y = Y[q];\n\n\t\trepn(i, N) {\n\t\t\tif (i == x || i == y) { continue; }\n\n\t\t\tmp[{x, i}] = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tmp[{x, i}] += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tmp[{y, i}] = ((mint)2 ^ (q - up[x][i] - 1)) * dp[x][i];\n\t\t\tmp[{y, i}] += ((mint)2 ^ (q - up[y][i] - 1)) * dp[y][i];\n\n\t\t\tmp[{i, x}] = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tmp[{i, x}] += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tmp[{i, y}] = ((mint)2 ^ (q - up[i][x] - 1)) * dp[i][x];\n\t\t\tmp[{i, y}] += ((mint)2 ^ (q - up[i][y] - 1)) * dp[i][y];\n\n\t\t\tup[x][i] = q;\n\t\t\tup[y][i] = q;\n\t\t\tup[i][x] = q;\n\t\t\tup[i][y] = q;\n\n\t\t}\n\n\t\tmp[{x, y}] = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tmp[{x, y}] += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tmp[{y, x}] = ((mint)2 ^ (q - up[x][y] - 1)) * dp[x][y];\n\t\tmp[{y, x}] += ((mint)2 ^ (q - up[y][x] - 1)) * dp[y][x];\n\n\t\tup[x][y] = q;\n\t\tup[y][x] = q;\n\n\t\tfor (auto p : mp) {\n\t\t\tdp[p.first.first][p.first.second] = p.second;\n\t\t}\n\n\n\t}\n\n\tmint ans = 0;\n\trepn(i, N)repn(j, N) {\n\t\tdp[i][j] *= ((mint)2 ^ (Q - up[i][j]));\n\t\tif (j > i) { ans += dp[i][j]; }\n\t}\n\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <omp.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n\n\n#define int ll\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\n\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pst;\ntypedef pair<pii, pii> piii;\ntypedef vector<piii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<pii> vpi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef pair<pld, pld> pldd;\ntypedef vector<pld> vpd;\ntypedef complex<double> base;\n\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define my_abs(a) (((a) >= 0) ? (a) : -(a))\n#define mp(a, b) make_pair(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define MODIK(a) (a >= M ? a - M : a)\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n#ifdef ART_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\nistream &operator >> (istream &in, pii &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pii &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\nistream &operator >> (istream &in, pld &a)\n{\n    in >> a.first >> a.second;\n    return in;\n}\n\n\nostream &operator << (ostream &out, pld &a)\n{\n    out << a.first << ' ' << a.second;\n    return out;\n}\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) <<\n               \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid print(int a, int b, int n, vi h)\n{\n    ofstream cout(\"output.txt\");\n    cout << SZ(h) << ' ' << a << ' ' << b << '\\n';\n    for (int i = 0; i < SZ(h); ++i) {\n        cout << h[i]  << ' ';\n    }\n    cout.close();\n    exit(0);\n}\n\n\ninline bool break_time(ld time)\n{\n    return clock() > CLOCKS_PER_SEC * time;\n}\n\n\nld get_rand_ld(ld l, ld r)\n{\n    uniform_real_distribution<double> gen(l, r);\n    return gen(rng);\n}\n\n\nbool may(int E, ld T)\n{\n    if (E < 0)\n        return 1;\n\n    double eps = get_rand_ld(0, 1);\n    return eps < exp(-E / T);\n}\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef ART_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(0) << fixed;\n    smain();\n#ifdef ART_HOME\n    cout << \"\\nTOTAL EXECUTIOn TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\n\nconst int N = 3e3 + 10, K = 1e2 + 10, B = 1000, oo = 1e18, M = 998244353, LOG = 20;\nconst int M1 = 1000000093, x1 = 27162;\nconst int M2 = 1000000087, x2 = 241;\nconst ld pi = atan2(1, 0) * 2, EPS = 1e-9;\n\n\nint dp[N][N];\nvpi flex;\n\nvoid inc(int a, int b, int v)\n{\n    flex.push_back(mp(a * N + b, v));\n}\n\n\nvoid smain() {\n    int n, q;\n    cin >> n >> q;\n\n    vi kek(n);\n    for (int i = 0; i < n; ++i)\n        cin >> kek[i];\n\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n        {\n            if (kek[i] < kek[j])\n                dp[i][j] = 1;\n            else if (kek[i] > kek[j])\n                dp[j][i] = 1;\n        }\n\n    for (int i = 0; i < q; ++i)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        flex.clear();\n\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (j == a || j == b)\n                continue;\n\n            inc(a, j, dp[b][j]);\n            inc(b, j, dp[a][j]);\n            inc(j, a, dp[j][b]);\n            inc(j, b, dp[j][a]);\n        }\n\n        inc(a, b, dp[b][a]);\n        inc(b, a, dp[a][b]);\n\n\n        for (auto p : flex)\n        {\n            int a, b, v;\n            tie(a, v) = p;\n\n            b = a % N;\n            a /= N;\n            dp[a][b] += v;\n        }\n\n        for (int x = 0; x < n; ++x)\n            for (int y = 0; y < n; ++y)\n            {\n                if (x == a || x == b || y == a || y == b)\n                    continue;\n\n                dp[x][y] *= 2;\n            }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            ans += dp[j][i];\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v((a %= mod) < 0 ? a + mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<MOD>;\nmint rec[3010][3010];\n\nsigned main() {\n    int N, Q; cin >> N >> Q;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n    mint inv = mint(1) / mint(2);\n    \n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(A[i] == A[j]) rec[i][j] = inv;\n            if(A[i] <  A[j]) rec[i][j] = mint(0);\n            if(A[i] >  A[j]) rec[i][j] = mint(1);\n        }\n    }\n\n    mint mul = mint(2).pow(Q);\n    while(Q--) {\n        int x, y; cin >> x >> y; x--; y--;\n\n        // x < y にする\n        if(x > y) swap(x, y);\n        \n        map< pair<int, int>, mint > memo;\n        \n        // (i, x, y) -> (i, y, x)\n        // (i, x) -> (i, y), (i, y) -> (i, x) と変える\n        for(int i=0; i<x; i++) {\n            mint va = rec[i][x], vb = rec[i][y];\n            rec[i][x] = (va + vb) * inv;\n            rec[i][y] = (va + vb) * inv;\n        }\n        \n        // (x, i, y) -> (y, i, x)\n        // (x, i) -> (y, i), (i, y) -> (i, x) と変える\n        for(int i=x+1; i<y; i++) {\n            mint va = rec[x][i], vb = rec[i][y];\n            rec[x][i] = (mint(1) - vb + va) * inv;\n            rec[i][y] = (mint(1) - va + vb) * inv;\n        }\n        \n        // (x, y, i) -> (y, x, i)\n        // (x, i) -> (y, i), (y, i) -> (x, i) と変える\n        for(int i=y+1; i<N; i++) {\n            mint va = rec[x][i], vb = rec[y][i];\n            rec[x][i] = (va + vb) * inv;\n            rec[y][i] = (va + vb) * inv;\n        }\n        \n        // x, y -> y, x\n        {\n            mint v = rec[x][y];\n            rec[x][y] = inv;\n        }\n    }\n\n    mint ans(0);\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            ans += rec[i][j];\n        }\n    }\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<N; j++) {\n            if(A[i] == A[j]) ans -= inv;\n        }\n    }\n    ans *= mul;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint m[3333][3333];\nint a[5555];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(55555);\n\tint n,q; cin>>n>>q;\n\tfor(int i=0;i<n;i++) \n\t{\n\t\tcin>>a[i]; a[i]--;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tm[i][j]=(a[i]>a[j]?1:0);\n\t\t}\n\t}\n\tint factor = 1;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint x,y; cin>>x>>y; x--; y--;\n\t\tfactor = mult(factor, 2);\n\t\tvector<int> tmp(n);\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\ttmp[j] = mult(add(m[x][j],m[y][j]),inv[2]);\n\t\t}\n\t\tvector<int> col(n);\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tcol[j]=mult(add(m[j][x],m[j][y]),inv[2]);\n\t\t}\n\t\tint c = mult(add(m[x][y],m[y][x]),inv[2]);\n\t\t//swap(m[x][y],m[y][x]);\n\t\t//m[x][y]=mult(m[x][y],inv[2]); m[y][x]=mult(m[y][x],inv[2]);\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tm[x][j]=m[y][j]=tmp[j];\n\t\t\tm[j][x]=m[j][y]=col[j];\n\t\t}\n\t\tm[x][y]=m[y][x]=c;\n\t\tm[x][x]=m[y][y]=0;\n\t\t/*\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcerr<<mult(factor, m[i][j])<<' ';\n\t\t\t}\n\t\t\tcerr<<'\\n';\n\t\t}\n\t\t*/\n\t}\n\tint ans = 0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tans = add(ans, mult(factor, m[i][j]));\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define popCnt(x) (__builtin_popcountll(x))\ntypedef long long Long;\n\nconst int N = 3003;\nconstexpr int MOD = round(1e9 + 7);\n\nLong ways[N][N];\nint arr[N];\n\npair<int, int> queries[N];\n\nint power(int p, int b) {\n  if (b == 0) return 1;\n  int res = power(p, b / 2);\n  res = 1LL * res * res % MOD;\n  if (b & 1) {\n    res = 1LL * res * p % MOD;\n  }\n  return res;\n}\n\nconst int INV2 = power(2, MOD - 2);\n\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#ifdef Local\n  freopen(\"test.in\", \"r\", stdin);\n#else\n#define endl '\\n'\n#endif\n\n  int n, q;\n  cin >> n >> q;\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n\n  for (int i = 0; i < q; ++i) {\n    cin >> queries[i].first >> queries[i].second;\n  }\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      ways[i][j] = (i > j);\n    }\n  }\n\n  for (int q_ind = q - 1; q_ind >= 0; --q_ind) {\n    int x = queries[q_ind].first, y = queries[q_ind].second;\n    --x, --y;\n\n    ways[y][x] = ways[x][y] = INV2;\n    for (int i = 0; i < n; ++i) {\n      if (i == y || i == x) {\n        continue;\n      }\n      ways[y][i] = ways[x][i] = 1LL * INV2 * (ways[x][i] + ways[y][i]) % MOD;\n      ways[i][y] = ways[i][x] = 1LL * INV2 * (ways[i][x] + ways[i][y]) % MOD;\n    }\n  }\n\n  int res = 0;\n  for (int x = 0; x < n; ++x) {\n    for (int y = 0; y < n; ++y) {\n      res = (res + (arr[x] < arr[y]) * ways[x][y]) % MOD;\n    }\n  }\n\n  res = 1LL * res * power(2, q) % MOD;\n  cout << res << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3050;\ntypedef long long ll;\nconst ll mod=1000000007;\nconst ll inv=500000004;\nint n,q,ai[N];\nll dp[N][N],ans,pl;\n\ninline ll KSM(ll a,ll p){\n\tll ret=1;\n\twhile(p){\n\t\tif(p&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tpl=KSM(2,q);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&ai[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(ai[i]>ai[j])\n\t\t\t\tdp[i][j]=1;\n\twhile(q--){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tdp[x][y]=dp[y][x]=((dp[x][y]+dp[y][x])%mod)*inv%mod;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(i==x || i==y) continue;\n\t\t\tdp[i][x]=dp[i][y]=((dp[i][y]+dp[i][x])%mod)*inv%mod;\n\t\t\tdp[x][i]=dp[y][i]=((dp[y][i]+dp[x][i])%mod)*inv%mod;\n\t\t}\n//\t\tfor(int i=1;i<=n;i++)\t\n//\t\t{\n//\t\t\tfor(int j=1;j<=n;j++)\n//\t\t\t\tcout<<dp[i][j]<<\" \";\n//\t\t\tcout<<endl;\n//\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tans=(dp[i][j]+ans)%mod;\n\tans=ans*pl%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 3050;\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) >> 1;\nint A[N][N], a[N], n, q;\ninline ll add(int x, int y) { return x + y >= P ? x + y - P : x + y; }\nvoid out(void) {\n    for (int i = 1;i <= n; i++, puts(\"\"))\n        for (int j = 1;j <= n; j++)\n            write(A[i][j], ' ');\n    puts(\"\");\n}\nint main() {\n    read(n), read(q);\n    for (int i = 1;i <= n; i++) read(a[i]);\n    for (int i = 1;i <= n; i++)\n        for (int j = 1;j <= n; j++) \n            A[i][j] = a[i] > a[j];\n    /* puts(\"\"); */\n    ll mi = 1;\n    for (int i = 1, x, y;i <= q; i++) {\n        /* out(); */\n        mi = add(mi, mi);\n        read(x), read(y);\n        /* if (x > y) swap(x, y); */\n        for (int i = 1;i <= n; i++) {\n            if (i == x || i == y) continue;\n            int tx = A[x][i], ty = A[y][i];\n            int ttx = A[i][x], tty = A[i][y];\n            A[x][i] = add(tx, ty) * inv2 % P;\n            A[y][i] = add(tx, ty) * inv2 % P;\n            A[i][x] = add(ttx, tty) * inv2 % P;\n            A[i][y] = add(ttx, tty) * inv2 % P;\n        }\n        A[x][y] = A[y][x] = inv2;\n    }\n    /* out(); */\n    int ans = 0;\n    for (int i = 1;i <= n; i++) \n        for (int j = i + 1;j <= n; j++)\n            ans = add(ans, A[i][j]);\n    write(1ll * ans * mi % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define mod 1000000007\nusing namespace std;\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nint ksm(int u, int v){\n\tint s = 1;\n\tfor(int i = v; i; i >>= 1){\n\t\tif(i & 1) s = 1ll * s * u % mod;\n\t\tu = 1ll * u * u % mod;\n\t}\n\treturn s;\n}\nint n, m, f[5001][5001], inv2, ans, a[5001], g[5001][5001];\nint main()\n{\n\tn = read(); m = read(); inv2 = 500000004;\n\tfor(int i = 1; i <= n; i++) a[i] = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) f[i][j] = (a[i] > a[j]);\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tint x = read(), y = read();\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tg[x][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv2 % mod;\t\t\n\t\t\tg[j][x] = 1ll * (f[j][x] + f[j][y]) % mod * inv2 % mod;\n\t\t\tg[y][j] = 1ll * (f[x][j] + f[y][j]) % mod * inv2 % mod;\n\t\t\tg[j][y] = 1ll * (f[j][y] + f[j][x]) % mod * inv2 % mod;\n\t\t}\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tf[x][j] = g[x][j]; f[j][x] = g[j][x];\n\t\t\tf[y][j] = g[y][j]; f[j][y] = g[j][y];\n\t\t}\n\t\tf[x][y] = 1ll * (f[x][y] + f[y][x]) % mod * inv2 % mod; f[y][x] = f[x][y];\n\t\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tans = (ans + f[i][j]) % mod;\n\tans = 1ll * ans * ksm(2, m) % mod; cout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 3010\nll po[N];\n\nll n,dat[N],q;\nll ok[N][N],ng[N][N];\nll rui[N][N],zen;\nll oe[N][N],ne[N][N];\n\nvoid eval(ll a,ll b){\n    ll dex=zen-rui[a][b];\n    ok[a][b]=ok[a][b]*po[dex]%mod;\n    ng[a][b]=ng[a][b]*po[dex]%mod;\n    rui[a][b]=zen;\n}\nvoid eva(ll a,ll b){\n    eval(a,b);\n    eval(b,a);\n}\n\nvoid setoe(ll a,ll b,ll x){\n    oe[a][b]=oe[b][a]=x;\n}\nvoid setne(ll a,ll b,ll x){\n    ne[a][b]=ne[b][a]=x;\n}\n\nvoid upe(ll a,ll b){\n    ok[a][b]+=oe[a][b];ok[a][b]%=mod;oe[a][b]=0;\n    ng[a][b]+=ne[a][b];ng[a][b]%=mod;ne[a][b]=0;\n    rui[a][b]=zen;\n}\nvoid outs(ll a,ll b){\n    eva(a,b);\n    cout<<a+1<<\" \"<<b+1<<\":\"<<ok[a][b]<<\" \"<<ng[a][b]<<endl;\n}\nvoid oute(){\n    outs(0,4);outs(1,2);\n}\n\nvoid upd(ll a,ll b){\n    lol(i,n){\n\teva(a,i);\n\teva(b,i);\n    }\n    setoe(a,b,ng[a][b]);\n    setne(a,b,ok[a][b]);\n    for(ll x=0;x<n;x++){\n\tif(x==a||x==b)continue;\n\tif(x<a||b<x){\n\t    setoe(x,a,ok[x][b]);\n\t    setoe(x,b,ok[x][a]);\n\t    setne(x,a,ng[x][b]);\n\t    setne(x,b,ng[x][a]);\n\t    continue;\n\t}\n\tsetoe(x,a,ng[x][b]);\n\tsetoe(x,b,ng[x][a]);\n\tsetne(x,a,ok[x][b]);\n\tsetne(x,b,ok[x][a]);\n    }\n    zen++;\n    lol(i,n){\n\tupe(a,i);upe(i,a);\n\tupe(b,i);upe(i,b);\n    }\n}\nint main(){\n    po[0]=1; for(ll i=1;i<N;i++)po[i]=po[i-1]*2%mod;\n    \n    cin>>n>>q;\n    lol(i,n)cin>>dat[i];\n    lol(i,n)lol(j,n){\n\tif(dat[i]==dat[j]){\n\t    ok[i][j]=ng[i][j]=0;\n\t    continue;\n\t}\n\tif(dat[i]<dat[j] xor i<j){\n\t    ok[i][j]=0,ng[i][j]=1;\n\t}\n\telse ok[i][j]=1,ng[i][j]=0;\n\trui[i][j]=0;\n    }\n    zen=0;\n    while(q--){\n\tll a,b;cin>>a>>b;a--,b--;\n\tupd(min(a,b),max(a,b));\n    }\n    ll ans=0;\n    lol(i,n)lol(j,i){\n\teva(i,j);\n\tans=(ans+ng[i][j])%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 3e3 + 7;\nconst modint v2 = (modint)1 / 2;\nint n, q, a[N];\nmodint f[N][N], ans;\n\ninline void work(modint &x, modint &y) {\n\tx = y = (x + y) * v2;\n}\n\nint main() {\n\trd(n, q), rda(a, n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tf[i][j] = a[i] > a[j];\n\tfor (int i = 1, x, y; i <= q; i++) {\n\t\trd(x, y), work(f[x][y], f[y][x]);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (j != x && j != y)\n\t\t\t\twork(f[j][x], f[j][y]), work(f[x][j], f[y][j]);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tans += f[i][j];\n\tprint(ans * ((modint)2 ^ q));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef long long ll;\nconst int mod=1e9+7,i2=(mod+1)/2;\nint mul(int a,int b){return(ll)a*b%mod;}\nvoid inc(int&a,int b){(a+=b)>=mod?a-=mod:0;}\nint a[3010],f[3010][3010];\nint main(){\n\tint n,q,i,j,x,y,s;\n\tscanf(\"%d%d\",&n,&q);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)f[i][j]=a[i]>a[j];\n\t}\n\tfor(j=1;j<=q;j++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=mul(f[x][y]+f[y][x],i2);\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=x&&i!=y){\n\t\t\t\tf[x][i]=f[y][i]=mul(f[x][i]+f[y][i],i2);\n\t\t\t\tf[i][x]=f[i][y]=mul(f[i][x]+f[i][y],i2);\n\t\t\t}\n\t\t}\n\t}\n\ts=0;\n\tfor(i=1;i<n;i++){\n\t\tfor(j=i+1;j<=n;j++)inc(s,f[i][j]);\n\t}\n\twhile(q--)s=mul(s,2);\n\tprintf(\"%d\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst int N = 3010 , mod = 1e9+7 , inv2 = (mod + 1) / 2;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , Q;\nint a[N] , F[N][N] , G[N][N];\n\ninline int add(int a , int b) { return a + b >= mod ? a - mod + b : a + b; }\ninline int mul(int a , int b) { return (LL)a * b % mod; }\n\nint main()\n{\n\tn = read(); Q = read();\n\tfor(int i = 1 ; i <= n ; ++i) a[i] = read();\n\tfor(int i = 1 ; i <= n ; ++i) for(int j = 1 ; j <= n ; ++j) F[i][j] = a[i] > a[j];\n\tint p1 , p2 , res = 1;\n\twhile(Q--)\n\t{\n\t\tp1 = read(); p2 = read();\n\t\tfor(int i = 1 ; i <= n ; ++i) if(i != p1 && i != p2)\n\t\t{\n\t\t\tG[i][p1] = G[i][p2] = mul(inv2 , add(F[i][p1] , F[i][p2]));\n\t\t\tG[p1][i] = G[p2][i] = mul(inv2 , add(F[p1][i] , F[p2][i]));\n\t\t}\n\t\tfor(int i = 1 ; i <= n ; ++i) if(i != p1 && i != p2) F[i][p1] = G[i][p1] , F[i][p2] = G[i][p2] , F[p1][i] = G[p1][i] , F[p2][i] = G[p2][i];\n\t\tF[p1][p2] = F[p2][p1] = mul(inv2 , add(F[p1][p2] , F[p2][p1]));\n\t\tres = mul(res , 2);\n\t}\n\tint ans = 0;\n\tfor(int i = 1 ; i <= n ; ++i) for(int j = i + 1 ; j <= n ; ++j) ans = add(ans , F[i][j]);\n\tcout << mul(res , ans) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3005,Mod=1e9+7,iM=Mod+1>>1;\nint n,q,a[N],f[N][N],t[N][N],ans,p=1;\n#define mul(x,y) (1ll*(x)*(y)%Mod)\ninline int add(int x, int y)\n{\treturn (x+y>=Mod?x+y-Mod:x+y);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j) f[i][j]=(a[i]>a[j]);\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tif(x==y) continue;\n\t\tt[x][y]=mul(iM,add(f[x][y],f[y][x]));\n\t\tfor(int i=1;i<=n;++i) if(i!=x&&i!=y)\n\t\t\tt[x][i]=mul(iM,add(f[x][i],f[y][i])),\n\t\t\tt[i][x]=mul(iM,add(f[i][x],f[i][y])),\n\t\t\tt[y][i]=mul(iM,add(f[y][i],f[x][i])),\n\t\t\tt[i][y]=mul(iM,add(f[i][y],f[i][x]));\n\t\tf[x][y]=f[y][x]=t[x][y];\n\t\tfor(int i=1;i<=n;++i) if(i!=x&&i!=y)\n\t\t\tf[x][i]=t[x][i],f[i][x]=t[i][x],f[y][i]=t[y][i],f[i][y]=t[i][y];\n\t\tp=mul(2,p);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j) ans=add(ans,f[i][j]);\n\tprintf(\"%d\\n\",mul(ans,p));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL>PL;\nconst LL INF=1e18;\nconst LL MOD=1e9+7;\ninline LL Pow(LL x,LL y)\n{\n    LL ans=1;\n    while(y>0)\n    {\n        if(y&1)\n            ans=ans*x%MOD;\n        x=x*x%MOD;\n        y>>=1;\n    }\n    return ans;\n}\ninline LL Inv(LL x)\n{\n    return Pow(x,MOD-2);\n}\nLL N,Q,i,j;\nLL A[3010];\nLL inv[3010][3010];\nLL ans,sum;\nLL inv2;\nLL X,Y;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>N>>Q;\n    for(i=0;i<N;i++)\n        cin>>A[i];\n    for(i=0;i<N;i++)\n        for(j=i+1;j<N;j++)\n            if(A[j]>A[i])\n                inv[i][j]=1;\n    inv2=Inv(2);\n    ans=Pow(2,Q);\n    while(Q-->0)\n    {\n        cin>>X>>Y;\n        if(X>Y)\n            swap(X,Y);\n        inv[--X][--Y]=inv2;\n        for(i=0;i<X;i++)\n            inv[i][X]=inv[i][Y]=inv2*(inv[i][X]+inv[i][Y])%MOD;\n        for(i=X+1;i<Y;i++)\n            inv[X][i]=inv[i][Y]=inv2*(inv[X][i]+inv[i][Y])%MOD;\n        for(i=Y+1;i<N;i++)\n            inv[X][i]=inv[Y][i]=inv2*(inv[X][i]+inv[Y][i])%MOD;\n    }\n    for(i=0;i<N;i++)\n        for(j=i+1;j<N;j++)\n            sum+=inv[i][j];\n    sum%=MOD;\n    cout<<ans*sum%MOD<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int md = 1e9 + 7;\n\nint mul(int a, int b) {\n  return ((ll)a * b) % md;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\nint power(int a, ll b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint inv(int a) {\n  return power(a, md - 2);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, q;\n  cin >> n >> q;\n  vector <int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  vector <pair <int, int>> op(q);\n  for (int i = 0; i < q; ++i) {\n    cin >> op[i].first >> op[i].second;\n    --op[i].first, --op[i].second;\n    if (op[i].first > op[i].second) swap(op[i].first, op[i].second);\n  }\n  vector <vector <vector <int>>> dp(n, vector <vector <int>> (n, vector <int> (2)));\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      dp[i][j][0] = 1;\n    }\n  }\n  int coef = 1, icoef = 1;\n  \n  for (int t = q - 1; t >= 0; --t) {\n    vector <pair <int&, int>> to_change;\n    auto recalc = [&] (int i, int j, int f) {\n      int new_dp = mul(coef, dp[i][j][f]);\n      int go_i = i, go_j = j;\n      if (i == op[t].first || i == op[t].second) go_i = op[t].first ^ op[t].second ^ i;\n      if (j == op[t].first || j == op[t].second) go_j = op[t].first ^ op[t].second ^ j;\n      int go_f = f;\n      if (go_i > go_j) {\n        swap(go_i, go_j);\n        go_f ^= 1;\n      }\n      add(new_dp, mul(coef, dp[go_i][go_j][go_f]));\n      to_change.push_back({dp[i][j][f], new_dp});\n    };\n\n    for (int i : {op[t].first, op[t].second}) {\n      for (int j = i + 1; j < n; ++j) {\n        for (int f = 0; f <= 1; ++f) {\n          recalc(i, j, f);\n        }\n      } \n    }\n    for (int j : {op[t].first, op[t].second}) {\n      for (int i = j - 1; i >= 0; --i) {\n        for (int f = 0; f <= 1; ++f) {\n          recalc(i, j, f);\n        }\n      } \n    }\n    icoef = mul(icoef, (md + 1) / 2); \n    coef = mul(coef, 2);\n\n    for (auto p : to_change) {\n      p.first = mul(p.second, icoef);\n    }\n  } \n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (a[i] > a[j]) {\n        add(ans, mul(coef, dp[i][j][0]));\n      } else if (a[i] < a[j]) {\n        add(ans, mul(coef, dp[i][j][1]));\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define modsum(a, b) ((a) + (b) >= M ? (a) + (b) - M : (a) + (b))\n#define modsubtract(a, b) ((a) - (b) < 0 ? (a) - (b) + M : (a) - (b))\n#define modmultiply(a, b) (((a) * (b)) % M)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)((a).size()))\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T>\nostream & operator << (ostream &out, vector<T> &a) {\n    out << \"{\";\n    fori (i, SZ(a))\n        out << a[i] << vector<string>{\", \", \"}\"}[i + 1 == SZ(a)];\n    return out;\n}\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\n\";\n    cout << \"TOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nint n, q;\nconst int N = 3003;\nconst ll M = 1e9 + 7;\nint a[N];\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % M;\n        a = (a * a) % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll pw2[N];\n\nmap<pii, int> dp[N];\n\npii queries[N];\n\nvi my_q[N];\n\n//ll dfs(int i, int l, int r) {\n//    if (i == q) {\n//        if (l > r) return 1;\n//        return 0;\n//    }\n//    if (dp[i].count({l, r})) return dp[i][{l, r}];\n//\n//    vi cur_q;\n//    for (auto ind : my_q[l]) {\n//        if (ind >= i) cur_q.push_back(ind);\n//    }\n//    for (auto ind : my_q[r]) {\n//        if (ind >= i) cur_q.push_back(ind);\n//    }\n//    sort(ALL(cur_q));\n//    cur_q.resize(unique(ALL(cur_q)) - cur_q.begin());\n//    ll ret = 0;\n//    for (int j = 0; j < cur_q.size(); ++j) {\n//        int ind = cur_q[j];\n//        int lf = queries[ind].first, rf = queries[ind].second;\n//        if ((l < r) ^ (lf < rf)) swap(lf, rf);\n//        ll ways = pw2[ind - i - j];\n//        if (lf == l && rf == r) {\n//            ret = (ret + ways * dfs(ind + 1, r, l)) % M;\n//        } else if (lf == l || rf == l) {\n//            if (lf != l) swap(lf, rf);\n//            ret = (ret + ways * dfs(ind + 1, rf, r)) % M;\n//        } else if (rf == r || lf == r) {\n//            if (rf != r) swap(lf, rf);\n//            ret = (ret + ways * dfs(ind + 1, l, lf)) % M;\n//        } else assert(0);\n//    }\n//    ret = (ret + pw2[q - i - cur_q.size()] * dfs(q, l, r)) % M;\n//    return dp[i][{l, r}] = ret;\n//}\n//\n//void smain() {\n//    pw2[0] = 1;\n//    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n//    cin >> n >> q;\n//    fori (i, n) cin >> a[i];\n//    fori (i, q) {\n//        cin >> queries[i].first >> queries[i].second;\n//        queries[i].first--, queries[i].second--;\n//        my_q[queries[i].first].push_back(i);\n//        my_q[queries[i].second].push_back(i);\n//    }\n//    ll ans = 0;\n//    for (int i = 0; i < n; ++i) {\n//        for (int j = i + 1; j < n; ++j) {\n//            ll cur = dfs(0, i, j);\n////            cout << \"cur[\" << i << \", \" << j << \"] = \" << cur << endl;\n//            if (a[i] < a[j]) ans = (ans + cur) % M;\n//            else if (a[i] > a[j]) ans = (ans + pw2[q] - cur + M) % M;\n//        }\n//    }\n//    cout << ans;\n//}\n\nint get(int x, int i) {\n    int ret = upper_bound(ALL(my_q[x]), i) - my_q[x].begin();\n    if (ret == my_q[x].size()) return q;\n    return my_q[x][ret];\n}\n\nll dfs(int i, int l, int r) {\n    if (i == q) {\n        if (l > r) return 1;\n        return 0;\n    }\n    if (dp[i].count({l, r})) return dp[i][{l, r}];\n\n    int lnx = get(l, i - 1);\n    int rnx = get(r, i - 1);\n\n    if (min(lnx, rnx) == q) {\n        return dp[i][{l, r}] = pw2[q - i] * dfs(q, l, r) % M;\n    }\n\n    int qi = min(lnx, rnx);\n    int lf = queries[qi].first, rf = queries[qi].second;\n    if ((l < r) ^ (lf < rf)) swap(lf, rf);\n    if (lf == l && rf == r) {\n        return pw2[qi - i] * (dfs(qi + 1, l, r) + dfs(qi + 1, r, l)) % M;\n    }\n    if (lf == l || rf == l) {\n        if (lf != l) swap(lf, rf);\n        return pw2[qi - i] * (dfs(qi + 1, l, r) + dfs(qi + 1, rf, r)) % M;\n    }\n\n    if (rf != r) swap(lf, rf);\n\n    return pw2[qi - i] * (dfs(qi + 1, l, r) + dfs(qi + 1, l, lf)) % M;\n}\n\nvoid smain() {\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n    cin >> n >> q;\n    fori (i, n) cin >> a[i];\n    fori (i, q) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--, queries[i].second--;\n        my_q[queries[i].first].push_back(i);\n        my_q[queries[i].second].push_back(i);\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ll cur = dfs(0, i, j);\n//            cout << \"cur[\" << i << \", \" << j << \"] = \" << cur << endl;\n            if (a[i] < a[j]) ans = (ans + cur) % M;\n            else if (a[i] > a[j]) ans = (ans + pw2[q] - cur + M) % M;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 1000000007;\nconst LL INV = (N + 1LL) / 2LL;\n\nLL tot = 1LL,sum = 0;\nLL dp[3005][3005],tmp[3005][3005];\nLL a[3005];\n\nint main(){\n\tLL n,q,u,v;\n\tcin >> n >> q;\n\tfor(LL i = 1;i <= n;i ++) cin >> a[i];\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tif(a[i] > a[j]) dp[i][j] = 1;\n\t\t}\n\t}\n\twhile(q --){\n\t\tcin >> u >> v;\n\t\tfor(LL i = 1;i <= n;i ++){\n\t\t\tif(i == u || i == v) continue;\n\t\t\ttmp[u][i] = (INV * ((dp[u][i] + dp[v][i]) % N)) % N;\n\t\t\ttmp[i][u] = (INV * ((dp[i][u] + dp[i][v]) % N)) % N;\n\t\t\ttmp[v][i] = (INV * ((dp[v][i] + dp[u][i]) % N)) % N;\n\t\t\ttmp[i][v] = (INV * ((dp[i][v] + dp[i][u]) % N)) % N;\n\t\t}\n\t\tfor(LL i = 1;i <= n;i ++){\n\t\t\tif(i == u || i == v) continue;\n\t\t\tdp[u][i] = tmp[u][i]; dp[i][u] = tmp[i][u];\n\t\t\tdp[v][i] = tmp[v][i]; dp[i][v] = tmp[i][v];\n\t\t}\n\t\ttmp[u][v] = (INV * ((dp[u][v] + dp[v][u]) % N)) % N;\n\t\ttmp[v][u] = (INV * ((dp[v][u] + dp[u][v]) % N)) % N;\n\t\tdp[u][v] = tmp[u][v]; dp[v][u] = tmp[v][u];\n\t\ttot = (tot * 2) % N;\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = i + 1;j <= n;j ++){\n\t\t\tsum = (sum + dp[i][j]) % N;\n\t\t}\n\t}\n\tcout << (sum * tot) % N << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint a[3005], x[3005], y[3005];\nint table[3005][3005];\n\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, q) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tint ans = 0;\n\n\trep(i, n) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (a[i] < a[j])table[i][j] = 1;\n\t\t\tif (a[i] > a[j])table[j][i] = 1;\n\t\t}\n\t}\n\n\tint inv2 = modpow(2, mod - 2);\n\n\trep(k, q) {\n\t\t//x[i]とy[i]をswap\n\t\trep(l, n) {//(x,l)->(y,l)\n\t\t\tif (x[k] == l || y[k] == l)continue;\n\t\t\ttable[x[k]][l] = table[x[k]][l] * inv2 % mod;\n\t\t\ttable[y[k]][l] = table[y[k]][l] * inv2 % mod;\n\t\t\ttable[l][x[k]] = table[l][x[k]] * inv2 % mod;\n\t\t\ttable[l][y[k]] = table[l][y[k]] * inv2%mod;\n\t\t\tint p1 = table[x[k]][l], p2 = table[y[k]][l], p3 = table[l][x[k]], p4 = table[l][y[k]];\n\t\t\ttable[x[k]][l] = (table[x[k]][l] + p2) % mod;\n\t\t\ttable[y[k]][l] = (table[y[k]][l] + p1) % mod;\n\t\t\ttable[l][x[k]] = (table[l][x[k]] + p4) % mod;\n\t\t\ttable[l][y[k]] = (table[l][y[k]] + p3) % mod;\n\t\t}\n\t\ttable[x[k]][y[k]] = table[x[k]][y[k]] * inv2 % mod;\n\t\ttable[y[k]][x[k]] = table[y[k]][x[k]] * inv2 % mod;\n\t\tint p1 = table[y[k]][x[k]], p2 = table[x[k]][y[k]];\n\t\ttable[x[k]][y[k]] = (table[x[k]][y[k]] + p1) % mod;\n\t\ttable[y[k]][x[k]] = (table[y[k]][x[k]] + p2) % mod;\n\t}\n\tint r = 0;\n\trep(k, n) {\n\t\tfor (int l = 0; l < k; l++) {\n\t\t\tr += table[k][l];\n\t\t}\n\t}\n\tans += r;\n\n\tcout << ans*modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nll Power(ll x,ll k)\n{\n\tx%=mod;\n\tll sss=1;\n\twhile (k)\n\t{\n\t\tif (k%2) sss=sss*x%mod;\n\t\tx=x*x%mod;\n\t\tk/=2;\n\t}\n\treturn sss;\n}\nll ny(ll x){return Power(x,mod-2);}\nint n,q;\nll f[4030][4030];\nll ans;\nll a[5030],b[5][5030];\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&a[i]);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) if (a[i]>a[j]) f[i][j]=1;\n\n\tint x,y; ll doe=ny(2);\n\tfor (int i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==y) continue;\n\t\tfor (int j=1;j<=n;++j) \n\t\t{\n\t\t\tb[0][j]=f[j][x];\n\t\t\tb[1][j]=f[x][j];\n\t\t\tb[2][j]=f[j][y];\n\t\t\tb[3][j]=f[y][j];\n\t\t}\n\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) (f[j][y]+=b[0][j])%=mod;\n\t\t\tif (j!=x) (f[y][j]+=b[1][j])%=mod;\n\t\t\tif (j!=y) (f[j][x]+=b[2][j])%=mod; \n\t\t\tif (j!=y) (f[x][j]+=b[3][j])%=mod;\n\t\t}\n\t\tfor (int j=1;j<=n;++j)\n\t\t{\n\t\t\tif (j!=x) f[j][y]=f[j][y]*doe%mod;\n\t\t\tif (j!=x) f[y][j]=f[y][j]*doe%mod;\n\t\t\tif (j!=y) f[j][x]=f[j][x]*doe%mod;\n\t\t\tif (j!=y) f[x][j]=f[x][j]*doe%mod;\n\t\t}\n\t\tll A=f[x][y],B=f[y][x];\n\t\tf[y][x]+=A; f[x][y]+=B;\n\t\tf[x][y]=f[x][y]*doe%mod; \n\t\tf[y][x]=f[y][x]*doe%mod;\n\t}\n/*\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=1;j<=n;++j)\n\t\t\tprintf(\"%lld \",f[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n;++j) (ans+=f[i][j])%mod;\n\tans=ans*Power(2,q)%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 3e3 + 10, MOD = 1e9 + 7, I2 = (MOD + 1) / 2;\n\nint n, Q;\nint a[MAXN], P[MAXN][MAXN];\n\nint main() {\n\tscanf(\"%d%d\", &n, &Q);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) P[i][j] = a[i] > a[j];\n\tfor (int i = 1, x, y; i <= Q; ++i) {\n\t\tscanf(\"%d%d\", &x, &y), P[x][y] = P[y][x] = 1LL * (P[x][y] + P[y][x]) * I2 % MOD;\n\t\tfor (int j = 1; j <= n; ++j) if (j != x && j != y) P[x][j] = P[y][j] = 1LL * (P[x][j] + P[y][j]) * I2 % MOD, P[j][x] = P[j][y] = 1LL * (P[j][x] + P[j][y]) * I2 % MOD;\n\t}\n\tint pro = 1, ans = 0;\n\tfor (int i = 1; i <= Q; ++i) pro = pro * 2 % MOD;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j) ans = (ans + P[i][j]) % MOD;\n\tprintf(\"%d\\n\", 1LL * ans * pro % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const i64 mod = 1'000'000'007;\n    i64 N,Q;\n    cin >> N >> Q;\n    \n    vector<i64> A(N);\n    rep(i,0,N){\n        cin >> A[i];\n    }\n\n    vector<i64> X(Q),Y(Q);\n    rep(i,0,Q){\n        cin >> X[i] >> Y[i];\n        --X[i];\n        --Y[i];\n    }\n\n    const i64 size=3000;\n    static i64 pow2[size+1];\n    pow2[0]=1;\n    rep(i,1,size+1){\n        pow2[i]=pow2[i-1]*2%mod;\n    }\n    static i64 dp[size][size];\n    static i64 last[size][size];\n    fill_n((i64*)dp,size*size,0);\n    fill_n((i64*)last,size*size,-1);\n    rep(i,0,N) {\n        rep(j, 0, N) {\n            if (A[j] <= A[i]) continue;\n            ++dp[j][i];\n        }\n    }\n\n    rep(j,0,Q){\n        i64 x=X[j],y=Y[j];\n\n        auto evaluate=[&](i64 k,i64 l){\n            if(last[k][l]<j){\n                dp[k][l]*=pow2[j-last[k][l]-1];\n                dp[k][l]%=mod;\n            }\n            last[k][l]=j;\n        };\n\n        vector<i64> xk(N),kx(N),yk(N),ky(N);\n        rep(k,0,N){\n            evaluate(x,k);\n            xk[k]=dp[x][k];\n\n            evaluate(k,x);\n            kx[k]=dp[k][x];\n\n            evaluate(y,k);\n            yk[k]=dp[y][k];\n\n            evaluate(k,y);\n            ky[k]=dp[k][y];\n        }\n        rep(k,0,N){\n            if(k==x) continue;\n            dp[x][k]+=yk[k];\n            dp[x][k]%=mod;\n\n            dp[k][x]+=ky[k];\n            dp[k][x]%=mod;\n        }\n\n        rep(k,0,N){\n            if(k==y) continue;\n            dp[y][k]+=xk[k];\n            dp[y][k]%=mod;\n\n            dp[k][y]+=kx[k];\n            dp[k][y]%=mod;\n        }\n\n        dp[y][x]+=xk[y];\n        dp[y][x]%=mod;\n\n        dp[x][y]+=yk[x];\n        dp[x][y]%=mod;\n    }\n\n    i64 ans = 0;\n    rep(j,0,N){\n        rep(k,j+1,N){\n            dp[j][k]*=pow2[Q-last[j][k]-1];\n            dp[j][k]%=mod;\n            ans+=dp[j][k];\n            ans%=mod;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//dengyaotriangle\nusing namespace std;\n\nconst int maxn=3005;\nconst int mdn=1000000007;\nconst int inv2=(mdn+1)>>1;\nint n,q;\nint a[maxn];\npair<int,int> c[maxn];\nlong long dp[maxn][maxn];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin>>n>>q;\n    for(int i=1;i<=n;i++){cin>>a[i];}\n    for(int i=1;i<=q;i++){cin>>c[i].first>>c[i].second;}\n    for(int i=1;i<=n;i++){for(int j=1;j<=n;j++){dp[i][j]=(a[i]<a[j]);}} \n    for(int i=1;i<=q;i++){\n        int u=c[i].first,v=c[i].second;\n        long long mean=(dp[u][v]+dp[v][u])*inv2%mdn;\n        dp[u][v]=dp[v][u]=mean;\n        for(int j=1;j<=n;j++){\n            if(j==u||j==v)continue;\n            long long m1=(dp[j][u]+dp[j][v])*inv2%mdn;\n            dp[j][v]=m1;\n            dp[j][u]=m1;\n            long long m2=(dp[u][j]+dp[v][j])*inv2%mdn;\n            dp[u][j]=m2;\n            dp[v][j]=m2;\n        }\n    }\n    long long ans=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<i;j++){\n            ans+=dp[i][j];\n        }\n    }\n    long long tot=1;\n    for(int i=1;i<=q;i++){tot=(tot<<1)%mdn;}\n    cout<<(ans%mdn*tot)%mdn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=3e3+10;\nconst int mod=1e9+7;\nconst int inv2=(mod+1)/2;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n,q,a[N],f[N][N],pw=1;\nstruct data {\n    int x,y,z;\n};\nint qpow(int a,int b) {\n    int ret=1;\n    while(b) {\n        if(b&1) ret=1ll*ret*a%mod;\n        a=1ll*a*a%mod,b>>=1;\n    }\n    return ret;\n}\nint main() {\n    n=gi(),q=gi();\n    for(int i=1;i<=n;i++) a[i]=gi();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++) f[i][j]=a[i]<a[j];\n    while(q--) {\n        pw=2ll*pw%mod;\n        int i=gi(),j=gi();\n        vector<data> v;\n        if(i>j) swap(i,j);\n        auto insert=[&](int x,int y,int z,int op=0) {\n                        v.pb({x,y,z});\n                        //cerr<<x<<\" \"<<y<<\" \"<<z<<\" \"<<op<<endl;\n                    };\n        for(int k=1;k<=n;k++) {\n            insert(i,k,1ll*inv2*add(f[i][k],f[j][k])%mod,1);\n            insert(k,i,1ll*inv2*add(f[k][i],f[k][j])%mod,2);\n            insert(j,k,1ll*inv2*add(f[i][k],f[j][k])%mod,3);\n            insert(k,j,1ll*inv2*add(f[k][i],f[k][j])%mod,4);\n        }\n        insert(i,j,1ll*inv2*add(f[i][j],f[j][i])%mod);\n        insert(j,i,1ll*inv2*add(f[i][j],f[j][i])%mod);\n        for(auto i:v) f[i.x][i.y]=i.z;\n        cerr<<endl;\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++) inc(ans,1ll*f[j][i]*pw%mod);\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// sync\n\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 3e3 + 33, P = 1e9 + 7, div2 = (P + 1) / 2;\n\nint n, m, x, y, a[N], b[N], dp[N][N], tmp[N][N], ans, pw2 = 1;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i), b[i] = a[i];\n\tstd::sort(b + 1, b + n + 1);\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(b + 1, b + n + 1, a[i]) - b;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) dp[i][j] = a[i] > a[j];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tfor (int j = 1, u, v; j <= n; j++)\n\t\t\tif (j != x && j != y) {\n\t\t\t\tu = 1ll * (dp[j][x] + dp[j][y]) * div2 % P;\n\t\t\t\tv = 1ll * (dp[y][j] + dp[x][j]) * div2 % P;\n\t\t\t\tdp[j][x] = u, dp[j][y] = u;\n\t\t\t\tdp[x][j] = v, dp[y][j] = v;\n\t\t\t}\n\t\tint u = 1ll * (dp[x][y] + dp[y][x]) * div2 % P;\n\t\tdp[x][y] = dp[y][x] = u;\n\t\tpw2 = pw2 * 2 % P;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) ans = (ans + dp[i][j]) % P;\n\tprintf(\"%lld\", 1ll * ans * pw2 % P);\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nusing mint=ModInt<1000000007>;\n\nconst int N=3010;\nconst mint inv2=mint(2).inv();\nint n;\nmint dp[N][N];\nvoid go( int x, int y ) {\n    auto to=[&]( int i ) {\n        if ( i==x ) return y;\n        if ( i==y ) return x;\n        return i;\n    };\n    vector<tuple<int,int,mint>> v;\n    auto push=[&]( int r, int c ) {\n        if ( r<c ) v.PB({r,c,dp[r][c]});\n    };\n    REP1(i,1,n) {\n        push(i,x);\n        push(i,y);\n        push(x,i);\n        push(y,i);\n    }\n    sort_uniq(v);\n    for ( auto i:v ) {\n        int r=get<0>(i),c=get<1>(i);\n        mint t=get<2>(i);\n        dp[r][c]-=t*inv2;\n        int nr=to(r),nc=to(c);\n        mint nt=t;\n        if ( nr>nc ) {\n            swap(nr,nc);\n            nt=mint(1)-nt;\n        }\n        dp[nr][nc]+=nt*inv2;\n    }\n}\n\nint q,a[N],x[N],y[N];\n\nmint run() {\n    REP(i,q) go(x[i],y[i]);\n    mint ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) ans+=dp[i][j];\n    ans*=mint(2).pow(q);\n    return ans;\n}\n\nvoid main() {\n    R(n,q);\n    REP1(i,1,n) R(a[i]);\n    REP(i,q) R(x[i],y[i]);\n    mint ans=0;\n    REP1(i,1,n) REP1(j,i+1,n) dp[i][j]=(a[i]>a[j]);\n    ans+=run();\n    memset(dp,0,sizeof(dp));\n    REP1(i,1,n) REP1(j,i+1,n) dp[i][j]=(a[i]>=a[j]);\n    ans+=run();\n    mint cnt=0;\n    REP1(i,1,n) REP1(j,i+1,n) cnt+=(a[i]==a[j]);\n    cnt*=mint(2).pow(q);\n    ans-=cnt;\n    ans*=inv2;\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n  }\n  public:\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  const int md = 1e9 + 7;\n  finite_field fld(1e9 + 7);\n  int inv2 = fld.inv(2);\n  int coeff = fld.pow(2, q);\n  while (q--) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      a = b = (long long)(a + b) * inv2 % md;\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tK = power(2, M, MOD);\n\tvector<vector<long long int>>dp(N, vector<long long int>(N, 0));\n\tvector<vector<long long int>>ch(N, vector<long long int>(N, 0));\n\tvector<long long int>rev_by(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\trev_by[i] = rev_by[i] * power(2, MOD - 2, MOD);\n\t\trev_by[i] %= MOD;\n\t}\n\tvector<long long int>v(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (v[i] > v[j])dp[i][j] = K;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tlong long int sum = dp[L][j] + dp[R][j];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[R][j] = ch[L][j] = sum;\n\t\t\tsum = dp[j][L] + dp[j][R];\n\t\t\tsum %= MOD;\n\t\t\tsum *= rev_by[1];\n\t\t\tsum %= MOD;\n\t\t\tch[j][R] = ch[j][L] = sum;\n\t\t}\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == L || j == R)continue;\n\t\t\tdp[R][j] = dp[L][j] = ch[L][j];\n\t\t\tdp[j][R] = dp[j][L] = ch[j][L];\n\t\t}\n\t\tdp[L][R] = dp[R][L] = (((dp[L][R] + dp[R][L])%MOD)*rev_by[1]) % MOD;\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++)ans += dp[i][j];\n\t}\n\tcout << ans % MOD << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3005;\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) / 2;\ntypedef long long ll;\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint n, q, a[MAXN], x[MAXN], y[MAXN];\nint mul, inv, dp[MAXN][MAXN];\nint main() {\n\tread(n), read(q);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]);\n\tfor (int i = 1; i <= q; i++)\n\t\tread(x[i]), read(y[i]);\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = 1; j <= n; j++)\n\t\tdp[i][j] = i > j;\n\tmul = inv = 1;\n\tfor (int i = q; i >= 1; i--) {\n\t\tint tmp = 1ll * inv2 * inv % P;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (j != x[i] && j != y[i]) {\n\t\t\t\tdp[x[i]][j] = dp[y[i]][j] = 1ll * mul * (dp[x[i]][j] + dp[y[i]][j]) % P * tmp % P;\n\t\t\t\tdp[j][x[i]] = dp[j][y[i]] = 1ll * mul * (dp[j][x[i]] + dp[j][y[i]]) % P * tmp % P;\n\t\t\t}\n\t\tdp[x[i]][y[i]] = dp[y[i]][x[i]] = 1ll * mul * (dp[x[i]][y[i]] + dp[y[i]][x[i]]) % P * tmp % P;\n\t\tmul = 2ll * mul % P, inv = tmp;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = 1; j <= n; j++)\n\t\tdp[i][j] = 1ll * dp[i][j] * mul % P;\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\t\tif (a[i] < a[j]) ans = (ans + dp[i][j]) % P;\n\t\telse if (a[i] > a[j]) ans = (ans + dp[j][i]) % P;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n//#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define modsum(a, b) ((a) + (b) >= M ? (a) + (b) - M : (a) + (b))\n#define modsubtract(a, b) ((a) - (b) < 0 ? (a) - (b) + M : (a) - (b))\n#define modmultiply(a, b) (((a) * (b)) % M)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int &\n#define SZ(a) ((int)((a).size()))\n#define watch(x) cout << (#x) << \" = \" << (x) << endl;\n\nconst double PI = 2 * acos(0.0);\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T>\nostream & operator << (ostream &out, vector<T> &a) {\n    out << \"{\";\n    fori (i, SZ(a))\n        out << a[i] << vector<string>{\", \", \"}\"}[i + 1 == SZ(a)];\n    return out;\n}\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\n\";\n    cout << \"TOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n}\n\nint n, q;\nconst int N = 3003;\nconst ll M = 1e9 + 7;\nint a[N];\n\nll pw(ll a, ll n) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = (ret * a) % M;\n        a = (a * a) % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll pw2[N];\n\nmap<pii, int> dp[N];\n\npii queries[N];\n\nvi my_q[N];\n\nll dfs(int i, int l, int r) {\n    if (i == q) {\n        if (l > r) return 1;\n        return 0;\n    }\n    if (dp[i].count({l, r})) return dp[i][{l, r}];\n\n    vi cur1, cur2;\n    for (int j = upper_bound(ALL(my_q[l]), i - 1) - my_q[l].begin(); j < SZ(my_q[l]); ++j) {\n        int ind = my_q[l][j];\n        cur1.push_back(ind);\n    }\n    for (int j = upper_bound(ALL(my_q[r]), i - 1) - my_q[r].begin(); j < SZ(my_q[r]); ++j) {\n        int ind = my_q[r][j];\n        cur2.push_back(ind);\n    }\n    vi cur_q(cur1.size() + cur2.size());\n    merge(ALL(cur1), ALL(cur2), cur_q.begin());\n    cur_q.resize(unique(ALL(cur_q)) - cur_q.begin());\n    \n    ll ret = 0;\n    for (int j = 0; j < cur_q.size(); ++j) {\n        int ind = cur_q[j];\n        int lf = queries[ind].first, rf = queries[ind].second;\n        if ((l < r) ^ (lf < rf)) swap(lf, rf);\n        ll ways = pw2[ind - i - j];\n        if (lf == l && rf == r) {\n            ret = (ret + ways * dfs(ind + 1, r, l)) % M;\n        } else if (lf == l || rf == l) {\n            if (lf != l) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, rf, r)) % M;\n        } else if (rf == r || lf == r) {\n            if (rf != r) swap(lf, rf);\n            ret = (ret + ways * dfs(ind + 1, l, lf)) % M;\n        } else assert(0);\n    }\n    ret = (ret + pw2[q - i - cur_q.size()] * dfs(q, l, r)) % M;\n    return dp[i][{l, r}] = ret;\n}\n\nvoid smain() {\n    pw2[0] = 1;\n    for (int i = 1; i < N; ++i) pw2[i] = pw2[i - 1] * 2 % M;\n    cin >> n >> q;\n    fori (i, n) cin >> a[i];\n    fori (i, q) {\n        cin >> queries[i].first >> queries[i].second;\n        queries[i].first--, queries[i].second--;\n        my_q[queries[i].first].push_back(i);\n        my_q[queries[i].second].push_back(i);\n    }\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ll cur = dfs(0, i, j);\n//            cout << \"cur[\" << i << \", \" << j << \"] = \" << cur << endl;\n            if (a[i] < a[j]) ans = (ans + cur) % M;\n            else if (a[i] > a[j]) ans = (ans + pw2[q] - cur + M) % M;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T> bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> v) {\n    for (int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for (auto &e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <ll mod> struct modint {\n    ll val;\n    inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n        if (a < b) {\n            return extgcd(b, a, y, x);\n        }\n        if (b == 0) {\n            x = 1, y = 0;\n            return a;\n        }\n        ll d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n        return d;\n    }\n    inline ll minv(ll k) {\n        ll x = 0, y = 0;\n        extgcd(k, mod, x, y);\n        if (x < 0) {\n            x += mod;\n        } else if (x == mod) {\n            x = 0;\n        }\n        return x;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(ll x) { val = (x + mod) % mod; }\n    modint inv() { return modint(minv(val)); }\n    modint operator+(const modint &to) const { return modint(val + to.val); }\n    modint operator-(const modint &to) const { return modint(val - to.val); }\n    modint operator*(const modint &to) const { return modint(val * to.val); }\n    modint operator/(const modint &to) const {\n        return modint(val * minv(to.val));\n    }\n    template <class T> explicit operator T() { return T(val); }\n    modint &operator++() { return *this = modint(val + 1); }\n    modint &operator--() { return *this = modint(val - 1); }\n    template <typename T> modint &operator+=(const T &to) {\n        return *this = *this + to;\n    }\n    template <typename T> modint &operator-=(const T &to) {\n        return *this = *this - to;\n    }\n    template <typename T> modint &operator*=(const T &to) {\n        return *this = *this * to;\n    }\n    template <typename T> modint &operator/=(const T &to) {\n        return *this = *this / to;\n    }\n    bool operator==(const modint &to) const { return val == to.val; }\n    bool operator!=(const modint &to) const { return val != to.val; }\n    bool operator>(const modint &to) const { return val > to.val; }\n    bool operator>=(const modint &to) const { return val >= to.val; }\n    bool operator<(const modint &to) const { return val < to.val; }\n    bool operator<=(const modint &to) const { return val <= to.val; }\n};\nusing mint = modint<MOD>;\nmint dp[3010][3010];\nint co[3010][3010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n            co[i][j] = -1;\n        }\n    }\n    vector<mint> p(q + 1);\n    p[0] = 1;\n    for (int i = 1; i <= q; i++) {\n        p[i] = p[i - 1] * 2LL;\n    }\n    for (ll i = 0; i < q; i++) {\n        int x, y;\n        cin >> x >> y;\n        --x;\n        --y;\n        mint s =\n            dp[x][y] * p[i - co[x][y] - 1] + dp[y][x] * p[i - co[y][x] - 1];\n        dp[x][y] = s;\n        dp[y][x] = s;\n        co[x][y] = i;\n        co[y][x] = i;\n        for (int j = 0; j < n; j++) {\n            if (j != x && j != y) {\n                mint s1 = dp[j][x] * p[i - co[j][x] - 1] +\n                          dp[j][y] * p[i - co[j][y] - 1],\n                     s2 = dp[x][j] * p[i - co[x][j] - 1] +\n                          dp[y][j] * p[i - co[y][j] - 1];\n                dp[j][x] = s1;\n                dp[x][j] = s2;\n                dp[j][y] = s1;\n                dp[y][j] = s2;\n                co[x][j] = i;\n                co[j][x] = i;\n                co[y][j] = i;\n                co[j][y] = i;\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            res += dp[i][j] * p[q - co[i][j] - 1];\n        }\n    }\n    cout << res.val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint a[3005], x[3005], y[3005];\nint table[3005][3005];\n\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\trep(i, n) {\n\t\tcin >> a[i]; a[i]--;\n\t}\n\trep(i, q) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tint ans = 0;\n\n\n\trep(i, n) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (a[i] < a[j])table[i][j] = 1;\n\t\t\tif (a[i] > a[j])table[j][i] = 1;\n\t\t}\n\t}\n\n\trep(k, q) {\n\t\t//x[i]とy[i]をswap\n\t\trep(l, n) {//(x,l)->(y,l)\n\t\t\tif (x[k] == l || y[k] == l)continue;\n\t\t\ttable[x[k]][l] = table[x[k]][l] * modpow(2, mod - 2) % mod;\n\t\t\ttable[y[k]][l] = table[y[k]][l] * modpow(2, mod - 2) % mod;\n\t\t\ttable[l][x[k]] = table[l][x[k]] * modpow(2, mod - 2) % mod;\n\t\t\ttable[l][y[k]] = table[l][y[k]] * modpow(2, mod - 2);\n\t\t\tint p1 = table[x[k]][l], p2 = table[y[k]][l], p3 = table[l][x[k]], p4 = table[l][y[k]];\n\t\t\ttable[x[k]][l] = (table[x[k]][l] + p2) % mod;\n\t\t\ttable[y[k]][l] = (table[y[k]][l] + p1) % mod;\n\t\t\ttable[l][x[k]] = (table[l][x[k]] + p4) % mod;\n\t\t\ttable[l][y[k]] = (table[l][y[k]] + p3) % mod;\n\t\t}\n\t\ttable[x[k]][y[k]] = table[x[k]][y[k]] * modpow(2, mod - 2) % mod;\n\t\ttable[y[k]][x[k]] = table[y[k]][x[k]] * modpow(2, mod - 2) % mod;\n\t\tint p1 = table[y[k]][x[k]], p2 = table[x[k]][y[k]];\n\t\ttable[x[k]][y[k]] = (table[x[k]][y[k]] + p1) % mod;\n\t\ttable[y[k]][x[k]] = (table[y[k]][x[k]] + p2) % mod;\n\t}\n\tint r = 0;\n\trep(k, n) {\n\t\tfor (int l = 0; l < k; l++) {\n\t\t\tr += table[k][l];\n\t\t}\n\t}\n\tans += r;\n\n\tcout << ans*modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <iostream>\n#define MODD 1000000007\n#define ll long long\nusing namespace std;\n\n\nint A[3333];\n\nll modpow(ll x, ll y) {\n    x%=MODD;\n    ll xs = x;\n    ll answer = 1;\n    while(y) {\n        if (y&1) {\n            answer = (answer * xs) % MODD;\n        }\n        y >>= 1;\n        xs = (xs * xs) % MODD;\n    }\n    return answer;\n}\n\n\nll X[3333][3333];\nll Y[3333][3333];\n\n\n\nint main() {\n    int N,Q;\n    cin>>N>>Q;\n    for(int i=1;i<=N;i++)\n        cin>>A[i];\n    \n    \n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++) {\n            X[i][j] = (A[i] < A[j] ? 1 : 0);\n            Y[i][j] = (A[i] > A[j] ? 1 : 0);\n        }\n    \n    ll twoinv = modpow(2,MODD-2);\n    \n    for(int q=1;q<=Q;q++) {\n        \n        int x,y;\n        cin>>x>>y;\n        \n        \n        // X[x][y] and X[y][x]\n        \n        // X[x][i] -> X[y][i]\n        // X[y][i] -> X[x][i]\n        \n        \n        \n        \n        // P(A[x] < A[y]) and P(A[y] < A[x])\n        \n        ll newx = (X[x][y]+X[y][x])*twoinv%MODD;\n        ll newy = (Y[x][y]+Y[y][x])*twoinv%MODD;\n        \n        \n        for(int j=1;j<=N;j++) {\n            if (j != x && j != y) {\n                X[x][j]=X[y][j]=(X[x][j]+X[y][j])*twoinv%MODD;\n                Y[x][j]=Y[y][j]=(Y[x][j]+Y[y][j])*twoinv%MODD;\n            }\n        }\n        for(int i=1;i<=N;i++) {\n            if (i != x && i != y) {\n                X[i][x]=X[i][y]=(X[i][x]+X[i][y])*twoinv%MODD;\n                Y[i][x]=Y[i][y]=(Y[i][x]+Y[i][y])*twoinv%MODD;\n            }\n        }\n        \n        X[x][y]=X[y][x]=newx;\n        Y[x][y]=Y[y][x]=newy;\n        X[x][x]=X[y][y]=Y[x][x]=Y[y][y]=0;\n        \n    }\n    \n    ll ans = 0;\n    \n    for(int i=1;i<=N;i++)\n        for(int j=1;j<=N;j++) {\n            if (i < j) {\n                ans = (ans + Y[i][j])%MODD;\n            } else {\n                ans = (ans + X[i][j])%MODD;\n            }\n        }\n    \n    ans = (ans * modpow(2, Q))%MODD;\n    ans = (ans * twoinv)%MODD;\n    \n    cout << ans << endl;\n    \n    \n    // M[i][j] = P(X[i] < X[j])\n    \n    \n    \n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 1e9 + 7;\nint nxt[3005][3005], arr[3005], lst[3005];\nint dp[3005][2][2][3005], qx[3005], qy[3005], pw[3005];\nint calc(int p, int x, int y)\n{\n\tif (p == -1)\n\t\treturn arr[x] > arr[y];\n\tint t = std::max(nxt[p][x], nxt[p][y]), coef = pw[p - t];\n\tp = t;\n\tif (p == -1)\n\t\treturn (arr[x] > arr[y]) * coef;\n\tbool a = qx[p] == x || qy[p] == x, b = qx[p] == y || qy[p] == y;\n\tint &res = dp[p][a][a ? (x == qx[p]) : (y == qx[p])][b ? x : y];\n\tif (~res)\n\t\treturn res;\n\tres = calc(p - 1, x, y);\n\tif (a && b)\n\t\tres += calc(p - 1, y, x);\n\telse if (a)\n\t\tres += calc(p - 1, qx[p] ^ qy[p] ^ x, y);\n\telse if (b)\n\t\tres += calc(p - 1, x, qx[p] ^ qy[p] ^ y);\n\telse\n\t\tthrow \"GG\";\n\treturn res = (ll)res * coef % MOD;\n}\nint main()\n{\n\t// freopen(\"AGC030-D.in\", \"r\", stdin);\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", arr + i);\n\tmemset(lst, -1, sizeof(lst));\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d%d\", qx + i, qy + i);\n\t\tqx[i]--;\n\t\tqy[i]--;\n\t\tlst[qx[i]] = lst[qy[i]] = i;\n\t\tmemcpy(nxt[i], lst, sizeof(lst));\n\t}\n\tpw[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tpw[i] = pw[i - 1] * 2 % MOD;\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t(ans += calc(m - 1, i, j)) %= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=3010,Mo=1000000007,P=(Mo+1)/2;\nint a[N],f[N][N],g[N][N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') ch=='-'?o=-1:0,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return o*x;\n}\nint main() {\n    int n,Q,ans=0,t=1;\n    cin>>n>>Q;\n    for(int i=1;i<=n;i++) a[i]=gi();\n    for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t    f[i][j]=(a[i]<a[j]),g[i][j]=(a[i]>a[j]);\n    for(int i=1;i<=Q;i++) {\n\tint x=gi(),y=gi();t=2*t%Mo;\n\tfor(int j=1;j<=n;j++)\n\t    if(j!=x&&j!=y) {\n\t\tg[x][j]=g[y][j]=f[j][x]=f[j][y]=1LL*P*(f[j][x]+f[j][y])%Mo;\n\t\tf[x][j]=f[y][j]=g[j][x]=g[j][y]=1LL*P*(g[j][x]+g[j][y])%Mo;\n\t    }\n\tf[x][y]=g[x][y]=f[y][x]=g[y][x]=1LL*P*(f[x][y]+g[x][y])%Mo;\n    }\n    for(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n;j++)\n\t    ans=(ans+1LL*g[i][j]*t)%Mo;\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll C(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\n\n\nint N, Q;\nll dp[3010][3010];\nint X[3010], Y[3010];\nint A[3010];\n\n\n\nvoid solve() {\n\tcin >> N >> Q;\n\trep(i, 0, N) cin >> A[i];\n\trep(i, 0, Q) {\n\t\tcin >> X[i] >> Y[i];\n\t\tX[i]--; Y[i]--;\n\t}\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tdp[i][j] = 1;\n\t\t}\n\t}\n\tll div2 = invf(2);\n\trer(k, Q, 0) {\n\t\tint x = X[k], y = Y[k];\n\t\trep(i, 0, N) {\n\t\t\tif(i == x || i == y) continue;\n\t\t\tMUL(dp[i][x], div2);\n\t\t\tMUL(dp[i][y], div2);\n\t\t\tll vx = dp[i][x];\n\t\t\tll vy = dp[i][y];\n\t\t\tdp[i][x] = (vx + vy) % mod;\n\t\t\tdp[i][y] = (vx + vy) % mod;\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\tif(j == x || j == y) continue;\n\t\t\tMUL(dp[x][j], div2);\n\t\t\tMUL(dp[y][j], div2);\n\t\t\tll vx = dp[x][j];\n\t\t\tll vy = dp[y][j];\n\t\t\tdp[x][j] = (vx + vy) % mod;\n\t\t\tdp[y][j] = (vx + vy) % mod;\n\t\t}\n\t\tMUL(dp[x][y], div2);\n\t\tMUL(dp[y][x], div2);\n\t\tll v1 = dp[x][y];\n\t\tll v2 = dp[y][x];\n\t\tdp[x][y] = (v1 + v2) % mod;\n\t\tdp[y][x] = (v1 + v2) % mod;\n\t\t// rep(i, 0, N) {\n\t\t// \tdebug(k, vl(dp[i], dp[i] + N));\n\t\t// }\n\t}\n\tll res = 0;\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tll v = dp[i][j];\n\t\t\tll pv = (1 - dp[i][j] + mod) % mod;\n\t\t\tif(A[i] > A[j]) ADD(res, v);\n\t\t\telse if(A[i] < A[j]) ADD(res, pv);\n\t\t}\n\t}\n\tcout << (res * mod_pow(2, Q)) % mod << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n  const int md;\n  const int sz;\n  vector<int> fct, fnv;\n  int inv2 = -1;\n  void init () {\n    if (sz) {\n      fct[0] = 1;\n      for (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n      fnv[sz - 1] = inv(fct[sz - 1]);\n      for (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n    }\n    inv2 = inv(2);\n  }\n  public :\n    finite_field(\n        const int md,\n        const int init_factorial_size = 0,\n        const int init_power_size = 0\n      ) :\n      md(md), sz(init_factorial_size),\n      fct(sz), fnv(sz)\n      {\n        init();\n      }\n    inline void add (int& a, const int b) const {\n      a += b;\n      if (a >= md) a -= md;\n    }\n    inline void sub (int& a, const int b) const {\n      a -= b;\n      if (a < 0) a += md;\n    }\n    template<class... A> inline int sum (A... args) const {\n      int ret = 0;\n      for (int a : initializer_list<int>{args...}) {\n        add(ret, a);\n      }\n      return ret;\n    }\n    inline int dif (int a, int b) const {\n      sub(a, b);\n      return a;\n    }\n    template<class... A> inline int prod (A... args) const {\n      long long ret = 1;\n      for (int a : initializer_list<int>{args...}) {\n        ret *= a;\n        ret %= md;\n      }\n      return (int)ret;\n    }\n    void mul (int& a, int b) const {\n      a = prod(a, b);\n    }\n    inline int inv (int a) const {\n      if (a == 2 && inv2 != -1) return inv2;\n      a %= md; if (a < 0) a += md;\n      int b = md, u = 0, v = 1;\n      while (a) {\n        int t = b / a;\n        b -= a * t; swap(a, b);\n        u -= v * t; swap(u, v);\n      }\n      assert(b == 1);\n      if(u < 0) u += md;\n      return u;\n    }\n    inline int quat (int a, int b) const {\n      return prod(a, inv(b));\n    }\n    inline void div (int& a, int b) const {\n      a = quat(a, b);\n    }\n    inline int pow (int a, long long b) {\n      int ret = 1;\n      for (; b; b >>= 1) {\n        if (b & 1) mul(ret, a);\n        a = prod(a, a);\n      }\n      return ret;\n    }\n    inline int binom (int n, int k) const {\n      assert(0 <= n && n < sz);\n      if (k < 0 || n < k) return 0;\n      return prod(fct[n], fnv[k], fnv[n - k]);\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<vector<int>> dp(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = a[i] > a[j] ? 1 : 0;\n    }\n  }\n  finite_field fld(1e9 + 7);\n  for (int cnt = 0; cnt < q; cnt++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    auto half = [&] (int& a, int& b) -> void {\n      fld.add(a, b);\n      fld.div(a, 2);\n      b = a;\n    };\n    half(dp[x][y], dp[y][x]);\n    for (int z = 0; z < n; z++) if (z != x && z != y) {\n      half(dp[x][z], dp[y][z]);\n      half(dp[z][x], dp[z][y]);\n    }\n  }\n  int ret = 0;\n  int coeff = fld.pow(2, q);\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      fld.mul(dp[i][j], coeff);\n      fld.add(ret, dp[i][j]);\n    }\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nconst int mod=1e9+7;\nconst int r=(mod+1)>>1;\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\nint n,Q;\nint a[3050];\nint f[3050][3050]; \nint t[3050][3050];\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(a[i]>a[j]) f[i][j]=1;\n\t\t}\n\t} \n\tfor(int i=1;i<=Q;++i)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tfor(int j=1;j<=n;++j) if(j!=x)\n\t\t{\n\t\t\tt[j][x]=1ll*(f[j][x]+f[j][y])*r%mod;\n\t\t\tt[x][j]=1ll*(f[x][j]+f[y][j])*r%mod;\n\t\t}\n\t\tfor(int j=1;j<=n;++j) if(j!=y)\n\t\t{\n\t\t\tt[j][y]=1ll*(f[j][y]+f[j][x])*r%mod;\n\t\t\tt[y][j]=1ll*(f[y][j]+f[x][j])*r%mod;\n\t\t}\n\t\tt[x][y]=1ll*(f[x][y]+f[y][x])*r%mod;\n\t\tt[y][x]=1ll*(f[y][x]+f[x][y])*r%mod;\n\t\tfor(int j=1;j<=n;++j) if(j!=x)\n\t\t{\n\t\t\tf[j][x]=t[j][x];\n\t\t\tf[x][j]=t[x][j];\n\t\t}\n\t\tfor(int j=1;j<=n;++j) if(j!=y)\n\t\t{\n\t\t\tf[j][y]=t[j][y];\n\t\t\tf[y][j]=t[y][j];\n\t\t}\n\t\tf[x][y]=t[x][y];\n\t\tf[y][x]=t[y][x];\n\t}\n\tint an=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tan=add(an+f[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=Q;++i)\n\t{\n\t\tan=add(an<<1);\n\t}\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 3050;\nconst int P = 1e9 + 7;\nconst int inv2 = (P + 1) >> 1;\nint A[N][N], a[N], n, q;\ninline ll add(int x, int y) { return x + y >= P ? x + y - P : x + y; }\nvoid out(void) {\n    for (int i = 1;i <= n; i++, puts(\"\"))\n        for (int j = 1;j <= n; j++)\n            write(A[i][j], ' ');\n    puts(\"\");\n}\nint main() {\n    read(n), read(q);\n    for (int i = 1;i <= n; i++) read(a[i]);\n    for (int i = 1;i <= n; i++)\n        for (int j = 1;j <= n; j++) \n            A[i][j] = a[i] > a[j];\n    /* puts(\"\"); */\n    ll mi = 1;\n    for (int i = 1, x, y;i <= q; i++) {\n        /* out(); */\n        mi = add(mi, mi);\n        read(x), read(y);\n        /* if (x > y) swap(x, y); */\n        for (int i = 1;i <= n; i++) {\n            if (i == x || i == y) continue;\n            int tx = A[x][i], ty = A[y][i];\n            int ttx = A[i][x], tty = A[i][y];\n            A[x][i] = add(tx, ty) * inv2 % P;\n            A[y][i] = add(tx, ty) * inv2 % P;\n            A[i][x] = add(ttx, tty) * inv2 % P;\n            A[i][y] = add(ttx, tty) * inv2 % P;\n        }\n        A[x][y] = A[y][x] = inv2;\n    }\n    /* out(); */\n    int ans = 0;\n    for (int i = 1;i <= n; i++) \n        for (int j = i + 1;j <= n; j++)\n            ans = add(ans, A[i][j]);\n    write(ans * mi % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e3 + 100;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nll C[maxn][maxn];\n\nll S[maxn][maxn];\n\nll A[maxn];\n\nvector <pll> Q;\n\nvector <ll> I;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll geti(ll x) {\n    return lower_bound(all(I), x) - I.begin();\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> k;\n    for (q = 0; q < n; q++) {\n        cin >> A[q];\n        I.pb(A[q]);\n        // A[q]--;\n        // C[q][A[q]]++;\n    }\n    sort(all(I));\n    I.resize(unique(all(I)) - I.begin());\n    for (q = 0; q < n; q++) {\n        A[q] = geti(A[q]);\n        // C[q][A[q]]++;\n    }\n    for (q = 0; q < n; q++) {\n        for (w = 0; w < n; w++) {\n            if (A[q] > A[w]) {\n                // cout << q << \" \" << w << \" Q W\" << endl;\n                C[q][w]++;\n            }\n        }\n    }\n    // cout << \"C:\" << endl;;\n    // for (w = 0; w < n; w++) {\n    //     for (e = 0; e < n; e++) {\n    //         cout << C[w][e] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n    for (q = 0; q < k; q++) {\n        cin >> a >> b;\n        a--; b--;\n        Q.pb(mp(a, b));\n        // cout << \"A B \" << a << \" \" << b << endl;\n        for (w = 0; w < n; w++) {\n            if (w == a || w == b) {\n                continue;\n            }\n            C[w][a] = (C[w][a] + C[w][b]) % mod;\n            C[a][w] = (C[a][w] + C[b][w]) % mod;\n            C[w][b] = C[w][a];\n            C[b][w] = C[a][w];\n\n            C[w][a] = del(C[w][a], 2);\n            C[a][w] = del(C[a][w], 2);\n            C[w][b] = del(C[w][b], 2);\n            C[b][w] = del(C[b][w], 2);\n        }\n        ll sum = C[a][b] + C[b][a];\n        C[a][b] = C[b][a] = sum;\n        C[a][b] = del(C[a][b], 2);\n        C[b][a] = del(C[b][a], 2);\n        // swap(C[a][b], C[b][a]);\n        // cout << \"C:\" << endl;;\n        // for (w = 0; w < n; w++) {\n        //     for (e = 0; e < n; e++) {\n        //         cout << C[w][e] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        // for (w = 0; w < n; w)\n    }\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        for (w = q + 1; w < n; w++) {\n            ll dans = C[q][w];\n            // ll dans = (C[q][w] * S[q - 1][w + 1]) % mod;\n            ans += dans;\n            ans %= mod;\n        }\n    }\n    cout << ans * step(2, k) % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n*/\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n       \n        \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define rank rank228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int Mod = 1000000007;\nconst int MAXN = 3008;\n\n\nint sum(int a, int b) {\n    return (1LL * a + b) % Mod;\n}\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\n\nint n, q;\nlong long dp[MAXN][MAXN];\nint a[MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> q;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i] > a[j]) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    int kek = powm(2, Mod - 2);\n    for (int it = 0; it < q; it++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        for (int i = 0; i < n; i++) {\n            if (i == x || i == y) {\n                continue;\n            }\n            dp[x][i] = dp[y][i] = mul(sum(dp[x][i], dp[y][i]), kek);\n            dp[i][x] = dp[i][y] = mul(sum(dp[i][x], dp[i][y]), kek);\n        }\n        dp[x][y] = dp[y][x] = mul(sum(dp[x][y], dp[y][x]), kek);\n    }   \n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            ans = sum(ans, dp[i][j]);\n        }\n    }\n    ans = mul(ans, powm(2, q));\n    cout << ans << '\\n';\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define i2 500000004ll\nusing namespace std;\nint read();\nvoid Add(int &x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nint n, m;\nint a[3003], f[3003][3003];\nint main() {\n    n = read(), m = read();\n    for (int i = 1; i <= n; ++i) {\n        a[i] = read();\n        for (int j = 1; j < i; ++j)\n            f[j][i] = a[j] > a[i], f[i][j] = a[i] > a[j];\n    }\n\n    for (int i = 1, x, y; i <= m; ++i) {\n        x = read(), y = read();\n        for (int j = 1; j <= n; ++j) {\n            if (j == x || j == y) continue;\n            f[j][x] = f[j][y] = i2 * (f[j][x] + f[j][y]) % mod;\n            f[x][j] = f[y][j] = i2 * (f[x][j] + f[y][j]) % mod;\n        }\n        f[x][y] = f[y][x] = i2 * (f[x][y] + f[y][x]) % mod, swap(f, f);\n    }\n\n    int res = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) Add(res, f[j][i]);\n\n    for (int i = 1; i <= m; ++i) Add(res, res);\n    printf(\"%d\\n\", res);\n    return 0;\n}\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = getchar();\n    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nll dp[3030][3030];\nint d[3030];\nint main()\n{\n\tint num, query;\n\tscanf(\"%d%d\", &num, &query);\n\tfor (int i = 0; i < num; i++)scanf(\"%d\", &d[i]);\n\tfor (int i = 0; i < num; i++)for (int j = 0; j < num; j++)dp[i][j] = d[i] < d[j];\n\tconst ll m=(mod+1)/2;\n  \tfor (int p = 0; p < query; p++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tfor (int i = 0; i < num; i++)\n\t\t{\n\t\t\tif (i != za&&i != zb)\n\t\t\t{\n\t\t\t\tdp[za][i] = dp[zb][i] = (dp[za][i] + dp[zb][i])*m % mod;\n\t\t\t\tdp[i][za] = dp[i][zb] = (dp[i][za] + dp[i][zb])*m % mod;\n\t\t\t}\n\t\t}\n\t\tdp[za][zb] = dp[zb][za] = (dp[za][zb] + dp[zb][za])*m % mod;\n\t}\n\tll r = 0;\n\tfor (int i = 0; i < num; i++)for (int j = 0; j < i; j++)r = (r + dp[i][j]) % mod;\n\tfor (int i = 0; i < query; i++)r = r * 2 % mod;\n\tprintf(\"%lld\\n\", r);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 3e3 + 5;\n\nint arr [MAX_N];\nModint dp [MAX_N][MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n\n  for (int i = 1; i <= n; i++) {\n    cin >> arr[i];\n  }\n\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (arr[i] > arr[j]) {\n        dp[i][j] = Modint(1);\n      }\n    }\n  }\n\n  Modint i2 = inv(Modint(2));\n  for (int t = 0; t < q; t++) {\n    int x, y;\n    cin >> x >> y;\n\n    vector<pair<pair<int, int>, Modint>> upd;\n    for (int i = 1; i <= n; i++) {\n      if (i != x && i != y) {\n        Modint avg = i2 * (dp[i][x] + dp[i][y]);\n        upd.push_back({{i, x}, avg});\n        upd.push_back({{i, y}, avg});\n\n        avg = i2 * (dp[x][i] + dp[y][i]);\n        upd.push_back({{x, i}, avg});\n        upd.push_back({{y, i}, avg});\n      }\n    }\n\n    Modint avg = i2 * (dp[x][y] + dp[y][x]);\n    upd.push_back({{x, y}, avg});\n    upd.push_back({{y, x}, avg});\n\n    for (auto pr : upd) {\n      dp[pr.first.first][pr.first.second] = pr.second;\n    }\n  }\n\n  Modint ans (0);\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      ans += dp[i][j];\n    }\n  }\n\n  ans = ans * exp(Modint(2), q);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#define N 3010\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar();\n\twhile (!isdigit(c)) c = getchar();\n\twhile (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\ninline ll quickpow(ll x, int k) {\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1)\tres = res *x  % P;\n\t\tx = x * x % P;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\nint n, q;\nint a[N];\nint f[N][N], g[N][N];\nint main() {\n\tread(n), read(q);\n\tfor (int i = 1; i <= n; ++i)\tread(a[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tf[i][j] = a[i] > a[j];\n\t\t\tf[j][i] = a[j] > a[i];\n\t\t}\n\t}\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint l, r; read(l), read(r);\n\t\tif (l > r)\tswap(l, r);\n\t\tint tmp = 1ll * inv2 * (f[l][r] + f[r][l]) % P;\n\t\tf[l][r] = f[r][l] = tmp;\n\t\tfor (int j = 1; j <= n; ++j) if (j != l && j != r) {\n\t\t\tf[j][l] = f[j][r] = 1ll * inv2 * (f[j][l] + f[j][r]) % P;\n\t\t\tf[l][j] = f[r][j] = 1ll * inv2 * (f[l][j] + f[r][j]) % P;\n\t\t}\n//\t\tfor (int j = l + 1; j < r; ++j) {\n//\t\t\tf[l][j] = f[j][r] = 1ll * inv2 * (f[l][j] + f[j][r]) % P;\n//\t\t}\n//\t\tfor (int j = r + 1; j <= n; ++j) {\n//\t\t\tf[l][j] = f[r][j] = 1ll * inv2 * (f[l][j] + f[r][j]) % P;\n//\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tans = (ans + f[i][j]) % P;\n\t\t}\n\t}\n\tans = ans * quickpow(2, q) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 3005;\nconst int mod = 1e9 + 7;\n#define sz(v) ((int)v.size())\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, q, a[MAXN];\nint l[MAXN], r[MAXN];\n\nstruct ds{\n\tint val[MAXN];\n\tint lazy = 1;\n\tvoid mul(int x){\n\t\tlazy *= 2;\n\t\tlazy %= mod;\n\t}\n\tvoid set(int x, int v){\n\t\tval[x] = 1ll * v * ipow(lazy, mod - 2) % mod;\n\t}\n\tint get(int x){\n\t\treturn 1ll * val[x] * lazy % mod;\n\t}\n}dp[MAXN];\n\nstruct rew{\n\tint x, y, z;\n};\n\nint main(){\n\tcin >> n >> q;\n\tfor(int i=1; i<=n; i++) cin >> a[i];\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<i; j++) dp[i].set(j, 1);\n\t}\n\tfor(int i=0; i<q; i++){\n\t\tcin >> l[i] >> r[i];\n\t\tif(l[i] > r[i]) swap(l[i], r[i]);\n\t}\n\tfor(int i=q-1; i>=0; i--){\n\t\tvector<rew> rewr;\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tif(l[i] == j){\n\t\t\t\tfor(int k=1; k<=n; k++){\n\t\t\t\t\tif(r[i] == k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[k].get(j)});\n\t\t\t\t\t}\n\t\t\t\t\telse if(j != k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[r[i]].get(k)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(r[i] == j){\n\t\t\t\tfor(int k=1; k<=n; k++){\n\t\t\t\t\tif(l[i] == k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[k].get(j)});\n\t\t\t\t\t}\n\t\t\t\t\telse if(j != k){\n\t\t\t\t\t\trewr.push_back({j, k, dp[j].get(k) + dp[l[i]].get(k)});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trewr.push_back({j, l[i], dp[j].get(l[i]) + dp[j].get(r[i])});\n\t\t\t\trewr.push_back({j, r[i], dp[j].get(l[i]) + dp[j].get(r[i])});\n\t\t\t}\n\t\t}\n\t\tfor(int j=1; j<=n; j++) dp[j].mul(2);\n\t\tfor(auto &j : rewr) dp[j.x].set(j.y, j.z);\n\t}\n\tlint ret = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tif(a[i] < a[j]) ret += dp[i].get(j);\n\t\t}\n\t}\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sstream>\n#include <iostream>\n#include <math.h>\n#include <time.h>\n#include <unistd.h>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <string>\n\n#ifndef ONLINE_JUDGE\n\t#define DEBUG(x) cout << '>' << #x << ':' << x << endl;\n#else\n\t#define DEBUG(x) do {} while(0);\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define FOR(i, A, N) for(int (i) = (A); (i) < (N); (i)++)\n#define REP(i, N) for(int (i) = 0; (i) < (N); (i)++)\n\nusing namespace std;\ntypedef long long ll;\ninline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }\n\nint n,m;\nconst int mod = 1000000007;\nll modpow(ll a, ll e) {\n\tif (e == 0) return 1;\n\tll x = modpow(a * a % mod, e >> 1);\n\treturn e & 1 ? x * a % mod : x;\n}\n\nll A[3333];\nll dp[3333][3333];\n\nint main() {\n\tll inv2 = modpow(2, mod-2);\n\tint n,q;\n\tscanf(\"%d%d\", &n, &q);\n\tREP(i, n) scanf(\"%lld\", A+i);\n\tREP(i, n) REP(j, n) dp[i][j] = A[i]>A[j];\n\tREP(i, q) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;y--;\n\t\tll o = dp[x][y];\n\t\tdp[x][y] = inv2*dp[x][y]+inv2*dp[y][x]; \n\t\tdp[y][x] = inv2*dp[y][x]+inv2*o;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i == x || i == y)\n\t\t\t\tcontinue;\n\t\t\tll ix = dp[i][x];\n\t\t\tll xi = dp[x][i];\n\t\t\tdp[i][x] = (inv2*dp[i][x]+inv2*dp[i][y])%mod;\n\t\t\tdp[x][i] = (inv2*dp[x][i]+inv2*dp[y][i])%mod;\n\t\t\tdp[i][y] = (inv2*dp[i][y]+inv2*ix)%mod;\n\t\t\tdp[y][i] = (inv2*dp[y][i]+inv2*xi)%mod;\n\t\t}\n\t\t\n\t}\n\tll sum = 0;\n\tREP(i, n) REP(j, n) if(i < j) sum = (sum+(mod+dp[i][j])%mod+mod)%mod;\n\tREP(i, q) sum = (2*sum)%mod;\n\tprintf(\"%lld\\n\", sum);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=1e9+7;\nll n,m,ans,hh,a[3010],f[3010][3010],b[3010][2],c[3010][2],ny;\nll ksm(ll x,ll y){\n\tll sej=1;\n\twhile(y){\n\t\tif(y&1)sej=sej*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn sej;\n}\nint main(){\n\tll i,j,x,y;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tfor(i=1;i<=n;i++)\n\t for(j=1;j<=n;j++)if(a[i]>a[j])f[i][j]=1;\n\tny=ksm(2,p-2);hh=1;\n\twhile(m--){\n\t\thh=hh*2%p;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tif(x>y)swap(x,y);\n\t\tfor(i=1;i<=n;i++)b[i][0]=f[i][x],b[i][1]=f[x][i],c[i][0]=f[i][y],c[i][1]=f[y][i];\n\t\tfor(i=1;i<=n;i++)if(i!=x&&i!=y){\n\t\t\tf[x][i]=(b[i][1]*ny+c[i][1]*ny)%p;\n\t\t\tf[i][x]=(b[i][0]*ny+c[i][0]*ny)%p;\n\t\t\tf[y][i]=(c[i][1]*ny+b[i][1]*ny)%p;\n\t\t\tf[i][y]=(c[i][0]*ny+b[i][0]*ny)%p;\n\t\t}\n\t\tf[x][y]=f[y][x]=(f[x][y]+f[y][x])*ny%p;\n\t}\n\t//printf(\"%lld\\n\",hh);\n\tfor(i=1;i<n;i++)\n\t for(j=i+1;j<=n;j++)ans=(ans+f[i][j]*hh)%p;\n\tprintf(\"%lld\",ans);\n}\n/*\nf[i,j] a[i]>a[j]的概率 \n*/"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable:4996)\n#include\"bits/stdc++.h\"\n#include<cassert>\n#define int long long\n#define MRE assert(0);\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long inf = 1e17;\ntypedef pair<int, int> P;\nint a[3005], x[3005], y[3005];\nint table[10][10];\n\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tint n, q; cin >> n >> q;\n\trep(i, n) {\n\t\tcin >> a[i]; a[i]--;\n\t}\n\trep(i, q) {\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tint ans = 0;\n\n\n\trep(i, n) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (a[i] < a[j])table[i][j] = 1;\n\t\t\tif (a[i] > a[j])table[j][i] = 1;\n\t\t}\n\t}\n\n\trep(k, q) {\n\t\t//x[i]とy[i]をswap\n\t\trep(l, n) {//(x,l)->(y,l)\n\t\t\tif (x[k] == l || y[k] == l)continue;\n\t\t\ttable[x[k]][l] = table[x[k]][l] * modpow(2, mod - 2) % mod;\n\t\t\ttable[y[k]][l] = table[y[k]][l] * modpow(2, mod - 2) % mod;\n\t\t\ttable[l][x[k]] = table[l][x[k]] * modpow(2, mod - 2) % mod;\n\t\t\ttable[l][y[k]] = table[l][y[k]] * modpow(2, mod - 2);\n\t\t\tint p1 = table[x[k]][l], p2 = table[y[k]][l], p3 = table[l][x[k]], p4 = table[l][y[k]];\n\t\t\ttable[x[k]][l] = (table[x[k]][l] + p2) % mod;\n\t\t\ttable[y[k]][l] = (table[y[k]][l] + p1) % mod;\n\t\t\ttable[l][x[k]] = (table[l][x[k]] + p4) % mod;\n\t\t\ttable[l][y[k]] = (table[l][y[k]] + p3) % mod;\n\t\t}\n\t\ttable[x[k]][y[k]] = table[x[k]][y[k]] * modpow(2, mod - 2) % mod;\n\t\ttable[y[k]][x[k]] = table[y[k]][x[k]] * modpow(2, mod - 2) % mod;\n\t\tint p1 = table[y[k]][x[k]], p2 = table[x[k]][y[k]];\n\t\ttable[x[k]][y[k]] = (table[x[k]][y[k]] + p1) % mod;\n\t\ttable[y[k]][x[k]] = (table[y[k]][x[k]] + p2) % mod;\n\t}\n\tint r = 0;\n\trep(k, n) {\n\t\tfor (int l = 0; l < k; l++) {\n\t\t\tr += table[k][l];\n\t\t}\n\t}\n\tans += r;\n\n\tcout << ans*modpow(2, q) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define R register\n#define ll long long\nconst int MAXN=3e3+10;\nconst int mod=1e9+7;\n\ninline int qpow(int x,int p)\n{\n\tint res=1;\n\twhile(p)\n\t{\n\t\tif(p&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tp>>=1;\n\t}\n\treturn res;\n}\n\nint n,q;\nint a[MAXN];\nint f[MAXN][MAXN];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(R int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(R int i=1;i<=n;i++)\n\t\tfor(R int j=1;j<=n;j++)\n\t\t\tf[i][j]=a[i]<a[j]?1:0;\n\tfor(R int i=1;i<=q;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tf[x][y]=f[y][x]=(ll)(f[x][y]+f[y][x])*qpow(2,mod-2)%mod;\n\t\tfor(R int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==x||j==y) continue;\n\t\t\tf[j][x]=f[j][y]=(ll)(f[j][x]+f[j][y])*qpow(2,mod-2)%mod;\n\t\t\tf[x][j]=f[y][j]=(ll)(f[x][j]+f[y][j])*qpow(2,mod-2)%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(R int i=1;i<=n;i++)\n\t\tfor(R int j=1;j<i;j++)\n\t\t\tans=(ans+f[i][j])>mod?ans+f[i][j]-mod:ans+f[i][j];\n\tprintf(\"%lld\\n\",(ll)ans*qpow(2,q)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define llong long long\nusing namespace std;\n\nconst int N = 3000;\nconst int P = 1e9+7;\nconst int INV2 = 5e8+4;\nllong a[N+3];\nllong dp[N+3][N+3];\nint n,q;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<i; j++) dp[i][j] = a[j]<a[i] ? 1 : 0;\n\t\tfor(int j=i+1; j<=n; j++) dp[i][j] = a[i]>a[j] ? 1 : 0;\n\t}\n\tfor(int i=1; i<=q; i++)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tdp[x][y] = dp[y][x] = (dp[x][y]+dp[y][x])*INV2%P;\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(j!=x && j!=y)\n\t\t\t{\n\t\t\t\tdp[j][x] = dp[j][y] = (dp[j][x]+dp[j][y])*INV2%P;\n\t\t\t\tdp[x][j] = dp[y][j] = (dp[x][j]+dp[y][j])*INV2%P;\n\t\t\t}\n\t\t}\n\t}\n\tllong ans = 0ll;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tans = (ans+dp[i][j])%P;\n\t\t}\n\t}\n\tans = ans*quickpow(2ll,q)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nvoid add_self(int &x, int y) {\n  x += y;\n  if (x >= mod)\n    x -= mod;\n}\n\nvoid sub_self(int &x, int y) {\n  x -= y;\n  if (x < 0)\n    x += mod;\n}\n\nint add(int x, int y) {\n  x += y;\n  if (x >= mod)\n    x -= mod;\n  return x;\n}\n\nint sub(int x, int y) {\n  x -= y;\n  if (x < 0)\n    x += mod;\n  return x;\n}\n\nint powmod(long long a, long long b) {\n  long long res = 1;\n  a %= mod;\n  assert(b >= 0);\n  for( ; b; b >>= 1){\n    if (b & 1)\n      res = res * a % mod;\n    a = a * a % mod;\n  }\n  return res % mod;\n}\n\nint mult(int x, int y) {\n  return (1LL * x * y) % mod;\n}\n\nint divide(int x, int y) {\n  return mult(x, powmod(y, mod - 2));\n}\n\nconst int N = 3010;\nconst int INV2 = divide(1, 2);\n\nint n, qq;\nint a[N], dp[N][N];\n\nint main() {\n  scanf(\"%d %d\", &n, &qq);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", &a[i]);\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      dp[i][j] = (a[i] > a[j]);\n  for (int i = 0; i < qq; ++i) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    --x, --y;\n    dp[x][y] = dp[y][x] = mult(add(dp[x][y], dp[y][x]), INV2);\n    for (int j = 0; j < n; ++j) {\n      if (j != x && j != y) {\n        dp[j][x] = dp[j][y] = mult(add(dp[j][x], dp[j][y]), INV2);\n        dp[x][j] = dp[y][j] = mult(add(dp[x][j], dp[y][j]), INV2);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = i + 1; j < n; ++j)\n      add_self(ans, dp[i][j]);\n  for (int i = 0; i < qq; ++i)\n    add_self(ans, ans);\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64;\ninline int rd(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 5e3+5, P = 1e9+7, I2 = (P+1)/2;\nint n, m, a[N], f[N][N], ans, S; void fix(int &x) { x<P?0:x-=P; }\nint main()\n{\n    n = rd(), m = rd(), S = 1;\n    for(int i = 1; i <= n; ++i) a[i] = rd();\n    for(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) f[i][j] = a[i] > a[j];\n    for(int i = 1; i <= m; ++i) \n    {\n        int x = rd(), y = rd();\n        for(int j = 1; j <= n; ++j) if(x != j&&y != j)\n            f[j][x] = f[j][y] = (i64)I2*(f[j][x]+f[j][y])%P,\n            f[x][j] = f[y][j] = (i64)I2*(f[x][j]+f[y][j])%P;\n        f[x][y] = f[y][x] = (i64)I2*(f[x][y]+f[y][x])%P, fix(S<<=1);\n    }\n    for(int i = 1; i <= n; ++i) for(int j = i+1; j <= n; ++j) fix(ans += f[i][j]);\n    printf(\"%lld\\n\", (i64)ans*S%P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int inv = 500000004;\n\nint a[3010];\nlong long dp[2][3010][3010];\n\nint main(){\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tint now = 0, pre = 1;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tdp[now][i][j] = a[i] > a[j];\n\t\t}\n\t}\n\tlong long pw = 1;\n\twhile (q--){\n\t\tpw = pw * 2 % mod;\n\t\tswap(now, pre);\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tx--, y--;\n\t\tif (x > y) swap(x, y);\n\t\tdp[now][x][y] = (dp[pre][y][x] * inv + dp[pre][x][y] * inv) % mod;\n\t\tdp[now][y][x] = (dp[pre][x][y] * inv + dp[pre][y][x] * inv) % mod;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (i == x || i == y) continue;\n\t\t\tdp[now][i][x] = (dp[pre][i][x] * inv + dp[pre][i][y] * inv) % mod;\n\t\t\tdp[now][x][i] = (dp[pre][x][i] * inv + dp[pre][y][i] * inv) % mod;\n\t\t\tdp[now][i][y] = (dp[pre][i][y] * inv + dp[pre][i][x] * inv) % mod;\n\t\t\tdp[now][y][i] = (dp[pre][y][i] * inv + dp[pre][x][i] * inv) % mod;\n\t\t}\n\t\tswap(now, pre);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdp[now][i][x] = dp[pre][i][x];\n\t\t\tdp[now][x][i] = dp[pre][x][i];\n\t\t\tdp[now][i][y] = dp[pre][i][y];\n\t\t\tdp[now][y][i] = dp[pre][y][i];\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = i + 1; j < n; j++){\n\t\t\tans = (ans + dp[now][i][j]) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans * pw % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 505;\nconst int MOD = 1e9 + 7;\n\nint mul(int a, int b) {\n   return (a * b) % MOD; \n}\n\nint add(int a, int b) {\n   return (a + b) % MOD;\n}\n\nint binpow(int a, int b) {\n   int res = 1;\n   while (b) {\n      if (b & 1) res = mul(res, a);\n      a = mul(a, a);\n      b >>= 1;\n   }\n   return res;\n}\n\nint divv(int a, int b) {\n   return mul(a, binpow(b, MOD - 2));\n}\n\nint n;\nint dp[N][N];\n\nvoid rec_dp(int x, int y) {\n   vector<pair<int, int>> torel;\n   for (int i = 0; i < n; i++) {\n      if (i == x || i == y) {\n         for (int j = 0; j < n; j++) {\n            torel.push_back({i, j});\n         }\n      } else {\n         torel.push_back({i, x});\n         torel.push_back({i, y});  \n      }\n   }\n   vector<tuple<int, int, int>> rval;\n   for (auto t : torel) {\n      int i, j;\n      tie(i, j) = t;\n      if (i == j) {\n         rval.push_back(make_tuple(i, j, dp[i][j]));\n         continue;\n      }\n      if (i != x && i != y && j != x && j != y) {\n         rval.push_back(make_tuple(i, j, dp[i][j]));\n         continue;  \n      }\n      if (i == x && j == y) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[j][i]), 2)));\n         continue;\n      }\n      if (i == y && j == x) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[j][i]), 2)));\n         continue;\n      }\n      if (i == x) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[y][j]), 2)));\n         continue;\n      }\n      if (i == y) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[x][j]), 2)));\n         continue;\n      }\n      if (j == x) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[i][y]), 2)));\n         continue;\n      }\n      if (j == y) {\n         rval.push_back(make_tuple(i, j, divv(add(dp[i][j], dp[i][x]), 2)));\n         continue;\n      }\n      assert(false);\n   }\n   for (auto t : rval) {\n      int i, j, c;\n      tie(i, j, c) = t;\n      dp[i][j] = c;\n   }\n}\n\nsigned main() {\n   ios_base::sync_with_stdio(false);\n   cin.tie(0);\n\n   int q;\n   cin >> n >> q;\n   vector<int> a(n);\n   for (auto &t : a) {\n      cin >> t;\n   }\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n         dp[i][j] = (a[i] > a[j]); \n      }\n   }\n   for (int i = 0; i < q; i++) {\n      int x, y;\n      cin >> x >> y;\n      x--;\n      y--;\n      rec_dp(x, y);\n   }\n   int ans = 0;\n   for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n         ans = add(ans, dp[i][j]);\n      }\n   }\n   // for (int i = 0; i < n; i++) {\n   //    for (int j = 0; j < n; j++) {\n   //       cerr << mul(2, dp[pnt][i][j]) << ' ';\n   //    }\n   //    cerr << endl;\n   // }\n   for (int i = 0; i < q; i++) {\n      ans = mul(ans, 2);\n   }\n   cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int mod=1e9+7,N=3005;\nconst ll inv2=(mod+1)/2;\nint f[N][N],g[N],h[N],a[N],n,Q,x,y,pw=1,ans;\n\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint main(){\n\tread(n),read(Q);\n\trep(i,1,n)read(a[i]);\n\trep(i,1,n)rep(j,1,n)\n\t\tf[i][j]=(a[i]>a[j]);\n\trep(k,1,Q){\n\t\tread(x),read(y),pw=pw*2%mod;\n\t\trep(i,1,n)if(i!=x&&i!=y){\n\t\t\tg[i]=inv2*(f[x][i]+f[y][i])%mod;\n\t\t\th[i]=inv2*(f[i][x]+f[i][y])%mod;\n\t\t}\n\t\trep(i,1,n)if(i!=x&&i!=y){\n\t\t\tf[x][i]=f[y][i]=g[i];\n\t\t\tf[i][x]=f[i][y]=h[i];\n\t\t}\n\t\tf[x][y]=f[y][x]=inv2*(f[x][y]+f[y][x])%mod;\n\t}\n\trep(i,1,n)rep(j,i+1,n)\n\t\tadd(ans,f[i][j]);\n\tans=(ll)ans*pw%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=3000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL a[NN][NN]={};\nint seq[NN]={};\nconst int mod=1e9+7;\nint main(){\n\t//open();\n\tn=read();\n\tint q=read();\n\tfor(int i=1;i<=n;++i)seq[i]=read();\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\ta[i][j]=(seq[i]>seq[j]?1:0);\n\t\t}\n\t}\n\tint rev2=(mod+1)>>1;\n\tfor(int i=1;i<=q;++i){\n\t\tint x=read(),y=read();\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(i!=y&&i!=x){\n\t\t\t\ta[y][i]=a[x][i]=rev2*(a[x][i]+a[y][i])%mod;\n\t\t\t\ta[i][y]=a[i][x]=rev2*(a[i][x]+a[i][y])%mod;\n\t\t\t}\n\t\t}\n\t\ta[y][x]=a[x][y]=rev2*(a[y][x]+a[x][y]);\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tans+=a[i][j];\n\t\t}\n\t}\n\tans%=mod;\n\tfor(int i=1;i<=q;++i){\n\t\tans=ans*2%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=3200;\nconst int mod=1000000007,inv2=500000004;\nint n,q,x,y,a[maxn],f[maxn][maxn],ans;\nsigned main()\n{ cin>>n>>q;\n  for (int i=1;i<=n;i++) cin>>a[i];\n  for (int i=1;i<=n;i++)\n  for (int j=1;j<=n;j++)\n  f[i][j]=a[i]>a[j];\n  for (int i=1;i<=q;i++)\n  {  cin>>x>>y;\n     for (int j=1;j<=n;j++)\n     {  if (j==x || j==y)  continue;\n\t    f[j][y]=f[j][x]=(f[j][x]+f[j][y])*inv2%mod;\n\t\tf[x][j]=f[y][j]=(f[x][j]+f[y][j])*inv2%mod;  \n\t }\n\t f[x][y]=f[y][x]=(f[x][y]+f[y][x])*inv2%mod;\n  }\n  for (int i=1;i<=n;i++)\n  for (int j=i+1;j<=n;j++)\n  ans=ans+f[i][j];\n  while (q--)  ans=ans*2%mod;\n  cout<<ans<<endl;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint dp[3005][3005],n,q,val[3005],now[3005][3005],inv2;\nint qpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nsigned main()\n{\n\tinv2=qpow(2,mod-2);\n\tscanf(\"%lld%lld\",&n,&q);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&val[i]);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tdp[i][j]=(val[i]<val[j]?1:0);\n\t\t}\n\t}\n\tint mx=qpow(2,q);\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tnow[x][i]=(dp[x][i]+dp[y][i])%mod*inv2%mod;\n\t\t\tnow[i][x]=(dp[i][x]+dp[i][y])%mod*inv2%mod;\n\t\t\tnow[y][i]=now[x][i];\n\t\t\tnow[i][y]=now[i][x];\n\t\t}\n\t\tnow[x][y]=now[y][x]=(dp[x][y]+dp[y][x])*inv2%mod;\n\t\tfor(int i=1;i<=n;++i)\n    {\n\t\t\tdp[x][i]=now[x][i];dp[i][x]=now[i][x];\n\t\t\tdp[y][i]=now[y][i];dp[i][y]=now[i][y];\n\t\t}\n\t\tswap(val[x],val[y]);\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t{\n\t\t\tres+=mx*dp[j][i]%mod;\n\t\t\tif(res>=mod)res-=mod;\n\t\t}\n\t}\n\tcout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\null c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null pp[3005][3005];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\t// for (i = 0; i < n; i++) {\n\t// \tb[i * 2] = a[i];\n\t// \tb[i * 2 + 1] = -(k - a[n - 1 - i]);\n\n\t// \tc[i * 2] = k - a[n - 1 - i];\n\t// \tc[i * 2 + 1] = -a[i];\n\t// \tprintf(\"%lld-%lld %lld-%lld\\n\", b[i * 2], b[i * 2 + 1], c[i * 2], c[i * 2 + 1]);\n\t// }\n\n\t// sum = 0;\n\t// ki = 0;\n\t// for (i = 0; i < n; i++) {\n\t// \tsum += sdiff(b[i], ki);\n\t// \tki = b[i];\n\t// }\n\t// result = smax(result, sum);\n\t// sum = 0;\n\t// ki = 0;\n\t// for (i = 0; i < n; i++) {\n\t// \tsum += sdiff(c[i], ki);\n\t// \tki = c[i];\n\t// }\n\t// result = smax(result, sum);\n\n\tull powq = bitpow(2, q, MOD);\n\tull inv2 = divide(1, 2, MOD);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tpp[i][j] = q;\n\n\t\t\tif (a[i] > a[j]) {\n\t\t\t\ttable[i][j] = powq;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (i = 0; i < q; i++) {\n\t\t// if (xy[i].a > xy[i].b) {\n\t\t// \tsll tmp = xy[i].a;\n\t\t// \txy[i].a = xy[i].b;\n\t\t// \txy[i].b = tmp;\n\t\t// }\n\t\tull xx;\n\n\t\tull a = xy[i].a, b = xy[i].b;\n\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (j == a || j == b) continue;\n\n\t\t\tpp[a][j]--;\n\t\t\tpp[b][j]--;\n\n\t\t\txx = (table[a][j] + table[b][j]) * inv2 % MOD;\n\t\t\ttable[a][j] = table[b][j] = xx;\n\n\n\t\t\tpp[j][a]--;\n\t\t\tpp[j][b]--;\n\n\t\t\txx = (table[j][a] + table[j][b]) * inv2 % MOD;\n\t\t\ttable[j][a] = table[j][b] = xx;\n\t\t}\n\t\tpp[a][b]--;\n\t\tpp[b][a]--;\n\t\txx = (table[a][b] + table[b][a]) * inv2 % MOD;\n\t\ttable[a][b] = table[b][a] = xx;\n\n\t\t// for (ki = 0; ki < n; ki++) {\n\t\t// \tfor (li = 0; li < n; li++) {\n\t\t// \t\tprintf(\"%llu \", table[ki][li]);\n\t\t// \t}\n\t\t// \tputs(\"\");\n\t\t// }\n\t\t// puts(\"\");\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t// printf(\"%llux2^%llu \", table[i][j], pp[i][j]);\n\t\t\t// result += table[i][j] * bitpow(2, pp[i][j], MOD) % MOD;\n\t\t\tresult += table[i][j];\n\t\t\tresult %= MOD;\n\n\n\t\t\t// sum = 0;\n\t\t\t// for (ki = 0; ki < 8; ki++) {\n\t\t\t// \t\tull v = i, u = j;\n\t\t\t// \tfor (li = 2; li >= 0; li--) {\n\t\t\t// \t\tif (ki & (1LL << li) ){\n\t\t\t// \t\t\tif (v == xy[li].a) v = xy[li].b;\n\t\t\t// \t\t\telse if (v == xy[li].b) v = xy[li].a;\n\t\t\t// \t\t\tif (u == xy[li].a) u = xy[li].b;\n\t\t\t// \t\t\telse if (u == xy[li].b) u = xy[li].a;\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// \tif (a[v] > a[u]) sum++;\n\t\t\t// }\n\t\t\t// printf(\"%llu \", sum);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &c[i]);\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\txy[i].a--;\n\t\txy[i].b--;\n\t}\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\nint main(){\n\tint N, Q, i, j;\n\tscanf(\"%lld%lld\", &N, &Q);\n\tint *A = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t}\n\tint **dp = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\tdp[i] = (int *)malloc(sizeof(int) * N);\n\t\tfor(j = 0; j < N; j++){\n\t\t\tif(A[i] > A[j]){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tint q, X, Y, inv2 = inverse(2);\n\tint *subOX = (int *)malloc(sizeof(int) * N);\n\tint *subOY = (int *)malloc(sizeof(int) * N);\n\tint *subXO = (int *)malloc(sizeof(int) * N);\n\tint *subYO = (int *)malloc(sizeof(int) * N);\n\tint subXY, subYX;\n\tfor(q = 0; q < Q; q++){\n\t\tscanf(\"%lld%lld\", &X, &Y);\n\t\tX--;\n\t\tY--;\n\t\tfor(i = 0; i < N; i++){\n\t\t\tsubOX[i] = dp[i][X];\n\t\t\tsubOY[i] = dp[i][Y];\n\t\t\tsubXO[i] = dp[X][i];\n\t\t\tsubYO[i] = dp[Y][i];\n\t\t}\n\t\tsubXY = dp[X][Y];\n\t\tsubYX = dp[Y][X];\n\t\tfor(i = 0; i < N; i++){\n\t\t\tif(i != X && i != Y){\n\t\t\t\tdp[i][X] = MOD((subOX[i] + subOY[i]) * inv2);\n\t\t\t\tdp[i][Y] = MOD((subOX[i] + subOY[i]) * inv2);\n\t\t\t\tdp[X][i] = MOD((subXO[i] + subYO[i]) * inv2);\n\t\t\t\tdp[Y][i] = MOD((subXO[i] + subYO[i]) * inv2);\n\t\t\t}\n\t\t}\n\t\tdp[X][Y] = MOD((subXY + subYX) * inv2);\n\t\tdp[Y][X] = MOD((subXY + subYX) * inv2);\n/*\t\tprintf(\"dp[%lld]:\\n\", q);\n\t\tfor(i = 0; i < N; i++){\n\t\t\tfor(j = 0; j < N; j++){\n\t\t\t\tprintf(\"%lld \", dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n*/\t}\n\tint ans = 0;\n\tfor(i = 0; i < N; i++){\n\t\tfor(j = 0; j < N; j++){\n\t\t\tif(i < j){\n\t\t\t\tans = MOD(ans + dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tans = MOD(ans * power(2, Q));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null ppide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\null c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null pp[3005][3005];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\t// for (i = 0; i < n; i++) {\n\t// \tb[i * 2] = a[i];\n\t// \tb[i * 2 + 1] = -(k - a[n - 1 - i]);\n\n\t// \tc[i * 2] = k - a[n - 1 - i];\n\t// \tc[i * 2 + 1] = -a[i];\n\t// \tprintf(\"%lld-%lld %lld-%lld\\n\", b[i * 2], b[i * 2 + 1], c[i * 2], c[i * 2 + 1]);\n\t// }\n\n\t// sum = 0;\n\t// ki = 0;\n\t// for (i = 0; i < n; i++) {\n\t// \tsum += sdiff(b[i], ki);\n\t// \tki = b[i];\n\t// }\n\t// result = smax(result, sum);\n\t// sum = 0;\n\t// ki = 0;\n\t// for (i = 0; i < n; i++) {\n\t// \tsum += sdiff(c[i], ki);\n\t// \tki = c[i];\n\t// }\n\t// result = smax(result, sum);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tpp[i][j] = q;\n\n\t\t\tif (a[i] > a[j]) {\n\t\t\t\ttable[i][j] = 1;\n\t\t\t}\n\n\t\t\t// sum = 0;\n\t\t\t// for (ki = 0; ki < 8; ki++) {\n\t\t\t// \t\tull v = i, u = j;\n\t\t\t// \tfor (li = 0; li < 3; li++) {\n\t\t\t// \t\tif (ki & (1LL << j) ){\n\t\t\t// \t\t\tif (v == xy[li].a) v = xy[li].b;\n\t\t\t// \t\t\telse if (v == xy[li].b) v = xy[li].a;\n\t\t\t// \t\t\tif (u == xy[li].a) u = xy[li].b;\n\t\t\t// \t\t\telse if (u == xy[li].b) u = xy[li].a;\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// \tif (v > u) sum++;\n\t\t\t// }\n\t\t\t// printf(\"%llu \", sum);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (i = 0; i < q; i++) {\n\t\t// if (xy[i].a > xy[i].b) {\n\t\t// \tsll tmp = xy[i].a;\n\t\t// \txy[i].a = xy[i].b;\n\t\t// \txy[i].b = tmp;\n\t\t// }\n\t\tull xx;\n\n\t\tull a = xy[i].a, b = xy[i].b;\n\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (j == a || j == b) continue;\n\n\t\t\tpp[a][j]--;\n\t\t\tpp[b][j]--;\n\n\t\t\txx = (table[a][j] + table[b][j]) % MOD;\n\t\t\ttable[a][j] = table[b][j] = xx;\n\n\n\t\t\tpp[j][a]--;\n\t\t\tpp[j][b]--;\n\n\t\t\txx = (table[j][a] + table[j][b]) % MOD;\n\t\t\ttable[j][a] = table[j][b] = xx;\n\t\t}\n\t\tpp[a][b]--;\n\t\tpp[b][a]--;\n\t\txx = (table[a][b] + table[b][a]) % MOD;\n\t\ttable[a][b] = table[b][a] = xx;\n\n\t\t// for (ki = 0; ki < n; ki++) {\n\t\t\t// for (li = 0; li < n; li++) {\n\t\t\t\t// printf(\"%llu \", table[ki][li]);\n\t\t\t// }\n\t\t\t// puts(\"\");\n\t\t// }\n\t\t// puts(\"\");\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t// printf(\"%llux2^%llu \", table[i][j], pp[i][j]);\n\t\t\tresult += table[i][j] * bitpow(2, pp[i][j], MOD) % MOD;\n\t\t\tresult %= MOD;\n\t\t}\n\t\t// puts(\"\");\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &c[i]);\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\txy[i].a--;\n\t\txy[i].b--;\n\t}\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong mod = 1000000007;\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tlong dp[][] = new long[n][n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(a[i] > a[j])\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tlong half = inverse(2,mod);\n\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(j!=y-1 && j!=x-1) {\n\t\t\t\t\tdp[y-1][j] = dp[x-1][j] = (half * dp[x-1][j] % mod + half * dp[y-1][j] % mod)%mod;\n\t\t\t\t\tdp[j][x-1] = dp[j][y-1] = (half * dp[j][x-1] % mod + half * dp[j][y-1] % mod)%mod;\n\t\t\t\t}\n\t\t\t\tdp[y-1][x-1] = dp[x-1][y-1] = (half * dp[y-1][x-1] % mod + half * dp[x-1][y-1] % mod)%mod;\n\t\t\t}\n\n\t\t}\n\n\t\tlong expectation = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\texpectation = (expectation + dp[i][j]) %mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(expectation*bin_exp(2,q,mod)%mod);\n\t}\n\t\n\tpublic static long bin_exp(long base, long exp, long mod) {\n\t\tif(exp == 0)\n\t\t\treturn 1;\n\t\treturn bin_exp(base*base%mod, exp/2, mod) * (exp%2 == 1? base : 1) % mod;\n\t}\n\t\n\tpublic static long inverse(long a, long mod) {\n\t\treturn bin_exp(a,mod-2,mod);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int q = in.readInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.readInt();\n            }\n            int[][] swaps = new int[q][2];\n            for (int i = 0; i < q; i++) {\n                swaps[i][0] = in.readInt() - 1;\n                swaps[i][1] = in.readInt() - 1;\n            }\n\n\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n            NumberTheory.Power pow = new NumberTheory.Power(mod);\n            int inv2 = pow.inverse(2);\n\n            int[][] dp = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (a[i] < a[j]) {\n                        dp[i][j]++;\n                    }\n                }\n            }\n\n            int[] xInL = new int[n];\n            int[] xInR = new int[n];\n\n            for (int j = 0; j < q; j++) {\n                int x = swaps[j][0];\n                int y = swaps[j][1];\n\n                // x in l\n                for (int r = 0; r < n; r++) {\n                    if (r == y || r == x) {\n                        xInL[r] = 0;\n                        continue;\n                    }\n                    xInL[r] = mod.plus(dp[y][r], dp[x][r]);\n                }\n\n\n                // x in r\n                for (int l = 0; l < n; l++) {\n                    if (l == y || l == x) {\n                        xInR[l] = 0;\n                        continue;\n                    }\n                    xInR[l] = mod.plus(dp[l][x], dp[l][y]);\n                }\n\n                int xy = dp[x][y];\n                int yx = dp[y][x];\n\n                // update x in l\n                for (int i = 0; i < n; i++) {\n                    int half = mod.mul(inv2, xInL[i]);\n                    dp[x][i] = dp[y][i] = half;\n                }\n\n                // update x in r\n                for (int i = 0; i < n; i++) {\n                    int half = mod.mul(inv2, xInR[i]);\n                    dp[i][x] = dp[i][y] = half;\n                }\n\n                int half = mod.mul(mod.plus(xy, yx), inv2);\n                dp[x][y] = dp[y][x] = half;\n            }\n\n            int p = pow.pow(2, q);\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (i > j) {\n                        ans = mod.plus(dp[i][j], ans);\n                    }\n                }\n            }\n            ans = mod.mul(p, ans);\n\n\n            out.println(ans);\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return modular.valueOf(1);\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n            public int inverse(int x) {\n                return pow(x, modular.m - 2);\n            }\n\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DInversionSum solver = new DInversionSum();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DInversionSum {\n        static final int mod = (int) 1e9 + 7;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] a = in.nextIntArray(n);\n            int[][] qs = in.nextIntArray2D(q, 2);\n\n            long[][] dp = new long[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dp[i][j] = a[i] > a[j] ? 1 : 0;\n                }\n            }\n\n            long inv2 = (mod + 1) / 2;\n            long pow = 1;\n\n            for (int i = 0; i < q; i++) {\n                int x = qs[i][0] - 1, y = qs[i][1] - 1;\n                if (x > y) {\n                    int t = x;\n                    x = y;\n                    y = t;\n                }\n                for (int j = 0; j < n; j++) {\n                    if (j != x && j != y) {\n                        dp[x][j] = dp[y][j] = (dp[x][j] + dp[y][j]) * inv2 % mod;\n                        dp[j][x] = dp[j][y] = (dp[j][x] + dp[j][y]) * inv2 % mod;\n                    }\n                }\n                dp[x][y] = dp[y][x] = (dp[x][y] + dp[y][x]) * inv2 % mod;\n                pow = pow * 2 % mod;\n            }\n\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    ans += dp[i][j] * pow % mod;\n                }\n            }\n\n            out.println(ans % mod);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[][] nextIntArray2D(final int n, final int k) {\n            final int[][] res = new int[n][];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextIntArray(k);\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        static final long MODULO = (int) (1e9 + 7);\n        static final long INV2 = (MODULO + 1) / 2;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) a[i] = in.nextInt();\n            int[][] ways = new int[n][n];\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    ways[i][j] = a[i] > a[j] ? 1 : 0;\n                }\n            }\n            for (int qi = 0; qi < q; ++qi) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                for (int i = 0; i < n; ++i)\n                    if (i != u && i != v) {\n                        ways[u][i] = ways[v][i] = (int) ((ways[u][i] + ways[v][i]) * INV2 % MODULO);\n                        ways[i][u] = ways[i][v] = (int) ((ways[i][u] + ways[i][v]) * INV2 % MODULO);\n                    }\n                ways[u][v] = ways[v][u] = (int) ((ways[u][v] + ways[v][u]) * INV2 % MODULO);\n            }\n            long res = 0;\n            for (int i = 0; i < n; ++i) {\n                for (int j = i + 1; j < n; ++j) {\n                    res = (res + ways[i][j]) % MODULO;\n                }\n            }\n            for (int i = 0; i < q; ++i) res = res * 2 % MODULO;\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tstatic final int P = 1_000_000_007;\n\tstatic final long INV2 = (P + 1) / 2;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint q = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = a[i] > a[j] ? 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\tint[] tmp1 = new int[n];\n\t\tint[] tmp2 = new int[n];\n\n\t\tint initQ = q;\n\n\t\twhile (q-- > 0) {\n\t\t\tint x = nextInt() - 1;\n\t\t\tint y = nextInt() - 1;\n\n\t\t\tint sum = (int) (INV2 * (dp[x][y] + dp[y][x]) % P);\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i != x && i != y) {\n\t\t\t\t\t// if (i != y) {\n\t\t\t\t\t// d_x[i] = (int) (INV2 * (dp[i][x] + dp[i][y]) % P);\n\t\t\t\t\t// dx_[i] = (int) (INV2 * (dp[x][i] + dp[y][i]) % P);\n\t\t\t\t\ttmp1[i] = (int) (INV2 * (dp[i][x] + dp[i][y]) % P);\n\t\t\t\t\ttmp2[i] = (int) (INV2 * (dp[x][i] + dp[y][i]) % P);\n\t\t\t\t\t// } else {\n\t\t\t\t\t// d_x[i] = dx_[i] = sum;\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == x || i == y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][x] = dp[i][y] = tmp1[i];\n\t\t\t\tdp[x][i] = dp[y][i] = tmp2[i];\n\t\t\t}\n\n\t\t\tdp[x][y] = dp[y][x] = sum;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tans += dp[i][j];\n\t\t\t\tif (ans >= P) {\n\t\t\t\t\tans -= P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < initQ; i++) {\n\t\t\tans *= 2;\n\t\t\tif (ans >= P) {\n\t\t\t\tans -= P;\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong mod = 1000000007;\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tlong[][] curr = new long[n][n];\n\t\tlong[][] next = new long[n][n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(a[i] > a[j])\n\t\t\t\t\tcurr[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tlong half = inverse(2,mod);\n\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(j!=y-1) {\n\t\t\t\t\tnext[x-1][j] = (half * curr[x-1][j] % mod + half * curr[y-1][j] % mod)%mod;\n\t\t\t\t\tnext[j][x-1] = (half * curr[j][x-1] % mod + half * curr[j][y-1] % mod)%mod;\n\t\t\t\t}\n\t\t\t\tif(j!=x-1) {\n\t\t\t\t\tnext[y-1][j] = (half * curr[y-1][j] % mod + half * curr[x-1][j] % mod)%mod;\n\t\t\t\t\tnext[j][y-1] = (half * curr[j][y-1] % mod + half * curr[j][x-1] % mod)%mod;\n\t\t\t\t}\n\t\t\t\tnext[y-1][x-1] = (half * curr[y-1][x-1] % mod + half * curr[x-1][y-1] % mod)%mod;\n\t\t\t\tnext[x-1][y-1] = (half * curr[x-1][y-1] % mod + half * curr[y-1][x-1] % mod)%mod;\n\t\t\t}\n\t\tcurr = next;\n//\t\tfor(int g=0; g<n; g++) {\n//\t\t\tfor(int h=0; h<n; h++) {\n//\t\t\t\tSystem.out.println(bin_exp(2,i+1,mod)*next[g][h]%mod);\n//\t\t\t}\n//\t\t}\n\t\tnext = new long[n][n];\n\t\t}\n\t\tlong expectation = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\texpectation = (expectation + curr[i][j]) %mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(expectation*bin_exp(2,q,mod)%mod);\n\t}\n\t\n\tpublic static long bin_exp(long base, long exp, long mod) {\n\t\tif(exp == 0)\n\t\t\treturn 1;\n\t\treturn bin_exp(base*base%mod, exp/2, mod) * (exp%2 == 1? base : 1) % mod;\n\t}\n\t\n\tpublic static long inverse(long a, long mod) {\n\t\treturn bin_exp(a,mod-2,mod);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\tlong mod = 1000000007;\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tlong dp[][] = new long[n][n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(a[i] > a[j])\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tlong half = inverse(2,mod);\n\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(j!=y-1 && j!=x-1) {\n\t\t\t\t\tdp[y-1][j] = dp[x-1][j] = (half * dp[x-1][j] % mod + half * dp[y-1][j] % mod)%mod;\n\t\t\t\t\tdp[j][x-1] = dp[j][y-1] = (half * dp[j][x-1] % mod + half * dp[j][y-1] % mod)%mod;\n\t\t\t\t}\n\t\t\t\tdp[y-1][x-1] = dp[x-1][y-1] = (half * dp[y-1][x-1] % mod + half * dp[x-1][y-1] % mod)%mod;\n\t\t\t}\n\n\t\t}\n\n\t\tlong expectation = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=i+1; j<n; j++) {\n\t\t\t\texpectation = (expectation + dp[i][j]) %mod;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(expectation*bin_exp(2,q,mod)%mod);\n\t}\n\t\n\tpublic static long bin_exp(long base, long exp, long mod) {\n\t\tif(exp == 0)\n\t\t\treturn 1;\n\t\treturn bin_exp(base*base%mod, exp/2, mod) * (exp%2 == 1? base : 1) % mod;\n\t}\n\t\n\tpublic static long inverse(long a, long mod) {\n\t\treturn bin_exp(a,mod-2,mod);\n\t}\n}\n\nclass FastScanner{\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    \n    public FastScanner(InputStream stream)\n    {\n        this.stream = stream;\n    }\n    \n    int read()\n    {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars){\n            curChar = 0;\n            try{\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n    \n    boolean isSpaceChar(int c)\n    {\n        return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;\n    }\n    \n    boolean isEndline(int c)\n    {\n        return c=='\\n'||c=='\\r'||c==-1;\n    }\n    \n    int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n    \n    String next(){\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do{\n            res.appendCodePoint(c);\n            c = read();\n        }while(!isSpaceChar(c));\n        return res.toString();\n    }\n    \n    String nextLine(){\n        int c = read();\n        while (isEndline(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do{\n            res.appendCodePoint(c);\n            c = read();\n        }while(!isEndline(c));\n        return res.toString();\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 1000000007;\n\tstatic final int HALF = (MOD + 1) / 2;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tint q = scanInt();\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = scanInt();\n\t\t}\n\t\tint v[][] = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tv[i][j] = a[i] < a[j] ? 1 : 0;\n\t\t\t}\n\t\t}\n\t\tfor (int qq = 0; qq < q; qq++) {\n\t\t\tint x = scanInt() - 1;\n\t\t\tint y = scanInt() - 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i != x && i != y) {\n\t\t\t\t\tv[i][x] = v[i][y] = mul(v[i][x] + v[i][y], HALF);\n\t\t\t\t\tv[x][i] = v[y][i] = mul(v[x][i] + v[y][i], HALF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[x][y] = v[y][x] = mul(v[x][y] + v[y][x], HALF);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tans = add(ans, v[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tans = add(ans, ans);\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), Q = ni();\n\t\tint[] a = na(n);\n\t\t\n\t\tint[][] qs = new int[Q][];\n\t\tfor(int i = 0;i < Q;i++) {\n\t\t\tqs[i] = new int[] {ni()-1, ni()-1};\n\t\t}\n\t\tint mod = 1000000007;\n\t\tlong[][] dp = new long[n][n];\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tfor(int j = 0;j < n;j++) {\n\t\t\t\tif(a[i] > a[j])dp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong i2 = invl(2, mod);\n\t\tfor(int i = 0;i < Q;i++) {\n\t\t\tint x = qs[i][0], y = qs[i][1];\n\t\t\tfor(int j = 0;j < n;j++) {\n\t\t\t\tif(j == x || j == y)continue;\n\t\t\t\t// [j][y]\n\t\t\t\tlong t = (dp[j][x] + dp[j][y]) * i2 % mod;\n\t\t\t\tdp[j][x] = dp[j][y] = t;\n\t\t\t}\n\t\t\tfor(int j = 0;j < n;j++) {\n\t\t\t\tif(j == x || j == y)continue;\n\t\t\t\t// [j][y]\n\t\t\t\tlong t = (dp[x][j] + dp[y][j]) * i2 % mod;\n\t\t\t\tdp[x][j] = dp[y][j] = t;\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tlong t = (dp[x][y] + dp[y][x]) * i2 % mod;\n\t\t\t\tdp[x][y] = dp[y][x] = t;\n\t\t\t}\n\t\t}\n\t\tlong s = 0;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tfor(int j = i+1;j < n;j++) {\n\t\t\t\ts += dp[i][j];\n\t\t\t}\n\t\t}\n\t\ts %= mod;\n\t\tfor(int i = 0;i < Q;i++)s = s * 2 % mod;\n\t\tout.println(s);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static int[] uniq(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\n\t\t}\n\t\treturn Arrays.copyOf(a, p);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        static final int mod = 1000 * 1000 * 1000 + 7;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextInt();\n            }\n            long[][] d = new long[n][n];\n            for (int i = 0; i < n; ++i)\n                for (int j = 0; j < n; ++j)\n                    d[i][j] = (a[i] < a[j] ? 1 : 0);\n            long inv2 = IntegerUtils.pow(2, mod - 2, mod);\n            for (int it = 0; it < q; ++it) {\n                int x = in.nextInt() - 1;\n                int y = in.nextInt() - 1;\n                Assert.assertTrue(x != y);\n                for (int i = 0; i < n; ++i) {\n                    if (i == x || i == y) continue;\n                    d[i][x] = (((d[i][x] + d[i][y]) * inv2) % mod);\n                    d[i][y] = d[i][x];\n                    d[x][i] = (((d[x][i] + d[y][i]) * inv2) % mod);\n                    d[y][i] = d[x][i];\n                }\n                long val = (d[x][y] + d[y][x]) * inv2;\n                val %= mod;\n                d[x][y] = val;\n                d[y][x] = val;\n            }\n            long mult = IntegerUtils.pow(2, q, mod);\n//        for (int i = 0; i < n; ++i) {\n//            for (int j = 0; j < n; ++j) {\n//                System.err.print((d[i][j] * (long) mult) % mod + \" \");\n//            }\n//            System.err.println();\n//        }\n//        System.err.flush();\n            long res = 0;\n            for (int i = 0; i < n; ++i)\n                for (int j = i + 1; j < n; ++j) {\n                    res += d[j][i];\n                    res %= mod;\n                }\n//        for (int i = 0; i < 30; ++i)\n//            System.err.println(i + \": \" + (res * IntegerUtils.pow(2, i, mod)) % mod);\n            res *= mult;\n            res %= mod;\n            out.printLine(res);\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static int pow(long x, long y, int mod) {\n            x %= mod;\n            long res = 1;\n            while (y > 0) {\n                if (y % 2 == 1) {\n                    --y;\n                    res = (res * x) % mod;\n                } else {\n                    y /= 2;\n                    x = (x * x) % mod;\n                }\n            }\n            return (int) (res % mod);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buffer = new byte[10000];\n        private int cur;\n        private int count;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isSpace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (count == -1) {\n                throw new InputMismatchException();\n            }\n            try {\n                if (cur >= count) {\n                    cur = 0;\n                    count = stream.read(buffer);\n                    if (count <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            return buffer[cur++];\n        }\n\n        public int readSkipSpace() {\n            int c;\n            do {\n                c = read();\n            } while (isSpace(c));\n            return c;\n        }\n\n        public int nextInt() {\n            int sgn = 1;\n            int c = readSkipSpace();\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isSpace(c));\n            res *= sgn;\n            return res;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class Assert {\n        public static void assertTrue(boolean flag) {\n//        if (!flag)\n//        while (true);\n            if (!flag)\n                throw new AssertionError();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var q = ri;\n            var a = Enumerate(n, x => ri);\n            var xs = a.Distinct().OrderBy(x => x).ToList();\n            for (int i = 0; i < n; i++)\n                a[i] = xs.BinarySearch(a[i]);\n            solve(n, a, xs.Count, q);\n        }\n        void solve(int n, int[] a, int m, int q) {\n            var P = Enumerate(n, x => new ModInt[n]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (a[i] > a[j]) P[i][j] = 1;\n            // P[i][j]: A[i] >A [j]\n            var rev2 = ModInt.Inverse(2);\n            for (int _ = 0; _ < q; _++) {\n                var u = ri - 1;\n                var v = ri - 1;\n                if (u > v) Swap(ref u, ref v);\n                P[u][v] = P[v][u] = (P[u][v] + P[v][u]) * rev2;\n                for (int i = 0; i < n; i++) {\n                    if (i != u && i != v) {\n                        var iu = (P[i][u] + P[i][v]) * rev2;\n                        var ui = (P[u][i] + P[v][i]) * rev2;\n                        var iv = (P[i][v] + P[i][u]) * rev2;\n                        var vi = (P[v][i] + P[u][i]) * rev2;\n                        P[i][u] = iu; P[u][i] = ui; P[i][v] = iv; P[v][i] = vi;\n                    }\n                }\n                Debug.WriteLine(\"----------------\");\n                foreach (var x in P)\n                    Debug.WriteLine(x.AsJoinedString());\n            }\n            ModInt ans = 0;\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++)\n                    ans += P[i][j];\n            ans *= ModInt.Pow(2, q);\n            Console.WriteLine(ans);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k) {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n\n    long mod = 1000000007;\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        int Q = cin.nextInt();\n        int[] A = cin.ArrayInt(N);\n        int[] X = new int[Q];\n        int[] Y = new int[Q];\n        for (int i = 0; i < Q; i++)\n        {\n            X[i] = cin.nextInt() - 1;\n            Y[i] = cin.nextInt() - 1;\n        }\n\n        long[,] dp = new long[N, N];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (A[i] > A[j]) dp[i, j] = 1;\n            }\n        }\n\n        long m2 = (mod + 1) / 2;\n\n        long mul = 1;\n\n        for (int t = 0; t < Q; t++)\n        {\n            int a = X[t];\n            int b = Y[t];\n            for (int i = 0; i < N; i++)\n            {\n                if (i == a || i == b) continue;\n\n                long IA = dp[i, a];\n                long IB = dp[i, b];\n                long AI = dp[a, i];\n                long BI = dp[b, i];\n\n                dp[i, a] += IB;\n                dp[i, b] += IA;\n                dp[a, i] += BI;\n                dp[b, i] += AI;\n\n                dp[i, a] %= mod;\n                dp[i, b] %= mod;\n                dp[a, i] %= mod;\n                dp[b, i] %= mod;\n\n                dp[i, a] *= m2;\n                dp[i, b] *= m2;\n                dp[a, i] *= m2;\n                dp[b, i] *= m2;\n\n                dp[i, a] %= mod;\n                dp[i, b] %= mod;\n                dp[a, i] %= mod;\n                dp[b, i] %= mod;\n            }\n\n            dp[a, b] += dp[b, a];\n            dp[a, b] %= mod;\n            dp[a, b] *= m2;\n            dp[a, b] %= mod;\n            dp[b, a] = dp[a, b];\n\n            mul *= 2;\n            mul %= mod;\n        }\n\n        long sum = 0;\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                sum += dp[i, j];\n            }\n        }\n        sum %= mod;\n        sum *= mul;\n        sum %= mod;\n        Console.WriteLine(sum);\n    }\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n\nclass XRand\n{\n    uint x, y, z, w;\n\n\n    public XRand()\n    {\n        init();\n    }\n\n    public XRand(uint s)\n    {\n        init();\n        init_xor128(s);\n    }\n\n    void init()\n    {\n        x = 314159265; y = 358979323; z = 846264338; w = 327950288;\n\n    }\n\n    public void init_xor128(uint s)\n    {\n        z ^= s;\n        z ^= z >> 21; z ^= z << 35; z ^= z >> 4;\n        z *= 736338717;\n    }\n\n    uint next()\n    {\n        uint t = x ^ x << 11; x = y; y = z; z = w; return w = w ^ w >> 19 ^ t ^ t >> 8;\n    }\n\n    public long nextLong(long m)\n    {\n        return (long)((((ulong)next() << 32) + next()) % (ulong)m);\n    }\n\n    public int nextInt(int m)\n    {\n        return (int)(next() % m);\n    }\n\n    public int nextIntP(int a)\n    {\n        return (int)Math.Pow(a, nextDouble());\n    }\n\n    public int nextInt(int min, int max)\n    {\n        return min + nextInt(max - min + 1);\n    }\n\n\n    public double nextDouble()\n    {\n        return (double)next() / uint.MaxValue;\n    }\n\n    public double nextDoubleP(double a)\n    {\n        return Math.Pow(a, nextDouble());\n    }\n}\n\n"
  },
  {
    "language": "Awk",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int mod=1e9+7;\nconst int inv2=(mod+1)/2;\nint qpow(int a,int b) { int c=1;\n    for (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n    return c;\n}\n\nconst int N=3000+10;\n\nint n,q,a[N],x[N],y[N],dp[N][N];\n\nint main() {\n    n=read(),q=read();\n    for (int i=1;i<=n;++i) a[i]=read();\n    for (int i=1;i<=q;++i) x[i]=read(),y[i]=read();\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            dp[i][j]=a[i]>a[j];\n    for (int i=1;i<=q;++i) {\n        int u=x[i],v=y[i];\n        dp[u][v]=dp[v][u]=1ll*(dp[u][v]+dp[v][u])*inv2%mod;\n        for (int j=1;j<=n;++j) {\n            if (j==u||j==v) continue;\n            dp[u][j]=dp[v][j]=1ll*(dp[u][j]+dp[v][j])*inv2%mod;\n            dp[j][u]=dp[j][v]=1ll*(dp[j][u]+dp[j][v])*inv2%mod;\n        }\n    }\n    int ans=0;\n    for (int i=1;i<=n;++i)\n        for (int j=i+1;j<=n;++j)\n            ans=(ans+dp[i][j])%mod;\n    printf(\"%lld\\n\",1ll*ans*qpow(2,q)%mod);\n    return 0;\n}"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nconst MOD = 1000000007\nvar N:int\nvar Q:int\nvar A:seq[int]\nvar X:seq[int]\nvar Y:seq[int]\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  Q = nextInt()\n  A = newSeqWith(N, nextInt())\n  X = newSeqWith(Q, 0)\n  Y = newSeqWith(Q, 0)\n  for i in 0..<Q:\n    X[i] = nextInt() - 1\n    Y[i] = nextInt() - 1\n    if X[i] > Y[i]: swap(X[i], Y[i])\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\ninv2 := initMint(1) / initMint(2)\n\nproc test(Q:int) =\n  var dp = ndSeq(N, N, 0)\n#  for i in 0..<N:\n#    for j in 0..<N:\n#      if A[i] < A[j]: dp[i][j].inc\n  var sum = 0\n  for b in 0..<(1 shl Q):\n    var A = A\n    for q in 0..<Q:\n      if (b and (1 shl q)) > 0:\n        swap(A[X[q]], A[Y[q]])\n    for i in 0..<N:\n      for j in 0..<N:\n        if A[i] < A[j]: dp[i][j].inc\n    var ans = 0\n    for i in 0..<N:\n      for j in 0..<i:\n        if A[i] < A[j]: ans.inc\n#    echo A\n#    echo ans\n    sum += ans\n  dump(sum)\n  echo \"test: \"\n  for i in 0..<N:\n    for j in 0..<N:\n      stdout.write dp[i][j], \" \"\n    echo \"\"\n  echo \"\"\n\n\nproc main() =\n  var dp = ndSeq(N, N, initMint(0))\n  var t = 0\n  for i in 0..<N:\n    for j in 0..<N:\n      if A[i] < A[j]: dp[i][j] += 1;t += 1\n  var\n    tmp_xi = newSeq[Mint](N)\n    tmp_ix = newSeq[Mint](N)\n    tmp_yi = newSeq[Mint](N)\n    tmp_iy = newSeq[Mint](N)\n  var prd = initMint(1)\n  for q in 0..<Q:\n    let (x, y) = (X[q], Y[q])\n    let s = (dp[x][y] + dp[y][x]) * inv2\n    dp[x][y] = s\n    dp[y][x] = s\n    for i in 0..<N:\n      if i == x or i == y: continue\n      dp[x][i] *= inv2\n      dp[i][x] *= inv2\n      dp[y][i] *= inv2\n      dp[i][y] *= inv2\n      tmp_xi[i] = dp[x][i]\n      tmp_ix[i] = dp[i][x]\n      tmp_yi[i] = dp[y][i]\n      tmp_iy[i] = dp[i][y]\n    for i in 0..<N:\n      if i == x or i == y: continue\n      dp[x][i] += tmp_yi[i]\n      dp[i][x] += tmp_iy[i]\n      dp[y][i] += tmp_xi[i]\n      dp[i][y] += tmp_ix[i]\n    prd *= 2\n  ans := initMint(0)\n  for i in 0..<N:\n    for j in 0..<i:\n      ans += dp[i][j]\n  echo ans * prd\n  return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N,Q=map(int,input().split())\nA=[int(input()) for i in range(N)]\nDP=[[0]*(N-i-1) for i in range(N-1)]\nmod=10**9+7\nfor i in range(N-1):\n  for j in range(len(DP[i])):\n    if A[i]>A[i+j+1]:\n      DP[i][j]=1\nx,y=0,0\nv=(10**9+8)>>1\nfor q in range(Q):\n  x,y=map(int,input().split())\n  x,y=x-1,y-1\n  if x>y:\n    x,y=y,x\n  for i in range(x+1,y+1):\n    if A[i]!=A[x]:\n      DP[x][i-x-1]=v\n  for i in range(x+1,y):\n    if A[i]!=A[y]:\n      DP[i][y-i-1]=v\nP=0\nfor i in range(N-1):\n  P+=sum(DP[i])\nP=P*pow(2,Q,mod)%mod\nprint(P)"
  },
  {
    "language": "Python",
    "code": "def run(N, Q, A, XY):\n    return rec_count(A, XY, 0)\n\n\ndef rec_count(A, XY, i):\n    div = 10**9 + 7\n    if i >= len(XY):\n        return count_swap(A) % div\n    A_swap = swap(A, XY[i])\n    return (rec_count(A, XY, i+1) + rec_count(A_swap, XY, i+1)) % div\n\n\ndef swap(A, XY):\n    A_swap = A.copy()\n    X = XY[0] - 1\n    Y = XY[1] - 1\n    A_swap[X], A_swap[Y] = A[Y], A[X]\n    return A_swap\n\n\ndef count_swap(A):\n    cnt = 0\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            if A[i] > A[j]:\n                cnt += 1\n    return cnt\n\n\ndef main():\n    N, Q = map(int, input().split())\n    A = []\n    for _ in range(N):\n        A.append(int(input()))\n    XY = []\n    for _ in range(Q):\n        XY.append(list(map(int, input().split())))\n    print(run(N, Q, A, XY))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def selection(elems, low, high):\n  num_swap = 0\n  ns_l = 0\n  ns_r = 0\n  if(low < high):\n    pos, num_swap = partition(elems,low, high)\n    ns_l = selection(elems, low, pos-1)\n    ns_r = selection(elems, pos+1, high)\n  return num_swap + ns_l + ns_r\n\ndef partition(elems, low, high):\n  pivot = elems[low]\n  num_swap = 0\n  lower_end = low\n  i = low+1\n  while(i <= high):\n    if(elems[i] < pivot):\n      tmp = elems[lower_end]\n      elems[lower_end] = elems[i]\n      elems[i] = tmp\n      #if(i != higher_start):\n      num_swap += 1\n      lower_end += 1\n    i += 1\n  elems[lower_end] = pivot\n  \n  return lower_end, num_swap\n\ndef swap_list(dl, idx1, idx2):\n  tmp = dl[idx1]\n  dl[idx1] = dl[idx2]\n  dl[idx2] = tmp\n\ndef dec2binary(dec):\n    q = dec//2\n    r = dec % 2\n    binary_list = [r]\n    while(q != 0):\n        r = q % 2\n        q = q // 2\n        binary_list.append(r)\n    return binary_list # get the reserved binary_list\n  \ndef main():\n  N, Q =[int(each) for each in input().split()]\n  dl = []\n  \n  operation = []\n  for i in range(N):\n    dl.append(int(input().strip()))\n  for i in range(Q):\n    operation.append([int(each) for each in input().split()])\n  print('dl ', dl)\n  total_num = 0\n  for i in range(2**Q):\n    valid_opr = dec2binary(i)\n    swap_dl = []\n    for m in range(N):\n      swap_dl.append(dl[m])\n\n    for j in range(len(operation)):\n      idx1 = operation[j][0] - 1\n      idx2 = operation[j][1] - 1 \n      if(j < len(valid_opr) and valid_opr[j] == 1):\n        swap_list(swap_dl, idx1, idx2)\n      elif(j >= len(valid_opr)):\n        break\n    tmp_num = selection(swap_dl, 0, len(swap_dl)-1)\n    #print('for {} , the inversion num {}'.format(swap_dl , tmp_num))\n    total_num += tmp_num\n  print(total_num)  \n  return total_num\n\nif __name__ == '__main__':\n  main()\n  "
  },
  {
    "language": "Python",
    "code": "import sys\n\nn, q = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nINV2 = (MOD + 1) // 2\nlines = sys.stdin.readlines()\naaa = list(map(int, lines[:n]))\nmat = [[0] * n for _ in [0] * n]\nfor i in range(n):\n    for j in range(n):\n        mat[i][j] = int(aaa[i] < aaa[j])\n# print(*mat, sep='\\n')\nfor line in lines[n:]:\n    x, y = map(int, line.split())\n    x -= 1\n    y -= 1\n    mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n    for i in range(n):\n        if i == x or i == y:\n            continue\n        mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n        mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    # print(x, y)\n    # print(*mat, sep='\\n')\n\nans = sum(sum(row[:i]) for i, row in enumerate(mat)) % MOD\nans = (ans << q) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N = 3005\nMOD = 1000 * 1000 * 1000 + 7\nn , m = map(int, input().split())\na = [int(input()) for i in range(n)]\nqu = [map(int, input().split()) for i in range(m)]\n\np2 = [1]\nfor i in range(N) : \n    p2.append(p2[i] * 2 % MOD)\n\nf = [[0 for i in range(n)] for j in range(n)]\n\nfor i in range(n) :\n    for j in range(n) : \n        f[i][j] = 1 if a[i] > a[j] else 0\n\nrev2 = (MOD + 1) // 2\n\nfor use in range(m) :\n    x, y = qu[use]\n    x = x - 1\n    y = y - 1\n    for z in range(n) : \n        if (z != x and z != y) :\n            sumzx = (f[z][x] + f[z][y]) * rev2 % MOD\n            sumxz = (f[x][z] + f[y][z]) * rev2 % MOD\n            f[z][x] = f[z][y] = sumzx\n            f[x][z] = f[y][z] = sumxz\n    sumxy = (f[x][y] + f[y][x]) * rev2 % MOD\n    f[x][y] = f[y][x] = sumxy % MOD\nans = 0\nfor i in range(n) :\n    for j in range(i) : \n        ans = (ans + f[j][i]) % MOD\nprint(ans * p2[m] % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn, q = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nINV2 = (MOD + 1) // 2\nlines = sys.stdin.readlines()\naaa = list(map(int, lines[:n]))\nmat = [[0] * n for _ in [0] * n]\nfor i in range(n):\n    for j in range(n):\n        mat[i][j] = int(aaa[i] < aaa[j])\n# print(*mat, sep='\\n')\nfor line in lines[n:]:\n    x, y = map(int, line.split())\n    x -= 1\n    y -= 1\n    mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n    for i in range(n):\n        if i == x or i == y:\n            continue\n        mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n        mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    # print(x, y)\n    # print(*mat, sep='\\n')\n\nans = sum(sum(row[:i]) for i, row in enumerate(mat)) % MOD\nans = (ans << q) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\nN, Q = map(int, readline().split())\nA = [int(readline()) for _ in range(N)]\n\ndp = [[0]*N for _ in range(N)]\n\ntinv = pow(2, MOD-2, MOD)\nfor i in range(N):\n    for j in range(N):\n        if A[i] > A[j]:\n            dp[i][j] = 1\n\nfor q in range(Q):\n    x, y = map(int, readline().split())\n    x -= 1\n    y -= 1\n    dxy = dp[x][y]\n    dyx = dp[y][x]\n    ix = [None]*N\n    iy = [None]*N\n    xi = [None]*N\n    yi = [None]*N\n    for i in range(N):\n        r1 = (dp[i][x] + dp[i][y])*tinv%MOD\n        ix[i] = r1\n        iy[i] = r1\n        r2 = (dp[x][i] + dp[y][i])*tinv%MOD\n        xi[i] = r2\n        yi[i] = r2\n    for i in range(N):\n        dp[x][i] = xi[i]\n        dp[y][i] = yi[i]\n        dp[i][x] = ix[i]\n        dp[i][y] = iy[i]\n    dp[x][y] = (dxy + dyx)*tinv%MOD\n    dp[y][x] = dp[x][y]\n    dp[x][x] = 0\n    dp[y][y] = 0\n\nres = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        res = (res+dp[i][j])%MOD\nprint(res*pow(2, Q, MOD)%MOD)\n    "
  },
  {
    "language": "Python",
    "code": "# input\nN, Q = map(int, input().split())\nA = [int(input()) for _ in range(N)]\nXY = []\nfor _ in range(Q):\n    XY.append(tuple(map(int, input().split())))\n\ndp = [[[None for _ in range(N)] for __ in range(N)] for ___ in range(Q+1)]\nfor i in range(N):\n    for j in range(N):\n        # inverse case\n        dp[0][i][j] = 1 if A[i] > A[j] else 0\n\nfor t in range(1, Q+1):\n    xy = tuple(b-1 for b in XY[t-1])\n    for i in range(N):\n        for j in range(N):\n            dp[t][i][j] = dp[t-1][i][j] * 2\n            if i == j:\n                dp[t][i][j] = 0\n                continue\n            if i in xy and j in xy:\n                dp[t][i][j] = dp[t-1][i][j] + dp[t-1][j][i]\n                continue\n            if i in xy and j not in xy:\n                a = xy[0] if xy[1] == i else xy[1]\n                dp[t][i][j] = dp[t-1][i][j] + dp[t-1][a][j]\n                continue\n            if i not in xy and j in xy:\n                a = xy[0] if xy[1] == j else xy[1]\n                dp[t][i][j] = dp[t-1][i][j] + dp[t-1][i][a]\n                continue\n\nprint(sum(v for i, r in enumerate(dp[-1]) for v in r[i+1:]))\n"
  },
  {
    "language": "Python",
    "code": "# input\nN, Q = map(int, input().split())\nA = [int(input()) for _ in range(N)]\nXY = []\nfor _ in range(Q):\n    XY.append(tuple(map(int, input().split())))\n\ndp = [[[None for _ in range(N)] for __ in range(N)] for ___ in range(Q+1)]\nfor i in range(N):\n    for j in range(N):\n        # inverse case\n        dp[0][i][j] = 1 if A[i] > A[j] else 0\n\n\ndef get_past_value(dp, cur, i, j):\n    past = 1\n    while True:\n        xprev = dp[cur-past][i][j]\n        if xprev is not None:\n            xprev *= pow(2, past-1)\n            return xprev\n        past += 1\n\n\nfor t in range(1, Q+1):\n    x, y = tuple(b-1 for b in XY[t-1])\n\n    # dp[t] = [[v * 2 for v in r] for r in dp[t-1]]\n\n    for j in range(N):\n        if j != x and j != y:\n            dpx, dpy = (get_past_value(dp, t, xy, j) for xy in (x, y))\n            dp[t][x][j] = dp[t][y][j] = dpx + dpy\n            # dp[t][x][j] = dp[t-1][x][j] + dp[t-1][y][j]\n            # dp[t][y][j] = dp[t-1][y][j] + dp[t-1][x][j]\n\n    for i in range(N):\n        if i != x and i != y:\n            dpx, dpy = (get_past_value(dp, t, i, xy) for xy in (x, y))\n            dp[t][i][x] = dp[t][i][y] = dpx + dpy\n            # dp[t][i][x] = dp[t-1][i][x] + dp[t-1][i][y]\n            # dp[t][i][y] = dp[t-1][i][y] + dp[t-1][i][x]\n\n    dpx, dpy = (get_past_value(dp, t, a, b) for (a, b) in zip((x, y), (y, x)))\n    dp[t][x][y] = dp[t][y][x] = dpx + dpy\n    # dp[t][x][y] = dp[t-1][x][y] + dp[t-1][y][x]\n    # dp[t][y][x] = dp[t-1][y][x] + dp[t-1][x][y]\n\n    # for i in range(N):\n    #     for j in range(N):\n    #         dp[t][i][j] = dp[t-1][i][j] * 2\n    #         if i == j:\n    #             dp[t][i][j] = 0\n    #             continue\n    #         if i in xy and j in xy:\n    #             dp[t][i][j] = dp[t-1][i][j] + dp[t-1][j][i]\n    #             continue\n    #         if i in xy and j not in xy:\n    #             a = xy[0] if xy[1] == i else xy[1]\n    #             dp[t][i][j] = dp[t-1][i][j] + dp[t-1][a][j]\n    #             continue\n    #         if i not in xy and j in xy:\n    #             a = xy[0] if xy[1] == j else xy[1]\n    #             dp[t][i][j] = dp[t-1][i][j] + dp[t-1][i][a]\n    #             continue\n\nres = 0\nfor i, r in enumerate(dp[-1]):\n    for j, v in enumerate(r[i+1:]):\n        tmp = 0\n        if v is not None:\n            tmp = v\n            # res += v\n        else:\n            tmp = get_past_value(dp, -1, i, i+j+1) * 2\n            # res += get_past_value(dp, -1, i, j) * 2\n        res += tmp\n\nprint(res)\n\n# print(sum(v for i, r in enumerate(dp[-1]) for v in r[i+1:]))\n\n# dp = [[[] for __ in range(N)] for ___ in range(N)]\n# for i in range(N):\n#     for j in range(N):\n#         # inverse case\n#         dp[i][j].append(1 if A[i] > A[j] else 0)\n\n# for t in range(1, Q+1):\n#     x, y = tuple(b-1 for b in XY[t-1])\n#     for j in range(N):\n#         if j != x and j != y:\n#             dp[x][j].append(dp[x][j][-1] + dp[y][j][-1])\n#             dp[y][j].append(dp[y][j][-1] + dp[x][j][-1])\n\n#     for i in range(N):\n#         if i != x and i != y:\n#             dp[i][x].append(dp[i][x][-1] + dp[i][y][-1])\n#             dp[i][y].append(dp[i][y][-1] + dp[i][x][-1])\n\n#     dp[x][y].append(dp[x][y][-1] + dp[y][x][-1])\n#     dp[y][x].append(dp[y][x][-1] + dp[x][y][-1])\n\n# print(sum(v[-1] for i, r in enumerate(dp) for v in r[i+1:]))\n"
  },
  {
    "language": "Python",
    "code": "# input\nN, Q = map(int, input().split())\nA = [int(input()) for _ in range(N)]\nXY = []\nfor _ in range(Q):\n    XY.append(tuple(map(int, input().split())))\n\ndp = [[[None for _ in range(N)] for __ in range(N)] for ___ in range(Q+1)]\nfor i in range(N):\n    for j in range(N):\n        # inverse case\n        dp[0][i][j] = 1 if A[i] > A[j] else 0\n\nfor t in range(1, Q+1):\n    x, y = tuple(b-1 for b in XY[t-1])\n    dp[t] = [[v * 2 for v in r] for r in dp[t-1]]\n\n    for j in range(N):\n        if j != x and j != y:\n            dp[t][x][j] = dp[t-1][x][j] + dp[t-1][y][j]\n            dp[t][y][j] = dp[t-1][y][j] + dp[t-1][x][j]\n\n    for i in range(N):\n        if i != x and i != y:\n            dp[t][i][x] = dp[t-1][i][x] + dp[t-1][i][y]\n            dp[t][i][y] = dp[t-1][i][y] + dp[t-1][i][x]\n\n    dp[t][x][y] = dp[t-1][x][y] + dp[t-1][y][x]\n    dp[t][y][x] = dp[t-1][y][x] + dp[t-1][x][y]\n\nprint(sum(v for i, r in enumerate(dp[-1]) for v in r[i+1:]))\n"
  },
  {
    "language": "Python",
    "code": "# input\nN, Q = map(int, input().split())\nA = [int(input()) for _ in range(N)]\nXY = []\nfor _ in range(Q):\n    XY.append(tuple(map(int, input().split())))\n\ndp = [[[None for _ in range(N)] for __ in range(N)] for ___ in range(Q+1)]\nfor i in range(N):\n    for j in range(N):\n        # inverse case\n        dp[0][i][j] = 1 if A[i] > A[j] else 0\n\n\ndef get_past_value(dp, cur, i, j):\n    past = 1\n    while True:\n        xprev = dp[cur-past][i][j]\n        if xprev is not None:\n            xprev *= pow(2, past-1)\n            return xprev\n        past += 1\n\n\nfor t in range(1, Q+1):\n    x, y = tuple(b-1 for b in XY[t-1])\n\n    # dp[t] = [[v * 2 for v in r] for r in dp[t-1]]\n\n    for j in range(N):\n        if j != x and j != y:\n            dpx, dpy = (get_past_value(dp, t, xy, j) for xy in (x, y))\n            dp[t][x][j] = dp[t][y][j] = dpx + dpy\n            # dp[t][x][j] = dp[t-1][x][j] + dp[t-1][y][j]\n            # dp[t][y][j] = dp[t-1][y][j] + dp[t-1][x][j]\n\n    for i in range(N):\n        if i != x and i != y:\n            dpx, dpy = (get_past_value(dp, t, i, xy) for xy in (x, y))\n            dp[t][i][x] = dp[t][i][y] = dpx + dpy\n            # dp[t][i][x] = dp[t-1][i][x] + dp[t-1][i][y]\n            # dp[t][i][y] = dp[t-1][i][y] + dp[t-1][i][x]\n\n    dpx, dpy = (get_past_value(dp, t, a, b) for (a, b) in zip((x, y), (y, x)))\n    dp[t][x][y] = dp[t][y][x] = dpx + dpy\n    # dp[t][x][y] = dp[t-1][x][y] + dp[t-1][y][x]\n    # dp[t][y][x] = dp[t-1][y][x] + dp[t-1][x][y]\n\n    # for i in range(N):\n    #     for j in range(N):\n    #         dp[t][i][j] = dp[t-1][i][j] * 2\n    #         if i == j:\n    #             dp[t][i][j] = 0\n    #             continue\n    #         if i in xy and j in xy:\n    #             dp[t][i][j] = dp[t-1][i][j] + dp[t-1][j][i]\n    #             continue\n    #         if i in xy and j not in xy:\n    #             a = xy[0] if xy[1] == i else xy[1]\n    #             dp[t][i][j] = dp[t-1][i][j] + dp[t-1][a][j]\n    #             continue\n    #         if i not in xy and j in xy:\n    #             a = xy[0] if xy[1] == j else xy[1]\n    #             dp[t][i][j] = dp[t-1][i][j] + dp[t-1][i][a]\n    #             continue\n\nres = 0\nfor i, r in enumerate(dp[-1]):\n    for j, v in enumerate(r[i+1:]):\n        tmp = 0\n        if v is not None:\n            tmp = v\n            # res += v\n        else:\n            tmp = get_past_value(dp, -1, i, i+j+1) * 2\n            # res += get_past_value(dp, -1, i, j) * 2\n        res += tmp\n\nprint(res)\n\n# print(sum(v for i, r in enumerate(dp[-1]) for v in r[i+1:]))\n\n# dp = [[[] for __ in range(N)] for ___ in range(N)]\n# for i in range(N):\n#     for j in range(N):\n#         # inverse case\n#         dp[i][j].append(1 if A[i] > A[j] else 0)\n\n# for t in range(1, Q+1):\n#     x, y = tuple(b-1 for b in XY[t-1])\n#     for j in range(N):\n#         if j != x and j != y:\n#             dp[x][j].append(dp[x][j][-1] + dp[y][j][-1])\n#             dp[y][j].append(dp[y][j][-1] + dp[x][j][-1])\n\n#     for i in range(N):\n#         if i != x and i != y:\n#             dp[i][x].append(dp[i][x][-1] + dp[i][y][-1])\n#             dp[i][y].append(dp[i][y][-1] + dp[i][x][-1])\n\n#     dp[x][y].append(dp[x][y][-1] + dp[y][x][-1])\n#     dp[y][x].append(dp[y][x][-1] + dp[x][y][-1])\n\n# print(sum(v[-1] for i, r in enumerate(dp) for v in r[i+1:]))\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc030/tasks/agc030_d\n\nNが小さいな…\n→ NC2のすべての組み合わせに関して、反転する場合は何通りあるか数える？\n→クエリの数を考えたら無理じゃね？\n\n各クエリを行った場合、全ての場合での反転数の合計はどうなるかをO(N)で求める？\n→わりとありそう\n→だとしたらdpっぽい\n\n反転数 = それより右にある小さい要素の数とする\n\n反転数をうまくdp式に縮められない…\n\nnum[i][j] = A[i] > A[j]となる通り数とする。(i < j なら反転数)\n\nindex xとyが交換される場合、全てのv(!=y)に関して\n\nnum[y][v] += num[x][v]\nnum[x][v] += num[y][v]\n\nnum[v][x] += num[v][y]\nnum[v][y] += num[v][x]\n\nnum[x][y] += num[y][x]\nnum[y][x] += num[x][y]\n\n更新は高々4*3000\nなので、C++なら可能？\n\nいじらない部分は2倍する操作が必要。\n最後にまとめて処理するために、いじった部分は半分にしておく\n\n\"\"\"\n\nN,Q = map(int,input().split())\n\nA = []\n\nfor i in range(N):\n\n    a = int(input())\n    A.append(a)\n\nlis = []\nmod = 10**9+7\nhalf = 500000004\n\nfor i in range(N):\n    now = []\n    for j in range(N):\n        if A[i] > A[j]:\n            now.append(1)\n        else:\n            now.append(0)\n    lis.append(now)\n\nfor loop in range(Q):\n\n    #print (lis)\n\n    q = []\n    q2 = []\n    x,y = map(int,input().split())\n    x -= 1\n    y -= 1\n\n    for v in range(N):\n        if v != x and v != y:\n            q.append([y,v,lis[x][v]])\n            q.append([x,v,lis[y][v]])\n            q.append([v,y,lis[v][x]])\n            q.append([v,x,lis[v][y]])\n    q.append([x,y,lis[y][x]])\n    q.append([y,x,lis[x][y]])\n\n    for t in q:\n        i,j,n = t\n        lis[i][j] += n\n        lis[i][j] *= half\n        lis[i][j] %= mod\n\n#print (lis)\n\nans = 0\nfor j in range(N):\n    for i in range(j):\n        ans += lis[i][j]\n        ans %= mod\nprint (ans * pow(2,Q,mod) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nn, q = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nINV2 = (MOD + 1) // 2\nlines = sys.stdin.readlines()\naaa = np.fromiter(map(int, lines[:n]), dtype=np.int)\nmat = (aaa.reshape(1, -1) < aaa.reshape(-1, 1)).astype(np.int64)\n# print(mat)\nfor line in lines[n:]:\n    x, y = map(int, line.split())\n    x -= 1\n    y -= 1\n    tmp = (mat[x, y] + mat[y, x]) * INV2 % MOD\n    mat[x] = mat[y] = (mat[x] + mat[y]) * INV2 % MOD\n    mat[:, x] = mat[:, y] = (mat[:, x] + mat[:, y]) * INV2 % MOD\n    mat[x, x] = mat[y, y] = 0\n    mat[x, y] = mat[y, x] = tmp\n\nans = int(np.triu(mat).sum() % MOD)\nans = (ans << q) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# input\nN, Q = map(int, input().split())\nA = [int(input()) for _ in range(N)]\nXY = []\nfor _ in range(Q):\n    XY.append(tuple(map(int, input().split())))\n\ndp = [[[None for _ in range(N)] for __ in range(N)] for ___ in range(Q+1)]\nfor i in range(N):\n    for j in range(N):\n        # inverse case\n        dp[0][i][j] = 1 if A[i] > A[j] else 0\n\nfor t in range(1, Q+1):\n    xy = tuple(b-1 for b in XY[t-1])\n    for i in range(N):\n        for j in range(N):\n            dp[t][i][j] = dp[t-1][i][j] * 2\n            if i == j:\n                dp[t][i][j] = 0\n                continue\n            if i in xy and j in xy:\n                dp[t][i][j] = dp[t-1][i][j] + dp[t-1][j][i]\n                continue\n            if i in xy and j not in xy:\n                a = xy[0] if xy[1] == i else xy[1]\n                dp[t][i][j] = dp[t-1][i][j] + dp[t-1][a][j]\n                continue\n            if i not in xy and j in xy:\n                a = xy[0] if xy[1] == j else xy[1]\n                dp[t][i][j] = dp[t-1][i][j] + dp[t-1][i][a]\n                continue\n\nprint(sum(v for i, r in enumerate(dp[-1]) for v in r[i+1:]))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n\"\"\"\n・逆再生\n・各時点に対して、「(Ai,Aj)がjが右になって終わる確率」を計算していく\n\"\"\"\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,Q = map(int,readline().split())\ndata = list(map(int,read().split()))\nA = np.array(data[:N])\nit = iter(data[N:])\nXY = list(zip(it,it))\n\ndp = np.triu(np.ones((N,N),np.int64),1)\n\nfor x,y in XY[::-1]:\n    x -= 1; y -= 1\n    p=dp[x,y]; q=dp[y,x]; r=p+q\n    if r&1:\n        r += MOD\n    r //= 2\n    if r>=MOD:\n        r -= MOD\n    temp = dp[x]\n    temp += dp[y]\n    temp[temp&1==1] += MOD; temp//=2; temp[temp>=MOD] -= MOD; dp[y] = temp\n    temp = dp[:,x]\n    temp += dp[:,y]\n    temp[temp&1==1] += MOD; temp//=2; temp[temp>=MOD] -= MOD; dp[:,y] = temp\n    dp[x,y]=r; dp[y,x]=r; dp[x,x]=0; dp[y,y]=0\n\nselect = A[:,None]>A[None,:]\nanswer = (dp*select).sum()*pow(2,Q,MOD)%MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n\"\"\"\n・逆再生\n・各時点に対して、「(Ai,Aj)がjが右になって終わる確率」を計算していく\n\"\"\"\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,Q = map(int,readline().split())\ndata = list(map(int,read().split()))\nA = np.array(data[:N])\nit = iter(data[N:])\nXY = list(zip(it,it))\n\ndp = np.triu(np.ones((N,N),np.int64),1)\n\nfor x,y in XY[::-1]:\n    x -= 1; y -= 1\n    p=dp[x,y]; q=dp[y,x]; r=p+q\n    if r&1:\n        r += MOD\n    r //= 2\n    if r>=MOD:\n        r -= MOD\n    temp = dp[x]\n    temp += dp[y]\n    temp[temp&1==1] += MOD; temp//=2; temp[temp>=MOD] -= MOD; dp[y] = temp\n    temp = dp[:,x]\n    temp += dp[:,y]\n    temp[temp&1==1] += MOD; temp//=2; temp[temp>=MOD] -= MOD; dp[:,y] = temp\n    dp[x,y]=r; dp[y,x]=r; dp[x,x]=0; dp[y,y]=0\n\nselect = A[:,None]>A[None,:]\nanswer = (dp*select).sum()%MOD*pow(2,Q,MOD)%MOD\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nuse std::ops::{Add, AddAssign, Sub, SubAssign, Mul, MulAssign, Neg};\n\nimpl Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n    pub fn comb(n: u32, k: u32) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        let k = std::cmp::min(k, n - k);\n        let mut nu = ModInt::one();\n        let mut de = ModInt::one();\n        for i in 0..k {\n            nu *= ModInt(n - i);\n            de *= ModInt(i + 1);\n        }\n        nu * de.inv()\n    }\n}\n\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end ModInt ----------\nuse std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let q: usize = it.next().unwrap().parse().unwrap();\n    let a: Vec<u32> = (0..n).map(|_| it.next().unwrap().parse().unwrap()).collect();\n    let mut dp = vec![vec![ModInt::zero(); n]; n];\n    let all = ModInt(2).pow(q as u32);\n    for i in 0..n {\n        for j in 0..n {\n            if a[i] > a[j] {\n                dp[i][j] = all;\n            }\n        }\n    }\n    let p = ModInt(2).inv();\n    for _ in 0..q {\n        let mut x = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let mut y = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        if x > y {\n            std::mem::swap(&mut x, &mut y);\n        }\n        for k in 0..n {\n            if k == x || k == y {\n                continue;\n            }\n            let v = (dp[x][k] + dp[y][k]) * p;\n            dp[x][k] = v;\n            dp[y][k] = v;\n            let v = (dp[k][x] + dp[k][y]) * p;\n            dp[k][x] = v;\n            dp[k][y] = v;\n        }\n        let v = (dp[x][y] + dp[y][x]) * p;\n        dp[x][y] = v;\n        dp[y][x] = v;\n    }\n    let mut ans = ModInt::zero();\n    for i in 0..n {\n        for j in (i + 1)..n {\n            ans += dp[i][j];\n        }\n    }\n    println!(\"{}\", ans.0);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc030/tasks/agc030_d\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 1000000007;\n\nfn pow(a: u64, p: u64, m: u64) -> u64 {\n    let mut ret = 1;\n    let mut aa = a;\n    let mut p = p;\n    while p >= 1 {\n        if p & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = (aa * aa) % m;\n        p >>= 1;\n    }\n    ret\n}\n\nfn inv(a: u64, m: u64) -> u64 {\n    pow(a, m - 2, m)\n}\n\nfn get(a: usize, b: usize, dp: &Vec<Vec<u64>>) -> u64 {\n    dp[a][b]\n}\n\nfn set(a: usize, b: usize, dp: &mut Vec<Vec<u64>>, v: u64) {\n    dp[a][b] = v % MOD;\n}\n\nfn main() {\n    input! {\n        n: usize, q: usize,\n        a: [u32; n],\n        queries: [(usize1, usize1); q]\n    };\n\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        for j in 0..n {\n            if a[i] > a[j] {\n                dp[i][j] = 1;\n            }\n        }\n    }\n\n    let div2 = inv(2, MOD);\n\n    for (u, v) in queries {\n        let a = min(u, v);\n        let b = max(u, v);\n\n        let mut ati = vec![];\n        let mut bti = vec![];\n        let mut ita = vec![];\n        let mut itb = vec![];\n        for i in 0..n {\n            ati.push(get(a, i, &dp));\n            bti.push(get(b, i, &dp));\n            ita.push(get(i, a, &dp));\n            itb.push(get(i, b, &dp));\n        }\n\n        {\n            set(a, b, &mut dp, ati[b] * div2 + bti[a] * div2);\n            set(b, a, &mut dp, ati[b] * div2 + bti[a] * div2);\n        }\n\n        for i in 0..n {\n            if i == b || i == a {\n                continue;\n            }\n            set(a, i, &mut dp, ati[i] * div2 + bti[i] * div2);\n            set(i, a, &mut dp, ita[i] * div2 + itb[i] * div2);\n            set(b, i, &mut dp, ati[i] * div2 + bti[i] * div2);\n            set(i, b, &mut dp, ita[i] * div2 + itb[i] * div2);\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n            ans += dp[i][j];\n            ans %= MOD;\n        }\n    }\n    ans *= pow(2, q as u64, MOD);\n    ans %= MOD;\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn get(u: usize, v: usize, qi: usize, dp: &mut Vec<Vec<i64>>, dp_last: &mut Vec<Vec<usize>>, p2: &Vec<i64>) -> i64 {\n    assert!(u != v);\n    assert!(qi >= dp_last[u][v]);\n    let bai = qi - dp_last[u][v];\n    dp[u][v] *= p2[bai];\n    dp[u][v] %= MOD;\n    dp_last[u][v] = qi;\n    dp[u][v]\n}\n\nfn main() {\n    input! {\n        n: usize, q: usize,\n        a: [i32; n],\n        queries: [(usize1, usize1); q]\n    };\n\n\n    let mut dp = dvec!(0; n, n);\n    let mut dp_last = dvec!(0; n, n);\n    for i in 0..n {\n        for j in 0..n {\n            dp[i][j] = ifv!(a[i] < a[j], 1, 0);\n        }\n    }\n\n    let mut p2 = vec![0; q+1];\n    p2[0] = 1;\n    for i in 0..q {\n        p2[i+1] = p2[i] * 2 % MOD;\n    }\n\n    let mut tmpu = vec![0; n];\n    let mut tmpv = vec![0; n];\n    let mut cr = 0;\n    for (u, v) in queries {\n        // u,v\n        tmpu[u] = 0;\n        tmpv[v] = 0;\n\n        let uv = get(u, v, cr, &mut dp, &mut dp_last, &p2);\n        let vu = get(v, u, cr, &mut dp, &mut dp_last, &p2);\n        tmpu[v] = (uv + vu) % MOD;\n        tmpv[u] = (uv + vu) % MOD;\n\n        for i in 0..n {\n            if i != u && i != v {\n                let ui = get(u, i, cr, &mut dp, &mut dp_last, &p2);\n                let vi = get(v, i, cr, &mut dp, &mut dp_last, &p2);\n                tmpu[i] = (ui + vi) % MOD;\n                tmpv[i] = (ui + vi) % MOD;\n                let iu = get(i, u, cr, &mut dp, &mut dp_last, &p2);\n                let iv = get(i, v, cr, &mut dp, &mut dp_last, &p2);\n                let nw = (iu + iv) % MOD;\n                dp[i][u] = nw;\n                dp[i][v] = nw;\n                dp_last[i][u] = cr+1;\n                dp_last[i][v] = cr+1;\n            }\n        }\n        for i in 0..n {\n            dp[u][i] = tmpu[i];\n            dp[v][i] = tmpv[i];\n            dp_last[u][i] = cr+1;\n            dp_last[v][i] = cr+1;\n        }\n        cr += 1;\n    }\n\n    // debug!(dp);\n\n    let mut ans = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            ans += get(j, i, q, &mut dp, &mut dp_last, &p2);\n            ans %= MOD;\n        }\n    }\n\n\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\n\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).ok();\n    let mut it = buf.split_whitespace();\n    let n = it.next().unwrap().parse::<usize>().unwrap();\n    let q = it.next().unwrap().parse::<usize>().unwrap();\n    let a = (0..n).map(|_| it.next().unwrap().parse::<i32>().unwrap()).collect::<Vec<_>>();\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        for j in 0..n {\n            if a[i] > a[j] { dp[i][j] = 1 }\n        }\n    }\n    let m : i64 = 1_000_000_007;\n    let d2 = m - m/2;\n    for _ in 0..q {\n        let x = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let y = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        for i in 0..n {\n            if i == x || i == y { continue }\n            let avg1 = d2 * (dp[i][x] + dp[i][y]) % m;\n            let avg2 = d2 * (dp[x][i] + dp[y][i]) % m;\n            dp[i][x] = avg1;\n            dp[i][y] = avg1;\n            dp[x][i] = avg2;\n            dp[y][i] = avg2;\n        }\n        let avg = d2 * (dp[x][y] + dp[y][x]) % m;\n        dp[x][y] = avg;\n        dp[y][x] = avg;\n    }\n    let mut res = 0;\n    for i in 0..n {\n        for j in i..n {\n            res = (res + dp[i][j]) % m;\n        }\n    }\n    for _ in 0..q { res = 2 * res % m }\n    println!(\"{}\", res);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc030/tasks/agc030_d\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 1000000007;\n\nfn pow(a: u64, p: u64, m: u64) -> u64 {\n    let mut ret = 1;\n    let mut aa = a;\n    let mut p = p;\n    while p >= 1 {\n        if p & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = (aa * aa) % m;\n        p >>= 1;\n    }\n    ret\n}\n\nfn inv(a: u64, m: u64) -> u64 {\n    pow(a, m - 2, m)\n}\n\nfn main() {\n    input! {\n        n: usize, q: usize,\n        a: [u32; n],\n        queries: [(usize1, usize1); q]\n    };\n\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        for j in 0..n {\n            if a[i] > a[j] {\n                dp[i][j] = 1;\n            }\n        }\n    }\n\n    let div2 = inv(2, MOD);\n\n    for (u, v) in queries {\n        let a = min(u, v);\n        let b = max(u, v);\n\n        let mut ati = vec![];\n        let mut bti = vec![];\n        let mut ita = vec![];\n        let mut itb = vec![];\n        for i in 0..n {\n            ati.push(dp[a][i]);\n            bti.push(dp[b][i]);\n            ita.push(dp[i][a]);\n            itb.push(dp[i][b]);\n        }\n\n        {\n            let r = (ati[b] * div2 + bti[a] * div2) % MOD;\n            dp[a][b] = r;\n            dp[b][a] = r;\n        }\n\n        for i in 0..n {\n            if i == b || i == a {\n                continue;\n            }\n            let abi = (ati[i] * div2 + bti[i] * div2) % MOD;\n            let iab = (ita[i] * div2 + itb[i] * div2) % MOD;\n            dp[a][i] = abi;\n            dp[b][i] = abi;\n            dp[i][a] = iab;\n            dp[i][b] = iab;\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n            ans += dp[i][j];\n            ans %= MOD;\n        }\n    }\n    ans *= pow(2, q as u64, MOD);\n    ans %= MOD;\n\n    println!(\"{}\", ans);\n}\n"
  }
]