[
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_M = 101;\nconst int MAX_F = 1000000;\n\nint table[MAX_N][MAX_N];\nint status[MAX_M][MAX_N];\nint N, M;\n\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef set<int> SI;\n\nvoid solve(int k);\nULL point(SI& s);\nbool is_finish(SI& s);\n\nULL maxval = 0;\n\nstruct state {\n\tint p;\n\tSI s;\n};\n\nvector<state> cls;\n\nint main() {\n\tint u, v, f;\n\tcls = vector<state>();\n\n\t// read data\n\tcin >> N >> M;\n\tmemset(&table[0][0], 0, sizeof(int) * MAX_N * MAX_N);\n\tmemset(&table[0][0], 0, sizeof(int) * MAX_M * MAX_N);\n\tfor(int m=0; m<M; m++) {\n\t\tcin >> u >> v >> f;\n\t\ttable[u-1][v-1] = f;\n\t\ttable[v-1][u-1] = f;\n\t\tstatus[m][u-1] = 1;\n\t\tstatus[m][v-1] = 1;\n\t}\n\n\t// solve problem\n\tmaxval = 0;\n\tfor(int i=0; i<M; i++) {\n\t\tsolve(i);\n\t}\n\n\t// print answer\n\tcout << maxval << endl;\n}\n\nvoid solve(int k) {\n\tqueue<SI> que;\n\t\n\t// set initial node\n\tSI s = SI();\n\tfor(int i=0; i<N; i++) {\n\t\tif(status[k][i]) s.insert(i);\n\t}\n\tif(s.size() == 0) return;\n\n\tque.push(s);\n\twhile(!que.empty()) {\n\t\tSI cs = que.front();\n\t\tque.pop();\n\n\t\tif(is_finish(cs)) continue;\n\n\t\tULL p = point(cs);\n\t\tif(maxval < p) maxval = p;\n\t\t\n\t\tint s = cs.size();\n\t\tif(s == N) continue;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tbool is_f = true;\n\t\t\tfor(SI::const_iterator jt = cs.begin(); jt != cs.end(); ++jt) {\n\t\t\t\tint u = (*jt);\n\t\t\t\tif(i != u && table[i][u] == 0) {\n\t\t\t\t\tis_f = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(is_f) {\n\t\t\t\tSI ns = SI();\n\t\t\t\tfor(SI::const_iterator it = cs.begin(); it != cs.end(); ++it) ns.insert((*it));\n\t\t\t\tns.insert(i);\n\t\t\t\tque.push(ns);\n\t\t\t}\n\t\t}\n\t}\n}\n\nULL point(SI& s) {\n\tULL val = 0;\n\tfor(SI::const_iterator it=s.begin(); it != s.end(); ++it) {\n\t\tint min_f = MAX_F;\n\t\tfor(SI::const_iterator jt=s.begin(); jt != s.end(); ++jt) {\n\t\t\tif(it == jt) continue;\n\t\t\tint k = (*it);\n\t\t\tint l = (*jt);\n\t\t\tif(min_f > table[k][l]) min_f = table[k][l];\n\t\t}\n\t\tval += (ULL)min_f;\n\t}\n\n\tstate st;\n\tst.p = val;\n\tst.s = s;\n\tcls.push_back(st);\n\n\treturn val;\n}\n\nbool is_finish(SI& s) {\n\tint size = cls.size();\n\tfor(int i=0; i<size; i++) {\n\t\tSI s0 = cls[i].s;\n\t\tif(s.size() != s0.size()) continue;\n\n\t\tSI::const_iterator it = s.begin();\n\t\tSI::const_iterator it0 = s0.begin();\n\t\tbool is_match = true;\n\t\twhile(it != s.end() && it0 != s0.end()) {\n\t\t\tif((*it) != (*it0)) {\n\t\t\t\tis_match = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++it;\n\t\t\t++it0;\n\t\t}\n\t\tif(is_match) return true;\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint main(){\n\tint N,M;\n\tcin >> N >> M;\n\tvector<vector<long long int>>bridge(N, vector<long long int>(N));\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t}\n\tlong long int ans = 0;\n\tfor(int bp = 0; bp < N; bp++){\n\t\tvector<long long int>D(N, -1);\n\t\tset<long long int>group;\n\t\tgroup.insert(bp);\n\n\t\twhile(true){\n\t\t\tlong long int plusscore = 0, pointidx = -1, plusnum = 0;\n\t\t\tfor(int one = 0; one < N; one++){\n\t\t\t\tif(!group.count(one)){\n\t\t\t\t\tlong long int scorememo = 0, minval = inf;\n\t\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\t\tif(group.count(x)){\n\t\t\t\t\t\t\tif(bridge[one][x] < D[x]){\n\t\t\t\t\t\t\t\tscorememo += D[x] - bridge[one][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tminval = min(bridge[one][x], minval);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(minval - scorememo >= plusscore && inf != minval){\n\t\t\t\t\t\tpointidx = one;\n\t\t\t\t\t\tplusscore = minval - scorememo;\n\t\t\t\t\t\tplusnum = minval;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pointidx == -1)break;\n\n\t\t\tD[pointidx] = plusnum;\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tif(x != pointidx && group.count(x)){\n\t\t\t\t\tif(D[x] == -1)D[x]=bridge[x][pointidx];\n\t\t\t\t\tD[x] = min(bridge[x][pointidx], D[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroup.insert(pointidx);\n\t\t}\n\t\tlong long int ansmemo = 0, bppoint = inf;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(D[i]!=-1){\n\t\t\tansmemo += D[i];\n\t\t\t}\n//\t\t\tcout<<D[i]<< \" \";\n\t\t}\n\t\tans = max(ans, ansmemo);\n//\t\tcout << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int>e[100],v;\nint n,s[100][100],res;\nvoid F()\n{\n\tint i,j,t,c;\n\tif(v.size()>1)\n\t{\n\t\tfor(c=i=0;i<v.size();++i)\n\t\t{\n\t\t\tt=2e9;\n\t\t\tfor(j=0;j<v.size();++j)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tt=min(t,s[v[i]][v[j]]);\n\t\t\t}\n\t\t\tc+=t;\n\t\t}\n\t\tres=max(res,c);\n\t}\n\tif(v.size())\n\t{\n\t\tfor(i=v[v.size()-1]+1;i<n;++i)\n\t\t{\n\t\t\tfor(j=0;j<v.size();++j)\n\t\t\t\tif(!std::binary_search(e[i].begin(),e[i].end(),v[j]))\n\t\t\t\t\tgoto N;\n\t\t\tv.push_back(i);\n\t\t\tF();\n\t\t\tv.pop_back();\n\t\t\tN:;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n-1;++i)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tF();\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\nint main()\n{\n\tint m,a,b,f;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&f);\n\t\t--a,--b;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t\ts[a][b]=s[b][a]=f;\n\t}\n\tfor(m=0;m<n;++m)sort(e[m].begin(),e[m].end());\n\tF();\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nint g[105][105];\n\nint solve(int n, vector<bool> d){\n\tint res = 0;\n\t//for(auto i : d){ cout << i << ' '; } cout << endl;\n\trep(i,n){\n\t\tif(d[i]) continue;\n\t\tint mini = INF;\n\t\trep(j,n){\n\t\t\tif(d[j]) continue;\n\t\t\tif(i == j) continue;\n\t\t\tmini = min(mini, g[i][j]);\n\t\t}\n\t\tres += mini;\n\t}\n\t//show(res)\n\treturn res;\n}\n\nsigned main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> v;\n\tint s = 0;\n\trep(i,m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a][b] = g[b][a] = c;\n\t\ts += c;\n\t}\n\n\tif(n == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<bool> d(n,0);\n\tint ans = solve(n,d);\n\trep(i,n - 2){\n\t\tint maxi = 0, p;\n\t\trep(j,n){\n\t\t\tif(d[j]) continue;\n\t\t\td[j] = true;\n\n\t\t\tint tmp = solve(n,d);\n\t\t\t//show(tmp)\n\t\t\tif(maxi < tmp){\n\t\t\t\tmaxi = tmp;\n\t\t\t\tp = j;\n\t\t\t}\n\t\t\td[j] = false;\n\t\t}\n\t\t//show(maxi)\n\t\tif(ans < maxi){\n\t\t\tans = maxi;\n\t\t\td[p] = true;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D, long long int idx){\n\tlong long int ret = 0;\n\tfor(int i = idx; i < N; i++){\n\t\tauto next = D;\n\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i!=j && D[j] != -1){\n\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t}\n\t\t}\n\t\tlong long int plus = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tlong long int x = D[j];\n\t\t\tlong long int y = next[j];\n\t\t\tif(x == -1)x = 0;\n\t\t\tif(y == -1)y = 0;\n\t\t\tplus += x - y;\n\t\t}\n\t\tif(plus >= 0){\n\t\t\tret = max(ret, solve(D, i + 1));\n\t\t}\n\t\tD = next;\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x, 0));\n//\t\tbridge[bridgepair[i].first][bridgepair[i].second] = 0;\n//\t\tbridge[bridgepair[i].second][bridgepair[i].first] = 0;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 200\ntypedef pair<int,int> P;\nvector<P> G[MAX];\nint ans=0,n,m;\nset<set<int> > ss;\nvoid dfs(set<int> v){\n  int res=0;\n  if(ss.find(v)!=ss.end()) return;\n  ss.insert(v);\n  //cout<<v.size()<<\":\";\n  for(auto i:v){\n    //cout<<i<<\" \";\n    int tmp=-1;\n    for(int j=0;j<(int)G[i].size();j++){\n      if(v.find(G[i][j].first)!=v.end()){\n\tif(tmp<0) tmp=G[i][j].second;\n\telse tmp=min(tmp,G[i][j].second);\n      }\n    }\n    if(tmp<0){\n      res=0;\n      break;\n    }\n    res+=tmp;\n  }\n  //cout<<\":\"<<res<<endl;\n  ans=max(ans,res);\n  set<int> u(v);\n  for(int i=0;i<n;i++){\n    if(v.find(i)!=v.end()) continue;\n    bool f=1;\n    for(auto j:v){\n      bool ff=0;\n      for(int k=0;k<(int)G[j].size();k++) ff|=(i==G[j][k].first);\n      f&=ff;\n    }\n    if(f){\n      u.insert(i);\n      dfs(u);\n      u.erase(i);\n    }\n  }\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int u,v,f;\n    cin>>u>>v>>f;\n    u--;v--;\n    G[u].push_back(P(v,f));\n    G[v].push_back(P(u,f));\n  }\n  set<int> v;\n  dfs(v);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\nint n, m, d[N][N];\nint used[N],ans=0;\n\nvoid dfs(int x){\n  \n  int sum=0;\n  \n  for(int i=0;i<n;i++){\n        \n    if(!used[i]) continue;\n    \n    int mincost=INF;\n    \n    for(int j=0;j<n;j++){\n      \n      if(!used[j]) continue;\n      \n      if(i!=j) mincost=min(mincost,d[i][j]);\n      \n    }\n\n    if(mincost!=INF) sum+=mincost;\n    \n  }\n  \n  if(x>=2) ans=max(ans,sum);\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n    \n    if(used[i]) continue;\n\n    used[i]=1;\n\n    int mincost=INF;\n\n    for(int j=0;j<n;j++)\n\n      if(i!=j&&used[j]) mincost=min(mincost,d[i][j]);\n      \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1);\n    \n    used[i]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<m;i++){\n\n    cin>>a>>b>>f;\n\n    d[a-1][b-1]=d[b-1][a-1]=f;\n  }\n\n  dfs(0);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D, long long int idx){\n\tlong long int ret = 0;\n\tfor(int i = idx; i < N; i++){\n\t\tauto next = D;\n\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(D[j] != -1){\n\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t}\n\t\t}\n\t\tlong long int plus = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tlong long int x = D[j];\n\t\t\tlong long int y = next[j];\n\t\t\tif(x == -1)x = 0;\n\t\t\tif(y == -1)y = 0;\n\t\t\tplus += x - y;\n\t\t}\n\t\tif(plus >= 0){\n\t\t\tret = max(ret, solve(D, i + 1));\n\t\t}\n\t\tD = next;\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x, 0));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int INF=1<<29;\n\nint n,adj[100][100],deg[100];\n\n// decompose to connected component\nvoid dfs(int u,bool *visited,vector<int> &cc){\n\tvisited[u]=true;\n\tcc.push_back(u);\n\trep(v,n) if(adj[u][v] && !visited[v]) dfs(v,visited,cc);\n}\n\nint calc(const vector<int> &cc){\n\tint res=0;\n\tfor(int d=1;d<20;d++){\n\t\t//  d ÈãÌ¸_ðSñ\n\t\tvector<int> S;\n\t\trep(i,cc.size()){\n\t\t\tint u=cc[i];\n\t\t\tif(deg[u]>=d) S.push_back(u);\n\t\t}\n\n\t\tint m=S.size();\n\t\tif(m<d+1) continue;\n\n\t\tif(d==1){\n\t\t\trep(j,m) rep(i,j) res=max(res,2*adj[S[i]][S[j]]);\n\t\t}\n\t\telse{\n\t\t\t// TCY d+1 Ì subset ðSñ\n\t\t\tull T=(1<<d+1)-1;\n\t\t\twhile(T<(1ULL<<m)){\n\t\t\t\t// T ªN[N©Ç¤©ð»è\n\t\t\t\tint w=0;\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,m) if(T&(1LL<<i)) {\n\t\t\t\t\tint w2=INF;\n\t\t\t\t\trep(j,m) if(i!=j && T&(1LL<<j)) w2=min(w2,adj[S[i]][S[j]]);\n\t\t\t\t\tif(w2==0){ ok=false; break; }\n\t\t\t\t\telse w+=w2;\n\t\t\t\t}\n\t\t\t\tif(ok) res=max(res,w);\n\n\t\t\t\tull x=T&-T,y=T+x;\n\t\t\t\tT=((T&~y)/x>>1)|y;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint m; scanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v,w; scanf(\"%d%d%d\",&u,&v,&w); u--; v--;\n\t\tadj[u][v]=adj[v][u]=w;\n\t\tdeg[u]++;\n\t\tdeg[v]++;\n\t}\n\n\tint ans=0;\n\tbool visited[100]={};\n\trep(u,n) if(!visited[u]) {\n\t\tvector<int> cc;\n\t\tdfs(u,visited,cc);\n\t\tans=max(ans,calc(cc));\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nconst double eps = 1e-12;\nconst int V = 110;\nconst int INFI = 1 << 29;\n#define REP(i, x) for (int i=0;i<x;i++)\n\n\nint n, m, ans;\nint mat[V][V], value[20], path[20];\n\nvoid dfs(int v,int path[],int value[],int cnt)\n{\n    int rvalue[20], rpath[20];\n    if (v > n) return;\n    \n    for (int i=0;i<cnt;i++) rpath[i] = path[i], rvalue[i] = value[i];\n    \n    int ret = 0;\n    rvalue[cnt] = INFI;\n    for (int i=0;i<cnt;i++)\n    {\n        int u = path[i];\n        if (!mat[v][u])\n            return;\n        rvalue[i] = min(rvalue[i], mat[v][u]);\n        rvalue[cnt] = min(rvalue[cnt], mat[v][u]);\n        \n        ret += rvalue[i];\n    }\n    if (cnt > 0) ret += rvalue[cnt];\n    \n    if (ret > ans) ans = ret;\n    \n    rpath[cnt] = v;\n    dfs(v+1, rpath, rvalue, cnt+1);\n    dfs(v+1, path, value, cnt);\n}\nint main()\n{\n    int a, b, c;\n    \n    scanf(\"%d%d\",&n,&m);\n    \n    memset(mat, 0, sizeof(mat));\n    for (int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&a,&b,&c);\n        mat[a][b] = c;\n        mat[b][a] = c;\n    }\n    ans = 0;\n    dfs(1, path, value, 0);\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\n\nint N,M;\nvector<edge>G[100];\nint T[100][100];\nconst int L=12;\n\nint ma=0;\nbool used[100];\nint deg[100];\n\nint calc(vint &v){\n    if(v.size()<=1)return 0;\n    int sum=0;\n    for(auto a:v){\n        int t=1001001001;\n        for(auto b:v)if(a!=b)chmin(t,T[a][b]);\n        sum+=t;\n    }\n    return sum;\n}\n\nvoid dfs(){\n    memset(deg,0,sizeof(deg));\n    rep(i,N){\n        if(used[i])continue;\n        for(auto e:G[i])if(!used[e.to])deg[i]++;\n        if(deg[i]>L)continue;\n        vector<int>lis;\n        for(auto e:G[i])if(!used[e.to])lis.pb(e.to);\n        rep(j,1<<lis.size()){\n            vector<int>v={i};\n            rep(k,lis.size()){\n                if(j>>k&1)v.pb(lis[k]);\n            }\n            chmax(ma,calc(v));\n        }\n        used[i]=true;\n        dfs();\n        return;\n    }\n\n    vector<int>v;\n    rep(i,N)if(!used[i])v.pb(i);\n    rep(i,1<<v.size()){\n        vector<int>u;\n        rep(j,v.size())if(i>>j&1)u.pb(v[j]);\n        chmax(ma,calc(u));\n    }\n}\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,M){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].pb(edge(b,c));\n        G[b].pb(edge(a,c));\n        T[a][b]=T[b][a]=c;\n    }\n\n    dfs();\n    cout<<ma<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, ans;\nint used[102];\nvector<P> t[102];\n\nint calcCost(){\n  int res = 0;\n\n  for(int i = 0; i < n; i++){\n    if(used[i] == 0) continue;\n\n    int minCost = INT_MAX;\n\n    for(int j = 0; j < t[i].size(); j++){\n      P p = t[i][j];\n      if(used[p.first] == 0) continue;\n      minCost = min(minCost, p.second);\n    }\n\n    if(minCost != INT_MAX){\n      res += minCost;\n    }\n  }\n\n  return res;\n}\n\nbool check(int id, int cnt){\n  for(int i = 0; i < t[id].size(); i++){\n    int to = t[id][i].first;\n    if(used[to] != 0) cnt--;\n  }\n\n  return cnt == 0;\n}\n\nvoid dfs(int id, int cnt){\n  if(id == n){\n    ans = max(ans, calcCost());\n    return;\n  }\n\n  dfs(id + 1, cnt);\n\n  if(check(id, cnt)){\n    used[id] = true;\n    dfs(id + 1, cnt + 1);\n    used[id] = false;\n  }\n\n  ans = max(ans, calcCost());\n}\n\nvoid solve(){\n  memset(used, 0, sizeof(used));\n  ans = INT_MIN;\n  dfs(0, 0);\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n >> m){\n    for(int i = 0; i < n; i++){\n      t[i].clear();\n    }\n\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n      cin >> a >> b >> c;\n      a--;\n      b--;\n      t[a].push_back(P(b, c));\n      t[b].push_back(P(a, c));\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#define __float128 long double\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nint fr[110][110];\nvector<P> G[110];\nvector<int> cand[20];\n\n\nint v[20];\n\nint calc(int n){\n\t//rep(i, n) cout << v[i] << ' ';\n\t//cout << endl;\n\tint res = 0;\n\trep(i, n){\n\t\tint tmp = 1e9;\n\t\trep(j, n){\n\t\t\tif (i == j) continue;\n\t\t\ttmp = min(tmp, fr[v[i]][v[j]]);\n\t\t}\n\t\tres += tmp;\n\t}\n\treturn res;\n}\n\nint dfs(int i, int k, int sz, int n){\n\tif (i == n) return calc(n);\n\n\tint res = 0;\n\tfor (int j = k; j < sz; ++j){\n\t\tv[i] = cand[n][j];\n\t\tres = max(res, dfs(i + 1, j + 1, sz, n));\n\t\tif (i + sz - k < n) break;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\n\trep(i, m){\n\t\tint a, b, f;\n\t\tcin >> a >> b >> f;\n\t\t--a, --b;\n\t\tG[a].push_back(MP(b, f));\n\t\tG[b].push_back(MP(a, f));\n\t\tfr[a][b] = fr[b][a] = f;\n\t}\n\n\trep(i, n){\n\t\tFOR(j, 1, 15){\n\t\t\tif (G[i].size() >= j) cand[j+1].push_back(i);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tFOR(i, 2, 15){\n\t\tans = max(ans, dfs(0, 0, cand[i].size(), i));\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint res;\nint n;\nint f[128][128];\nvector<int> inv;\n\nvoid dfs(vector<int> v){\n\tif(v.size() > 2){\n\t\tres = max(res, accumulate(v.begin(), v.end(), 0));\n\t}\n\tvector<int> w(v.size() + 1);\n\tfor(int i = inv.back() + 1; i <= n; ++i){\n\t\tint r = 1010101010;\n\t\tfor(size_t j = 1; r && j < v.size(); ++j){\n\t\t\tw[j] = min(v[j], f[inv[j]][i]);\n\t\t\tr = min(r, w[j]);\n\t\t}\n\t\tif(r){\n\t\t\tinv.push_back(i);\n\t\t\tw.back() = r;\n\t\t\tdfs(w);\n\t\t\tinv.pop_back();\n\t\t}\n\t}\n}\n\nint main(){\n\tint m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tf[a][b] = f[b][a] = c;\n\t}\n\tinv.assign(1, 0);\n\tvector<int> v(1);\n\tdfs(v);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n \nint ans,n,m,x,y,z,a[111][111],used[111];\n \n \nvoid dfs(int d,int b){\n  if(d==n){\n    int res=0;\n    if(b<2)return;\n    r(i,b){\n      int A=1e9;\n      r(j,b)if(i!=j){\n        A=min(A,a[used[i]][used[j]]);\n      }\n      res+=A;\n    }\n    ans=max(ans,res);\n    return;\n  }\n  int f=1;\n  r(i,b)if(a[d][used[i]]==0)f=0;\n  if(f){\n    used[b]=d;\n    dfs(d+1,b+1);\n  }\n  dfs(d+1,b);\n}\n \nint main(){\n  cin>>n>>m;\n  r(i,m){\n    cin>>x>>y>>z;\n    x--;y--;\n    a[x][y]=a[y][x]=z;\n  }\n  dfs(0,0);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2306.cc: Rabbit Party\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 100;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\n\n/* global variables */\n\nint n, m;\nvi frs[MAX_N];\nint fns[MAX_N][MAX_N];\nbool used[MAX_N];\n\n/* subroutines */\n\nint calc_sum() {\n  int sum = 0;\n  for (int i = 0; i < n; i++)\n    if (used[i]) {\n      int minf = INF;\n      for (int j = 0; j < n; j++)\n\tif (i != j && used[j] && minf > fns[i][j]) minf = fns[i][j];\n      if (minf < INF) sum += minf;\n    }\n  return sum;\n}\n\nint rec(int u, int k) {\n  if (k == 0) return calc_sum();\n  if (u >= n) return 0;\n\n  int maxsum = 0;\n  vi &fru = frs[u];\n  for (vi::iterator vit = fru.begin(); vit != fru.end(); vit++) {\n    int &v = *vit;\n    if (! used[v]) {\n      used[v] = true;\n      int sum = rec(u + 1, k - 1);\n      used[v] = false;\n\n      if (maxsum < sum) maxsum = sum;\n    }\n  }\n\n  return maxsum;\n}\n\n/* main */\n\nint main() {\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int u, v, f;\n    cin >> u >> v >> f;\n    u--, v--;\n    fns[u][v] = fns[v][u] = f;\n    frs[u].push_back(v);\n    frs[v].push_back(u);\n  }\n\n  int maxsum = 0;\n  for (int i = 2; i * (i - 1) / 2 <= m; i++) {\n    int sum = rec(0, i);\n    if (maxsum < sum) maxsum = sum;\n  }\n\n  printf(\"%d\\n\", maxsum);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000007;\n\nint N, M, ans = 0;\nint g[111][111];\nvector<int> adj[111];\nvector<int> homura;\n\nvoid update()\n{\n\tif (homura.size()==1) return;\n\tint res = 0;\n\tfor (int i = 0; i < homura.size(); ++i)\n\t{\n\t\tint madoka = INF;\n\t\tfor (int j = 0; j < homura.size(); ++j)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tmadoka = min(madoka, g[homura[i]][homura[j]]);\n\t\t}\n\t\tres += madoka;\n\t}\n\tans = max(ans, res);\n}\n\ninline bool check(int v)\n{\n\tfor (int i = 0; i < homura.size(); ++i)\n\t\tif (!g[homura[i]][v]) return 0;\n\treturn 1;\n}\n\nvoid dfs(int u)\n{\n\thomura.push_back(u);\n\tupdate();\n\tint v;\n\tfor (int i = 0; i < adj[u].size(); ++i)\n\t{\n\t\tv = adj[u][i];\n\t\tif (v < u) continue;\n\t\tif (check(v)) dfs(v);\n\t}\n\thomura.pop_back();\n}\n\nint main()\n{\n\tint u, v, d;\n\tscanf(\"%d%d\", &N, &M);\n\twhile (M--)\n\t{\n\t\tscanf(\"%d%d%d\", &u, &v, &d);\n\t\tg[u][v] = g[v][u] = d;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tfor (u = 1; u <= N; ++u)\n\t\tdfs(u);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef __int128 State;\n\nint N, M;\nint G[110][110];\n\nint calc(State s){\n    int res = 0;\n    for(int i=0; i<N; i++) if((s>>i)&1){\n        int x = 1e9;\n        for(int j=0; j<N; j++) if(i!=j && (s>>j)&1){\n            x = min(x, G[i][j]);\n        }\n        res += x;\n    }\n    return res;\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i=0; i<M; i++){\n        int x, y, w;\n        cin >> x >> y >> w; x--; y--;\n        G[x][y] = G[y][x] = w;\n    }\n    \n    int ans = 0;\n    set<State> states;\n    for(int i=0; i<N; i++){\n        states.insert((State)1<<i);\n    }\n    \n    while(states.size()){\n        set<State> tmp;\n        for(auto u: states){\n            for(int i=0; i<N; i++) if(!((u>>i)&1)){\n                bool ok = true;\n                for(int j=0; j<N; j++) if((u>>j)&1){\n                    ok &= G[i][j] != 0;\n                }\n                if(ok){\n                    State v = u;\n                    v |= ((State)1<<i);\n                    ans = max(ans, calc(v));\n                    tmp.insert(v);\n                }\n            }\n        }\n        states = tmp;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D, long long int idx){\n\tlong long int ret = 0;\n\tfor(int i = idx; i < N; i++){\n\t\tauto next = D;\n\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i!=j && D[j] != -1){\n\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t}\n\t\t}\n\t\tlong long int plus = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tlong long int x = D[j];\n\t\t\tlong long int y = next[j];\n\t\t\tif(x == -1)x = 0;\n\t\t\tif(y == -1)y = 0;\n\t\t\tplus += x - y;\n\t\t}\n\t\tif(plus >= 0){\n\t\t\tret = max(ret, solve(D, i + 1));\n\t\t}\n\t\tD = next;\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x, 0));\n\t\tbridge[bridgepair[i].first][bridgepair[i].second] = -inf;\n\t\tbridge[bridgepair[i].second][bridgepair[i].first] = -inf;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 110;\nconst int inf = 0x3f3f3f3f;\n\nint n, m, ans;\nint dis[maxn][maxn];\nint vis[maxn];\n\nvoid dfs(int cur)\n{\n    if (cur > n) return ;\n    int cnt = 0;\n    vis[cur] = 1;\n    dfs(cur + 1);\n    for (int i = 1; i < cur; i++)\n    {\n        if (vis[i] && !dis[i][cur]) return ;\n    }\n    for (int i = 1; i <= cur; i++)\n    {\n        if (!vis[i]) continue;\n        int cc = inf;\n        int flag = 0;\n        for (int j = 1; j <= cur; j++)\n        {\n            if (!vis[j] || i == j) continue;\n            cc = min(cc, dis[i][j]);\n            flag = 1;\n        }\n        if (!flag)\n            cnt += 0;\n        else\n            cnt += cc;\n    }\n    if (cnt > ans)\n        ans = cnt;\n    vis[cur] = 0;\n    dfs(cur + 1);\n    return ;\n}\n\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m))\n    {   \n        ans = 0;\n        memset(dis, 0, sizeof(dis));\n        memset(vis, 0, sizeof(vis));\n        for (int i = 0; i < m; i++)\n        {\n            int u, v, w;\n            scanf(\"%d%d%d\", &u, &v, &w);\n            dis[u][v] = dis[v][u] = max(dis[u][v], w);\n        }\n        dfs(1);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint edges[110][110];\nbool picked[110];\nint n,m;\n\n// ??????u??\\?????????????????????????±?(u??????\n// ?????????????????????????±????????¨????????????§????????????????????????????????\\?????????????????°??????\n// (= ???????????????????????¢??????????????????\nint _solve(int u) {\n    // ?????¨?????¶??????????????¢????¨????\n    int ret = 0;\n    for (int i=0; i<n; ++i) if (picked[i]) {\n        int score = 999999999;\n        for (int j=0; j<n; ++j) if (i != j && picked[j]) {\n            score = min(score, edges[i][j]);\n        }\n        ret += score;\n    }\n \n    for (int i=u; i<n; ++i) if (!picked[i]) { // ?¬?????????¶?????????????£?\n        // ????????????????????¨????????¨????????£?????????\n        bool ok = true;\n        for (int k=0; k<n; ++k) if (picked[k]) {\n            if (edges[i][k] == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            picked[i] = true;\n            ret = max(ret, _solve(i + 1));\n            picked[i] = false;\n        }\n    }\n   return ret;\n}\n\nint solve() {\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        for (int j=i+1; j<n; ++j) if (edges[i][j]) { // ?????????2??????????????¶\n            picked[i] = picked[j] = true;\n            ret = max(ret, _solve(max(i,j) + 1));\n            picked[i] = picked[j] = false;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i=0; i<m; ++i) {\n        int u,v,f; cin >> u >> v >> f;\n        u--; v--;\n        edges[u][v] = edges[v][u] = f;\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVVI G(101);\nint is[101][101];\n\nint dfs(int i, int num, VI& xs){\n  if(SZ(xs) == num){\n\tint res = 0;\n\tfor(int j=0;j<num;++j){\n\t  int tmp = 1e9;\n\t  for(int k=0;k<num;++k){\n\t\tif(j == k) continue;\n\t\tif(!is[xs[j]][xs[k]]) return 0;\n\t\ttmp = min(is[xs[j]][xs[k]], tmp);\n\t  }\n\t  res += tmp;\n\t}\n\treturn res;\n  }\n\n  int res = 0;\n  for(int to: G[i]){\n\tif(find(ALL(xs), to) != xs.end()) continue;\n\txs.PB(to);\n\tres = max(res, dfs(to, num, xs));\n\txs.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  REP(i,M){\n\tint u, v, c; cin >> u >> v >> c;\n\t--u, --v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n\tis[u][v] = is[v][u] = c;\n  }\n\n  int ans = 0;\n  for(int i=2;i<=min(N,4);++i){\n\tVI xs;\n\tREP(u,N){\n\t  xs.PB(u);\n\t  ans = max(ans, dfs(u,i,xs));\n\t  xs.pop_back();\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint ret;\nint g[100][100];\nint use[100][100];\nint n;\nvoid solve(int a){\n\t//for(int i=0;i<n;i++)printf(\"%d \",use[a-1][i]);\n\t//printf(\"\\n\");\n\tfor(int i=a;i<n;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<i&&ok;j++){\n\t\t\tif(a&&use[a-1][j]&&!g[i][j])ok=false;\n\t\t}\n\t\tfor(int j=0;j<=i;j++)use[i][j]=0;\n\t\tif(a==0){\n\t\t\tuse[i][i]=9999999;\n\t\t\tsolve(i+1);\n\t\t}else{\n\t\t\tuse[i][i]=9999999;\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t\tif(use[a-1][j]){\n\t\t\t\t\tuse[i][i]=min(use[i][i],g[i][j]);\n\t\t\t\t\tuse[i][j]=min(use[a-1][j],g[i][j]);\n\t\t\t\t}\n\t\t\tint val=0;\n\t\t\tfor(int j=0;j<=i;j++)if(use[i][j])val+=use[i][j];\n\t\t\tret=max(ret,val);\n\t\t\tsolve(i+1);\n\t\t}\n\t}\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tn=a;\n\tif(a==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint c,d,e;\n\t\tscanf(\"%d%d%d\",&c,&d,&e);\n\t\tc--;d--;\n\t\tg[c][d]=g[d][c]=e;\n\t}\n\tsolve(0);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<memory.h>\n#define min(a,b) (a)<(b)?(a):(b)\n#define max(a,b) (a)>(b)?(a):(b)\nint n,m;\nint a[110][110],dp[110][110],f[110],max[101];\nint dfs(int i,int j,int num)\n{\n if(j>n)\n   return 0;\n if(num>dp[i][j])\n   dp[i][j]=num;\n dfs(i,j+1,num+f[j+1]);\n}\nint main()\n{\n while(scanf(\"%d%d\",&n,&m)==2)\n  {\n   memset(a,0,sizeof(a));\n   memset(f,0,sizeof(f));\n   memset(dp,0,sizeof(dp));\n   memset(max,0,sizeof(max));\n   for(int i=1;i<=m;i++)\n   {\n     int x,y,z;\n     scanf(\"%d%d%d\",&x,&y,&z);\n     a[x][y]=z;\n     a[y][x]=z;\n   }\n   if(m==1)\n   {\n     printf(\"%d\\n\",a[1][2]*2);\n   }\n   else\n   {\n   for(int i=3;i<=n;i++)\n   {\n    for(int j=1;j<i;j++)\n     {\n      f[i]+=a[j][i]-max[j];\n      max[j]=min(max[j],a[j][i]);\n     }\n   }\n   int ans;\n   for(int i=1;i<n;i++)\n    {\n     dfs(i,i,0);\n    }\n    ans=2*dp[1][n];\n    printf(\"%d\\n\",ans);\n  }\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    int tmp = [&]()mutable->int{\n      int ret = 0;\n      int mincost[node];\n      rep(i,node) mincost[i] = IINF;\n      //for(int& i : mincost)i = IINF;\n      for(int i=0;i<node;i++){\n\tfor(int j=i+1;j<node;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      rep(i,node) ret += mincost[i]; \n      return ret;\n    }();\n\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint mat[105][105];\nint n;\nmap<set<pair<int,int>>, int> memo;\n\nint solve(set<pair<int,int>> s){\n  if(memo.count(s)==1) return memo[s];\n\n  int ret = 0;\n  for(auto &p : s) ret += p.se;\n  rep(i,n){\n    auto itr = s.lower_bound(mp(i,0));\n    if(itr!=s.end() && itr->fi == i) continue;\n\n    set<pair<int,int>> ns;\n    bool ok = true;\n    int v = INF;\n    for(auto &p : s){\n      if(mat[i][p.fi] == 0){ok=false; break;}\n      ns.insert(mp(p.fi, min(p.se, mat[i][p.fi])));\n      v = min(v, mat[i][p.fi]);\n    }\n    if(!ok) continue;\n    ns.insert(mp(i,v));\n    ret = max(ret, solve(ns));\n  }\n  return memo[s] = ret;\n}\n\nint main(){\n  int m;\n  cin>>n>>m;\n  fill(mat[0], mat[100], 0);\n  rep(i,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    mat[a][b] = mat[b][a] = c;\n  }\n\n  int res = 0;\n  rep(i,n) rep(j,i) if(mat[i][j]>0){\n    set<pair<int,int>> s = {{i,mat[i][j]}, {j,mat[i][j]}};\n    res = max(res, solve(s));\n  }\n\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\nstruct E{\n  int cost,to;\n  E(int _to,int _cost){\n    cost = _cost;\n    to = _to;\n  }\n};\n\nconst int MAX = 100;\nvector<E>G[MAX];\nint G2[MAX][MAX];\nint res;\nint N,M;\n\nvoid func(set<int>&st){\n  vector<int>vec(st.begin(),st.end());\n  int sum = 0;\n  for(int i = 0 ; i < vec.size() ; i++){\n    int cost = 1e8;\n    for(int j = 0 ; j < vec.size() ; j++){\n      if(i == j)continue;\n      cost = min(cost,G2[vec[i]][vec[j]]);\n    }\n    if(cost == 1e8)cost = 0;\n    sum += cost;\n  }\n  res = max(res,sum);\n  /*\n  for(int i = 0 ; i < vec.size() ; i++){\n    cout << vec[i] << ' ';\n  }\n  cout << endl;\n  cout << \"res = \" << res << \" sum = \" << sum << endl;\n  */\n\n  for(int i = 0 ; i < vec.size() ; i++){\n    for(int j = 0 ; j < G[vec[i]].size() ; j++){\n      int to = G[vec[i]][j].to;\n      if(st.count(to))continue;\n      bool flag = true;\n      for(int k = 0 ; k < vec.size() ; k++){\n        if(G2[to][vec[k]] == 0){\n          flag = false;\n          break;\n        }\n      }\n      if(flag){\n        set<int>n_st = st;\n        n_st.insert(to);\n        func(n_st);\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i = 0 ; i < N ; i++){\n    G[i].clear();\n    for(int j = 0 ; j < N ; j++){\n      G2[i][j] = 0;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    int a,b,c; cin >> a >> b >> c;\n    a--; b--;\n    G[a].push_back(E(b,c));\n    G[b].push_back(E(a,c));\n    G2[a][b] = G2[b][a] = c;\n  }\n  \n  res = 0;\n  for(int i = 0 ; i < N ; i++){\n    set<int>st;\n    st.insert(i);\n    func(st);\n  }\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//cout<<setprecision(20)\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint LBI(vector<llint>&ar,llint in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint UBI(vector<llint>&ar,llint in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint n,m,i;cin>>n>>m;\n\tllint ans=0;\n\tstatic int fre[100][100]={0};\n\tqueue<vector<int>>que;\n\tfor(i=0;i<m;i++){\n\t\tint u,v;llint f;\n\t\tcin>>u>>v>>f;u--;v--;\n\t\tfre[u][v]=f;\n\t\tfre[v][u]=f;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfre[i][i]=big;\n\t\tvector<int>iti;\n\t\titi.pub(i);\n\t\tque.push(iti);\n\t}\n\twhile(que.size()>0){\n\t\tvector<int>rab=que.front();\n\t\tque.pop();\n\t\tif(rab.size()>=2){\n\t\t\tllint gen=0;\n\t\t\tfor(auto it:rab){\n\t\t\t\tllint sai=big;\n\t\t\t\tfor(auto itr:rab){\n\t\t\t\t\tmineq(sai,fre[it][itr]);\n\t\t\t\t}\n\t\t\t\tgen+=sai;\n\t\t\t}\n\t\t\tmaxeq(ans,gen);\n\t\t}\n\t\tfor(i=rab.back()+1;i<n;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(auto it:rab){\n\t\t\t\tif(fre[i][it]==0){ok=false;break;}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tauto rr=rab;\n\t\t\t\trr.pub(i);\n\t\t\t\tque.push(rr);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint n,m;\nvvp G;\nvi used;\nint out=0;\nint f(){\n\tint sum=0;\n\trep(i,n)if(used[i]){\n\t\tint mi=inf;\n\t\trep(j,G[i].size())if(used[G[i][j].first])mi=min(mi,G[i][j].second);\n\t\tif(mi==inf)mi=0;\n\t\tsum+=mi;\n\t}\n\t// cout<<sum<<endl;\n\t// show1d(used);\n\treturn sum;\n}\nmap<pii,int>ma;\nvoid dfs(int a){\n\tif(a==n)return ;\n\tbool H=true;\n\trep(j,a)if(used[j]&&ma[{a,j}]==0)H=false;\n\tdfs(a+1);\n\tif(H){\n\t\tused[a]=1;\n\t\tout=max(out,f());\n\t\tdfs(a+1);\n\t\tused[a]=0;\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tG=vvp(n);\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tG[a].pb({b,c});\n\t\tG[b].pb({a,c});\n\t\tma[{a,b}]=1;\n\t\tma[{b,a}]=1;\n\t}\n\tused=vi(n);\n\tdfs(0);\n\tcout<<out<<endl;\n}\n\n/*\nint n;\nvvi in;\nmap<pii,int>ma;\nbool dfs(int a){\n\trep(i,n+1){\n\t\tif(i==n)return true;\n\t\tif(in[i][3]==0){\n\t\t\t\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vvi(n,vi(4));\n\t\tma.clear();\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tchar c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tin[i]={a,b,c=='y',0};\n\t\t\tma[{a,b}]=i+1;\n\t\t\tif(c=='x')a++;\n\t\t\telse b++;\n\t\t\tma[{a,b}]=i+1;\n\t\t}\n\t\tif(dfs(0))cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}\n*/\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nvector<P> idx;\n\nset<vector<int> > memo;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n  sort(G.begin(),G.end());\n  \n  if(memo.count(G)) return ;\n  memo.insert(G);\n  \n  for(int i=0;i<n;i++){\n\n    if(used[idx[i].S]) continue;\n\n    used[idx[i].S]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(idx[i].S);\n    \n    for(int j=0;j<nG.size();j++)\n      \n      if(idx[i].S!=nG[j]&&used[nG[j]])\n\tmincost=min(mincost,d[idx[i].S][nG[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n    \n    used[idx[i].S]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<n;i++) idx.push_back(P(0,i));\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n    idx[a-1].first++;\n    idx[b-1].first++;\n  }\n\n  //  sort(idx.begin(),idx.end());\n  \n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> graph(n,vector<int>(n));\n    rep(i,0,m){\n        int u,v,f;\n        cin >> u >> v >> f;\n        --u;\n        --v;\n        graph[u][v]=graph[v][u]=f;\n    }\n\n    int ans=0;\n    rep(i,2,inf){\n        if(i*(i-1)/2>m) continue;\n        map<set<int>,int> memo;\n        map<set<int>,bool> done;\n        function<int(int,set<int>)> rec=[&](int num,set<int> s){\n            int &res=memo[s];\n            if(done[s]) return res;\n            done[s]=true;\n            if(num==0){\n                for(int v:s){\n                    int tmp=inf;\n                    for(int u:s){\n                        if(u==v) continue;\n                        tmp=min(tmp,graph[v][u]);\n                    }\n                    res+=tmp;\n                }\n                return res;\n            }\n            rep(v,0,n){\n                if(s.find(v)!=s.end()) continue;\n                bool ok=true;\n                for(int u:s){\n                    if(graph[v][u]!=0) continue;\n                    ok=false;\n                    break;\n                }\n                if(!ok) continue;\n                set<int> s_=s;\n                s_.insert(v);\n                res=max(res,rec(num-1,s_));\n            }\n            return res;\n        };\n        int tmp=rec(i,set<int>());\n        if(tmp==0) break;\n        ans=max(ans,tmp);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 101 , INF = 1000000000;\n\nint adj[N][N];\n\nint n , m , opt;\n\nint subG[N] , sub_cnt;\n\nint read() {\n    if(scanf(\"%d%d\" , &n , &m) == -1) return 0;\n    memset(adj , 0 , sizeof(adj));\n    for(int i = 0 ; i < m ; i++) {\n        int s , t , w;\n        scanf(\"%d%d%d\" , &s , &t , &w);\n        adj[s][t] = adj[t][s] = w;\n    }\n    return 1;\n}\n\nint check(int u) {\n    for(int i = 1 ; i <= sub_cnt ; i++) {\n        if(adj[u][subG[i]] == 0) return 0;\n    }\n    return 1;\n}\n\nvoid update() {\n    int res = 0;\n    for(int i = 1 ; i <= sub_cnt ; i++) {\n        int mn = INF;\n        for(int j = 1 ; j <= sub_cnt ; j++) if(i ^ j) {\n            if(adj[subG[i]][subG[j]] < mn)\n                mn = adj[subG[i]][subG[j]];\n        }\n        res += mn;\n    }\n    if(res > opt) opt = res;\n}\n\nvoid dfs(int u) {\n    if(sub_cnt > 1) update();\n    for(int i = 1 ; i <= n ; i++) {\n        if(check(i)) {\n            subG[++sub_cnt] = i;\n            dfs(i);\n            --sub_cnt;\n        }\n    }\n}\n\nvoid solve() {\n    opt = 0;\n    sub_cnt = 0;\n    for(int i = 1 ; i <= n ; i++) {\n        subG[++sub_cnt] = i;\n        dfs(i);\n        --sub_cnt;\n    }\n    printf(\"%d\\n\" , opt);\n}\n\n\nint main() {\n\n//    freopen(\"std.in\" , \"r\" , stdin);\n    while(read()) {\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge\n{\n\tint v,w;\n\tEdge *nxt;\n}buf[2*1005],*g[105],*p;\nvoid add(int u, int v, int w)\n{\n\tp->v = v;\n\tp->w = w;\n\tp->nxt = g[u];\n\tg[u] = p++;\n}\nint n,m;\nstruct Node\n{\n\tint x,y,w;\n}e[105];\nbool cmp(Node p1, Node p2)\n{\n\treturn p1.w > p2.w;\n}\nint f[105],val[105],ax[105];\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tmemset(g,0,sizeof(g));\n\t\tp = buf;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&e[i].x,&e[i].y,&e[i].w);\n\t\t\tadd(e[i].x,e[i].y,e[i].w);\n\t\t\tadd(e[i].y,e[i].x,e[i].w);\n\t\t}\n\t\tsort(e,e+m,cmp);\n\t\tmemset(val,-1,sizeof(val));\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(val[e[i].x]!=-1 && val[e[i].y]!=-1)continue;\n\t\t\tint tp = 0;\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tax[j] = val[j];\n\t\t\tif(ax[e[i].x]==-1)\n\t\t\t\tax[e[i].x] = e[i].w;\n\t\t\telse ax[e[i].x] = min(ax[e[i].x],e[i].w);\n\t\t\tif(ax[e[i].y]==-1)\n\t\t\t\tax[e[i].y] = e[i].w;\n\t\t\telse ax[e[i].y] = min(ax[e[i].y],e[i].w);\n\t\t\tif(!f[e[i].x])\n\t\t\t\tfor(Edge *now = g[e[i].x]; now; now = now->nxt)\n\t\t\t\t{\n\t\t\t\t\tint v = now->v;\n\t\t\t\t\tif(ax[v]!=-1 && v!=e[i].y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ax[v]>now->w)\n\t\t\t\t\t\t\ttp += now->w-ax[v], ax[v]=now->w;\n\t\t\t\t\t\tax[e[i].x] = min(ax[e[i].x],now->w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(!f[e[i].y])\n\t\t\t\tfor(Edge *now = g[e[i].y]; now; now = now->nxt)\n\t\t\t\t{\n\t\t\t\t\tint v = now->v;\n\t\t\t\t\tif(ax[v]!=-1 && v!=e[i].x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ax[v]>now->w)\n\t\t\t\t\t\t\ttp += now->w-ax[v], ax[v]=now->w;\n\t\t\t\t\t\tax[e[i].y] = min(ax[e[i].y],now->w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\ttp += ax[e[i].x]-max(val[e[i].x],0)+ax[e[i].y]-max(val[e[i].y],0);\n\t\t\tif(tp>0)\n\t\t\t{\n\t\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\t\tval[j] = ax[j];\n\t\t\t}\n//\t\t\tfor(int j = 1; j <= n; j++)\n//\t\t\t\tprintf(\"%d%c\",val[j],j==n?'\\n':' ');\n\t\t}\n\t\tint ret = 0;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(val[i]!=-1)\n\t\t\t{\n\t\t\t\tret += val[i];\n\t\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef __int128 State;\n\nint N, M;\nint G[110][110];\n\nint calc(State s){\n    int res = 0;\n    for(int i=0; i<N; i++) if((s>>i)&1){\n        int x = 1e9;\n        for(int j=0; j<N; j++) if(i!=j && (s>>j)&1){\n            x = min(x, G[i][j]);\n        }\n        res += x;\n    }\n    return res;\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i=0; i<M; i++){\n        int x, y, w;\n        cin >> x >> y >> w; x--; y--;\n        G[x][y] = G[y][x] = w;\n    }\n    \n    int ans = 0;\n    set<State> states;\n    for(int i=0; i<N; i++){\n        states.insert(1LL<<i);\n    }\n    \n    while(states.size()){\n        set<State> tmp;\n        for(auto u: states){\n            for(int i=0; i<N; i++) if(!((u>>i)&1)){\n                bool ok = true;\n                for(int j=0; j<N; j++) if((u>>j)&1){\n                    ok &= G[i][j] != 0;\n                }\n                if(ok){\n                    State v = u;\n                    v |= (1<<i);\n                    ans = max(ans, calc(v));\n                    tmp.insert(v);\n                }\n            }\n        }\n        states = tmp;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 1234567;\nint n;\nint f[100][100]={};\n\nmap<set<pi>,int> dp;\nint dfs(const set<pi> &s)\n{\n    if(dp.count(s)) return dp[s];\n\n    int ret = 0;\n    for(auto &x:s) ret += x.se;\n\n    // dbg(vector<pi>(all(s)));\n    // dbg(ret);\n    rep(i,n)\n    {\n        auto itr = s.lower_bound(pi(i,0));\n        if(itr->fi == i) continue;\n\n        bool ok = true;\n        set<pi> ns;\n        int a = INF;\n        for(auto x:s)\n        {\n            ok &= (f[x.fi][i]>0);\n            x.se = min(x.se,f[x.fi][i]);\n            a = min(a,f[x.fi][i]);\n            ns.insert(x);\n        }\n        ns.insert(pi(i,a));\n\n        if(ok) ret = max(ret, dfs(ns));\n    }\n    return dp[s] = ret;\n}\n\nint main()\n{\n    int m;\n    cin >>n >>m;\n\n    vector<int> u(m),v(m),c(m);\n    rep(i,m)\n    {\n        cin >>u[i] >>v[i] >>c[i];\n        --u[i];\n        --v[i];\n        f[u[i]][v[i]] = f[v[i]][u[i]] = c[i];\n    }\n\n    int ans = 0;\n    rep(i,m)\n    {\n        set<pi> s;\n        s.insert(pi(u[i],c[i]));\n        s.insert(pi(v[i],c[i]));\n        ans = max(ans,dfs(s));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nint n,adj[100][100],deg[100];\n\nvoid dfs(int u,bool *visited,vector<int> &cc){\n\tvisited[u]=true;\n\tcc.push_back(u);\n\trep(v,n) if(adj[u][v] && !visited[v]) dfs(v,visited,cc);\n}\n\nint calc(const vector<int> &cc){\n\tint res=0;\n\tfor(int d=1;d<20;d++){\n\t\tvector<int> S;\n\t\trep(i,cc.size()){\n\t\t\tint u=cc[i];\n\t\t\tif(deg[u]>=d) S.push_back(u);\n\t\t}\n\n\t\tint m=S.size();\n\t\tif(m<d+1) continue;\n\t\tif(d==1){\n\t\t\trep(j,m) rep(i,j) res=max(res,2*adj[S[i]][S[j]]);\n\t\t}\n\t\telse{\n\t\t\tll T=(1<<d+1)-1;\n\t\t\twhile(T<(1LL<<m)){\n\t\t\t\tint w=0;\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,m) if(T&(1LL<<i)) {\n\t\t\t\t\tint w2=INF;\n\t\t\t\t\trep(j,m) if(i!=j && T&(1LL<<j)) w2=min(w2,adj[S[i]][S[j]]);\n\t\t\t\t\tif(w2==0){ ok=false; break; }\n\t\t\t\t\telse w+=w2;\n\t\t\t\t}\n\t\t\t\tif(ok) res=max(res,w);\n\n\t\t\t\tll x=T&-T,y=T+x;\n\t\t\t\tT=((T&~y)/x>>1)|y;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint m; scanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v,w; scanf(\"%d%d%d\",&u,&v,&w); u--; v--;\n\t\tadj[u][v]=adj[v][u]=w;\n\t\tdeg[u]++;\n\t\tdeg[v]++;\n\t}\n\n\tint ans=0;\n\tbool visited[100]={};\n\trep(u,n) if(!visited[u]) {\n\t\tvector<int> cc;\n\t\tdfs(u,visited,cc);\n\t\tans=max(ans,calc(cc));\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nint N, M;\nint u, v, f;\nconst int MAX_N = 101;\nconst int MAX_F = 1000000;\n\nint maxv = 0;\nint table[MAX_N][MAX_N];\nbool att[MAX_N];\n\nvoid solve(int last) {\n\tint ret = 0;\n\tfor(int i=0; i<last+1; i++) {\n\t\tif(!att[i]) continue;\n\t\tint minF = MAX_F;\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tif(i == j) continue;\n\t\t\tif(!att[j]) continue;\n\t\t\tminF = min(minF, table[i][j]);\n\t\t}\n\t\tif(minF == MAX_F) continue;\n\t\tret += minF;\n\t}\n\tmaxv = max(maxv, ret);\n\n\tfor(int i=last+1; i<N; i++) {\n\t\tbool isF = true;\n\t\tfor(int j=0; j<last+1; j++) {\n\t\t\tif(!att[j]) continue;\n\t\t\tif(table[i][j]==0) { isF = false; break; }\n\t\t}\n\t\tif(!isF) continue;\n\t\tatt[i] = true;\n\t\tsolve(i);\n\t\tatt[i] = false;\n\t}\n}\n\nint main() {\n\tcin >> N >> M;\n\tmemset(table, 0, sizeof(int) * MAX_N * MAX_N);\n\tfor(int i=0; i<N; i++) att[i] = false;\t\n\tfor(int i=0; i<M; i++) {\n\t\tcin >> u >> v >> f;\n\t\tu--;\n\t\tv--;\n\t\ttable[u][v] = f;\n\t\ttable[v][u] = f;\n\t}\n\tmaxv = 0;\n\tsolve(-1);\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int maxn=105;\nconst int INF=1e9;\nint g[maxn][maxn];\nint father[maxn],mincost[maxn];\nint n,m,ans;\nbool check(int x,int y)\n{\n  while(g[x][y])\n  {\n    x=father[x];\n    if(x==-1)\n        return 1;\n  }\n  return 0;\n}\nvoid update_mincost(int x)\n{\n   int mi=INF;\n   int res=0,tmp=x;\n   while(father[x]!=-1)\n   {\n       x=father[x];\n       if(g[x][tmp]<mincost[x])\n       mincost[x]=g[x][tmp];\n       if(g[x][tmp]<mi)\n        mi=g[x][tmp];\n       res+=mincost[x];\n   }\n   mincost[tmp]=mi;\n   res+=mi;\n   if(res>ans&&mi!=INF)\n    ans=res;\n}\nvoid dfs(int x)\n{\n    update_mincost(x);\n    for(int i=x+1;i<=n;i++)\n    {\n       if(!g[x][i])\n        continue ;\n        if(check(x,i))\n        {\n            father[i]=x;\n            dfs(i);\n        }\n    }\n}\nint main()\n{\n//    cout << \"Hello world!\" << endl;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        memset(g,0,sizeof(g));\n        int from,to,cost;\n        for(int i=0;i<m;i++)\n        {\n           scanf(\"%d%d%d\",&from,&to,&cost);\n           g[from][to]=cost;\n           g[to][from]=cost;\n        }\n        ans=0;\n        for(int i=1;i<=n;i++)\n        {\n            father[i]=-1;\n            dfs(i);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint rab1[101],rab2[101],fri[101];\nint n,m;\nint usemin[101];\n\nint getpoint(int usemap[101],int count){\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(usemap[i]==count-1){\n\t\t\tans += usemin[i];\n\t\t}else if(usemap[i]){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint solve(int usemap[101],int i,int count){\n\tif(i==m){\n\t\treturn 0;\n\t}\n\tint ans1=0,ans2=0;\n\tint buf=0;\n\tif(!usemap[rab1[i]]){\n\t\tbuf++;\n\t}\n\tif(!usemap[rab2[i]]){\n\t\tbuf++;\n\t}\n\tif(count+buf < 14){\n\t\tusemap[rab1[i]]++;\n\t\tusemap[rab2[i]]++;\n\t\tint minbuf1 = usemin[rab1[i]];\n\t\tint minbuf2 = usemin[rab2[i]];\n\t\tusemin[rab1[i]] = min(usemin[rab1[i]],fri[i]);\n\t\tusemin[rab2[i]] = min(usemin[rab2[i]],fri[i]);\n\t\tans1 = max(solve(usemap,i+1,count+buf),getpoint(usemap,count+buf));\n\t\tusemap[rab1[i]]--;\n\t\tusemap[rab2[i]]--;\n\t\tusemin[rab1[i]] = minbuf1;\n\t\tusemin[rab2[i]] = minbuf2;\n\t}\n\tans2 = solve(usemap,i+1,count);\n\n\treturn max(ans1,ans2);\n}\n\nint main(){\n\tmemset(usemin,(1000*1000+1),sizeof(usemin));\n\tcin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> rab1[i] >> rab2[i] >> fri[i];\n\t}\n\tint usemap[101];\n\tmemset(usemap,0,sizeof(usemap));\n\tint ans = solve(usemap,0,0);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    int tmp = [&]()mutable->int{\n      int ret = 0;\n      int mincost[node];\n      rep(i,node) mincost[i] = IINF;\n      for(int i=0;i<node;i++){\n\tfor(int j=i+1;j<node;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      rep(i,node) ret += mincost[i]; \n      return ret;\n    }();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nint n, m;\nint g[105][105];\nint ans;\nset<vector<bool>> memo;\n\nvoid dfs(vector<bool> used){\n\tif(not (memo.emplace(used)).second) return;\n\tfor(auto i : used){ cout << i << ' ' ; } cout << endl;\n\n\tvector<int> to;\n\trep(i,n){\n\t\tif(used[i]) continue;\n\t\tbool f = true;\n\t\trep(j,n){\n\t\t\tif(not used[j]) continue;\n\t\t\tif(i == j || g[j][i] == 0){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) to.emplace_back(i);\n\t}\n\n\tfor(auto i : to){\n\t\tused[i] = true;\n\t\tdfs(used);\n\t\tused[i] = false;\n\t}\n\n\tint sum = 0;\n\trep(i,n){\n\t\tif(not used[i]) continue;\n\t\tint mini = INF;\n\t\trep(j,n){\n\t\t\tif(not used[j]) continue;\n\t\t\tif(g[i][j] == 0) continue;\n\t\t\tmini = min(mini, g[i][j]);\n\t\t}\n\t\tif(mini == INF) continue;\n\t\tsum += mini;\n\t}\n\tans = max(ans, sum);\n}\n\nsigned main(){\n\tcin >> n >> m;\n\n\tvector<int> v;\n\trep(i,m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a][b] = g[b][a] = c;\n\t}\n\n\trep(i,n){\n\t\tvector<bool> tmp(n,0);\n\t\ttmp[i] = true;\n\t\tdfs(tmp);\n\t}\n\tcout << ans << endl;\n\n\t//for(auto i : memo){ for(auto j : i){ cout << j << ' '; } cout << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nvector<P> idx;\n\nset<vector<int> > memo;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n  sort(G.begin(),G.end());\n  \n  if(memo.count(G)) return ;\n  memo.insert(G);\n  \n  for(int i=0;i<n;i++){\n\n    if(used[idx[i].S]) continue;\n\n    used[idx[i].S]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(idx[i].S);\n    \n    for(int j=0;j<nG.size();j++)\n      \n      if(idx[i].S!=nG[j]&&used[nG[j]])\n\tmincost=min(mincost,d[idx[i].S][nG[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n    \n    used[idx[i].S]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<n;i++) idx.push_back(P(0,i));\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n    idx[a-1].first++;\n    idx[b-1].first++;\n  }\n\n  sort(idx.begin(),idx.end());\n  \n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n    int u, v, f;\n    Edge(int u = 0, int v = 0, int f = 0) : u(u), v(v), f(f) {}\n};\n\nconst int maxn = 105;\n\nint n, m;\n//vector<Edge> edge;\n//vector<int> g[maxn];\n//\n//void add(int u, int v, int f) {\n//    edge.push_back(Edge(u, v, f));\n//    g[u].push_back(edge.size() - 1);\n//}\nint g[maxn][maxn];\n\nint maxv;\nint ans[maxn];\nint picked[maxn];\nvoid dfs(int k) {\n    int sum = 0;\n    for(int i = 1; i <= k; i++) if(picked[i]) {\n        int minv = 1 << 29;\n        for(int j = 1; j <= k; j++) if(picked[j] && i != j) {\n            minv = min(minv, g[i][j]);\n        }\n        sum += minv == 1 << 29 ? 0 : minv;\n    }\n    maxv = max(maxv, sum);\n\n    for(int i = k + 1; i <= n; i++) {\n        int flag = 1;\n        for(int j = 1; j <= k; j++) if(picked[j]) \n            {\n            if(g[i][j] == 0) flag = 0;\n        }\n        if(flag) {\n            picked[i] = 1;\n            dfs(i);\n            picked[i] = 0;\n        }\n    }\n}\nint main() {\n    while(scanf(\"%d%d\", &n, &m) != EOF) {\n        memset(g, 0, sizeof(g));\n        for(int i = 0; i < m; i++) {\n            int u, v, f;\n            scanf(\"%d%d%d\", &u, &v, &f);\n            g[u][v] = g[v][u] = f;\n//            add(u, v, f);\n//            add(v, u, f);\n        }\n        maxv = 0;\n        memset(picked, 0, sizeof(picked));\n        for(int i = 1; i <= n; i++) {\n            picked[i] = 1;\n            dfs(i);\n            picked[i] = 0;\n        }\n        printf(\"%d\\n\", maxv);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n  int n, m;\n  while (cin >> n >> m && n + m){\n    int score[110][110];\n    memset(score, 0, sizeof(score));\n\n    REP(i, m){\n      int x, y, f;\n      cin >> x >> y >> f; x--, y--;\n      score[x][y] = score[y][x] = f;\n    }\n\n    int res = 0;\n    REP(i, n){\n      vector<int> fs;\n      REP(j, n) if (score[i][j] > 0){\n        fs.push_back(j);\n      }\n      \n      int size = fs.size();\n      if (size * (size - 1) / 2 <= m){\n\n        \n        REP2(mask, 1, 1 << size){\n          \n          vector<int> vs(1, i);\n          REP(j, mask) if (mask & (1 << j)){\n            vs.push_back(fs[j]);\n          }\n          \n          int sum = 0;\n          REP(j, vs.size()){\n            int add = 1e9;\n            REP(k, vs.size()) if (j != k) {\n              add = min(add, score[vs[j]][vs[k]]);\n            }\n            sum += add;\n          }\n          res = max(res, sum);\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\ntypedef struct{\n    int to, w;\n}Edge;\n\nint N, M;\nvector<vector<Edge>> G;\n\nint main(){\n    cin >> N >> M;\n    G.resize(N);\n    for(int i=0; i<M; i++){\n        int x, y, w;\n        cin >> x >> y >> w; x--; y--;\n        G[x].push_back(Edge({y, w}));\n        G[y].push_back(Edge({x, w}));\n    }\n    \n    int ans = 0;\n    for(int s=0; s<N; s++){\n        int tans = 0;\n        vector<int> data(N, INF);\n        vector<bool> done(N);\n        done[s] = true;\n        \n        bool updated = true;\n        while(updated){\n            updated = false;\n            for(int v=0; v<N; v++) if(!done[v]){\n                vector<int> odata = data;\n                for(auto e: G[v]) if(done[e.to]){\n                    data[e.to] = min(data[e.to], e.w);\n                    data[v] = min(data[v], e.w);\n                }\n                int sum = 0;\n                for(int i=0; i<N; i++) if(data[i] != INF)\n                    sum += data[i];\n                if(tans < sum){\n                    tans = sum;\n                    done[v] = true;\n                    updated = true;\n                }else{\n                    data = odata;\n                }\n            }\n        }\n        ans = max(ans, tans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n \nusing namespace std;\n \nint dfs(const vector<vector<pair<int, int> > > &v, int idx, vector<int> &used, int needs) {\n    int ans = 0;\n \n    for(int i = idx; i < v.size(); ++i) {\n        int used_cnt = 0;\n        for(int j = 0; j < v[i].size(); ++j) {\n            if(used[v[i][j].first]) {\n                ++used_cnt;\n            }\n        }\n        if(used_cnt != needs) continue;\n \n        used[i] = 1;\n        int score = 0;\n        for(int k = 0; k < used.size(); ++k) {\n            if(!used[k]) continue;\n            int sat = 10000000;\n            for(int l = 0; l < v[k].size(); ++l) {\n                if(used[v[k][l].first]) sat = min(sat, v[k][l].second);\n            }\n            if(sat == 10000000) sat = 0;\n            score += sat;\n            //cout << k << ' ';\n        }\n        //cout << ':' << score << endl;\n        ans = max(ans, score);\n        ans = max(ans, dfs(v, i+1, used, needs+1));\n        used[i] = 0;\n    }\n \n    return ans;\n}\n \nint main() {\n    int N, M;\n    cin >> N >> M;\n \n    vector<vector<pair<int, int> > > friends(N);\n    for(int i = 0; i < M; ++i) {\n        int u, v, f;\n        cin >> u >> v >> f;\n        --u; --v;\n        friends[u].push_back(make_pair(v, f));\n        friends[v].push_back(make_pair(u, f));\n    }\n \n    vector<int> tmp(N, 0);\n    cout << dfs(friends, 0, tmp, 0) << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100\n#define INF (1<<29)\n \nint N, cost[MAX][MAX];\n \nint get_sat(set<int> &inv)\n{\n    int sat = 0;\n    for (auto &i: inv) {\n        int s = INF;\n        for (auto &j: inv) {\n            if (i == j) continue;\n            s = min(s, cost[i][j]);\n        }\n        sat += s;\n    }\n    return sat;\n}\n \nmap<set<int>, int> memo;\n \nint dfs(set<int> inv)\n{\n    int res = 0;\n    if (memo.count(inv) > 0) {\n        return memo[inv];\n    }\n         \n    if (inv.size() >= 2) {\n        res = get_sat(inv);\n    }\n    for (int i = 0; i < N; i++) {\n        bool ok = 1;\n        for (auto &j: inv) {\n            if (cost[i][j] == 0) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok) {\n            set<int> ninv = inv;\n            ninv.insert(i);\n            res = max(res, dfs(ninv));\n        }            \n    }\n    return (memo[inv] = res);\n}\n \nint main()\n{\n    int M, a, b, c;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> c;\n        a--; b--;\n        cost[a][b] = cost[b][a] = c;\n    }    \n    cout << dfs(set<int>()) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nvvll g;\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    g = vvll(n, vll(n)); rep(i, n) g[i][i] = INF;\n\n    rep(i, m) {\n        ll u, v, f; cin >> u >> v >> f; u--, v--;\n        g[u][v] = g[v][u] = f;\n    }\n\n    vll vs;\n    function<ll(vll&)> f = [&](vll& vs) {\n        ll ret = 0;\n        rep(i, vs.size()) {\n            ll min_f = INF;\n            rep(j, vs.size()) \n                chmin(min_f, g[vs[i]][vs[j]]);\n            ret += min_f != INF ? min_f : 0;\n        }\n        repi(i, vs.size() ? vs.back()+1 : 0, n) {\n            vs.pb(i);\n            chmax(ret, f(vs));\n            vs.pop_back();\n        }\n        return ret;\n    };\n    cout << f(vs) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nvint G[111];\nint D[111][111];\n\n\nint calc(vint vs){\n\tint n=vs.size();\n\tint ans=0;\n\trep(i,1<<n){\n\t\tif(__builtin_popcount(i)<=1)continue;\n\t\tint score=0;\n\t\trep(j,n)if(i>>j&1){\n\t\t\tint f=1001001001;\n\t\t\trep(k,n)if((i>>k&1)&&j!=k)chmin(f,D[vs[j]][vs[k]]);\n\t\t\tscore+=f;\n\t\t}\n\t\tchmax(ans,score);\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tG[a].pb(b);G[b].pb(a);\n\t\tD[a][b]=D[b][a]=c;\n\t}\n\n\tvint big;\n\n\tint ans=0;\n\n\trep(i,N){\n\t\tif(G[i].size()<12){\n\t\t\tvector<int>lis=G[i];\n\t\t\tlis.pb(i);\n\t\t\tchmax(ans,calc(lis));\n\t\t}\n\t\telse{\n\t\t\tbig.pb(i);\n\t\t}\n\t}\n\tchmax(ans,calc(big));\n\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<int> deg(N, 0);                           // 次数\n    vector<vector<int>> cost(N, vector<int>(N, 0));  // 隣接行列\n    for (int i = 0; i < M; ++i) {\n        int u, v, f;\n        cin >> u >> v >> f;\n        --u, --v;\n        cost[u][v] = cost[v][u] = f;\n        ++deg[u], ++deg[v];\n    }\n\n    int ans = 0;\n    for (int d = 2; d * (d - 1) / 2 <= M; ++d) {\n        // 頂点数dのクリークを全列挙\n        vector<int> vs;\n        for (int v = 0; v < N; ++v) {\n            if (deg[v] >= d - 1) vs.push_back(v);\n        }\n\n        int K = vs.size();\n        if (K < d) continue;\n\n        vector<bool> pat(K, false);\n        for (int i = 0; i < d; ++i) pat[K - i - 1] = true;\n\n        // 要素数dの部分集合をnext_permutationで全列挙\n        do {\n            int sum = 0;\n            for (int i = 0; i < K; ++i) {\n                if (!pat[i]) continue;\n\n                int mi = INF;\n                for (int j = 0; j < K; ++j) {\n                    if (i == j || !pat[j]) continue;\n                    mi = min(mi, cost[vs[i]][vs[j]]);\n                }\n                sum += mi;\n            }\n            ans = max(ans, sum);\n        } while (next_permutation(pat.begin(), pat.end()));\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass RelationShip{\npublic:\n  int _to;\n  int _friendliness;\n  RelationShip(int to,int friendliness) :\n    _to(to), _friendliness(friendliness) {}\n  bool operator<(const RelationShip &r) const {\n    return _friendliness < r._friendliness;\n  }\n  bool operator>(const RelationShip &r) const {\n    return _friendliness > r._friendliness;\n  }\n};\n\n\nbool used[101];\nvector<RelationShip> edges[101];\nint idx[101][101];\nint total_rabbits;\nint total_pairs;\n\nint dfs(int last){\n  int res = 0;\n\n  int sum = 0;\n  for(int orig=0; orig <= last; orig++){\n    if(!used[orig]) continue;\n\n    int tmp = INF;\n    for(int next_i = 0; next_i < edges[orig].size(); next_i++){\n      int next = edges[orig][next_i]._to;\n      if(!used[next]) continue;\n      tmp = min(tmp,edges[orig][next_i]._friendliness);\n    }\n    if(tmp != INF) sum += tmp;\n  }\n  \n  res = max(sum,res);\n\n  for(int next=last + 1; next < total_rabbits; next++){\n    for(int prev = 0; prev <= last; prev++){\n      if(!used[prev] && idx[prev][next] == -1) continue;\n      used[next] = true;\n      res = max(res,dfs(next));\n      used[next] = false;\n    }\n  }\n  \n  return res;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_rabbits,&total_pairs)){\n    for(int i=0;i<total_rabbits;i++){\n      edges[i].clear();\n    }\n    memset(used,false,sizeof(used));   \n    memset(idx,-1,sizeof(idx));\n\n    for(int pair_i = 0; pair_i < total_pairs; pair_i++){\n      int from,to,friendliness;\n      scanf(\"%d %d %d\",&from,&to,&friendliness);\n      from--; to--;\n      edges[from].push_back(RelationShip(to,friendliness));\n      edges[to].push_back(RelationShip(from,friendliness));\n      idx[from][to] = edges[from].size() - 1;\n      idx[to][from] = edges[to].size() - 1;\n    }\n\n    cout << dfs(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nvector<P> idx;\n\nset<vector<int> > memo;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n  sort(G.begin(),G.end());\n  \n  if(memo.count(G)) return ;\n  memo.insert(G);\n  \n  if(x*(x-1)>m*m) return ;\n  \n  for(int i=0;i<n;i++){\n\n    if(used[idx[i].S]) continue;\n\n    used[idx[i].S]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(idx[i].S);\n    \n    for(int j=0;j<nG.size();j++)\n      \n      if(idx[i].S!=nG[j]&&used[nG[j]])\n\tmincost=min(mincost,d[idx[i].S][nG[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n    \n    used[idx[i].S]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<n;i++) idx.push_back(P(0,i));\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n    idx[a-1].first++;\n    idx[b-1].first++;\n  }\n\n  sort(idx.begin(),idx.end());\n  \n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    int tmp = [&]()mutable->int{\n      int ret = 0;\n      int mincost[node];\n      rep(i,node) mincost[i] = IINF;\n      //for(int& i : mincost)i = IINF;\n      for(int i=0;i<node;i++){\n\tfor(int j=i+1;j<node;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      rep(i,node) ret += mincost[i]; \n      return ret;\n    }();\n\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  int test[5];\n  for(int& i : test)i = IINF;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint n, m;\nset<vector<int> > ho, ge;\nset<vector<int> >::iterator it;\nint ans = 0;\nbool saw[100];\nint ed[100][100];\n\nint main(){\n    cin >> n >> m;\n    rep(i,m){\n        int f, t, c;\n        cin >> f >> t >> c;\n        f--; t--;\n        if(f > t) swap(f,t);\n        ed[f][t] = c; ed[t][f] = c;\n        vector<int> tmp;\n        tmp.push_back(f); tmp.push_back(t);\n        ho.insert(tmp);\n        ans = max(ans,c*2);\n    }\n    while(true){\n        ge.clear();\n        for(it = ho.begin(); it != ho.end(); it++){\n            vector<int> tmp = (*it);\n            memset(saw,0,sizeof(saw));\n            rep(i,tmp.size()) saw[tmp[i]] = true;\n            rep(i,n){\n                if(saw[i]) continue;\n                bool ok = true;\n                rep(j,tmp.size()){\n                    if(ed[i][tmp[j]] == 0){\n                        ok = false;\n                        break;\n                    }\n                }\n                if(!ok) continue;\n                vector<int> foge = tmp;\n                foge.push_back(i);\n                sort(foge.begin(),foge.end());\n                ge.insert(foge);\n                int cnt = 0;\n                rep(j,foge.size()){\n                    int mi = INF;\n                    rep(k,foge.size()){\n                        if(j == k) continue;\n                        mi = min(mi,ed[foge[j]][foge[k]]);\n                    }\n                    cnt += mi;\n                }\n                ans = max(ans,cnt);\n            }\n        }\n        ho = ge;\n        if(ge.size() == 0) break;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nint n,m;\nint g[110][110], deg[110];\nvector<int> V, use;\n\nint rec(int d, int k){\n  if(k==0){\n    int res = 0;\n    for(int a : use){\n      int v = 1e9;\n      for(int b: use){\n\tif(a!=b)v = min(v, g[a][b]);\n      }\n      res += v;\n    }\n    return res;\n  }\n  if(d==V.size())return 0;\n\n  int res = rec(d+1,k);\n  if(k){\n    for(int a : use){\n      if(!g[a][V[d]])return res;\n    }\n\n    use.push_back(V[d]);\n    res = max(res, rec(d+1,k-1));\n    use.pop_back();\n  }\n  return res;\n}\n\nint cal(int k){\n  V.clear();\n  rep(i,n){\n    if(deg[i]>=k-1)V.push_back(i);\n  }\n  return rec(0,k);\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i,m){\n    int a,b,c;\n    cin >> a >> b >> c; a--; b--;\n    g[a][b] = g[b][a] = c;\n    deg[a]++; deg[b]++;\n  }\n\n  int res = 0;\n  for(int k=2;k*(k-1)/2<=m;k++)res = max(res, cal(k));\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\ntemplate <unsigned T>\nbool prevSubset(bitset<T>& bs, const bitset<T>& mask)\n{\n    if(bs.none())\n        return false;\n    bs = bs.to_ulong() - 1ull;\n    bs &= mask;\n    return true;\n}\n\n\nint n;\nvector<vector<int> > edges;\nvector<bitset<100> > isEdges;\n\nint solve(bitset<100> bs, int i)\n{\n\tint ret = 0;\n\tfor(int j=i; j<n; ++j){\n\t\tif((bs & isEdges[j]) == bs){\n\t\t\tbs[j] = true;\n\t\t\tret = max(ret, solve(bs, j+1));\n\t\t\tbs[j] = false;\n\t\t}\n\t}\n\n\tif(bs.count() <= 1)\n\t\treturn ret;\n\n\tint tmp1 = 0;\n\tfor(int i=0; i<n; ++i){\n\t\tif(!bs[i])\n\t\t\tcontinue;\n\t\tint tmp2 = INT_MAX;\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(bs[j] && j != i)\n\t\t\t\ttmp2 = min(tmp2, edges[i][j]);\n\t\t}\n\t\ttmp1 += tmp2;\n\t}\n\n\treturn max(ret, tmp1);\n}\n\nint main()\n{\n\tint m;\n\tcin >> n >> m;\n\tedges.assign(n, vector<int>(n, 0));\n\tisEdges.assign(n, 0);\n\n\tfor(int i=0; i<m; ++i){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t-- a;\n\t\t-- b;\n\t\tedges[a][b] = edges[b][a] = c;\n\t\tisEdges[a][b] = isEdges[b][a] = true;\n\t}\n\n\tcout << solve(0, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2306>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nvoid dfs(ll n,vector<ll>& use,vector<vector<ll>>& cost,ll& res){\n    size_t size = use.size();\n    if(size >= 2){\n        ll sum = 0;\n        for(int i = 0; i < size;i++){\n            ll minc = INF;\n            for(int j = 0; j < size;j++){\n                if(i == j) continue;\n                minc = min(minc,cost[use[i]][use[j]]);\n            }\n            sum += minc;\n        }\n        res = max(res,sum);\n    }\n    \n    for(ll next = n + 1; next < cost[0].size(); next++){\n        [&]{\n            for(int i = 0; i < size;i++){\n                if(cost[next][use[i]] == 0) return;\n            }\n            use.push_back(next);\n            dfs(next,use,cost,res);\n            use.pop_back();\n        }();\n    }\n}\nll solve(){\n    ll res = 0;\n    ll n,m; cin >> n >> m;\n    vector<ll> u(m),v(m),f(m);\n    for(int i = 0; i < m;i++){\n        cin >> u[i] >> v[i] >> f[i];\n        u[i]--; v[i]--;\n    }\n    vector<vector<ll>> cost(n,vector<ll>(n,0));\n    //for(int i = 0; i < n;i++) cost[i][i] = LINF;\n    for(int i = 0;i < m;i++){\n        cost[u[i]][v[i]] = cost[v[i]][u[i]] = f[i];\n    }\n    vector<ll> use;\n    for(int i = 0; i < n;i++){\n        use.clear();\n        use.push_back(i);\n        dfs(i,use,cost,res);\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdlib.h>\n#include <time.h>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include <limits.h>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<bitset>\nusing namespace std;\n\n\n#define LL long long\n\n//?自己加油O(∩_∩)O~\n\nconst long long  mod =1000000007;  //?个必?是?数\nint q[111][111];\nbitset<102> w[111];\nbitset<102> duilie[4200000];\nint haha[4200000];\nint n,m;\nint ans=0;\nmap<string,bool> vis;\nvoid BFS()\n{\n    for (int j=0;j<n;j++) duilie[j][j]=1;\n    int fron=0,rear=n;\n    while (fron<rear){\n        ans=max(ans,haha[fron]);\n        vector<int> v;\n        v.clear();\n        for (int j=0;j<n;j++) if (duilie[fron][j]) v.push_back(j);\n        for (int j=0;j<n;j++){\n            if ((w[j]&duilie[fron])==duilie[fron]){\n                duilie[rear]=duilie[fron];\n                string z=\"\";\n                for (int k=0;k<n;k++){\n                    char hh;\n                    if (duilie[fron][k] || k==j) hh='1';else hh='0';\n                    z+=hh;\n                }\n                if (vis[z]) continue;\n                vis[z]=1;\n                haha[rear]=0;\n                v.push_back(j);\n                for (int k=0;k<v.size();k++){\n                    int g=2100000000;\n                    for (int l=0;l<v.size();l++){\n                        if (k==l) continue;\n                        g=min(g,q[v[k]][v[l]]);\n                    }\n                    haha[rear]+=g;\n                }\n                duilie[rear++][j]=1;\n            }\n        }\n        fron++;\n    }\n}\nint main()\n{\n\n    scanf(\"%d%d\",&n,&m);\n    for (int j=0;j<m;j++){\n        int g,h,f;\n        scanf(\"%d%d%d\",&g,&h,&f);\n        g--;h--;\n        q[g][h]=f;q[h][g]=f;\n    }\n    for (int j=0;j<n;j++){\n        for (int k=0;k<n;k++){\n            if (q[j][k]) {\n                w[j][k]=1;\n                w[k][j]=1;\n            }\n        }\n    }\n    BFS();\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define ECH(it, A) for (__typeof(A.begin()) it = A.begin(); it != A.end(); ++it)\n#define RST(A) memset(A, 0, sizeof(A))\n#define FLC(A, x) memset(A, x, sizeof(A))\n#define PB push_back\n\ntemplate<class T> void checkMin(T &a, T b){if (b < a) a = b;}\ntemplate<class T> void checkMax(T &a, T b){if (b > a) a = b;}\n\ntypedef double DB;\ntypedef vector<int> VI;\nconst int INF = 0x3f3f3f3f;\n\nconst int N = int(1e2) + 9, NN = 16;\nint G[N][N];\nint n;\n\nint Aid[NN], A[NN], An, ans;\n\n\nvoid dfs(){\n\n    if (An > 1){\n        int cur = 0; REP(i, An) cur += A[i]; checkMax(ans, cur);\n    }\n\n    int AA[NN]; REP(i, An) AA[i] = A[i];\n    int st = An ? Aid[An-1]+1 : 0;\n\n    FOR(v, st, n){\n\n        bool ok = true; A[An] = INF; REP(i, An){\n            int u = Aid[i];\n            if (!G[u][v]){\n                ok = false;\n                break;\n            }\n            checkMin(A[i], G[u][v]);\n            checkMin(A[An], G[u][v]);\n        }\n\n        if (!ok) continue;\n        Aid[An] = v; ++An; dfs(); --An;\n        REP(i, An) A[i] = AA[i];\n    }\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    int m; while (~scanf(\"%d%d\", &n, &m)){\n\n        RST(G); DO(m){\n            int u, v, w; scanf(\"%d%d%d\", &u, &v, &w); --u, --v;\n            G[u][v] = G[v][u] = w;\n        }\n\n        ans = 0; dfs();\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nint g[105][105];\n\nint solve(int n, vector<bool> d){\n\tint res = 0;\n\t//for(auto i : d){ cout << i << ' '; } cout << endl;\n\trep(i,n){\n\t\tif(d[i]) continue;\n\t\tint mini = INF;\n\t\trep(j,n){\n\t\t\tif(d[j]) continue;\n\t\t\tif(i == j) continue;\n\t\t\tmini = min(mini, g[i][j]);\n\t\t}\n\t\tres += mini;\n\t}\n\t//show(res)\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> v;\n\tint s = 0;\n\trep(i,m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a][b] = g[b][a] = c;\n\t\ts += c;\n\t}\n\n\tif(n == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<bool> d(n,0);\n\tint ans = solve(n,d);\n\trep(i,n - 2){\n\t\tint maxi = 0, p;\n\t\trep(j,n){\n\t\t\tif(d[j]) continue;\n\t\t\td[j] = true;\n\n\t\t\tint tmp = solve(n,d);\n\t\t\t//show(tmp)\n\t\t\tif(maxi < tmp){\n\t\t\t\tmaxi = tmp;\n\t\t\t\tp = j;\n\t\t\t}\n\t\t\td[j] = false;\n\t\t}\n\t\t//show(maxi)\n\t\tif(ans < maxi){\n\t\t\tans = maxi;\n\t\t\td[p] = true;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int>e[100],v;\nint n,s[100][100],res;\nvoid F()\n{\n\tint i,j,t,c;\n\tif(v.size()>1)\n\t{\n\t\tfor(c=i=0;i<v.size();++i)\n\t\t{\n\t\t\tt=INT_MAX;\n\t\t\tfor(j=0;j<v.size();++j)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tt=min(t,s[v[i]][v[j]]);\n\t\t\t}\n\t\t\tc+=t;\n\t\t}\n\t\tres=max(res,c);\n\t}\n\tif(v.size())\n\t{\n\t\tfor(i=v[0]+1;i<n;++i)\n\t\t{\n\t\t\tfor(j=1;j<v.size();++j)\n\t\t\t\tif(find(e[v[j]].begin(),e[v[j]].end(),i)==e[v[j]].end())\n\t\t\t\t\tgoto N;\n\t\t\tv.push_back(i);\n\t\t\tF();\n\t\t\tv.pop_back();\n\t\t\tN:;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tF();\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\nint main()\n{\n\tint m,a,b,f;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&f);\n\t\t--a,--b;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t\ts[a][b]=s[b][a]=f;\n\t}\n\tF();\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint ans,n,m,g[110][110],f[110],l;\nbool chk(int x){\n    for(int i=0;i<l;i++)\n        if(!g[x][f[i]]) return false;\n    return true;\n}\nvoid updata(){\n    int tmp=0;\n    for(int i=0;i<l;i++){\n        int tmp2=0;\n        for(int j=0;j<l;j++)if(i!=j){\n            if(tmp2==0 || g[f[i]][f[j]]<tmp2)\n                tmp2=g[f[i]][f[j]];\n        }\n        tmp+=tmp2;\n    }\n    if(tmp > ans)\n        ans=tmp;\n}\nvoid dfs(int x){\n    f[l++]=x;\n    updata();\n    for(int i=x+1;i<=n;i++)\n        if(chk(i)){\n            dfs(i);\n        }\n    --l;\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m)){\n        memset(g,0,sizeof(g));\n        for(int i=0;i<m;i++){\n            int x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            g[x][y]=g[y][x]=z;\n        }\n        ans=0;\n        for(int i=1;i<=n;i++){\n            l=0;\n            dfs(i);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n\n#define INF (1LL<<62)\n\nusing namespace std;\n\ntypedef long long ll;\n\nll g[101][101],n,m;\n\nll rec(set<int> S,int mx){\n  \n  if(mx<0)return 0;\n\n  ll res=0;\n  set<int>::iterator it=S.begin();\n  for(;it!=S.end();it++){\n    set<int>::iterator j=S.begin();\n    ll t=INF;\n    for(;j!=S.end();j++){\n      if(it==j)continue;\n      t=min(t,g[*it][*j]);\n    }\n    res+=t;\n  }\n  \n  if(mx>=n-1)return res;\n\n  int id=-1;\n  ll cost=0;\n  for(int v=mx+1;v<n;v++){\n    if(S.count(v))continue;\n\n    bool fg=true;\n    set<int>::iterator it=S.begin();\n    for(;it!=S.end();it++){\n      fg&=(g[v][*it]<INF);\n    }\n    if(!fg)continue;\n\n    ll tmp=INF;\n    it=S.begin();\n    for(;it!=S.end();it++){\n      tmp=min(tmp,g[v][*it]);\n    }\n    if(cost<tmp)cost=tmp,id=v;\n  }\n  \n  S.insert(id);\n\n  return max(rec(S,id),res);\n}\n\nint main(void){\n\n  fill(g[0],g[101],INF);\n  //for(int i=0;i<101;i++)g[i][i]=0;\n\n  cin >> n >> m;\n\n  for(int i=0;i<m;i++){\n    ll a,b,f;\n    cin >> a >> b >>f;\n    g[a-1][b-1]=g[b-1][a-1]=f;\n  }\n  \n  ll ans=0;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(g[i][j]<INF){\n\tset<int>S;\n\tS.insert(i);\n\tS.insert(j);\n\tans=max(ans,rec(S,max(i,j)));\n      }\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 50)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D, long long int idx){\n\tlong long int ret = 0;\n\tfor(int i = idx; i < N; i++){\n\t\tauto next = D;\n\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i!=j && D[j] != -1){\n\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t}\n\t\t}\n\t\tlong long int plus = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tlong long int x = D[j];\n\t\t\tlong long int y = next[j];\n\t\t\tif(x == -1)x = 0;\n\t\t\tif(y == -1)y = 0;\n\t\t\tplus += x - y;\n\t\t}\n\t\tif(plus >= 0){\n\t\t\tret = max(ret, solve(D, i + 1));\n\t\t}\n\t\tD = next;\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x, 0));\n\t\tbridge[bridgepair[i].first][bridgepair[i].second] = -inf;\n//\t\tbridge[bridgepair[i].second][bridgepair[i].first] = -inf;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0, lp_num_##_i = (int)(n); i < lp_num_##_i; ++i)\n#define FORE(x, a) for (auto &x : a)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n\ntemplate <class T, class U>\nbool chmax(T &a, const U &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <class T, class U>\nbool chmin(T &a, const U &b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate <class T, class U>\nbool contains(const T &cont, const U &elem) {\n\treturn cont.find(elem) != cont.end();\n}\n\nint N, M;\nint ans;\nint f[110][110];\n\nvector<int> V;\nvoid rec() {\n\tif (SZ(V) > 1) {\n\t\tint tmp = 0;\n\t\tREP(i, SZ(V)) {\n\t\t\tint friendliness = 1e9;\n\t\t\tREP(j, SZ(V)) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tchmin(friendliness, f[V[i]][V[j]]);\n\t\t\t}\n\t\t\ttmp += friendliness;\n\t\t}\n\t\tchmax(ans, tmp);\n\t}\n\n\tfor (int i = V.back() + 1; i < N; i++) {\n\t\tbool ok = true;\n\t\tREP(j, SZ(V)) {\n\t\t\tif (f[i][V[j]] == 0) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) continue;\n\n\t\tV.push_back(i);\n\t\trec();\n\t\tV.pop_back();\n\t}\n}\n\nsigned main() {\n\tcin >> N >> M;\n\tREP(i, M) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tf[a][b] = f[b][a] = c;\n\t}\n\n\tans = 0;\n\tREP(i, N) {\n\t\tV.push_back(i);\n\t\trec();\n\t\tV.pop_back();\n\t}\n\tcout << ans << endl;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint n,m;\nint a[110][110];\n\nint calc(vector<int> &v) {\n  int res = 0;\n  for (int i = 0; i < v.size(); i++) {\n    int add = INF;\n    for (int j = 0; j < v.size(); j++) {\n      if (j == i) continue;\n      CHMIN(add,a[v[i]][v[j]]);\n    }\n    res += add;\n  }\n  return res;\n}\n\nvoid dfs(vector<int> &v, int &ans) {\n  if (v.size() > 1) CHMAX(ans,calc(v));\n  for (int i = v.back()+1; i < n; i++) {\n    bool ok = true;\n    for (int j = 0; j < v.size(); j++) {\n      if (a[v[j]][i] == 0) ok = false;\n    }\n    if (ok) {\n      v.push_back(i);\n      dfs(v,ans);\n      v.pop_back();\n    }\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> n >> m;\n  REP(i,m) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--; y--;\n    a[x][y] = a[y][x] = z;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    vector<int> v;\n    v.push_back(i);\n    dfs(v,ans);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint f[111][111];\n\nint rec(int p, vector<int> &used){\n    int res = 0;\n    for(int u : used){\n        int min_f = 1e9;\n        for(int v : used){\n            if(u == v) continue;\n            min_f = min(min_f, f[u][v]);\n            assert(f[u][v] > 0);\n        }\n        if(min_f == 1e9) min_f = 0;\n        res += min_f;\n    }\n    for(int i = p; i < n; ++i){\n        int min_f = 1e9;\n        for(int v : used){\n            min_f = min(min_f, f[i][v]);\n        }\n        if(min_f == 0) continue;\n        used.push_back(i);\n        res = max(res, rec(i+1, used));\n        used.pop_back();\n    }\n    return res;\n}\n\nint main(){\n    cin >> n >> m;\n    for(int i = 0; i < m; ++i){\n        int u,v,f_;\n        cin >> u >> v >> f_;\n        --u; --v;\n        f[u][v] = f[v][u] = f_;\n    }\n    vector<int> used;\n    cout << rec(0,used) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sat[100];\nbool used[100];\nvector<P> G[100]; //to, f\nint N,M;\nvector<array<int, 3>> E;\n\nint greedy(int ret){\n    int n = 2;\n    while(true){\n        int best_v=-1, best_score=ret, best_s=0;\n        for(int i=0;i<N;i++){\n            int cnt=0,s=10000000;\n            int score=0;\n            if(used[i]) continue;\n            for(auto e:G[i]){\n                int to = e.first, f = e.second;\n                if(!used[to]) continue;\n                cnt++;\n                score += min(sat[to], f);\n                s = min(f,s);                \n            }\n            if(cnt!=n) s=0;\n            score += s;\n            if(score>best_score){\n                best_v = i;\n                best_score = score;\n                best_s = s;\n            }\n        }\n        if(best_v==-1){\n            return ret;\n        }else{\n            ret = best_score;\n            used[best_v]=true;\n            sat[best_v]=best_s;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].emplace_back(b,c);\n        G[b].emplace_back(a,c);\n        E.push_back(array<int, 3>{a,b,c});\n    }\n    int ans=0;\n    for(auto e:E){\n        fill(used,used+100,false);\n        fill(sat,sat+100,0);\n        used[e[0]]=used[e[1]]=true;\n        sat[e[0]]=sat[e[1]]=e[2];\n        \n        ans = max(ans,greedy(2*e[2]));\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl;\n#define CNO cout<<\"No\"<<endl;\n\ntypedef long long LL;\ntypedef long double LD;\n\nint n,m;\nvector<vector<int>> e;\n\nint ans=0;\nvoid dfs(int x, vector<pair<int,int>> &v){\n  vector<pair<int,int>> w = v;\n  int k = w.size();\n  repp(i, x+1, n){\n    int mi=IINF;\n    w=v;\n    rep(j,k){\n      mi=min(mi,e[i][w[j].first]);\n      w[j].second=min(w[j].second,e[i][w[j].first]);\n      if(mi==0) break;\n    }\n    if(mi>0){\n      int tmp=mi;\n      rep(j,k){\n        tmp+=w[j].second;\n      }\n      ans=max(ans,tmp);\n      w.push_back({i,mi});\n      dfs(i,w);\n    }\n  }\n}\n\nint main(){\n  cin >> n >> m;\n  int u,v,c;\n  e=vector<vector<int>>(n,vector<int>(n,0));\n  rep(i,m){\n    cin >> u >> v >> c;\n    u--,v--;\n    e[u][v]=c;\n    e[v][u]=c;\n  }\n  vector<pair<int,int>> aa(1,{0,IINF});\n  rep(i,n){\n    aa[0].first=i;\n    dfs(i,aa);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nll a[111][111];\nll ans;\nint n;\n\nvoid dfs(vector<int>& v){\n    int m=v.size();\n    ll ret=0;\n    rep(i,m){\n        ll res=inf;\n        rep(j,m){\n            if(i==j)continue;\n            res=min(res,a[v[i]][v[j]]);\n        }\n        ret+=res;\n    }\n    if(m==1)ret=0;\n    ans=max(ans,ret);\n    REP(i,v[m-1]+1,n){\n        bool ok=true;\n        rep(j,m)if(a[v[j]][i]==0)ok=false;\n        if(!ok)continue;\n        v.push_back(i);\n        dfs(v);\n        v.pop_back();\n    }\n}\nint main(){\n    cin>>n;\n    int m;\n    cin>>m;\n    rep(i,m){\n        int x,y,z;\n        cin>>x>>y>>z;\n        --x;--y;\n        a[x][y]=a[y][x]=z;\n    }\n    rep(i,n){\n        vector<int> v(1,i);\n        dfs(v);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 50)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D, long long int idx){\n\tlong long int ret = 0;\n\tfor(int i = idx; i < N; i++){\n\t\tauto next = D;\n\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i!=j && D[j] != -1){\n\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t}\n\t\t}\n\t\tlong long int plus = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tlong long int x = D[j];\n\t\t\tlong long int y = next[j];\n\t\t\tif(x == -1)x = 0;\n\t\t\tif(y == -1)y = 0;\n\t\t\tplus += x - y;\n\t\t}\n\t\tif(plus >= 0){\n\t\t\tret = max(ret, solve(D, i + 1));\n\t\t}\n\t\tD = next;\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x, 0));\n//\t\tbridge[bridgepair[i].first][bridgepair[i].second] = -inf;\n//\t\tbridge[bridgepair[i].second][bridgepair[i].first] = -inf;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint c[109][109], n, m, p, q, r, maxn;\n\nvoid dfs(vector<int>vec) {\n\tif (vec.size() >= 2) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint minx = 1000009;\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tminx = min(minx, c[vec[i]][vec[j]]);\n\t\t\t\tif (minx == 0) return;\n\t\t\t}\n\t\t\tsum += minx;\n\t\t}\n\t\tmaxn = max(maxn, sum);\n\t}\n\tint T = 1; if (vec.size() >= 1) T = vec[vec.size() - 1] + 1;\n\tfor (int i = T; i <= n; i++) {\n\t\tvector<int>F = vec; F.push_back(i);\n\t\tdfs(F);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> p >> q >> r;\n\t\tc[p][q] = r; c[q][p] = r;\n\t}\n\tdfs(vector<int>{});\n\tcout << maxn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint main(){\n\tint N,M;\n\tcin >> N >> M;\n\tvector<vector<pair<long long int, long long int>>>bridge(N);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a].push_back(make_pair(b, c));\n\t\tbridge[b].push_back(make_pair(a, c));\n\t}\n\tlong long int ans = 0;\n\tfor(int bp = 0; bp < N; bp++){\n\t\tvector<long long int>D(N, 0);\n\t\tset<long long int>group;\n\t\tgroup.insert(bp);\n\n\t\twhile(true){\n\t\t\tlong long int plusscore = 0, pointidx = -1, plusnum = 0;\n\t\t\tfor(int one = 0; one < N; one++){\n\t\t\t\tif(!group.count(one)){\n\t\t\t\t\tlong long int scorememo = 0, minval = inf;\n\t\t\t\t\tfor(auto x: bridge[one]){\n\t\t\t\t\t\tif(group.count(x.first)){\n\t\t\t\t\t\t\tif(x.second < D[x.first]){\n\t\t\t\t\t\t\t\tscorememo += D[x.first] - x.second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tminval = min(x.second, minval);\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t\tif(minval - scorememo > plusscore && inf != minval){\n\t\t\t\t\t\tpointidx = one;\n\t\t\t\t\t\tplusscore = minval - scorememo;\n\t\t\t\t\t\tplusnum = minval;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pointidx == -1)break;\n\n\t\t\tD[pointidx] = plusnum;\n\t\t\tgroup.insert(pointidx);\n\t\t\tfor(auto x: bridge[pointidx]){\n\t\t\t\tif(group.count(x.first)){ \n\t\t\t\t\tif(x.second < D[x.first]){\n\t\t\t\t\t\tD[x.first] = x.second;\n\t\t\t\t\t}\n\t\t\t\t\tif(x.first == bp){\n\t\t\t\t\t\tif(D[bp] == 0){\n\t\t\t\t\t\t\tD[bp] = x.second;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tD[bp] = min(x.second, D[bp]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ansmemo = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tansmemo += D[i];\n//\t\t\tcout<<D[i]<< \" \";\n\t\t}\n\t\tans = max(ans, ansmemo);\n//\t\tcout << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n,m;\nint f[105][105];\nint a[20],res;\nint d[20];\nvoid calc(int n)\n{\n \t    int c=0,cc;\n      for(int i=1;i<=n;i++)\t \n \t    {\n\t\t\t \tcc=100000000;\t\t\t\n \t      for(int j=1;j<=n;j++)\n \t      if(i!=j)cc=min(cc,f[a[i]][a[j]]);\n \t      c+=cc;\n      }\n      res=max(res,c);\n}\nvoid dfs(int k)\n{\n \t    if(k!=1)calc(k);\n\t\t\tfor(int i=a[k-1]+1;i<=n;i++)  \t \n\t\t\t{\n\t\t\t \t\tbool flag=true;\n\t\t\t \t\n\t\t\t\t\tfor(int j=1;j<k&&flag;j++) \t\t\n\t\t\t\t\t{\n \t\t\t\t    if(f[i][a[j]]==0)flag=false;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\ta[k]=i;\n\t\t\t    if(flag)dfs(k+1);\t\t\t\t \n\t\t  }\n} \nint main()\n{\n            int a,b,c;\n      scanf(\"%d%d\",&n,&m);\n\t\t\tres=0;\n\t\t\tfor(int i=1;i<=m;i++) \n\t\t\t{\n\t\t\t   scanf(\"%d%d%d\",&a,&b,&c);\n         f[a][b]=f[b][a]=c;\n         res=max(res,2*c);\n\t\t\t}\n\t\t\t::a[0]=0;\n      dfs(1);\n      cout<<res;\n      return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <set>\n#include <string>\n#define PB push_back\n#define FT first\n#define SD second\n#define MP make_pair\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int>  P;\nconst int N=105,MOD=7+1e9;\nint a[20],G[N][N];\nint n,m,ans,cnt;\nint solve()\n{\n    if(cnt<2) return 0;\n    int res=0;\n    for(int i=0;i<cnt;i++){\n        int _min = INF;\n        for(int j=0;j<cnt;j++) {\n            if(i==j) continue;\n            _min = min(_min,G[a[i]][a[j]]);\n        }\n        res += _min;\n    }\n    return res;\n}\nvoid dfs(int u)\n{\n    ans = max(ans,solve());\n    for(int i=u;i<=n;i++){\n        bool fg=1;\n        for(int j=0;j<cnt;j++){\n            int v=a[j];\n            if(G[i][v]==0) {\n                fg=0;\n                break;\n            }\n        }\n        if(fg) {\n            a[cnt++]=i;\n            dfs(i+1);\n            cnt--;\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    ans=0;\n    for(int i=0;i<m;i++){\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        G[u][v]=G[v][u]=w;\n        ans = max(ans,w*2);\n    }\n    dfs(1);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <map>\n#define INF 100000000\nusing namespace std;\n\nint n,m;\nint edge[101][101];\nint cnt[101];\nint num[101];\nint res=0;\n\nvoid dfs(int v,int depth){\n\tnum[depth]=v;\n\tint cntmin=15;\n\tfor(int i=0;i<=depth;i++){\n\t\tcntmin=min(cntmin,cnt[num[i]]);\n\t}\n\tint score=0;\n\tfor(int i=0;i<=depth;i++){\n\t\tint mini=INF;\n\t\tfor(int j=0;j<=depth;j++){\n\t\t\tif(i==j)continue;\n\t\t\tmini=min(mini,edge[num[i]][num[j]]);\n\t\t}\n\t\tscore+=mini;\n\t}\n\tif(depth>0)res=max(res,score);\n\tif(depth==cntmin)return;\n\tfor(int i=v+1;i<n;i++){\n\t\tif(cnt[i]<=depth)continue;\n\t\tbool flag=true;\n\t\tfor(int j=0;j<=depth;j++){\n\t\t\tif(edge[i][num[j]]==0)flag=false;\n\t\t}\n\t\tif(flag)dfs(i,depth+1);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;\n\t\tb--;\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t\tedge[a][b]=c;\n\t\tedge[b][a]=c;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs(i,0);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nconst int MAX = 111;\nint es[MAX][MAX]={};\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int u,v,w;\n    cin>>u>>v>>w;\n    u--;v--;\n    es[u][v]=es[v][u]=w;\n  }\n\n  int ans=0;\n  vector<int> used(n,0);\n  MFP([&](auto dfs,int v)->void{\n        int res=0,cnt=0;\n        for(int i=0;i<n;i++){\n          if(!used[i]) continue;\n          cnt++;\n          int tmp=1e9;\n          for(int j=0;j<n;j++)\n            if(i!=j&&used[j]) chmin(tmp,es[i][j]);\n          if(tmp==0) return;\n          res+=tmp;\n        }\n        if(cnt>1) chmax(ans,res);\n\n        if(v==n) return;\n\n        used[v]=1;\n        dfs(v+1);\n        used[v]=0;\n        dfs(v+1);\n      })(0);\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Edge { int v, f; };\n\nint n, m, f[110][110];\n\nint getCost(vector< int > X) {\n\tif (X.size() == 1) return 0;\n\tint ret = 0;\n\tfor (int v : X) {\n\t\tint add = 1L << 30;\n\t\tfor (int u : X) if (u != v) add = min(add, f[u][v]);\n\t\tret += add;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> n >> m;\n\t\n\tvector< vector< int > > adj(n, vector< int >());\n\tfor_(i,0,m) {\n\t\tint u, v, c;\n\t\tcin >> u >> v >> c;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t\tf[u][v] = f[v][u] = c;\n\t}\n\t\n\tvector< int > order(n);\n\tiota(order.begin(), order.end(), 0);\n\t\n\tsort(order.begin(), order.end(), [&](int i, int j) { return adj[i].size() < adj[j].size(); });\n\t\n\tint ans = 0;\n\tfor_(v,0,n) {\n\t\tint k = adj[v].size();\n\t\tfor_(S,0,(1<<k)) {\n\t\t\tvector< int > X = {v};\n\t\t\tfor_(i,0,k) if (S >> i & 1) X.push_back(adj[v][i]);\n\t\t\tans = max(ans, getCost(X));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2306.cc: Rabbit Party\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 100;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef set<int> si;\n\n/* global variables */\n\nint n, m;\nint fns[MAX_N][MAX_N];\nbool used[MAX_N];\n\n/* subroutines */\n\nint calc_sum() {\n  int sum = 0;\n  for (int i = 0; i < n; i++)\n    if (used[i]) {\n      int minf = INF;\n      for (int j = 0; j < n; j++)\n\tif (i != j && used[j] && minf > fns[i][j]) minf = fns[i][j];\n      if (minf < INF) sum += minf;\n    }\n  return sum;\n}\n\nint rec(int u, int k, si &vs) {\n  if (k == 0) return calc_sum();\n  if (u >= n) return 0;\n\n  int maxsum = 0;\n  for (int v = u; v <= n; v++)\n    if (! used[v]) {\n      bool ng = false;\n      for (si::iterator sit = vs.begin(); sit != vs.end(); sit++)\n\tif (! fns[v][*sit]) {\n\t  ng = true;\n\t  break;\n\t}\n      if (ng) continue;\n\n      used[v] = true;\n      vs.insert(v);\n      int sum = rec(v + 1, k - 1, vs);\n      vs.erase(v);\n      used[v] = false;\n\n      if (maxsum < sum) maxsum = sum;\n    }\n\n  return maxsum;\n}\n\n/* main */\n\nint main() {\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++) {\n    int u, v, f;\n    cin >> u >> v >> f;\n    u--, v--;\n    fns[u][v] = fns[v][u] = f;\n  }\n\n  int maxsum = 0;\n  for (int i = 2; i * (i - 1) / 2 <= m; i++) {\n    si vs;\n    int sum = rec(0, i, vs);\n    if (maxsum < sum) maxsum = sum;\n  }\n\n  printf(\"%d\\n\", maxsum);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\n#define N 101\n#define INF 1e9\ntypedef pair<int,int> P;\nvector<P> G[N];\nint n,g[N][N];\n\nvector<int> U,V;\nint can[N],ans;\nvector<bool> used(N);\nset<vector<bool> > S;\n\n\nint calc(){\n  \n  int res=0;\n  for(int i=0;i<V.size();i++){\n    int mn=INF;\n    for(int j=0;j<V.size();j++)if(i!=j) mn=min(mn,g[V[i]][V[j]]);\n    res+=mn;\n  }\n  if(V.size()==1)return 0;\n  return res;\n}\n\n\nvoid solve(int idx){\n  if(idx==U.size()){\n    ans=max(ans,calc());\n    return;\n  }\n  solve(idx+1);\n\n  V.push_back(U[idx]);\n  solve(idx+1);\n  V.pop_back();\n}\n\n\nvoid dfs(int pos){\n  int flg=1;\n  U.push_back(pos),used[pos]=1;\n  if(S.count(used)){\n    U.pop_back(),used[pos]=0;\n    return;\n  }\n  S.insert(used);\n  \n  for(int i=0;i<G[pos].size();i++) can[G[pos][i].f]++;\n  \n  for(int i=0;i<G[pos].size();i++){\n    int nx=G[pos][i].f;\n    if(used[nx]||can[nx]!=U.size())continue;\n    flg=0;\n    dfs(nx);\n  }\n  if(flg)solve(0);\n  U.pop_back(),used[pos]=0;\n  for(int i=0;i<G[pos].size();i++) can[G[pos][i].f]--;\n}\n\n\nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(P(b,c));\n    G[b].push_back(P(a,c));\n    g[a][b]=g[b][a]=c;\n  }\n  \n  for(int i=0;i<n;i++)dfs(i);\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,ans;\nint edge[105][105];\nvoid rec(int nx,vector<int>vec,vector<int>val){\n\tif(nx == n+1) return;\n\trec(nx+1,vec,val);\n\t\n\tint x = INF;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(edge[nx][vec[i]] == -1) return;\n\t\tval[i] = min(val[i],edge[nx][vec[i]]);\n\t\tx = min(x,edge[nx][vec[i]]);\n\t}\n\tvec.pb(nx); val.pb(x);\n\tif(val.size() >= 2){\n\t\tint S = 0; for(int i=0;i<val.size();i++) S += val[i];\n\t\tans = max(ans,S);\n\t}\n\trec(nx+1,vec,val);\n}\nint main(){\n\tcin >> n >> m;\n\tmemset(edge,-1,sizeof(edge));\n\trep(i,m){\n\t\tint a,b,c; cin >> a >> b >> c;\n\t\tedge[a][b] = edge[b][a] = c;\n\t}\n\trec(1,vector<int>(0),vector<int>(0)); cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\nusing namespace std;\n\nstruct node\n{\n    long long a,b;\n    friend bool operator < (const node& a,const node& b)\n    {\n        if (a.a == b.a) return a.b < b.b;\n        return a.a < b.a;\n    }\n    void set(int pos)\n    {\n        if (pos < 64)\n            a |= 1LL<<pos;\n        else\n            b |= 1LL<<(pos-64);\n    }\n    int get(int pos)\n    {\n        if (pos < 64)\n            return ((a>>pos)&1);\n        else\n            return ((b>>(pos-64))&1);\n    }\n};\n\nint n,m,res;\nint g[100][100];\nset<node> flag;\n\nvoid Gao(int tot,node used,int last)\n{\n    if (tot > 1)\n    {\n        int sum = 0,tsum;\n        for (int i = 0; i <= last; i++)\n            if (used.get(i) == 1)\n            {\n                tsum = 19921005;\n                for (int j = 0; j <= last; j++)\n                    if (i != j && used.get(j) == 1)\n                        tsum = min(tsum,g[i][j]);\n                sum += tsum;\n            }\n        res = max(res,sum);\n    }\n    node tmp;\n    bool check;\n    for (int i = last+1; i < n; i++)\n    {\n        check = true;\n        for (int j = 0; j <= last; j++)\n            if (used.get(j) == 1 && g[j][i] == 0)\n            {\n                check = false;\n                break;\n            }\n        if (check == true)\n        {\n            tmp = used;\n            tmp.set(i);\n            Gao(tot+1,tmp,i);\n        }\n    }\n}\n\nint main()\n{\n    while (scanf(\"%d%d\",&n,&m) != EOF)\n    {\n        memset(g,0,sizeof(g));\n        for (int i = 0; i < m; i++)\n        {\n            int u,v,f;\n            scanf(\"%d%d%d\",&u,&v,&f);\n            u--;\n            v--;\n            g[u][v] = max(g[u][v],f);\n            g[v][u] = max(g[v][u],f);\n        }\n        res = 0;\n        flag.clear();\n        node tmp;\n        tmp.a = tmp.b = 0;\n        Gao(0,tmp,-1);\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<cmath>\nusing namespace std;\n\nconst double eps = 1e-12;\nconst int V = 110;\nconst int INFI = 1 << 29;\n#define REP(i, x) for (int i=0;i<x;i++)\n\n\nint n, m, ans;\nint mat[V][V], value[20], path[20];\n\nvoid dfs(int v,int path[],int value[],int cnt)\n{\n    int rvalue[20], rpath[20];\n    if (v > n) return;\n    \n    for (int i=0;i<cnt;i++) rpath[i] = path[i], rvalue[i] = value[i];\n    \n    int ret = 0;\n    rvalue[cnt] = INFI;\n    for (int i=0;i<cnt;i++)\n    {\n        int u = path[i];\n        if (!mat[v][u])\n            return;\n        rvalue[i] = min(rvalue[i], mat[v][u]);\n        rvalue[cnt] = min(rvalue[cnt], mat[v][u]);\n        \n        ret += rvalue[i];\n    }\n    if (cnt > 0) ret += rvalue[cnt];\n    \n    if (ret > ans) ans = ret;\n    \n    rpath[cnt] = v;\n    dfs(v+1, rpath, rvalue, cnt+1);\n    dfs(v+1, rpath, rvalue, cnt);\n}\nint main()\n{\n    int a, b, c;\n    \n    scanf(\"%d%d\",&n,&m);\n    \n    memset(mat, 0, sizeof(mat));\n    for (int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&a,&b,&c);\n        mat[a][b] = c;\n        mat[b][a] = c;\n    }\n    ans = 0;\n    dfs(1, path, value, 0);\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint n, m;\nint f[100][100];\n\nint dfs(vector<int> &v)\n{\n    // cout << sum << endl;\n    // printv(v);\n    int sz = v.size();\n    int last = v[sz - 1], res = 0;\n    for (int i = 0; i < sz; i++)\n    {\n        if (sz == 1)\n            break;\n        int mi = INF;\n        for (int j = 0; j < sz; j++)\n        {\n            if (i == j)\n                continue;\n            if (f[v[i]][v[j]] == 0)\n            {\n                v.pop_back();\n                return 0;\n            }\n            mi = min(mi, f[v[i]][v[j]]);\n        }\n        res += mi;\n    }\n    for (int i = last + 1; i < n; i++)\n    {\n        v.push_back(i);\n        res = max(res, dfs(v));\n    }\n    v.pop_back();\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> m;\n    for (int i = 0; i < m; i++)\n    {\n        int u, v, x;\n        cin >> u >> v >> x;\n        u--;\n        v--;\n        f[u][v] = f[v][u] = x;\n    }\n    int res = 0;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> v;\n        v.push_back(i);\n        res = max(res, dfs(v));\n    }\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#define __float128 long double\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nint fr[110][110];\nvector<P> G[110];\nvector<int> cand[20];\n\n\nint v[20];\n\nint calc(int n){\n\t//rep(i, n) cout << v[i] << ' ';\n\t//cout << endl;\n\tint res = 0;\n\trep(i, n){\n\t\tint tmp = 1e9;\n\t\trep(j, n){\n\t\t\tif (i == j) continue;\n\t\t\ttmp = min(tmp, fr[v[i]][v[j]]);\n\t\t}\n\t\tres += tmp;\n\t}\n\treturn res;\n}\n\nint dfs(int i, int k, int sz, int n){\n\tif (i == n) return calc(n);\n\n\tint res = 0;\n\tfor (int j = k; j < sz; ++j){\n\t\tv[i] = j;\n\t\tres = max(res, dfs(i + 1, j + 1, sz, n));\n\t\tif (i + sz - k < n) break;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\n\trep(i, m){\n\t\tint a, b, f;\n\t\tcin >> a >> b >> f;\n\t\t--a, --b;\n\t\tG[a].push_back(MP(b, f));\n\t\tG[b].push_back(MP(a, f));\n\t\tfr[a][b] = fr[b][a] = f;\n\t}\n\n\trep(i, n){\n\t\tFOR(j, 1, 15){\n\t\t\tif (G[i].size() >= j) cand[j+1].push_back(i);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tFOR(i, 2, 15){\n\t\tans = max(ans, dfs(0, 0, cand[i].size(), i));\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n\n#define INF (1LL<<62)\n\nusing namespace std;\n\ntypedef long long ll;\n\nll g[101][101],n,m;\n\nll rec(set<int> S,int mx){\n  \n  if(mx<0)return 0;\n\n  ll res=0;\n  set<int>::iterator it=S.begin();\n  for(;it!=S.end();it++){\n    set<int>::iterator j=S.begin();\n    ll t=INF;\n    for(;j!=S.end();j++){\n      if(it==j)continue;\n      t=min(t,g[*it][*j]);\n    }\n    res+=t;\n  }\n  \n  if(mx>=n-1)return res;\n\n  int id=-1;\n  ll cost=0;\n  for(int v=mx+1;v<n;v++){\n    if(S.count(v))continue;\n\n    bool fg=true;\n    set<int>::iterator it=S.begin();\n    for(;it!=S.end();it++){\n      fg&=(g[v][*it]<INF);\n    }\n    if(!fg)continue;\n    /*\n    ll tmp=INF;\n    it=S.begin();\n    for(;it!=S.end();it++){\n      tmp=min(tmp,g[v][*it]);\n    }\n    //    if(cost<tmp)cost=tmp,id=v;\n    */\n    set<int>T=S;\n    T.insert(v);\n    cost=max(cost,rec(T,v));\n  }\n  \n  //S.insert(id);\n  return max(res,cost);\n  //return max(rec(S,id),res);\n}\n\nint main(void){\n\n  fill(g[0],g[101],INF);\n  for(int i=0;i<101;i++)g[i][i]=0;\n\n  cin >> n >> m;\n\n  for(int i=0;i<m;i++){\n    ll a,b,f;\n    cin >> a >> b >>f;\n    g[a-1][b-1]=g[b-1][a-1]=f;\n  }\n  \n  ll ans=0;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(g[i][j]<INF){\n\tset<int>S;\n\tS.insert(i);\n\tS.insert(j);\n\tans=max(ans,rec(S,max(i,j)));\n      }\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> dim(N);\n    vector<vector<int>> edge(N, vector<int>(N, 0));\n    for (int i = 0; i < M; i++) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        u--, v--;\n        edge[u][v] = edge[v][u] = c;\n        dim[u]++, dim[v]++;\n    }\n    int ans = 0;\n    for (int s = 2; s <= 14; s++) {\n        vector<int> cand;\n        for (int i = 0; i < N; i++) {\n            if (dim[i] >= s - 1) { cand.push_back(i); }\n        }\n        if (cand.size() < s) { break; }\n        const int sz = cand.size();\n        vector<bool> mask(sz, false);\n        fill(mask.end() - s, mask.end(), true);\n        auto score = [&](const vector<int>& node) {\n            int ans = 0;\n            for (const int i : node) {\n                int mini = 1 << 30;\n                for (const int j : node) {\n                    if (i == j) { continue; }\n                    if (edge[i][j] == 0) { return 0; }\n                    mini = min(mini, edge[i][j]);\n                }\n                ans += mini;\n            }\n            return ans;\n        };\n        do {\n            vector<int> node;\n            for (int i = 0; i < sz; i++) {\n                if (mask[i]) { node.push_back(cand[i]); }\n            }\n            ans = max(ans, score(node));\n        } while (next_permutation(mask.begin(), mask.end()));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      for(int& i : mincost)i = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      for(int& i : mincost) ret += i;\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e18;\n\nlli dfs(int node, vector<int> &used, vector<lli> score, vector<vector<lli> > &adj){\n\tlli res = inf;\n\tfor(int i: used){\n\t\tres = min(res, adj[i][node]);\n\t}\n\tif(res == 0) return 0;\n\t\n\tscore.push_back(res);\n\tfor(int i=0; i<(int)used.size(); i++){\n\t\tscore[i] = min(score[i], adj[used[i]][node]);\n\t\tres += score[i];\n\t}\n\t\n\tused.push_back(node);\n\tfor(int i=node+1; i<(int)adj.size(); i++){\n\t\tres = max(res, dfs(i, used, score, adj));\n\t}\n\tused.pop_back();\n\treturn res;\n}\n\nlli solve(vector<vector<lli> > &adj){\n\tint n = adj.size();\n\tvector<int> used(1);\n\tvector<lli> score(1);\n\tlli res = 0;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=i+1; j<n; j++){\n\t\t\tif(adj[i][j] == 0) continue;\n\t\t\tused[0] = i;\n\t\t\tscore[0] = adj[i][j];\n\t\t\tres = max(res, dfs(j, used, score, adj));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<vector<lli> > adj(n, vector<lli>(n, 0));\n\tfor(int i=0; i<m; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadj[a][b] = adj[b][a] = c;\n\t}\n\tcout << solve(adj) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\ntypedef long long LL;\nLL mat[100][100];\nLL ans;\nint n, m;\nvoid dfs(vector<int> &v) {\n\tif (v.size() > 1) {\n\t\tLL tmp = 0;\n\t\tfor (int i : v) {\n\t\t\tLL m = 1 << 30;\n\t\t\tfor (int j : v) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tm = min(m, mat[i][j]);\n\t\t\t}\n\t\t\ttmp += m;\n\t\t}\n\t\tans = max(ans, tmp);\n\t}\n\tfor (int i = v.back() + 1; i < n; i++) {\n\t\tbool ok = 1;\n\t\tfor (int j : v) {\n\t\t\tif (!mat[i][j]) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tv.push_back(i);\n\t\t\tdfs(v);\n\t\t\tv.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, f;\n\t\tcin >> u >> v >> f;\n\t\tu--; v--;\n\t\tmat[u][v] = mat[v][u] = f;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> v(1, i);\n\t\tdfs(v);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  xioumu\n * Created Time:  2012/10/9 14:23:22\n * File Name: g.cpp\n * solve: g.cpp\n */\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr(x) memset(x,0,sizeof(x))\n#define clrs( x , y ) memset(x,y,sizeof(x))\n#define out(x) printf(#x\" %d\\n\", x)\ntypedef long long lint;\nconst int maxint = -1u>>1;\nconst double esp = 1e-8;\nconst int maxn = 100 + 10;\nint e[maxn][maxn];\nint n, m, ans;\nint v[maxn];\nvoid dfs(int w) {\n    if(w == n + 1) return;\n    dfs(w + 1);\n    repf (i, 1, w - 1)\n        if(v[i] && e[i][w] == 0)\n            return ;\n    v[w] = 1;\n    int res = 0;\n    repf (i, 1, w) {\n        if(!v[i]) continue;\n        int h = maxint;\n        repf (j, 1, w) {\n            if(i == j) continue;\n            if(v[j])\n                h = min(e[i][j], h); \n        }\n        if(h == maxint) h = 0;\n        res += h;\n    }\n    ans = max(res, ans);\n    dfs(w + 1);\n    v[w] = 0;\n}\nint main() {\n    while(scanf(\"%d%d\", &n, &m) == 2) {\n        memset(e, 0, sizeof(e));\n        ans = 0;\n        memset(v, 0, sizeof(v));\n        rep (i, m) {\n            int x, y, z;\n            scanf(\"%d%d%d\", &x, &y, &z);\n            e[x][y] = e[y][x] = z;\n        }\n        dfs(1);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint candidate[100];\nint cn;\nint fr[100][100];\nint n, m;\nint ans;\n\nvoid solve(int now){\n  if(now == cn){\n    if(cn == 1) return;\n    int tmp = 0;\n    REP(i,cn){\n      int mm = INT_MAX;\n      REP(j,cn)if(i != j){\n\tmm = min(mm, fr[candidate[i]][candidate[j]]);\n      }\n      tmp += mm;\n    }\n\n    //REP(i,cn) printf(\"%d \", candidate[i]+1); printf(\": %d\\n\", tmp);\n\n    ans = max(ans, tmp);\n  }else{\n    // select\n    {\n      int cntmp = cn;\n      int rab = candidate[now];\n      for(int i = now + 1; i < cn;){\n\tif(fr[rab][candidate[i]] == 0){\n\t  --cn;\n\t  swap(candidate[i], candidate[cn]);\n\t}else{\n\t  ++i;\n\t}\n      }\n\n      solve(now + 1);\n\n      cn = cntmp;\n    }\n    // not select\n    {\n      --cn;\n      swap(candidate[now], candidate[cn]);\n      solve(now);\n      swap(candidate[now], candidate[cn]);\n      ++cn;\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d%d\", &n, &m);\n  cn = n;\n  REP(i,m){\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    fr[a-1][b-1] = fr[b-1][a-1] = c;\n  }\n  REP(i,n) candidate[i] = i;\n  \n  solve(0);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nint n,adj[100][100],deg[100];\n\nvoid dfs(int u,bool *visited,vector<int> &cc){\n\tvisited[u]=true;\n\tcc.push_back(u);\n\trep(v,n) if(adj[u][v] && !visited[v]) dfs(v,visited,cc);\n}\n\nint calc(const vector<int> &cc){\n\tint res=0;\n\tfor(int d=1;d<20;d++){\n\t\tvector<int> S;\n\t\trep(i,cc.size()){\n\t\t\tint u=cc[i];\n\t\t\tif(deg[u]>=d) S.push_back(u);\n\t\t}\n\n\t\tint m=S.size();\n\t\tif(m<d+1) continue;\n\t\tif(d==1){\n\t\t\trep(j,m) rep(i,j) res=max(res,2*adj[S[i]][S[j]]);\n\t\t}\n\t\telse{\n\t\t\tll T=(1<<d+1)-1;\nif(m>63) for(;;);\n\t\t\twhile(T<(1LL<<m)){\n\t\t\t\tint w=0;\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,m) if(T&(1LL<<i)) {\n\t\t\t\t\tint w2=INF;\n\t\t\t\t\trep(j,m) if(i!=j && T&(1LL<<j)) w2=min(w2,adj[S[i]][S[j]]);\n\t\t\t\t\tif(w2==0){ ok=false; break; }\n\t\t\t\t\telse w+=w2;\n\t\t\t\t}\n\t\t\t\tif(ok) res=max(res,w);\n\n\t\t\t\tll x=T&-T,y=T+x;\n\t\t\t\tT=((T&~y)/x>>1)|y;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint m; scanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v,w; scanf(\"%d%d%d\",&u,&v,&w); u--; v--;\n\t\tadj[u][v]=adj[v][u]=w;\n\t\tdeg[u]++;\n\t\tdeg[v]++;\n\t}\n\n\tint ans=0;\n\tbool visited[100]={};\n\trep(u,n) if(!visited[u]) {\n\t\tvector<int> cc;\n\t\tdfs(u,visited,cc);\n\t\tans=max(ans,calc(cc));\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, M, ST, gans, ans, hg1, ohg1;\nint jiyou[120][120], val[200], oval[300];\nbool used[1000];\n\nint getans()\n{\n\tint i, res = 0, nc = 0;\n\tfor (i = ST; i <= N; ++i)\n\t\tif (used[i])\n\t\t{\n\t\t\t++nc;\n\t\t\tres += val[i];\n\t\t}\n\tif (nc < 2) return 0;\n\treturn res;\n}\n\nvoid dfs(int x);\n\nint main()\n{\n\tint i, j, k, x, y, l;\n\tmemset(jiyou, 0, sizeof(jiyou));\n\tscanf(\"%d%d\", &N, &M);\n\tfor (i = 0; i < M; ++i)\n\t{\n\t\tscanf(\"%d%d%d\", &x, &y, &l);\n\t\tjiyou[x][y] = l;\n\t\tjiyou[y][x] = l;\n\t}\n\tfor (i = 1; i < N; ++i)\n\t{\n\t\tST = i;\n\t\tans = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\tfor (i = 0; i < 150; ++i) val[i] = 1000000008;\n\t\tused[i] = true;\n\t\tdfs(i+1);\n\t}\n\tprintf(\"%d\\n\", gans);\n\treturn 0;\n}\n\nvoid dfs(int x)\n{\n\tint i, haogandu = 2000000000;\n\tif (x > N)\n\t{\n\t\tgans = max(gans, getans());\n\t\treturn;\n\t}\n\tfor (i = ST; i <= N; ++i)\n\t\tif (used[i])\n\t\t\thaogandu = min(haogandu, jiyou[x][i]);\n\tif (haogandu)\n\t{\n\t\tfor (i = ST; i <= N; ++i)\n\t\t\toval[i] = val[i];\n\t\tval[x] = haogandu;\n\t\tfor (i = ST; i <= N; ++i)\n\t\t\tif (used[i])\n\t\t\t{\n\t\t\t\tval[i] = min(val[i], jiyou[x][i]);\n\t\t\t\tif (i > ST)\n\t\t\t\t\tval[ST] = min(val[ST], jiyou[i][ST]);\n\t\t\t}\n\t\tused[x] = true;\n\t\tgans = max(gans, getans());\n\t\tdfs(x+1);\n\t\tused[x] = false;\n\t\tfor (i = ST; i <= N; ++i)\n\t\t\tval[i] = oval[i];\n\t}\n\tdfs(x+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst int inf = 1012345678;\n#define pb push_back\n#define sz(x) (int)x.size()\nint rd(){int x;scanf(\"%d\",&x);return x;}\n#define clr(x,a) memset(x,a,sizeof(x))\nconst int maxn = 110;\nconst int maxe = 100000;\n\nint g[maxn][maxn],ans,n,m;\nint r[maxn][maxn],maxr[maxn][maxn],b[maxn][maxn]; \nvoid clq(int rcnt,int bcnt,int now)\n{\n\tint i,j,k;\n\tint tcnt=0,vn=0;\n\tans=max(ans,now);\n\tif(bcnt==0)\n\t{\n\t\treturn ;\n\t}\n\n\tfor(i=0; i<bcnt; i++)\n\t{\n\t\tvn=0,tcnt=0;\n\t\tint flag=0;\n\t\tfor(j=0; j<rcnt; j++)\n\t\tif(g[r[rcnt-1][j]][b[rcnt-1][i]]==0)\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(!flag)\n\t\t{\n\t\t\tint tp=inf;\n\t\t\tint sum=0;\n\t\t\tfor(j=0; j<rcnt;j++)\n\t\t\t{\n\t\t\t\tr[rcnt][j]=r[rcnt-1][j];\n\t\t\t\tmaxr[rcnt][j]=maxr[rcnt-1][j];\n\tif(g[r[rcnt-1][j]][b[rcnt-1][i]]!=0 && g[r[rcnt-1][j]][b[rcnt-1][i]]<maxr[rcnt-1][j])\n\t\t\t\t\tmaxr[rcnt][j]=g[r[rcnt-1][j]][b[rcnt-1][i]];\n\t\t\t\t\n\t\t\t\ttp=min(tp,g[r[rcnt-1][j]][b[rcnt-1][i]]);\n\t\t\t\tsum+=maxr[rcnt][j];\n\t\t\t}\n\t\t\tr[rcnt][j]=b[rcnt-1][i];\n\t\t\tmaxr[rcnt][rcnt]=tp;\n\t\t\tsum+=tp;\n\t\t\t\n\t\t\tfor(j=0; j<bcnt; j++)\n\t\t\tif(i!=j && g[b[rcnt-1][i]][b[rcnt-1][j]])\n\t\t\t{\n\t\t\t\tb[rcnt][vn++]=b[rcnt-1][j];\n\t\t\t}\n\t\t\tclq(rcnt+1,vn,sum);\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in\",\"r\",stdin);\n\tint i,j,k;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint x,y,z;\n\t\tclr(g,0);\n\t\tfor(i=0; i<m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tg[x][y]=g[y][x]=z;\n\t\t}\n\t\tans=0;\n\t\tfor(i=1; i<=n ;i++)\n\t\t{\n\t\t\tk=0;\n\t\t\tfor(j=i; j<=n; j++)\n\t\t\tif(i!=j && g[i][j])\n\t\t\t\tb[0][k++]=j;\n\n\t\t\tr[0][0]=i;\n\t\t\tmaxr[0][0]=inf;\n\t\t\tclq(1,k,0);\n\t\t}\n\t\tif(n==1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MS(a) memset(a,0,sizeof(a))\n#define MP make_pair\n#define PB push_back\nconst int INF = 0x3f3f3f3f;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3fLL;\ninline ll read(){\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n//////////////////////////////////////////////////////////////////////////\nconst int maxn = 1e5+10;\n\nint n,m,mp[20][20],vis[20],ans;\nvector<int> Q;\n\nvoid dfs(int u){\n\tint tmp = 0;\n\tfor(int i=0; i<(int)Q.size(); i++){\n\t\tint minn = INF;\n\t\tfor(int j=0; j<(int)Q.size(); j++){\n\t\t\tif(i!=j) minn = min(minn,mp[Q[i]][Q[j]]);\n\t\t}\n\t\tif(minn == INF)\n\t\t\tminn = 0;\n\t\ttmp += minn;\n\t}\n\tans = max(ans,tmp);\n\n\tfor(int v=u+1; v<=n; v++){\n\t\tif(vis[v]) continue;\n\t\tint flag = 1;\n\t\tfor(int j=0; j<(int)Q.size(); j++){//?????????v???????????????????????????????????????v?°±???????????¨??????????????????\n\t\t\tif(mp[v][Q[j]] == 0) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(flag){\n\t\t\tvis[v] = 1;  // ???v\n\t\t\tQ.push_back(v);\n\t\t\tdfs(v);\n\t\t\tvis[v] = 0; // ??????v  ?????? ???v??????????????????????°?\n\t\t\tQ.pop_back();\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read(), m=read();\n\tfor(int i=0; i<m; i++){\n\t\tint u,v,w; scanf(\"%d%d%d\",&u,&v,&w);\n\t\tmp[u][v]=mp[v][u]=w;\n\t}\n\n\tfor(int i=1; i<=n; i++){\n\t\tvis[i] = 1;\n\t\tQ.push_back(i); // ?????????????????????????????????\n\t\tdfs(0);\n\t\tQ.pop_back();\n\t\tvis[i] = 0;\n\t}\n\n\tcout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      mincost[0] = 0;\n      for(int& i : mincost)i = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      for(int& i : mincost) ret += i;\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Nmax 102\nusing namespace std;\n\nint mx,s,n,m,x,y,mat[Nmax][Nmax],mn;\nvector<int> V;\nvector<int> MN;\n\n\nvoid bkt(int k)\n{\n    s = 0;\n    for (auto it : MN)\n    {\n        if (it!=2e9)\n            s+=it;\n    }\n    if (s>mx)\n        mx = s;\n    if (k>n)\n        return;\n    vector<int> sav = vector<int>(MN);\n\n    for (int i=k;i<=n;i++)\n    {\n        int ok = 1;\n        mn = 2e9;\n        for (auto it : V)\n        {\n            mn = min(mn,mat[i][it]);\n            if (mat[i][it]==0)\n                break;\n        }\n        if (mn==2e9)\n            mn = 0;\n        if (mn)\n        {\n            MN = vector<int>(sav);\n            for (int j=0;j<V.size();j++)\n            {\n                MN[j] = min(MN[j],mat[V[j]][i]);\n            }\n            V.push_back(i);\n            MN.push_back(mn);\n            bkt(k+1);\n        }\n    }\n}\n\nint main()\n{\n    cin>>n>>m;\n    for (int i=1;i<=m;i++)\n    {\n        cin>>x>>y;\n        cin>>mat[x][y];\n        mat[y][x] = mat[x][y];\n    }\n\n    for (int i=1;i<=n;i++)\n    {\n        V.clear();\n        MN.clear();\n        V.push_back(i);\n        MN.push_back(2e9);\n        bkt(i+1);\n    }\n\n    cout<<mx;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_N = 100;\n\nint n, m;\nmap<int, int> G[MAX_N];\n\nint base;\nint ans = -1;\n\nvoid calc(const vector<int> &nodes) {\n\tconst int V = nodes.size();\n\n\tvector<int> idx(n, -1);\n\tfor(int i = 0; i < V; ++i) {\n\t\tidx[nodes[i]] = i;\n\t}\n\n\tfor(int bit = 0; bit < (1 << V); ++bit) {\n\t\tint sum = 0;\n\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tif(bit & (1 << i)) continue;\n\n\t\t\tint score = INT_MAX;\n\t\t\tconst int v = nodes[i];\n\n\t\t\tfor(int j = 0; j < V; ++j) {\n\t\t\t\tif(i == j || (bit & (1 << j))) continue;\n\n\t\t\t\tconst int u = nodes[j];\n\t\t\t\tif(!G[u].count(v)) goto ng;\n\t\t\t\tchmin(score, G[u][v]);\n\t\t\t}\n\n\t\t\tif(score != INT_MAX) sum += score;\n\t\t}\n\t \n\t\tchmax(ans, sum);\n\tng:;\n\t}\n}\n\nvoid dfs(int v = 0) {\n\tif(v == n) return;\n\n\tif(static_cast<int>(G[v].size()) <= base) {\n\t\tvector<int> nodes(G[v].size() + 1);\n\n\t\tauto it = G[v].cbegin();\n\t\tfor(int i = 0; it != G[v].cend(); ++i, ++it) {\n\t\t\tnodes[i] = it->first;\n\t\t}\n\t\tnodes.back() = v;\n\t\tcalc(nodes);\n\t}\n\tdfs(v + 1);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\n\tbase = sqrt(2 * m);\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t--a; --b;\n\t\tG[a].insert({b, c});\n\t\tG[b].insert({a, c});\n\t}\n\n\tdfs();\n\n\tif(ans == -1) {\n\t\tvector<int> nodes(n);\n\t\tiota(nodes.begin(), nodes.end(), 0);\n\t\tcalc(nodes);\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n#define inf 100000000\n\nusing namespace std;\n\nint n, m;\nvector<int> G[105];\nint g[105][105];\n\nbool used[105];\nvector<int> vec;\n\nint calc()\n{\n\tint mi, ret = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tmi = inf;\n\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\tif(i == j) continue;\n\t\t\tmi = min(mi, g[vec[i]][vec[j]]);\n\t\t}\n\t\tif(mi == inf) mi = 0;\n\t\tret += mi;\n\t}\n\treturn ret;\n}\n\nint dfs(int v, int num)\n{\n\tif(num >= 14) return 0;\n\tvec.push_back(v);\n\tused[v] = true;\n\t\n\tint ret = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tret = max(ret, dfs(G[v][i], num+1));\n\t}\n\tret = max(ret, calc());\n\tvec.pop_back();\n\tused[v] = false;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tint u, v, f;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u >> v >> f;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tg[u][v] = g[v][u] = f;\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans = max(ans, dfs(i, 0));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreeIdea\n * Created Time:  2011/10/22 16:13:15\n * File Name: G.cpp\n */\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\nconst int maxn = 100 + 5;\nint g[maxn][maxn], vis[maxn][maxn], com[maxn][maxn];\nint n, m, ans;\nvector<int> vec, res;\nbool use[maxn];\n\nvoid calc() {\n    res.clear();\n    for(int i = 0; i < vec.size(); i++) {\n        if(use[i]) {\n            res.push_back(vec[i]);\n        }\n    }\n    if(res.size() <= 1) return;\n    int r = 0;\n    for(int i = 0; i < res.size(); i++) {\n        int c = maxint;\n        for(int j = 0; j < res.size(); j++) {\n            if(i == j)  continue;\n            get_min(c, g[res[i]][res[j]]);\n        }\n        r += c;\n    }\n    get_max(ans, r);\n}\n    \nvoid dfs(int dep) {\n    if(dep == vec.size()) {\n        calc();\n        return;\n    }\n    for(int i = 0; i <= 1; i++) {\n        use[dep] = i;\n        dfs(dep + 1);\n    }\n}\n\n\nvoid clique(int com_cnt, int vis_cnt, int dep) {\n    if(!com_cnt) {\n        if(!vis_cnt) {\n            dfs(0);\n        }\n        return;\n    }\n    for(int i = 1; i <= vis_cnt; i++) {\n        bool found = false;\n        int t = vis[dep][i];\n        for(int j = 1; j <= com_cnt; j++) {\n            if(!g[t][com[dep][j]]) {\n                found = true;\n                break;\n            }\n        }\n        if(!found)  return;\n    }\n    for(int i = 1; i <= com_cnt; i++) {\n        int v = com[dep][i];\n        int t, t_com_cnt = 0, t_vis_cnt = 0;\n        for(int j = i + 1; j <= com_cnt; j++) {\n            t = com[dep][j];\n            if(g[v][t]) com[dep + 1][++t_com_cnt] = t;\n        }\n        for(int j = 1; j <= vis_cnt; j++) {\n            t = vis[dep][j];\n            if(g[v][t]) vis[dep + 1][++t_vis_cnt] = t;\n        }\n        vec.push_back(v);\n        clique(t_com_cnt, t_vis_cnt, dep + 1);\n        vec.pop_back();\n        vis[dep][++vis_cnt] = v;\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    if(n > 50) while(1);\n    for(int i = 1; i <= m; i++) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        g[u][v] = g[v][u] = w;\n    }\n    for(int i = 1; i <= n; i++) com[1][i] = i;\n    clique(n, 0, 1);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, m, a[109], b[109], c[109], ret, g[109][109]; long long pw[109]; bool vis[109]; set<long long> s;\nvoid solve(vector<int> v, long long h) {\n\tint res = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tint r = 1 << 30;\n\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\tif (i != j) r = min(r, g[v[i]][v[j]]);\n\t\t}\n\t\tif(v.size() >= 2) res += r;\n\t}\n\tret = max(ret, res);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (vis[a[i]] || vis[b[i]]) {\n\t\t\tint u1 = a[i], u2 = b[i];\n\t\t\tif (!vis[u1]) swap(u1, u2);\n\t\t\tbool flag = true;\n\t\t\tfor (int j : v) {\n\t\t\t\tif (!g[u2][j]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) continue;\n\t\t\tlong long nh = h + pw[u2];\n\t\t\tif (!s.count(nh)) {\n\t\t\t\ts.insert(nh);\n\t\t\t\tvis[u2] = true;\n\t\t\t\tv.push_back(u2);\n\t\t\t\tsolve(v, nh);\n\t\t\t\tv.pop_back();\n\t\t\t\tvis[u2] = false;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tpw[0] = 1;\n\tfor (int i = 1; i <= 100; i++) pw[i] = pw[i - 1] * 314159265358979;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t\tg[a[i]][b[i]] = g[b[i]][a[i]] = c[i];\n\t}\n\tfor (int i = 0; i < n; i++) vis[i] = true, solve(vector<int>({ i }), pw[i]), vis[i] = false;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m;\nll f[111][111];\nvector<ll> crt;\n\nll calc_score(vector<ll> vs){\n  if(vs.size()<2)return 0;\n  ll res=0;\n  rep(i,vs.size()){\n    ll mins=INF;\n    rep(j,vs.size()){\n      if(i==j)continue;\n      minch(mins,f[vs[i]][vs[j]]);\n    }\n    res+=mins;\n  }\n  return res;\n}\n\nll dfs(ll v){\n  //dbg(v);\n  ll res=calc_score(crt);\n  repl(i,v+1,n){\n    bool ok=true;\n    for(ll u : crt){\n      if(i!=u&&f[i][u]==0){\n        ok=false;\n      }\n    }\n    if(ok){\n      crt.push_back(i);\n      maxch(res,dfs(i));\n      crt.pop_back();\n    }\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  memset(f,0,sizeof(f));\n  cin>>n>>m;\n  rep(i,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--; b--;\n    f[a][b]=f[b][a]=c;\n  }\n  ll res=0;\n  rep(i,n){\n    crt.push_back(i);\n    maxch(res,dfs(i));\n    crt.pop_back();\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>e[100],v;\nint n,s[100][100],res;\nvoid F()\n{\n\tint i,j,t,c;\n\tif(v.size()>1)\n\t{\n\t\tfor(c=i=0;i<v.size();++i)\n\t\t{\n\t\t\tt=INT_MAX;\n\t\t\tfor(j=0;j<v.size();++j)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tt=min(t,s[v[i]][v[j]]);\n\t\t\t}\n\t\t\tc+=t;\n\t\t}\n\t\tres=max(res,c);\n\t}\n\tfor(i=0;i<n;++i)\n\t{\n\t\tif(find(v.begin(),v.end(),i)!=v.end())\n\t\t\tcontinue;\n\t\tfor(j=0;j<v.size();++j)\n\t\t\tif(find(e[v[j]].begin(),e[v[j]].end(),i)==e[v[j]].end())\n\t\t\t\tgoto N;\n\t\tv.push_back(i);\n\t\tF();\n\t\tv.pop_back();\n\t\tN:;\n\t}\n}\nint main()\n{\n\tint m,a,b,f;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&f);\n\t\t--a,--b;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t\ts[a][b]=s[b][a]=f;\n\t}\n\tF();\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    int tmp = [&]()mutable->int{\n      int ret = 0;\n      //int mincost[node];\n      //for(int& i : mincost)i = IINF;\n      vector<int> mincost(node,IINF);\n      for(int i=0;i<node;i++){\n\tfor(int j=i+1;j<node;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      for(int& i : mincost) ret += i;\n      return ret;\n    }();\n\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nvvll g;\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    g = vvll(n, vll(n)); rep(i, n) g[i][i] = INF;\n\n    rep(i, m) {\n        ll u, v, f; cin >> u >> v >> f; u--, v--;\n        g[u][v] = g[v][u] = f;\n    }\n\n    vll vs;\n    function<ll(vll&)> f = [&](vll& vs) {\n        ll ret = 0;\n        rep(i, vs.size()) {\n            ll min_f = INF;\n            rep(j, vs.size()) \n                chmin(min_f, g[vs[i]][vs[j]]);\n            ret += min_f != INF ? min_f : 0;\n        }\n        repi(i, vs.size() ? vs.back()+1 : 0, n) {\n            for (auto v : vs) if (!g[v][i]) goto next;\n            vs.pb(i);\n            chmax(ret, f(vs));\n            vs.pop_back();\n            next:;\n        }\n        return ret;\n    };\n    cout << f(vs) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define INF (1<<29)\n\nint N, cost[MAX][MAX];\n\nint get_sat(set<int> &inv)\n{\n    int sat = 0;\n    for (auto &i: inv) {\n        int s = INF;\n        for (auto &j: inv) {\n            if (i == j) continue;\n            s = min(s, cost[i][j]);\n        }\n        sat += s;\n    }\n    return sat;\n}\n\nint dfs(set<int> inv)\n{\n    int res = 0;\n    if (inv.size() >= 2) {\n        res = get_sat(inv);\n    }\n    for (int i = 0; i < N; i++) {\n        bool ok = 1;\n        for (auto &j: inv) {\n            if (cost[i][j] == 0) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok) {\n            set<int> ninv = inv;\n            ninv.insert(i);\n            res = max(res, dfs(ninv));\n        }            \n    }\n    return res;\n}\n\nint main()\n{\n    int M, a, b, c;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> c;\n        a--; b--;\n        cost[a][b] = cost[b][a] = c;\n    }    \n    cout << dfs(set<int>()) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint m[110][110];\nint now[110];\nint n;\nint dfs(int a,int b){\n\tif(n==a){\n\t\tif(b<2)return 0;\n\t\tint val=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint t=9999999;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(i!=j)t=min(t,m[now[i]][now[j]]);\n\t\t\t}\n\t\t\tval+=t;\n\t\t}\n\t\treturn val;\n\t}\n\tint ret=dfs(a+1,b);\n\tbool ok=true;\n\tfor(int i=0;i<b;i++)if(!m[now[i]][a])ok=false;\n\tif(ok){\n\t\tnow[b]=a;\n\t\tret=max(ret,dfs(a+1,b+1));\n\t}\n\treturn ret;\n}\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tn=a;\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);p--;q--;\n\t\tm[p][q]=m[q][p]=r;\n\t}\n\tprintf(\"%d\\n\",dfs(0,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int NODE = 101;\nconst int INF = (1<<28);\nint N,M;\nint fri[NODE][NODE];\nbool used[NODE];\nset<int> edge;\n\nstruct State{\n  ll A,B; // state -> AB\n  State operator & (const State& st) const {\n    State res;\n    res.A = A&st.A;\n    res.B = B&st.B;\n    return res;\n  }\n\n  void turnOn(int n){\n    if(n < 64) A |= (1LL<<n);\n    else B |= (1LL<<(n-64));\n  }\n\n  void toggle(int n){\n    if(n < 64) A ^= (1LL<<n);\n    else B ^= (1LL<<(n-64));\n  }\n\n  bool getAt(int n) const { return n<64?(A&(1LL<<n)):(B&(1LL<<(64-n)));}\n  int count() const { return __builtin_popcountll(A) + __builtin_popcountll(B);}\n};\n\nvoid input(){\n  memset(fri, 0, sizeof(fri));\n  edge.clear();\n\n  cin >> N >> M;\n  for(int i = 0; i < M; i++){\n    int a,b,f;\n    cin >> a >> b >> f;\n    a--; b--;\n    fri[a][b] = fri[b][a] = f;\n    edge.insert(f);\n  }\n}\n\nll find(int now, vector<int>& v, const int& lb, State& st){\n \n  ll res = -1;\n  for(int i = 0; i < N; i++){\n    if(fri[now][i] >= lb && !(st.getAt(i)) && !used[i]){\n      used[i] = true;\n      for(int j = 0; j < N; j++) if(i != j) v[j] = min(v[j], fri[i][j]);\n      st.turnOn(i);\n      res = max(res, find(i, v, lb, st));\n      st.toggle(i);\n    }\n  }\n  \n  if(st.count() > 1){\n    ll tmp = 0;\n    for(int i = 0; i < N; i++) if(st.getAt(i)) tmp += v[i];\n    res = max(res, tmp);\n  }\n  return res;\n}\n\n\nvoid solve(){\n  long long ans = 0;\n  for(set<int>::iterator ite = edge.begin(); ite != edge.end(); ite++)\n    for(int i = 0; i < N; i++){\n      memset(used, false, sizeof(used));\n      vector<int> cost(NODE, INF);\n      for(int j = 0; j < N; j++) if(i != j) cost[j] = fri[i][j];\n      used[i] = true;\n      State st = (State){0,0};\n      st.turnOn(i);\n      ans = max(ans, find(i, cost, *ite, st));\n    }\n  cout << ans << endl;\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define INF 1000000007\n#define MP make_pair\n#define FI first\n#define SE second\n#define PB push_back\n#define VI vector<int>\nconst double EPS = 1e-7, PI = acos(-1.0);\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int, int> P;\ntemplate<class T>\ninline T IN(T& num)\n{\n    num = 0;\n    char c = getchar(), f = 0;\n    while(c != '-' && (c < '0' || c > '9')) c = getchar();\n    if(c == '-') f = 1, c = getchar();\n    while('0' <= c && c <= '9') num = num * 10 + c - '0', c = getchar();\n    if(f) num = -num;\n    return num;\n}\n//------------------------   code   ---------------------------------//\nconst int NUM = 100010;\nconst int MAXV = 100 + 10, MAXE = 100 * 2 + 10;\nint cost[MAXV][MAXV];\nstruct node\n{\n    LL a, b;\n    node() {a = b = 0;}\n    void set(int x)\n    {\n        if(x < 64) a |= (1LL << x);\n        else b |= (1LL << (x - 64));\n    }\n    void reset(int x)\n    {\n        if(x < 64) a &= ~(1LL << x);\n        else b &= ~(1LL << (x - 64));\n    }\n    bool get(int x)\n    {\n        if(x < 64) return (a & (1LL << x));\n        else return (b & (1LL << (x - 64)));\n    }\n    bool operator < (const node& x) const\n    {\n        if(a == x.a) return b < x.b;\n        return a < x.a;\n    }\n};\n\nint n, m;\nset<node> st;\nint ans = 0;\nvoid solve(node vis)\n{\n    int res = 0;\n    for(int i = 1; i <= n; ++i)\n    {\n        if(!vis.get(i)) continue;\n        int mn = INF;\n        for(int j = 1; j <= n; ++j)\n        {\n            if(!vis.get(j) || i == j) continue;\n            mn = min(mn, cost[i][j]);\n        }\n        if(mn != INF) res += mn;\n    }\n    ans = max(ans, res);\n}\nvoid dfs(node vis)\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        if(vis.get(i)) continue;\n        vis.set(i);\n        node tmp = vis;\n        for(int j = 1; j <= n; ++j)\n        {\n            if(vis.get(j) && cost[i][j] == 0) vis.reset(i);\n        }\n        if(st.find(tmp) == st.end())\n        {\n            solve(tmp);\n            st.insert(tmp);\n            dfs(tmp);\n        }\n    }\n}\nint main()\n{\n#ifdef ACM_TEST\n    freopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"in.txt\", \"w\", stdout);\n#endif\n    int u, v, w;\n    IN(n), IN(m);\n    for(int i = 0; i < m; ++i)\n    {\n        IN(u), IN(v), IN(w);\n        cost[u][v] = w;\n        cost[v][u] = w;\n    }\n    node vis;\n    dfs(vis);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = std::uint32_t;\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing ld = long double;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(all(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(all(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint n, m;\nint g[100][100];\n\nint dfs(int p, vector<int> &v)\n{\n\tif (p == n){\n\t\tif (v.size() <= 1) return 0;\n\t\tint res = 0;\n\t\trep(i, v.size()){\n\t\t\tint mn = INF;\n\t\t\trep(j, v.size()){\n\t\t\t\tif (i == j) continue;\n\t\t\t\tchmin(mn, g[v[i]][v[j]]);\n\t\t\t}\n\t\t\tres += mn;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tbool f = true;\n\trep(i, v.size()){\n\t\tif (g[p][v[i]] == 0) f = false;\n\t}\n\tint res = 0;\n\tif (f){\n\t\tv.pb(p);\n\t\tchmax(res, dfs(p + 1, v));\n\t\tv.pop_back();\n\t}\n\tchmax(res, dfs(p + 1, v));\n\treturn res;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\trep(i, m){\n\t\tint u, v, f;\n\t\tcin >> u >> v >> f, u--, v--;\n\t\tg[u][v] = f;\n\t\tg[v][u] = f;\n\t}\n\tvector<int> v;\n\tcout << dfs(0, v) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nconst int maxn = 1010;\nconst int inf = 1 << 29;\nconst double eps = 1e-8;\nint n,m;\n#define N 110\nint g[110][110];\nbool r[110][110];\nint d[110][110];\nint p[N][N];\nbool x[N][N];\nint ans;\nvoid BronKerbosch2(int dep)\n{\n    int v=0;\n//    cout<<dep<<endl;\n//    cout<<\"ANSSSS\"<<ans<<endl;\n    for(int i=0;i<n;i++)\n    {\n        if(d[dep][i]<inf)v+=d[dep][i];\n//        cout<<d[dep][i]<<' ';\n    }\n//    cout<<endl;\n    ans=max(v,ans);\n//    cout<<\"ANS\"<<ans<<endl;\n    int u=-1;\n    for(int i=0;i<n;i++)\n    {\n        if(p[dep][i]||x[dep][i])\n        {\n            u=i;break;\n        }\n    }\n    if(u<0)\n    {\n        return;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(p[dep][i]<inf&&!g[u][i])\n        {\n            for(int j=0;j<n;j++)\n            {\n                d[dep+1][j]=inf;\n                r[dep+1][j]=false;\n                p[dep+1][j]=inf;\n                x[dep+1][j]=false;\n            }\n            for(int j=0;j<n;j++)\n            {\n                r[dep+1][j]=r[dep][j]||(j==i);\n                if(r[dep][j]&&j!=i)\n                {\n                    d[dep+1][j]=min(d[dep][j],g[i][j]);\n                    d[dep+1][i]=min(d[dep+1][i],g[i][j]);\n                }\n                p[dep+1][j]=min(p[dep][j],g[i][j]);\n                x[dep+1][j]=x[dep][j]&&g[i][j];\n            }\n            BronKerbosch2(dep+1);\n            p[dep][i]=0;\n            x[dep][i]=true;\n        }\n    }\n}\n\nint main() {\n    #ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    #endif\n\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                g[i][j]=0;\n            }\n        }\n\n        for(int i=0;i<m;i++)\n        {\n            int u,v,f;\n            scanf(\"%d%d%d\",&u,&v,&f);\n            u--,v--;\n            g[u][v]=f;\n            g[v][u]=f;\n        }\n\n        for(int i=0;i<n;i++)\n            d[0][i]=p[0][i]=inf,r[0][i]=x[0][i]=false;\n\n        ans=0;\n\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                d[1][j]=inf;\n                r[1][j]=false;\n                p[1][j]=inf;\n                x[1][j]=false;\n            }\n            for(int j=0;j<n;j++)\n            {\n                r[1][j]=r[0][j]||(i==j);\n                p[1][j]=min(p[0][j],g[i][j]);\n                x[1][j]=x[0][j]&&g[i][j];\n            }\n//            cout<<\"ANSS\"<<ans<<endl;\n            BronKerbosch2(1);\n            p[0][i]=0;\n            x[0][i]=true;\n        }\n\n        cout<<ans<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\nint n, m, d[N][N];\nint used[N],ans=0;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n    \n    int sum=0;\n  \n    for(int i=0;i<G.size();i++){\n    \n      if(!used[G[i]]) continue;\n    \n      int mincost=INF;\n    \n      for(int j=0;j<G.size();j++){\n      \n\tif(!used[G[j]]) continue;\n      \n\tif(G[i]!=G[j]) mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n  }\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n    \n    if(used[i]) continue;\n\n    used[i]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(i);\n    \n    for(int j=0;j<G.size();j++)\n\n      if(i!=j&&used[G[j]]) mincost=min(mincost,d[i][G[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n    \n    used[i]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<m;i++){\n\n    cin>>a>>b>>f;\n\n    d[a-1][b-1]=d[b-1][a-1]=f;\n  }\n\n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, G[100][100];\n\nint dfs(int idx, vector< int > used)\n{\n  if(idx == N) {\n    if(used.size() <= 1) return (0);\n    int res = 0;\n    for(int i : used) {\n      int ret = 11451419;\n      for(int j : used) if(i != j) ret = min(ret, G[i][j]);\n      res += ret;\n    }\n    return (res);\n  } else {\n    int res = dfs(idx + 1, used);\n\n    bool isnext = true;\n    for(int i : used) if(G[idx][i] == 0) isnext = false;\n    if(isnext) {\n      used.push_back(idx);\n      res = max(res, dfs(idx + 1, used));\n    }\n    return (res);\n  }\n}\n\nint main()\n{\n  cin >> N >> M;\n  for(int i = 0; i < M; i++) {\n    int A, B, C;\n    cin >> A >> B >> C;\n    --A, --B;\n    G[A][B] = G[B][A] = C;\n  }\n\n  cout << dfs(0, vector< int >()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\nint n, m;\nvector<vector<pair<int,ll>>> G;\nvector<vector<int>> E; // 辺が存在するかどうか\n\nbool clique(vector<int> &vec){\n    for(auto e : vec){\n        for(auto f : vec){\n            if(!E[e][f] && e != f){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nll dfs(int v, vector<int> &vec){\n    if(v == n){\n        if(vec.size() <= 1) return false;\n        ll ret = 0;\n        for(int i = 0; i < vec.size(); ++i){\n            ll tmp = INF;\n            for(int j = 0; j < vec.size(); ++j){\n                if(i != j) chmin(tmp, (ll)E[vec[i]][vec[j]]);\n            }\n            ret += tmp;\n        }\n        return ret;\n    }\n    \n    ll ret1 = dfs(v + 1, vec);\n    ll ret2 = 0;\n    // vを加えてもクリーク\n    vec.push_back(v);\n    if(clique(vec)){\n        ret2 = dfs(v + 1, vec);\n    }\n    vec.pop_back();\n    \n    ll ret = max(ret1, ret2);\n\n    return ret;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    G.resize(n);\n    E.resize(n, vector<int>(n, 0));\n    \n    REP(i, m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        a--, b--;\n        G[a].push_back(pair<int, ll>(b,c));\n        G[b].push_back(pair<int, ll>(a,c));\n        E[a][b] = E[b][a] = c;\n    }\n    \n    vector<int> vec;\n    ll ans = dfs(0, vec);\n    \n    cout << ans << endl;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdlib>\nusing namespace std;\n\nint res;\nint n;\nint f[128][128];\nvector<int> inv;\n\nvoid dfs(const vector<int> &v){\n\tif(v.size() > 2){\n\t\tres = max(res, accumulate(v.begin(), v.end(), 0));\n\t}\n\tvector<int> w(v.size() + 1);\n\tfor(int i = inv.back() + 1; i <= n; ++i){\n\t\tint r = 1010101010;\n\t\tfor(size_t j = 1; r && j < v.size(); ++j){\n\t\t\tw[j] = min(v[j], f[i][inv[j]]);\n\t\t\tr = min(r, f[i][inv[j]]);\n\t\t}\n\t\tif(r){\n\t\t\tinv.push_back(i);\n\t\t\tw.back() = r;\n\t\t\tdfs(w);\n\t\t\tinv.pop_back();\n\t\t}\n\t}\n}\n\nint main(){\n\tint m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < m; ++i){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tf[a][b] = f[b][a] = c;\n\t}\n\tinv.assign(1, 0);\n\tvector<int> v(1);\n\tdfs(v);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint dfs(vector<vector<int>> const& g, int v, int inv_num, vector<int>& invited) {\n    const int N = g.size();\n    int res = 0;\n    if(inv_num == 0) {\n        for(auto i : invited) {\n            int t = INF;\n            for(auto j : invited) {\n                if(i == j) {\n                    continue;\n                }\n                t = min(t, g[i][j]);\n            }\n            res += t;\n        }\n        return res == INF ? 0 : res;\n    }\n    if(v == N) {\n        return 0;\n    }\n    for(auto u : invited) {\n        if(g[v][u] == 0) {\n            return dfs(g, v+1, inv_num, invited);\n        }\n    }\n    invited.push_back(v);\n    res = max(res, dfs(g, v+1, inv_num-1, invited));\n    invited.pop_back();\n    res = max(res, dfs(g, v+1, inv_num, invited));\n    return res;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n, vector<int>(n));\n    for(int i=0; i<m; ++i) {\n        int u, v, f;\n        cin >> u >> v >> f;\n        u--; v--;\n        g[u][v] = g[v][u] = f;\n    }\n    int res = 0;\n    for(int i=0; i*(i-1)/2 <= m; ++i) {\n        vector<int> invited;\n        res = max(res, dfs(g, 0, i, invited));\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define ECH(it, A) for (__typeof(A.begin()) it = A.begin(); it != A.end(); ++it)\n#define RST(A) memset(A, 0, sizeof(A))\n#define FLC(A, x) memset(A, x, sizeof(A))\n#define PB push_back\n\ntemplate<class T> void checkMin(T &a, T b){if (b < a) a = b;}\ntemplate<class T> void checkMax(T &a, T b){if (b > a) a = b;}\n\ntypedef double DB;\ntypedef vector<int> VI;\nconst int INF = 0x3f3f3f3f;\n\nconst int N = int(1e2) + 9, NN = 16;\nint G[N][N];\nint n;\n\nint Aid[NN], A[NN], An, ans;\n\nbool ok(int v){\n    REP(i, An){\n        int u = Aid[i];\n        if (!G[u][v]) return false;\n    }\n    return true;\n}\n\nvoid dfs(){\n\n    if (An > 1){\n        int cur = 0; REP(i, An) cur += A[i]; checkMax(ans, cur);\n    }\n\n    int AA[NN]; REP(i, An) AA[i] = A[i];\n    int st = An ? Aid[An-1]+1 : 0;\n\n    FOR(v, st, n){\n\n        if (!ok(v)) continue;\n\n        A[An] = INF; REP(i, An){\n            int u = Aid[i];\n            checkMin(A[i], G[u][v]);\n            checkMin(A[An], G[u][v]);\n        }\n\n        if (!ok) continue;\n        Aid[An] = v; ++An; dfs(); --An;\n        REP(i, An) A[i] = AA[i];\n    }\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    int m; while (~scanf(\"%d%d\", &n, &m)){\n\n        RST(G); DO(m){\n            int u, v, w; scanf(\"%d%d%d\", &u, &v, &w); --u, --v;\n            G[u][v] = G[v][u] = w;\n        }\n\n        ans = 0; dfs();\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<numeric>\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int N=100;\ntypedef array<int,N> INTARRAY;\ntypedef array<bool,N> BOOLARRAY;\n\nint d[N][N];\n\nint sum(INTARRAY ia){\n  int s=accumulate(begin(ia),end(ia),0);\n  return (s==INF)?0:s;\n}\n\nint dfs(BOOLARRAY ba,INTARRAY ia,int n){\n  int s=sum(ia);\n  if(n==N)return s;\n  int r=dfs(ba,ia,n+1);\n  BOOLARRAY cba=ba;\n  cba[n]=true;\n  INTARRAY cia=ia;\n  cia[n]=INF;\n  bool f=false;\n  for(int i=0;i<n;i++){\n    if(cba[i]){\n      cia[i]=min(cia[i],d[n][i]);\n      cia[n]=min(cia[n],d[n][i]);\n      f|=cia[i]==0;\n      f|=cia[n]==0;\n    }\n  }\n  if(!f){\n    r=max(r,dfs(cba,cia,n+1));\n  }\n  return r;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    d[i][i]=INF;\n  }\n  int n,m;\n  cin>>n>>m;\n  while(m--){\n    int u,v,f;\n    cin>>u>>v>>f;\n    u--;\n    v--;\n    d[u][v]=d[v][u]=f;\n  }\n  int ans=0;\n  for(int i=0;i<N;i++){\n    BOOLARRAY ba={};\n    ba[i]=true;\n    INTARRAY ia={};\n    ia[i]=INF;\n    ans=max(ans,dfs(ba,ia,i+1));\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<utility>\n#include<climits>\n#include<cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\n\nset<pii> S;\n\nconst int maxn=128;\nint f[maxn][maxn];\n\nint N;\n\nint curi[maxn],curn;\nint curv[16];\nint best;\n\ninline bool in(int i,const pii& p){\n\tif(i<60)\n\t\treturn ((1ll<<i)&p.first)!=0;\n\treturn ((1ll<<(i-60))&p.second)!=0;\n}\n\npii add(int i,const pii& p){\n\tpii q=p;\n\tif(i<60)\n\t\tq.first |= (1ll<<i);\n\telse\n\t\tq.second |= (1ll<<(i-60));\n\treturn q;\n}\n\nvoid search(pii p,int k){\n\tif(S.count(p))return;\n\tS.insert(p);\n\t//printf(\"-- %lld\\n\",p.first);\n\tfor(int i=k;i<N;++i){\n\t\tif(in(i,p))continue;\n\t\tint j;\n\t\tcurv[curn]=INT_MAX;\n\t\tfor(j=0;j<curn;++j){\n\t\t\tcurv[curn]=min(curv[curn],f[i][curi[j]]);\n\t\t\tif(curv[curn]==0)break;\n\t\t}\n\t\tif(j!=curn)continue;\n\t\tint d[16];\n\t\tmemcpy(d,curv,sizeof(d));\n\t\tint now=curv[curn];\n\t\tfor(j=0;j<curn;++j){\n\t\t\tcurv[j]=min(curv[j],f[curi[j]][i]);\n\t\t\tnow+=curv[j];\n\t\t}\n\t\tcuri[curn++]=i;\n\t\tif(curn>1){\n\t\t\tif(now>best)best=now;\n\t\t}\n\t\t/*if(curn==2){\n\t\t\tfor(int i=0;i<curn;++i)\n\t\t\t\tprintf(\"%d %d\\n\",curi[i],curv[i]);\n\t\t}*/\n\t\tpii q=add(i,p);\n\t\tsearch(q,i+1);\n\t\t--curn;\n\t\tmemcpy(curv,d,sizeof(d));\n\t}\n}\n\nint main(){\n\tint M;\n\twhile(2==scanf(\"%d%d\",&N,&M)){\n\t\tmemset(f,0,sizeof(f));\n\t\tbest=0;\n\t\tS.clear();\n\t\twhile(M--){\n\t\t\tint a,b,x;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&x);\n\t\t\t--a,--b;\n\t\t\tf[a][b]=f[b][a]=x;\n\t\t}\n\t\tcurn=0;\n\t\tsearch(pii(0,0),0);\n\t\tprintf(\"%d\\n\",best);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\nint n, m, f[110][110], deg[110];\nvector< int > cand, sel;\n\nint calc() {\n\tint res = 0;\n\tfor_(i,0,size_of(sel)) {\n\t\tint mn = 1e9;\n\t\tfor_(j,0,size_of(sel)) if (j != i) mn = min(mn, f[sel[i]][sel[j]]);\n\t\tres += mn;\n\t}\n\treturn res;\n}\n\nint rec(int i, int s, int k) {\n\tif (s == k) return calc();\n\tif (i == size_of(cand)) return 0;\n\t\n\tint res = rec(i+1, s, k);\n\t\n\tsel.push_back(cand[i]);\n\tres = max(res, rec(i+1, s+1, k));\n\tsel.pop_back();\n\t\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> m;\n\t\n\tminit(f,0);\n\tminit(deg,0);\n\t\n\tfor_(i,0,m) {\n\t\tint u, v, p; cin >> u >> v >> p;\n\t\t--u; --v;\n\t\tf[v][u] = f[u][v] = p;\n\t\t++deg[u]; ++deg[v];\n\t}\n\t\n\tint ans = 0;\n\tfor_(i,2,15) {\n\t\tcand.clear();\n\t\tfor_(j,0,n) if (deg[j] >= i - 1) cand.push_back(j);\n\t\tif (size_of(cand) >= i) ans = max(ans, rec(0, 0, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\nint n, m, d[N][N];\nint used[N],ans=0;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n    \n    int sum=0;\n  \n    for(int i=0;i<n;i++){\n    \n      if(!used[i]) continue;\n    \n      int mincost=INF;\n    \n      for(int j=0;j<n;j++){\n      \n\tif(!used[j]) continue;\n      \n\tif(i!=j) mincost=min(mincost,d[i][j]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n  }\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n    \n    if(used[i]) continue;\n\n    used[i]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(i);\n    \n    for(int j=0;j<G.size();j++)\n\n      if(i!=j&&used[G[j]]) mincost=min(mincost,d[i][G[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n    \n    used[i]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<m;i++){\n\n    cin>>a>>b>>f;\n\n    d[a-1][b-1]=d[b-1][a-1]=f;\n  }\n\n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\nusing namespace std;\nint tem,tmp,ans,a,b,n,m;\nint f[111][111],q[111],head;\nvoid dfs(int o){\n\tif(o>n){\n\t\tif(head==1)return;\n\t\ttem=0;\n\t\tfor(int i=0;i<head;++i){\n\t\t\ttmp=0x3f3f3f3f;\n\t\t\tfor(int j=0;j<head;++j){\n\t\t\t\tif(i!=j)tmp=min(tmp,f[q[i]][q[j]]);\n\t\t\t}\n\t\t\ttem+=tmp;\n\t\t}\n\t\tans=max(ans,tem);\n\t\treturn;\n\t}\n\tfor(int i=0;i<head;++i){\n\t\tif(f[q[i]][o]==0)return;\n\t}\n\tq[head++]=o;\n\tdfs(o+1);\n\thead--;\n\tdfs(o+1);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tscanf(\"%d\",&f[a][b]);\n\t\tf[b][a]=f[a][b];\n\t}\n\tdfs(1);\n\tprintf(\"%d\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define INF (1<<30)\nconst int N=105;\nint n,m;\nint adj[N][N],set[N],res,sum;\nbool judge(int ind,int cnt)\n{\n    for(int i=0;i<cnt;i++)\n    {\n        if(adj[ind][set[i]]==0) return false;\n    }\n    return true;\n}\nint calu(int cnt)\n{\n    if(cnt<=1) return 0;\n    int sum=0;\n    for(int i=0;i<cnt;i++)\n    {\n        int imin=INF;\n        for(int j=0;j<cnt;j++)\n        {\n            if(i==j) continue;\n            imin=min(imin,adj[set[i]][set[j]]);\n        }\n        sum+=imin;\n    }\n    return sum;\n}\nvoid dfs(int ind,int cnt)\n{\n   // cout<<ind<<\" \"<<cnt<<endl;\n    if(ind==n+1)\n    {\n        res=max(res,calu(cnt));\n        return;\n    }\n    if(judge(ind,cnt))\n    {\n        set[cnt]=ind;\n        dfs(ind+1,cnt+1);\n    }\n    dfs(ind+1,cnt);\n}\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        res=sum=0;\n        memset(adj,0,sizeof(adj));\n        memset(set,0,sizeof(set));\n\n        for(int i=0;i<m;i++)\n        {\n            int a,b,c;  scanf(\"%d%d%d\",&a,&b,&c);\n            adj[a][b]=adj[b][a]=c;\n        }\n        dfs(1,0);\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<cstring>\n\n\nusing namespace std;\n\ntypedef long long ll;\nconst int NODE = 101;\nconst int INF = (1<<28);\nint N,M;\nint fri[NODE][NODE];\nbool used[NODE];\nset<int> edge;\nint cnt = 0;\n\nstruct State{\n  ll A,B; // state -> AB\n  static const bool debug = false;\n  State operator & (const State& st) const {\n    State res;\n    res.A = A&st.A;\n    res.B = B&st.B;\n    return res;\n  }\n\n  void turnOn(int n){\n    if(debug) cout << \"turnOn \" << n << endl;\n    if(debug) cout << A << \", \" << B << \" -> \";\n    if(n < 64) A |= (1LL<<n);\n    else B |= (1LL<<(n-64));\n    if(debug) cout << A << \", \" << B << endl;\n  }\n\n  void toggle(int n){\n    if(debug) cout << \"turnOff \" << n << endl;\n    if(debug) cout << A << \", \" << B << \" -> \";\n    if(n < 64) A ^= (1LL<<n);\n    else B ^= (1LL<<(n-64));\n    if(debug) cout << A << \", \" << B << \" -> \";\n  }\n\n  bool getAt(int n) const {\n    return n<64?(A&(1LL<<n)):(B&(1LL<<(64-n)));\n  }\n\n  int count() const {\n    return __builtin_popcountll(A) + __builtin_popcountll(B);\n  }\n};\n\nvoid input(){\n  memset(fri, 0, sizeof(fri));\n  edge.clear();\n\n  cin >> N >> M;\n  for(int i = 0; i < M; i++){\n    int a,b,f;\n    cin >> a >> b >> f;\n    a--; b--;\n    fri[a][b] = fri[b][a] = f;\n    edge.insert(f);\n  }\n}\n\nll find(int now, vector<int>& v, const int& lb, State& st){\n  \n  //  cout << st.count() << endl;\n\n  //  cout << cnt++ << endl;\n  ll res = -1;\n  for(int i = 0; i < N; i++){\n    if(fri[now][i] >= lb && !(st.getAt(i)) && !used[i]){\n      used[i] = true;\n      for(int j = 0; j < N; j++) if(i != j) v[j] = min(v[j], fri[i][j]);\n      st.turnOn(i);\n      res = max(res, find(i, v, lb, st));\n      st.toggle(i);\n    }\n  }\n  \n  if(res < 0 && st.count() > 1){\n    res = 0;\n    for(int i = 0; i < N; i++) if(st.getAt(i)) res += v[i];\n  }\n  return res;\n}\n\n\nvoid solve(){\n  long long ans = 0;\n  for(set<int>::iterator ite = edge.begin(); ite != edge.end(); ite++)\n    for(int i = 0; i < N; i++){\n      memset(used, false, sizeof(used));\n      vector<int> cost(NODE, INF);\n      for(int j = 0; j < N; j++) if(i != j) cost[j] = fri[i][j];\n      used[i] = true;\n      State st = (State){0,0};\n      st.turnOn(i);\n      ans = max(ans, find(i, cost, *ite, st));\n    }\n  cout << ans << endl;\n}\n\nvoid TEST(){\n  \n  State st = (State){0,0};\n  st.turnOn(80);\n  cout << st.A << \" \" << st.B << endl;\n  exit(0);\n}\nint main(){\n  //TEST();\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint ans;\nvector<int> neighbors[100];\nset< set<int> > used;\nint weight[100][100];\n\nvoid dfs(set<int> vs){\n\tif( used.count(vs) ) return;\n\n\t\n\tint score = 0;\n\tif( vs.size() > 1 ){\n\t\tfor( auto &&i : vs ){\n\t\t\tint c = 1e9;\n\t\t\tfor( auto &&j : vs ){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tc = min(weight[i][j],c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tscore += c;\n\t\t}\n\t}\n\tans = max(ans,score);\n\t\n\n\tconst int representative = *vs.begin();\n\t\n\tint cost[100];\n\tfor( auto &&i : neighbors[representative])\n\t\t cost[i] = 1e9;\n\t\n\tfor( auto &&i : vs ){\n\t\tfor( auto &&j : neighbors[representative]){\n\t\t\tcost[j] = min(weight[i][j],cost[j]);\n\t\t}\n\t}\n\tfor( auto &&i : neighbors[representative])\n\t\tif( !vs.count(i) and cost[i] > 0 ){\n\t\t\tset<int> nvs = vs;\n\t\t\tnvs.insert(i);\n\t\t\tdfs(nvs);\n\t\t}\n\t\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\t--a,--b;\n\t\tweight[a][b] = c;\n\t\tweight[b][a] = c;\n\t\tneighbors[a].push_back(b);\n\t\tneighbors[b].push_back(a);\n\t}\n\tans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdfs({i});\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint n, m, g[128][128], deg[128];\n\nint rec(int ix, int rem, const vector<int>& u, const vector<int>& cs) {\n    if(rem==0) {\n        int ans = 0;\n        rep(i, u.size()) if(u[i]==1) {\n            int t = INT_MAX;\n            rep(j, u.size()) if(i!=j && u[j]==1) t = min(t, g[cs[i]][cs[j]]);\n            ans += t;\n        }\n        return ans;\n    }\n    int c = 0;\n    for(int i=ix; i<(int)u.size(); i++) if(u[i]==0) c++;\n    if(ix==(int)u.size() || c<rem) return 0;\n    int ans = 0;\n    if(u[ix]!=-1) {\n        vector<int> w(u);\n        w[ix] = 1;\n        rep(i, w.size()) if(i!=ix && g[cs[ix]][cs[i]]==0) w[i] = -1;\n        ans = max(ans, rec(ix+1, rem-1, w, cs));\n    }\n    ans = max(ans, rec(ix+1, rem, u, cs));\n    return ans;\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    rep(i, m) {\n        int u, v, f;\n        scanf(\"%d%d%d\", &u, &v, &f);\n        u--, v--;\n        g[u][v] = g[v][u] = f;\n        deg[u]++, deg[v]++;\n    }\n    int ans = 0;\n    rep(i, n) rep(j, i) ans = max(ans, g[i][j]*2);\n    rep(i, n) rep(j, i) if(g[i][j]) rep(k, j) if(g[k][i] && g[k][j]) {\n        const int s = min(g[i][j], g[i][k])\n                + min(g[j][i], g[j][k])\n                + min(g[k][i], g[k][j]);\n        ans = max(ans, s);\n    }\n    for(int k=4; k<15; k++) {\n        vector<int> cs;\n        rep(i, n) if(deg[i]>=k-1) cs.push_back(i);\n        ans = max(ans, rec(0, k, vector<int>(cs.size(), 0), cs));\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n  int n, m;\n  while (cin >> n >> m && n + m){\n    int score[110][110];\n    memset(score, 0, sizeof(score));\n\n    REP(i, m){\n      int x, y, f;\n      cin >> x >> y >> f; x--, y--;\n      score[x][y] = score[y][x] = f;\n    }\n\n    int res = 0;\n    REP(i, n){\n      vector<int> fs;\n      REP(j, n) if (score[i][j] > 0){\n        fs.push_back(j);\n      }\n      \n      int size = fs.size();\n      if (size * (size - 1) / 2 <= m){\n\n        \n        REP2(mask, 1, 1 << size){\n          \n          vector<int> vs(1, i);\n          REP(j, size) if (mask & (1 << j)){\n            vs.push_back(fs[j]);\n          }\n          \n          int sum = 0;\n          REP(j, vs.size()){\n            int add = 1e9;\n            REP(k, vs.size()) if (j != k) {\n              add = min(add, score[vs[j]][vs[k]]);\n            }\n            sum += add;\n          }\n          res = max(res, sum);\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\ntemplate <typename T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n//const ll mod = 1000000007;\nint N, M;\nbitset<100> bits[100];\nbitset<100> Zero;\nint A[100][100];\nint ans;\nvoid dfs(bitset<100> now, bitset<100> can, int vertex) {\n    /*\n    cerr << \"-----\" << endl;\n    cerr << now << endl;\n    cerr << can << endl;\n    cerr << vertex << endl;\n    cerr << \"-----\" << endl;\n    */\n    if(now.count() >= 2) {\n        int score = 0;\n        for(int i = 0; i < N; i++) {\n            if(!now[i]) continue;\n            int nowscore = 1e9;\n            for(int j = 0; j < N; j++) {\n                if(!now[j]) continue;\n                if(i == j) continue;\n                chmin(nowscore, A[i][j]);\n            }\n            score += nowscore;\n        }\n        chmax(ans, score);\n    }\n    for(int i = vertex; i < N; i++) {\n        if(!can[i]) {\n            //cerr << \"ng: \" << vertex << \" \" << i << endl;\n            continue;\n        }\n        auto sub = now;\n        sub[i] = true;\n        auto sub2 = can;\n        sub2 &= bits[i];\n        //cerr << \"ok : \" << vertex << \" \" << i << endl;\n        dfs(sub, sub2, i + 1);\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        A[a][b] = c;\n        A[b][a] = c;\n        bits[a][b] = true;\n        bits[b][a] = true;\n    }\n    bitset<100> One;\n    for(int i = 0; i < N; i++) One[i] = true;\n    dfs(Zero, One, 0);\n    cout << ans << endl;\n    /*\n    for(int i = 0; i < N; i++) {\n        cerr << bits[i] << endl;\n    }\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint n,m;\nlong a[101][101];\nint v[101],viz[101];\nlong maxim;\n\nvoid bkt(int poz, int sol)\n{\n    if(poz==sol+1)\n    {\n        long minim=0,suma=0;\n        for(int j=1; j<=sol; ++j)\n        {\n            minim=a[v[1]][v[j]];\n            for(int i=1; i<=sol; ++i)\n                minim=min(minim, a[v[i]][v[j]]);\n            suma+=minim;\n        }\n        maxim=max(maxim, suma);\n    }\n     else\n        {\n         for(int i=v[poz-1]+1;i<=n-sol+poz;++i)\n            {\n             if(!viz[i])\n                {\n                 v[poz]=i;\n                 viz[i]=1;\n                 bkt(poz+1, sol);\n                 viz[i]=0;\n                }\n            }\n        }\n}\n\nint main()\n{\n    cin>>n>>m;\n    int u=0,v=0;\n    long f=0;\n    char s[21];\n    cin.get();\n    for(int j=1; j<=m; j++)\n    {\n        //cin>>u>>v>>f;\n        cin.getline(s,20);\n        int i=0;\n        u=v=f=0;\n        while(s[i]!=' ')\n            {\n             u=u*10+s[i]-'0';\n             ++i;\n            }\n        ++i;\n        while(s[i]!=' ')\n            {\n             v=v*10+s[i]-'0';\n             ++i;\n            }\n        ++i;\n        while(s[i]!=NULL)\n            {\n             f=f*10+s[i]-'0';\n             ++i;\n            }\n        a[u][v]=a[v][u]=f;\n    }\n\n    for(int i=1;i<=n;++i) a[i][i]=1000001;\n\n    for(int i=2; i<=n; i++) bkt(1,i);\n\n    cout<<maxim;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n//li chao tree by ei1333. It's public available.\n// https://ei1333.github.io/luzhiled/snippets/structure/li-chao-tree.html\n/*\ntemplate< typename T >\nstruct LiChaoTree {\n    struct Line {\n        T a, b;\n\n        Line(T a, T b) : a(a), b(b) {}\n\n        inline T get(T x) const { return a * x + b; }\n\n        inline bool over(const Line& b, const T& x) const {\n            return get(x) < b.get(x);\n        }\n    };\n\n    vector< T > xs;\n    vector< Line > seg;\n    int sz;\n\n    LiChaoTree(const vector< T >& x, T INF) : xs(x) {\n        sz = 1;\n        while (sz < xs.size()) sz <<= 1;\n        while (xs.size() < sz) xs.push_back(xs.back() + 1);\n        seg.assign(2 * sz - 1, Line(0, INF));\n    }\n\n    void update(Line& x, int k, int l, int r) {\n        int mid = (l + r) >> 1;\n        auto latte = x.over(seg[k], xs[l]), malta = x.over(seg[k], xs[mid]);\n        if (malta) swap(seg[k], x);\n        if (l + 1 >= r) return;\n        else if (latte != malta) update(x, 2 * k + 1, l, mid);\n        else update(x, 2 * k + 2, mid, r);\n    }\n\n    void update(T a, T b) { // ax+b\n        Line l(a, b);\n        update(l, 0, 0, sz);\n    }\n\n    T query(int k) { // xs[k]\n        const T x = xs[k];\n        k += sz - 1;\n        T ret = seg[k].get(x);\n        while (k > 0) {\n            k = (k - 1) >> 1;\n            ret = min(ret, seg[k].get(x));\n        }\n        return ret;\n    }\n};\n\n#define int long long\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> landmarks;\n    vector<vector<int>> costs;\n    REP(i, n) {\n        vector<int> tmp;\n        REP(q, m) {\n            int b;\n            cin >> b;\n            b = xor128() % 10000000;\n            tmp.push_back(b);\n        }\n        landmarks.push_back(tmp);\n    }\n    REP(i, n) {\n\n        vector<int> tmp;\n        {\n            REP(q, m) {\n                int b;\n                cin >> b;\n                b = xor128() % 100000000;\n                tmp.push_back(b);\n            }\n        }\n        costs.push_back(tmp);\n    }\n    vector<LiChaoTree<int>> yoko; // size should be m\n    REP(i, n) {\n        vector<int> hoge(m);\n        REP(q, m) {\n            hoge[q] = q;\n        }\n        LiChaoTree<int> now(hoge, 1e18);//size should be n\n        yoko.push_back(now);\n    }\n    vector<vector<int>> dp = landmarks;\n    for (int q = 0; q < m; ++q) {\n        vector<int> hoge(n);\n        REP(i, n) {\n            hoge[i] = i;\n        }\n        LiChaoTree<int> now(hoge, 1e18);//size should be n\n\n        for (int i = 0; i < n; ++i) {\n            int now_min = costs[0][0] * (i + q);\n            if (q < 0) {\n                int geko = yoko[i].query(q);\n                now_min = min(now_min, geko);\n            }\n            if (i != 0) {\n                int geko = now.query(i);\n                now_min = min(now_min, geko);\n            }\n            dp[i][q] = now_min;\n            yoko[i].update(costs[i][q], landmarks[i][q] + dp[i][q] - q * costs[i][q]);\n            now.update(costs[i][q], landmarks[i][q] + dp[i][q] - i * costs[i][q]);\n        }\n    }\n\n    cout << dp[n - 1][m - 1] << endl;\n}\n*/\n\n#define int ll\nint used[200];\nvector<int> kouho;\nset<pair<int,int>> already;\nint dist[200][200];\nint n, m;\n\nint dfs(int now,pair<int,int> bit) {\n    if (now < 50) {\n        bit.first += (1LL << now);\n    }\n    else {\n        bit.second += (1LL << (now - 50));\n    }\n    if (already.count(bit)) {\n        return 0;\n    }\n    used[now] = 1;\n    kouho.push_back(now);\n    already.insert(bit);\n    for (int i = 0; i < n; ++i) {\n        if (used[i]) continue;\n        int ok = 1;\n        REP(q, kouho.size()) {\n            if (dist[kouho[q]][i] == 0) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok == 0) continue;\n        dfs(i, bit);\n    }\n    kouho.pop_back();\n    used[now] = 0;\n    return 0;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    REP(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        dist[a][b] = c;\n        dist[b][a] = c;\n    }\n    int ans = 0;\n    REP(i, n) {\n        ans = max(ans, dfs(i, pair<int, int>{0, 0}));\n   }\n    for (auto x : already) {\n        vector<int> huku;\n        for (int q = 0; q < 51; ++q) {\n            if ((1LL << q) & x.first) {\n                huku.push_back(q);\n            }\n            if ((1LL << q) & x.second) {\n                huku.push_back(q + 50);\n            }\n        }\n        if (huku.size() == 1) continue;\n        int tmp = 0;\n        REP(q, huku.size()) {\n            int hoge = 1e9;\n            REP(j, huku.size()) {\n                if (q == j) continue;\n                hoge = min(hoge, dist[huku[q]][huku[j]]);\n            }\n            tmp += hoge;\n        }\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int MAXN=100+10;\nstruct edge\n{\n    int to,cost;\n    bool operator <(const edge &a) const\n    {\n        return cost>a.cost;\n    }\n};\n\nvector<edge> G[MAXN];\nvoid add_edge(int from,int to,int cost)\n{\n    G[from].push_back((edge){to,cost});\n    G[to].push_back((edge){from,cost});\n}\nbool vis[MAXN];\nint m,n;\nint get(int u)\n{\n    int ans=1<<30;\n    for(int i=0;i<G[u].size();i++)\n        if(vis[G[u][i].to]) ans=min(ans,G[u][i].cost);\n    return ans;\n}\nint main()\n{\n//    freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        for(int i=1;i<=n;i++) G[i].clear();\n        for(int i=0;i<m;i++)\n        {\n            int u,v,c;\n            scanf(\"%d%d%d\",&u,&v,&c);\n            add_edge(u,v,c);\n        }\n        int ans=0;\n        for(int i=1;i<=n;i++)\n        {\n            vector<edge> &p=G[i];\n            sort(p.begin(),p.end());\n            memset(vis,0,sizeof(vis));\n            vis[i]=true;\n            for(int j=0;j<p.size();j++)\n            {\n                edge e=p[j];\n                vis[e.to]=true;\n                int one=e.cost;\n                for(int k=0;k<=j;k++)\n                    one+=get(p[k].to);\n                ans=max(ans,one);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint n;\nint g[128][128];\nint res;\nvector<int> used;\nvoid dfs(int depth)\n{\n    if (depth == n)\n    {\n        if (used.size() >= 2)\n        {\n            int score = 0;\n            rep(i, used.size())\n            {\n                int s = ten(9);\n                rep(j, used.size())\n                    if (i != j)\n                        chmin(s, g[used[i]][used[j]]);\n                score += s;\n            }\n            chmax(res, score);\n        }\n        return;\n    }\n\n    dfs(depth + 1);\n\n    bool can_use = true;\n    rep(i, used.size())\n        can_use &= g[used[i]][depth] != -1;\n    if (can_use)\n    {\n        used.pb(depth);\n        dfs(depth + 1);\n        used.pop_back();\n    }\n}\nint main()\n{\n    int m;\n    cin >> n >> m;\n    CL(g, -1);\n    rep(i, m)\n    {\n        int u, v, f;\n        cin >> u >> v >> f;\n        --u, --v;\n        g[u][v] = g[v][u] = f;\n    }\n\n    dfs(0);\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nint N,M;\nint graph[100][100];\n\nbool friendly(vector<int>& u, int k)\n{\n\tfor(int i=0; i<u.size(); i++) \n\t\tif(graph[u[i]][k] == 0) return false;\n\n\treturn true;\n}\n\nint solve(vector<int>& u, int k)\n{\n\tint res = 0;\n\tfor(int i=k; i<N; i++) {\n\t\tif(!friendly(u, i)) continue;\n\n\t\tint tc = 0;\n\t\tu.push_back(i);\n\n\t\tif(u.size() > 1) {\n\t\t\tfor(int j=0; j<u.size(); j++) {\n\t\t\t\tint v = (1<<28);\n\t\t\t\tfor(int k=0; k<u.size(); k++) {\n\t\t\t\t\tif(j==k) continue;\n\t\t\t\t\tv = min(v, graph[u[j]][u[k]]);\n\t\t\t\t}\n\t\t\t\ttc += v;\n\t\t\t}\n\t\t}\n\n\t\tres = max(res, tc);\n\t\tres = max(res, solve(u,i+1));\n\n\t\tu.pop_back();\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tmemset(graph,0,sizeof(graph));\n\n\tcin >> N >> M;\n\tfor(int i=0; i<M; i++) {\n\t\tint s,t,c;\n\t\tcin >> s >> t >> c;\n\t\ts--; t--;\n\n\t\tgraph[s][t] = graph[t][s] = c;\n\t}\n\n\tvector<int> a;\n\tcout << solve(a, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint solve(vector< vector<int> > &G, int n, int m){\n  if(!m) return 0;\n  int ret = 0;\n  for(int i = 0; i < n; ++i){\n    vector<int> V;\n    int m_ = sqrt(2*m);\n    for(int j = 0; j < n; ++j){\n      if(G[i][j] > 0) V.push_back(j);\n    }\n    if(V.size() < m_){\n      int n_ = V.size();\n      for(int j = 0; j < (1<<n_); ++j){\n        vector<int> V_(1,i);\n        for(int k = 0; k < n_; ++k){\n          if((j>>k) & 1){\n            V_.push_back(V[k]);\n          }\n        }\n        if(V_.size() < 2) continue;\n        int t = 0;\n        for(int k = 0; k < V_.size(); ++k){\n          int s = 1e9;\n          for(int l = 0; l < V_.size(); ++l){\n            if(k != l) s = min(s, G[V_[k]][V_[l]]);\n          }\n          t += s;\n        }\n        ret = max(ret, t);\n      }\n      for(int j = 0; j < n; ++j){\n        if(G[i][j] > 0){\n          G[j][i] = 0;\n          G[i][j] = 0;\n          --m;\n        }\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j) cout << G[i][j] << \" \";cout << endl;\n  }\n  vector<int> V;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(G[i][j] > 0){\n        V.push_back(i);\n        break;\n      }\n    }\n  }\n  if(V.size() >= 2){\n    int n_ = V.size();\n    for(int j = 0; j < (1<<n_); ++j){\n      vector<int> V_;\n      for(int k = 0; k < n_; ++k){\n        if((j>>k) & 1){\n          V_.push_back(V[k]);\n        }\n      }\n      if(V_.size() < 2) continue;\n      int t = 0;\n      for(int k = 0; k < V_.size(); ++k){\n        int s = 1e9;\n        for(int l = 0; l < V_.size(); ++l){\n          if(k != l) s = min(s, G[V_[k]][V_[l]]);\n        }\n        t += s;\n      }\n      ret = max(ret, t);\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  vector< vector<int> > G(n, vector<int>(n,0));\n  int a, b, c;\n  for(int i = 0; i < m; ++i){\n    cin >> a >> b >> c;\n    --a;\n    --b;\n    G[a][b] = c;\n    G[b][a] = c;\n  }\n  cout << solve(G, n, m) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint solve(vector< vector<int> > &G, int n, int m){\n  if(!m) return 0;\n  int ret = 0;\n  for(int i = 0; i < n; ++i){\n    vector<int> V;\n    int m_ = sqrt(2*m);\n    for(int j = 0; j < n; ++j){\n      if(G[i][j] > 0) V.push_back(j);\n    }\n    if(V.size() < m_){\n      int n_ = V.size();\n      for(int j = 0; j < (1<<n_); ++j){\n        vector<int> V_(1,i);\n        for(int k = 0; k < n_; ++k){\n          if((j>>k) & 1){\n            V_.push_back(V[k]);\n          }\n        }\n        if(V_.size() < 2) continue;\n        int t = 0;\n        for(int k = 0; k < V_.size(); ++k){\n          int s = 1e9;\n          for(int l = 0; l < V_.size(); ++l){\n            if(k != l) s = min(s, G[V_[k]][V_[l]]);\n          }\n          t += s;\n        }\n        ret = max(ret, t);\n      }\n      for(int j = 0; j < n; ++j){\n        if(G[i][j] > 0){\n          G[j][i] = 0;\n          G[i][j] = 0;\n          --m;\n        }\n      }\n    }\n  }\n  /*\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j) cout << G[i][j] << \" \";cout << endl;\n  }\n  */\n  vector<int> V;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(G[i][j] > 0){\n        V.push_back(i);\n        break;\n      }\n    }\n  }\n  if(V.size() >= 2){\n    int n_ = V.size();\n    for(int j = 0; j < (1<<n_); ++j){\n      vector<int> V_;\n      for(int k = 0; k < n_; ++k){\n        if((j>>k) & 1){\n          V_.push_back(V[k]);\n        }\n      }\n      if(V_.size() < 2) continue;\n      int t = 0;\n      for(int k = 0; k < V_.size(); ++k){\n        int s = 1e9;\n        for(int l = 0; l < V_.size(); ++l){\n          if(k != l) s = min(s, G[V_[k]][V_[l]]);\n        }\n        t += s;\n      }\n      ret = max(ret, t);\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  vector< vector<int> > G(n, vector<int>(n,0));\n  int a, b, c;\n  for(int i = 0; i < m; ++i){\n    cin >> a >> b >> c;\n    --a;\n    --b;\n    G[a][b] = c;\n    G[b][a] = c;\n  }\n  cout << solve(G, n, m) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define INF (1<<29)\n\nint N, cost[MAX][MAX];\n\nint get_sat(set<int> &inv)\n{\n    int sat = 0;\n    for (auto &i: inv) {\n        int s = INF;\n        for (auto &j: inv) {\n            if (i == j) continue;\n            s = min(s, cost[i][j]);\n        }\n        sat += s;\n    }\n    return sat;\n}\n\nint dfs(set<int> inv)\n{\n    int res = 0;\n    if (inv.size() >= 2) {\n        res = get_sat(inv);\n    }\n    for (int i = 0; i < N; i++) {\n        bool ok = 1;\n        for (auto &j: inv) {\n            if (cost[i][j] == 0) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok) {\n            set<int> ninv = inv;\n            ninv.insert(i);\n            res = max(res, dfs(ninv));\n        }            \n    }\n    return res;\n}\n\nint main()\n{\n    int M, a, b, c;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> c;\n        a--; b--;\n        cost[a][b] = cost[b][a] = c;\n    }    \n    cout << dfs(set<int>()) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint ans;\nvector<int> neighbors[100];\nset< set<int> > used;\nint weight[100][100];\n\nvoid dfs(set<int> vs){\n\tif( used.count(vs) ) return;\n\tused.insert(vs);\n\t\n\tint score = 0;\n\tif( vs.size() > 1 ){\n\t\tfor( auto &&i : vs ){\n\t\t\tint c = 1e9;\n\t\t\tfor( auto &&j : vs ){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tc = min(weight[i][j],c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tscore += c;\n\t\t}\n\t}\n\tans = max(ans,score);\n\t\n\n\tconst int representative = *vs.begin();\n\t\n\tint cost[100];\n\tfor( auto &&i : neighbors[representative])\n\t\t cost[i] = 1e9;\n\t\n\tfor( auto &&i : vs ){\n\t\tfor( auto &&j : neighbors[representative]){\n\t\t\tcost[j] = min(weight[i][j],cost[j]);\n\t\t}\n\t}\n\tfor( auto &&i : neighbors[representative])\n\t\tif( !vs.count(i) and cost[i] > 0 ){\n\t\t\tset<int> nvs = vs;\n\t\t\tnvs.insert(i);\n\t\t\tdfs(nvs);\n\t\t}\n\t\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\t--a,--b;\n\t\tweight[a][b] = c;\n\t\tweight[b][a] = c;\n\t\tneighbors[a].push_back(b);\n\t\tneighbors[b].push_back(a);\n\t}\n\tans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdfs({i});\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\nifstream fin(\"date.in\");\n\nint n,m;\nlong a[101][101];\nint v[101],viz[101];\nlong maxim;\n\nvoid bkt(int poz, int sol)\n{\n    if(poz==sol+1)\n    {\n        long minim=0,suma=0;\n        for(int j=1; j<=sol; ++j)\n        {\n            minim=a[v[1]][v[j]];\n            for(int i=2; i<=sol; ++i)\n                minim=min(minim, a[v[i]][v[j]]);\n            suma+=minim;\n        }\n        maxim=max(maxim, suma);\n    }\n     else\n        {\n         for(int i=v[poz-1]+1;i<=n-sol+poz;++i)\n            {\n             if(!viz[i])\n                {\n                 v[poz]=i;\n                 viz[i]=1;\n                 bkt(poz+1, sol);\n                 viz[i]=0;\n                }\n            }\n        }\n}\n\nint main()\n{\n    cin>>n>>m;\n    if(m==0)\n        {\n         cout<<0<<\"\\n\";\n         return 0;\n        }\n    int u=0,v=0;\n    long f=0;\n    char s[21];\n    cin.get();\n    for(int j=1; j<=m; ++j)\n    {\n        //cin>>u>>v>>f;\n        cin.getline(s,20);\n        int i=0;\n        u=v=f=0;\n        while(s[i]!=' ')\n            {\n             u=u*10+s[i]-'0';\n             ++i;\n            }\n        ++i;\n        while(s[i]!=' ')\n            {\n             v=v*10+s[i]-'0';\n             ++i;\n            }\n        ++i;\n        while(s[i]!=NULL)\n            {\n             f=f*10+s[i]-'0';\n             ++i;\n            }\n        a[u][v]=a[v][u]=f;\n    }\n\n    for(int i=1;i<=n;++i) a[i][i]=1000001;\n\n    for(int j=1;j<=n;++j)\n        {\n         long minim=a[1][j];\n         for(int i=2;i<=n;++i) minim=min(minim,a[i][j]);\n         maxim+=minim;\n        }\n\n    for(int i=1;i<n;++i)\n        {\n         for(int j=i+1;j<=n;++j)\n            maxim=max(maxim,min(a[i][i],a[i][j])+min(a[j][i],a[j][j]));\n        }\n\n    for(int i=3; i<n; i++) bkt(1,i);\n\n    cout<<maxim<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint ans,n,m,x,y,z,a[111][111],used[111];\n\n\nvoid dfs(int d,int b){\n  if(d==n){\n    int res=0;\n    if(b<2)return;\n    r(i,b){\n      int A=1e9;\n      r(j,b)if(i!=j){\n        A=min(A,a[used[i]][used[j]]);\n      }\n      res+=A;\n    }\n    ans=max(ans,res);\n    return;\n  }\n  int f=1;\n  r(i,b)if(a[d][used[i]]==0)f=0;\n  if(f){\n    used[b]=d;\n    dfs(d+1,b+1);\n  }\n  dfs(d+1,b);\n}\n\nint main(){\n  cin>>n>>m;\n  r(i,m){\n    cin>>x>>y>>z;\n    x--;y--;\n    a[x][y]=a[y][x]=z;\n  }\n  dfs(0,0);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sat[100];\nbool used[100];\nvector<P> G[100]; //to, f\nint N,M;\nvector<array<int, 3>> E;\n\nint greedy(int ret){\n    int n = 2;\n    while(true){\n        int best_v=-1, best_score=ret, best_s=0;\n        for(int i=0;i<N;i++){\n            int cnt=0,s=10000000;\n            int score=0;\n            if(used[i]) continue;\n            for(auto e:G[i]){\n                int to = e.first, f = e.second;\n                if(!used[to]) continue;\n                cnt++;\n                score += min(sat[to], f);\n                s = min(f,s);                \n            }\n            if(cnt!=n) s=0;\n            score += s;\n            if(score>best_score){\n                best_v = i;\n                best_score = score;\n                best_s = s;\n            }\n        }\n        if(best_v==-1){\n            return ret;\n        }else{\n            n++;\n            ret = best_score;\n            used[best_v]=true;\n            sat[best_v]=best_s;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].emplace_back(b,c);\n        G[b].emplace_back(a,c);\n        E.push_back(array<int, 3>{a,b,c});\n    }\n    int ans=0;\n    for(auto e:E){\n        fill(used,used+100,false);\n        fill(sat,sat+100,0);\n        used[e[0]]=used[e[1]]=true;\n        sat[e[0]]=sat[e[1]]=e[2];\n        \n        ans = max(ans,greedy(2*e[2]));\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = 1LL << 50;\nll N, M, E[100][100];\nbool used[100];\nvector<ll> vec;\n\nll dfs(ll t) {\n  ll ans = 0;\n\n  REP(v, t, N) {\n    bool ok = true;\n    for(ll u : vec) ok = ok && E[u][v] > 0;\n    if(ok) {\n      vec.push_back(v);\n\n      ll x = 0;\n      for(ll i : vec) {\n        ll m = INF;\n        for(ll j : vec) if(i != j) m = min(m, E[i][j]);\n        x += m != INF ? m : 0;\n      }\n      ans = max(ans, x);\n\n      ans = max(ans, dfs(v + 1));\n      vec.resize(vec.size() - 1);\n    }\n  }\n\n  return ans;\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, N) REP(j, 0, N) E[i][j] = 0;\n  REP(i, 0, M) {\n    ll u, v, f; cin >> u >> v >> f; u--; v--;\n    E[u][v] = f;\n    E[v][u] = f;\n  }\n\n  REP(i, 0, N) used[i] = false;\n  cout << dfs(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\nint n, m, f[110][110], deg[110];\nvector< int > cand, sel;\n\nint calc() {\n\tint res = 0;\n\tfor_(i,0,size_of(sel)) {\n\t\tint mn = 1e9;\n\t\tfor_(j,0,size_of(sel)) if (j != i) mn = min(mn, f[sel[i]][sel[j]]);\n\t\tres += mn;\n\t}\n\treturn res;\n}\n\nint rec(int i, int s, int k) {\n\tif (s == k) return calc();\n\tif (i == size_of(cand)) return 0;\n\t\n\tint res = rec(i+1, s, k);\n\t\n\tsel.push_back(cand[i]);\n\tres = max(res, rec(i+1, s+1, k));\n\tsel.pop_back();\n\t\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> m;\n\t\n\tminit(f,0);\n\tminit(deg,0);\n\t\n\tfor_(i,0,m) {\n\t\tint u, v, p; cin >> u >> v >> p;\n\t\t--u; --v;\n\t\tf[v][u] = f[u][v] = p;\n\t\t++deg[u]; ++deg[v];\n\t}\n\t\n\tint ans = 0;\n\tfor_(i,2,15) {\n\t\tcand.clear();\n\t\tfor_(j,0,n) if (deg[j] >= i - 1) cand.push_back(j);\n\t\tans = max(ans, rec(0, 0, i));\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n \n#define INF (1LL<<62)\n \nusing namespace std;\n \ntypedef long long ll;\n \nll g[101][101],n,m;\n \nll rec(set<int> S,int mx){\n   \n  if(mx<0)return 0;\n \n  ll res=0;\n  set<int>::iterator it=S.begin();\n  for(;it!=S.end();it++){\n    set<int>::iterator j=S.begin();\n    ll t=INF;\n    for(;j!=S.end();j++){\n      if(it==j)continue;\n      t=min(t,g[*it][*j]);\n    }\n    res+=t;\n  }\n   \n  if(mx>=n-1)return res;\n \n  int id=-1;\n  ll cost=0;\n  for(int v=mx+1;v<n;v++){\n    if(S.count(v))continue;\n \n    bool fg=true;\n    set<int>::iterator it=S.begin();\n    for(;it!=S.end();it++){\n      fg&=(g[v][*it]<INF);\n    }\n    if(!fg)continue;\n    \n    set<int>T=S;\n    T.insert(v);\n    cost=max(cost,rec(T,v));\n  }\n   \n  return max(res,cost);\n}\n \nint main(void){\n \n  fill(g[0],g[101],INF);\n  for(int i=0;i<101;i++)g[i][i]=0;\n \n  cin >> n >> m;\n \n  for(int i=0;i<m;i++){\n    ll a,b,f;\n    cin >> a >> b >>f;\n    g[a-1][b-1]=g[b-1][a-1]=f;\n  }\n   \n  ll ans=0;\n \n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(g[i][j]<INF){\n    set<int>S;\n    S.insert(i);\n    S.insert(j);\n    ans=max(ans,rec(S,max(i,j)));\n      }\n    }\n  }\n \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n#define inf 100000000\n\nusing namespace std;\n\nint n, m;\nvector<int> G[105];\nint g[105][105];\n\nbool used[105];\nvector<int> vec;\n\nint calc()\n{\n\tint mi, ret = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tmi = inf;\n\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\tif(i == j) continue;\n\t\t\tmi = min(mi, g[vec[i]][vec[j]]);\n\t\t}\n\t\tif(mi == inf) mi = 0;\n\t\tret += mi;\n\t}\n\treturn ret;\n}\n\nint dfs(int v, int num)\n{\n\tif(num >= 14) return 0;\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(g[vec[i]][v] == 0) return 0;\n\t}\n\tvec.push_back(v);\n\tused[v] = true;\n\t\n\tint ret = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tret = max(ret, dfs(G[v][i], num+1));\n\t}\n\tret = max(ret, calc());\n\tvec.pop_back();\n\tused[v] = false;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tint u, v, f;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u >> v >> f;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tg[u][v] = g[v][u] = f;\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans = max(ans, dfs(i, 0));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\n\nint w[101][101];\nint N, M, ans;\nvector<int> use;\nvoid dfs(int depth) {\n    if(depth == N) {\n        if(use.size() < 2) return;\n        int sum = 0;\n        for(int k : use) {\n            int mi = INF;\n            for(int l : use) if(k != l)\n              mi = min(mi, w[k][l]);\n            sum += mi;\n        }\n        ans = max(ans, sum);\n        return;\n    }\n    bool ok = true;\n    for(int k : use) if(!w[k][depth]) ok = false;\n    dfs(depth + 1);\n    if(ok) {\n        use.push_back(depth);\n        dfs(depth + 1);\n        use.pop_back();\n    }\n    return;\n}\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    int u_, v_, w_;\n    memset(w, 0, sizeof(w));\n    rep(i, M) {\n        scanf(\"%d%d%d\", &u_, &v_, &w_);\n        --u_; --v_;\n        w[u_][v_] = w[v_][u_] = w_;\n    }\n    ans = 0; \n    dfs(0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint n,m;\nll ans = 0LL;\nll G[100][100];\n\nvoid dfs(set<int> st, vector<bool> used, size_t max_size, ll score){\n    ans = max(ans, score);\n    if(st.size() == max_size) return;\n    rep(n){\n        if(used[i]) continue;\n        bool can_add = true;\n        for(int x: st){\n            if(!G[i][x]){\n                can_add = false;\n                break;\n            }\n        }\n        if(can_add){\n            st.insert(i);\n            used[i] = true;\n            ll new_score = 0LL;\n            if(st.size() > 1)for(int x: st){\n                ll tmp = LLONG_MAX;\n                for(int y: st){\n                    if(x == y) continue;\n                    tmp = min(tmp, G[x][y]);\n                }\n                new_score += tmp;\n            }\n            dfs(st, used, max_size, new_score);\n            used[i] = false;\n            st.erase(i);\n        }\n    }\n}\n\nint main(){\n    int u,v;\n    ll f;\n    cin >> n >> m;\n    rep(m){\n        cin >> u >> v >> f;\n        u--; v--;\n        G[u][v] = G[v][u] = f;\n    }\n    \n    reppp(i, 1, 14){\n        if(i != 1 && 2*m/(i-1) < i) continue;\n        dfs(set<int>(), vector<bool>(n, false), i, 0LL);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n#define MAX_V 100\nstruct edge{int to,cost;};\n\nint v,e;\nvector<edge> G[MAX_V];\n\nbool solve(vector<bool> &used){\n    vector<set<pii>> vp(v);\n    rep(i,v){\n        if(used[i])continue;\n        vp[i].insert(pii(INF,-1));\n        for(auto e:G[i]){\n            if(used[e.to])continue;\n            vp[i].insert(pii(e.cost,e.to));\n        }\n    }\n    \n    rep(i,v){\n        if(used[i])continue;\n        int the_score = vp[i].begin()->first;\n        if(the_score==INF) the_score = 0;\n        \n        for(auto e:G[i]){\n            if(used[e.to])continue;\n            int pos_score;\n            pii t = *vp[e.to].begin();\n            assert(t.first<=e.cost);\n            if(t.first<e.cost)pos_score = 0;\n            else{\n                assert(t.first==e.cost);\n                \n                pii tmp = pii(-1,-1);\n                if(t.second==i){\n                    tmp = t;\n                    vp[e.to].erase(t);\n                }\n                \n                int x = vp[e.to].begin()->first;\n                if(x==INF) x = 0;\n                \n                pos_score = x-e.cost;\n                \n                if(tmp!=pii(-1,-1))vp[e.to].insert(tmp);\n            }\n            the_score-=pos_score;\n            \n        }\n        if(the_score<0){\n            used[i] = true;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nint main(){\n    int d[101][101]={};\n    cin>>v>>e;\n    rep(i,e){\n        int s,t,c;\n        cin>>s>>t>>c;\n        s--,t--;\n        G[s].pb(edge{t,c});\n        G[t].pb(edge{s,c});\n        d[s][t] = d[t][s] = 1;\n    }\n    \n    rep(i,v)rep(j,v){\n        if(d[i][j]==0 && i!=j){\n            G[i].pb(edge{(int)j,0});\n        }\n    }\n    vector<bool> used(v,false);\n    \n    \n    while(solve(used));\n    \n    int ans = 0;\n    rep(i,v){\n        if(used[i])continue;\n        int mini = INF;\n        for(auto e:G[i]){\n            if(used[e.to])continue;\n            mini = min(mini,e.cost);\n        }\n        if(mini==INF)mini = 0;\n        ans+=mini;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint n;\nint g[128][128];\nint res;\nset<vector<int> > visit;\nvector<int> used;\nvector<int> s;\nvoid dfs()\n{\n    if (visit.count(used))\n        return;\n    visit.insert(used);\n\n    if (used.size() >= 2)\n    {\n        int score = 0;\n        rep(i, used.size())\n        {\n            int s = ten(9);\n            rep(j, used.size())\n                if (i != j)\n                    chmin(s, g[used[i]][used[j]]);\n            score += s;\n        }\n        chmax(res, score);\n    }\n\n    bool next[111];\n    fill_n(next, n, true);\n    rep(i, used.size()) rep(j, n)\n        next[j] &= g[used[i]][j] != -1;\n    rep(i, n)\n    {\n        if (next[i])\n        {\n            used.pb(i);\n            sort(all(used));\n            \n            dfs();\n\n            used.erase(find(all(used), i));\n        }\n    }\n}\nint main()\n{\n    int m;\n    cin >> n >> m;\n    CL(g, -1);\n    rep(i, m)\n    {\n        int u, v, f;\n        cin >> u >> v >> f;\n        --u, --v;\n        g[u][v] = g[v][u] = f;\n    }\n\n    dfs();\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<math.h>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nconst int mod=1000000007;\n\nint n,m,u,v,f;\nint ma[102][102];\nint invite[102];\n\nint dfs(int cur, int in){\n    if(cur==n){\n        if(in<2)return 0;\n        int tot=0;\n        for(int i=0;i<in;i++){\n            int t=INT_MAX;\n            for(int j=0;j<in;j++){\n                if(i!=j){\n                    t=min(t,ma[invite[i]][invite[j]]);\n                }\n            }\n            tot+=t;\n        }\n        return tot;\n    }\n    int ret=dfs(cur+1,in);\n    bool ok=true;\n    for(int i=0;i<in;i++){\n        if(ma[cur][invite[i]]==0){\n            ok=false;\n        }\n    }\n    if(ok){\n        invite[in]=cur;\n        ret=max(dfs(cur+1,in+1),ret);\n    }\n    return ret;\n}\n\nint main(){\n    cin>>n>>m;\n    memset(ma,0,sizeof(ma));\n    for(int i=0;i<m;i++){\n        cin>>u>>v>>f;\n        ma[u-1][v-1]=f;\n        ma[v-1][u-1]=f;\n    }\n    cout<<dfs(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint g[100][100];\nint deg[100];\nbool v[100];\n\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  for(int i = 0; i < M; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x, --y;\n    g[x][y] = z;\n    g[y][x] = z;\n    deg[x]++;\n    deg[y]++;\n  }\n  int ret = 0;\n  if(N <= 20) {\n    for(int i = 0; i < (1 << N); i++) {\n      if(__builtin_popcount(i) <= 1) continue;\n      int cost = 0;\n      for(int j = 0; j < N; j++) {\n        if((i >> j) & 1) {\n          int add = INF;\n          for(int k = 0; k < N; k++) {\n            if(j == k) continue;\n            if((i >> k) & 1) add = min(add, g[j][k]);\n          }\n          cost += add;\n        }\n      }\n      ret = max(ret, cost);\n    }\n  } else {\n    for(int i = 0; i < N; i++) {\n      int chal = -1;\n      for(int j = 0; j < N; j++) {\n        if(v[j]) continue;\n        if(chal == -1 || deg[j] < deg[chal]) chal = j;\n      }\n      vector< int > rots;\n      for(int j = 0; j < N; j++) {\n        if(g[chal][j] > 0) rots.emplace_back(j);\n      }\n      for(int j = 1; j < (1 << rots.size()); j++) {\n        int cost = 0, st = INF;\n        for(int k = 0; k < rots.size(); k++) {\n          if((j >> k) & 1) {\n            int add = g[chal][rots[k]];\n            for(int l = 0; l < rots.size(); l++) {\n              if(k == l) continue;\n              if((j >> l) & 1) add = min(add, g[rots[k]][rots[l]]);\n            }\n            cost += add;\n            st = min(st, g[chal][rots[k]]);\n          }\n        }\n        ret = max(ret, cost + st);\n      }\n      v[chal] = true;\n      for(int j = 0; j < N; j++) {\n        if(g[j][chal] > 0) --deg[j];\n        g[chal][j] = g[j][chal] = 0;\n      }\n    }\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint g[100][100];\nint n;\n\nbool used[100];\nint ans;\nvoid dfs(int now) {\n  if (now == n) {\n    int tmp = 0;\n    REP(i,n) {\n      if (!used[i]) continue;\n      int mi = INF;\n      REP(j,n) {\n        if (!used[j] || i==j) continue;\n        mi = min(mi, g[i][j]);\n      }\n      if (mi!=INF)\n        tmp += mi;\n    }\n    ans = max(ans, tmp);\n    return;\n  }\n  bool f = 1;\n  REP(i,now) {\n    if (used[i] && g[now][i]==0) {\n      f = 0;\n      break;\n    }\n  }\n  if (f) {\n    used[now] = 1;\n    dfs(now+1);\n    used[now] = 0;\n  }\n  dfs(now+1);\n}\n\nint main() {\n  int m;\n  cin >> n >> m;\n\n  REP(i,m) {\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a][b] = c;\n    g[b][a] = c;\n  }\n  dfs(0);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m;\nll f[111][111];\n\nll calc_score(vector<ll> vs){\n  if(vs.size()<2)return 0;\n  ll res=0;\n  rep(i,vs.size()){\n    ll mins=INF;\n    rep(j,vs.size()){\n      if(i==j)continue;\n      minch(mins,f[vs[i]][vs[j]]);\n    }\n    res+=mins;\n  }\n  return res;\n}\n\nll dfs(ll v,vector<ll> crt){\n  if(v==n)return calc_score(crt);\n  ll res=calc_score(crt);\n  bool ok=true;\n  for(ll u : crt){\n    if(f[v][u]==0){\n      ok=false;\n    }\n  }\n  maxch(res,dfs(v+1,crt));\n  if(ok){\n    crt.push_back(v);\n    maxch(res,dfs(v+1,crt));\n    crt.pop_back();\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  memset(f,0,sizeof(f));\n  cin>>n>>m;\n  rep(i,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--; b--;\n    f[a][b]=f[b][a]=c;\n  }\n  cout<<dfs(0,vector<ll>())<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass RelationShip{\npublic:\n  int _to;\n  int _friendliness;\n  RelationShip(int to,int friendliness) :\n    _to(to), _friendliness(friendliness) {}\n  bool operator<(const RelationShip &r) const {\n    return _friendliness < r._friendliness;\n  }\n  bool operator>(const RelationShip &r) const {\n    return _friendliness > r._friendliness;\n  }\n};\n\n\nbool used[101];\nvector<RelationShip> edges[101];\nint idx[101][101];\nint total_rabbits;\nint total_pairs;\n\nint dfs(int last){\n  int res = 0;\n\n  int sum = 0;\n  for(int orig=0; orig <= last; orig++){\n    if(!used[orig]) continue;\n\n    int tmp = INF;\n    for(int next_i = 0; next_i < edges[orig].size(); next_i++){\n      int next = edges[orig][next_i]._to;\n      if(!used[next]) continue;\n      tmp = min(tmp,edges[orig][next_i]._friendliness);\n    }\n    if(tmp != INF) sum += tmp;\n  }\n  \n  res = max(sum,res);\n\n  for(int next=last + 1; next < total_rabbits; next++){\n    for(int prev = 0; prev <= last; prev++){\n      if(!used[prev] && idx[prev][next] == -1) continue;\n      used[next] = true;\n      res = max(res,dfs(next));\n      used[next] = false;\n    }\n  }\n  \n  return res;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_rabbits,&total_pairs)){\n    memset(used,false,sizeof(used));   \n    memset(idx,-1,sizeof(idx));\n\n    for(int pair_i = 0; pair_i < total_pairs; pair_i++){\n      int from,to,friendliness;\n      scanf(\"%d %d %d\",&from,&to,&friendliness);\n      from--; to--;\n      edges[from].push_back(RelationShip(to,friendliness));\n      edges[to].push_back(RelationShip(from,friendliness));\n      idx[from][to] = edges[from].size() - 1;\n      idx[to][from] = edges[to].size() - 1;\n    }\n\n    cout << dfs(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      for(auto& i : mincost)i = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      for(int& i : mincost) ret += i;\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <map>\n#include <string.h>\n\nusing namespace std;\n\n#define MAX_N 101\n#define MAX_M 101\n#define MAX_F 1000000\n\ntypedef pair<int, int> PII;\n\nint table[MAX_N][MAX_N];\nint part[MAX_N];\n\nint min_f(int i, int n) {\n  int minval = MAX_F;\n  for(int j=0; j<n; j++) {\n    if(i == j) continue;\n\n    if(part[j]) {\n      if(minval > table[i][j]) {\n\tminval = table[i][j];\n      }\n    }\n  }\n\n  return minval;\n}\n\nint main() {\n  multimap<int, PII, greater<int> > list;\n\t\n  int n, m;\n  int i, j;\n  int u, v, f;\n\t\n  cin >> n >> m;\n  memset(table, 0, sizeof(int) * MAX_N * MAX_N);\n  memset(part, 0, sizeof(int) * MAX_N);\n  list.clear();\n  for(i=0; i<m; i++) {\n    cin >> u >> v >> f;\n    table[u-1][v-1] = f;\n    table[v-1][u-1] = f;\n    list.insert(pair<int, PII>(f, PII(u-1, v-1)));\n  }\n\n  int p = 0;\n  map<int, PII>::iterator iter = list.begin();\n  while(iter != list.end()) {\n    pair<int, PII> item = (*iter);\n    f = item.first;\n    u = item.second.first;\n    v = item.second.second;\n      \n    part[u] = 1;\n    part[v] = 1;\n    int new_p = 0;\n    for(i=0; i<n; i++) {\n      if(part[i]) {\n\tnew_p += min_f(i, n);\n      }\n    }\n\n    if(new_p < p) break;\n    else p = new_p;\n      \n    ++iter;\n  }\n\n  printf(\"%d\\n\", p);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 58) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nvector< vector< int > > enumerate_clique(Matrix< bool > g) {\n\n  int N = (int) g.size(), M = 0;\n  vector< int > deg(N);\n  vector< vector< int > > edge(N, vector< int >(N));\n  for(int i = 0; i < N; i++) {\n    for(auto p : g[i]) deg[i] += p;\n    M += deg[i];\n  }\n  int lim = (int) sqrt(M);\n\n  vector< vector< int > > cliques;\n\n  auto add_clique = [&](const vector< int > &rem, bool last) {\n    vector< int > neighbor((int) rem.size() - last);\n    for(int i = 0; i < (int) neighbor.size(); i++) {\n      for(int j = 0; j < (int) neighbor.size(); j++) {\n        if(i != j && !g[rem[i]][rem[j]]) neighbor[i] |= 1 << j;\n      }\n    }\n    for(int i = 1 - last; i < (1 << neighbor.size()); i++) {\n      bool ok = true;\n      for(int j = 0; j < neighbor.size(); j++) {\n        if((i >> j) & 1) {\n          if(i & neighbor[j]) {\n            ok = false;\n            break;\n          }\n        }\n      }\n      if(ok) {\n        vector< int > clique;\n        if(last) clique.emplace_back(rem.back());\n        for(int j = 0; j < neighbor.size(); j++) {\n          if((i >> j) & 1) clique.emplace_back(rem[j]);\n        }\n        cliques.emplace_back(clique);\n      }\n    }\n  };\n\n  vector< int > used(N);\n  queue< int > que;\n  for(int i = 0; i < N; i++) {\n    if(deg[i] < lim) {\n      used[i] = true;\n      que.emplace(i);\n    }\n  }\n  while(!que.empty()) {\n    int idx = que.front();\n    que.pop();\n    vector< int > rem;\n    for(int k = 0; k < N; k++) {\n      if(g[idx][k]) rem.emplace_back(k);\n    }\n    rem.emplace_back(idx);\n    add_clique(rem, true);\n    used[idx] = true;\n    for(int k = 0; k < N; k++) {\n      if(g[idx][k]) {\n        g[idx][k] = false;\n        g[k][idx] = false;\n        --deg[k];\n        if(!used[k] && deg[k] < lim) {\n          used[k] = true;\n          que.emplace(k);\n        }\n      }\n    }\n  }\n  vector< int > rem;\n  for(int i = 0; i < N; i++) {\n    if(!used[i]) rem.emplace_back(i);\n  }\n  add_clique(rem, false);\n  return cliques;\n}\n\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Matrix< bool > g(N, vector< bool >(N));\n  Matrix< int > h(N, vector< int >(N));\n  for(int i = 0; i < M; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x, --y;\n    g[x][y] = true;\n    g[y][x] = true;\n    h[x][y] = z;\n    h[y][x] = z;\n  }\n  auto cliques = enumerate_clique(g);\n  int ret = 0;\n  for(auto &clique : cliques) {\n    if(clique.size() == 1) continue;\n    int add = 0;\n    for(auto &i : clique) {\n      int uku = 1 << 30;\n      for(auto &j : clique) {\n        if(i != j) uku = min(uku, h[i][j]);\n      }\n      add += uku;\n    }\n    ret = max(ret, add);\n  }\n  cout << ret << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n\nconst int inf = 1e9;\n\nint n, m;\nint deg_lim;\nvector<vector<int>> A;\nint ma = 0;\n\nvector<int> calcDeg(const vector<bool>& alive) {\n    vector<int> deg(n);\n    rep(i, n) {\n        if (!alive[i]) continue;\n        rep(j, n) {\n            if (i != j && alive[j] && A[i][j] > 0) {\n                deg[i]++;\n            }\n        }\n    }\n    return deg;\n}\n\nint findVertex(const vector<bool>& alive, const vector<int>& deg) {\n    // cerr << \"[findVertex]\" << endl;\n    // cerr << \"alive:\";\n    // rep(i, n) {\n    //     cerr << \" \" << alive[i];\n    // }\n    // cerr << endl;\n    // cerr << \"deg:\";\n    // rep(i, n) {\n    //     cerr << \" \" << deg[i];\n    // }\n    // cerr << endl;\n\n    rep(i, n) {\n        if (alive[i] && deg[i] < deg_lim) {\n            return i;\n        }\n    }\n    assert(false);\n}\n\n/*\nbool isClique(int state, const vector<int>& ids) {\n    int k = ids.size();\n    if (k == 1) return true;\n    rep(i, k) {\n        if (!((state >> i) & 1)) continue;\n        rep2(j, i + 1, k) {\n            if (!((state >> j) & 1)) continue;\n            if (A[ids[i]][ids[j]] == 0) return false;\n        }\n    }\n    return true;\n}\n*/\n\nint eval(int state, const vector<int>& ids) {\n    int k = ids.size();\n\n    // cerr << \"[eval]\" << endl;\n    // cerr << bitset<3>(state) << endl;\n    // cerr << \"ids:\";\n    // rep(i, k) {\n    //     cerr << \" \" << ids[i];\n    // }\n    // cerr << endl;\n\n    assert(__builtin_popcount(state) > 0);\n    if (__builtin_popcount(state) == 1) return 0;\n\n    int score = 0;\n    rep(i, k) {\n        if (!((state >> i) & 1)) continue;\n        int mi = inf;\n        rep(j, k) {\n            if (i == j) continue;\n            if (!((state >> j) & 1)) continue;\n            if (A[ids[i]][ids[j]] == 0) return -1;\n            mi = min(mi, A[ids[i]][ids[j]]);\n        }\n        assert(mi != inf);\n        score += mi;\n    }\n    return score;\n}\n\nvoid update(int state, const vector<int>& ids) {\n    // if (!isClique(state, ids)) return;\n    ma = max(ma, eval(state, ids));\n}\n\nvoid genBrute(const vector<bool>& alive) {\n    // cerr << \"[genBrute]\" << endl;\n    vector<int> ids;\n    rep(i, n) {\n        if (alive[i]) ids.emplace_back(i);\n    }\n    int k = ids.size();\n    assert(k > 0);\n    assert(k < 15);\n    rep2(state, 1, 1 << k) {\n        update(state, ids);\n    }\n}\n\nvoid genBruteWith(const vector<bool>& alive, int v) {\n    // cerr << \"[genBruteWith]\" << endl;\n    vector<int> ids;\n    rep(i, n) {\n        if (i != v && alive[i] && A[i][v] > 0) ids.emplace_back(i);\n    }\n    ids.emplace_back(v);\n    int k = ids.size();\n\n    // cerr << \"ids:\";\n    // rep(i, k) {\n    //     cerr << \" \" << ids[i];\n    // }\n    // cerr << endl;\n\n    rep(state, 1 << (k - 1)) {\n        update(state | (1 << (k - 1)), ids);\n    }\n}\n\nbool existAlive(const vector<bool>& alive) {\n    rep(i, n) {\n        if (alive[i]) return true;\n    }\n    return false;\n}\n\nvoid genClique(vector<bool>& alive) {\n    // cerr << \"[genClique]\" << endl;\n    if (!existAlive(alive)) return;\n    vector<int> deg = calcDeg(alive);\n    int ma_deg = *max_element(deg.begin(), deg.end());\n    if (ma_deg >= deg_lim) {\n        // cerr << \"- Case 1\" << endl;\n        genBrute(alive);\n    }\n    else {\n        // cerr << \"- Case 2\" << endl;\n        int v = findVertex(alive, deg);\n        // cerr << \"v = \" << v << endl;\n        genBruteWith(alive, v);\n        alive[v] = false;\n        genClique(alive);\n        alive[v] = true;\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    deg_lim = sqrt(2 * m) + 1;\n    // cerr << \"deg_lim = \" << deg_lim << endl;\n    A.assign(n, vector<int>(n));\n    rep(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        A[a][b] = c;\n        A[b][a] = c;\n    }\n\n    vector<bool> alive(n, true);\n    genClique(alive);\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\nifstream fin(\"date.in\");\n\nint n,m;\nlong a[101][101];\nint v[101],viz[101];\nlong maxim;\n\nvoid bkt(int poz, int sol)\n{\n    if(poz==sol+1)\n    {\n        long minim=0,suma=0;\n        for(int j=1; j<=sol; ++j)\n        {\n            minim=a[v[1]][v[j]];\n            for(int i=2; i<=sol; ++i)\n                minim=min(minim, a[v[i]][v[j]]);\n            suma+=minim;\n        }\n        maxim=max(maxim, suma);\n    }\n     else\n        {\n         for(int i=v[poz-1]+1;i<=n-sol+poz;++i)\n            {\n             if(!viz[i])\n                {\n                 v[poz]=i;\n                 viz[i]=1;\n                 bkt(poz+1, sol);\n                 viz[i]=0;\n                }\n            }\n        }\n}\n\nint main()\n{\n    cin>>n>>m;\n    int u=0,v=0;\n    long f=0;\n    char s[21];\n    cin.get();\n    for(int j=1; j<=m; ++j)\n    {\n        //cin>>u>>v>>f;\n        cin.getline(s,20);\n        int i=0;\n        u=v=f=0;\n        while(s[i]!=' ')\n            {\n             u=u*10+s[i]-'0';\n             ++i;\n            }\n        ++i;\n        while(s[i]!=' ')\n            {\n             v=v*10+s[i]-'0';\n             ++i;\n            }\n        ++i;\n        while(s[i]!=NULL)\n            {\n             f=f*10+s[i]-'0';\n             ++i;\n            }\n        a[u][v]=a[v][u]=f;\n    }\n\n    for(int i=1;i<=n;++i) a[i][i]=1000001;\n\n    for(int j=1;j<=n;++j)\n        {\n         long minim=a[1][j];\n         for(int i=2;i<=n;++i) minim=min(minim,a[i][j]);\n         maxim+=minim;\n        }\n\n    for(int i=1;i<n;++i)\n        {\n         for(int j=i+1;j<=n;++j)\n            maxim=max(maxim,min(a[i][i],a[i][j])+min(a[j][i],a[j][j]));\n        }\n\n    for(int i=3; i<n; i++) bkt(1,i);\n\n    cout<<maxim<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint G[111][111];\nint ans;\n\nbool check(vector<int> v,int id){\n  if( v.empty() ) return true;\n  for(int i=0;i<(int)v.size();i++)\n    if( G[v[i]][id] == 0 ) return false;  \n  return true;\n}\n\nvoid result(const vector<int> &v){\n  if( v.size() < 2 ) return;\n  int res = 0;\n  for(int i=0;i<(int)v.size();i++){\n    int ret = (1<<29);\n    for(int j=0;j<(int)v.size();j++){\n      if( i == j ) continue;\n      ret = min( ret, G[v[i]][v[j]] );\n    }\n    res += ret;\n  }\n  ans = max ( res, ans );\n}\n\nvoid solve(int id,vector<int> v){\n  if( id == N ) {\n    result(v);\n    return;\n  }\n  solve(id+1,v);\n  if( check(v,id) ){\n    v.push_back(id);\n    solve(id+1,v);\n  } \n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    cin >> a >> b >> c;\n    --a; --b;\n    G[a][b] = c;\n    G[b][a] = c;\n  }\n  solve(0,vector<int>());\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\n\nint w[101][101];\nint N, M, ans;\nvector<int> use;\nvoid dfs(int depth) {\n    if(depth == N) {\n        if(use.size() < 2) return;\n        int sum = 0;\n        for(int& k : use) {\n            int mi = INF;\n            for(int& l : use) if(k != l)\n              mi = min(mi, w[k][l]);\n            sum += mi;\n        }\n        ans = max(ans, sum);\n        return;\n    }\n    bool ok = true;\n    for(int& k : use) if(!w[k][depth]) ok = false;\n    dfs(depth + 1);\n    if(ok) {\n        use.push_back(depth);\n        dfs(depth + 1);\n        use.pop_back();\n    }\n    return;\n}\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    int u_, v_, w_;\n    memset(w, 0, sizeof(w));\n    rep(i, M) {\n        scanf(\"%d%d%d\", &u_, &v_, &w_);\n        --u_; --v_;\n        w[u_][v_] = w[v_][u_] = w_;\n    }\n    ans = 0; \n    dfs(0);\n    printf(\"%d\\n\", ans);\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dist[101][101];\nmap<vector<int>,int> mp;\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tqueue<pair<vector<int>,vector<int> > > q;\n\t\n\tint ans = 0;\n\t\n\tREP(i,m)\n\t{\n\t\tint a,b,c;cin >> a >> b >> c;\n\t\tdist[a][b] = dist[b][a] = c;\n\t\tif(a > b)swap(a,b);\n\t\tvector<int> A = {a,b};\n\t\tvector<int> B = {c,c};\n\t\tq.push(MP(A,B));\n\t\tmp[A] = 2*c;\n\t\tans = max(ans,2*c);\n\t}\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<vector<int>,vector<int> > now = q.front();q.pop();\n\t\tvector<int> list = now.FI;\n\t\tvector<int> score = now.SE;\n\t\tfor(int i = list[list.size()-1]+1;i <= n;i++)\n\t\t{\n\t\t\tvector<int> tmp = list;\n\t\t\ttmp.PB(i);\n\t\t\tif(mp.find(tmp) != mp.end())continue;\n\t\t\tvector<int> tmpscore;\n\t\t\tint nowscore = 0;\n\t\t\tint sa = 0;\n\t\t\tint plus = 100000000;\n\t\t\t\n\t\t\tREP(j,list.size())\n\t\t\t{\n\t\t\t\tint AA =  min(score[j],dist[list[j]][i]);\n\t\t\t\tnowscore += AA;\n\t\t\t\ttmpscore.PB(AA);\n\t\t\t\tsa += score[j];\n\t\t\t\tplus = min(plus,dist[list[j]][i]);\n\t\t\t}\n\t\t\t\n\t\t\tnowscore += plus;\n\t\t\ttmpscore.PB(plus);\n\n\t\t\t//cout << ' ' << nowscore << endl;\n\t\t\t//SHOW1d(tmp,tmp.size());\n\t\t\t//SHOW1d(tmpscore,tmp.size());\n\t\t\t\t\t\t\n\t\t\tif(sa <= nowscore)\n\t\t\t{\n\t\t\t\tmp[tmp] = nowscore;\n\t\t\t\tans = max(ans,nowscore);\n\t\t\t\tq.push(MP(tmp,tmpscore));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nconst int N = 100 + 10;\nconst int INF = 1 << 30;\n\nint value[N][N], queue[N], dist[N], temp_dist[N];\nint n, m, length, answer;\n\nvoid dfs(int u, int current) {\n\tif (current > answer) {\n\t\tanswer = current;\n\t}\n\tif (u > n) {\n\t\treturn;\n\t}\n\tdfs(u + 1, current);\n\tbool flag = true;\n\tint temp = INF;\n\tfor (int i = 1; i <= length && flag; ++ i) {\n\t\tint v = queue[i];\n\t\tflag &= (value[u][v] > 0);\n\t\tif (value[u][v] < temp) {\n\t\t\ttemp = value[u][v];\n\t\t}\n\t}\n\tif (flag) {\n\t\t/*\n\t\tdist[u] = temp;\n\t\tif (dist[u] != dist[0]) current += dist[u];\n\t\tfor (int i = 1; i <= length; ++ i) {\n\t\t\tint v = queue[i];\n\t\t\ttemp_dist[v] = dist[v];\n\t\t\tif (value[u][v] < dist[v]) {\n\t\t\t\tif (dist[v] != dist[0]) current -= dist[v];\n\t\t\t\tdist[v] = value[u][v];\n\t\t\t\tcurrent += dist[v];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tqueue[++ length] = u;\n\t\tcurrent = 0;\n\t\tfor (int i = 1; i <= length; ++ i) {\n\t\t\tint min_value = dist[0];\n\t\t\tint a = queue[i];\n\t\t\tfor (int j = 1; j <= length; ++ j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tint b = queue[j];\n\t\t\t\t\tmin_value = std::min(min_value, value[a][b]);\n\t\t\t\t} \n\t\t\t}\n\t\t\tcurrent += min_value;\n\t\t}\n\t\tdfs(u + 1, current);\n\t\tlength --;\n\t\t/*\n\t\tfor (int i = 1; i <= length; ++ i) {\n\t\t\tint v = queue[i];\n\t\t\tdist[v] = temp_dist[v];\n\t\t}\n\t\tdist[u] = dist[0];\n\t\t*/\n\t}\n}\n\nint main() {\t\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < m; ++ i) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tvalue[a][b] = value[b][a] = c;\n\t}\n\tmemset(dist, 127, sizeof(dist));\n\tanswer = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tlength = 1;\n\t\tqueue[1] = i;\n\t\tdfs(i, 0);\n\t}\n\tprintf(\"%d\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> dim(N);\n    vector<vector<int>> edge(N, vector<int>(N, 0));\n    for (int i = 0; i < M; i++) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        u--, v--;\n        edge[u][v] = edge[v][u] = c;\n        dim[u]++, dim[v]++;\n    }\n    int ans = 0;\n    for (int s = 2; s <= 14; s++) {\n        vector<int> cand;\n        for (int i = 0; i < N; i++) {\n            if (dim[i] >= s - 1) { cand.push_back(i); }\n        }\n        if (cand.size() < s) { break; }\n        vector<bool> mask(N, false);\n        fill(mask.end() - s, mask.end(), true);\n        auto score = [&](const vector<int>& node) {\n            int ans = 0;\n            for (const int i : node) {\n                int mini = 1 << 30;\n                for (const int j : node) {\n                    if (i == j) { continue; }\n                    if (edge[i][j] == 0) { return 0; }\n                    mini = min(mini, edge[i][j]);\n                }\n                ans += mini;\n            }\n            return ans;\n        };\n        do {\n            vector<int> node;\n            for (int i = 0; i < N; i++) {\n                if (mask[i]) { node.push_back(cand[i]); }\n            }\n            ans = max(ans, score(node));\n        } while (next_permutation(mask.begin(), mask.end()));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nset<vector<int> > memo;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n  sort(G.begin(),G.end());\n  \n  if(memo.count(G)) return ;\n  memo.insert(G);\n  \n  for(int i=0;i<n;i++){\n\n    if(used[i]) continue;\n\n    used[i]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(i);\n    \n    for(int j=0;j<nG.size();j++)\n      \n      if(i!=nG[j]&&used[nG[j]])\n\tmincost=min(mincost,d[i][nG[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n    \n    used[i]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n  }\n\n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nint n,m;\nint adj[100][100] = {};\n\nint dfs(int curr, vector<int> &nodes){\n\tint ret = 0;\n\tif(nodes.size() > 1){\n\t\tfor(int i=0; i<(int)nodes.size(); i++){\n\t\t\tint sub = inf;\n\t\t\tfor(int j=0; j<(int)nodes.size(); j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tsub = min(sub, adj[nodes[i]][nodes[j]]);\n\t\t\t}\n\t\t\tret += sub;\n\t\t}\n\t}\n\tfor(int i=curr; i<n; i++){\n\t\tbool ok = true;\n\t\tfor(int v: nodes){\n\t\t\tif(adj[i][v] == 0) ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tif(ok){\n\t\t\tnodes.push_back(i);\n\t\t\tret = max(ret, dfs(i+1, nodes));\n\t\t\tnodes.pop_back();\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i=0; i<m; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tadj[a][b] = adj[b][a] = c;\n\t}\n\tvector<int> nodes;\n\tcout << dfs(0, nodes) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sat[100];\nbool used[100];\nvector<P> G[100]; //to, f\nint N,M;\nvector<array<int, 3>> E;\n\nint greedy(){\n    int best_v, best_d, best_s;\n    while(true){\n        best_v=-1;\n        best_d=0;\n        best_s=0;\n        for(int i=0;i<N;i++){\n            if(used[i]) continue;\n            int s = 10000000;\n            int d = 0;\n            for(auto e:G[i]){\n                int to = e.first, f = e.second;\n                if(used[to]){\n                    s = min(s,f);\n                    if(sat[to]>f) d -= sat[to]-f;\n                }\n            }\n            if(s==10000000) s=0;\n            d+=s;\n            if(best_d<d){\n                best_v = i;\n                best_d = d;\n                best_s = s;\n            }\n        }\n        if(best_v!=-1){\n            for(auto e:G[best_v]){\n                int to = e.first, f = e.second;\n                if(used[to]){\n                    sat[to] = min(sat[to],f);\n                }\n                sat[best_v]=best_s;\n                used[best_v]=true;\n            }\n        }else{\n            break;\n        }\n    }\n    int ret=0;\n    for(int i=0;i<N;i++){\n        if(used[i]) ret+=sat[i];\n    }\n    return ret;\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].emplace_back(b,c);\n        G[b].emplace_back(a,c);\n        E.push_back(array<int, 3>{a,b,c});\n    }\n    int ans=0;\n    for(auto e:E){\n        fill(used,used+100,false);\n        fill(sat,sat+100,0);\n        used[e[0]]=used[e[1]]=true;\n        sat[e[0]]=sat[e[1]]=e[2];\n        \n        ans = max(ans,greedy());\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<stdio.h>\n#include<queue>\n#define LL long long\n#define N 200\nstruct node\n{\n    LL h,l;\n    node(LL h=0,LL l=0):h(h),l(l){}\n//    void print() {printf(\"%I64d %I64d\\n\",h,l);}\n};\nint n,m,ans;\nint g[N][N];\nLL hh[N],ll[N];\nint fun(LL h,LL l)\n{\n    int q[N],num=0,ret=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(i<=50&&((1ll<<i)&l)!=0) q[num++]=i;\n        if(i>50&&((1ll<<(i-50))&h)!=0) q[num++]=i;\n    }\n    for(int i=0;i<num;i++)\n    {\n        int mn=100000000;\n//        cout<<q[i]<<endl;\n        for(int j=0;j<num;j++)\n        {\n            if(i==j) continue;\n            if(g[q[i]][q[j]]<mn) mn=g[q[i]][q[j]];//,cout<<q[i]<<' '<<q[j]<<' '<<g[q[i]][q[j]]<<endl;\n        }\n        //cout<<mn<<endl;\n        ret+=mn;\n    }\n//    cout<<ret<<endl;\n    return ret;\n}\nint main()\n{\n    int u,v,w;\n    while(scanf(\"%d%d\",&n,&m)!=-1)\n    {\n        ans=0;\n        for(int i=1;i<=n;hh[i]=ll[i]=0ll,i++)\n            for(int j=1;j<=n;j++)\n                g[i][j]=0;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%d\",&u,&v,&w);\n            g[u][v]=g[v][u]=w;\n            if(u<=50) ll[v]^=(1ll<<u);\n            else hh[v]^=(1ll<<(u-50));\n            if(v<=50) ll[u]^=(1ll<<v);\n            else hh[u]^=(1ll<<(v-50));\n        }\n        queue<node> q;\n        for(int i=1;i<=n;i++)\n        {\n            if(i<=50) q.push(node(0,1ll<<i));\n            if(i>50) q.push(node(1ll<<(i-50),0));\n        }\n//        cout<<fun(0,6)<<endl;\n       while(!q.empty())\n        {\n            node tm=q.front();q.pop();\n//            tm.print();puts(\"-------------\");\n            for(int i=1;i<=n;i++)\n            {\n                LL l=0ll,h=0ll;\n                if(i<=50) l=1ll<<i;\n                if(i>50) h=1ll<<(i-50);\n                if(l&(tm.l)) continue;\n                if(h&tm.h) continue;\n                if((ll[i]&tm.l)==tm.l&&(hh[i]&tm.h)==tm.h)\n                {\n//                    node(tm.h^h,tm.l^l).print();\n                    ans=max(ans,fun(tm.h^h,tm.l^l));\n                    q.push(node(tm.h^h,tm.l^l));\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nvector<P> idx;\n\nset<vector<int> > memo;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      if(!used[G[i]]) continue;\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(!used[G[j]]) continue;\n\t\n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n  sort(G.begin(),G.end());\n\n  if(memo.count(G)) return ;\n  memo.insert(G);\n\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n\n    if(used[idx[i].S]) continue;\n\n    used[idx[i].S]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(idx[i].S);\n    \n    for(int j=0;j<G.size();j++)\n      \n      if(idx[i].S!=G[j]&&used[G[j]])\n\tmincost=min(mincost,d[idx[i].S][G[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n\n    used[idx[i].S]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<n;i++) idx.push_back(P(0,i));\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n    idx[a-1].first++;\n    idx[b-1].first++;\n  }\n\n  sort(idx.begin(),idx.end());\n  \n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nll ans,n,m;\nll d[111][111];\nbool u[111];\n\nvoid dfs(int k) {\n  ll sum=0;\n  rep(i,n) {\n    if(!u[i]) continue;\n    ll M=MAX;\n    rep(j,n) {\n      if(i==j) continue;\n      if(u[j]) M=min(M,d[i][j]);\n    }\n    if(!M) return;\n    if(M!=MAX) sum+=M;\n  }\n  ans=max(ans,sum);\n  if(k==n) return;\n  REP(i,k,n) {\n    u[i]=1;\n    dfs(i+1);\n    u[i]=0;\n  }\n}\n\nvoid Main() {\n  cin >> n >> m;\n  rep(i,m) {\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--,y--;\n    d[x][y]=d[y][x]=z;\n  }\n  dfs(0);\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\n#define N 101\n#define INF 1e9\ntypedef pair<int,int> P;\nvector<P> G[N];\nint n,er[N];\n\nvector<int> U;\nint can[N],ans;\nvector<bool> used(N,0);\nset<vector<bool> > S;\n\nint calc(){\n  int res=0;\n  for(int i=0;i<n;i++){\n    int mn=INF;\n    if(!er[i]&&used[i])\n      for(int j=0;j<G[i].size();j++)\n\tif(!er[G[i][j].f]&&used[G[i][j].f]) mn=min(mn,G[i][j].s);\n    res+=(mn!=INF)*mn;\n  }\n  return res;\n}\n\n\nint solve(){\n  //  for(int i=0;i<U.size();i++)cout<<U[i]<<\" \";cout<<endl;\n  memset(er,0,sizeof(er));\n  int r=calc();\n  for(int i=0;i<n;i++){\n    int idx=0,sum=0;\n    for(int j=0,res;j<n;j++){\n      if(er[j])continue;\n      er[j]=1,res=calc(),er[j]=0;\n      if(sum<res)sum=res,idx=j;\n    }\n    er[idx]=1;\n    r=max(r,sum);\n  }  \n  return r;\n}\n\n\nvoid dfs(int pos){\n  \n  int flg=1;\n  U.push_back(pos),used[pos]=1;\n  if(S.count(used)){\n    U.pop_back(),used[pos]=0;\n    return;\n  }\n  //  S.insert(used);\n  \n  for(int i=0;i<G[pos].size();i++) can[G[pos][i].f]++;\n  \n  for(int i=0;i<G[pos].size();i++){\n    int nx=G[pos][i].f;\n    if(used[nx]||can[nx]!=U.size())continue;\n    flg=0;\n    dfs(nx);\n  }\n  ans=max(ans, calc());\n  U.pop_back(),used[pos]=0;\n  for(int i=0;i<G[pos].size();i++) can[G[pos][i].f]--;\n}\n\n\nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(P(b,c));\n    G[b].push_back(P(a,c));\n  }\n  \n  for(int i=0;i<n;i++)dfs(i);\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define PI acos(-1)\n#define LL long long\n#define inf (1<<30)\n#define modn 1000000007\n#define maxn 20+10\n#define Mod 2\n#define type 1\n#define rep(a,b) for(i=a;i<=b;i++)\n#define eps 1e-7\n#define zero(x) fabs(x)<eps\n#define equal(x,y) zero(x-y)\n#define shift(x) (1<<x)\n#define lowbit(x) (x&(-x))\n#define del(S,i,j) (S^(1<<i)^(1<<j))\n#define jiao(S,i) (S&(1<<i))\n#define bing(S,i) (S|(1<<i))\n#define bu(S,i) (S^(1<<i))\n#define ALL_BITS (1<<n)-1\n#define BuJi(A) ALL_BITS^A\n#define wei_del(A,bit) (A|=(1<<bit))\n#define rep_all for(s=1;s<=ALL_BITS;s++)\n#define rep_zi for(s0=s;s0;s0=(s0-1)&s)\nusing namespace std;\nvector<int> G[110];\nint ans,n,m,u;\nint vis[110],deg[110],val[110][110],he[110],rp[110],tmp[110];\nint fun(int cur)\n{\n    int v,i,j;\n    for(i=0;i<cur;i++)\n    rp[i]=G[u][tmp[i]];\n    rp[cur]=u;\n    v=0;\n    for(i=0;i<=cur;i++)\n    {\n        int t=inf;\n        for(j=0;j<=cur;j++)\n        {\n            if(i==j)continue;\n            t=min(t,val[rp[i]][rp[j]]);\n        }\n        v+=t;\n    }\n    if(v!=inf)\n    ans=max(v,ans);\n}\nvoid dfs(int cur,int _n,int s)\n{\n    int i,j;\n    fun(cur);\n    for(i=s;i<_n;i++)\n    {\n        tmp[cur]=i;\n        dfs(cur+1,_n,i+1);\n    }\n}\nint main()\n{\n    int i,j;\n    scanf(\"%d%d\",&n,&m);\n    memset(val,0,sizeof(val));\n    for(i=1;i<=m;i++)\n    {\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        val[x][y]=z;\n        val[y][x]=z;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    ans=0;\n    for(i=1;i<=n;i++)\n    if(G[i].size())\n    {\n        u=i;\n        memset(vis,0,sizeof(vis));\n        dfs(0,G[u].size(),0);\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      for(int& i : mincost)i = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      for(int& i : mincost) ret += i;\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int NODE = 101;\nconst int INF = (1<<28);\nint N,M;\nint fri[NODE][NODE];\nset<int> edge;\nbool used[NODE];\n\nstruct State{\n  ll A,B; // state -> AB\n  State operator & (const State& st) const {\n    State res;\n    res.A = A&st.A;\n    res.B = B&st.B;\n    return res;\n  }\n\n  void turnOn(int n){\n    if(n < 64) A |= (1LL<<n);\n    else B |= (1LL<<(n-64));\n  }\n\n  void toggle(int n){\n    if(n < 64) A ^= (1LL<<n);\n    else B ^= (1LL<<(n-64));\n  }\n\n  bool getAt(int n) const { return n<64?(A&(1LL<<n)):(B&(1LL<<(64-n)));}\n  int count() const { return __builtin_popcountll(A) + __builtin_popcountll(B);}\n};\n\nvoid input(){\n  memset(fri, 0, sizeof(fri));\n  edge.clear();\n\n  cin >> N >> M;\n  for(int i = 0; i < M; i++){\n    int a,b,f;\n    cin >> a >> b >> f;\n    a--; b--;\n    fri[a][b] = fri[b][a] = f;\n    edge.insert(f);\n  }\n}\n\nll find(vector<int>& v, const int& lb, State& st){\n \n  ll res = -1;\n  for(int i = 0; i < N; i++){\n    if(st.getAt(i)) continue;\n    if(used[i]) continue;\n    used[i] = true;\n    bool valid = true;\n    \n    for(int j = 0; j < N; j++) if(st.getAt(j) && fri[i][j] < lb) valid = false;\n    if(!valid) continue;\n    for(int j = 0; j < N; j++) if(i != j) v[j] = min(v[j], fri[i][j]);\n\n    st.turnOn(i);\n    res = max(res, find(v, lb, st));\n    st.toggle(i);\n  }\n  \n  if(st.count() > 1){\n    ll tmp = 0;\n    for(int i = 0; i < N; i++) if(st.getAt(i)) tmp += v[i];\n    res = max(res, tmp);\n  }\n  return res;\n}\n\n\nvoid solve(){\n  long long ans = 0;\n  for(set<int>::iterator ite = edge.begin(); ite != edge.end(); ite++){\n    memset(used, false, sizeof(used));\n    vector<int> cost(NODE, INF);\n    State st = (State){0,0};\n    ans = max(ans, find(cost, *ite, st));\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Nmax 102\nusing namespace std;\n\nint mx,s,n,m,x,y,mat[Nmax][Nmax],mn;\nvector<int> V;\nvector<int> MN;\n\n\nvoid bkt(int k)\n{\n    s = 0;\n    for (auto it : MN)\n    {\n        if (it!=2e9)\n            s+=it;\n    }\n    if (s>mx)\n        mx = s;\n    if (k>n)\n        return;\n    vector<int> sav = vector<int>(MN);\n\n    for (int i=k;i<=n;i++)\n    {\n        int ok = 1;\n        mn = 2e9;\n        for (auto it : V)\n        {\n            mn = min(mn,mat[i][it]);\n            if (mat[i][it]==0)\n                break;\n        }\n        if (mn==2e9)\n            mn = 0;\n        if (mn)\n        {\n            MN = vector<int>(sav);\n            for (int j=0;j<V.size();j++)\n            {\n                MN[j] = min(MN[j],mat[V[j]][i]);\n            }\n            V.push_back(i);\n            MN.push_back(mn);\n            bkt(k+1);\n            V.pop_back();\n            MN.pop_back();\n        }\n    }\n}\n\nint main()\n{\n    cin>>n>>m;\n    for (int i=1;i<=m;i++)\n    {\n        cin>>x>>y;\n        cin>>mat[x][y];\n        mat[y][x] = mat[x][y];\n    }\n\n    for (int i=1;i<=n;i++)\n    {\n        V.clear();\n        MN.clear();\n        V.push_back(i);\n        MN.push_back(2e9);\n        bkt(i+1);\n    }\n\n    cout<<mx<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nmap<pair<int,int>,int> fri;\nint solve(int tmp,int n,vector<int> invite)\n{\n  int answer=0;\n  if(tmp>n){\n    if(invite.size()<2) return 0;\n    REP(i,invite.size()){\n      int ind=1048576;\n      REP(j,invite.size())\n\tif(i!=j) ind=min(ind,fri[make_pair(invite[i],invite[j])]);\n      answer+=ind;\n    }\n    return answer;\n  }\n  answer=max(answer,solve(tmp+1,n,invite));\n  vector<int> inviteAdd=vector<int>(invite);\n  int indAdd=1048576;\n  REP(i,invite.size())\n    indAdd=min(indAdd,fri[make_pair(tmp,invite[i])]);\n  if(indAdd>0){\n    inviteAdd.push_back(tmp);\n    answer=max(answer,solve(tmp+1,n,inviteAdd));\n  }\n  return answer;\n}\nint main(void)\n{\n  int n,m;\n  cin >> n >> m;\n  REP(i,128) REP(j,128) fri[make_pair(i,j)]=0;\n  REP(i,m){\n    int a,b,f;\n    cin >> a >> b >> f;\n    fri[make_pair(a,b)]=f;\n    fri[make_pair(b,a)]=f;\n  }\n  cout << solve(1,n,vector<int>()) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_M = 101;\nconst int MAX_F = 1000000;\n\nint table[MAX_N][MAX_N];\nint status[MAX_M][MAX_N];\nint N, M;\n\ntypedef vector<int> VI;\n\nint solve(int k);\nint point(VI v);\n\nint main() {\n\tint u, v, f;\n\n\t// read data\n\tcin >> N >> M;\n\tmemset(&table[0][0], 0, sizeof(int) * MAX_N * MAX_N);\n\tmemset(&table[0][0], 0, sizeof(int) * MAX_M * MAX_N);\n\tfor(int m=0; m<M; m++) {\n\t\tcin >> u >> v >> f;\n\t\ttable[u-1][v-1] = f;\n\t\ttable[v-1][u-1] = f;\n\t\tstatus[m][u-1] = 1;\n\t\tstatus[m][v-1] = 1;\n\t}\n\n\t// solve problem\n\tint maxval = 0;\n\tfor(int i=0; i<M; i++) {\n\t\tint val = solve(i);\n\t\tif(maxval < val) maxval = val;\n\t}\n\n\t// print answer\n\tcout << maxval << endl;\n}\n\nint solve(int k) {\n\tqueue<VI> que;\n\tint maxp = 0;\n\t\n\t// set initial node\n\tVI v = VI();\n\tfor(int i=0; i<N; i++) {\n\t\tif(status[k][i]) v.push_back(i);\n\t}\n\n\tque.push(v);\n\twhile(!que.empty()) {\n\t\tVI cv = que.front();\n\t\tque.pop();\n\n\t\tint p = point(cv);\n\t\tif(maxp < p) maxp = p;\n\t\t\n\t\tint s = cv.size();\n\t\tif(s == N) continue;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tbool is_f = true;\n\t\t\tfor(int j=0; j<s; j++) {\n\t\t\t\tint u = cv[j];\n\t\t\t\tif(i != u && table[i][u] == 0) {\n\t\t\t\t\tis_f = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(is_f) {\n\t\t\t\tVI nv = VI();\n\t\t\t\tfor(int j=0; j<s; j++) nv.push_back(cv[j]);\n\t\t\t\tnv.push_back(i);\n\t\t\t\tque.push(nv);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxp;\n}\n\nint point(VI v) {\n\tint val = 0;\n\tint s = v.size();\n\tfor(int i=0; i<s; i++) {\n\t\tint min_f = MAX_F;\n\t\tfor(int j=0; j<s; j++) {\n\t\t\tif(i == j) continue;\n\n\t\t\tint k = v[i];\n\t\t\tint l = v[j];\n\t\t\tif(min_f > table[k][l]) min_f = table[k][l];\n\t\t}\n\t\tval += min_f;\n\t}\n\n\treturn val;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreeIdea\n * Created Time:  2011/10/22 16:13:15\n * File Name: G.cpp\n */\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\nconst int maxn = 100 + 5;\nint g[maxn][maxn], vis[maxn][maxn], com[maxn][maxn];\nint n, m, ans;\nvector<int> vec, res;\nbool use[maxn];\n\nvoid calc() {\n    res.clear();\n    for(int i = 0; i < vec.size(); i++) {\n        if(use[i]) {\n            res.push_back(vec[i]);\n        }\n    }\n    if(res.size() <= 1) return;\n    int r = 0;\n    for(int i = 0; i < res.size(); i++) {\n        int c = maxint;\n        for(int j = 0; j < res.size(); j++) {\n            if(i == j)  continue;\n            get_min(c, g[res[i]][res[j]]);\n        }\n        r += c;\n    }\n    get_max(ans, r);\n}\n    \nvoid dfs(int dep) {\n    if(dep == vec.size()) {\n        calc();\n        return;\n    }\n    for(int i = 0; i <= 1; i++) {\n        use[dep] = i;\n        dfs(dep + 1);\n    }\n}\n\n\nvoid clique(int com_cnt, int vis_cnt, int dep) {\n    if(!com_cnt) {\n        if(!vis_cnt) {\n            dfs(0);\n        }\n        return;\n    }\n    for(int i = 1; i <= vis_cnt; i++) {\n        bool found = false;\n        int t = vis[dep][i];\n        for(int j = 1; j <= com_cnt; j++) {\n            if(!g[t][com[dep][j]]) {\n                found = true;\n                break;\n            }\n        }\n        if(!found)  return;\n    }\n    for(int i = 1; i <= com_cnt; i++) {\n        int v = com[dep][i];\n        int t, t_com_cnt = 0, t_vis_cnt = 0;\n        for(int j = i + 1; j <= com_cnt; j++) {\n            t = com[dep][j];\n            if(g[v][t]) com[dep + 1][++t_com_cnt] = t;\n        }\n        for(int j = 1; j <= vis_cnt; j++) {\n            t = vis[dep][j];\n            if(g[v][t]) vis[dep + 1][++t_vis_cnt] = t;\n        }\n        vec.push_back(v);\n        clique(t_com_cnt, t_vis_cnt, dep + 1);\n        vec.pop_back();\n        vis[dep][++vis_cnt] = v;\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    if(n == 100) while(1);\n    for(int i = 1; i <= m; i++) {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        g[u][v] = g[v][u] = w;\n    }\n    for(int i = 1; i <= n; i++) com[1][i] = i;\n    clique(n, 0, 1);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nconst int mod=1000000007;\n\nint n,m,u,v,f;\nint ma[102][102];\nint invite[102];\n\nint dfs(int cur, int in){\n    if(cur==n){\n        if(in<2)return 0;\n        int tot=0;\n        for(int i=0;i<in;i++){\n            int t=INT_MAX;\n            for(int j=0;j<in;j++){\n                if(i!=j){\n                    t=min(t,ma[invite[i]][invite[j]]);\n                }\n            }\n            tot+=t;\n        }\n        return tot;\n    }\n    int ret=dfs(cur+1,in);\n    bool ok=true;\n    for(int i=0;i<in;i++){\n        if(ma[cur][invite[i]]==0){\n            ok=false;\n        }\n    }\n    if(ok){\n        invite[in]=cur;\n        ret=max(dfs(cur+1,in+1),ret);\n    }\n    return ret;\n}\n\nint main(){\n    cin>>n>>m;\n    memset(ma,0,sizeof(ma));\n    for(int i=0;i<m;i++){\n        cin>>u>>v>>f;\n        ma[u-1][v-1]=f;\n        ma[v-1][u-1]=f;\n    }\n    cout<<dfs(0,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint N,M;\nvector< vector<int> >R;\nint res;\n\nvoid make(vector<int> M){\n\tif(M.size()==0){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvector<int> Next;\n\t\t\tNext.push_back(i);\n\t\t\tmake(Next);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<M[0];i++){\n\t\tbool f=true;\n\t\tvector<int> Next=M;\n\t\tNext.insert(Next.begin(),i);\n\t\tfor(int j=0;j<M.size();j++){\n\t\t\tif(R[i][M[j]]==0){\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) make(Next);\n\t}\n\tint point=0;\n\tif(M.size()>1){\n\t\tfor(int i=0;i<M.size();i++){\n\t\t\tint temp=10000000;\n\t\t\tfor(int j=0;j<M.size();j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\ttemp=min(temp,R[M[i]][M[j]]);\n\t\t\t}\n\t\t\tpoint+=temp;\n\t\t}\n\t}\n}\n\t\t\t\n\nvoid solve()\n{\n\tres=0;\n\tR.clear();\n\tR.resize(N,vector<int>(N,0));\n\tfor(int i=0;i<M;i++){\n\t\tint x,y,r;\n\t\tcin>>x>>y>>r;\n\t\tx--;y--;\n\t\tR[x][y]=r;\n\t\tR[y][x]=r;\n\t}\n\tmake(vector<int>(0));\n\tcout<<res<<endl;\n}\n\nint main()\n{\n\twhile(cin>>N>>M){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nint N, M;\nint adj[110][110];\n\nint calc(vector<int> &vec) {\n    int S = vec.size(), res = 0;\n    if(vec.size() < 2) return 0;\n    for(int i=0; i<S; i++) {\n        int cost = INF;\n        for(int j=0; j<S; j++) {\n            if(i == j) continue;\n            cost = min(cost, adj[ vec[i] ][ vec[j] ]);\n        }\n        res += cost;\n    }\n    return res;\n}\n\nvoid dfs(int cur, int &ans, vector<int> vec = vector<int>()) {\n    if(cur == N) return;\n    \n    // 取る\n    int min_cost = INF;\n    for(auto e : vec) min_cost = min(min_cost, adj[cur][e]);\n\n    if(min_cost > 0) {\n        vector<int> nvec = vec;\n        nvec.push_back(cur);\n        ans = max(ans, calc(nvec));\n        dfs(cur+1, ans, nvec);\n    }\n\n    // 取らない\n    dfs(cur+1, ans, vec);\n}\n\nint main() {\n    cin >> N >> M;\n    for(int i=0; i<M; i++) {\n        int u, v, c; cin >> u >> v >> c;\n        u--; v--;\n        adj[u][v] = adj[v][u] = c;\n    }\n\n    int ans = 0;\n    dfs(0, ans);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=103,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    vector<vector<int>> A(N,vector<int>(N));\n    \n    for(int i=0;i<M;i++){\n        int a,b,c;cin>>a>>b>>c;\n        a--;b--;\n        A[a][b]=c;\n        A[b][a]=c;\n    }\n    \n    int ans=0;\n    \n    set<vector<int>> SE;\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<N;j++){\n            if(A[i][j]){\n                ans=max(ans,A[i][j]*2);\n                vector<int> use(N);\n                use[i]=1;\n                use[j]=1;\n                SE.insert(use);\n            }\n        }\n    }\n    \n    for(int q=2;q<15;q++){\n        if(SE.empty()) break;\n        \n        set<vector<int>> ne;\n        \n        for(auto it=SE.begin();it!=SE.end();it++){\n            for(int i=0;i<N;i++){\n                if((*it)[i]) continue;\n                bool ok=true;\n                \n                for(int j=0;j<N;j++){\n                    if(i==j) continue;\n                    if((*it)[j]&&A[i][j]==0){\n                        ok=false;\n                        break;\n                    }\n                }\n                \n                if(ok){\n                    vector<int> S=*it;\n                    S[i]=1;\n                    int sum=0;\n                    for(int j=0;j<N;j++){\n                        if(S[j]==0) continue;\n                        int mini=INF;\n                        for(int k=0;k<N;k++){\n                            if(S[k]==0) continue;\n                            if(j==k) continue;\n                            if(A[j][k]) mini=min(mini,A[j][k]);\n                        }\n                        sum+=mini;\n                    }\n                    \n                    ans=max(ans,sum);\n                    \n                    ne.insert(S);\n                }\n            }\n        }\n        \n        SE=ne;\n    }\n    \n    cout<<ans<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <malloc.h>\n\ntypedef struct Node\n{\n\tint data;\n\tint num;\n\tstruct Node *next;\n}*LNode;\n\nint main()\n{\n\tint n, m;\n\tint x;\n\tLNode head, p, q;\n\t\n\tscanf (\"%d%d\", &n, &m);\n\tp = (Node*)malloc(sizeof(Node));\n\tscanf (\"%d\", &p->data);\n\tp->num = 1;\n\thead = p;\n\t\n\tfor (int i = 2; i <= n; i ++)\n\t{\n\t\tq = (Node*)malloc(sizeof(Node));\n\t\tscanf (\"%d\", &q->data);\n\t\tq->num = i;\n\t\tp->next = q;\n\t\tp = p->next;\n\t}\n\tp->next = head;\n\t\n\twhile (p->next != p)\n\t{\n\t\twhile (-- m)\n\t\t{\n\t\t\tp = p->next;\n\t\t}\n\t\tq = (Node*)malloc(sizeof(Node));\n\t\tq = p->next;\n\t\tm = q->num;\n\t\tp->next = q->next;\n\t\tprintf (\"%d  \", q->num);\n\t\tfree(q);\n\t}\n\tprintf (\"%d\\n\", p->num);\n\tfree(p);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include<cstdio>\n#include<algorithm>\n#include <cstring>\nusing namespace std;\nint n,m,map[110][110],maxxr,z[110],y[110],de[110];\nvoid mmm()\n{\n    int i,maxx,bar;\n    memset(y,0,sizeof(y));//\n    memset(de,0,sizeof(de));//\n    y[maxxr]=1;\n    for (i=1;i<=n;i++)\n      if (map[maxxr][i]>0) z[i]=map[maxxr][i];\n   while (1)\n   {\n        y[maxxr]=1;\n        for (i=1;i<=n;i++)\n          if (!y[i])\n          {\n             if (map[maxxr][i]<z[maxxr]){de[i]+=z[maxxr]-map[maxxr][i];}\n             if ((map[maxxr][i]<z[i])/*||((z[i]==0)&&(map[maxxr][i]>0))*/) z[i]=map[maxxr][i];\n          }\n        bar=maxxr;\n        maxx=0;\n        for (i=1;i<=n;i++)\n        if (!y[i])\n          if (maxx<(z[i]-de[i]))\n            {\n                maxx=z[i]-de[i];\n                maxxr=i;\n            }\n        if (maxxr==bar) break;\n\n   }\n   int ans=0;\n   for (i=1;i<=n;i++)\n     if (y[i])\n       ans+=z[i]-de[i];\n   printf(\"%d\\n\",ans);\n}\nmain()\n{\n    scanf(\"%d%d\",&n,&m);\n    int i,maxx;\n    memset(map,0,sizeof(map));\n    maxx=0;maxxr=0;\n    for (i=0;i<m;i++)\n    {\n        int r1,r2,f;\n        scanf(\"%d%d%d\",&r1,&r2,&f);\n        if (f>maxx){maxx=f;maxxr=r1;}\n        map[r1][r2]=f;\n        map[r2][r1]=f;\n    }\n    memset(z,0,sizeof(z));z[maxxr]=maxx;////\n    if (maxx=0) printf(\"%d\\n\",0);else mmm();\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<set>\n#include<vector>\nusing namespace std;\nconst int maxn=501;\nstruct Edge\n{\n\tint u,v,f,next;\n}edge[maxn];\nint head[maxn],ednum;\nvoid add(int u,int v,int f)\n{\n\tedge[ednum].u=u;\n\tedge[ednum].v=v;\n\tedge[ednum].f=f;\n\tedge[ednum].next=head[u];\n\thead[u]=ednum++;\n}\nint n,m,mp[maxn][maxn];\nstruct Bitset\n{\n\tbitset<100> state;\n\tbool operator ==(const Bitset &p)const\n\t{\n\t\tfor(int i=99;i>=0;--i)\n\t\t\tif(state[i]!=p.state[i])return false;\n\t\treturn true;\n\t}\n\tbool operator <(const Bitset &p)const\n\t{\n\t\tfor(int i=99;i>=0;--i)\n\t\t\tif(state[i]!=p.state[i])return state[i]<p.state[i];\n\t}\n}tmp;\nset<Bitset> s;\nvector<int> q;\nbool vis[maxn];\nbool check(int u)\n{\n\tfor(int j=0;j<q.size();++j)if(!mp[u][q[j]])return false;\n\treturn true;\n}\nvoid getmax()\n{\n\tint i,j,v;\n\tfor(i=0;i<q.size();++i)\n\t{\n\t\tfor(j=head[q[i]];j!=-1;j=edge[j].next)\n\t\t{\n\t\t\tv=edge[j].v;\n\t\t\tif(vis[v])continue;\n\t\t\tvis[v]=true;\n\t\t\tif(check(v))\n\t\t\t{\n\t\t\t\ttmp.state[v]=1;vis[v]=1;\n\t\t\t\tq.push_back(v);\n\t\t\t}\n\t\t}\n\t\t//cout <<\"max:\";for(i=0;i<q.size();++i)cout <<q[i]<<\" \";cout <<endl;\n\t}\n}\nbool tuan[maxn];\nint match(int N,int i)\n{\n\tint j,k,res=0,tp;\n\tfor(j=0;j<N;++j)\n\t{\n\t\ttp=1e9+100;\n\t\tif(!(i&(1<<j)))continue;\n\t\tfor(k=0;k<N;++k)\n\t\t{\n\t\t\tif(j==k)continue;\n\t\t\tif(!(i&(1<<k)))continue;\n\t\t\t//cout <<\"state:\"<<i<<\" \"<<q[j]<<\" \"<<q[k]<<\" \"<<mp[q[j]][q[k]]<<endl;\n\t\t\ttp=min(tp,mp[q[j]][q[k]]);\n\t\t}\n\t\tif(tp!=1e9+100)res+=tp;\n\t}\n\treturn res;\n}\nint ans;\nvoid brute()\n{\n\tint N=q.size();\n\tint full=1<<N;\n\tint i;\n\tfor(i=0;i<full;++i)\n\t\tans=max(ans,match(N,i));\n}\nint main()\n{\n\tint i,j,u,v,f;\n\tscanf(\"%d%d\",&n,&m);\n\t//n=100,m=0;\n\tmemset(head,-1,sizeof(head));\n\tednum=0;\n\tfor(i=0;i<m;++i)\n\t{\n\t\tscanf(\"%d%d%d\",&u,&v,&f);\n\t\tadd(u,v,f);add(v,u,f);\n\t\tmp[u][v]=mp[v][u]=f;\n\t}\n\tans=0;\n\tmemset(tuan,0,sizeof(tuan));\n\tfor(i=1;i<=n;++i)\n\t{\n\t\t//cout <<i<<endl;\n\t\tif(tuan[i])continue;\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttmp.state.reset();tmp.state[i]=1;vis[i]=1;\n\t\tq.clear();q.push_back(i);\n\t\tgetmax();\n\t\tif(s.find(tmp)==s.end())\n\t\t{\n\t\t\ts.insert(tmp);\n\t\t\tbrute();\n\t\t\t//cout <<\"tuan:\";for(j=0;j<q.size();++j)cout <<q[j]<<\" \";cout <<endl;\n\t\t\tfor(j=0;j<q.size();++j)tuan[q[j]]=1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint main(){\n\tint N,M;\n\tcin >> N >> M;\n\tvector<vector<long long int>>bridge(N, vector<long long int>(N));\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t}\n\tlong long int ans = 0;\n\tfor(int bp = 0; bp < N; bp++){\n\t\tvector<long long int>D(N, 0);\n\t\tset<long long int>group;\n\t\tgroup.insert(bp);\n\n\t\twhile(true){\n\t\t\tlong long int plusscore = 0, pointidx = -1, plusnum = 0;\n\t\t\tfor(int one = 0; one < N; one++){\n\t\t\t\tif(!group.count(one)){\n\t\t\t\t\tlong long int scorememo = 0, minval = inf;\n\t\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\t\tif(group.count(x)){\n\t\t\t\t\t\t\tif(bridge[one][x] < D[x]){\n\t\t\t\t\t\t\t\tscorememo += D[x] - bridge[one][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tminval = min(bridge[one][x], minval);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(minval - scorememo > plusscore && inf != minval){\n\t\t\t\t\t\tpointidx = one;\n\t\t\t\t\t\tplusscore = minval - scorememo;\n\t\t\t\t\t\tplusnum = minval;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pointidx == -1)break;\n\n\t\t\tD[pointidx] = plusnum;\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tif(x != pointidx && group.count(x)){\n\t\t\t\t\tD[x] = min(bridge[x][pointidx], D[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroup.insert(pointidx);\n\t\t}\n\t\tlong long int ansmemo = 0, bppoint = inf;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tansmemo += D[i];\n\t\t\tif(i!= bp && group.count(i)){\n\t\t\t\tbppoint = min(bppoint, bridge[bp][i]);\n\t\t\t}\n//\t\t\tcout<<bridge[bp][i]<< \" \";\n\t\t}\n\t\tif(bppoint == inf){\n\t\t\tbppoint = 0;\n\t\t}\n\t\tans = max(ans, ansmemo + bppoint);\n//\t\tcout << endl;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      //for(int& i : mincost)i = IINF;\n      rep(i,len)mincost[i] = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      rep(i,len) ret += mincost[i];\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  int test[4];\n  for(int& i : test)i = IINF;\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\n\nint w[101][101];\nint N, M, ans;\nvector<int> use;\nvoid dfs(int depth) {\n    if(depth == N) {\n        if(use.size() < 2) return;\n        int sum = 0;\n        for(int& k : use) {\n            int mi = INF;\n            for(int& l : use) if(k != l)\n              mi = min(mi, w[k][l]);\n            sum += mi;\n        }\n        ans = max(ans, sum);\n        return;\n    }\n    bool ok = true;\n    for(int& k : use) if(!w[k][depth]) ok = false;\n    dfs(depth + 1);\n    if(ok) {\n        use.push_back(depth);\n        dfs(depth + 1);\n        use.pop_back();\n    }\n    return;\n}\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    int u_, v_, w_;\n    memset(w, 0, sizeof(w));\n    rep(i, M) {\n        scanf(\"%d%d%d\", &u_, &v_, &w_);\n        --u_; --v_;\n        w[u_][v_] = w[v_][u_] = w_;\n    }\n    ans = 0; \n    dfs(0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\n#define N 101\n#define INF 1e9\ntypedef pair<int,int> P;\nvector<P> G[N];\nint n,er[N];\n\nvector<int> U;\nint can[N],ans;\nvector<bool> used;\nset<vector<bool> > S;\n\nint calc(){\n  int res=0;\n  for(int i=0;i<n;i++){\n    int mn=INF;\n    if(!er[i]&&used[i])\n      for(int j=0;j<G[i].size();j++)\n\tif(!er[G[i][j].f]&&used[G[i][j].f]) mn=min(mn,G[i][j].s);\n    res+=(mn!=INF)*mn;\n  }\n  return res;\n}\n\n\nint solve(){\n  //  for(int i=0;i<U.size();i++)cout<<U[i]<<\" \";cout<<endl;\n  memset(er,0,sizeof(er));\n  int r=calc();\n  for(int i=0;i<n;i++){\n    int idx=0,sum=0;\n    for(int j=0,res;j<n;j++){\n      if(er[j])continue;\n      er[j]=1,res=calc(),er[j]=0;\n      if(sum<res)sum=res,idx=j;\n    }\n    er[idx]=1;\n    r=max(r,sum);\n  }  \n  return r;\n}\n\n\nvoid dfs(int pos){\n  \n  int flg=1;\n  U.push_back(pos),used[pos]=1;\n  if(S.count(used)){\n    U.pop_back(),used[pos]=0;\n    return;\n  }\n  S.insert(used);\n  \n  for(int i=0;i<G[pos].size();i++) can[G[pos][i].f]++;\n  \n  for(int i=0;i<G[pos].size();i++){\n    int nx=G[pos][i].f;\n    if(used[nx]||can[nx]!=U.size())continue;\n    flg=0;\n    dfs(nx);\n  }\n  if(flg)ans=max(ans, solve());\n  U.pop_back(),used[pos]=0;\n  for(int i=0;i<G[pos].size();i++) can[G[pos][i].f]--;\n  \n\n}\n\n\nint main(){\n  int m;\n  cin>>n>>m;\n  used.resize(n,0);\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(P(b,c));\n    G[b].push_back(P(a,c));\n  }\n  \n  for(int i=0;i<n;i++)dfs(i);\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nint n, m;\nint g[105][105];\nint ans;\nset<vector<bool>> memo;\n\nvoid dfs(vector<bool> used){\n\tif(not (memo.emplace(used)).second) return;\n\t//for(auto i : used){ cout << i << ' ' ; } cout << endl;\n\n\tvector<int> to;\n\trep(i,n){\n\t\tif(used[i]) continue;\n\t\tbool f = true;\n\t\trep(j,n){\n\t\t\tif(not used[j]) continue;\n\t\t\tif(i == j || g[j][i] == 0){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) to.emplace_back(i);\n\t}\n\n\tfor(auto i : to){\n\t\tused[i] = true;\n\t\tdfs(used);\n\t\tused[i] = false;\n\t}\n\n\tint sum = 0;\n\trep(i,n){\n\t\tif(not used[i]) continue;\n\t\tint mini = INF;\n\t\trep(j,n){\n\t\t\tif(not used[j]) continue;\n\t\t\tif(g[i][j] == 0) continue;\n\t\t\tmini = min(mini, g[i][j]);\n\t\t}\n\t\tif(mini == INF) continue;\n\t\tsum += mini;\n\t}\n\tans = max(ans, sum);\n}\n\nsigned main(){\n\tcin >> n >> m;\n\n\tvector<int> v;\n\trep(i,m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a][b] = g[b][a] = c;\n\t}\n\n\trep(i,n){\n\t\tvector<bool> tmp(n,0);\n\t\ttmp[i] = true;\n\t\tdfs(tmp);\n\t}\n\tcout << ans << endl;\n\n\t//for(auto i : memo){ for(auto j : i){ cout << j << ' '; } cout << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, e[100][100], ans;\nbool can[100];\nvi use;\n\nvoid rec(int c){\n\tint sc = 0;\n\trep(i, use.size()){\n\t\tint mn = inf;\n\t\trep(j, use.size()) if(i != j) mn = min(mn, e[use[i]][use[j]]);\n\t\tsc += mn;\n\t}\n\tif(use.size() > 1) ans = max(ans, sc);\n\tif(c == n) return;\n\t\n\tif(can[c]){\n\t\tbool can2[100];\n\t\trep(j, n) can2[j] = can[j];\n\t\tfor(int j = c + 1; j < n; j++) if(!e[c][j]) can[j] = 0;\n\t\tuse.pb(c);\n\t\trec(c + 1);\n\t\tuse.pop_back();\n\t\trep(j, n) can[j] = can2[j];\n\t}\n\trec(c + 1);\n}\n\nint main(){\n\tcin >> n >> m;\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\te[a][b] = e[b][a] = c;\n\t}\n\tmemset(can, 1, sizeof(can));\n\trec(0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<set>\n#include<vector>\nusing namespace std;\nconst int maxn=501;\nstruct Edge\n{\n\tint u,v,f,next;\n}edge[maxn];\nint head[maxn],ednum;\nvoid add(int u,int v,int f)\n{\n\tedge[ednum].u=u;\n\tedge[ednum].v=v;\n\tedge[ednum].f=f;\n\tedge[ednum].next=head[u];\n\thead[u]=ednum++;\n}\nint n,m,mp[maxn][maxn];\nstruct Bitset\n{\n\tbitset<100> state;\n\tbool operator ==(const Bitset &p)const\n\t{\n\t\tfor(int i=99;i>=0;--i)\n\t\t\tif(state[i]!=p.state[i])return false;\n\t\treturn true;\n\t}\n\tbool operator <(const Bitset &p)const\n\t{\n\t\tfor(int i=99;i>=0;--i)\n\t\t\tif(state[i]!=p.state[i])return state[i]<p.state[i];\n\t}\n}tmp;\nset<Bitset> vis;\nqueue<Bitset> q;\nbool check(int u,Bitset a)\n{\n\tfor(int j=0;j<99;++j)if(a.state[j]&&!mp[u][j+1])return false;\n\treturn true;\n}\nint ans;\nint match(Bitset a)\n{\n\tint j,k,res=0,tp;\n\tfor(j=0;j<100;++j)\n\t{\n\t\tif(!a.state[j])continue;\n\t\ttp=1e9+100;\n\t\tfor(k=0;k<100;++k)\n\t\t{\n\t\t\tif(j==k)continue;\n\t\t\tif(!a.state[k])continue;\n\t\t\ttp=min(tp,mp[j+1][k+1]);\n\t\t}\n\t\tif(tp!=1e9+100)res+=tp;\n\t}\n\treturn res;\n}\nvoid bfs(int u)\n{\n\tint i;\n\tBitset now,tmp;\n\tnow.state.reset();\n\tq.push(now);\n\tvis.insert(now);\n\twhile(!q.empty())\n\t{\n\t\tnow=q.front();\n\t\tq.pop();\n\t\tfor(i=1;i<=100;++i)\n\t\t{\n\t\t\tif(now.state[i-1])continue;\n\t\t\tif(!check(i,now))continue;\n\t\t\ttmp=now;\n\t\t\ttmp.state[i-1]=1;\n\t\t\tif(vis.find(tmp)==vis.end())\n\t\t\t{\n\t\t\t\tvis.insert(tmp);\n\t\t\t\tans=max(ans,match(tmp));\n\t\t\t\tq.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint i,j,u,v,f;\n\tscanf(\"%d%d\",&n,&m);\n\t//n=100,m=0;\n\tmemset(head,-1,sizeof(head));\n\tednum=0;\n\tfor(i=0;i<m;++i)\n\t{\n\t\tscanf(\"%d%d%d\",&u,&v,&f);\n\t\tadd(u,v,f);add(v,u,f);\n\t\tmp[u][v]=mp[v][u]=f;\n\t}\n\tans=0;\n\tbfs(0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\nint deg[110];\nint graph[110][110];\nvector<int> use;\n\nll calc(int depth, int need) {\n  if ((int)use.size() == need) {\n    ll ret = 0;\n    FORIT(it1, use) {\n      ll lans = 1LL << 30;\n      FORIT(it2, use) {\n        if (*it1 == *it2) { continue; }\n        lans = min(lans, (ll)graph[*it1][*it2]);\n      }\n      ret += lans;\n    }\n    return ret;\n  }\n  if (depth == n) { return 0; }\n  ll ret = calc(depth + 1, need);\n  if (deg[depth] >= need - 1) {\n    FORIT(it, use) {\n      if (graph[depth][*it] == 0) { return ret; }\n    }\n    use.push_back(depth);\n    ret = max(ret, calc(depth + 1,  need));\n    use.pop_back();\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    MEMSET(deg, 0);\n    MEMSET(graph, 0);\n    REP(i, m) {\n      int x, y, c;\n      scanf(\"%d %d %d\", &x, &y, &c);\n      x--; y--;\n      graph[x][y] = graph[y][x] = c;\n      deg[x]++;\n      deg[y]++;\n    }\n    ll ans = 0;\n    FOR(i, 2, 16) {\n      use.clear();\n      ans = max(ans, calc(0, i));\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nconst int NMax = 150;\n\nint A[NMax][NMax];\nint used[NMax];\nint N, M;\n\nint bkt (int x, int y)\n{\n    if (x >= N)\n\t{\n        if (y < 2)\n\t\t\treturn 0;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < y; ++i)\n\t\t{\n            int Min = INT_MAX;\n\n            for (int j = 0; j < y; ++j)\n\t\t\t\tif (i != j)\n\t\t\t\t\tMin = min(Min, A[used[i]][used[j]]);\n\n\t\t\tans = ans + Min;\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tint ans = bkt(x + 1, y);\n\tint Ok = 0;\n\n\tfor (int i = 0; i < y; ++i)\n\t\tif (!A[used[i]][x])\n\t\t\tOk = 1;\n\n\tif (!Ok)\n\t{\n        used[y] = x;\n        ans = max(ans, bkt(x+1, y+1));\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < M; ++i)\n\t{\n        int u, v, f;\n\n        cin >> u >> v >> f;\n\t\tA[u-1][v-1] = A[v-1][u-1] = f;\n\n\t}\n\n\tint ans = bkt(0,0);\n\tcout <<ans <<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sat[100];\nint F[100][100];\nbool used[100];\nvector<P> G[100]; //to, f\nint N,M;\nvector<array<int, 3>> E;\n\nint greedy(int ret){\n    int n = 2;\n    while(true){\n        int best_v=-1, best_score=ret, best_s=0;\n        for(int i=0;i<N;i++){\n            int cnt=0,s=10000000;\n            int score=0;\n            if(used[i]) continue;\n            for(auto e:G[i]){\n                int to = e.first, f = e.second;\n                if(!used[to]) continue;\n                cnt++;\n                score += min(sat[to], f);\n                s = min(f,s);                \n            }\n            if(cnt!=n) s=0;\n            score += s;\n            if(score>best_score){\n                best_v = i;\n                best_score = score;\n                best_s = s;\n            }\n        }\n        if(best_v==-1){\n            return ret;\n        }else{\n            n++;\n            ret = best_score;\n            used[best_v]=true;\n            for(int i=0;i<N;i++){\n                if(!used[i]||i==best_v) continue;\n                sat[i]=min(sat[i],F[best_v][i]);\n            }\n            sat[best_v]=best_s;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].emplace_back(b,c);\n        G[b].emplace_back(a,c);\n        F[a][b]=F[b][a]=c;\n        E.push_back(array<int, 3>{a,b,c});\n    }\n    int ans=0;\n    for(auto e:E){\n        fill(used,used+100,false);\n        fill(sat,sat+100,0);\n        used[e[0]]=used[e[1]]=true;\n        sat[e[0]]=sat[e[1]]=e[2];\n        \n        ans = max(ans,greedy(2*e[2]));\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      //for(int& i : mincost)i = IINF;\n      rep(i,len)mincost[i] = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      rep(i,len) ret += mincost[i];\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nint n,g[N][N],ans;\nvector<int> V;\n \nvoid calc(){\n  int sum=0;\n  for(int i=0;i<V.size();i++){\n    int mn=INF;\n    for(int j=0;j<V.size();j++)if(i!=j) mn=min(mn,g[V[i]][V[j]]);\n    sum+=mn;\n  }\n  ans=max(ans, (V.size()>1)*sum);\n}\n \n \nset<int> used;\nvoid solve(int pos){\n  if(pos==n){calc();return;}\n  solve(pos+1);\nif(used.count(pos))V.push_back(pos),solve(pos+1),V.pop_back();\n}\n \nvector<int> G[N];\nint can[N];\nset<set<int> > S;\nvoid dfs(int pos,int cnt){\n  int flg=1,len=G[pos].size();\n  used.insert(pos);\n  if(S.count(used)){used.erase(pos);return;}\n  S.insert(used);\n  for(int i=0;i<len;i++) can[G[pos][i]]++;\n   \n  for(int i=0;i<len;i++){\n    int nx=G[pos][i];\n    if(!used.count(nx)&&can[nx]==cnt)flg=0,dfs(nx,cnt+1);\n  }\n  if(flg)solve(0);\n  used.erase(pos);\n  for(int i=0;i<len;i++) can[G[pos][i]]--;\n}\n \n \nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    g[a][b]=g[b][a]=c;\n  }\n   \n  for(int i=0;i<n;i++)dfs(i,1);\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define LL long long\n#define PI 3.1415926535897932626\nusing namespace std;\nint gcd(int a, int b) {return a % b == 0 ? b : gcd(b, a % b);}\nint N,M,ans;\nconst int INF = 0x3f3f3f3f;\nint dis[110][110];\nbool vis[110];//是否?用了?个点\nvoid dfs(int cur)\n{\n    if (cur > N) return ;\n    dfs(cur + 1);\n    for (int i = 1 ; i <= cur; i++)\n    {\n        if (vis[i] && dis[cur][i] == 0) return;\n    }\n    //上述??情况是无法??当前cur的,?里需要思考?明一下\n    //那?前面那个DIS?0的点就被更新?0更劣。?于不?0的已????\n    //如果他可以更新那个???的最小?。那?不如不更新更劣。\n    //如果他不可以更???个最小?那?\n    vis[cur] = 1;\n    int tmp = 0;\n    for (int i = 1; i <= cur ; i++)\n    {\n        int dist = INF;\n        for (int j = 1; j <= cur ; j++)\n        {\n            if (!vis[j] || j == i) continue;\n            dist = min(dist,dis[i][j]);\n        }\n        tmp += dist == INF ? 0 : dist;\n    }\n    ans = max(ans,tmp);\n    dfs(cur + 1);\n    vis[cur] = 0;\n}\nint main()\n{\n    while (scanf(\"%d%d\",&N,&M) != EOF)\n    {\n        ans = 0;\n        memset(vis,false,sizeof(vis));\n        memset(dis,0,sizeof(dis));\n        for (int i = 0 ; i < M ; i++)\n        {\n            int u ,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            dis[u][v] = dis[v][u] = max(w,dis[u][v]);\n        }\n        dfs(1);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n\nusing namespace std;\n\nint rab1[101],rab2[101],fri[101];\nint n,m;\nint usemin[101];\n\nint getpoint(int usemap[101],int count){\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(usemap[i]==count-1){\n\t\t\tans += usemin[i];\n\t\t}else if(usemap[i]){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint solve(int usemap[101],int i,int count){\n\tif(i==m){\n\t\treturn 0;\n\t}\n\tint ans1=0,ans2=0;\n\tint buf=0;\n\tif(!usemap[rab1[i]]){\n\t\tbuf++;\n\t}\n\tif(!usemap[rab2[i]]){\n\t\tbuf++;\n\t}\n\tif(count+buf < 14){\n\t\tusemap[rab1[i]]++;\n\t\tusemap[rab2[i]]++;\n\t\tint minbuf1 = usemin[rab1[i]];\n\t\tint minbuf2 = usemin[rab2[i]];\n\t\tusemin[rab1[i]] = min(usemin[rab1[i]],fri[i]);\n\t\tusemin[rab2[i]] = min(usemin[rab2[i]],fri[i]);\n\t\tans1 = max(solve(usemap,i+1,count+buf),getpoint(usemap,count+buf));\n\t\tusemap[rab1[i]]--;\n\t\tusemap[rab2[i]]--;\n\t\tusemin[rab1[i]] = minbuf1;\n\t\tusemin[rab2[i]] = minbuf2;\n\t}\n\tans2 = solve(usemap,i+1,count);\n\n\treturn max(ans1,ans2);\n}\n\nint main(){\n\tmemset(usemin,(1000*1000+1),sizeof(usemin));\n\tcin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> rab1[i] >> rab2[i] >> fri[i];\n\t}\n\tint usemap[101];\n\tmemset(usemap,0,sizeof(usemap));\n\tint ans = solve(usemap,0,0);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint dfs(const vector<vector<pair<int, int> > > &v, int idx, vector<int> &used, int needs) {\n    int ans = 0;\n\n    for(int i = idx; i < v.size(); ++i) {\n        int used_cnt = 0;\n        for(int j = 0; j < v[i].size(); ++j) {\n            if(used[v[i][j].first]) {\n                ++used_cnt;\n            }\n        }\n        if(used_cnt != needs) continue;\n\n        used[i] = 1;\n        int score = 0;\n        for(int k = 0; k < used.size(); ++k) {\n            if(!used[k]) continue;\n            int sat = 10000000;\n            for(int l = 0; l < v[k].size(); ++l) {\n                if(used[v[k][l].first]) sat = min(sat, v[k][l].second);\n            }\n            if(sat == 10000000) sat = 0;\n            score += sat;\n            //cout << k << ' ';\n        }\n        //cout << ':' << score << endl;\n        ans = max(ans, score);\n        ans = max(ans, dfs(v, i+1, used, needs+1));\n        used[i] = 0;\n    }\n\n    return ans;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<pair<int, int> > > friends(N);\n    for(int i = 0; i < M; ++i) {\n        int u, v, f;\n        cin >> u >> v >> f;\n        --u; --v;\n        friends[u].push_back(make_pair(v, f));\n        friends[v].push_back(make_pair(u, f));\n    }\n\n    vector<int> tmp(N, 0);\n    cout << dfs(friends, 0, tmp, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MS(a) memset(a,0,sizeof(a))\n#define MP make_pair\n#define PB push_back\nconst int INF = 0x3f3f3f3f;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3fLL;\ninline ll read(){\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n//////////////////////////////////////////////////////////////////////////\nconst int maxn = 1e5+10;\n\nint n,m,mp[105][105],vis[105],ans;\nvector<int> Q;\n\nvoid dfs(int u){\n\tint tmp = 0;\n\tfor(int i=0; i<(int)Q.size(); i++){\n\t\tint minn = INF;\n\t\tfor(int j=0; j<(int)Q.size(); j++){\n\t\t\tif(i!=j) minn = min(minn,mp[Q[i]][Q[j]]);\n\t\t}\n\t\tif(minn == INF)\n\t\t\tminn = 0;\n\t\ttmp += minn;\n\t}\n\tans = max(ans,tmp);\n\n\tfor(int v=u+1; v<=n; v++){\n\t\tif(vis[v]) continue;\n\t\tint flag = 1;\n\t\tfor(int j=0; j<(int)Q.size(); j++){//?????????v???????????????????????????????????????v?°±???????????¨??????????????????\n\t\t\tif(mp[v][Q[j]] == 0) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(flag){\n\t\t\tvis[v] = 1;  // ???v\n\t\t\tQ.push_back(v);\n\t\t\tdfs(v);\n\t\t\tvis[v] = 0; // ??????v  ?????? ???v??????????????????????°?\n\t\t\tQ.pop_back();\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read(), m=read();\n\tfor(int i=0; i<m; i++){\n\t\tint u,v,w; scanf(\"%d%d%d\",&u,&v,&w);\n\t\tmp[u][v]=mp[v][u]=w;\n\t}\n\n\tfor(int i=1; i<=n; i++){\n\t\tvis[i] = 1;\n\t\tQ.push_back(i); // ?????????????????????????????????\n\t\tdfs(0);\n\t\tQ.pop_back();\n\t\tvis[i] = 0;\n\t}\n\n\tcout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMax = 150;\n\nint A[NMax][NMax];\nint used[NMax];\nint N, M;\n\nint bkt (int x, int y)\n{\n    if (x >= N)\n\t{\n        if (y < 2)\n\t\t\treturn 0;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < y; ++i)\n\t\t{\n            int Min = INT_MAX;\n\n            for (int j = 0; j < y; ++j)\n\t\t\t\tif (i != j)\n\t\t\t\t\tMin = min(Min, A[used[i]][used[j]]);\n\n\t\t\tans = ans + Min;\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tint ans = bkt(x + 1, y);\n\tint Ok = 0;\n\n\tfor (int i = 0; i < y; ++i)\n\t\tif (!A[used[i]][x])\n\t\t\tOk = 1;\n\n\tif (!Ok)\n\t{\n        used[y] = x;\n        ans = max(ans, bkt(x+1, y+1));\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < M; ++i)\n\t{\n        int u, v, f;\n\n        cin >> u >> v >> f;\n\t\tA[u-1][v-1] = A[v-1][u-1] = f;\n\n\t}\n\n\tint ans = bkt(0,0);\n\tcout <<ans <<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst int inf = 1012345678;\n#define pb push_back\n#define sz(x) (int)x.size()\nint rd(){int x;scanf(\"%d\",&x);return x;}\n#define clr(x,a) memset(x,a,sizeof(x))\nconst int maxn = 110;\nconst int maxe = 100000;\n\nint g[maxn][maxn],ans,n,m,maxx[maxn];\nint r[maxn];\nvoid clq(int maxr[],int rcnt,int b[],int bcnt)\n{\n\tint i,j,k;\n\tint maxt[maxn],tcnt=0,v[maxn],vn=0;\n\t\n\tif(bcnt==0)\n\t{\n\t\treturn ;\n\t}\n\n\tfor(i=0; i<bcnt; i++)\n\t{\n\t\tvn=0,tcnt=0;\n\t\tint flag=0;\n\t\tfor(j=0; j<rcnt; j++)\n\t\tif(g[r[j]][b[i]]==0)\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tint all=0;\n\t\t\tint tp=inf;\n\t\t\tint sum=0;\n\t\t\tfor(j=0; j<rcnt;j++)\n\t\t\t{\n\t\t\t\tmaxt[j]=maxr[j];\n\t\t\t\tif(g[r[j]][b[i]]!=0 && g[r[j]][b[i]]<maxr[j])\n\t\t\t\t\tmaxt[j]=g[r[j]][b[i]];\n\t\t\t\ttp=min(tp,g[r[j]][b[i]]);\n\t\t\t\tsum+=maxt[j];\n\t\t\t}\n\t\t\tr[rcnt]=b[i];\n\t\t\tmaxt[rcnt]=tp;\n\t\t\tsum+=tp;\n\t\t\tfor(j=0; j<bcnt; j++)\n\t\t\tif(i!=j && g[b[i]][b[j]])\n\t\t\t{\n\t\t\t\tall+=maxx[b[j]];\n\t\t\t\tv[vn++]=b[j];\n\t\t\t}\n\t\t\tif(all+sum>ans)\n\t\t\t{\n\t\t\t\tans=max(ans,sum);\n\t\t\t\tclq(maxt,rcnt+1,v,vn);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tint i,j,k;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint x,y,z;\n\n\t\tfor(i=0; i<m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tg[x][y]=g[y][x]=z;\n\t\t\tmaxx[x]=max(maxx[x],z);\n\t\t\tmaxx[y]=max(maxx[y],z);\n\t\t}\n\t\t\n\t\tint maxr[maxn],b[maxn];\n\t\tans=0;\n\t\tfor(i=n; i>=1 ;i--)\n\t\t{\n\t\t\tk=0;\n\t\t\tint sum=maxx[i];\n\t\t\tfor(j=i; j<=n; j++)\n\t\t\tif(i!=j && g[i][j])\n\t\t\t{\n\t\t\t\tb[k++]=j;\n\t\t\t\tsum+=maxx[j];\n\t\t\t}\n\t\t\tr[0]=i;\n\t\t\tmaxr[0]=inf;\n\t\t\tif(sum>ans)\n\t\t\t\tclq(maxr,1,b,k);\n\t\t}\n\t\tif(n==1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nconst int maxn = 1010;\nconst int inf = 1 << 29;\nconst double eps = 1e-8;\nint n,m;\n#define N 110\nint g[110][110];\nbool r[110][110];\nint d[110][110];\nint p[N][N];\nbool x[N][N];\nint ans;\nvoid BronKerbosch2(int dep)\n{\n    int v=0;\n//    cout<<dep<<endl;\n//    cout<<\"ANSSSS\"<<ans<<endl;\n    for(int i=0;i<n;i++)\n    {\n        if(d[dep][i]<inf)v+=d[dep][i];\n//        cout<<d[dep][i]<<' ';\n    }\n//    cout<<endl;\n    ans=max(v,ans);\n//    cout<<\"ANS\"<<ans<<endl;\n    int u=-1;\n    for(int i=0;i<n;i++)\n    {\n        if(p[dep][i]||x[dep][i])\n        {\n            u=i;break;\n        }\n    }\n    if(u<0)\n    {\n        return;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(p[dep][i]<inf&&!g[u][i])\n        {\n            for(int j=0;j<n;j++)\n            {\n                d[dep+1][j]=inf;\n                r[dep+1][j]=false;\n                p[dep+1][j]=inf;\n                x[dep+1][j]=false;\n            }\n            for(int j=0;j<n;j++)\n            {\n                r[dep+1][j]=r[dep][j]||(j==i);\n                if(r[dep][j]&&j!=i)\n                {\n                    d[dep+1][j]=min(d[dep][j],g[i][j]);\n                    d[dep+1][i]=min(d[dep+1][i],g[i][j]);\n                }\n                p[dep+1][j]=min(p[dep][j],g[i][j]);\n                x[dep+1][j]=x[dep][j]&&g[i][j];\n            }\n            BronKerbosch2(dep+1);\n            p[dep][i]=0;\n            x[dep][i]=true;\n        }\n    }\n}\n\nint main() {\n    #ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    #endif\n\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                g[i][j]=0;\n            }\n        }\n\n        for(int i=0;i<m;i++)\n        {\n            int u,v,f;\n            scanf(\"%d%d%d\",&u,&v,&f);\n            u--,v--;\n            g[u][v]=f;\n            g[v][u]=f;\n        }\n\n        for(int i=0;i<n;i++)\n            d[0][i]=p[0][i]=inf,r[0][i]=x[0][i]=false;\n\n        ans=0;\n\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                d[1][j]=inf;\n                r[1][j]=false;\n                p[1][j]=inf;\n                x[1][j]=false;\n            }\n            for(int j=0;j<n;j++)\n            {\n                r[1][j]=r[0][j]||(i==j);\n                p[1][j]=min(p[0][j],g[i][j]);\n                x[1][j]=x[0][j]&&g[i][j];\n            }\n//            cout<<\"ANSS\"<<ans<<endl;\n            BronKerbosch2(1);\n            p[0][i]=0;\n            x[0][i]=true;\n        }\n\n        cout<<ans<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> graph(n,vector<int>(n));\n    rep(i,0,m){\n        int u,v,f;\n        cin >> u >> v >> f;\n        --u;\n        --v;\n        graph[u][v]=graph[v][u]=f;\n    }\n\n    function<int(int,set<int>)> rec=[&](int num,set<int> s){\n        if(num==0){\n            int res=0;\n            for(int v:s){\n                int tmp=inf;\n                for(int u:s){\n                    if(u==v) continue;\n                    tmp=min(tmp,graph[v][u]);\n                }\n                res+=tmp;\n            }\n            return res;\n        }\n        int res=0;\n        rep(v,0,n){\n            if(s.find(v)!=s.end()) continue;\n            bool ok=true;\n            for(int u:s){\n                if(graph[v][u]!=0) continue;\n                ok=false;\n                break;\n            }\n            if(!ok) continue;\n            set<int> s_=s;\n            s_.insert(v);\n            res=max(res,rec(num-1,s_));\n        }\n        return res;\n    };\n\n    int ans=0;\n    rep(i,2,inf){\n        int tmp=rec(i,set<int>());\n        if(tmp==0) break;\n        ans=max(ans,tmp);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nint N,M;\nint graph[100][100];\n\nbool friendly(vector<int>& u, int k)\n{\n\tfor(int i=0; i<u.size(); i++) \n\t\tif(graph[u[i]][k] == 0) return false;\n\n\treturn true;\n}\n\nint solve(vector<int>& u, int k)\n{\n\tint res = 0;\n\tfor(int i=k; i<N; i++) {\n\t\tif(!friendly(u, i)) continue;\n\n\t\tint tc = 0;\n\t\tu.push_back(i);\n\n\t\tif(u.size() > 1) {\n\t\t\tfor(int j=0; j<u.size(); j++) {\n\t\t\t\tint v = (1<<28);\n\t\t\t\tfor(int k=0; k<u.size(); k++) {\n\t\t\t\t\tif(j==k) continue;\n\t\t\t\t\tv = min(v, graph[u[j]][u[k]]);\n\t\t\t\t}\n\t\t\t\ttc += v;\n\t\t\t}\n\t\t}\n\n\t\tres = max(res, tc);\n\t\tres = max(res, solve(u,i+1));\n\n\t\tu.pop_back();\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tmemset(graph,0,sizeof(graph));\n\n\tcin >> N >> M;\n\tfor(int i=0; i<M; i++) {\n\t\tint s,t,c;\n\t\tcin >> s >> t >> c;\n\t\ts--; t--;\n\n\t\tgraph[s][t] = graph[t][s] = c;\n\t}\n\n\tcout << solve(vector<int>(), 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define INF 0X7FFFFFFF\n#define LL long long\nusing namespace std;\nint N,M;\nLL ans=0;\nint map[105][105];\nint F[105];\nint Node[105];\nbool flag[105];\ninline void dfs(int cnt)\n{\n\tLL temp=0;\n\tfor(int i=1;i<=cnt-1;i++)\n\t\tNode[F[i]]=INF;\n\tfor(int i=1;i<=cnt-1;i++)\n\t\tfor(int j=1;j<=cnt-1;j++)\n\t\t{\n\t\t\tif(i==j)\tcontinue;\n\t\t\tNode[F[i]]=min(Node[F[i]],map[F[i]][F[j]]);\n\t\t}\n\tfor(int i=1;i<=cnt-1;i++)\n\t{\n\t\tif(Node[F[i]]==INF)\n\t\t\tNode[F[i]]=0;\n\t\ttemp+=Node[F[i]];\n\t}\n\tif(temp>ans) ans=temp;\n\tif(cnt>N) return ;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tif(flag[i])\tcontinue;\n\t\tbool tag=0;\n\t\tfor(int j=1;j<cnt;j++)\n\t\t{\n\t\t\tif(i==F[j]) continue; \n\t\t\tif(!map[i][F[j]])\n\t\t\t{\n\t\t\t\ttag=1;break;\n\t\t\t}\n\t\t}\n\t\tif(tag==1)\tcontinue;\n\t\tF[cnt]=i;flag[i]=1;\n\t\tdfs(cnt+1);\n\t\tflag[i]=0;\n\t}\n}\nint main()\n{\n\tint i,a,b,c;\n\tmemset(map,0,sizeof(map));\n\tscanf(\"%d%d\",&N,&M);\n\tfor(i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tmap[a][b]=c;\n\t\tmap[b][a]=c;\n\t}\n\tdfs(1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll n,m;\nll f[111][111];\nvector<ll> crt;\n\nll calc_score(vector<ll> vs){\n  if(vs.size()<2)return 0;\n  ll res=0;\n  rep(i,vs.size()){\n    ll mins=INF;\n    rep(j,vs.size()){\n      if(i==j)continue;\n      minch(mins,f[vs[i]][vs[j]]);\n    }\n    res+=mins;\n  }\n  return res;\n}\n\nll dfs(ll v){\n  ll res=calc_score(crt);\n  repl(i,v,n){\n    bool ok=true;\n    for(ll u : crt){\n      if(f[v][u]==0){\n        ok=false;\n      }\n    }\n    if(ok){\n      crt.push_back(v);\n      maxch(res,dfs(v+1));\n      crt.pop_back();\n    }\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  memset(f,0,sizeof(f));\n  cin>>n>>m;\n  rep(i,m){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--; b--;\n    f[a][b]=f[b][a]=c;\n  }\n  ll res=0;\n  rep(i,n){\n    maxch(res,dfs(i));\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nint n,m;\nint g[110][110], deg[110];\nvector<int> V, use;\n\nint rec(int d, int k){\n  if(k==0){\n    int res = 0;\n    for(int a : use){\n      int v = 1e9;\n      for(int b: use){\n\tif(a!=b)v = min(v, g[a][b]);\n      }\n      res += v;\n    }\n    return res;\n  }\n  if(d==V.size())return 0;\n\n  int res = rec(d+1,k);\n  if(k){\n    for(int a : use){\n      if(!g[a][V[d]])return res;\n    }\n\n    use.push_back(V[d]);\n    res = max(res, rec(d+1,k-1));\n    use.pop_back();\n  }\n  return res;\n}\n\nint cal(int k){\n  V.clear();\n  rep(i,n){\n    if(deg[i]>=k-1)V.push_back(i);\n  }\n  return rec(0,k);\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i,m){\n    int a,b,c;\n    cin >> a >> b >> c; a--; b--;\n    g[a][b] = g[b][a] = c;\n    deg[a]++; deg[b]++;\n  }\n\n  int res = 0;\n  for(int k=2;k*(k-1)/2<=m;k++)res = max(res, cal(k));\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst int inf = 1012345678;\n#define pb push_back\n#define sz(x) (int)x.size()\nint rd(){int x;scanf(\"%d\",&x);return x;}\n#define clr(x,a) memset(x,a,sizeof(x))\nconst int maxn = 110;\nconst int maxe = 100000;\n\nint g[maxn][maxn],ans,n,m,maxx[maxn];\n\nvoid clq(int r[],int maxr[],int rcnt,int b[],int bcnt,int now)\n{\n\tint i,j,k;\n\tint t[maxn],maxt[maxn],tcnt=0,v[maxn],vn=0;\n\tans=max(ans,now);\n\tif(bcnt==0)\n\t{\n\t\treturn ;\n\t}\n\n\tfor(i=0; i<bcnt; i++)\n\t{\n\t\tvn=0,tcnt=0;\n\t\tint flag=0;\n\t\tfor(j=0; j<rcnt; j++)\n\t\tif(g[r[j]][b[i]]==0)\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tint all=0;\n\t\t\tint tp=inf;\n\t\t\tint sum=0;\n\t\t\tfor(j=0; j<rcnt;j++)\n\t\t\t{\n\t\t\t\tt[j]=r[j];\n\t\t\t\tmaxt[j]=maxr[j];\n\t\t\t\tif(g[r[j]][b[i]]!=0 && g[r[j]][b[i]]<maxr[j])\n\t\t\t\t\tmaxt[j]=g[r[j]][b[i]];\n\t\t\t\ttp=min(tp,g[r[j]][b[i]]);\n\t\t\t\tsum+=maxt[j];\n\t\t\t}\n\t\t\tt[rcnt]=b[i];\n\t\t\tmaxt[rcnt]=tp;\n\t\t\tsum+=tp;\n\t\t\tfor(j=0; j<bcnt; j++)\n\t\t\tif(i!=j && g[b[i]][b[j]])\n\t\t\t{\n\t\t\t\tall+=maxx[b[j]];\n\t\t\t\tv[vn++]=b[j];\n\t\t\t}\n\t\t\tif(all+sum>ans)\n\t\t\t\tclq(t,maxt,rcnt+1,v,vn,sum);\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tint i,j,k;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint x,y,z;\n\n\t\tfor(i=0; i<m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tg[x][y]=g[y][x]=z;\n\t\t\tmaxx[x]=max(maxx[x],z);\n\t\t\tmaxx[y]=max(maxx[y],z);\n\t\t}\n\t\t\n\t\tint r[maxn],maxr[maxn],b[maxn];\n\t\tans=0;\n\t\tfor(i=1; i<=n ;i++)\n\t\t{\n\t\t\tk=0;\n\t\t\tint sum=maxx[i];\n\t\t\tfor(j=i; j<=n; j++)\n\t\t\tif(i!=j && g[i][j])\n\t\t\t{\n\t\t\t\tb[k++]=j;\n\t\t\t\tsum+=maxx[j];\n\t\t\t}\n\t\t\tr[0]=i;\n\t\t\tmaxr[0]=inf;\n\t\t\tif(sum>ans)\n\t\t\t\tclq(r,maxr,1,b,k,0);\n\t\t}\n\t\tif(n==1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    int tmp = [&]()mutable->int{\n      int ret = 0;\n      int mincost[node];\n      rep(i,node) mincost[i] = IINF;\n      for(int i=0;i<node;i++){\n\tfor(int j=i+1;j<node;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      rep(i,node) ret += mincost[i]; \n      return ret;\n    }();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/04/30  Problem: AOJ 2306 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2306  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nLL N;\n\nLL ans = 0LL;\n\n\n\nvoid dfs(int v, VI &vs, VVI &G) {\n\tif (v == N) {\n\t\tLL ret = 0;\n\t\tif (SZ(vs) < 2)return;\n\t\tFOR(i, 0, SZ(vs)) {\n\t\t\tint u = vs[i];\n\t\t\tint t = INF;\n\t\t\tFOR(j, 0, SZ(vs)) {\n\t\t\t\tint n = vs[j];\n\t\t\t\tif (n != u) {\n\t\t\t\t\tt = min(t, G[u][n]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret += t;\n\t\t}\n\t\tans = max(ans, ret);\n\t\treturn;\n\t}\n\n\tdfs(v + 1, vs,G);\n\n\tFOR(i, 0, SZ(vs)) {\n\t\tint u = vs[i];\n\t\tif (G[v][u] == 0)return;\n\t}\n\tvs.push_back(v);\n\tdfs(v + 1, vs, G);\n\tvs.pop_back();\n\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint M; cin >> N >> M;\n\tVVI G(N, VI(N, 0));\n\tFOR(i, 0, M) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tG[a][b] = G[b][a] = c;\n\t}\n\tVI v;\n\tdfs(0, v, G);\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dist[101][101];\nmap<vector<int>,int> mp;\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tqueue<pair<vector<int>,vector<int> > > q;\n\t\n\tint ans = 0;\n\t\n\tREP(i,m)\n\t{\n\t\tint a,b,c;cin >> a >> b >> c;\n\t\tdist[a][b] = dist[b][a] = c;\n\t\tif(a > b)swap(a,b);\n\t\tvector<int> A = {a,b};\n\t\tvector<int> B = {c,c};\n\t\tq.push(MP(A,B));\n\t\tmp[A] = 2*c;\n\t\tans = max(ans,2*c);\n\t}\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<vector<int>,vector<int> > now = q.front();q.pop();\n\t\tvector<int> list = now.FI;\n\t\tvector<int> score = now.SE;\n\t\tfor(int i = list[list.size()-1]+1;i <= n;i++)\n\t\t{\n\t\t\tvector<int> tmp = list;\n\t\t\ttmp.PB(i);\n\t\t\tif(mp.find(tmp) != mp.end())continue;\n\t\t\tvector<int> tmpscore;\n\t\t\tint nowscore = 0;\n\t\t\tint sa = 0;\n\t\t\tint plus = 100000000;\n\t\t\t\n\t\t\tREP(j,list.size())\n\t\t\t{\n\t\t\t\tint AA =  min(score[j],dist[list[j]][i]);\n\t\t\t\tnowscore += AA;\n\t\t\t\ttmpscore.PB(AA);\n\t\t\t\tsa += score[j];\n\t\t\t\tplus = min(plus,dist[list[j]][i]);\n\t\t\t}\n\t\t\t\n\t\t\tnowscore += plus;\n\t\t\ttmpscore.PB(plus);\n\n\t\t\t//cout << ' ' << nowscore << endl;\n\t\t\t//SHOW1d(tmp,tmp.size());\n\t\t\t//SHOW1d(tmpscore,tmp.size());\n\t\t\t\t\t\t\n\t\t\tif(plus != 0)\n\t\t\t{\n\t\t\t\tmp[tmp] = nowscore;\n\t\t\t\tans = max(ans,nowscore);\n\t\t\t\tq.push(MP(tmp,tmpscore));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 200\ntypedef pair<int,int> P;\nvector<P> G[MAX];\nint ans=0,n,m;\nset<set<int> > ss;\nvoid dfs(set<int> v){\n  int res=0;\n  if(ss.find(v)!=ss.end()) return;\n  ss.insert(v);\n  //cout<<v.size()<<\":\";\n  for(auto i:v){\n    //cout<<i<<\" \";\n    int tmp=-1;\n    for(int j=0;j<(int)G[i].size();j++){\n      if(v.find(G[i][j].first)!=v.end()){\n\tif(tmp<0) tmp=G[i][j].second;\n\telse tmp=min(tmp,G[i][j].second);\n      }\n    }\n    if(tmp<0){\n      res=0;\n      break;\n    }\n    res+=tmp;\n  }\n  //cout<<\":\"<<res<<endl;\n  ans=max(ans,res);\n  set<int> u(v);\n  for(int i=0;i<n;i++){\n    if(v.find(i)!=v.end()) continue;\n    bool f=1;\n    for(auto j:v){\n      bool ff=0;\n      for(int k=0;k<(int)G[j].size();k++) ff|=(i==G[j][k].first);\n      f&=ff;\n    }\n    if(f){\n      u.insert(i);\n      dfs(u);\n      u.erase(i);\n    }\n  }\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    int u,v,f;\n    cin>>u>>v>>f;\n    u--;v--;\n    G[u].push_back(P(v,f));\n    G[v].push_back(P(u,f));\n  }\n  set<int> v;\n  dfs(v);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint n, m, ans;\nint g[105][105];\n\nvoid dfs(VI &v) {\n  if(v.size() >= 2) {\n    int tmp = 0;\n    REP(i, v.size()) {\n      int t = INF;\n      REP(j, v.size()) if(i != j) {\n        chmin(t, g[v[i]][v[j]]);\n      }\n      tmp += t;\n    }\n    chmax(ans, tmp);\n  }\n\n  int last = v.back();\n  FOR(i, last+1, n) {\n    bool ok = true;\n    for(int j: v) {\n      if(g[i][j] == 0) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      v.PB(i);\n      dfs(v);\n      v.pop_back();\n    }\n  }\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n >> m;\n  REP(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--,  b--;\n    g[a][b] = g[b][a] = c;\n  }\n\n  REP(i, n) {\n    VI v({i});\n    dfs(v);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nint n, m;\nint fn[101][101];\nint ans;\n\nvoid dfs(int idx, vector<int> rab)\n{\n  if(rab.size() > 1) {\n    int sum = 0;\n    for(int a : rab) {\n      int mn = inf;\n      for(int b : rab) {\n\tif(a == b) continue;\n\tmn = min(mn, fn[a][b]);\n      }\n      sum += mn;\n    }\n    ans = max(ans, sum);\n  }\n  reps(a, idx, n) {\n    bool flag = true;\n    for(int b : rab) {\n      if(fn[a][b] == 0) {\n\tflag = false; break;\n      }\n    }\n    if(flag) {\n      auto nrab = rab;\n      nrab.push_back(a);\n      dfs(a+1, nrab);\n    }\n  }\n  \n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> n >> m;\n  memset(fn, 0, sizeof(fn));\n  rep(i, m) {\n    int u, v, f;\n    cin >> u >> v >> f; u--, v--;\n    fn[u][v] = fn[v][u] = f;\n  }\n\n  ans = 0;\n  dfs(0, vector<int>());\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint n,m;\nll ans = 0LL;\nll G[100][100];\n\nvoid dfs(int i, int cnt, int max_cnt, vector<bool> v){\n    if(cnt == max_cnt){\n        ll tmp_ans = 0LL;\n        repp(x, n){\n            if(!v[x]) continue;\n            ll tmp = LLONG_MAX;\n            repp(y, n){\n                if(!v[y] || x == y) continue;\n                tmp = min(tmp, G[x][y]);\n            }\n            tmp_ans += tmp;\n        }\n        ans = max(ans, tmp_ans);\n        return;\n    }\n    if(i == n) return;\n\n    for(int j=i;j<n;j++){\n        bool flag = true;\n        repp(x, n){\n            if(v[x] && G[j][x] == 0LL){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            v[j] = true;\n            dfs(j+1, cnt+1, max_cnt, v);\n            v[j] = false;\n        }\n    }\n    return;\n}\n\nint main(){\n    int u,v;\n    ll f;\n    cin >> n >> m;\n    rep(m){\n        cin >> u >> v >> f;\n        u--; v--;\n        G[u][v] = G[v][u] = f;\n    }\n    \n    reppp(i, 2, 15){\n        if(2*m/(i-1) < i) break;\n        dfs(0, 0, i, vector<bool>(n, false));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n#define inf 100000000\n\nusing namespace std;\n\nint n, m;\nint g[105][105];\n\nbool used[105];\nvector<int> vec;\nint table[20][20];\n\nint calc()\n{\n\tint mi, ret = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tmi = inf;\n\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\tif(i == j) continue;\n\t\t\tmi = min(mi, g[vec[i]][vec[j]]);\n\t\t}\n\t\tif(mi == inf) mi = 0;\n\t\tret += mi;\n\t}\n\treturn ret;\n}\n\nint dfs()\n{\n\tint ret = calc();\n\tint mi = inf;\n\t\n\tif(vec.size() >= 14) return ret;\n\tfor(int i = vec.back()+1; i <= n; i++){\n\t\tfor(int j = 0; j < vec.size(); j++){\n\t\t\tif(g[vec[j]][i] == 0) goto NG;\n\t\t}\n\t\tvec.push_back(i);\n\t\tret = max(ret, dfs());\n\t\tvec.pop_back();\n\t\tNG:;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tint u, v, f;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u >> v >> f;\n\t\tg[u][v] = g[v][u] = f;\n\t}\n\t\n\tfor(int i = 0; i <= 19; i++){\n\t\tfor(int j = 0; j <= 19; j++){\n\t\t\ttable[i][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tvec.push_back(i);\n\t\tans = max(ans, dfs());\n\t\tvec.pop_back();\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\n\nint solve(const vvi& g,vi& rs,int i)\n{\n\tint n=g.size();\n\tif(i==n){\n\t\tif(rs.size()==1) return 0;\n\t\tint res=0;\n\t\tfor(int u:rs){\n\t\t\tint x=INF;\n\t\t\tfor(int v:rs) if(u!=v)\n\t\t\t\tx=min(x,g[u][v]);\n\t\t\tres+=x;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tint res=solve(g,rs,i+1);\n\tbool ok=true;\n\tfor(int r:rs)\n\t\tif(g[i][r]==0){\n\t\t\tok=false;\n\t\t\tbreak;\n\t\t}\n\tif(ok){\n\t\trs.push_back(i);\n\t\tres=max(res,solve(g,rs,i+1));\n\t\trs.pop_back();\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tif(m==0){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvvi g(n,vi(n));\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w; u--,v--;\n\t\t\tg[u][v]=g[v][u]=w;\n\t\t}\n\t\t\n\t\tvi rs;\n\t\tcout<<solve(g,rs,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> graph(n,vector<int>(n));\n    rep(i,0,m){\n        int u,v,f;\n        cin >> u >> v >> f;\n        --u;\n        --v;\n        graph[u][v]=graph[v][u]=f;\n    }\n\n    int ans=0;\n    rep(i,2,inf){\n        if(i*(i-1)/2>m) continue;\n        map<set<int>,int> memo;\n        map<set<int>,bool> done;\n        function<int(int,set<int>&)> rec=[&](int num,set<int> &s){\n            int &res=memo[s];\n            if(done[s]) return res;\n            done[s]=true;\n            if(num==0){\n                for(int v:s){\n                    int tmp=inf;\n                    for(int u:s){\n                        if(u==v) continue;\n                        tmp=min(tmp,graph[v][u]);\n                    }\n                    res+=tmp;\n                }\n                return res;\n            }\n            rep(v,0,n){\n                if(s.find(v)!=s.end()) continue;\n                bool ok=true;\n                for(int u:s){\n                    if(graph[v][u]!=0) continue;\n                    ok=false;\n                    break;\n                }\n                if(!ok) continue;\n                s.insert(v);\n                res=max(res,rec(num-1,s));\n                s.erase(v);\n            }\n            return res;\n        };\n        set<int> s;\n        int tmp=rec(i,s);\n        if(tmp==0) break;\n        ans=max(ans,tmp);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint v[100][100];\n\nset<set<int>> mem;\n\nint dfs(set<int> used) {\n    int cost = 0;\n    for (auto i: used) {\n        int min_cost = 1 << 28;\n        for (auto j: used) {\n            if (i == j) continue;\n            min_cost = min(min_cost, v[i][j]);\n        }\n        if (min_cost == 1 << 28) min_cost = 0;\n        cost += min_cost;\n    }\n\n    mem.insert(used);\n\n    for (int i = 0; i < n; i++) {\n        if (used.find(i) != used.end()) continue;\n\n        bool flag = true;\n        for (auto j: used) {\n            if (v[i][j] == 0) flag = false;\n        }\n\n        if (flag) {\n            auto tmp = used;\n            tmp.insert(i);\n            if (mem.find(tmp) == mem.end())\n                cost = max(cost, dfs(tmp));\n        }\n    }\n\n    return cost;\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        v[x-1][y-1] = v[y-1][x-1] = z;\n    }\n\n    cout << dfs(set<int>()) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[101];\nint n,er[101];\n\nint calc(){\n  int res=0;\n  for(int i=0;i<n;i++){\n    int mn=1e9;\n    if(!er[i])\n      for(int j=0;j<G[i].size();j++)\n\tif(!er[G[i][j].f]) mn=min(mn,G[i][j].s);\n    res+=mn==1e9? 0:mn;\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(P(b,c));\n    G[b].push_back(P(a,c));\n  }\n\n\n  int ans=calc();\n  for(int i=0;i<n;i++){\n    int idx=0,sum=0;\n    for(int j=0;j<n;j++){\n      if(er[j])continue;\n      er[j]=1;\n      int res=calc();\n      er[j]=0;\n      if(sum<res)sum=res,idx=j;\n    }\n    er[idx]=1;\n    ans=max(ans,sum);\n  }  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sat[100];\nbool used[100];\nvector<P> G[100]; //to, f\nint N,M;\nvector<array<int, 3>> E;\n\nint greedy(int ret){\n    int n = 2;\n    while(true){\n        int best_v=-1, best_score=0, best_s=0;\n        for(int i=0;i<N;i++){\n            int cnt=0,s=10000000;\n            int score=0;\n            if(used[i]) continue;\n            for(auto e:G[i]){\n                int to = e.first, f = e.second;\n                if(!used[to]) continue;\n                cnt++;\n                score += min(sat[to], f);\n                s = min(f,s);                \n            }\n            if(cnt!=n) s=0;\n            score += s;\n            if(score>best_score){\n                best_v = i;\n                best_score = score;\n                best_s = s;\n            }\n        }\n        if(best_v==-1){\n            return ret;\n        }else{\n            ret = best_score;\n            used[best_v]=true;\n            sat[best_v]=best_s;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].emplace_back(b,c);\n        G[b].emplace_back(a,c);\n        E.push_back(array<int, 3>{a,b,c});\n    }\n    int ans=0;\n    for(auto e:E){\n        fill(used,used+100,false);\n        fill(sat,sat+100,0);\n        used[e[0]]=used[e[1]]=true;\n        sat[e[0]]=sat[e[1]]=e[2];\n        \n        ans = max(ans,greedy(2*e[2]));\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef int Weight;\nconst Weight INF = 1000000000;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint calc(const Matrix &g, const vector<int> &v) {\n  int m=v.size();\n  if (m <= 1) return 0;\n  int sum = 0;\n  REP(i,m) {\n    int mn = INF;\n    REP(j,m) {\n      if (i==j) continue;\n      mn = min(mn, g[v[i]][v[j]]);\n    }\n    sum += mn;\n  }\n  return sum;\n}\n\nint func(const Matrix &g, const vector<int> &v) {\n  int n=g.size();\n  int mxs = calc(g, v);\n  REP(i,n){\n    if (!v.empty() && i >= v.back()) break;\n    bool ok = true;\n    REP(j,v.size()) {\n      if(g[i][v[j]] == 0) ok = false;\n    }\n    if (ok) {\n      auto cp = v;\n      cp.push_back(i);\n      mxs = max(mxs, func(g, cp));\n    }\n  }\n  return mxs;\n}\n\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  Matrix g(n, Array(n, 0));\n  REP(i,m){\n    int u,v,f;\n    cin>>u>>v>>f;\n    --u;--v;\n    g[u][v] = g[v][u] = f;\n  }\n  vector<int> v;\n  cout << func(g, v) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\nstruct E{\n  int cost,to;\n  E(int _to,int _cost){\n    cost = _cost;\n    to = _to;\n  }\n};\n\nconst int MAX = 100;\nvector<E>G[MAX];\nint G2[MAX][MAX];\nset<set<int> >S;\nint res;\nint N,M;\n\nvoid func(set<int>&st){\n  vector<int>vec(st.begin(),st.end());\n  if(S.count(st))return;\n  S.insert(st);\n  int sum = 0;\n  for(int i = 0 ; i < vec.size() ; i++){\n    int cost = 1e8;\n    for(int j = 0 ; j < vec.size() ; j++){\n      if(i == j)continue;\n      cost = min(cost,G2[vec[i]][vec[j]]);\n    }\n    if(cost == 1e8)cost = 0;\n    sum += cost;\n  }\n  res = max(res,sum);\n  for(int i = 0 ; i < vec.size() ; i++){\n    for(int j = 0 ; j < G[vec[i]].size() ; j++){\n      int to = G[vec[i]][j].to;\n      if(st.count(to))continue;\n      bool flag = true;\n      for(int k = 0 ; k < vec.size() ; k++){\n        if(G2[to][vec[k]] == 0){\n          flag = false;\n          break;\n        }\n      }\n      if(flag){\n        set<int>n_st = st;\n        n_st.insert(to);\n        func(n_st);\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i = 0 ; i < N ; i++){\n    G[i].clear();\n    for(int j = 0 ; j < N ; j++){\n      G2[i][j] = 0;\n    }\n  }\n  for(int i = 0 ; i < M ; i++){\n    int a,b,c; cin >> a >> b >> c;\n    a--; b--;\n    G[a].push_back(E(b,c));\n    G[b].push_back(E(a,c));\n    G2[a][b] = G2[b][a] = c;\n  }\n  \n  res = 0;\n  for(int i = 0 ; i < N ; i++){\n    set<int>st;\n    st.insert(i);\n    func(st);\n  }\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>   \n#include<string.h>   \n#include <iostream>\n#include<vector>   \n#include<queue>\n#include<algorithm>   \n#define Fr0(i,n) for (int i=0;i<n;i++)\n#define Fr1(i,n) for (int i=1;i<=n;i++)\n#define sf scanf\n#define pf printf\n#define wh while\n#define lc(x) (x << 1)\n#define rc(x) (x << 1 | 1)\n#define lowbit(x) (x & (-x))\n#define v1 \"%d\"\n#define v2 \"%d%d\"\n#define v3 \"%d%d%d\"\n#define inf 2147483647\nusing namespace std;\ntypedef long long ll;\nint n,m,u,v,w;\nstruct Edge{\n\tint aim;\n\tint wei;\n\tEdge(int a,int w){\n\t\taim=a;\n\t\twei=w;\n\t}\n};\nvector<Edge> ve[101];\nint d[201][201];  \nvoid init(){\n\tFr1(i,n)  \n\t\tFr1(j,n)   \n\t\td[i][j]=inf;  \n\tFr1(i,n) d[i][i]=0;  \n}\nvoid deledge(int st){\n\tFr0(i,ve[st].size()){\n\t\tEdge tmpe=ve[st][i];\n\t\td[st][tmpe.aim]=inf;\n\t\td[tmpe.aim][st]=inf;\n\t}\n}\n\nvoid addedge(int st){\n\tFr0(i,ve[st].size()){\n\t\tEdge tmpe=ve[st][i];\n\t\t{\n\t\t\td[st][tmpe.aim]=tmpe.wei,d[tmpe.aim][st]=tmpe.wei;\n\t\t}\n\t}\n\td[st][st]=0;\n}\nint solve(int x){\n\tdeledge(x);\n\tint ret=0,num;\n\tfor (int i=1;i<=n;i++){\n\t\tnum=inf;\n\t\tif (i!=x){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(d[i][j]!=inf) num=min(num,d[i][j]);\n\t\t\t}\n\t\t\tif (num!=inf) ret+=num;\n\t\t}\n\t}\n\taddedge(x);\n\treturn ret;\n}\nint main(){\n\n\twhile(sf(v2,&n,&m)!=EOF){\n\t\tinit();\n\t\tFr0(i,m){\n\t\t\tsf(v3,&u,&v,&w);\n\t\t\tve[u].push_back(Edge(v,w));\n\t\t\tve[v].push_back(Edge(u,w));\n\t\t\td[u][v]=w;\n\t\t\td[v][u]=w;\n\t\t}\n\t\tint ans=inf;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans=min(solve(i),ans);\n\t\t}\n\t\tpf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint N,M,e[100][100],deg[100];\nint main(){\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--,b--;\n\t\te[a][b]=e[b][a]=c;\n\t\tdeg[a]++,deg[b]++;\n\t}\n\tint ans=0;\n\tfor(int d=2;d<=14;d++){\n\t\tvector<int> vs;\n\t\trep(i,N) if(deg[i]>=d-1) vs.pb(i);\n\t\tint K=vs.size();\n\t\tint c=(1<<d)-1;\n\t\twhile(c<1<<K){\n\t\t\tvector<int> vc;\n\t\t\trep(i,K) if((c>>i)&1) vc.pb(vs[i]);\n\t\t\tbool can=1;\n\t\t\trep(i,d) rep(j,i) if(e[vc[i]][vc[j]]==0) can=0;\n\t\t\tif(can){\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int i:vc){\n\t\t\t\t\tint tmp=1e9;\n\t\t\t\t\tfor(int j:vc) if(i!=j) chmin(tmp,e[i][j]);\n\t\t\t\t\tsum+=tmp;\n\t\t\t\t}\n\t\t\t\tchmax(ans,sum);\n\t\t\t}\n\t\t\tint x=c&-c,y=c+x;\n\t\t\tc=(((c&~y)/x)>>1)|y;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst int INF=1<<29;\n\nint n,adj[100][100],deg[100];\n\nvoid dfs(int u,bool *visited,vector<int> &cc){\n\tvisited[u]=true;\n\tcc.push_back(u);\n\trep(v,n) if(adj[u][v] && !visited[v]) dfs(v,visited,cc);\n}\n\nint calc(const vector<int> &cc){\n\tint res=0;\n\tfor(int d=1;d<=14;d++){\n\t\tvector<int> S;\n\t\trep(i,cc.size()){\n\t\t\tint u=cc[i];\n\t\t\tif(deg[u]>=d) S.push_back(u);\n\t\t}\n\n\t\tint m=S.size();\n\t\tif(m<d+1) continue;\n\n\t\tif(d==1){\n\t\t\trep(j,m) rep(i,j) res=max(res,2*adj[S[i]][S[j]]);\n\t\t}\n\t\telse{\n\t\t\tull T=(1<<d+1)-1;\n\t\t\twhile(T<(1ULL<<m)){\n\t\t\t\tint w=0;\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,m) if(T&(1ULL<<i)) {\n\t\t\t\t\tint w2=INF;\n\t\t\t\t\trep(j,m) if(i!=j && T&(1ULL<<j)) w2=min(w2,adj[S[i]][S[j]]);\n\t\t\t\t\tif(w2==0){ ok=false; break; }\n\t\t\t\t\telse w+=w2;\n\t\t\t\t}\n\t\t\t\tif(ok) res=max(res,w);\n\n\t\t\t\tull x=T&-T,y=T+x;\n\t\t\t\tT=((T&~y)/x>>1)|y;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint m; scanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v,w; scanf(\"%d%d%d\",&u,&v,&w); u--; v--;\n\t\tadj[u][v]=adj[v][u]=w;\n\t\tdeg[u]++;\n\t\tdeg[v]++;\n\t}\n\n\tint ans=0;\n\tbool visited[100]={};\n\trep(u,n) if(!visited[u]) {\n\t\tvector<int> cc;\n\t\tdfs(u,visited,cc);\n\t\tans=max(ans,calc(cc));\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint v[100][100];\n\nint dfs(set<int> used) {\n    int cost = 0;\n    for (auto i: used) {\n        int min_cost = 1 << 28;\n        for (auto j: used) {\n            if (i == j) continue;\n            min_cost = min(min_cost, v[i][j]);\n        }\n        if (min_cost == 1 << 28) min_cost = 0;\n        cost += min_cost;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (used.find(i) != used.end()) continue;\n\n        bool flag = true;\n        for (auto j: used) {\n            if (v[i][j] == 0) flag = false;\n        }\n\n        if (flag) {\n            auto tmp = used;\n            tmp.insert(i);\n            cost = max(cost, dfs(tmp));\n        }\n    }\n\n    return cost;\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        v[x-1][y-1] = v[y-1][x-1] = z;\n    }\n\n    cout << dfs(set<int>()) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint N, M;\nint G[110][110];\n\nint main(){\n    cin >> N >> M;\n    for(int i=0; i<M; i++){\n        int x, y, w;\n        cin >> x >> y >> w; x--; y--;\n        G[x][y] = G[y][x] = w;\n    }\n    \n    int ans = 0;\n    for(int s=0; s<N; s++){\n        int tans = 0;\n        vector<int> data(N, INF);\n        vector<bool> done(N);\n        done[s] = true;\n        \n        bool updated = true;\n        while(updated){\n            updated = false;\n            for(int v=0; v<N; v++) if(!done[v]){\n                vector<int> odata = data;\n                for(int u=0; u<N; u++)if(done[u]){\n                    data[u] = min(data[u], G[u][v]);\n                    data[v] = min(data[v], G[u][v]);\n                }\n                int sum = 0;\n                for(int i=0; i<N; i++) if(data[i] != INF)\n                    sum += data[i];\n                if(tans < sum){\n                    tans = sum;\n                    done[v] = true;\n                    updated = true;\n                }else{\n                    data = odata;\n                }\n            }\n        }\n        ans = max(ans, tans);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nint n,m;\nint g[110][110];\nint deg[110], use[110];\nvector<int> V;\n\nint rec(int d, int k){\n  if(k==0){\n    int res = 0;\n    rep(i,V.size()){\n      if(!use[i])continue;\n      int minv = 1e9;\n      rep(j,V.size()){\n\tif(i==j || !use[j])continue;\n\tminv = min(minv, g[V[i]][V[j]]);\n      }\n      res += minv;\n    }\n    return res;\n  }\n\n  if(d==(int)V.size())return 0;\n\n  int res = rec(d+1,k);\n\n  if(k>0){\n    bool f = true;\n    for(int i=0;i<d;i++){\n      if(use[i] && !g[V[i]][V[d]]){\n\tf = false; break;\n      }\n    }\n\n    if(f){\n      use[d] = true;\n      res = max(res, rec(d+1,k-1));\n      use[d] = false;\n    }\n  }\n  return res;\n}\n\nint max_clique(int k){\n  V.clear();\n  rep(i,n){\n    if(deg[i]>=k-1)V.push_back(i);\n  }\n\n  memset(use,0,sizeof(use));\n  return rec(0,k);\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i,m){\n    int a,b,c;\n    cin >> a >> b >> c; a--; b--;\n    g[a][b] = g[b][a] = c;\n    deg[a]++; deg[b]++;\n  }\n\n  int res = 0;\n  for(int k=2;k*(k-1)/2<=m;k++){\n    res = max(res, max_clique(k));\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint dist[101][101];\nmap<vector<int>,int> mp;\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\t\n\tqueue<pair<vector<int>,vector<int> > > q;\n\t\n\tint ans = 0;\n\t\n\tREP(i,m)\n\t{\n\t\tint a,b,c;cin >> a >> b >> c;\n\t\tdist[a][b] = dist[b][a] = c;\n\t\tif(a > b)swap(a,b);\n\t\tvector<int> A = {a,b};\n\t\tvector<int> B = {c,c};\n\t\tq.push(MP(A,B));\n\t\tmp[A] = 2*c;\n\t\tans = max(ans,2*c);\n\t}\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<vector<int>,vector<int> > now = q.front();q.pop();\n\t\tvector<int> list = now.FI;\n\t\tvector<int> score = now.SE;\n\t\tfor(int i = list[list.size()-1]+1;i <= n;i++)\n\t\t{\n\t\t\tvector<int> tmp = list;\n\t\t\ttmp.PB(i);\n\t\t\tif(mp.find(tmp) != mp.end())continue;\n\t\t\tvector<int> tmpscore;\n\t\t\tint nowscore = 0;\n\t\t\tint sa = 0;\n\t\t\tint plus = 100000000;\n\t\t\t\n\t\t\tREP(j,list.size())\n\t\t\t{\n\t\t\t\tint AA =  min(score[j],dist[list[j]][i]);\n\t\t\t\tnowscore += AA;\n\t\t\t\ttmpscore.PB(AA);\n\t\t\t\tsa += score[j];\n\t\t\t\tplus = min(plus,dist[list[j]][i]);\n\t\t\t}\n\t\t\t\n\t\t\tnowscore += plus;\n\t\t\ttmpscore.PB(plus);\n\n\t\t\t//cout << ' ' << nowscore << endl;\n\t\t\t//SHOW1d(tmp,tmp.size());\n\t\t\t//SHOW1d(tmpscore,tmp.size());\n\t\t\t\t\t\t\n\t\t\tif(sa <= nowscore)\n\t\t\t{\n\t\t\t\tmp[tmp] = nowscore;\n\t\t\t\tans = max(ans,nowscore);\n\t\t\t\tq.push(MP(tmp,tmpscore));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint n,m,a[101][101];\nint v[101],viz[101];\nint maxim;\n\nvoid bkt(int poz, int sol)\n{\n    if(poz==sol+1)\n    {\n        int minim=0,suma=0;\n        for(int j=v[1]; j<=v[sol]; ++j)\n        {\n            minim=a[v[1]][j];\n            for(int i=v[1]; i<=v[sol]; ++i)\n                minim=min(minim, a[i][j]);\n            suma=suma+minim;\n        }\n        maxim=max(maxim, suma);\n    }\n     else\n        {\n         for(int i=v[poz-1]+1;i<=n-sol+poz;++i)\n            {\n             if(!viz[i])\n                {\n                 v[poz]=i;\n                 viz[i]=1;\n                 bkt(poz+1, sol);\n                 viz[i]=0;\n                }\n            }\n        }\n}\n\nint main()\n{\n    cin>>n>>m;\n    int u=0,v=0,f=0;\n    for(int i=1; i<=m; i++)\n    {\n        cin>>u>>v>>f;\n        a[u][v]=a[v][u]=f;\n    }\n    for(int i=1;i<=n;++i)\n        a[i][i]=1111111;\n    for(int i=2; i<=n; i++)\n        bkt(1,i);\n    cout<<maxim<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//notepad\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 100;\ntypedef pair<int,int> pii;\nconst int inf = 1000001;\nvector<pii> edge[N];\nbool e[N][N];\n\nint ans;\nvoid search(int n,int last,bool *used){\n  int ret=0;\n  rep(i,last+1){\n    if (!used[i])continue;\n    int tmp=inf;\n    rep(j,(int)edge[i].size()){\n      int next=edge[i][j].first;\n      if(!used[next])continue;\n      tmp=min(tmp,edge[i][j].second);\n    }\n    if (tmp == inf)continue;\n    ret+=tmp;\n  }\n  ans=max(ans,ret);\n  REP(i,last+1,n){\n    bool isPG=true;\n    rep(j,last+1){\n      if (!used[j])continue;\n      if (!e[i][j]){isPG=false;break;}\n    }\n    if (!isPG)continue;\n    used[i]=true;\n    search(n,i,used);\n    used[i]=false;\n  }\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m){\n    bool used[n];\n    rep(i,n)used[i]=false;\n    rep(i,n)edge[i].clear();\n    rep(i,n)rep(j,n)e[i][j]=false;\n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      e[f][t]=e[t][f]=true;\n      edge[f].push_back(make_pair(t,c));\n      edge[t].push_back(make_pair(f,c));\n    }\n    ans=0;\n    search(n,-1,used);\n    cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[len];\n      //for(int& i : mincost)i = IINF;\n      rep(i,len)mincost[i] = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      rep(i,len) ret += mincost[i];\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  int test[4];\n  for(int& i : test);\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint g[100][100];\n\nint solve(vi& vec)\n{\n    int res = 0;\n    rep(i,len(vec)){\n        int cri = INF;\n        rep(j,len(vec)){\n            if(j != i){\n                cmn(cri,g[vec[i]][vec[j]]);\n            }\n        }\n        res += cri;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        g[a-1][b-1] = g[b-1][a-1] = c;\n    }\n    int ans = 0;\n    srep(i,2,min(n+1,15)){\n        vi vec;\n        rep(j,n){\n            int cnt = 0;\n            rep(k,n){\n                if(g[j][k] > 0){\n                    cnt++;\n                }\n            }\n            if(cnt >= i-1){\n                vec.pb(j);\n            }\n        }\n        if(len(vec) >= i){\n            vector<bool> v(len(vec),false);\n            fill(v.end() - i, v.end(), true);\n            do{\n                vi ch;\n                rep(j,len(v)){\n                    if(v[j]){\n                        ch.pb(vec[j]);\n                    }\n                }\n                cmx(ans,solve(ch));\n            }while(next_permutation(all(v)));\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint n, m;\n\nbool exi[100][100];\nint c[100][100];\n\nint ma = 0;\nvector<int> v;\nvoid dfs(int id) {\n\tif (id == n)return;\n\trep(j, v.size()) {\n\t\tif (!exi[v[j]][id]) {\n\t\t\tdfs(id + 1); return;\n\t\t}\n\t}\n\tint sum = 0;\n\tv.push_back(id);\n\tif (v.size() > 1) {\n\t\trep(i, v.size()) {\n\t\t\tint mi = mod;\n\t\t\trep(j, v.size()) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tmi = min(mi, c[v[i]][v[j]]);\n\t\t\t}\n\t\t\tsum += mi;\n\t\t}\n\t}\n\tma = max(ma, sum);\n\tdfs(id + 1);\n\tv.pop_back();\n\n\tdfs(id + 1);\n}\n\nvoid solve() {\n\tcin >> n >> m;\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--; int cost; cin >> cost;\n\t\tc[a][b] = c[b][a] = cost;\n\t\texi[a][b] = exi[b][a] = true;\n\t}\n\tdfs(0);\n\tcout << ma << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nvector<P> idx;\n\nset<vector<int> > memo;\n\nvoid dfs(int x,vector<int> G){\n  \n  sort(G.begin(),G.end());\n\n  if(memo.count(G)) return ;\n  memo.insert(G);\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      if(!used[G[i]]) continue;\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(!used[G[j]]) continue;\n\t\n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n\n    if(used[idx[i].S]) continue;\n\n    used[idx[i].S]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(idx[i].S);\n    \n    for(int j=0;j<G.size();j++)\n      \n      if(idx[i].S!=G[j]&&used[G[j]])\n\tmincost=min(mincost,d[idx[i].S][G[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n\n    used[idx[i].S]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<n;i++) idx.push_back(P(0,i));\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n    idx[a-1].first++;\n    idx[b-1].first++;\n  }\n\n  sort(idx.begin(),idx.end());\n  \n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nint n, m;\nint g[105][105];\nint ans;\nset<vector<int>> memo;\n\nvoid dfs(vector<int> used){\n\tif(not (memo.emplace(used)).second) return;\n\t//for(auto i : used){ cout << i << ' ' ; } cout << endl;\n\n\tvector<int> to;\n\trep(i,n){\n\t\tbool f = true;\n\t\tfor(auto j : used){\n\t\t\tif(i == j || g[j][i] == 0){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) to.emplace_back(i);\n\t}\n\n\tfor(auto i : to){\n\t\tused.emplace_back(i);\n\t\tdfs(used);\n\t\tused.pop_back();\n\t}\n\n\tif(used.size() == 1) return;\n\n\tint sum = 0;\n\tfor(auto i : used){\n\t\tint mini = INF;\n\t\tfor(auto j : used){\n\t\t\tif(g[i][j] == 0) continue;\n\t\t\tmini = min(mini, g[i][j]);\n\t\t}\n\t\tsum += mini;\n\t}\n\tans = max(ans, sum);\n}\n\nsigned main(){\n\tcin >> n >> m;\n\n\tvector<int> v;\n\trep(i,m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a][b] = g[b][a] = c;\n\t}\n\n\trep(i,n){\n\t\tvector<int> tmp;\n\t\ttmp.emplace_back(i);\n\t\tdfs(tmp);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint fr[101][101] = {};\nint ans = 0;\n\nint calc_score(const vector<int> &node) {\n    if (node.size() == 1) return 0;\n\n    int score = 0;\n    for (auto x : node) {\n        int min_fr = 1e9;\n        for (auto y : node) {\n            if (x == y) continue;\n            min_fr = min(min_fr, fr[x][y]);\n        }\n        score += min_fr;\n    }\n    return score;\n}\n\nvoid dfs(vector<int> &node) {\n    ans = max(ans, calc_score(node));\n\n    for (int i = node.back() + 1; i < n; i++) {\n        bool is_ok = true;\n        for (int j = 0; is_ok && j < node.size(); j++)\n            if (fr[i][node[j]] == 0) is_ok = false;\n        if (!is_ok) continue;\n\n        node.push_back(i);\n        dfs(node);\n        node.pop_back();\n    }\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int u, v, f; cin >> u >> v >> f;\n        u--, v--;\n        fr[u][v] = fr[v][u] = f;\n    }\n\n    for (int i = 0; i < n; i++) {\n        auto node = vector<int>(1, i);\n        dfs(node);\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst int inf = 1012345678;\n#define pb push_back\n#define sz(x) (int)x.size()\nint rd(){int x;scanf(\"%d\",&x);return x;}\n#define clr(x,a) memset(x,a,sizeof(x))\nconst int maxn = 110;\nconst int maxe = 100000;\n\nint g[maxn][maxn],ans,n,m;\n\nvoid clq(int r[],int maxr[],int rcnt,int b[],int bcnt,int now)\n{\n\tint i,j,k;\n\tint t[maxn],maxt[maxn],tcnt=0,v[maxn],vn=0;\n\tans=max(ans,now);\n\tif(bcnt==0)\n\t{\n\t\treturn ;\n\t}\n\n\n\tfor(i=0; i<bcnt; i++)\n\t{\n\t\tvn=0,tcnt=0;\n\t\tint flag=0;\n\t\tfor(j=0; j<rcnt; j++)\n\t\tif(g[r[j]][b[i]]==0)\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tint tp=inf;\n\t\t\tint sum=0;\n\t\t\tfor(j=0; j<rcnt;j++)\n\t\t\t{\n\t\t\t\tt[j]=r[j];\n\t\t\t\tmaxt[j]=maxr[j];\n\t\t\t\tif(g[r[j]][b[i]]!=0 && g[r[j]][b[i]]<maxr[j])\n\t\t\t\t\tmaxt[j]=g[r[j]][b[i]];\n\t\t\t\ttp=min(tp,g[r[j]][b[i]]);\n\t\t\t\tsum+=maxt[j];\n\t\t\t}\n\t\t\tt[rcnt]=b[i];\n\t\t\tmaxt[rcnt]=tp;\n\t\t\tsum+=tp;\n\t\t\tfor(j=0; j<bcnt; j++)\n\t\t\tif(i!=j && g[b[i]][b[j]])\n\t\t\t{\n\t\t\t\tv[vn++]=b[j];\n\t\t\t}\n\t\t\tclq(t,maxt,rcnt+1,v,vn,sum);\n\t\t}\n\t}\n}\n\nint main()\n{\n\t///freopen(\"in.txt\",\"r\",stdin);\n\tint i,j,k;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint x,y,z;\n\t\tclr(g,0);\n\t\tfor(i=0; i<m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tg[x][y]=g[y][x]=z;\n\t\t}\n\t\tint r[maxn],maxr[maxn],b[maxn];\n\t\tans=0;\n\t\tfor(i=1; i<=n ;i++)\n\t\t{\n\t\t\tk=0;\n\t\t\tfor(j=1; j<=n; j++)\n\t\t\tif(i!=j && g[i][j])\n\t\t\t{\n\t\t\t\tb[k++]=j;\n\t\t\t}\n\t\t\tr[0]=i;\n\t\t\tmaxr[0]=inf;\n\t\t\tclq(r,maxr,1,b,k,0);\n\t\t}\n\t\tif(n==1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vi> mat(n, vi(n));\n\tREP(i, m)\n\t{\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tmat[a][b] = mat[b][a] = c;\n\t}\n\tset<set<int>> st;\n\tqueue<set<int>> que;\n\tREP(i, n)\n\t{\n\t\tset<int> t = { i };\n\t\tst.insert(t);\n\t\tque.push(t);\n\t}\n\twhile (que.size())\n\t{\n\t\tset<int> tmp = que.front();\n\t\tque.pop();\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (tmp.count(i)) continue;\n\t\t\tset<int> nx = tmp;\n\t\t\tnx.insert(i);\n\t\t\tif (st.count(nx)) continue;\n\t\t\tbool f = true;\n\t\t\tfor (auto j : tmp)\n\t\t\t{\n\t\t\t\tif (mat[i][j] == 0)\n\t\t\t\t{\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tque.push(nx);\n\t\t\t\tst.insert(nx);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (auto i : st)\n\t{\n\t\tif (i.size() == 1) continue;\n\t\tint tmp = 0;\n\t\tfor (auto j : i)\n\t\t{\n\t\t\tint res = INF;\n\t\t\tfor (auto k : i)\n\t\t\t{\n\t\t\t\tif (j == k) continue;\n\t\t\t\telse chmin(res, mat[j][k]);\n\t\t\t}\n\t\t\ttmp += res;\n\t\t}\n\t\tchmax(ans, tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    auto check = [&]()mutable->int{\n      int ret = 0,len = deq.size();\n      int mincost[node];\n      for(int& i : mincost)i = IINF;\n      for(int i=0;i<len;i++){\n\tfor(int j=i+1;j<len;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      for(int& i : mincost) ret += i;\n      return ret;\n    };\n    int tmp = check();\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nint n,g[N][N],ans;\nvector<int> V;\n\nvoid calc(){\n  int sum=0;\n  for(int i=0;i<V.size();i++){\n    int mn=INF;\n    for(int j=0;j<V.size();j++)if(i!=j) mn=min(mn,g[V[i]][V[j]]);\n    sum+=mn;\n  }\n  ans=max(ans, (V.size()>1)*sum);\n}\n\n\nset<int> used;\nvoid solve(int pos){\n  if(pos==n){calc();return;}\n  solve(pos+1);\nif(used.count(pos))V.push_back(pos),solve(pos+1),V.pop_back();\n}\n\nvector<int> G[N];\nint can[N];\nset<set<int> > S;\nvoid dfs(int pos,int cnt){\n  int flg=1,len=G[pos].size();\n  used.insert(pos);\n  if(S.count(used)){used.erase(pos);return;}\n  S.insert(used);\n  for(int i=0;i<len;i++) can[G[pos][i]]++;\n  \n  for(int i=0;i<len;i++){\n    int nx=G[pos][i];\n    if(!used.count(nx)&&can[nx]==cnt)flg=0,dfs(nx,cnt+1);\n  }\n  if(flg)solve(0);\n  used.erase(pos);\n  for(int i=0;i<len;i++) can[G[pos][i]]--;\n}\n\n\nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    g[a][b]=g[b][a]=c;\n  }\n  \n  for(int i=0;i<n;i++)dfs(i,1);\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nint n, m;\nint g[105][105];\nint ans;\nset<vector<bool>> memo;\n\nvoid dfs(vector<bool> used){\n\tif(not (memo.emplace(used)).second) return;\n\t//for(auto i : used){ cout << i << ' ' ; } cout << endl;\n\n\tvector<int> to;\n\trep(i,n){\n\t\tif(used[i]) continue;\n\t\tbool f = true;\n\t\trep(j,n){\n\t\t\tif(not used[i]) continue;\n\t\t\tif(i == j || g[j][i] == 0){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) to.emplace_back(i);\n\t}\n\n\tfor(auto i : to){\n\t\tused[i] = true;\n\t\tdfs(used);\n\t\tused[i] = false;\n\t}\n\n\n\tint sum = 0;\n\trep(i,n){\n\t\tif(not used[i]) continue;\n\t\tint mini = INF;\n\t\trep(j,n){\n\t\t\tif(not used[j]) continue;\n\t\t\tif(g[i][j] == 0) continue;\n\t\t\tmini = min(mini, g[i][j]);\n\t\t}\n\t\tif(mini == INF) continue;\n\t\tsum += mini;\n\t}\n\tans = max(ans, sum);\n}\n\nsigned main(){\n\tcin >> n >> m;\n\n\tvector<int> v;\n\trep(i,m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a][b] = g[b][a] = c;\n\t}\n\n\trep(i,n){\n\t\tvector<bool> tmp(n,0);\n\t\ttmp[i] = true;\n\t\tdfs(tmp);\n\t}\n\tcout << ans << endl;\n\n\t//for(auto i : memo){ for(auto j : i){ cout << j << ' '; } cout << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll n,m;\nvector<vector<P>> g;\n\nll dfs(ll idx,vector<ll> &used) {\n\tif(idx==n) {\n\t\tll ret=0;\n\t\tREP(i,n) ret+=used[i];\n\t\tif(ret==INF) return 0;\n\t\telse return ret;\n\t}\n\tif(used[idx]==0) return dfs(idx+1,used);\n\tvector<ll> tmp(n); REP(i,n) tmp[i]=used[i];\n\tused[idx]=0;\n\tll ret=dfs(idx+1,used);\n\tused[idx]=INF;\n\tFOR(i,idx+1,n) used[i]=0;\n\tREP(i,g[idx].size()) {\n\t\tif(g[idx][i].first>idx) {\n\t\t\tused[g[idx][i].first]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(used[g[idx][i].first]==0) continue;\n\t\tused[idx]=min(used[idx],g[idx][i].second);\n\t\tused[g[idx][i].first]=min(used[g[idx][i].first],g[idx][i].second);\n\t}\n\tret=max(ret,dfs(idx+1,used));\n\tREP(i,n) used[i]=tmp[i];\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tg.assign(n,vector<P>(0));\n\tREP(i,m) {\n\t\tll u,v,f;\n\t\tcin>>u>>v>>f;\n\t\tu--;\n\t\tv--;\n\t\tg[u].pb(P(v,f));\n\t\tg[v].pb(P(u,f));\n\t}\n\tREP(i,n) sort(ALL(g[i]));\n\tvector<ll> used(n,-1);\n\tcout<<dfs(0,used)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> g(n, vector<int>(n));\n  vector<int> d(n);\n  while (m--) {\n    int u, v, f;\n    cin >> u >> v >> f;\n    --u, --v;\n    g[u][v] = g[v][u] = f;\n    ++d[u], ++d[v];\n  }\n  int res = 0;\n  auto fn = [&](const auto& a) {\n    int crr = 0;\n    for (int v : a) {\n      int mn = 1e9;\n      for (int u : a) {\n        if (u != v) {\n          mn = min(mn, g[v][u]);\n        }\n      }\n      crr += mn;\n    }\n    res = max(res, crr);\n  };\n  for (int k = 2; k < 20; ++k) {\n    vector<int> vs;\n    for (int v = 0; v < n; ++v) {\n      if (d[v] >= k - 1) {\n        vs.push_back(v);\n      }\n    }\n    m = vs.size();\n    if (m < k) {\n      continue;\n    }\n    vector<int> p(m);\n    fill(end(p) - k, end(p), 1);\n    do {\n      vector<int> a;\n      for (int i = 0; i < m; ++i) {\n        if (p[i]) {\n          a.push_back(vs[i]);\n        }\n      }\n      fn(a);\n    } while (next_permutation(begin(p), end(p)));\n  }\n  cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint n,p,m;\nint d[110]={0};\nvector<int> ve;\nint a[110][110]={0};\nint ans=0;\nvoid dfs(){\n\tint las=0;\n\tif(ve.size()!=0)las=1+ve.back();\n\t\n\tint val=0;\n\tint l=ve.size();\n\t//for(auto v:ve)cout<<v<<\" \";\n//\tcout<<endl;\n\t\t\n\tif(l>1){\n\t\n\tfor(int i=0;i<l;i++){\n\t\tint e=inf;\n\t\tfor(int j=0;j<l;j++)if(i!=j){\n\t\t\te=min(e,a[ve[i]][ve[j]]);\n\t\t}\n\t\tval+=e;\n\t}\n\tans=max(ans,val);\n\t}\n\t\n\t//if(ve.back()==n-1) return;\n\t\n\tfor(int i=las;i<n;i++){\n//\t\tcout<<i<<endl;\n\t\tbool bo=true;\n\t\tfor(auto v:ve)if(a[v][i]==0)bo=0;\n\t\tif(bo){\n\t\t\tve.pb(i);\n\t\t\tdfs();\n\t\t\tve.pop_back();\n\t\t}\n\t}\n}\n   signed main(){\ncin>>n>>m;\n   \tfor(int i=0;i<m;i++){\n   \tint y,yy,yyy;\n   \t\tcin>>y>>yy>>yyy;\n   \t\ty--;\n   \t\tyy--;\n   \t\ta[y][yy]=yyy;\n   \t\ta[yy][y]=yyy;\n   \t}\n   \t\n   \tdfs();\n   \tcout<<ans<<endl;\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; \nstatic const long long INF = 1e18;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    vvll g(n, vll(n)); rep(i, n) g[i][i] = INF;\n\n    rep(i, m) {\n        ll u, v, f; cin >> u >> v >> f; u--, v--;\n        g[u][v] = g[v][u] = f;\n    }\n\n    vll vs;\n    function<ll(vll&)> f = [&](vll& vs) {\n        ll ret = 0;\n        rep(i, vs.size()) {\n            ll min_f = INF;\n            rep(j, vs.size()) \n                chmin(min_f, g[vs[i]][vs[j]]);\n            ret += min_f != INF ? min_f : 0;\n        }\n        repi(i, vs.size() ? vs.back()+1 : 0, n) {\n            for (auto v : vs) if (!g[v][i]) goto next;\n            vs.pb(i);\n            chmax(ret, f(vs));\n            vs.pop_back();\n            next:;\n        }\n        return ret;\n    };\n    cout << f(vs) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<climits>\n#include<cassert>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nint V,E,ans;\nvector<int> G[MAX];\nint COST[MAX][MAX];\nbool used[MAX];\n\nvoid dfs(int node,deque<int>& deq,int sp){\n  if(node >= 15)return;\n\n  if(node >= 2){\n    int tmp = [&]()mutable->int{\n      int ret = 0;\n      int mincost[node];\n      rep(i,node) mincost[i] = IINF;\n      //for(int& i : mincost)i = IINF;\n      for(int i=0;i<node;i++){\n\tfor(int j=i+1;j<node;j++){\n\t  int cost = COST[deq[i]][deq[j]];\n\t  if(cost==0)return -1;\n\t  mincost[i] = min(mincost[i],cost);\n\t  mincost[j] = min(mincost[j],cost);\n\t}\n      }\n      //for(int& i : mincost) ret += i;\n      rep(i,node) ret += mincost[i]; \n      return ret;\n    }();\n\n    if(tmp != -1)ans = max(ans,tmp);\n  }\n\n  REP(i,sp,V){\n    if(used[i])continue;\n    if(G[i].size() < node)continue;\n    used[i] = true;\n    deq.push_back(i);\n    dfs(node+1,deq,i+1);\n    deq.pop_back();\n    used[i] = false;\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  int test[V];\n  for(int& i : test)i = IINF;\n  rep(i,V)G[i].clear();\n  rep(i,E){\n    int u,v,f;\n    cin >> u >> v >> f;\n    u--,v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    COST[u][v] = COST[v][u] = f;\n  }\n\n  deque<int> deq;\n  dfs(0,deq,0);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nint n, res;\nusing vvi = vector<vi>;\nvvi costs;\nvi invited, used;\n\nvoid dfs(int v){\n    if(v == n){\n        int cost = 0;\n        rep(i, n){\n            if(not invited[i]) continue;\n\n            int diff = inf;\n            rep(j, n){\n                if(i != j and invited[j]){\n                    chmin(diff, costs[i][j]);\n                }\n            }\n            if(diff == inf) continue;\n\n            cost += diff;\n        }\n        chmax(res, cost);\n\n        return;\n    }\n\n    // not use v\n    dfs(v + 1);\n\n    if(used[v]) return;\n\n    // use v\n    invited[v] = true;\n    vi idxs;\n    rep(u, v + 1, n){\n        if(costs[v][u] == 0 and not used[u]){\n            used[u] = true;\n            idxs.push_back(u);\n        }\n    }\n    dfs(v + 1);\n    for(auto & u : idxs){\n        used[u] = false;\n    }\n    invited[v] = false;\n}\n\nint main(void){\n    int m; cin >> n >> m;\n    costs = vvi(n, vi(n));\n\n    rep(loop, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        costs[a][b] = costs[b][a] = c;\n    }\n\n    invited = used = vi(n);\n    res = 0;\n    dfs(0);\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//cout<<setprecision(20)\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint LBI(vector<llint>&ar,llint in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint UBI(vector<llint>&ar,llint in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint n,m,i;cin>>n>>m;\n\tllint ans=0;\n\tstatic llint fre[100][100]={0};\n\tqueue<vector<int>>que;\n\tfor(i=0;i<m;i++){\n\t\tint u,v;llint f;\n\t\tcin>>u>>v>>f;u--;v--;\n\t\tfre[u][v]=f;\n\t\tfre[v][u]=f;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfre[i][i]=big;\n\t\tvector<int>iti;\n\t\titi.pub(i);\n\t\tque.push(iti);\n\t}\n\twhile(que.size()>0){\n\t\tvector<int>rab=que.front();\n\t\tque.pop();\n\t\tif(rab.size()>=2){\n\t\t\tllint gen=0;\n\t\t\tfor(auto it:rab){\n\t\t\t\tllint sai=big;\n\t\t\t\tfor(auto itr:rab){\n\t\t\t\t\tmineq(sai,fre[it][itr]);\n\t\t\t\t}\n\t\t\t\tgen+=sai;\n\t\t\t}\n\t\t\tmaxeq(ans,gen);\n\t\t}\n\t\tfor(i=rab.back()+1;i<n;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(auto it:rab){\n\t\t\t\tif(fre[i][it]==0){ok=false;break;}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tauto rr=rab;\n\t\t\t\trr.pub(i);\n\t\t\t\tque.push(rr);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nint n,g[N][N],ans;\nvector<int> V;\n\nvoid calc(){\n  int sum=0;\n  for(int i=0;i<V.size();i++){\n    int mn=INF;\n    for(int j=0;j<V.size();j++)if(i!=j) mn=min(mn,g[V[i]][V[j]]);\n    sum+=mn;\n  }\n  ans=max(ans, (V.size()>1)*sum);\n}\n\n\nvector<bool> used(N);\nvoid solve(int pos){\n  if(pos==n){calc();return;}\n  solve(pos+1);\n  if(used[pos])V.push_back(pos),solve(pos+1),V.pop_back();\n}\n\nvector<int> G[N];\nint can[N];\nset<vector<bool> > S;\nvoid dfs(int pos,int cnt){\n  int flg=1,len=G[pos].size();\n  used[pos]=1;\n  if(S.count(used)){used[pos]=0;return;}\n  S.insert(used);\n  for(int i=0;i<len;i++) can[G[pos][i]]++;\n  \n  for(int i=0;i<len;i++){\n    int nx=G[pos][i];\n    if(!used[nx]&&can[nx]==cnt)flg=0,dfs(nx,cnt+1);\n  }\n  if(flg)solve(0);\n  used[pos]=0;\n  for(int i=0;i<len;i++) can[G[pos][i]]--;\n}\n\n\nint main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    g[a][b]=g[b][a]=c;\n  }\n  for(int i=0;i<n;i++)dfs(i,1);\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint mat[102][102];\nint N, M;\n\nvector<int> vs;\nint ans;\n\nvoid dfs(int v){\n    int n = vs.size();\n    if(n > 1){\n        int total = 0;\n        for(int p : vs){\n            int score = 1000002;\n            for(int q : vs){\n                if(p == q) continue;\n                score = min(score, mat[p][q]);\n            }\n            total += score;\n        }\n        ans = max(ans, total);\n    }\n    for(int nv=v+1;nv<N;nv++){\n        bool ok = true;\n        for(int p : vs){\n            if(mat[p][nv] == 0){\n                ok = false;\n                break;\n            }\n        }\n        if(ok){\n            vs.push_back(nv);\n            dfs(nv);\n            vs.pop_back();\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n\n    memset(mat, 0, sizeof(mat));\n    for(int i=0;i<M;i++){\n        int u, v, f;\n        cin >> u >> v >> f;\n        u--; v--;\n        mat[u][v] = f;\n        mat[v][u] = f;\n    }\n\n    ans = 0;\n    vs.clear();\n    for(int i=0;i<N;i++){\n        vs.push_back(i);\n        dfs(i);\n        vs.pop_back();\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint n, m;\nlong long int fr[110][110] = {};\n\nlong long int ans = 0;\nvector<int> v;\n\nvoid func(int pos){\n    if(v.size() >= 2){\n        long long int S = 0;\n        for(int i = 0; i < v.size(); i++){\n            long long int num = INF;\n            for(int j = 0; j < v.size(); j++){\n                if(i == j){\n                    continue;\n                }\n                num = min(num, fr[v[i]][v[j]]);\n            }\n            S += num;\n        }\n        ans = max(ans, S);\n    }\n    for(int i = pos; i <= n; i++){\n        long long int cost = INF;\n        for(int j = 0; j < v.size(); j++){\n            cost = min(cost, fr[i][v[j]]);\n        }\n        if(cost > 0){\n            v.push_back(i);\n            func(i + 1);\n            v.pop_back();\n        }\n    }\n}\n\nint main(){\n    cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int u, v, f;\n        cin >> u >> v >> f;\n        fr[u][v] = f;\n        fr[v][u] = f;\n    }\n    func(1);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nint n,m;\nint g[110][110], deg[110];\nvector<int> V, use;\n\nint rec(int d, int k){\n  if(k==0){\n    int res = 0;\n    for(int a : use){\n      int minv = 1e9;\n      for(int b: use){\n\tif(a!=b)minv = min(minv, g[a][b]);\n      }\n      res += minv;\n    }\n    return res;\n  }\n  if(d==(int)V.size())return 0;\n\n  int res = rec(d+1,k);\n\n  if(k>0){\n    for(int a : use){\n      if(!g[a][V[d]])return res;\n    }\n\n    use.push_back(V[d]);\n    res = max(res, rec(d+1,k-1));\n    use.pop_back();\n  }\n  return res;\n}\n\nint max_clique(int k){\n  V.clear();\n  rep(i,n){\n    if(deg[i]>=k-1)V.push_back(i);\n  }\n  return rec(0,k);\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i,m){\n    int a,b,c;\n    cin >> a >> b >> c; a--; b--;\n    g[a][b] = g[b][a] = c;\n    deg[a]++; deg[b]++;\n  }\n\n  int res = 0;\n  for(int k=2;k*(k-1)/2<=m;k++)res = max(res, max_clique(k));\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 105\n\n\nint n,m,a,b,c;\nint ans=0;\n\nint t[MAX];\nint g[MAX];\nint G[MAX][MAX];\n\nvoid rec(int p,int cnt,int size){\n\n  \n  \n  if(cnt==size){\n    int sum=0;\n    for(int i=0;i<size;i++){\n\n      int mini=1e9;\n      for(int j=0;j<size;j++){\n        if(i==j)continue;\n        mini=min(mini,G[t[i]][t[j]]);\n      }\n      sum+=mini;\n    }\n\n    ans=max(ans,sum);\n    return;\n  }\n  if(p==n+1)return;\n\n  rec(p+1,cnt,size);\n\n  if(g[p]>=size-1){\n    t[cnt]=p;\n    rec(p+1,cnt+1,size);\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b>>c;\n    g[a]++;\n    g[b]++;\n    G[a][b]=G[b][a]=c;\n  }\n  for(int i=2;i<=15;i++)rec(1,0,i);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\nint ans = 0;\nint N,M;\nint table[NUM][NUM];\n\nvoid recursive(int index,vector<int> Party){\n\n\tif(index == N){\n\t\tif(Party.size() <= 1)return;\n\n\t\tint tmp_sum = 0,tmp_minimum;\n\n\t\tfor(int i = 0; i < Party.size(); i++){\n\t\t\ttmp_minimum = BIG_NUM;\n\t\t\tfor(int k = 0; k < Party.size(); k++){\n\t\t\t\tif(i == k)continue;\n\t\t\t\ttmp_minimum = min(tmp_minimum,table[Party[i]][Party[k]]);\n\t\t\t}\n\t\t\ttmp_sum += tmp_minimum;\n\t\t}\n\t\tans = max(ans,tmp_sum);\n\t\treturn;\n\t}\n\n\trecursive(index+1,Party);\n\n\tint tmp_minimum = BIG_NUM;\n\tfor(int i = 0; i < Party.size(); i++){\n\t\ttmp_minimum = min(tmp_minimum,table[index][Party[i]]);\n\t}\n\n\tif(tmp_minimum == 0)return;\n\n\tvector<int> NextParty;\n\tfor(int i = 0; i < Party.size(); i++)NextParty.push_back(Party[i]);\n\tNextParty.push_back(index);\n\n\trecursive(index+1,NextParty);\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)table[i][k] = 0;\n\t}\n\n\tint A,B,value;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %d\",&A,&B,&value);\n\t\tA--;\n\t\tB--;\n\t\ttable[A][B] = value;\n\t\ttable[B][A] = value;\n\t}\n\n\tvector<int> first_IN,first_OUT;\n\tfirst_IN.push_back(0);\n\n\trecursive(1,first_IN);\n\trecursive(1,first_OUT);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass RelationShip{\npublic:\n  int _to;\n  int _friendliness;\n  RelationShip(int to,int friendliness) :\n    _to(to), _friendliness(friendliness) {}\n  bool operator<(const RelationShip &r) const {\n    return _friendliness < r._friendliness;\n  }\n  bool operator>(const RelationShip &r) const {\n    return _friendliness > r._friendliness;\n  }\n};\n\n\nbool used[101];\nvector<RelationShip> edges[101];\nint idx[101][101];\nint total_rabbits;\nint total_pairs;\n\nint dfs(int last){\n  int res = 0;\n\n  int sum = 0;\n  for(int orig=0; orig <= last; orig++){\n    if(!used[orig]) continue;\n\n    int tmp = INF;\n    for(int next_i = 0; next_i < edges[orig].size(); next_i++){\n      int next = edges[orig][next_i]._to;\n      if(!used[next]) continue;\n      tmp = min(tmp,edges[orig][next_i]._friendliness);\n    }\n    if(tmp != INF) sum += tmp;\n  }\n  \n  res = max(sum,res);\n\n  for(int next=last + 1; next < total_rabbits; next++){\n    bool isok = true;\n    for(int prev = 0; prev <= last; prev++){\n      if(used[prev] && idx[prev][next] == -1) {\n        isok = false;\n        break;\n      }\n    }\n\n    if(!isok) continue;\n    used[next] = true;\n    res = max(res,dfs(next));\n    used[next] = false;\n  }\n  return res;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_rabbits,&total_pairs)){\n    for(int i=0;i<total_rabbits;i++){\n      edges[i].clear();\n    }\n    memset(used,false,sizeof(used));   \n    memset(idx,-1,sizeof(idx));\n\n    for(int pair_i = 0; pair_i < total_pairs; pair_i++){\n      int from,to,friendliness;\n      scanf(\"%d %d %d\",&from,&to,&friendliness);\n      from--; to--;\n      edges[from].push_back(RelationShip(to,friendliness));\n      edges[to].push_back(RelationShip(from,friendliness));\n      idx[from][to] = edges[from].size() - 1;\n      idx[to][from] = edges[to].size() - 1;\n    }\n\n    cout << dfs(-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 111;\nconst int INF = 1e9;\nint mat[MAXN][MAXN];\nint ans;\nint n, m;\n\nvoid dfs(vector<int>& v) {\n    int sz = v.size();\n    if (v.size() > 1) {\n        int tmp = 0;\n        for (int i = 0; i < sz; i++) {\n            int mini = INF;\n            for (int j = 0; j < sz; j++) if (j != i) {\n                mini = min(mini, mat[v[i]][v[j]]);\n            }\n            tmp += mini;\n        }\n        ans = max(ans, tmp);\n    }\n    int last = v.back();\n    for (int i = last+1; i < n; i++) {\n        bool ok = true;\n        for (int j = 0; j < sz; j++) {\n            if (!mat[i][v[j]]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            v.push_back(i);\n            dfs(v);\n            v.pop_back();\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v, f;\n        cin >> u >> v >> f;\n        u--; v--;\n        mat[u][v] = mat[v][u] = f;\n    }\n    ans = 0;\n    for (int i = 0; i < n; i++) {\n        vector<int> v(1, i);\n        dfs(v);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nint f[111][111];\n\nint rec(int p, vector<int> &used){\n    // if(k*(k+1)/2 > m) return 0;\n    \n    // cout << \"A \";\n    // for(int u : used) cout << u << ' ' ;\n    // cout << endl;\n\n    int res = 0;\n    for(int u : used){\n        int min_f = 1e9;\n        for(int v : used){\n            if(u == v) continue;\n            min_f = min(min_f, f[u][v]);\n            assert(f[u][v] > 0);\n        }\n        if(min_f == 1e9) min_f = 0;\n        res += min_f;\n    }\n    \n    for(int i = p; i < n; ++i){\n        int min_f = 1e9;\n        for(int v : used){\n            min_f = min(min_f, f[i][v]);\n        }\n        if(min_f == 0) continue;\n        used.push_back(i);\n        res = max(res, rec(i+1, used));\n        used.pop_back();\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m){\n        // cout << \"####################\" << endl;\n        memset(f, 0, sizeof f);\n        for(int i = 0; i < m; ++i){\n            int u,v,f_;\n            cin >> u >> v >> f_;\n            --u; --v;\n            f[u][v] = f[v][u] = f_;\n        }\n        if(n == 1){\n            cout << 0 << endl;\n        } else {\n            vector<int> used;\n            cout << rec(0,used) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nint dfs(int I,vi a){\n\tint res=0,S=a.size();\n\tbool b=1;\n\tif(S>=2){\n\t\tint sum=0;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint M=inf;\n\t\t\tfor(int j=0;j<S;j++) if(i!=j){\n\t\t\t\tint c=g[a[i]][a[j]];\n\t\t\t\tif(c==0) b=0;\n\t\t\t\tM=min(M,c);\n\t\t\t}\n\t\t\tsum+=M;\n\t\t}\n\t\tres=max(res,sum);\n\t}\n\tif(b&&S<14){\n\t\tfor(int i=I;i<n;i++){\n\t\t\ta.push_back(i);\n\t\t\tres=max(res,dfs(i+1,a));\n\t\t\ta.pop_back();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n,vi(n));\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tu--;v--;\n\t\tg[u][v]=c;\n\t\tg[v][u]=c;\n\t}\n\tvi a;\n\tcout<<dfs(0,a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nint N, M;\nint u, v, f;\nconst int MAX_N = 101;\nconst int MAX_F = 1000000;\n\nint maxv = 0;\nint table[MAX_N][MAX_N];\nbool att[MAX_N];\n\nvoid solve(int last) {\n\tint ret = 0;\n\tfor(int i=0; i<last+1; i++) {\n\t\tif(!att[i]) continue;\n\t\tint minF = MAX_F;\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tif(i == j) continue;\n\t\t\tif(!att[j]) continue;\n\t\t\tminF = min(minF, table[i][j]);\n\t\t}\n\t\tif(minF == MAX_F) continue;\n\t\tret += minF;\n\t}\n\tmaxv = max(maxv, ret);\n\n\tfor(int i=last+1; i<N; i++) {\n\t\tbool isF = true;\n\t\tfor(int j=0; j<last+1; j++) {\n\t\t\tif(!att[j]) continue;\n\t\t\tif(table[i][j]==0) { isF = false; break; }\n\t\t}\n\t\tif(!isF) continue;\n\t\tatt[i] = true;\n\t\tsolve(i);\n\t\tatt[i] = false;\n\t}\n}\n\nint main() {\n\tcin >> N >> M;\n\tmemset(table, 0, sizeof(int) * MAX_N * MAX_N);\n\tfor(int i=0; i<N; i++) att[i] = false;\t\n\tfor(int i=0; i<M; i++) {\n\t\tcin >> u >> v >> f;\n\t\tu--;\n\t\tv--;\n\t\ttable[u][v] = f;\n\t\ttable[v][u] = f;\n\t}\n\tmaxv = 0;\n\tsolve(-1);\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nlong long a[110][110],x[110],y[110],z[110];\nbool v[110];\nlong long n,m,maxn=0;\nint main()\n{\n while(cin>>n>>m)\n {\n  memset(a,0,sizeof(a));\n  for(long long i=1;i<=m;i++)\n  {\n   cin>>x[i]>>y[i]>>z[i];\n   a[x[i]][y[i]]=z[i];a[y[i]][x[i]]=z[i];\n  }\n  maxn=0;\n  for(long long i=1;i<=m;i++)\n  {\n   memset(v,0,sizeof(v));v[x[i]]=true;v[y[i]]=true;\n   for(long long j=1;j<=n;j++)\n   if(j!=x[i] && j!=y[i])\n   {\n    bool flag=true;\n    for(long long k=1;k<=n;k++)\n    if(j!=k && v[k])if(a[j][k]<z[i]){flag=false;break;}\n\n    if(flag)v[j]=true;\n   }\n  long long ans=0;\n  for(long long j=1;j<=n;j++)\n  if(v[j])\n  {\n   long long minn=1<<30;\n   for(long long k=1;k<=n;k++)\n   if(k!=j && v[k] && a[k][j]<minn)minn=a[k][j];\n   ans+=minn;\n  }\n  if(ans>maxn)maxn=ans;\n  }\n  cout<<maxn<<endl;\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint edges[110][110];\nbool picked[110];\nint n,m;\n\nint _solve() {\n    // ?????¨?????¶??????????????¢????¨????\n    int ret = 0;\n    for (int i=0; i<n; ++i) if (picked[i]) {\n        int score = 999999999;\n        for (int j=0; j<n; ++j) if (i != j && picked[j]) {\n            score = min(score, edges[i][j]);\n        }\n        ret += score;\n    }\n \n    for (int i=0; i<n; ++i) if (!picked[i]) { // ?¬?????????¶?????????????£?\n        // ????????????????????¨????????¨????????£?????????\n        bool ok = true;\n        for (int k=0; k<n; ++k) if (picked[k]) {\n            if (edges[i][k] == 0) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            picked[i] = true;\n            ret = max(ret, _solve());\n            picked[i] = false;\n        }\n    }\n   return ret;\n}\n\nint solve() {\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        for (int j=i+1; j<n; ++j) if (edges[i][j]) { // ?????????2??????????????¶\n            picked[i] = picked[j] = true;\n            ret = max(ret, _solve());\n            picked[i] = picked[j] = false;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i=0; i<m; ++i) {\n        int u,v,f; cin >> u >> v >> f;\n        u--; v--;\n        edges[u][v] = edges[v][u] = f;\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define INF 0X7FFFFFFF\n#define LL long long\nusing namespace std;\nint N,M;\nLL ans=0;\nint map[105][105];\nint F[105];\nint Node[105];\nbool flag[105];\ninline void dfs(int cnt)\n{\n\tLL temp=0;\n\tfor(int i=1;i<=cnt-1;i++)\n\t\tNode[F[i]]=INF;\n\tfor(int i=1;i<=cnt-1;i++)\n\t\tfor(int j=1;j<=cnt-1;j++)\n\t\t{\n\t\t\tif(i==j)\tcontinue;\n\t\t\tNode[F[i]]=min(Node[F[i]],map[F[i]][F[j]]);\n\t\t}\n\tfor(int i=1;i<=cnt-1;i++)\n\t{\n\t\tif(Node[F[i]]==INF)\n\t\t\tNode[F[i]]=0;\n\t\ttemp+=Node[F[i]];\n\t}\n\tif(temp>ans) ans=temp;\n\tif(cnt>14) return ;\n\tfor(int i=F[cnt-1];i<=N;i++)\n\t{\n\t\tif(flag[i])\tcontinue;\n\t\tbool tag=0;\n\t\tfor(int j=1;j<cnt;j++)\n\t\t{\n\t\t\tif(i==F[j]) continue; \n\t\t\tif(!map[i][F[j]])\n\t\t\t{\n\t\t\t\ttag=1;break;\n\t\t\t}\n\t\t}\n\t\tif(tag==1)\tcontinue;\n\t\tF[cnt]=i;flag[i]=1;\n\t\tdfs(cnt+1);\n\t\tflag[i]=0;\n\t}\n}\nint main()\n{\n\tint i,a,b,c;\n\tmemset(map,0,sizeof(map));\n\tscanf(\"%d%d\",&N,&M);\n\tfor(i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tmap[a][b]=c;\n\t\tmap[b][a]=c;\n\t}\n\tdfs(1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nint dfs(int I,vi a){\n\tint res=0,S=a.size();\n\tif(S>=2){\n\t\tint sum=0;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint M=inf;\n\t\t\tfor(int j=0;j<S;j++) if(i!=j) M=min(M,g[a[i]][a[j]]);\n\t\t\tsum+=M;\n\t\t}\n\t\tif(S==3&&a[0]==6&&a[1]==42&&a[2]==72) cout<<sum<<endl;\n\t\tres=max(res,sum);\n\t}\n\tif(S<14){\n\t\tfor(int i=I;i<n;i++){\n\t\t\ta.push_back(i);\n\t\t\tres=max(res,dfs(i+1,a));\n\t\t\ta.pop_back();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n,vi(n));\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tu--;v--;\n\t\tg[u][v]=c;\n\t\tg[v][u]=c;\n\t}\n\tvi a;\n\tcout<<dfs(0,a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint n,m;\nll ans = 0LL;\nll G[100][100];\n\nvoid dfs(int i, int cnt, int max_cnt, vector<bool> v){\n    if(cnt == max_cnt){\n        ll tmp_ans = 0LL;\n        repp(x, n){\n            if(!v[x]) continue;\n            ll tmp = LLONG_MAX;\n            repp(y, n){\n                if(!v[y] || x == y) continue;\n                tmp = min(tmp, G[x][y]);\n            }\n            tmp_ans += tmp;\n        }\n        ans = max(ans, tmp_ans);\n        return;\n    }\n    if(i == n) return;\n\n    for(int j=i;j<n;j++){\n        bool flag = true;\n        repp(x, n){\n            if(v[x] && G[j][x] == 0LL){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            v[j] = true;\n            dfs(j+1, cnt+1, max_cnt, v);\n            v[j] = false;\n        }\n    }\n    return;\n}\n\nint main(){\n    int u,v;\n    ll f;\n    cin >> n >> m;\n    rep(m){\n        cin >> u >> v >> f;\n        u--; v--;\n        G[u][v] = G[v][u] = f;\n    }\n    \n    reppp(i, 2, 14){\n        if(2*m/(i-1) < i) break;\n        dfs(0, 0, i, vector<bool>(n, false));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n\n#define INF (1LL<<62)\n\nusing namespace std;\n\ntypedef long long ll;\n\nll g[101][101],n,m;\n\nll rec(set<int> S,int mx){\n  \n  if(mx<0)return 0;\n\n  ll res=0;\n  set<int>::iterator it=S.begin();\n  for(;it!=S.end();it++){\n    set<int>::iterator j=S.begin();\n    ll t=INF;\n    for(;j!=S.end();j++){\n      if(it==j)continue;\n      t=min(t,g[*it][*j]);\n    }\n    res+=t;\n  }\n  \n  if(mx>=n-1)return res;\n\n  int id=-1;\n  ll cost=0;\n  for(int v=mx+1;v<n;v++){\n    if(S.count(v))continue;\n\n    bool fg=true;\n    set<int>::iterator it=S.begin();\n    for(;it!=S.end();it++){\n      fg&=(g[v][*it]<INF);\n    }\n    if(!fg)continue;\n\n    ll tmp=INF;\n    it=S.begin();\n    for(;it!=S.end();it++){\n      tmp=min(tmp,g[v][*it]);\n    }\n    if(cost<tmp)cost=tmp,id=v;\n  }\n  \n  S.insert(id);\n\n  return max(rec(S,id),res);\n}\n\nint main(void){\n\n  fill(g[0],g[101],INF);\n  for(int i=0;i<101;i++)g[i][i]=0;\n\n  cin >> n >> m;\n\n  for(int i=0;i<m;i++){\n    ll a,b,f;\n    cin >> a >> b >>f;\n    g[a-1][b-1]=g[b-1][a-1]=f;\n  }\n  \n  ll ans=0;\n\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(g[i][j]<INF){\n\tset<int>S;\n\tS.insert(i);\n\tS.insert(j);\n\tans=max(ans,rec(S,max(i,j)));\n      }\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVVI G(101);\nint is[101][101];\n\nint dfs(int i, int num, VI& xs){\n  if(SZ(xs) == num){\n\tint res = 0;\n\tfor(int j=0;j<num;++j){\n\t  int tmp = 1e9;\n\t  for(int k=0;k<num;++k){\n\t\tif(j == k) continue;\n\t\tif(!is[xs[j]][xs[k]]) return 0;\n\t\ttmp = min(is[xs[j]][xs[k]], tmp);\n\t  }\n\t  res += tmp;\n\t}\n\treturn res;\n  }\n\n  int res = 0;\n  for(int to: G[i]){\n\tif(find(ALL(xs), to) != xs.end()) continue;\n\txs.PB(to);\n\tres = max(res, dfs(to, num, xs));\n\txs.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  REP(i,M){\n\tint u, v, c; cin >> u >> v >> c;\n\t--u, --v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n\tis[u][v] = is[v][u] = c;\n  }\n\n  int ans = 0;\n  for(int i=2;i<=min(N,15);++i){\n\tVI xs;\n\tREP(u,N){\n\t  xs.PB(u);\n\t  ans = max(ans, dfs(u,i,xs));\n\t  xs.pop_back();\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n#define MAX_V 100\nstruct edge{int to,cost;};\n\nint v,e;\nvector<edge> G[MAX_V];\n\nbool solve(vector<bool> &used){\n    vector<set<pii>> vp(v);\n    rep(i,v){\n        if(used[i])continue;\n        vp[i].insert(pii(INF,-1));\n        for(auto e:G[i]){\n            if(used[e.to])continue;\n            vp[i].insert(pii(e.cost,e.to));\n        }\n    }\n    \n    rep(i,v){\n        if(used[i])continue;\n        int the_score = vp[i].begin()->first;\n        if(the_score==INF) the_score = 0;\n        \n        for(auto e:G[i]){\n            int pos_score;\n            pii t = *vp[e.to].begin();\n            assert(t.first<=e.cost);\n            if(t.first<e.cost)pos_score = 0;\n            else{\n                assert(t.first==e.cost);\n                \n                pii tmp = pii(-1,-1);\n                if(t.second==i){\n                    tmp = t;\n                    vp[e.to].erase(t);\n                }\n                \n                int x = vp[e.to].begin()->first;\n                if(x==INF) x = 0;\n                \n                pos_score = x-e.cost;\n                \n                if(tmp!=pii(-1,-1))vp[e.to].insert(tmp);\n            }\n            the_score-=pos_score;\n            \n        }\n        if(the_score<0){\n            used[i] = true;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nint main(){\n    cin>>v>>e;\n    rep(i,e){\n        int s,t,c;\n        cin>>s>>t>>c;\n        s--,t--;\n        G[s].pb(edge{t,c});\n        G[t].pb(edge{s,c});\n    }\n    \n    vector<bool> used(v,false);\n    \n    \n    while(solve(used));\n    \n    int ans = 0;\n    rep(i,v){\n        if(used[i])continue;\n        int mini = INF;\n        for(auto e:G[i]){\n            if(used[e.to])continue;\n            mini = min(mini,e.cost);\n        }\n        if(mini==INF)mini = 0;\n        ans+=mini;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll n,m;\nvector<vector<P>> g;\n\nll dfs(ll idx,vector<ll> &used) {\n\tif(idx==n) {\n\t\tll ret=0;\n\t\tREP(i,n) ret+=used[i];\n\t\tif(ret==INF) return 0;\n\t\telse return ret;\n\t}\n\tif(used[idx]==0) return dfs(idx+1,used);\n\tvector<ll> tmp(n); REP(i,n) tmp[i]=used[i];\n\tused[idx]=0;\n\tll ret=dfs(idx+1,used);\n\tused[idx]=INF;\n\tFOR(i,idx+1,n) used[i]=0;\n\tREP(i,g[idx].size()) {\n\t\tif(g[idx][i].first>idx) {\n\t\t\tused[g[idx][i].first]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(used[g[idx][i].first]==0) continue;\n\t\tused[idx]=min(used[idx],g[idx][i].second);\n\t\tused[g[idx][i].first]=min(used[g[idx][i].first],g[idx][i].second);\n\t}\n\tREP(i,n) if(tmp[i]==0) used[i]=0;\n\tret=max(ret,dfs(idx+1,used));\n\tREP(i,n) used[i]=tmp[i];\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tg.assign(n,vector<P>(0));\n\tREP(i,m) {\n\t\tll u,v,f;\n\t\tcin>>u>>v>>f;\n\t\tu--;\n\t\tv--;\n\t\tg[u].pb(P(v,f));\n\t\tg[v].pb(P(u,f));\n\t}\n\tREP(i,n) sort(ALL(g[i]));\n\tvector<ll> used(n,-1);\n\tcout<<dfs(0,used)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint n,m;\nll ans = 0LL;\nll G[100][100];\n\nvoid dfs(set<int> st, vector<bool> used, size_t max_size){\n    if(st.size() <= max_size){\n        ll new_score = 0LL;\n        if(st.size() > 1) for(int x: st){\n            ll tmp = LLONG_MAX;\n            for(int y: st){\n                if(x == y) continue;\n                tmp = min(tmp, G[x][y]);\n            }\n            new_score += tmp;\n        }\n        ans = max(ans, new_score);\n        if(st.size() == max_size) return;\n    }\n    \n    rep(n){\n        if(used[i]) continue;\n        bool can_add = true;\n        for(int x: st){\n            if(!G[i][x]){\n                can_add = false;\n                break;\n            }\n        }\n        if(can_add){\n            st.insert(i);\n            used[i] = true;\n            dfs(st, used, max_size);\n            used[i] = false;\n            st.erase(i);\n        }\n    }\n}\n\nint main(){\n    int u,v;\n    ll f;\n    cin >> n >> m;\n    rep(m){\n        cin >> u >> v >> f;\n        u--; v--;\n        G[u][v] = G[v][u] = f;\n    }\n    \n    ll i = 1LL;\n    while(i == 1 || 2*m/(i-1) >= i) i++;\n    dfs(set<int>(), vector<bool>(n, false), i-1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\ntemplate<typename T>\nT maximum_clique(\n        vector<vector<bool>> G,\n        const function<T(const vector<int>&)>& f) {\n    T ret = numeric_limits<T>::min();\n\n    int n = G.size();\n    vector<int> deg(n);\n    int M = 0;  // |edge|\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            if (G[i][j]) ++deg[i], ++deg[j], ++M;\n        }\n    }\n    vector<bool> used(n);\n\n    int lim = sqrt(2*M);\n\n    while (true) {\n        int u = -1;\n        for (int i = 0; i < n; ++i) {\n            if (!used[i] and deg[i] < lim) {\n                u = i;\n                used[u] = true;\n                break;\n            }\n        }\n\n        vector<int> neighbor;\n        if (u != -1) neighbor.push_back(u);\n        for (int v = 0; v < n; ++v) if (!used[v]) {\n            if (u == -1 || G[u][v]) {\n                neighbor.push_back(v);\n            }\n        }\n\n        int sz = neighbor.size();\n        vector<int> bit(sz);\n        for (int i = 0; i < sz; i++) {\n            for (int j = 0; j < sz; j++) {\n                if (G[neighbor[i]][neighbor[j]]) {\n                    bit[i] |= 1 << j;\n                }\n            }\n        }\n\n        vector<bool> dp(1<<sz);\n        dp[0] = true;\n        for (int s = 1; s < 1<<sz; ++s) {\n            int i = __builtin_ffs(s) - 1;\n            dp[s] = dp[s & ~(1<<i)] and (~bit[i] & s) == 0;\n            if (dp[s]) {\n                vector<int> vs;\n                for (int i = 0; i < sz; ++i) if (s >> i & 1) {\n                    vs.push_back(neighbor[i]);\n                }\n                ret = max(ret, f(vs));\n            }\n        }\n\n        if (u == -1) break;\n\n        for (int v : neighbor) {\n            --deg[v], --deg[u];\n            G[u][v] = G[v][u] = false;\n        }\n    }\n\n    return ret;\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m; cin >> n >> m;\n    auto G = make_v<bool>(n, n);\n    for (int i = 0; i < n; ++i) G[i][i] = true;\n\n    auto g = make_v<int>(n, n);\n    for (int i = 0; i < m; ++i) {\n        int u, v, f; cin >> u >> v >> f; --u, --v;\n        G[u][v] = G[v][u] = 1;\n        g[u][v] = g[v][u] = f;\n    }\n\n    function<int(const vector<int>&)> f = [&](const vector<int>& vs){\n        int ret = 0;\n        for (int i : vs) {\n            int mi = 0;\n            for (int j : vs) if (i != j) {\n                if (mi == 0) mi = g[i][j];\n                else chmin(mi, g[i][j]);\n            }\n            ret += mi;\n        }\n        return ret;\n    };\n\n    cout << maximum_clique<int>(G, f) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF=1000000000;\nint d[101][101];\n\nint selected[101];\nint maxSum=0;\nint n,m;\n\nvoid dfs(int num,int cnt,int idx){\n  if(cnt==num){\n    // for(int i = 0; i < num; i++){\n    //   //      cout<<selected[i]<<\" \";\n    // }\n    int sum=0;\n    // N[NÌRXgðßé\n    for(int i = 0; i < cnt; i++){\n      int minc=INF;\n      for(int j = 0; j < cnt; j++)\n\tif(i!=j)minc=min(minc,d[selected[i]][selected[j]]);\n      sum+=minc;\n    }\n    //    cout<<\" \"<<sum<<endl;\n    maxSum=max(maxSum,sum);\n  }\n  else{\n    for(int i = idx; i < n; i++){\n      bool ok=true;\n      // SyAÔÉ¹ª éÈçÂ­é\n      for(int j = 0; j < cnt; j++){\n\t// ¹ª¶ÝµÈ¢\n\tif(d[i][selected[j]]==INF){\n\t  ok=false;\n\t  break;\n\t}\n      }\n      if(ok){\n\tselected[cnt]=i;\n\tdfs(num,cnt+1,i+1);\n      }\n    }\n  }\n}\n \nint main(){\n  cin>>n>>m;\n  for(int i = 0; i < 101; i++)\n    for(int j = 0; j < 101; j++)\n      d[i][j]=INF;\n  for(int i = 0; i < m; i++){\n    int from,to,cost;\n    cin>>from>>to>>cost;\n    from--;to--;\n    d[from][to]=d[to][from]=cost;\n  }\n  maxSum=0;\n  // 1©ç14¸_©çÈéN[NÌÅåRXgðTõ\n  for(int i = 2; i <= 14; i++){\n    dfs(i,0,0);\n  }\n  cout<<maxSum<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint N,M,e[100][100],deg[100];\nvector<int> vs;\nvector<int> vc;\nint ans;\nvoid dfs(int x,int left){\n\tif(left==0){\n\t\tbool can=1;\n\t\trep(i,vc.size()) rep(j,i) if(e[vc[i]][vc[j]]==0) can=0;\n\t\tif(can){\n\t\t\tint sum=0;\n\t\t\tfor(int i:vc){\n\t\t\t\tint tmp=1e9;\n\t\t\t\tfor(int j:vc) if(i!=j) chmin(tmp,e[i][j]);\n\t\t\t\tsum+=tmp;\n\t\t\t}\n\t\t\tchmax(ans,sum);\n\t\t}\n\t\treturn;\n\t}\n\tif(x==vs.size()) return;\n\tdfs(x+1,left);\n\tvc.pb(vs[x]);\n\tdfs(x+1,left-1);\n\tvc.pop_back();\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--,b--;\n\t\te[a][b]=e[b][a]=c;\n\t\tdeg[a]++,deg[b]++;\n\t}\n\tfor(int d=2;d<=14;d++){\n\t\tvs.clear();\n\t\trep(i,N) if(deg[i]>=d-1) vs.pb(i);\n\t\tdfs(0,d);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{int from,to,cost;};\nusing Graph=vector<vector<Edge>>;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<bitset<100>> bit(n);\n    for(int i=0;i<m;i++){\n        int u,v,f;\n        cin>>u>>v>>f;\n        u--,v--;\n        g[u].push_back({u,v,f});\n        g[v].push_back({v,u,f});\n        bit[u][v]=true;\n        bit[v][u]=true;\n    }\n    bitset<100> s;\n    function<int(int,bitset<100>)> dfs=[&](int idx,bitset<100> used){\n        if(idx==n){\n            int res=0;\n            if(s.count()<=1) return 0;\n            for(int i=0;i<n;i++){\n                if(s[i]){\n                    int sc=1000000;\n                    for(auto &e:g[i]){\n                        if(s[e.to]){\n                            sc=min(sc,e.cost);\n                        }\n                    }\n                    res+=sc;\n                }\n            }\n            return res;\n        }\n        int res=dfs(idx+1,used);\n        if(used[idx]) return res;\n        s[idx]=true;\n        res=max(res,dfs(idx+1,(used|(~bit[idx])).set(idx,true)));\n        s[idx]=false;\n        return res;\n    };\n    cout<<dfs(0,bitset<100>())<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N, M, ST, gans, ans, hg1, ohg1;\nint jiyou[120][120], val[200], oval[300];\nbool used[1000];\n\nint getans()\n{\n\tint i, res = 0, nc = 0;\n\tfor (i = ST; i <= N; ++i)\n\t\tif (used[i])\n\t\t{\n\t\t\t++nc;\n\t\t\tres += val[i];\n\t\t}\n\tif (nc < 2) return 0;\n\treturn res;\n}\n\nvoid dfs(int x);\n\nint main()\n{\n\tint i, j, k, x, y, l;\n\tmemset(jiyou, 0, sizeof(jiyou));\n\tscanf(\"%d%d\", &N, &M);\n\tfor (i = 0; i < M; ++i)\n\t{\n\t\tscanf(\"%d%d%d\", &x, &y, &l);\n\t\tjiyou[x][y] = l;\n\t\tjiyou[y][x] = l;\n\t}\n\tfor (i = 1; i < N; ++i)\n\t{\n\t\tST = i;\n\t\tans = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\tmemset(val, 127, sizeof(val));\n\t\tused[i] = true;\n\t\tdfs(i+1);\n\t}\n\tprintf(\"%d\\n\", gans);\n\treturn 0;\n}\n\nvoid dfs(int x)\n{\n\tint i, haogandu = 10000000;\n\tif (x > N)\n\t{\n\t\tgans = max(gans, getans());\n\t\treturn;\n\t}\n\tfor (i = ST; i <= N; ++i)\n\t\tif (used[i])\n\t\t\thaogandu = min(haogandu, jiyou[x][i]);\n\tif (haogandu)\n\t{\n\t\tfor (i = ST; i <= N; ++i)\n\t\t\toval[i] = val[i];\n\t\tval[x] = haogandu;\n\t\tfor (i = ST; i <= N; ++i)\n\t\t\tif (used[i])\n\t\t\t{\n\t\t\t\tval[i] = min(val[i], jiyou[x][i]);\n\t\t\t\tif (i > ST)\n\t\t\t\t\tval[ST] = min(val[ST], jiyou[i][ST]);\n\t\t\t}\n\t\tused[x] = true;\n\t\tgans = max(gans, getans());\n\t\tdfs(x+1);\n\t\tused[x] = false;\n\t\tfor (i = ST; i <= N; ++i)\n\t\t\tval[i] = oval[i];\n\t}\n\tdfs(x+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint number[16];\nint graph[100][100];\nint creak(int idx, int k, int D, vector<int>& cand){\n  if(D - k > cand.size() - idx) return 0;\n  if(k == D){\n    int res = 0;\n    for(int i = 0; i < D; i++){\n      int m = INF;\n      for(int j = 0; j < D; j++) if(i != j) {\n        m = min(m, graph[number[i]][number[j]]);\n      }\n      if(m == 0) return 0;\n      res += m;\n    }\n    return res;\n  }else{\n    int ret = creak(idx + 1, k, D, cand);\n    number[k] = cand[idx];\n    ret = max(ret, creak(idx + 1, k + 1, D, cand));\n    return ret;\n  }\n}\nint main(){\n  int N, M;\n  while (cin>>N>>M && N) {\n    memset(graph, 0, sizeof(graph));\n    int dim[100] = {};\n    REP(i, M){\n      int u, v, f;\n      cin>>u>>v>>f;\n      u--; v--;\n      graph[u][v] = graph[v][u] = f;\n      dim[u]++;\n      dim[v]++;\n    }\n    vector<int> cand[16];\n    REP(i, N){\n      for(int d = 2; d <= dim[i] + 1 && d <= 15; d++){\n        cand[d].push_back(i);\n      }\n    }\n    int ans = 0;\n    for(int d = 2; d <= 15; d++){\n      if(cand[d].size() < d) break;\n      ans = max(ans, creak(0, 0, d, cand[d]));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<numeric>\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int N=100;\ntypedef array<int,N> INTARRAY;\ntypedef array<bool,N> BOOLARRAY;\n\nint d[N][N];\n\nint sum(INTARRAY ia){\n  int s=accumulate(begin(ia),end(ia),0);\n  return (s==INF)?0:s;\n}\n\nint dfs(BOOLARRAY ba,INTARRAY ia,int n){\n  int s=sum(ia);\n  if(n==N)return s;\n  int r=dfs(ba,ia,n+1);\n  BOOLARRAY cba=ba;\n  cba[n]=true;\n  INTARRAY cia=ia;\n  cia[n]=INF;\n  for(int i=0;i<n;i++){\n    if(cba[i]){\n      cia[i]=min(cia[i],d[n][i]);\n      cia[n]=min(cia[n],d[n][i]);\n    }\n  }\n  if(sum(cia)>s){\n    r=max(r,dfs(cba,cia,n+1));\n  }\n  return r;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    d[i][i]=INF;\n  }\n  int n,m;\n  cin>>n>>m;\n  while(m--){\n    int u,v,f;\n    cin>>u>>v>>f;\n    u--;\n    v--;\n    d[u][v]=d[v][u]=f;\n  }\n  int ans=0;\n  for(int i=0;i<N;i++){\n    BOOLARRAY ba={};\n    ba[i]=true;\n    INTARRAY ia={};\n    ia[i]=INF;\n    ans=max(ans,dfs(ba,ia,i+1));\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nint dfs(int I,vi a){\n\tint res=0,S=a.size();\n\tif(S>=2){\n\t\tint sum=0;\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint M=inf;\n\t\t\tfor(int j=0;j<S;j++) if(i!=j) M=min(M,g[a[i]][a[j]]);\n\t\t\tsum+=M;\n\t\t}\n\t\tres=max(res,sum);\n\t}\n\tif(I<14){\n\t\tfor(int i=I;i<n;i++){\n\t\t\ta.push_back(i);\n\t\t\tres=max(res,dfs(i+1,a));\n\t\t\ta.pop_back();\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n,vi(n));\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tu--;v--;\n\t\tg[u][v]=c;\n\t\tg[v][u]=c;\n\t}\n\tvi a;\n\tcout<<dfs(0,a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x7fffffff\n#define M 15\n\ntypedef long long int LLI;\n\nint n;\nint m;\nmap<int, LLI> es[114514];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i=0; i<m; i++) {\n    int a, b;\n    LLI c;\n    scanf(\"%d%d%lld\", &a, &b, &c);\n    es[a][b] = c;\n    es[b][a] = c;\n  }\n\n  LLI ans = 0;\n  for (int i=1; i<=n; i++) {\n    if (es[i].size() > M) continue;\n\n    int g = es[i].size();\n    int lim = 1 << g;\n    for (int k=0; k<lim; k++) {\n      int idx = 0;\n      LLI sum = 0;\n      vector<int> vs;\n      vs.emplace_back(i);\n      for (auto e : es[i]) {\n        if (k>>idx&1) {\n          vs.emplace_back(e.first);\n        }\n        idx++;\n      }\n\n      for (int v : vs) {\n        LLI mini = INF;\n        for (int u : vs) {\n          if (v == u) continue;\n          if (!es[v].count(u)) {\n            mini = INF;\n            break;\n          }\n          mini = min(mini, es[v][u]);\n        }\n        sum += mini;\n      }\n      if (sum >= INF) sum = 0;\n      ans = max(ans, sum);\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\ntemplate<typename T>\nvector<vector<T>> keisann(const vector<vector<T>>l, const vector<vector<T>>r) {\n\tvector<vector<T>>ans(l.size(), vector<T>(r[0].size()));\n\tassert(l[0].size() == r.size());\n\tfor (unsigned int h = 0; h < l.size(); ++h) {\n\t\tfor (unsigned int i = 0; i < r.size(); ++i) {\n\t\t\tfor (unsigned int w = 0; w < r[0].size(); ++w) {\n\n\t\t\t\tans[h][w] += l[h][i] * r[i][w];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\ntemplate<typename T>\nvector<vector<T>>powgyou(vector<vector<T>>a, const long long int n) {\n\tassert(a.size() == a[0].size());\n\tif (!n) {\n\t\tvector<vector<T>>e(a.size(), vector<T>(a[0].size()));\n\t\tfor (unsigned int i = 0; i < a.size(); ++i) {\n\t\t\te[i][i] = 1;\n\t\t}\n\t\treturn e;\n\t}\n\tif (n == 1)return a;\n\telse {\n\t\tvector<vector<T>>ans(a.size(), vector<T>(a[0].size(), 0));\n\t\tans = powgyou(a, n / 2);\n\t\tans = keisann(ans, ans);\n\t\tif (n % 2) {\n\t\t\tans = keisann(ans, a);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst int INF = 2147483647;\nconst long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\nvector<pair<int, int>>uses;\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\t\t\t\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\nok = true;\nbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, 0));\n\t\t\t}\n\t\t}\n\t}\n\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nmap<long long int, int>soinnsuu(long long int a) {\n\tmap<long long int, int>ans;\n\tfor (long long i = 2; i*i <= a; ++i) {\n\t\twhile (a%i == 0) {\n\t\t\tans[i]++;\n\t\t\ta /= i;\n\t\t}\n\t}\n\tif (a != 1)ans[a]++;\n\n\n\treturn ans;\n}\n\nbool isso(long long int a) {\n\tif (a == 1)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif (!(a%i)) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t}\n\t}\n\treturn true;\n}\n\n\nstruct vert {\n\tint deg;\n\tint s;\n\tint id;\n\tvert(int a, int b, int c) {\n\t\tdeg = a;\n\t\ts = b;\n\t\tid = c;\n\t}\n};\n\n\n#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\nclass Compare {\npublic:\n\tbool operator()(const pair<int, int>&l, const pair<int, int>&r) {\n\t\treturn l.second > r.second;\n\t}\n};\n\n\n\nint fri[100][100];\nint N, M;\n\nlong long int getans(vector<int>be,int now,vector<int>hapiness) {\n\tif (now == N)  {\n\t\treturn accumulate(hapiness.begin(), hapiness.end(), 0);\n\t}\n\n\t\n\tbool canjoin = true;\n\tlong long int ans(getans(be, now+1, hapiness));\n\n\tif (be.size() == 0) {\n\t\tbe.push_back(now);\n\t\thapiness.push_back(0);\n\t\tans = max(ans,getans(be, now + 1, hapiness));\n\t}\n\telse if (be.size() == 1) {\n\t\tbe.push_back(now);\n\t\thapiness.push_back(0);\n\t\thapiness[0] = fri[now][be[0]];\n\t\thapiness[1] = fri[now][be[0]];\n\t\tans = max(ans,getans(be, now + 1, hapiness));\n\t}\n\telse {\n\t\tint aminhap = 99999999;\n\t\tfor (int i = 0; i < be.size(); ++i) {\n\t\t\tif (fri[now][be[i]]) {\n\t\t\t\taminhap = min(aminhap, fri[now][be[i]]);\n\t\t\t\thapiness[i] = min(hapiness[i], fri[now][be[i]]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcanjoin = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (canjoin) {\n\n\t\t\tbe.push_back(now);\n\t\t\thapiness.push_back(aminhap);\n\t\t\tans = max(ans, getans(be, now, hapiness));\n\n\t\t}\n\t}\n\n\treturn ans;\n\t\n}\n\nint main() {\n\tmemset(fri, 0, sizeof(fri));\n\t cin >> N >> M;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tint c; cin >> c;\n\t\tfri[a][b] = c;\n\t\tfri[b][a] = c;\n\t}\n\n\tlong long int ans(getans(vector<int>(0, false),0, vector<int>(0)));\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n#define inf 100000000\n\nusing namespace std;\n\nint n, m;\nvector<int> G[105];\nint g[105][105];\n\nbool used[105];\nvector<int> vec;\nint table[15][15];\n\nint calc(int r)\n{\n\tint ret = 0;\n\tfor(int i = 1; i <= r; i++){\n\t\tif(table[r][i] != inf) ret += table[r][i];\n\t}\n\treturn ret;\n}\n\nint dfs(int v, int num)\n{\n\tif(num >= 14) return 0;\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(g[vec[i]][v] == 0) return 0;\n\t}\n\tvec.push_back(v);\n\tused[v] = true;\n\t\n\tint mi = inf;\n\tfor(int i = 1; i <= num; i++){\n\t\ttable[num+1][i] = min(table[num][i], g[vec[i-1]][v]);\n\t\tmi = min(mi, g[vec[i-1]][v]);\n\t}\n\ttable[num+1][num+1] = mi;\n\t\n\tint ret = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(used[G[v][i]]) continue;\n\t\tret = max(ret, dfs(G[v][i], num+1));\n\t}\n\tret = max(ret, calc(num+1));\n\tvec.pop_back();\n\tused[v] = false;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tint u, v, f;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u >> v >> f;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tg[u][v] = g[v][u] = f;\n\t}\n\t\n\tfor(int i = 0; i <= 14; i++){\n\t\tfor(int j = 0; j <= 14; j++){\n\t\t\ttable[i][j] = inf;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tans = max(ans, dfs(i, 0));\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#define RMAX 105\n\nusing namespace std;\n\nint n, m, first, second, f, mMax;\nint fr[RMAX][RMAX], p[RMAX];\nint sum;\n\nint processSum ()\n{\n    int i, j, currSum = 0;\n    for (i = 1; i <= m; i++)\n    {\n        int iMin = 1e6;\n        for (j = 1; j <= m; j++)\n            if (i != j) iMin = min (iMin, fr[p[i]][p[j]]);\n\n        if (iMin == 1e6) iMin = 0;\n        currSum += iMin;\n    }\n\n    return currSum;\n}\n\nvoid comb (int k)\n{\n    int i;\n    if (k == m+1)\n    {\n        sum = max (sum, processSum());\n    }\n    else\n    {\n        for (i = p[k-1] + 1; i <= n - m + k; i++)\n        {\n            p[k] = i;\n            comb (k+1);\n        }\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        cin >> first >> second >> f;\n        fr[first][second] = fr[second][first] = f;\n\n        if (fr[first][0] == 0) mMax++;\n        if (fr[second][0] == 0) mMax++;\n        fr[first][0] += f; fr[second][0] += f;\n    }\n\n    for (m = 1; m <= mMax; m++) comb(1);\n\n    cout << sum << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<cstring>\n\n\nusing namespace std;\n\ntypedef long long ll;\nconst int NODE = 101;\nconst int INF = (1<<28);\nint N,M;\nint fri[NODE][NODE];\nset<int> edge;\nstruct State{\n  ll A,B; // state -> AB\n  static const bool debug = false;\n  State operator & (const State& st) const {\n    State res;\n    res.A = A&st.A;\n    res.B = B&st.B;\n    return res;\n  }\n\n  void turnOn(int n){\n    if(debug) cout << \"turnOn \" << n << endl;\n    if(debug) cout << A << \" -> \";\n    if(n < 64) A |= (1LL<<n);\n    else B |= (1LL<<(n-64));\n    if(debug) cout << A << endl;\n  }\n\n  void toggle(int n){\n    if(debug) cout << \"turnOff \" << n << endl;\n    if(debug) cout << A << \" -> \";\n    if(n < 64) A ^= (1LL<<n);\n    else B ^= (1LL<<(n-64));\n    if(debug) cout << A << endl;\n  }\n\n  bool getAt(int n) const {\n    return n<64?(A&(1LL<<n)):(B&(1LL<<(64-n)));\n  }\n\n  int count() const {\n    return __builtin_popcountll(A) + __builtin_popcountll(B);\n  }\n};\n\nvoid input(){\n  memset(fri, 0, sizeof(fri));\n  edge.clear();\n\n  cin >> N >> M;\n  for(int i = 0; i < M; i++){\n    int a,b,f;\n    cin >> a >> b >> f;\n    a--; b--;\n    fri[a][b] = fri[b][a] = f;\n    edge.insert(f);\n  }\n}\n\nll find(int now, vector<int>& v, const int& lb, State& st){\n  \n  //cout << st.count() << endl;\n\n  ll res = -1;\n  for(int i = 0; i < N; i++){\n    if(fri[now][i] >= lb && !st.getAt(i)){\n      for(int j = 0; j < N; j++) if(i != j) v[j] = min(v[j], fri[i][j]);\n      st.turnOn(i);\n      res = max(res, find(now, v, lb, st));\n      st.toggle(i);\n    }\n  }\n  \n  if(res < 0 && st.count() > 1){\n    res = 0;\n    for(int i = 0; i < N; i++) if(st.getAt(i)) res += v[i];\n    //if(res == 17) cout << st.A << endl;\n  }\n  return res;\n}\n\n\nvoid solve(){\n  long long ans = 0;\n  for(set<int>::iterator ite = edge.begin(); ite != edge.end(); ite++)\n    for(int i = 0; i < N; i++){\n      vector<int> cost(N, INF);\n      for(int j = 0; j < N; j++) if(i != j) cost[j] = fri[i][j];\n      State st = (State){0,0};\n      st.turnOn(i);\n      ans = max(ans, find(i, cost, *ite, st));\n    }\n  cout << ans << endl;\n}\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 105\n\n\nint n,m,a,b,c;\nint ans=0;\n\nint t[MAX];\nint g[MAX];\nint G[MAX][MAX];\n\nvoid rec(int p,int cnt,int size){\n\n  \n  \n  if(cnt==size){\n    int sum=0;\n    for(int i=0;i<size;i++){\n\n      int mini=1e9;\n      for(int j=0;j<size;j++){\n        if(i==j)continue;\n        mini=min(mini,G[t[i]][t[j]]);\n      }\n      sum+=mini;\n    }\n\n    ans=max(ans,sum);\n    return;\n  }\n  if(p==n+1)return;\n\n  rec(p+1,cnt,size);\n\n  if(g[p]>=size-1){\n    t[cnt]=p;\n    rec(p+1,cnt+1,size);\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>a>>b>>c;\n    g[a]++;\n    g[b]++;\n    G[a][b]=G[b][a]=c;\n  }\n  for(int i=2;i<=14;i++)rec(1,0,i);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVVI G(101);\nint is[101][101];\n\nint dfs(int i, int num, VI& xs){\n  if(SZ(xs) == num){\n\tint res = 0;\n\tfor(int j=0;j<num;++j){\n\t  int tmp = 1e9;\n\t  for(int k=0;k<num;++k){\n\t\tif(j == k) continue;\n\t\tif(!is[xs[j]][xs[k]]) return 0;\n\t\ttmp = min(is[xs[j]][xs[k]], tmp);\n\t  }\n\t  res += tmp;\n\t}\n\treturn res;\n  }\n\n  int res = 0;\n  for(int to: G[i]){\n\tif(find(ALL(xs), to) != xs.end() || to <= i) continue;\n\txs.PB(to);\n\tres = max(res, dfs(to, num, xs));\n\txs.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  REP(i,M){\n\tint u, v, c; cin >> u >> v >> c;\n\t--u, --v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n\tis[u][v] = is[v][u] = c;\n  }\n\n  int ans = 0;\n  for(int i=2;i<=min(N,15);++i){\n\tVI xs;\n\tREP(u,N){\n\t  xs.PB(u);\n\t  ans = max(ans, dfs(u,i,xs));\n\t  xs.pop_back();\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\nint n, m, d[N][N];\nint used[N],ans=0;\n\nvoid dfs(int x){\n  \n  if(x>=2){\n    \n    int sum=0;\n  \n    for(int i=0;i<n;i++){\n    \n      if(!used[i]) continue;\n    \n      int mincost=INF;\n    \n      for(int j=0;j<n;j++){\n      \n\tif(!used[j]) continue;\n      \n\tif(i!=j) mincost=min(mincost,d[i][j]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n  }\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n    \n    if(used[i]) continue;\n\n    used[i]=1;\n\n    int mincost=INF;\n\n    for(int j=0;j<n;j++)\n\n      if(i!=j&&used[j]) mincost=min(mincost,d[i][j]);\n      \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1);\n    \n    used[i]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<m;i++){\n\n    cin>>a>>b>>f;\n\n    d[a-1][b-1]=d[b-1][a-1]=f;\n  }\n\n  dfs(0);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_N = 100;\n\nint n, m;\nmap<int, int> G[MAX_N];\n\nint base;\nint ans = -1;\n\nvoid calc(const vector<int> &nodes) {\n\tconst int V = nodes.size();\n\n\tvector<int> idx(n, -1);\n\tfor(int i = 0; i < V; ++i) {\n\t\tidx[nodes[i]] = i;\n\t}\n\n\tfor(int bit = 0; bit < (1 << V); ++bit) {\n\t\tint sum = 0;\n\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tif(bit & (1 << i)) continue;\n\n\t\t\tint score = INT_MAX;\n\t\t\tconst int v = nodes[i];\n\n\t\t\tfor(int j = 0; j < V; ++j) {\n\t\t\t\tif(i == j || (bit & (1 << j))) continue;\n\n\t\t\t\tconst int u = nodes[j];\n\t\t\t\tif(!G[u].count(v)) goto ng;\n\t\t\t\tchmin(score, G[u][v]);\n\t\t\t}\n\n\t\t\tif(score != INT_MAX) sum += score;\n\t\t}\n\t \n\t\tchmax(ans, sum);\n\tng:;\n\t}\n}\n\nvoid dfs(int v = 0) {\n\tif(v == n) return;\n\n\tif(static_cast<int>(G[v].size()) <= base) {\n\t\tvector<int> nodes(G[v].size() + 1);\n\n\t\tauto it = G[v].cbegin();\n\t\tfor(int i = 0; it != G[v].cend(); ++i, ++it) {\n\t\t\tnodes[i] = it->first;\n\t\t}\n\t\tnodes.back() = v;\n\t\tcalc(nodes);\n\t}\n\tdfs(v + 1);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\n\tbase = sqrt(2 * m);\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t--a; --b;\n\t\tG[a].insert({b, c});\n\t\tG[b].insert({a, c});\n\t}\n\n\tdfs();\n\n\tif(ans == -1) {\n\t\tvector<int> nodes(n);\n\t\tiota(nodes.begin(), nodes.end(), 0);\n\t\tcalc(nodes);\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct Edge {\n  int from, to, friendliness;\n};\nmap<vector<bool>, int> mp;\nll dfs(int now, vector<bool> &sel, const vector<vector<Edge>> &g, const vvll &d, int n) {\n  if(mp[sel] != 0) return mp[sel];\n  ll res = 0;\n  for(int i=0;i<n;++i) {\n    if(!sel[i]) continue;\n    ll val = LINF;\n    for(int j=0;j<n;++j) {\n      if(i == j || !sel[j]) continue;\n      val = min(val, d[i][j]);\n    }\n    if(val == LINF) val = 0;\n    res += val;\n  }\n  for(int i=0;i<(int)(g[now].size());++i) {\n    int nxt = g[now][i].to;\n    if(sel[nxt]) continue;\n    bool ok = true;\n    for(int j=0;j<n;++j) {\n      if(j == nxt) continue;\n      if(sel[j] && d[nxt][j] == 0) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) {\n      sel[nxt] = true;\n      res = max(res, dfs(nxt, sel, g, d, n));\n      sel[nxt] = false;\n    }\n  }\n  return mp[sel] = res;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, m; cin >> n >> m;\n  vector<vector<Edge>> g(n);\n  vvll d(n, vll(n, 0));\n  for(int i=0;i<m;++i) {\n    int u, v, f; cin >> u >> v >> f;\n    u--; v--;\n    g[u].push_back({u, v, f});\n    g[v].push_back({v, u, f});\n    d[u][v] = f;\n    d[v][u] = f;\n  }\n  vector<bool> sel(n, false);\n  ll ans = 0;\n  for(int i=0;i<n;++i) {\n    sel[i] = true;\n    ans = max(ans, dfs(i, sel, g, d, n));\n    sel[i] = false;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint g[100][100];\n\nint solve(vi& vec)\n{\n    int res = 0;\n    rep(i,len(vec)){\n        int cri = INF;\n        rep(j,len(vec)){\n            if(j != i){\n                cmn(cri,g[vec[i]][vec[j]]);\n            }\n        }\n        res += cri;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        g[a-1][b-1] = g[b-1][a-1] = c;\n    }\n    int ans = 0;\n    srep(i,2,min(n+1,15)){\n        vi vec;\n        rep(j,n){\n            int cnt = 0;\n            rep(k,n){\n                if(g[j][k] > 0){\n                    cnt++;\n                }\n            }\n            if(cnt >= i-1){\n                vec.pb(j);\n            }\n        }\n        if(len(vec) >= i){\n            vector<bool> v(len(vec),false);\n            fill(v.end() - i, v.end(), true);\n            do{\n                vi ch;\n                rep(j,len(v)){\n                    if(v[j]){\n                        ch.pb(vec[j]);\n                    }\n                }\n                cmx(ans,solve(ch));\n            }while(next_permutation(all(v)));\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D){\n\tlong long int ret = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i]==-1){\n\t\t\tauto next = D;\n\t\t\t\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(D[j] != -1){\n\t\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long int plus = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tlong long int x = D[j];\n\t\t\t\tlong long int y = next[j];\n\t\t\t\tif(x == -1)x = 0;\n\t\t\t\tif(y == -1)y = 0;\n\t\t\t\tplus += x - y;\n\t\t\t}\n\t\t\tif(plus >= 0){\n\t\t\t\tret = max(ret, solve(D));\n\t\t\t}\n\t\t\tD = next;\n\t\t}\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x));\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint ans=0;\nint n,m;\nint g[101][101];\n\nvoid bfs(int x,vector<int>s){\n\tif(x==n){\n\t\tif(s.size()==0||s.size()==1)return;\n\t\tint tmp =0;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tint mi = inf;\n\t\t\tfor(int j=0;j<s.size();j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tmi = min(mi,g[s[i]][s[j]]);\n\t\t\t}\n\t\t\ttmp += mi;\n\t\t}\n\t\tans = max(ans,tmp);\n\t\treturn;\n\t}\n\tbfs(x+1,s);\n\tbool flag = 1;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(g[x][s[i]]==0)flag = 0;\n\t}\n\tif(flag){\n\t\ts.PB(x);\n\t\tbfs(x+1,s);\n\t}\n\treturn;\n}\n\n\n\nint main(){\n\tcin >> n >> m;\n\tint u,v,f;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> u >> v >> f;\n\t\tu--;\n\t\tv--;\n\t\tg[u][v] = f;\n\t\tg[v][u] = f;\n\t}\n\tvector<int> s;\n\tbfs(0,s);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint N,M;\nvector< vector<int> >R;\nint res;\n\nvoid make(vector<int> M){\n\tif(M.size()==0){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvector<int> Next;\n\t\t\tNext.push_back(i);\n\t\t\tmake(Next);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<M[0];i++){\n\t\tbool f=true;\n\t\tvector<int> Next=M;\n\t\tNext.insert(Next.begin(),i);\n\t\tfor(int j=0;j<M.size();j++){\n\t\t\tif(R[i][M[j]]==0){\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) make(Next);\n\t}\n\tint point=0;\n\tif(M.size()>1){\n\t\tfor(int i=0;i<M.size();i++){\n\t\t\tint temp=10000000;\n\t\t\tfor(int j=0;j<M.size();j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\ttemp=min(temp,R[M[i]][M[j]]);\n\t\t\t}\n\t\t\tpoint+=temp;\n\t\t}\n\t}\n\tres=max(point,res);\n}\n\t\t\t\n\nvoid solve()\n{\n\tres=0;\n\tR.clear();\n\tR.resize(N,vector<int>(N,0));\n\tfor(int i=0;i<M;i++){\n\t\tint x,y,r;\n\t\tcin>>x>>y>>r;\n\t\tx--;y--;\n\t\tR[x][y]=r;\n\t\tR[y][x]=r;\n\t}\n\tmake(vector<int>(0));\n\tcout<<res<<endl;\n}\n\nint main()\n{\n\twhile(cin>>N>>M){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define INF (1<<29)\n\nint N, cost[MAX][MAX];\n\nint get_sat(set<int> &inv)\n{\n    int sat = 0;\n    for (auto &i: inv) {\n        int s = INF;\n        for (auto &j: inv) {\n            if (i == j) continue;\n            s = min(s, cost[i][j]);\n        }\n        sat += s;\n    }\n    return sat;\n}\n\nmap<set<int>, int> memo;\n\nint dfs(set<int> inv)\n{\n    int res = 0;\n    if (memo.count(inv) > 0) {\n        return memo[inv];\n    }\n        \n    if (inv.size() >= 2) {\n        res = get_sat(inv);\n    }\n    for (int i = 0; i < N; i++) {\n        bool ok = 1;\n        for (auto &j: inv) {\n            if (cost[i][j] == 0) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok) {\n            set<int> ninv = inv;\n            ninv.insert(i);\n            res = max(res, dfs(ninv));\n        }            \n    }\n    return (memo[inv] = res);\n}\n\nint main()\n{\n    int M, a, b, c;\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        cin >> a >> b >> c;\n        a--; b--;\n        cost[a][b] = cost[b][a] = c;\n    }    \n    cout << dfs(set<int>()) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1LL << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nint n, res;\nusing vvi = vector<vi>;\nvvi costs;\nvi invited, used;\n\nvoid dfs(int v){\n    if(v == n){\n        int cost = 0;\n        rep(i, n){\n            if(not invited[i]) continue;\n\n            int diff = inf;\n            rep(j, n){\n                if(i != j and invited[j]){\n                    chmin(diff, costs[i][j]);\n                }\n            }\n            if(diff == inf) continue;\n\n            cost += diff;\n        }\n        chmax(res, cost);\n\n        return;\n    }\n\n    // not use v\n    dfs(v + 1);\n\n    // use v\n    invited[v] = true;\n    vi idxs;\n    rep(u, v + 1, n){\n        if(costs[v][u] == 0 and not used[u]){\n            used[u] = true;\n            idxs.push_back(u);\n        }\n    }\n    dfs(v + 1);\n    for(auto & u : idxs){\n        used[u] = false;\n    }\n    invited[v] = false;\n}\n\nint main(void){\n    int m; cin >> n >> m;\n    costs = vvi(n, vi(n));\n\n    rep(loop, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        costs[a][b] = costs[b][a] = c;\n    }\n\n    invited = used = vi(n);\n    res = 0;\n    dfs(0);\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\n\nint w[101][101];\nint N, M, ans;\nbitset<101> use;\nvoid dfs(int depth) {\n    if(depth == N) {\n        if(use.count() < 2) return;\n        int sum = 0;\n        rep(i, N) if(use[i]) {\n            int mi = INF;\n            rep(j, N) if(i != j && use[j])\n              mi = min(mi, w[i][j]);\n            sum += mi;\n        }\n        ans = max(ans, sum);\n        return;\n    }\n    bool ok = true;\n    rep(i, depth)\n      if(use[i] && !w[i][depth]) ok = false;\n    dfs(depth + 1);\n    if(ok) {\n        use[depth] = 1;\n        dfs(depth + 1);\n        use[depth] = 0;\n    }\n    return;\n}\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    int u_, v_, w_;\n    memset(w, 0, sizeof(w));\n    rep(i, M) {\n        scanf(\"%d%d%d\", &u_, &v_, &w_);\n        --u_; --v_;\n        w[u_][v_] = w[v_][u_] = w_;\n    }\n    ans = 0;\n    dfs(0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct CWW{CWW(){ios::sync_with_stdio(false);cin.tie(0);}}cww;\n\ntypedef __int128 Int;\ntypedef long long LL;\ntypedef vector<int> V;\ntypedef vector<LL> VL;\ntypedef vector<Int> VI;\nmap<Int,int> pos;\nmap<Int,LL> memo;\nInt allbit;\nLL sum(VL &v){\n    LL res=0;\n    for(auto &it:v)res+=it;\n    return res;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,vector<T> v){\n    for(auto &it:v)os<<it<<\" \";\n    return os;\n}\nvoid dfs(Int used,VI& exists,V &vv,VL val,vector<VL>& edge){\n    Int rest=allbit&(~used);\n    for(auto &it:vv)rest&=exists[it];\n    //cout<<vv<<endl;\n    while(rest){\n\tInt nowbit=rest&(-rest);\n\trest-=nowbit;\n\tif(memo.count(nowbit|used))continue;\n\tint nowpos=pos[nowbit];\n\tauto nxtval=val;\n\tnxtval[nowpos]=1145141919;\n\tfor(auto &it:vv){\n\t    nxtval[it]=min(nxtval[it],edge[it][nowpos]);\n\t    nxtval[nowpos]=min(nxtval[nowpos],edge[it][nowpos]);\n\t}\n\tmemo[nowbit|used]=sum(nxtval);\n\tvv.push_back(nowpos);\n\tdfs(used|nowbit,exists,vv,nxtval,edge);\n\tvv.pop_back();\n    }\n}\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    VI exists(N,0);\n    vector<VL> edge(N,VL(N,0));\n    Int bit=1;\n    for(Int i=0;i<N;i++,bit<<=1){\n\tpos[bit]=i;\n    }\n    allbit=bit-1;\n    while(M--){\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\ta--,b--;\n\tedge[a][b]=c;\n\tedge[b][a]=c;\n\texists[a]|=((Int)1)<<b;\n\texists[b]|=((Int)1)<<a;\n    }\n    for(int i=0;i<N;i++){\n\tvector<int> vv(1,i);\n\tVL val(N,0);\n\tval[i]=1145141919;\n\tdfs(((Int)1)<<i,exists,vv,val,edge);\n    }\n    LL res=0;\n    for(auto &it:memo)res=max(res,it.second);\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nint n,m,ans;\nint mp[105][105];\nbool vis[105];\nint val[105];\nvector<int> q;\nvoid dfs(int sum,int v[])\n{\n\tans=max(ans,sum);\n\tint i,j,k;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tbool flag;\n\t\tif(!vis[i])\n\t\t{\n\t\t\tflag=true;\n\t\t\tfor(j=0;flag&&j<q.size();j++)\n\t\t\t\tif(mp[i][q[j]]==0)\n\t\t\t\t\tflag=false;\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tint res=0;\n\t\t\t\tfor(j=0;j<q.size();j++)\n\t\t\t\t{\n\t\t\t\t\tv[q[j]]=min(val[q[j]],mp[i][q[j]]);\n\t\t\t\t\tv[i]=min(val[i],mp[i][q[j]]);\n\t\t\t\t}\n\t\t\t\tq.push_back(i);\n\t\t\t\tvis[i]=true;\n\t\t\t\tfor(j=0;j<q.size();j++)\n\t\t\t\t\tres+=v[q[j]];\n\t\t\t\tdfs(res,v);\n\t\t\t\tvis[i]=false;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m)==2)\n\t{\n\t\tmemset(mp,0,sizeof(mp));\n\t\tint i;\n\t\tfor(i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tmp[a][b]=mp[b][a]=c;\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tq.clear();\n\t\t\tq.push_back(i);\n\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\tmemset(val,inf,sizeof(val));\n\t\t\tvis[i]=true;\n\t\t\tdfs(0,val);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint n,m,ans=0;\nint graph[110][110];\nint degree[100];\n\nconst int inf=1<<29;\nusing state=tuple<int,int>; \n\nvoid dfs(int v,int d,vector<state> &ary){\n\tif(v==n) return;\n\tif(ary.size()>=d+1) return;\n\n\tdfs(v+1,d,ary);\n\n\tif(int(ary.size())<=degree[v]){\n\t\tvector<state> backup=ary;\n\t\t\n\t\tbool ok=true;\n\t\tint cmin=inf,sum=0;\n\t\tfor(auto &v2:ary){\n\t\t\tif(graph[v][get<0>(v2)]==0) ok=false;\n\t\t\tchmin(get<1>(v2),graph[v][get<0>(v2)]);\n\t\t\tchmin(cmin,graph[v][get<0>(v2)]);\n\t\t\tsum+=get<1>(v2);\n\t\t}\n\n\t\tif(ok){\n\t\t\tary.push_back(state(v,cmin));\n\t\t\tsum+=cmin;\n\t\t\tif(int(ary.size())>=2) chmax(ans,sum);\n\t\t\tdfs(v+1,min(d,degree[v]),ary);\n\t\t}\n\n\t\tary=backup;\n\t}\n\n\treturn;\n}\n\nint main(void){\n\tcin >> n >> m;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tgraph[a-1][b-1]=graph[b-1][a-1]=c;\n\t\tdegree[a-1]++,degree[b-1]++;\n\t}\n\n\tvector<state> ary;\n\tdfs(0,n,ary);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define clearAll(a) memset(a,0,sizeof(a))\n#define oo 1000000000\n#define maxn 105\nusing namespace std;\n\nstruct edge\n{\tint x,y,d;\n};\n\nint n,m;\nint h[maxn];\nint g[maxn][maxn];\nint set[maxn];\nedge a[maxn*maxn];\n\nbool cmp(edge a,edge b)\n{\ta.d>b.d;\n}\n\nint find(int x)\n{\treturn set[x]==x?x:set[x]=find(set[x]);\n}\n\nint main()\n{\tscanf(\"%d %d\",&n,&m); \n\tclearAll(g);\n\tfor (int i=1;i<=m;i++)\n\t{\tscanf(\"%d %d %d\",&a[i].x,&a[i].y,&a[i].d);\n\t\tg[a[i].x][a[i].y]=g[a[i].y][a[i].x]=a[i].d;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)\n\t\tif (g[i][j]==0)\n\t\t{\ta[++m].x=i;\n\t\t\ta[m].y=j;\n\t\t\ta[m].d=0;\n\t\t}\n\n\tsort(a+1,a+m+1,cmp);\n\tbool isIn[maxn];\n\tclearAll(isIn);\n\tint ans=0;\n\tint rest=n;\n\tint tot;\n\twhile (true)\n\t{\tint cnt=0;\n\t\tif (rest==0) break;\n\t\ttot=0;\n\t\tclearAll(h);\n\t\tfor (int i=1;i<=n;i++)\tset[i]=i;\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\tif (cnt==rest-1) break;\n\t\t\tint x=a[i].x,y=a[i].y;\n\t\t\tif (isIn[x]||isIn[y]) continue;\n\t\t\tint xx=find(x),yy=find(y);\n\t\t\tif (xx==yy) continue;\n\t\t\tset[xx]=yy;\n\t\t\tif (h[xx]==0) { h[xx]=a[i].d; tot+=h[xx];}\n\t\t\tif (h[yy]==0) { h[yy]=a[i].d; tot+=h[yy];}\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tif (tot>ans) ans=tot;\n\t\tisIn[a[1].x]=isIn[a[1].y]=true;\n\t\trest-=2;\n\t}\n\t\n\tprintf(\"%d\\n\",tot);\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> graph(n,vector<int>(n));\n    rep(i,0,m){\n        int u,v,f;\n        cin >> u >> v >> f;\n        --u;\n        --v;\n        graph[u][v]=graph[v][u]=f;\n    }\n\n    function<int(int,set<int>)> rec=[&](int num,set<int> s){\n        if(num==0){\n            int res=0;\n            for(int v:s){\n                int tmp=inf;\n                for(int u:s){\n                    if(u==v) continue;\n                    tmp=min(tmp,graph[v][u]);\n                }\n                res+=tmp;\n            }\n            return res;\n        }\n        int res=0;\n        rep(v,0,n){\n            if(s.find(v)!=s.end()) continue;\n            bool ok=true;\n            for(int u:s){\n                if(graph[v][u]!=0) continue;\n                ok=false;\n                break;\n            }\n            if(!ok) continue;\n            set<int> s_=s;\n            s_.insert(v);\n            res=max(res,rec(num-1,s_));\n        }\n        return res;\n    };\n\n    int ans=0;\n    rep(i,2,inf){\n        if(i*(i-1)/2>m) continue;\n        int tmp=rec(i,set<int>());\n        if(tmp==0) break;\n        ans=max(ans,tmp);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, M;\nint graph[100][100];\nint dig[100];\nvector<int> use;\nint calc(int depth, int need){\n  if(use.size() == need) {\n    int ret = 0;\n    REP(i, need) {\n      int minf = INF;\n      REP(j, need) if(i != j) minf = min(minf, graph[use[i]][use[j]]);\n      ret += minf;\n    }\n    return ret;\n  }\n  if(depth == N) return 0;\n  int ret = calc(depth + 1, need);\n  if(dig[depth] >= need - 1){\n    FORIT(it, use) if(graph[*it][depth] == 0) return ret;\n    use.push_back(depth);\n    ret = max(ret, calc(depth + 1, need));\n    use.pop_back();\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> N >> M && N){\n    REP(i, M){\n      int u, v, f;\n      cin >> u >> v >> f;\n      u--; v--;\n      graph[u][v] = graph[v][u] = f;\n      dig[u]++; dig[v]++;\n    }\n    int ans = 0;\n    for(int d = 2; d <= 15; d++){\n      ans = max(ans, calc(0, d));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint n;\nint g[128][128];\nint res;\nset<vector<int> > visit;\nvector<int> used;\nvector<int> s;\nvoid dfs()\n{\n    // if (visit.count(used))\n    //     return;\n    // visit.insert(used);\n\n    if (used.size() >= 2)\n    {\n        int score = 0;\n        rep(i, used.size())\n        {\n            int s = ten(9);\n            rep(j, used.size())\n                if (i != j)\n                    chmin(s, g[used[i]][used[j]]);\n            score += s;\n        }\n        chmax(res, score);\n    }\n\n    bool next[111];\n    fill_n(next, n, true);\n    rep(i, used.size()) rep(j, n)\n        next[j] &= g[used[i]][j] != -1;\n    rep(i, n)\n    {\n        if (next[i])\n        {\n            used.pb(i);\n            // sort(all(used));\n            \n            dfs();\n\n            used.pop_back();\n            // used.erase(find(all(used), i));\n        }\n    }\n}\nint main()\n{\n    int m;\n    cin >> n >> m;\n    CL(g, -1);\n    rep(i, m)\n    {\n        int u, v, f;\n        cin >> u >> v >> f;\n        --u, --v;\n        g[u][v] = g[v][u] = f;\n    }\n\n    dfs();\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define inf (1LL << 27)\n\nint N,M;\nvector<vector<long long int>>bridge;\n\nlong long int solve(vector<long long int>D, long long int idx){\n\tlong long int ret = 0;\n\tfor(int i = idx; i < N; i++){\n\t\tauto next = D;\n\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i!=j && D[j] != -1){\n\t\t\t\tif(D[i] == -1)D[i] = bridge[i][j];\n\t\t\t\tD[i] = min(D[i], bridge[i][j]);\n\t\t\t\tD[j] = min(D[j], bridge[i][j]);\n\t\t\t}\n\t\t}\n\t\tlong long int plus = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tlong long int x = D[j];\n\t\t\tlong long int y = next[j];\n\t\t\tif(x == -1)x = 0;\n\t\t\tif(y == -1)y = 0;\n\t\t\tplus += x - y;\n\t\t}\n\t\tif(plus >= 0){\n\t\t\tret = max(ret, solve(D, i + 1));\n\t\t}\n\t\tD = next;\n\t}\n\tlong long int sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(D[i] != -1){\n\t\t\tsum += D[i];\n\t\t}\n\t}\n\treturn max(sum, ret);\n}\n\nint main(){\n\tcin >> N >> M;\n\tbridge = vector<vector<long long int>>(N, vector<long long int>(N));\n\tvector<pair<long long int,long long int>>bridgepair(M);\n\tfor(int i = 0; i < M; i++){\n\t\tlong long int a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tbridge[a][b] = c;\n\t\tbridge[b][a] = c;\n\t\tbridgepair[i]=(make_pair(a,b));\n\t}\n\tlong long int ans=0;\n\tfor(int i = 0; i < M; i++){\n\t\tauto x = vector<long long int>(N, -1);\n\t\tx[bridgepair[i].first]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tx[bridgepair[i].second]=bridge[bridgepair[i].first][bridgepair[i].second];\n\t\tans = max(ans, solve(x, 0));\n\t\tbridge[bridgepair[i].first][bridgepair[i].second] = 0;\n\t\tbridge[bridgepair[i].second][bridgepair[i].first] = 0;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> graph(n,vector<int>(n));\n    rep(i,0,m){\n        int u,v,f;\n        cin >> u >> v >> f;\n        --u;\n        --v;\n        graph[u][v]=graph[v][u]=f;\n    }\n\n    map<pair<int,set<int>>,int> memo;\n    map<pair<int,set<int>>,bool> done;\n    function<int(int,set<int>)> rec=[&](int num,set<int> s){\n        auto p=make_pair(num,s);\n        int &res=memo[p];\n        if(done[p]) return res;\n        done[p]=true;\n        if(num==0){\n            for(int v:s){\n                int tmp=inf;\n                for(int u:s){\n                    if(u==v) continue;\n                    tmp=min(tmp,graph[v][u]);\n                }\n                res+=tmp;\n            }\n            return res;\n        }\n        rep(v,0,n){\n            if(s.find(v)!=s.end()) continue;\n            bool ok=true;\n            for(int u:s){\n                if(graph[v][u]!=0) continue;\n                ok=false;\n                break;\n            }\n            if(!ok) continue;\n            set<int> s_=s;\n            s_.insert(v);\n            res=max(res,rec(num-1,s_));\n        }\n        return res;\n    };\n\n    int ans=0;\n    rep(i,2,inf){\n        if(i*(i-1)/2>m) continue;\n        int tmp=rec(i,set<int>());\n        if(tmp==0) break;\n        ans=max(ans,tmp);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define S second\n#define INF (1e9)\n#define N 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m, d[N][N];\nint used[N], ans=0;\n\nvector<P> idx;\n\nvoid dfs(int x,vector<int> G){\n  \n  if(x>=2){\n\n    int sum=0;\n\n    for(int i=0;i<G.size();i++){\n      \n      if(!used[G[i]]) continue;\n      \n      int mincost=INF;\n      \n      for(int j=0;j<G.size();j++){\n      \n\tif(!used[G[j]]) continue;\n\t\n\tif(G[i]!=G[j])\n\t  mincost=min(mincost,d[G[i]][G[j]]);\n      \n      }\n\n      if(mincost!=INF) sum+=mincost;\n    \n    }\n  \n    ans=max(ans,sum);\n\n  }\n  \n  if(x*(x-1)>m) return ;\n    \n  for(int i=0;i<n;i++){\n\n    if(used[idx[i].S]) continue;\n\n    used[idx[i].S]=1;\n    \n    int mincost=INF;\n\n    vector<int> nG=G;\n\n    nG.push_back(idx[i].S);\n    \n    for(int j=0;j<G.size();j++)\n      \n      if(idx[i].S!=G[j]&&used[G[j]])\n\tmincost=min(mincost,d[idx[i].S][G[j]]);\n    \n    if(!x||(mincost&&mincost!=INF)) dfs(x+1,nG);\n\n    used[idx[i].S]=0;\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n>>m;\n\n  int a, b , f;\n\n  for(int i=0;i<n;i++) idx.push_back(P(0,i));\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>a>>b>>f;\n    \n    d[a-1][b-1]=d[b-1][a-1]=f;\n    \n    idx[a-1].first++;\n    idx[b-1].first++;\n  }\n\n  sort(idx.begin(),idx.end());\n  \n  vector<int> init;\n  \n  dfs(0,init);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint n,m;\nvector<pair<int,int>> g[111];\nint mat[111][111];\nint on[111];\nint List[111],l;\n\nint f(int cur){\n\tif(cur == n){\n\t\tif(l <= 1) return 0;\n\t\tint res = 0;\n\t\trep(i,l){\n\t\t\tint x = INF;\n\t\t\trep(j,l) x = min(x, mat[List[i]][List[j]]);\n\t\t\tres += x;\n\t\t}\n\t\treturn res;\n\t}\n\tint res = f(cur+1);\n\tint ok = 1;\n\trep(i,l)if(!mat[cur][List[i]]){\n\t\tok=0; break;\n\t}\n\tif(ok){\n\t\tList[l++] = cur;\n\t\tres = max(res, f(cur+1));\n\t\tl--;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n>>m;\n\trep(i,n){\n\t\tmat[i][i] = INF;\n\t}\n\trep(i,m){\n\t\tint u,v,F;\n\t\tcin>>u>>v>>F;\n\t\tu--;v--;\n\t\tg[u].pb(mp(v,F));\n\t\tg[v].pb(mp(u,F));\n\t\tmat[u][v] = mat[v][u] = F;\n\t}\n\tl=0;\n\tcout<<f(0)<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <string.h>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int MAX_M = 101;\nconst int MAX_F = 1000000;\n\nint table[MAX_N][MAX_N];\nint status[MAX_M][MAX_N];\nint N, M;\n\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef set<int> SI;\n\nvoid solve(int k);\nULL point(SI& s);\nbool is_finish(SI& s);\n\nULL maxval = 0;\n\nstruct state {\n\tint p;\n\tSI s;\n};\n\nvector<state> cls;\n\nint main() {\n\tint u, v, f;\n\tcls = vector<state>();\n\n\t// read data\n\tcin >> N >> M;\n\tmemset(&table[0][0], 0, sizeof(int) * MAX_N * MAX_N);\n\tmemset(&table[0][0], 0, sizeof(int) * MAX_M * MAX_N);\n\tfor(int m=0; m<M; m++) {\n\t\tcin >> u >> v >> f;\n\t\ttable[u-1][v-1] = f;\n\t\ttable[v-1][u-1] = f;\n\t\tstatus[m][u-1] = 1;\n\t\tstatus[m][v-1] = 1;\n\t}\n\n\t// solve problem\n\tmaxval = 0;\n\tfor(int i=0; i<M; i++) {\n\t\tsolve(i);\n\t}\n\n\t// print answer\n\tcout << maxval << endl;\n}\n\nvoid solve(int k) {\n\tqueue<SI> que;\n\t\n\t// set initial node\n\tSI s = SI();\n\tfor(int i=0; i<N; i++) {\n\t\tif(status[k][i]) s.insert(i);\n\t}\n\tif(s.size() == 0) return;\n\n\tque.push(s);\n\twhile(!que.empty()) {\n\t\tSI cs = que.front();\n\t\tque.pop();\n\n\t\tif(is_finish(cs)) continue;\n\n\t\tULL p = point(cs);\n\t\tif(maxval < p) maxval = p;\n\t\t\n\t\tint s = cs.size();\n\t\tif(s == N) continue;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tbool is_f = true;\n\t\t\tfor(SI::const_iterator jt = cs.begin(); jt != cs.end(); ++jt) {\n\t\t\t\tint u = (*jt);\n\t\t\t\tif(i != u && table[i][u] == 0) {\n\t\t\t\t\tis_f = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(is_f) {\n\t\t\t\tSI ns = SI();\n\t\t\t\tfor(SI::const_iterator it = cs.begin(); it != cs.end(); ++it) ns.insert((*it));\n\t\t\t\tns.insert(i);\n\t\t\t\tque.push(ns);\n\t\t\t}\n\t\t}\n\t}\n}\n\nULL point(SI& s) {\n\tULL val = 0;\n\tfor(SI::const_iterator it=s.begin(); it != s.end(); ++it) {\n\t\tint min_f = MAX_F;\n\t\tfor(SI::const_iterator jt=s.begin(); jt != s.end(); ++jt) {\n\t\t\tif(it == jt) continue;\n\t\t\tint k = (*it);\n\t\t\tint l = (*jt);\n\t\t\tif(min_f > table[k][l]) min_f = table[k][l];\n\t\t}\n\t\tval += (ULL)min_f;\n\t}\n\n\tstate st;\n\tst.p = val;\n\tst.s = s;\n\tcls.push_back(st);\n\n\treturn val;\n}\n\nbool is_finish(SI& s) {\n\tint size = cls.size();\n\tfor(int i=0; i<size; i++) {\n\t\tSI s0 = cls[i].s;\n\t\tif(s.size() != s0.size()) continue;\n\n\t\tSI::const_iterator it = s.begin();\n\t\tSI::const_iterator it0 = s0.begin();\n\t\tbool is_match = true;\n\t\twhile(it != s.end() && it0 != s0.end()) {\n\t\t\tif((*it) != (*it0)) {\n\t\t\t\tis_match = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++it;\n\t\t\t++it0;\n\t\t}\n\t\tif(is_match) return true;\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2306\n  Title:Rabbit Party\n  @kankichi573\n  2015/1/8 WA 21/55\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nstatic int N,M;\nstatic int friend[101][101];\nstatic int max_;\n\nstatic void calc_invite(int inv[],int from)\n{\n  int i,j,f,fr,min_;\n  int inv2[102];\n\n  for(i=f=0;i<=from;i++)\n    {\n      if(inv[i]>0)\n\t{\n\t  f += inv[i];\n#ifdef DEBUG\n\t  printf(\"%d[%d]|\",i,inv[i]);\n#endif\n\t}\n    }\n  max_=max(max_,f);\n\n  if(from>N)\n    return;\n  for(i=from;i<=N;i++)\n    {\n      min_=INT_MAX;\n       for(j=0;j<from;j++)\n\t{\n\t  if(inv[j]>0)\n\t    {\n\t      if((fr=friend[i][j])==0)\n\t\tgoto NEXT;\n\t      else \n\t\t{\n\t\t  min_=min(min_,fr);\n\t\t  if(inv[j]>fr)\n\t\t    {\n\t\t      f-=(inv[i]-fr);\n\t\t      inv[j]=fr;\n\t\t    }\n\t\t}\n\t    }\n\t}\n       \n\n       memcpy(inv2,inv,sizeof(inv2));\n       inv2[i]=min_;\n       calc_invite(inv2,i+1);\n    NEXT: ;\n    }\n}\n\nstatic void solve()\n{\n  int i,j,f;\n  int inv[102];\n\n  max_=0;\n  if(N==1)\n    return;\n  \n  for(i=0;i<=N-1;i++)\n    for(j=i+1;j<=N;j++)\n      {\n\tif((f=friend[i][j])>0)\n\t  {\n\t    memset(inv,0,sizeof(inv));\n\t    inv[i]=f;\n\t    inv[j]=f;\n\t    max_=max(max_,2*f);\n\t    calc_invite(inv,j+1);\n\t  }\n      }\n}\n\nmain()\n{\n  int i,u,v,f;\n  (void)scanf(\"%d %d\",&N,&M);\n    \n  memset(friend,0,sizeof(friend));\n  for(i=0;i<M;i++)\n    {\n      (void)scanf(\"%d %d %d\",&u,&v,&f);\n      friend[u][v]=f;\n      friend[v][u]=f;\n    }\n  solve();\n  printf(\"%d\\n\",max_);\n\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2306\n  Title:Rabbit Party\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nint N,M;\nint friend[101][101];\nint max_;\nvoid calc_invite(char inv[],int from)\n{\n  int i,j,f,fr,min_;\n  char inv2[101];\n\n  for(i=f=0;i<=from;i++)\n    f += inv[i];\n  max_=max(max_,f);\n#ifdef DEBUG\n  for(i=0;i<=N;i++)\n    if(inv[i])\n      printf(\"%d[%d]|\",i,inv[i]);\n  printf(\"from=%d,f=%d\",from,f);\n  printf(\"\\n\");\n#endif\n  if(from>N)\n    return;\n  for(i=from;i<=N;i++)\n    {\n      min_=INT_MAX;\n       for(j=0;j<from;j++)\n\t{\n\t  if(inv[j])\n\t    {\n\t      if((fr=friend[i][j])==0)\n\t\tgoto NEXT;\n\t      else \n\t\t{\n\t\t  min_=min(min_,fr);\n\t\t  if(inv[j]>fr)\n\t\t    {\n\t\t      f-=(inv[i]-fr);\n\t\t      inv[j]=fr;\n\t\t    }\n\t\t}\n\t    }\n\t}\n       \n\n      memcpy(inv2,inv,100);\n      inv2[i]=min_;\n      calc_invite(inv2,i+1);\n    NEXT: ;\n    }\n}\n\nvoid solve()\n{\n  int i,j,f;\n  char inv[101];\n\n  max_=0;\n  if(N==1)\n    return;\n  \n  for(i=0;i<=N-1;i++)\n    for(j=i+1;j<=N;j++)\n      {\n\tif((f=friend[i][j]))\n\t  {\n\t    memset(inv,0,100);\n\t    inv[i]=inv[j]=f;\n\t    max_=max(max_,2*f);\n\t    calc_invite(inv,j+1);\n\t  }\n      }\n}\n\nmain()\n{\n  int i,ret,u,v,f;\n  scanf(\"%d %d\",&N,&M);\n    \n  memset(friend,0,sizeof(friend));\n  for(i=0;i<M;i++)\n    {\n      scanf(\"%d %d %d\",&u,&v,&f);\n      friend[u][v]=friend[v][u]=f;\n    }\n  solve();\n  printf(\"%d\\n\",max_);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n\nstruct data{int v,next;} a[400];\nint vis[110],b[110][110],Q[110],H[110],cnt,N,M,x,y,d,ans,i,j;\n\nint add(int u,int v){\n    a[++cnt].v=v; a[cnt].next=H[u]; H[u]=cnt;\n}\n\nint calc(int c){\n    int i,j,d,tt,s=0;\n    for (i=1;i<=c;i++){\n        d=100000000;\n        for (j=1;j<=c;j++)\n            if (i!=j && b[Q[i]][Q[j]]<d) d=b[Q[i]][Q[j]];\n        s+=d;\n    }\n    if (s>ans) ans=s;\n}\n\nint dfs(int c,int u){\n    int i,bo,tt,v;\n    if (c>1) calc(c);\n    for (tt=H[u];tt;tt=a[tt].next){\n        v=a[tt].v;\n        if (vis[v]) continue;\n        bo=1;\n        for (i=1;i<=c;i++)\n            if (!b[v][Q[i]]){\n                bo=0; break;\n            }\n        if (bo){\n            vis[v]=1; Q[c+1]=v; dfs(c+1,v); vis[v]=0;\n        }\n    }\n}\n\nint main()\n{\n    while (~scanf(\"%d%d\",&N,&M)){\n        memset(b,0,sizeof(b));\n        memset(H,0,sizeof(H));\n        cnt=ans=0; \n        for (i=1;i<=M;i++){\n            scanf(\"%d%d%d\",&x,&y,&d);\n            b[x][y]=b[y][x]=d; \n            add(x,y); add(y,x);\n        }\n        for (i=1;i<=N;i++){\n            Q[1]=i;  vis[i]=1;\n            dfs(1,i);  vis[i]=0;\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2306 Rabbit Party\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint n;\nint rel[102][102];\nint hi[102];\nint id[102];\nint ans;\n\nvoid calc(int v, int d)\n{\n\tint i, j, t, c, max, sum;\n\n\tid[d] = v;\n\tmax = 14, sum = 0;\n\tfor (i = 0; i <= d; i++) {\n\t\tif (hi[id[i]] < max) max = hi[id[i]];\n\t\tif (!d) break;\n\t\tc = 1000000;\n\t\tfor (j = 0; j <= d; j++) if (i != j) {\n\t\t\tif ((t=rel[id[i]][id[j]]) < c) c = t;\n\t\t}\n\t\tsum += c;\n\t}\n\tif (d && sum > ans) ans = sum;\n\tif (d == max) return;\n\tfor (i = v+1; i < n; i++) {\n\t\tif (hi[i] <= d) continue;\n\t\tfor (j = 0; ; j++) {\n\t\t\tif (j == d) { calc(i, d+1); break; }\n\t\t\tif (!rel[i][id[j]]) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m, i, u, v;\n\n\tn = in(), m = in();\n\twhile (m--) {\n\t\tu = in()-1, v = in()-1;\n\t\thi[u]++, hi[v]++;\n\t\trel[u][v] = rel[v][u] = in();\n\t}\n\tans = 0;\n\tfor (i = 0; i < n; i++) calc(i, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2306\n  Title:Rabbit Party\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nint N,M;\nint friend[101][101];\nint max_;\nvoid calc_invite(char inv[],int from)\n{\n  int i,j,f,fr,min_;\n  char inv2[101];\n\n  for(i=f=0;i<=from;i++)\n    f += inv[i];\n  max_=max(max_,f);\n#ifdef DEBUG\n  for(i=0;i<=N;i++)\n    if(inv[i])\n      printf(\"%d[%d]|\",i,inv[i]);\n  printf(\"from=%d,f=%d\",from,f);\n  printf(\"\\n\");\n#endif\n  if(from>N)\n    return;\n  for(i=from;i<=N;i++)\n    {\n      min_=INT_MAX;\n       for(j=0;j<from;j++)\n\t{\n\t  if(inv[j])\n\t    {\n\t      if((fr=friend[i][j])==0)\n\t\tgoto NEXT;\n\t      else \n\t\t{\n\t\t  min_=min(min_,fr);\n\t\t  if(inv[j]>fr)\n\t\t    {\n\t\t      f-=(inv[i]-fr);\n\t\t      inv[j]=fr;\n\t\t    }\n\t\t}\n\t    }\n\t}\n       \n\n       memcpy(inv2,inv,sizeof(inv2));\n       inv2[i]=min_;\n       calc_invite(inv2,i+1);\n    NEXT: ;\n    }\n}\n\nvoid solve()\n{\n  int i,j,f;\n  char inv[101];\n\n  max_=0;\n  if(N==1)\n    return;\n  \n  for(i=0;i<=N-1;i++)\n    for(j=i+1;j<=N;j++)\n      {\n\tif((f=friend[i][j]))\n\t  {\n\t    memset(inv,0,sizeof(inv));\n\t    inv[i]=inv[j]=f;\n\t    max_=max(max_,2*f);\n\t    calc_invite(inv,j+1);\n\t  }\n      }\n}\n\nmain()\n{\n  int i,ret,u,v,f;\n  scanf(\"%d %d\",&N,&M);\n    \n  memset(friend,0,sizeof(friend));\n  for(i=0;i<M;i++)\n    {\n      scanf(\"%d %d %d\",&u,&v,&f);\n      friend[u][v]=friend[v][u]=f;\n    }\n  solve();\n  printf(\"%d\\n\",max_);\n\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2306\n  Title:Rabbit Party\n  @kankichi573\n  2015/1/8 WA 21/55\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nint N,M;\nint friend[101][101];\nint max_;\nvoid calc_invite(char inv[],int from)\n{\n  int i,j,f,fr,min_;\n  char inv2[101];\n\n  for(i=f=0;i<=from;i++)\n    f += inv[i];\n  max_=max(max_,f);\n#ifdef DEBUG\n  for(i=0;i<=N;i++)\n    if(inv[i])\n      printf(\"%d[%d]|\",i,inv[i]);\n  printf(\"from=%d,f=%d\",from,f);\n  printf(\"\\n\");\n#endif\n  if(from>N)\n    return;\n  for(i=from;i<=N;i++)\n    {\n      min_=INT_MAX;\n       for(j=0;j<from;j++)\n\t{\n\t  if(inv[j])\n\t    {\n\t      if((fr=friend[i][j])==0)\n\t\tgoto NEXT;\n\t      else \n\t\t{\n\t\t  min_=min(min_,fr);\n\t\t  if(inv[j]>fr)\n\t\t    {\n\t\t      f-=(inv[i]-fr);\n\t\t      inv[j]=fr;\n\t\t    }\n\t\t}\n\t    }\n\t}\n       \n\n       memcpy(inv2,inv,sizeof(inv2));\n       inv2[i]=min_;\n       calc_invite(inv2,i+1);\n    NEXT: ;\n    }\n}\n\nvoid solve()\n{\n  int i,j,f;\n  char inv[101];\n\n  max_=0;\n  if(N==1)\n    return;\n  \n  for(i=0;i<=N-1;i++)\n    for(j=i+1;j<=N;j++)\n      {\n\tif((f=friend[i][j]))\n\t  {\n\t    memset(inv,0,sizeof(inv));\n\t    inv[i]=inv[j]=f;\n\t    max_=max(max_,2*f);\n\t    calc_invite(inv,j+1);\n\t  }\n      }\n}\n\nmain()\n{\n  int i,ret,u,v,f;\n  scanf(\"%d %d\",&N,&M);\n    \n  memset(friend,0,sizeof(friend));\n  for(i=0;i<M;i++)\n    {\n      scanf(\"%d %d %d\",&u,&v,&f);\n      friend[u][v]=friend[v][u]=f;\n    }\n  solve();\n  printf(\"%d\\n\",max_);\n\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();// the number of rabbits\n\t\tint m = sc.nextInt();//\n\t\tlong[][] g = new long[n][n];\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tlong f = sc.nextLong();// the friendliness between u and v.\n\t\t\tg[u][v] = f;\n\t\t\tg[v][u] = f;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tArrayList<Integer> used=new ArrayList<>();\n\t\t\tused.add(i);\n\t\t\tdfs(used,g);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long ans = 0;\n\n\tvoid dfs(ArrayList<Integer> used, long[][] g) {\n\t\tint n = g.length;\n\t\tif (used.size() > 1) {\n\t\t\tlong tmp = 0;\n\t\t\tfor (int v : used) {\n\t\t\t\tlong min = 1L << 60;\n\t\t\t\tfor (int u : used) {\n\t\t\t\t\tif (u == v)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmin=Math.min(min, g[u][v]);\n\t\t\t\t}\n\t\t\t\ttmp+=min;\n\t\t\t}\n\t\t\tans=Math.min(tmp, ans);\n\t\t}\n\t\tfor (int i = used.get(used.size() - 1); i < n; i++) {\n\t\t\tint v = i;\n\t\t\tboolean f = true;\n\t\t\tfor (int u : used) {\n\t\t\t\tif (g[u][v] == 0) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tused.add(v);\n\t\t\t\tdfs(used, g);\n\t\t\t\tused.remove(used.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tlong friendliness;\n\n\t\tEdge(int from, int to, long friendliness) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.friendliness = friendliness;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();// the number of rabbits\n\t\tint m = sc.nextInt();//\n\t\tlong[][] g = new long[n][n];\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tlong f = sc.nextLong();// the friendliness between u and v.\n\t\t\tg[u][v] = f;\n\t\t\tg[v][u] = f;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tArrayList<Integer> used=new ArrayList<>();\n\t\t\tused.add(i);\n\t\t\tdfs(used,g);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long ans = 0;\n\n\tvoid dfs(ArrayList<Integer> used, long[][] g) {\n\t\tint n = g.length;\n\t\tif (used.size() > 1) {\n\t\t\tlong tmp = 0;\n\t\t\tfor (int v : used) {\n\t\t\t\tlong min = 1L << 60;\n\t\t\t\tfor (int u : used) {\n\t\t\t\t\tif (u == v)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmin=Math.min(min, g[u][v]);\n\t\t\t\t}\n\t\t\t\ttmp+=min;\n\t\t\t}\n\t\t\tans=Math.max(tmp, ans);\n\t\t}\n\t\tfor (int i = used.get(used.size() - 1); i < n; i++) {\n\t\t\tint v = i;\n\t\t\tboolean f = true;\n\t\t\tfor (int u : used) {\n\t\t\t\tif (g[u][v] == 0) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tused.add(v);\n\t\t\t\tdfs(used, g);\n\t\t\t\tused.remove(used.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tlong friendliness;\n\n\t\tEdge(int from, int to, long friendliness) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.friendliness = friendliness;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic int[][] g;\n\tstatic int ans;\n\tstatic int[] min = new int[20];\n\n\tpublic static void main(String[] arg) {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tg = new int[N][N];\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint f = sc.nextInt();\n\t\t\tg[u][v] = g[v][u] = f;\n\t\t}\n\t\tint[] r = new int[20];\n\t\tdfs(0, r, 0);\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic void dfs(int c, int[] r, int d) {\n\t\tif (d >= 2) {\n\t\t\tfor (int i = 0; i < d; ++i) {\n\t\t\t\tmin[i] = 1 << 30;\n\t\t\t}\n\t\t\tfor (int i = 0; i < d; ++i) {\n\t\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\t\tmin[i] = Math.min(min[i], g[r[i]][r[j]]);\n\t\t\t\t\tmin[j] = Math.min(min[j], g[r[i]][r[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < d; ++i) {\n\t\t\t\tsum += min[i];\n\t\t\t}\n\t\t\tans = Math.max(ans, sum);\n\t\t}\n\t\tfor (int i = c; i < N; ++i) {\n\t\t\tboolean ok = true;\n\t\t\tfor (int j = 0; j < d; ++j) {\n\t\t\t\tif (g[i][r[j]] == 0) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) continue;\n\t\t\tr[d] = i;\n\t\t\tdfs(i + 1, r, d + 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint c[109][109], n, m, p, q, r, maxn;\n\nvoid dfs(vector<int>vec) {\n\tif (vec.size() >= 2) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tint minx = 1000009;\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tminx = min(minx, c[vec[i]][vec[j]]);\n\t\t\t\tif (minx == 0) return;\n\t\t\t}\n\t\t\tsum += minx;\n\t\t}\n\t\tmaxn = max(maxn, sum);\n\t}\n\tint T = 1; if (vec.size() >= 1) T = vec[vec.size() - 1] + 1;\n\tfor (int i = T; i <= n; i++) {\n\t\tvector<int>F = vec; F.push_back(i);\n\t\tdfs(F);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> p >> q >> r;\n\t\tc[p][q] = r; c[q][p] = r;\n\t}\n\tdfs(vector<int>{});\n\tcout << maxn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic static class combi\n{\n    public static IEnumerable<IEnumerable<T>> Comb<T>(this IEnumerable<T> items, int r)\n    {\n        if (r == 0)\n        {\n            yield return Enumerable.Empty<T>();\n        }\n        else\n        {\n            var i = 1;\n            foreach (var x in items)\n            {\n                var xs = items.Skip(i);\n                foreach (var c in Comb(xs, r - 1))\n                    yield return c.Before(x);\n                i++;\n            }\n        }\n    }\n    public static IEnumerable<T> Before<T>(this IEnumerable<T> items, T first)\n    {\n        yield return first;\n        foreach (var i in items)\n            yield return i;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var m = int.Parse(line[1]);\n        var fam = new int[n + 1, n + 1];\n        var te = new List<int>();\n        for (int i = 0; i < m; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var u = int.Parse(line2[0]);\n            var u2 = int.Parse(line2[1]);\n            var f = int.Parse(line2[2]);\n            fam[u, u2] = f; fam[u2, u] = f;\n            te.Add(u); te.Add(u2);\n        }\n        var mem = te.Distinct().ToList();\n        Console.WriteLine(getV(fam, mem));\n    }\n    public static int getV(int[,] fam, List<int> mem)\n    {\n        var ret = 0;\n        for (int i = 2; i <= mem.Count(); i++)\n        {\n            var x1 = mem.Comb(i);\n            var x2 = x1.Select(x => x.ToArray()).ToArray();\n            foreach (var x in x2)\n            {\n                var te = getv2(fam, x);\n                ret = Math.Max(ret, te);\n            }\n        }\n        return ret;\n    }\n    public static int getv2(int[,] fam, int[] x)\n    {\n        var xL = x.Length;\n        var mintotal = 0;\n        for (int i = 0; i < xL; i++)\n        {\n            var minv = 999999999;\n            for (int j = 0; j < xL; j++)\n                if (fam[x[i], x[j]] > 0) minv = Math.Min(minv, fam[x[i], x[j]]);\n            if (minv != 999999999) mintotal += minv;\n        }\n        return mintotal;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing P = System.Numerics.Complex;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var g = Enumerate(n, x => new int[n]);\n            for (int i = 0; i < n; i++)\n                g[i][i] = 1000000000;\n            var G = Enumerate(n, x => new List<int>());\n            for (int i = 0; i < m; i++)\n            {\n                var u = ri - 1;\n                var v = ri - 1;\n                var w = ri;\n                g[u][v] = g[v][u] = w;\n                G[u].Add(v); G[v].Add(u);\n            }\n            var ans = 0;\n            Action<List<int>, bool[]> dfs = null;\n            dfs = (s, contain) =>\n            {\n                Debug.WriteLine(s.AsJoinedString());\n                if (s.Count > 1)\n                    ans = Max(ans,\n                        s.Sum(x => s.Min(y => g[x][y])));\n                for (int i = s[s.Count - 1] + 1; i < n; i++)\n                    if (!contain[i] && G[i].Count(x => contain[x]) == s.Count)\n                    {\n                        s.Add(i); contain[i] = true;\n                        dfs(s, contain);\n                        s.RemoveAt(s.Count - 1); contain[i] = false;\n                    }\n            };\n            for (int i = 0; i < n; i++)\n            {\n                var s = new List<int>() { i };\n                var s2 = new bool[n]; s2[i] = true;\n                dfs(s, s2);\n            }\n            Console.WriteLine(ans);\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nn, m = gets.split.map &:to_i\n\nfriend = (1..n).map{ [] }\ncost = {}\n\n(1..m).each{\n\ti, j, f = gets.split.map &:to_i\n\ti -= 1\n\tj -= 1\n\tfriend[i] << j\n\tfriend[j] << i\n\tcost[[i,j]] = f\n\tcost[[j,i]] = f\n}\n\nrabbits = (0..n-1).to_a\n\nbest = 0\n\nuntil rabbits.empty? \n\ti = rabbits.min_by{|i| friend[i].size}\n\tclique = [[]]\n\n\tf = friend[i]\n\t(1..(1<<friend[i].size)-1).each{|x|\n\t\ty = x & (x - 1)\n\t\tk = Math.log2(x ^ (x-1)).to_i\n\t\tif c = clique[y]\n\t\t\tif c.all?{|j| j == f[k] || friend[j].include?(f[k])}\n\t\t\t\tclique[x] = c + [f[k]]\n\t\t\telse\n\t\t\t\tclique[x] = nil\n\t\t\tend\n\t\telse\n\t\t\tclique[x] = nil\n\t\tend\n\t}\n\n\tclique.compact!\n\tclique.map!{|c| c + [i]}\n\tclique.select!{|c| c.size > 1}\n\n\tclique.each{|c|\n\t\tx = c.map{|i|\n\t\t\t(c - [i]).map{|j|\n\t\t\t\tcost[[i,j]]\t\n\t\t\t}.min\n\t\t}.inject(:+)\n\t\tbest = x if x > best\n\t}\n\n\trabbits.delete(i)\n\tfriend.map{|f| f.delete(i)}\nend\n\np best"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nn, m = gets.split.map &:to_i\n\nfriend = (1..n).map{ [] }\ncost = {}\n\n(1..m).each{\n\ti, j, f = gets.split.map &:to_i\n\ti -= 1\n\tj -= 1\n\tfriend[i] << j\n\tfriend[j] << i\n\tcost[[i,j]] = f\n\tcost[[j,i]] = f\n}\n\nrabbits = (0..n-1).to_a\n\nbest = 0\n\nuntil rabbits.empty? \n\ti = rabbits.min_by{|i| friend[i].size}\n\tclique = [[]]\n\n\tf = friend[i]\n\t(1..(1<<friend[i].size)-1).each{|x|\n\t\ty = x & (x - 1)\n\t\tk = Math.log2(x ^ (x-1)).to_i\n\t\tif c = clique[y]\n\t\t\tif c.all?{|j| j == f[k] || friend[j].include?(f[k])}\n\t\t\t\tclique[x] = c + [f[k]]\n\t\t\telse\n\t\t\t\tclique[x] = nil\n\t\t\tend\n\t\telse\n\t\t\tclique[x] = nil\n\t\tend\n\t}\n\n\tclique.map!{|c| c + [i]}\n\tclique.select!{|c| c.size > 1}\n\n\tclique.compact.each{|c|\n\t\tx = c.map{|i|\n\t\t\t(c - [i]).map{|j|\n\t\t\t\tcost[[i,j]]\t\n\t\t\t}.min\n\t\t}.inject(:+)\n\t\tbest = x if x > best\n\t}\n\n\trabbits.delete(i)\n\tfriend.map{|f| f.delete(i)}\nend\n\np best"
  },
  {
    "language": "Python",
    "code": "from itertools import product\ndef main():\n    INF = 10**9\n    N, M = map(int, input().split())\n    E = [[INF]*N for i in range(N)]\n    G = [set() for i in range(N)]\n    D = [0]*N\n    for i in range(M):\n        u, v, f = map(int, input().split()); u -= 1; v -= 1\n        E[u][v] = E[v][u] = f\n        G[u].add(v)\n        G[v].add(u)\n        D[u] += 1; D[v] += 1\n\n    def calc(vs):\n        if len(vs) == 1:\n            return 0\n        res = 0\n        for ps in product([0, 1], repeat=len(vs)):\n            R = [v for p, v in zip(ps, vs) if p]\n            if len(R) == 1:\n                continue\n            rs = 0\n            for v in R:\n                r = INF\n                for w in R:\n                    if v == w:\n                        continue\n                    r = min(r, E[v][w])\n                rs += r\n            res = max(res, rs)\n        return res\n\n    def dfs(V, P, X):\n        if not P and not X:\n            return calc(V)\n        u = next(iter(X or P))\n        r = 0\n        for v in P - G[u]:\n            r = max(r, dfs(V | {v}, P & G[v], X & G[v]))\n            P.remove(v)\n            X.add(v)\n        return r\n\n    *I, = range(N)\n    I.sort(key = D.__getitem__, reverse=1)\n\n    ans = 0\n    P = set(range(N))\n    X = set()\n    for v in I:\n        ans = max(ans,  dfs({v}, P & G[v], X & G[v]))\n        P.remove(v)\n        X.add(v)\n    print(ans)\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,m = LI()\n    e = []\n    f = [[0]*n for i in range(n)]\n    v = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = LI()\n        a -= 1\n        b -= 1\n        e.append([a,b,c])\n        f[a][b] = c\n        f[b][a] = c\n        v[a].append(b)\n        v[b].append(a)\n    ans = 0\n    S = []\n    for p in range(n):\n        K = [{p}]\n        for q in v[p]:\n            K += [s|{q} for s in K]\n        S += K\n    for s in S:\n        for x in s:\n            for y in s:\n                if x == y:\n                    continue\n                if f[x][y] > 0:\n                    continue\n                else:\n                    break\n            else:\n                continue\n            break\n        else:\n            m = [float(\"inf\")]*n\n            for a in s:\n                for b in s:\n                    if a == b:\n                        continue\n                    if f[a][b] < m[a]:\n                        m[a] = f[a][b]\n                    if f[a][b] < m[b]:\n                        m[b] = f[a][b]\n            k = 0\n            for i in m:\n                if i != float(\"inf\"):\n                    k += i\n            if ans < k:\n                ans = k\n\n\n    print(ans)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        e = [[0]*n for _ in range(n)]\n        cs = []\n        for _ in range(m):\n            a,b,c = LI_()\n            c += 1\n            e[a][b] = c\n            e[b][a] = c\n            cs.append([a,b])\n\n        r = 0\n        while cs:\n            ns = []\n            for a in cs:\n                t = 0\n                for i in a:\n                    m = inf\n                    for j in a:\n                        if i == j:\n                            continue\n                        if m > e[i][j]:\n                            m = e[i][j]\n                    t += m\n                if r < t:\n                    r = t\n                for i in range(a[-1]+1,n):\n                    f = True\n                    for j in a:\n                        if e[i][j] < 1:\n                            f = False\n                            break\n                    if f:\n                        ns.append(a + [i])\n            cs = ns\n\n        return r\n\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n        # print('rr', rr[-1])\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]