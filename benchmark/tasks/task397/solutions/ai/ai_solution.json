[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_RABBITS 100\n#define MAX_EDGES 10000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nEdge edges[MAX_EDGES];\nint parent[MAX_RABBITS];\nint rank[MAX_RABBITS];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        if (rank[u] < rank[v]) {\n            parent[u] = v;\n        } else {\n            parent[v] = u;\n            if (rank[u] == rank[v]) {\n                rank[u]++;\n            }\n        }\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeB->w - edgeA->w;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    qsort(edges, m, sizeof(Edge), compare);\n\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int max_satisfaction = INT_MAX;\n\n    for (int i = 0; i < m; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n\n        if (find(u) != find(v)) {\n            union_sets(u, v);\n            if (w < max_satisfaction) {\n                max_satisfaction = w;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_satisfaction);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint findMaxSatisfaction(int n, vector<vector<int>>& edges) {\n    if (n == 0) return 0;\n    if (edges.empty()) return 0;\n    \n    sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[2] > b[2];\n    });\n    \n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n    \n    auto find = [&](int u) {\n        while (parent[u] != u) {\n            parent[u] = parent[parent[u]];\n            u = parent[u];\n        }\n        return u;\n    };\n    \n    int res = 0;\n    for (auto& e : edges) {\n        int u = e[0], v = e[1], w = e[2];\n        int pu = find(u), pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n            res += w;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> edges(m, vector<int>(3));\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i][0] >> edges[i][1] >> edges[i][2];\n    }\n    cout << findMaxSatisfaction(n, edges) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RabbitParty {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[][] friendliness = new int[N][N];\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            int c = scanner.nextInt();\n            friendliness[a][b] = c;\n            friendliness[b][a] = c;\n        }\n\n        int maxSatisfaction = 0;\n        for (int mask = 1; mask < (1 << N); mask++) {\n            List<Integer> group = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    group.add(i);\n                }\n            }\n            int minFriendliness = Integer.MAX_VALUE;\n            boolean valid = true;\n            for (int i = 0; i < group.size(); i++) {\n                for (int j = i + 1; j < group.size(); j++) {\n                    int a = group.get(i);\n                    int b = group.get(j);\n                    if (friendliness[a][b] == 0) {\n                        valid = false;\n                        break;\n                    }\n                    minFriendliness = Math.min(minFriendliness, friendliness[a][b]);\n                }\n                if (!valid) {\n                    break;\n                }\n            }\n            if (valid && !group.isEmpty()) {\n                int satisfaction = minFriendliness * group.size();\n                maxSatisfaction = Math.max(maxSatisfaction, satisfaction);\n            }\n        }\n        System.out.println(maxSatisfaction);\n    }\n}",
    "timestamp": "2025-08-05 21:22:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int maxSatisfaction(int[] satisfaction) {\n        Arrays.sort(satisfaction);\n        int n = satisfaction.length;\n        int totalSatisfaction = 0;\n        int suffixSum = 0;\n        \n        for (int i = n - 1; i >= 0 && suffixSum + satisfaction[i] > 0; i--) {\n            suffixSum += satisfaction[i];\n            totalSatisfaction += suffixSum;\n        }\n        \n        return totalSatisfaction;\n    }\n}",
    "timestamp": "2025-08-05 21:22:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_RABBITS 1000\n\ntypedef struct {\n    int friendliness[MAX_RABBITS];\n    int invited;\n} Rabbit;\n\nint max_satisfaction(Rabbit rabbits[], int n, int friendships[][2], int m) {\n    int max_score = 0;\n    \n    for (int mask = 0; mask < (1 << n); mask++) {\n        int current_score = 0;\n        int valid_party = 1;\n        \n        memset(rabbits, 0, n * sizeof(Rabbit));\n        \n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                rabbits[i].invited = 1;\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a = friendships[i][0];\n            int b = friendships[i][1];\n            int friendship = friendships[i][2];\n            \n            if (rabbits[a].invited && rabbits[b].invited) {\n                rabbits[a].friendliness[b] = friendship;\n                rabbits[b].friendliness[a] = friendship;\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (rabbits[i].invited) {\n                int min_friendliness = INT_MAX;\n                \n                for (int j = 0; j < n; j++) {\n                    if (i != j && rabbits[j].invited) {\n                        min_friendliness = (rabbits[i].friendliness[j] < min_friendliness) ? \n                                            rabbits[i].friendliness[j] : min_friendliness;\n                    }\n                }\n                \n                if (min_friendliness == INT_MAX) {\n                    min_friendliness = 0;\n                }\n                \n                current_score += min_friendliness;\n            }\n        }\n        \n        max_score = (current_score > max_score) ? current_score : max_score;\n    }\n    \n    return max_score;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    Rabbit rabbits[MAX_RABBITS];\n    int friendships[MAX_RABBITS][3];\n    \n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &friendships[i][0], &friendships[i][1], &friendships[i][2]);\n    }\n    \n    int result = max_satisfaction(rabbits, n, friendships, m);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxTotalSatisfaction(vector<vector<int>>& friendships, int n) {\n        vector<vector<int>> graph(n + 1);\n        vector<int> friendliness(n + 1, 0);\n        \n        for (auto& friendship : friendships) {\n            int a = friendship[0], b = friendship[1], f = friendship[2];\n            graph[a].push_back(b);\n            graph[b].push_back(a);\n            friendliness[a] = max(friendliness[a], f);\n            friendliness[b] = max(friendliness[b], f);\n        }\n        \n        vector<bool> invited(n + 1, false);\n        return dfs(graph, friendliness, invited, 1, n);\n    }\n    \nprivate:\n    int dfs(vector<vector<int>>& graph, vector<int>& friendliness, vector<bool>& invited, int curr, int n) {\n        if (curr > n) {\n            int totalSatisfaction = 0;\n            for (int i = 1; i <= n; i++) {\n                if (invited[i]) {\n                    int minFriendliness = INT_MAX;\n                    for (int friend_id : graph[i]) {\n                        if (invited[friend_id]) {\n                            minFriendliness = min(minFriendliness, friendliness[friend_id]);\n                        }\n                    }\n                    totalSatisfaction += (minFriendliness == INT_MAX ? friendliness[i] : minFriendliness);\n                }\n            }\n            return totalSatisfaction;\n        }\n        \n        int skipSatisfaction = dfs(graph, friendliness, invited, curr + 1, n);\n        \n        invited[curr] = true;\n        int inviteSatisfaction = dfs(graph, friendliness, invited, curr + 1, n);\n        invited[curr] = false;\n        \n        return max(skipSatisfaction, inviteSatisfaction);\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<int>> friendships = {{1, 2, 5}, {2, 3, 3}, {3, 4, 2}, {4, 1, 4}};\n    int n = 4;\n    \n    int maxSatisfaction = solution.maxTotalSatisfaction(friendships, n);\n    cout << \"Maximum Satisfaction: \" << maxSatisfaction << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nimport sys\n\ndef maximal_satisfaction(n, m, friendships):\n    adj = [[0] * n for _ in range(n)]\n    \n    for a, b, f in friendships:\n        adj[a][b] = f\n        adj[b][a] = f\n\n    max_satisfaction = 0\n\n    for r in range(1, n + 1):\n        for group in combinations(range(n), r):\n            min_friendliness = sys.maxsize\n            valid_group = True\n            \n            for i in range(r):\n                for j in range(i + 1, r):\n                    if adj[group[i]][group[j]] == 0:\n                        valid_group = False\n                        break\n                    min_friendliness = min(min_friendliness, adj[group[i]][group[j]])\n                \n                if not valid_group:\n                    break\n            \n            if valid_group:\n                max_satisfaction = max(max_satisfaction, min_friendliness * r)\n\n    return max_satisfaction\n\n# Example usage:\nn = 5  # number of rabbits\nm = 6  # number of friendships\nfriendships = [\n    (0, 1, 5),\n    (0, 2, 3),\n    (1, 2, 2),\n    (1, 3, 7),\n    (2, 4, 4),\n    (3, 4, 1)\n]\n\nprint(maximal_satisfaction(n, m, friendships))  # Output should be the max possible satisfaction score",
    "timestamp": "2025-08-13 06:14:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RabbitParty {\n    static class Edge {\n        int to, friendliness;\n\n        Edge(int to, int friendliness) {\n            this.to = to;\n            this.friendliness = friendliness;\n        }\n    }\n\n    private List<List<Edge>> graph;\n    private int numRabbits;\n    private boolean[] visited;\n    private int maxSatisfaction;\n\n    public RabbitParty(int numRabbits, int[][] friendships) {\n        this.numRabbits = numRabbits;\n        graph = new ArrayList<>();\n        for (int i = 0; i < numRabbits; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] friendship : friendships) {\n            int from = friendship[0];\n            int to = friendship[1];\n            int friendliness = friendship[2];\n            graph.get(from).add(new Edge(to, friendliness));\n            graph.get(to).add(new Edge(from, friendliness));\n        }\n        visited = new boolean[numRabbits];\n    }\n\n    private int calculateFriendlinessScore(int rabbit, int minFriendliness) {\n        visited[rabbit] = true;\n        int localFriendliness = minFriendliness;\n        for (Edge edge : graph.get(rabbit)) {\n            if (!visited[edge.to]) {\n                localFriendliness = Math.min(localFriendliness,\n                        calculateFriendlinessScore(edge.to, Math.min(minFriendliness, edge.friendliness)));\n            }\n        }\n        visited[rabbit] = false;\n        return localFriendliness;\n    }\n\n    public int getMaxSatisfaction() {\n        for (int i = 0; i < numRabbits; i++) {\n            Arrays.fill(visited, false);\n            maxSatisfaction = Math.max(maxSatisfaction, calculateFriendlinessScore(i, Integer.MAX_VALUE));\n        }\n        return maxSatisfaction;\n    }\n\n    public static void main(String[] args) {\n        int numRabbits = 5;\n        int[][] friendships = {\n            {0, 1, 4},\n            {1, 2, 3},\n            {2, 3, 2},\n            {3, 4, 5},\n            {0, 2, 1}\n        };\n\n        RabbitParty rabbitParty = new RabbitParty(numRabbits, friendships);\n        System.out.println(rabbitParty.getMaxSatisfaction());\n    }\n}",
    "timestamp": "2025-08-13 06:14:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_RABBITS 100\n\ntypedef struct {\n    int u, v, friendliness;\n} Friendship;\n\nint max_satisfaction_score(int n, int m, Friendship friendships[]) {\n    int satisfaction[MAX_RABBITS] = {0};\n    int included[MAX_RABBITS] = {0};\n    int max_satisfaction = 0;\n\n    for (int i = 0; i < n; i++) {\n        satisfaction[i] = INT_MIN;\n    }\n\n    for (int i = 0; i < m; i++) {\n        satisfaction[friendships[i].u] = (friendships[i].friendliness > satisfaction[friendships[i].u]) ?\n                                         friendships[i].friendliness : satisfaction[friendships[i].u];\n        satisfaction[friendships[i].v] = (friendships[i].friendliness > satisfaction[friendships[i].v]) ?\n                                         friendships[i].friendliness : satisfaction[friendships[i].v];\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (satisfaction[i] != INT_MIN) {\n            max_satisfaction += satisfaction[i];\n            included[i] = 1;\n        }\n    }\n\n    return max_satisfaction;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Friendship friendships[MAX_RABBITS];\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &friendships[i].u, &friendships[i].v, &friendships[i].friendliness);\n    }\n\n    int max_satisfaction = max_satisfaction_score(n, m, friendships);\n    printf(\"%d\\n\", max_satisfaction);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:14:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_party_satisfaction(n, friendships):\n    # Create adjacency matrix to represent friendships\n    graph = [[0] * n for _ in range(n)]\n    for u, v, friendliness in friendships:\n        graph[u-1][v-1] = friendliness\n        graph[v-1][u-1] = friendliness\n    \n    # Try all possible party combinations\n    max_satisfaction = 0\n    for mask in range(1, 1 << n):\n        # Check current party configuration\n        current_satisfaction = float('inf')\n        valid_party = True\n        \n        # Check friendliness for each guest pair\n        for i in range(n):\n            if mask & (1 << i):\n                min_friendliness = float('inf')\n                for j in range(n):\n                    if i != j and mask & (1 << j):\n                        min_friendliness = min(min_friendliness, graph[i][j])\n                \n                # If no connection, skip this configuration\n                if min_friendliness == 0 and graph[i][j] == 0:\n                    valid_party = False\n                    break\n                \n                # Update satisfaction for this guest\n                current_satisfaction = min(current_satisfaction, \n                                           min_friendliness if min_friendliness != float('inf') else 0)\n        \n        # Update max satisfaction if valid party\n        if valid_party:\n            max_satisfaction = max(max_satisfaction, current_satisfaction)\n    \n    return max_satisfaction",
    "timestamp": "2025-08-13 06:14:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    \n    graph = defaultdict(list)\n    for _ in range(M):\n        a = int(input[ptr]) - 1\n        ptr += 1\n        b = int(input[ptr]) - 1\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    \n    max_satisfaction = 0\n    \n    def backtrack(current, selected, min_friendliness):\n        nonlocal max_satisfaction\n        if current == N:\n            if len(selected) > 0:\n                max_satisfaction = max(max_satisfaction, min_friendliness)\n            return\n        \n        # Option 1: Do not select current rabbit\n        backtrack(current + 1, selected, min_friendliness)\n        \n        # Option 2: Select current rabbit\n        new_min = min_friendliness\n        new_selected = selected.copy()\n        for rabbit in selected:\n            found = False\n            for (neighbor, cost) in graph[current]:\n                if neighbor == rabbit:\n                    new_min = min(new_min, cost) if len(selected) > 0 else cost\n                    found = True\n                    break\n            if not found:\n                return  # No edge to at least one selected rabbit\n        \n        new_selected.add(current)\n        if len(new_selected) == 1:\n            new_min = float('inf')\n            backtrack(current + 1, new_selected, new_min)\n        else:\n            backtrack(current + 1, new_selected, new_min)\n    \n    backtrack(0, set(), float('inf'))\n    print(max_satisfaction if max_satisfaction != 0 else 0)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 06:14:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\n// Structure to represent an edge between two nodes with a weight\nstruct Edge {\n    int u, v, weight;\n};\n\n// Function to find the subset of an element i\nint find(std::vector<int>& parent, int i) {\n    if (parent[i] == i) return i;\n    return parent[i] = find(parent, parent[i]);\n}\n\n// Function to perform the union of two subsets\nvoid union_set(std::vector<int>& parent, std::vector<int>& rank, int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n    \n    if (xroot != yroot) {\n        if (rank[xroot] < rank[yroot]) {\n            parent[xroot] = yroot;\n        } else if (rank[xroot] > rank[yroot]) {\n            parent[yroot] = xroot;\n        } else {\n            parent[yroot] = xroot;\n            rank[xroot]++;\n        }\n    }\n}\n\n// Function to calculate the maximal possible satisfaction score\nint maximalSatisfaction(std::vector<Edge>& edges, int n) {\n    // Sort edges in descending order of their weight\n    std::sort(edges.begin(), edges.end(), [](Edge a, Edge b) {\n        return a.weight > b.weight;\n    });\n    \n    std::vector<int> parent(n);\n    std::vector<int> rank(n, 0);\n\n    // Initially, every element is its own subset\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n\n    int maxSatisfaction = 0;\n\n    // Iterate over sorted edges\n    for (const auto& edge : edges) {\n        int uSet = find(parent, edge.u);\n        int vSet = find(parent, edge.v);\n\n        // If u and v belong to different sets, include this edge in the result\n        if (uSet != vSet) {\n            union_set(parent, rank, uSet, vSet);\n            maxSatisfaction += edge.weight;\n        }\n    }\n\n    return maxSatisfaction;\n}\n\nint main() {\n    int n, m;\n    std::cin >> n >> m; // n is the number of rabbits, m is the number of pairs of friendships\n\n    std::vector<Edge> edges(m);\n\n    for (int i = 0; i < m; ++i) {\n        std::cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n        edges[i].u--; // Convert to 0-based index\n        edges[i].v--; // Convert to 0-based index\n    }\n\n    std::cout << maximalSatisfaction(edges, n) << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:48"
  }
]